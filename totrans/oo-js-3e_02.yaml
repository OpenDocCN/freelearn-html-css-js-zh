- en: Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the object-oriented features of JavaScript, let''s first
    take a look at some of the basics. This chapter walks you through the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The primitive data types in JavaScript, such as strings and numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common operators, such as `+`, `-`, `delete`, and `typeof`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control statements, such as loops and `if...else` conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are used to store data; they are placeholders for concrete values.
    When writing programs, it's convenient to use variables instead of the actual
    data as it's much easier to write `pi` instead of `3.141592653589793`; especially
    when it happens several times inside your program. The data stored in a variable
    can be changed after it initially assigned, hence the name **variable**. You can
    also use variables to store data that is unknown to you while you write the code,
    such as the result of a later operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a variable requires the following two steps. You will need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize it, that is, give it a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To declare a variable, you will use the `var` statement like the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the names of the variables, you can use any combination of letters, numbers,
    the underscore character, and the dollar sign. However, you can''t start with
    a number, which means that the following declaration of code is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize a variable means to give it a value for the first (initial) time.
    The following are the two ways to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the variable first, then initialize it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare and initialize it with a single statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of the latter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now the variable named `a` contains the value `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare, and optionally initialize, several variables with a single
    `var` statement; just separate the declarations with a comma, as shown in the
    following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For readability, this is often written using one variable per line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The $ character in variable names**'
  prefs: []
  type: TYPE_NORMAL
- en: You may see the dollar sign character (`$`) used in variable names, as in `$myvar`
    or less commonly `my$var`. This character is allowed to appear anywhere in a variable
    name, although previous versions of the ECMA standard discouraged its use in handwritten
    programs and suggested it should only be used in generated code (programs written
    by other programs). This suggestion is not well respected by the JavaScript community,
    and `$` is in fact commonly used in practice as a function name.
  prefs: []
  type: TYPE_NORMAL
- en: Variables are case sensitive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variable names are case sensitive. You can easily verify this statement using
    your JavaScript console. Try typing the following code by pressing *Enter* after
    each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To save keystrokes when you enter the third line, you can type `case` and press
    the *Tab* or right arrow key. **Console** autocompletes the variable name to `case_matters`.
    Similarly, for the last line, type `CASE` and press the *Tab* key. The end result
    is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variables are case sensitive](img/image_02_001-e1482738938732.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Throughout the rest of this book, only the code for the examples is given instead
    of a screenshot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The greater-than signs (`>`) show the code that you type; the rest is the result
    as printed in **Console**. Again, remember that when you see such code examples,
    you're strongly encouraged to type in the code yourself. Then, you can experiment
    by tweaking it a little here and there to get a better feeling of how exactly
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see in the preceding screenshot that sometimes what you type in **Console**
    results in the word **undefined**. You can simply ignore this, but if you're curious,
    here's what happens when evaluating (executing) what you type-the **Console**
    prints the returned value. Some expressions, such as `var a = 1;`, don't return
    anything explicitly, in which case, they implicitly return the special value **undefined**
    (more on in a bit). When an expression returns some value (for example, `case_matters`
    in the previous example or something such as `1 + 1`), the resulting value is
    printed out. Not all consoles print the **undefined** value; for example, the
    Firebug console.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators take one or two values (or variables), perform an operation, and
    return a value. Let''s check out a simple example of using an operator, just to
    clarify the terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `+` symbol is the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operation is addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input values are `1` and `2` (they are also called operands)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result value is `3`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole thing is called an expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of using the values `1` and `2` directly in the expression, you can
    use variables. You can also use a variable to store the result of the operation
    as the following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table lists the basic arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator symbol** | **Operation** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-` | Subtraction |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `*` | Multiplication |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/` | Division |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `%` | Modulo, the remainder of a division |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s sometimes useful to test if a number is even or odd. Using the modulo
    operator, it''s easy to do just that. All odd numbers return `1` when divided
    by `2`, while all even numbers return `0`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `++` | Increment a value by `1` | Post increment is when the input value
    is incremented after it''s returned, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite is pre-increment. The input value is incremented by `1` first
    and then returned, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `--` | Decrement a value by 1 | Post-decrement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Pre-decrement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The `var a = 1;` is also an operation; it's the simple assignment operation,
    and `=` is the **simple ** **assignment ** **operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a family of operators that are a combination of an assignment
    and an arithmetic operator. These are called **compound operators**. They can
    make your code more compact. Let''s see some of them with the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `a += 3;` is just a shorter way of doing `a = a + 3;`. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `a -= 3;` is the same as `a = a - 3;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the arithmetic and assignment operators discussed previously,
    there are other types of operators, as you'll see later in this, and the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Always end your expressions with a semicolon. JavaScript has a semicolon insertion
    mechanism, where it can add the semicolon if you forget it at the end of a line.
    However, this can also be a source of errors, so it's best to make sure you always
    explicitly state where you want to terminate your expressions. In other words,
    both expressions `> 1 + 1` and `> 1 + 1;` will work; but throughout the book,
    you'll always see the second type, terminated with a semicolon, just to emphasize
    this habit.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any value that you use is of a certain type. In JavaScript, the following are
    just a few primitive data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Number**: This includes floating point numbers as well as integers. For example,
    these values are all numbers-`1`, `100`, `3`.`14`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**String**: These consist of any number of characters, for example, `a`, `one`,
    and `one 2 three`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Boolean**: This can be either `true` or `false`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Undefined**: When you try to access a variable that doesn''t exist, you get
    the special value undefined. The same happens when you declare a variable without
    assigning a value to it yet. JavaScript initializes the variable behind the scenes
    with the value `undefined`. The undefined data type can only have one value-the
    special value `undefined`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Null**: This is another special data type that can have only one value-the
    `null` value. It means no value, an empty value, or nothing. The difference with
    undefined is that if a variable has a null value, it''s still defined; it just
    so happens that its value is nothing. You''ll see some examples shortly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any value that doesn''t belong to one of the five primitive types listed here
    is an object. Even null is considered an object, which is a little awkward having
    an object (something) that is actually nothing. We''ll learn more about objects
    in [Chapter 4](ch04.html "Chapter 4. Objects"), *Objects*, but for the time being,
    just remember that in JavaScript, the data types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive (the five types listed previously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-primitive (objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out the value type - the typeof operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to know the type of a variable or a value, you can use the special
    `typeof` operator. This operator returns a string that represents the data type.
    The return values of using `typeof` are one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few sections, you'll see `typeof` in action using examples of each
    of the five primitive data types.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest number is an integer. If you assign `1` to a variable, and then
    use the `typeof` operator, it returns the string `number`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you can see that the second time you set a variable's
    value, you don't need the `var` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numbers can also be floating point (decimals), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call `typeof` directly on the value without assigning it to a variable
    first, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Octal and hexadecimal numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a number starts with a `0`, it''s considered an octal number. For example,
    the octal `0377` is the decimal `255`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The last line in the preceding example prints the decimal representation of
    the octal value.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 provides a prefix `0o` (or `0O`, but this looks very confusing in most
    monospace fonts) to represent octals. Consider the following line of code for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: While you may not be intimately familiar with octal numbers, you've probably
    used hexadecimal values to define colors in CSS stylesheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In CSS, you have several options to define a color, two of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using decimal values to specify the amount of R (red), G (green), and B (blue),
    ranging from `0` to `255`. For example, *rgb(0, 0, 0)* is black and *rgb(255,
    0, 0)* is red (maximum amount of red and no green or blue).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using hexadecimals and specifying two characters for each R, G, and B value.
    For example, *#000000* is black and *#ff0000* is red. This is because *ff* is
    the hexadecimal value for `255`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In JavaScript, you can put `0x` before a hexadecimal value, also called hex
    for short, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Binary Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Untill ES6, if you needed binary representation of an integer, you had to pass
    them to the `parseInt()` function as a string with a radix of `2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6 you can use `0b` (or `0B`) prefix to represent binary integers. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Exponent literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`1e1` (also written as `1e+1` or `1E1` or `1E+1`) represents the number 1 with
    a 0 after it, or in other words, `10`. Similarly, `2e+3` represents the number
    2 with three 0s after it, or `2000`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`2e+3` means moving the decimal point three digits to the right of the number
    **2**. There''s also `2e-3`, meaning you move the decimal point three digits to
    the left of the number **2**. Look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exponent literals](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Infinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a special value in JavaScript called Infinity. It represents a number
    too big for JavaScript to handle. Infinity is indeed a number, as typing `typeof
    Infinity` in the console will confirm. You can also quickly check that a number
    with `308` zeros is ok, but `309` zeros is too much. To be precise, the biggest
    number JavaScript can handle is `1.7976931348623157e+308`, while the smallest
    is `5e-324`, Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Dividing by zero gives you infinity, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`Infinity` is the biggest number (or rather a little bigger than the biggest),
    but how about the smallest? It''s infinity with a minus sign in front of it; `-Infinity`,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this mean you can have something that''s exactly twice as big as Infinity,
    from 0 up to infinity and then from 0 down to minus infinity? Well, not really.
    When you sum `Infinity` and `-Infinity`, you don''t get `0`, but something that
    is called **Not a Number** (**NaN**), For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Any other arithmetic operation with `Infinity` as one of the operands gives
    you `Infinity`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There is a lesser known global method, `isFinite()`, that tells you if the value
    is infinity or not. ES6 adds a `Number.isFinite()`method to do just that. Why
    another method, you may ask. The global variant of `isFinite()` tries to cast
    the value through Number(value), while `Number.isFinite()` doesn't, hence it's
    more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: NaN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What was this `NaN` in the previous example? It turns out that despite its
    name, Not a Number, `NaN` is a special value that is also a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You get `NaN` when you try to perform an operation that assumes numbers, but
    the operation fails. For example, if you try to multiply `10` by the character
    `"f"`, the result is `NaN`, because `"f"` is obviously not a valid operand for
    a multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN` is contagious, so if you have even one `NaN` in your arithmetic operation,
    the whole result goes down the drain, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Number.isNaN
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ES5 has a global method-`isNaN()`. It determines if a value is `NaN` or not.
    ES6 provides a very similar method-`Number.isNaN()` (Notice that this method is
    not global).
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between the global `isNaN()` and `Number.isNaN()` is that global
    `isNaN()` casts non-numeric values before evaluating them to be `NaN`. Let''s
    look at the following example. We are using the ES6 `Number.isNaN()` method to
    test if something is a `NaN` or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw that ES5''s global `isNaN()` method first casts non-numeric values and
    then does the comparison; the following result will be different from its ES6
    counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, compared to its global variant, `Number.isNaN()` is more correct.
    However, neither of them can be used to figure out if something is not a number-they
    just answer if the value is a `NaN` or not. Practically, you are interested in
    knowing if a value identifies as a number or not. Mozilla suggests the following
    polyfill method to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Number.isInteger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is a new method in ES6\. It returns `true` if the number is finite and
    does not contain any decimal points (is an integer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A string is a sequence of characters used to represent text. In JavaScript,
    any value placed between single or double quotes is considered a string. This
    means that `1` is a number, but `"1"` is a string. When used with strings, `typeof`
    returns the string `"string"`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of a number used in the string context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put nothing in quotes, it''s still a string (an empty string), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you already know, when you use the plus sign with two numbers, this is the
    arithmetic addition operation. However, if you use the plus sign with strings,
    this is a string concatenation operation, and it returns the two strings glued
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The dual purpose of the `+` operator is a source of errors. Therefore, if you
    intend to concatenate strings, it's always best to make sure that all of the operands
    are strings. The same applies for addition; if you intend to add numbers then
    make sure the operands are numbers. You'll learn various ways to do so further
    in the chapter and the book.
  prefs: []
  type: TYPE_NORMAL
- en: String conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use a number-like string, for example, `"1"`, as an operand in an
    arithmetic operation, the string is converted to a number behind the scenes. This
    works for all arithmetic operations except addition, because of its ambiguity.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A lazy way to convert any number-like string to a number is to multiply it
    by `1` (another way is to use a function called `parseInt()`, as you''ll see in
    the next chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If the conversion fails, you''ll get `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert a string to a number by multiplying it by `1`. The opposite-converting
    anything to a string-can be done by concatenating it with an empty string, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Special strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are also strings with special meanings, as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **String** | **Meaning** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `\\``''``"` | The `\` is the escape character. When you want to have quotes
    inside your string, you can escape them so that JavaScript doesn''t think they
    mean the end of the string.If you want to have an actual backslash in the string,
    escape it with another backslash. | `> var s = ''I don''t know'';`: This is an
    error because JavaScript thinks the string is `I don` and the rest is invalid
    code. The following codes are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `\n` | End of line. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `\r` | Carriage return. | Consider the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of all of these is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `\t` | Tab. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `\u` | The `\u` followed by a character code allows you to use Unicode. |
    Here''s my name in Bulgarian written with Cyrillic characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also additional characters that are rarely used: `\b` (backspace),
    `\v` (vertical tab), and `\f` (form feed).'
  prefs: []
  type: TYPE_NORMAL
- en: String template literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 introduced template literals. If you are familiar with other programming
    languages, Perl and Python have supported template literals for a while now. Template
    literals allow expressions to be embedded within regular strings. ES6 has two
    kinds of literals: template literals and tagged literals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Template literals are single or multiple line strings with embedded expressions.
    For example, you must have done something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can accomplish the same using template literals, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Template literals are enclosed by the back-tick ([PRE60]) (grave accent) character
    instead of the usual double or single quotes. Template literal place holders are
    indicated by the dollar sign and curly braces (`${expression}`). By default, they
    are concatenated to form a single string. The following example shows a template
    literal with a slightly complex expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How about embedding a function call?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Template literals also simplify multiline string syntax. Instead of writing
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have a much cleaner syntax using template literals, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'ES6 has another interesting literal type called **Tagged Template Literals**.
    Tagged templates allow you to modify the output of template literals using a function.
    If you prefix an expression to a template literal, that prefix is considered to
    be a function to be invoked. The function needs to be defined before we can use
    the tagged template literal. For example, the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression is converted into a function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The tag function, ''transform'', gets two parameters-template strings like
    `Name is` and substitutions defined by `${}`. The substitutions are only known
    at runtime. Let''s expand the `transform` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When template strings (`Name is`) are passed to the tag function, there are
    two forms of each template string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The raw form where the backslashes are not interpreted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cooked form where the backslashes has special meaning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the raw string form using raw property, as the following example
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only two values that belong to the Boolean data type-the `true` and
    `false` values used without quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you quote `true` or `false`, they become strings, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three operators, called logical operators, that work with Boolean
    values. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You know that when something is not true, it must be false. Here''s how this
    is expressed using JavaScript and the logical `!` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the logical `NOT` twice, you will get the original value, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use a logical operator on a non-Boolean value, the value is converted
    to Boolean behind the scenes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding case, the string value `"one"` is converted to a Boolean,
    `true`, and then negated. The result of negating `true` is `false`. In the following
    example, there''s a double negation, so the result is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert any value to its Boolean equivalent using a double negation.
    Understanding how any value converts to a Boolean is important. Most values convert
    to `true` with the exception of the following, which convert to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: The empty string `""`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `NaN`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Boolean `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These six values are referred to as falsy, while all others are truthy, (including,
    for example, the strings `"0"`, `" "`, and `"false"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some examples of the other two operators-the logical `AND` (`&&`)
    and the logical `OR` (`||`). When you use `&&`, the result is `true` only if all
    of the operands are `true`. When you use `||`, the result is `true` if at least
    one of the operands is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a list of the possible operations and their results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| `true && true` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `true && false` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `false && true` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `false && false` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `true &#124;&#124; true` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `true &#124;&#124; false` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `false &#124;&#124; true` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `false &#124;&#124; false` | `false` |'
  prefs: []
  type: TYPE_TB
- en: 'You can use several logical operations one after the other, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mix `&&` and `||` in the same expression. In such cases, you should
    use parentheses to clarify how you intend the operation to work. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Operator precedence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might wonder why the previous expression (`false && false || true && true`)
    returned `true`. The answer lies in the operator precedence, as you know from
    mathematics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because multiplication has a higher precedence over addition, so `2
    * 3` is evaluated first, as if you typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly for logical operations, `!` has the highest precedence and is executed
    first, assuming there are no parentheses that demand otherwise. Then, in the order
    of precedence, comes `&&` and finally, `||`. In other words, the following two
    code snippets are the same. The first one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Use parentheses instead of relying on operator precedence. This makes your code
    easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: The ECMAScript standard defines the precedence of operators. While it may be
    a good memorization exercise, this book doesn't offer it. First of all, you'll
    forget it, and second, even if you manage to remember it, you shouldn't rely on
    it. The person reading and maintaining your code will likely be confused.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have several logical operations one after the other, but the result
    becomes clear at some point before the end, the final operations will not be performed
    because they don''t affect the end result. Consider the following line of code
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'As these are all `OR` operations and have the same precedence, the result will
    be `true` if at least, one of the operands is `true`. After the first operand
    is evaluated, it becomes clear that the result will be `true`, no matter what
    values follow. So, the JavaScript engine decides to be lazy (OK, efficient) and
    avoids unnecessary work by evaluating code that doesn''t affect the end result.
    You can verify this short-circuiting behavior by experimenting in the console,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This example also shows another interesting behavior-if JavaScript encounters
    a non-Boolean expression as an operand in a logical operation, the non-Boolean
    is returned as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior is not something you should rely on because it makes the code
    harder to understand. It''s common to use this behavior to define variables when
    you''re not sure whether they were previously defined. In the next example, if
    the `mynumber` variable is defined, its value is kept; otherwise, it''s initialized
    with the value `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simple and looks elegant, but be aware that it''s not completely foolproof.
    If `mynumber` is defined and initialized to `0`, or to any of the six falsy values,
    this code might not behave as you expect, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There''s another set of operators that all return a Boolean value as a result
    of the operation. These are the comparison operators. The following table lists
    them together with example uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator symbol** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | **Equality comparison**: This returns `true` when both operands are
    equal. The operands are converted to the same type before being compared. They''re
    also called loose comparison. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `===` | **Equality and type comparison**: This returns `true` if both operands
    are equal and of the same type. It''s better and safer to compare this way because
    there''s no behind-the-scenes type conversions. It is also called strict comparison.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `!=` | **Non-equality comparison**: This returns `true` if the operands are
    not equal to each other (after a type conversion). |'
  prefs: []
  type: TYPE_TB
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `!==` | **Non-equality comparison without type conversion**: Returns `true`
    if the operands are not equal or if they are of different types. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `>` | This returns `true` if the left operand is greater than the right one.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `>=` | This returns `true` if the left operand is greater than or equal to
    the right one. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `<` | This returns `true` if the left operand is less than the right one.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `<=` | This returns `true` if the left operand is less than or equal to the
    right one. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `NaN` is not equal to anything, not even itself. Take a look at the
    following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Undefined and null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you try to use a non-existing variable, you''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `typeof` operator on a non-existing variable is not an error. You
    will get the `"undefined"` string back, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'If you declare a variable without giving it a value, this is, of course, not
    an error. But, the `typeof` still returns `"undefined"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because, when you declare a variable without initializing it, JavaScript
    automatically initializes it with the `undefined` value, as shown in the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The `null` value, on the other hand, is not assigned by JavaScript behind the
    scenes; it''s assigned by your code, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the difference between `null` and `undefined` is small, it can be
    critical at times. For example, if you attempt an arithmetic operation, you will
    get different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because of the different ways `null` and `undefined` are converted
    to the other primitive types. The following examples show the possible conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversion to a number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Conversion to NaN:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Conversion to a Boolean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Conversion to a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 introduced a new primitive type-symbols. Several languages have a similar
    notion. Symbols look very similar to regular strings, but they are very different.
    Let''s see how these symbols are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we don''t use `new` operator while creating symbols. You will get
    an error when you do use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'You can describe `Symbol` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Describing symbols comes in very handy while debugging large programs where
    there are lots of symbols scattered across.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important property of `Symbol` (and hence the reason of their existence)
    is that they are unique and immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: For now, we will have to pause this discussion on symbols. Symbols are used
    as property keys and places where you need unique identifiers. We will discuss
    symbols in a later part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly summarize some of the main points discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five primitive data types in JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything that is not a primitive data type is an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primitive number data type can store positive and negative integers or floats,
    hexadecimal numbers, octal numbers, exponents, and the special numbers-`NaN`,
    `Infinity`, and `-Infinity`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The string data type contains characters in quotes. Template literals allow
    embedding of expressions inside a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only values of the Boolean data type are `true` and `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only value of the null data type is the `null` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only value of the undefined data type is the `undefined` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All values become `true` when converted to a Boolean, with the exception of
    the following six falsy values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaN`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know about the basic primitive data types in JavaScript, it's time
    to move to a more powerful data structure-the array.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is an array? It's simply a list (a sequence) of values. Instead of
    using one variable to store one value, you can use one array variable to store
    any number of values as elements of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a variable that contains an empty array, you can use square brackets
    with nothing between them, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'To define an array that has three elements, you can write the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'When you simply type the name of the array in the console, you can get the
    contents of your array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the question is how to access the values stored in these array elements.
    The elements contained in an array are indexed with consecutive numbers, starting
    from zero. The first element has index (or position) 0, the second has index 1,
    and so on. Here''s the three-element array from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: 'To access an array element, you can specify the index of that element inside
    square brackets. So, `a[0]` gives you the first element of the array `a`, `a[1]`
    gives you the second, and so on, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Adding/updating array elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the index, you can also update the values of the elements of the array.
    The next example updates the third element (index 2) and prints the contents of
    the new array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add more elements by addressing an index that didn''t exist before,
    as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add a new element but leave a gap in the array, those elements in between
    don''t exist and return the `undefined` value if accessed. Check out the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Deleting elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete an element, you can use the `delete` operator. However, after the
    deletion, the length of the array does not change. In a sense, you may get a hole
    in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Arrays of arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays can contain all types of values, including other arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Array[3]` in the result is clickable in the console and it expands the
    array values. Let''s look at an example where you have an array of two elements,
    both of them being other arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of the array is `[0]`, and it''s also an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element in the nested array, you can refer to the element index
    in another set of square brackets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can use the array notation to access individual characters inside
    a string, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Array access to strings was supported by many browsers for a while (not older
    IEs), but it was officially recognized only as late as ECMAScript 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more ways to have fun with arrays (and we get to those in [Chapter
    4](ch04.html "Chapter 4. Objects"), *Objects*), but let''s stop here for now,
    remembering the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: An array is a data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array contains indexed elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes start from zero and increment by one for each element in the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access an element of an array, you can use its index in square brackets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array can contain any type of data, including other arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions and loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditions provide a simple but powerful way to control the flow of code execution.
    Loops allow you to perform repetitive operations with less code. Let''s take a
    look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`, `do...while`, `for`, and `for...in` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples in the following sections require you to switch to the multiline
    Firebug console. Or, if you use the WebKit console, press *Shift* + *Enter* instead
    of *Enter* to add a new line.
  prefs: []
  type: TYPE_NORMAL
- en: Code blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding examples, you saw the use of code blocks. Let's take a moment
    to clarify what a block of code is, because you will use blocks extensively when
    constructing conditions and loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'A block of code consists of zero or more expressions enclosed in curly brackets,
    which is shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'You can nest blocks within each other indefinitely, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice tips**'
  prefs: []
  type: TYPE_NORMAL
- en: Use end-of-line semicolons, as discussed previously in the chapter. Although
    the semicolon is optional when you have only one expression per line, it's good
    to develop the habit of using them. For best readability, the individual expressions
    inside a block should be placed one per line and separated by semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Indent any code placed within curly brackets. Some programmers like one tab
    indentation, some use four spaces, and some use two spaces. It really doesn't
    matter, as long as you're consistent. In the preceding example, the outer block
    is indented with two spaces, the code in the first nested block is indented with
    four spaces, and the innermost block is indented with six spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Use curly brackets. When a block consists of only one expression, the curly
    brackets are optional, but for readability and maintainability, you should get
    into the habit of always using them, even when they're optional.
  prefs: []
  type: TYPE_NORMAL
- en: The if condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a simple example of an `if` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The parts of the `if` condition are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A condition in parentheses-`is a greater than 2`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A block of code wrapped in `{}` that executes if the condition is satisfied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The condition (the part in parentheses) always returns a Boolean value, and
    may also contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A logical operation-`!`, `&&`, or `||`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comparison, such as `===`, `!=`, `>`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any value or variable that can be converted to a Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of the above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The else clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There can also be an optional else part of the `if` condition. The `else` statement
    is followed by a block of code that runs if the condition evaluates to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'In between the `if` and the `else` statements, there can also be an unlimited
    number of `else...if` conditions. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also nest conditions by putting new conditions within any of the blocks,
    as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Checking if a variable exists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s apply the new knowledge about conditions for something practical. It''s
    often necessary to check whether a variable exists. The laziest way to do this
    is to simply put the variable in the condition part of the `if` statement, for
    example, `if (somevar) {...}`. But, this is not necessarily the best method. Let''s
    take a look at an example that tests whether a variable called `somevar` exists,
    and if so, sets the `result` variable to `yes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This code obviously works because the end result was not `yes`. But firstly,
    the code generated an error-`somevar` is not defined, and you don't want your
    code to behave like that. Secondly, just because `if (somevar)` returns `false`,
    it doesn't mean that `somevar` is not defined. It could be that `somevar` is defined
    and initialized but contains a falsy value like `false` or `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to check if a variable is defined is to use `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeof` operator always returns a string, and you can compare this string
    with the string `"undefined"`. Note that the `somevar` variable may have been
    declared but not assigned a value yet and you''ll still get the same result. So,
    when testing with `typeof` like this, you''re really testing whether the variable
    has any value other than the `undefined` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'If a variable is defined and initialized with any value other than `undefined`,
    its type returned by `typeof` is no longer `"undefined"`, as shown in the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Alternative if syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you have a simple condition, you can consider using an alternative `if`
    syntax. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also write this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: You should only use this syntax for simple conditions. Be careful not to abuse
    it, as it can easily make your code unreadable. Here's an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to make sure a number is within a certain range, say between
    `50` and `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'It may not be clear how this code works exactly because of the multiple ?.
    Adding parentheses makes it a little clearer, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '`?:` is called a ternary operator because it takes three operands.'
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you find yourself using an `if` condition and having too many `else...if`
    parts, you can consider changing the `if` to a `switch`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The result after executing this is `"String 1"`. Let''s see what the parts
    of a `switch` are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression in parentheses. The expression most often contains a variable,
    but can be anything that returns a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of `case` blocks enclosed in curly brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `case` statement is followed by an expression. The result of the expression
    is compared to the expression found after the `switch` statement. If the result
    of the comparison is `true`, the code that follows the colon after the `case`
    is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an optional `break` statement to signal the end of the `case` block.
    If this `break` statement is reached, the `switch` statement is all done. Otherwise,
    if the `break` is missing, the program execution enters the next `case` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's an optional default case marked with the `default` statement and followed
    by a block of code. The `default` case is executed if none of the previous cases
    evaluated to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, the step-by-step procedure to execute a `switch` statement
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the `switch` expression found in parentheses; remember it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the first case and compare its value with the one from Step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the comparison in Step 2 returns `true`, execute the code in the `case` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `case` block is executed, if there's a `break` statement at the end
    of it, exit `switch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there's no `break` or Step 2 returned `false`, move on to the next `case`
    block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 to 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are still here (no exit in Step 4), execute the code following the `default`
    statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Indent the code that follows the case lines. You can also indent case from the
    switch, but that doesn't give you much in terms of readability.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to break
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes, you may want to omit the break intentionally, but that's rare. It's
    called a fall-through and should always be documented because it may look like
    an accidental omission. On the other hand, sometimes you may want to omit the
    whole code block following a case and have two cases sharing the same code. This
    is fine, but it doesn't change the rule that if there's code that follows a case
    statement, this code should end with a break. In terms of indentation, aligning
    the break with the case or with the code inside the case is a personal preference;
    again, being consistent is what matters.
  prefs: []
  type: TYPE_NORMAL
- en: Use the default case. This helps you make sure that you always have a meaningful
    result after the switch statement, even if none of the cases matches the value
    being switched.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `if...else` and `switch` statements allow your code to take different paths,
    as if you're at a crossroad, and decide which way to go depending on a condition.
    Loops, on the other hand, allow your code to take a few roundabouts before merging
    back into the main road. How many repetitions? That depends on the result of evaluating
    a condition before (or after) each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you are (your program execution is) traveling from **A** to **B**.
    At some point, you will reach a place where you have to evaluate a condition,
    **C**. The result of evaluating **C** tells you whether you should go into a loop,
    **L**. You make one iteration and arrive at **C** again. Then, you evaluate the
    condition once again to see if another iteration is needed. Eventually, you move
    on your way to **B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loops](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An infinite loop is when the condition is always `true`, and your code gets
    stuck in the loop forever. This is, of course, a logical error, and you should
    look out for such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, the following are the four types of loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do-while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for-in` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loops are the simplest type of iteration. They look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The `while` statement is followed by a condition in parentheses and a code block
    in curly brackets. As long as the condition evaluates to `true`, the code block
    is executed over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Do-while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `do...while` loops are a slight variation of `while` loops. An example
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `do` statement is followed by a code block and a condition after the
    block. This means that the code block is always executed, at least once, before
    the condition is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: If you initialize `i` to `11` instead of `0` in the last two examples, the code
    block in the first example (the `while` loop) will not be executed, and `i` will
    still be `11` at the end, while in the second (the `do...while` loop), the code
    block will be executed once and `i` will become `12`.
  prefs: []
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` loop is the most widely used type of loop, and you should make sure
    you''re comfortable with this one. It requires just a little bit more in terms
    of syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![For loops](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the **C** condition and the **L** code block, you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: This is the code that is executed before you even enter
    the loop (marked with **0** in the diagram)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increment**: This is the code that is executed after every iteration (marked
    with **++** in the diagram)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the most widely used `for` loop pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: In the initialization part, you can define a variable (or set the initial value
    of an existing variable), most often called `i`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the condition part, you can compare `i` to a boundary value, such as `i <
    100`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the increment part, you can increase `i` by `1`, such as `i++`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'All three parts (initialization, condition, and increment) can contain multiple
    expressions separated by commas. Say you want to rewrite the example and define
    the variable `punishment` inside the initialization part of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you move the body of the loop inside the increment part? Yes, you can,
    especially as it''s a one-liner. This gives you a loop that looks a little awkward,
    as it has no body. Note that this is just an intellectual exercise; it''s not
    recommended that you write awkward-looking code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'These three parts are all optional. Here''s another way of rewriting the same
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Although the last rewrite works exactly the same way as the original, it's longer
    and harder to read. It's also possible to achieve the same result using a `while`
    loop. But, the `for` loops make the code tighter and more robust because the mere
    syntax of the `for` loop makes you think about the three parts (initialization,
    condition, and increment), and thus helps you reconfirm your logic and avoid situations
    such as being stuck in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loops can be nested within each other. Here''s an example of a loop
    that is nested inside another loop and assembles a string containing ten rows
    and ten columns of asterisks. Think of `i` being the row and `j` being the column
    of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a string, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another example that uses nested loops and a modulo operation to draw
    a snowflake-like result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: For...in loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `for...in` loop is used to iterate over the elements of an array, or an
    object, as you'll see later. This is its only use; it cannot be used as a general-purpose
    repetition mechanism to replace `for` or `while`. Let's see an example of using
    a `for-in` to loop through the elements of an array. But, bear in mind that this
    is for informational purposes only, as `for...in` is mostly suitable for objects
    and the regular `for` loop should be used for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you can iterate over all of the elements of an array and print
    out the index (the key) and the value of each element, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last thing for this chapter-comments. Inside your JavaScript program, you
    can put comments. These are ignored by the JavaScript engine and don't have any
    effect on how the program works. But they can be invaluable when you revisit your
    code after a few months, or transfer the code to someone else for maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two types of comments are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: Single line comments start with `//` and end at the end of the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline comments start with `/*` and end with `*/` on the same line or any
    subsequent line. Note that any code in between the comment start and the comment
    end is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: There are even utilities, such as JSDoc and YUIDoc, that can parse your code
    and extract meaningful documentation based on your comments.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the result of executing each of these lines in the console? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the value of v after the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Experiment by first setting `v` to `100`, `0`, or `null`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a small program that prints out the multiplication table. Hint: use a
    loop nested inside another loop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned a lot about the basic building blocks of a JavaScript
    program. Now you know the following primitive data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You also know quite a few operators, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic operators**: `+`, `-`, `*`, `/`, and `%`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increment operators**: `++` and `-`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assignment operators**: `=`, `+=`, `-=`, `*=`, `/=`, and `%=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Special operators**: `typeof` and `delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical operators**: `&&`, `||`, and `!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparison operators**: `==`, `===`, `!=`, `!==`, `<`, `>`, `>=`, and `<=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The ternary operator**: `?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then you learned how to use arrays to store and access data, and finally you
    saw different ways to control the flow of your program using conditions (`if...else`
    or `switch`) and loops (`while`, `do...while`, `for`, and `for...in`).
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a bit of information; give yourself a well-deserved pat on the
    back before diving into the next chapter. More fun is coming up!
  prefs: []
  type: TYPE_NORMAL
