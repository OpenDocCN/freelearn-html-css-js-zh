- en: Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：原始数据类型、数组、循环和条件
- en: 'Before diving into the object-oriented features of JavaScript, let''s first
    take a look at some of the basics. This chapter walks you through the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨JavaScript面向对象特性之前，让我们先看看一些基础知识。本章将带你了解以下主题：
- en: The primitive data types in JavaScript, such as strings and numbers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的原始数据类型，例如字符串和数字
- en: Arrays
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Common operators, such as `+`, `-`, `delete`, and `typeof`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见运算符，例如`+`、`-`、`delete`和`typeof`
- en: Flow control statements, such as loops and `if...else` conditions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程控制语句，例如循环和`if...else`条件
- en: Variables
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Variables are used to store data; they are placeholders for concrete values.
    When writing programs, it's convenient to use variables instead of the actual
    data as it's much easier to write `pi` instead of `3.141592653589793`; especially
    when it happens several times inside your program. The data stored in a variable
    can be changed after it initially assigned, hence the name **variable**. You can
    also use variables to store data that is unknown to you while you write the code,
    such as the result of a later operation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 变量用于存储数据；它们是具体值的占位符。在编写程序时，使用变量而不是实际数据更方便，例如，用`pi`代替`3.141592653589793`要容易得多；尤其是在程序内部多次出现时。变量中存储的数据在最初赋值后可以更改，因此得名**变量**。你还可以使用变量来存储你在编写代码时不知道的数据，例如后续操作的結果。
- en: 'Using a variable requires the following two steps. You will need to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量需要以下两个步骤。你需要：
- en: Declare the variable
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明变量
- en: Initialize it, that is, give it a value
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化它，即给它赋值
- en: 'To declare a variable, you will use the `var` statement like the following
    piece of code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个变量，你将使用类似于以下代码片段的`var`语句：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the names of the variables, you can use any combination of letters, numbers,
    the underscore character, and the dollar sign. However, you can''t start with
    a number, which means that the following declaration of code is invalid:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变量的命名，你可以使用字母、数字、下划线字符和美元符号的任意组合。然而，变量不能以数字开头，这意味着以下代码声明是无效的：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To initialize a variable means to give it a value for the first (initial) time.
    The following are the two ways to do so:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量意味着给它第一次（初始）赋值。以下有两种这样做的方式：
- en: Declare the variable first, then initialize it
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先声明变量，然后初始化它
- en: Declare and initialize it with a single statement
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个语句声明并初始化它
- en: 'An example of the latter is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的一个例子如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now the variable named `a` contains the value `1`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在名为`a`的变量包含值`1`。
- en: 'You can declare, and optionally initialize, several variables with a single
    `var` statement; just separate the declarations with a comma, as shown in the
    following line of code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单个`var`语句声明并可选地初始化多个变量；只需用逗号分隔声明，如下面的代码行所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For readability, this is often written using one variable per line, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，通常使用每行一个变量的方式来编写，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The $ character in variable names**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量名中的$字符**'
- en: You may see the dollar sign character (`$`) used in variable names, as in `$myvar`
    or less commonly `my$var`. This character is allowed to appear anywhere in a variable
    name, although previous versions of the ECMA standard discouraged its use in handwritten
    programs and suggested it should only be used in generated code (programs written
    by other programs). This suggestion is not well respected by the JavaScript community,
    and `$` is in fact commonly used in practice as a function name.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在变量名中看到美元符号字符（`$`），例如`$myvar`或较少见的`my$var`。这个字符可以在变量名中的任何位置出现，尽管ECMA标准的早期版本不建议在手工编写的程序中使用它，并建议它只应在由其他程序编写的代码（生成代码）中使用。这个建议并没有得到JavaScript社区的广泛尊重，实际上`$`在实践中被广泛用作函数名。
- en: Variables are case sensitive
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的
- en: 'Variable names are case sensitive. You can easily verify this statement using
    your JavaScript console. Try typing the following code by pressing *Enter* after
    each line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的。你可以通过使用JavaScript控制台轻松验证此声明。尝试在每行后按*Enter*键输入以下代码：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To save keystrokes when you enter the third line, you can type `case` and press
    the *Tab* or right arrow key. **Console** autocompletes the variable name to `case_matters`.
    Similarly, for the last line, type `CASE` and press the *Tab* key. The end result
    is shown in the following figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在输入第三行时节省按键，你可以输入`case`并按*Tab*键或右箭头键。**控制台**会自动补全变量名为`case_matters`。同样，对于最后一行，输入`CASE`并按*Tab*键。最终结果如下所示：
- en: '![Variables are case sensitive](img/image_02_001-e1482738938732.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![变量区分大小写](img/image_02_001-e1482738938732.jpg)'
- en: 'Throughout the rest of this book, only the code for the examples is given instead
    of a screenshot, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，只给出了示例代码，而不是截图，如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The greater-than signs (`>`) show the code that you type; the rest is the result
    as printed in **Console**. Again, remember that when you see such code examples,
    you're strongly encouraged to type in the code yourself. Then, you can experiment
    by tweaking it a little here and there to get a better feeling of how exactly
    it works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大于号（`>`）显示你输入的代码；其余的是在**控制台**中打印的结果。再次提醒，当你看到这样的代码示例时，强烈建议你自己输入代码。然后，你可以通过稍作调整来实验，以更好地了解它的工作原理。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can see in the preceding screenshot that sometimes what you type in **Console**
    results in the word **undefined**. You can simply ignore this, but if you're curious,
    here's what happens when evaluating (executing) what you type-the **Console**
    prints the returned value. Some expressions, such as `var a = 1;`, don't return
    anything explicitly, in which case, they implicitly return the special value **undefined**
    (more on in a bit). When an expression returns some value (for example, `case_matters`
    in the previous example or something such as `1 + 1`), the resulting value is
    printed out. Not all consoles print the **undefined** value; for example, the
    Firebug console.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的截图看到，有时你在**控制台**中输入的内容会导致出现**未定义**这个词。你可以简单地忽略它，但如果你想知道，这里是你输入（执行）的内容时会发生什么——**控制台**会打印出返回的值。有些表达式，例如`var
    a = 1;`，不会明确返回任何内容，在这种情况下，它们隐式地返回特殊值**未定义**（稍后会有更多介绍）。当一个表达式返回某个值（例如，前一个例子中的`case_matters`或`1
    + 1`）时，该值会被打印出来。并非所有控制台都会打印**未定义**值；例如，Firebug控制台。
- en: Operators
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Operators take one or two values (or variables), perform an operation, and
    return a value. Let''s check out a simple example of using an operator, just to
    clarify the terminology:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符接受一个或两个值（或变量），执行一个操作，并返回一个值。让我们通过一个简单的例子来看看如何使用运算符，以便澄清术语：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中：
- en: The `+` symbol is the operator
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`符号是运算符'
- en: The operation is addition
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作是加法
- en: The input values are `1` and `2` (they are also called operands)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入值是`1`和`2`（它们也被称为操作数）
- en: The result value is `3`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果值是`3`
- en: The whole thing is called an expression
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个东西被称为表达式
- en: 'Instead of using the values `1` and `2` directly in the expression, you can
    use variables. You can also use a variable to store the result of the operation
    as the following example demonstrates:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式中直接使用`1`和`2`的值，你可以使用变量。你还可以使用变量来存储操作的结果，如下面的例子所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following table lists the basic arithmetic operators:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了基本的算术运算符：
- en: '| **Operator symbol** | **Operation** | **Example** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **运算符符号** | **操作** | **示例** |'
- en: '| `+` | Addition |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 |'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `-` | Subtraction |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法 |'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '| `=` | 赋值运算符 |'
- en: '| `*` | Multiplication |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 |'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/` | Division |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 |'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `%` | Modulo, the remainder of a division |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模，除法的余数 |'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s sometimes useful to test if a number is even or odd. Using the modulo
    operator, it''s easy to do just that. All odd numbers return `1` when divided
    by `2`, while all even numbers return `0`, for example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候测试一个数字是偶数还是奇数是有用的。使用取模运算符，这样做很容易。所有奇数除以`2`时都返回`1`，而所有偶数都返回`0`，例如：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `++` | Increment a value by `1` | Post increment is when the input value
    is incremented after it''s returned, for example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '| `++` | 将值增加`1` | 后增量是在返回输入值之后增加输入值，例如：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The opposite is pre-increment. The input value is incremented by `1` first
    and then returned, for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 预增量的相反是后增量。输入值首先增加`1`，然后返回，例如：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `--` | Decrement a value by 1 | Post-decrement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '| `--` | 将值减`1` | 后减量：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Pre-decrement:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 预减量：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The `var a = 1;` is also an operation; it's the simple assignment operation,
    and `=` is the **simple ** **assignment ** **operator**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`var a = 1;`也是一个操作；它是简单的赋值操作，`=`是**简单** **赋值** **运算符**。'
- en: 'There is also a family of operators that are a combination of an assignment
    and an arithmetic operator. These are called **compound operators**. They can
    make your code more compact. Let''s see some of them with the following examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一系列运算符，它们是赋值运算符和算术运算符的组合。这些被称为**复合运算符**。它们可以使你的代码更加紧凑。让我们通过以下示例来看看其中的一些：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, `a += 3;` is just a shorter way of doing `a = a + 3;`. For
    example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a += 3;` 只是一种更简短的方式来执行 `a = a + 3;`。例如：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, `a -= 3;` is the same as `a = a - 3;`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`a -= 3;` 与 `a = a - 3;` 相同：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In addition to the arithmetic and assignment operators discussed previously,
    there are other types of operators, as you'll see later in this, and the following
    chapters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的算术和赋值运算符之外，还有其他类型的运算符，你将在后面的章节中看到。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Best practice**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Always end your expressions with a semicolon. JavaScript has a semicolon insertion
    mechanism, where it can add the semicolon if you forget it at the end of a line.
    However, this can also be a source of errors, so it's best to make sure you always
    explicitly state where you want to terminate your expressions. In other words,
    both expressions `> 1 + 1` and `> 1 + 1;` will work; but throughout the book,
    you'll always see the second type, terminated with a semicolon, just to emphasize
    this habit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总是以分号结束你的表达式。JavaScript 有一个分号插入机制，它可以在你忘记在行尾添加分号时添加它。然而，这也可能成为错误的一个来源，所以最好确保你总是明确地指出你想要在哪里结束你的表达式。换句话说，表达式
    `> 1 + 1` 和 `> 1 + 1;` 都可以工作；但在这本书中，你将始终看到第二种类型，以分号结束，只是为了强调这个习惯。
- en: Primitive data types
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: 'Any value that you use is of a certain type. In JavaScript, the following are
    just a few primitive data types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的任何值都是某种类型。在 JavaScript 中，以下只是一些原始数据类型：
- en: '**Number**: This includes floating point numbers as well as integers. For example,
    these values are all numbers-`1`, `100`, `3`.`14`.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数字**：这包括浮点数和整数。例如，这些值都是数字 - `1`，`100`，`3`.`14`。'
- en: '**String**: These consist of any number of characters, for example, `a`, `one`,
    and `one 2 three`.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符串**：这些由任意数量的字符组成，例如，`a`，`one`，和 `one 2 three`。'
- en: '**Boolean**: This can be either `true` or `false`.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布尔值**：这可以是 `true` 或 `false`。'
- en: '**Undefined**: When you try to access a variable that doesn''t exist, you get
    the special value undefined. The same happens when you declare a variable without
    assigning a value to it yet. JavaScript initializes the variable behind the scenes
    with the value `undefined`. The undefined data type can only have one value-the
    special value `undefined`.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未定义**：当你尝试访问一个不存在的变量时，你会得到特殊的值 `undefined`。同样，当你声明一个变量但尚未为其分配值时，也会发生这种情况。JavaScript
    在幕后将变量的值初始化为 `undefined`。未定义数据类型只能有一个值 - 特殊值 `undefined`。'
- en: '**Null**: This is another special data type that can have only one value-the
    `null` value. It means no value, an empty value, or nothing. The difference with
    undefined is that if a variable has a null value, it''s still defined; it just
    so happens that its value is nothing. You''ll see some examples shortly.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**空值**：这是另一种只能有一个值 - `null` 值的特殊数据类型。它表示没有值，空值或无。与 `undefined` 的区别在于，如果一个变量有
    `null` 值，它仍然是已定义的；只是恰好它的值是空的。你很快就会看到一些例子。'
- en: 'Any value that doesn''t belong to one of the five primitive types listed here
    is an object. Even null is considered an object, which is a little awkward having
    an object (something) that is actually nothing. We''ll learn more about objects
    in [Chapter 4](ch04.html "Chapter 4. Objects"), *Objects*, but for the time being,
    just remember that in JavaScript, the data types are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不属于这里列出的五种原始类型的值都是对象。即使是 `null` 也是一个对象，这有点尴尬，因为一个实际上什么都没有的对象（某物）。我们将在 [第 4
    章](ch04.html "第 4 章。对象") 中学习更多关于对象的内容，但在此期间，请记住，在 JavaScript 中，数据类型如下：
- en: Primitive (the five types listed previously)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始数据类型（前面列出的五种类型）
- en: Non-primitive (objects)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非原始数据类型（对象）
- en: Finding out the value type - the typeof operator
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找值类型 - typeof 操作符
- en: 'If you want to know the type of a variable or a value, you can use the special
    `typeof` operator. This operator returns a string that represents the data type.
    The return values of using `typeof` are one of the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道变量或值的类型，你可以使用特殊的 `typeof` 操作符。此运算符返回一个表示数据类型的字符串。使用 `typeof` 的返回值可以是以下之一：
- en: number
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: string
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: boolean
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: undefined
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: object
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: function
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: In the next few sections, you'll see `typeof` in action using examples of each
    of the five primitive data types.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，你将通过每个五种原始数据类型的示例来看到 `typeof` 的实际应用。
- en: Numbers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'The simplest number is an integer. If you assign `1` to a variable, and then
    use the `typeof` operator, it returns the string `number`, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的数字是整数。如果你将 `1` 分配给一个变量，然后使用 `typeof` 操作符，它将返回字符串 `number`，如下所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, you can see that the second time you set a variable's
    value, you don't need the `var` statement.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可以看到第二次设置变量的值时，不需要`var`语句。
- en: 'Numbers can also be floating point (decimals), for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 数字也可以是浮点数（小数），例如：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can call `typeof` directly on the value without assigning it to a variable
    first, for example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在值上调用`typeof`而不需要先将其赋给变量，例如：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Octal and hexadecimal numbers
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 八进制和十六进制数
- en: 'When a number starts with a `0`, it''s considered an octal number. For example,
    the octal `0377` is the decimal `255`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数字以`0`开头时，它被认为是八进制数。例如，八进制`0377`是十进制的`255`：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The last line in the preceding example prints the decimal representation of
    the octal value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子中的最后一行打印了八进制值的十进制表示。
- en: 'ES6 provides a prefix `0o` (or `0O`, but this looks very confusing in most
    monospace fonts) to represent octals. Consider the following line of code for
    example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ES6提供了一个前缀`0o`（或`0O`，但在大多数等宽字体中看起来非常混乱）来表示八进制。以下代码行为例：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While you may not be intimately familiar with octal numbers, you've probably
    used hexadecimal values to define colors in CSS stylesheets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能对八进制数字不太熟悉，但你可能已经使用十六进制值在CSS样式表中定义颜色。
- en: 'In CSS, you have several options to define a color, two of them are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，你有几种定义颜色的选项，其中两个如下：
- en: Using decimal values to specify the amount of R (red), G (green), and B (blue),
    ranging from `0` to `255`. For example, *rgb(0, 0, 0)* is black and *rgb(255,
    0, 0)* is red (maximum amount of red and no green or blue).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用十进制值来指定R（红色）、G（绿色）和B（蓝色）的量，范围从`0`到`255`。例如，*rgb(0, 0, 0)*是黑色，而*rgb(255, 0,
    0)*是红色（红色量最大，没有绿色或蓝色）。
- en: Using hexadecimals and specifying two characters for each R, G, and B value.
    For example, *#000000* is black and *#ff0000* is red. This is because *ff* is
    the hexadecimal value for `255`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用十六进制并指定每个R、G和B值两个字符。例如，*#000000*是黑色，而*#ff0000*是红色。这是因为*ff*是表示`255`的十六进制值。
- en: 'In JavaScript, you can put `0x` before a hexadecimal value, also called hex
    for short, for example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以在十六进制值前加上`0x`，也简称为hex，例如：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Binary Literals
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制字面量
- en: 'Untill ES6, if you needed binary representation of an integer, you had to pass
    them to the `parseInt()` function as a string with a radix of `2`, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，如果你需要整数的二进制表示，你必须将它们作为基数`2`的字符串传递给`parseInt()`函数，如下所示：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In ES6 you can use `0b` (or `0B`) prefix to represent binary integers. For
    example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，你可以使用`0b`（或`0B`）前缀来表示二进制整数。例如：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Exponent literals
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指数字面量
- en: '`1e1` (also written as `1e+1` or `1E1` or `1E+1`) represents the number 1 with
    a 0 after it, or in other words, `10`. Similarly, `2e+3` represents the number
    2 with three 0s after it, or `2000`, for example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`1e1`（也写作`1e+1`或`1E1`或`1E+1`）表示数字1后面跟着一个0，换句话说，`10`。同样，`2e+3`表示数字2后面跟着三个0，即`2000`，例如：'
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`2e+3` means moving the decimal point three digits to the right of the number
    **2**. There''s also `2e-3`, meaning you move the decimal point three digits to
    the left of the number **2**. Look at the following figure:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`2e+3`意味着将数字**2**的小数点向右移动三位。还有`2e-3`，意味着将数字**2**的小数点向左移动三位。 以下是一个图示：'
- en: '![Exponent literals](img/image_02_002.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![指数字面量](img/image_02_002.jpg)'
- en: 'The following is the code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一段代码：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Infinity
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Infinity
- en: 'There is a special value in JavaScript called Infinity. It represents a number
    too big for JavaScript to handle. Infinity is indeed a number, as typing `typeof
    Infinity` in the console will confirm. You can also quickly check that a number
    with `308` zeros is ok, but `309` zeros is too much. To be precise, the biggest
    number JavaScript can handle is `1.7976931348623157e+308`, while the smallest
    is `5e-324`, Look at the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有一个特殊值叫做Infinity。它表示一个JavaScript无法处理的非常大的数。Infinity确实是一个数字，如你在控制台中输入`typeof
    Infinity`可以确认。你也可以快速检查一个有`308`个零的数字是可行的，但`309`个零就太多了。精确地说，JavaScript可以处理的最大数字是`1.7976931348623157e+308`，而最小的是`5e-324`。以下是一个例子：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Dividing by zero gives you infinity, for example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除以零会得到无限大，例如：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Infinity` is the biggest number (or rather a little bigger than the biggest),
    but how about the smallest? It''s infinity with a minus sign in front of it; `-Infinity`,
    for example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`是最大的数字（或者说是比最大的数字略大），那么最小的是什么呢？它是在前面带有负号的无限大；例如`-Infinity`：'
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Does this mean you can have something that''s exactly twice as big as Infinity,
    from 0 up to infinity and then from 0 down to minus infinity? Well, not really.
    When you sum `Infinity` and `-Infinity`, you don''t get `0`, but something that
    is called **Not a Number** (**NaN**), For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你可以有一个正好是无穷大两倍的东西，从 0 到无穷大，然后从 0 到负无穷大？实际上并不是这样。当你将 `Infinity` 和 `-Infinity`
    相加时，你不会得到 `0`，而是得到一个被称为 **非数字**（**NaN**）的东西。例如：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Any other arithmetic operation with `Infinity` as one of the operands gives
    you `Infinity`, for example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含 `Infinity` 作为操作数的其他算术运算都会得到 `Infinity`，例如：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is a lesser known global method, `isFinite()`, that tells you if the value
    is infinity or not. ES6 adds a `Number.isFinite()`method to do just that. Why
    another method, you may ask. The global variant of `isFinite()` tries to cast
    the value through Number(value), while `Number.isFinite()` doesn't, hence it's
    more accurate.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个不太为人所知的全局方法，`isFinite()`，它可以告诉你一个值是否是无穷大。ES6 添加了一个 `Number.isFinite()` 方法来执行这个操作。你可能会问，为什么还需要另一个方法呢？全局版本的
    `isFinite()` 会尝试将值通过 `Number(value)` 转换，而 `Number.isFinite()` 则不会，因此它更准确。
- en: NaN
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NaN
- en: 'What was this `NaN` in the previous example? It turns out that despite its
    name, Not a Number, `NaN` is a special value that is also a number:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，这个 `NaN` 是什么？实际上，尽管它的名字叫“非数字”，`NaN` 也是一个特殊的值，它也是一个数字：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You get `NaN` when you try to perform an operation that assumes numbers, but
    the operation fails. For example, if you try to multiply `10` by the character
    `"f"`, the result is `NaN`, because `"f"` is obviously not a valid operand for
    a multiplication:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试执行一个假设数字的操作，但操作失败时，你会得到 `NaN`。例如，如果你尝试将 `10` 乘以字符 `"f"`，结果就是 `NaN`，因为 `"f"`
    显然不是一个有效的乘法操作数：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`NaN` is contagious, so if you have even one `NaN` in your arithmetic operation,
    the whole result goes down the drain, for example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN` 是具有传染性的，所以如果你在算术运算中有一个 `NaN`，整个结果都会变成 `NaN`，例如：'
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Number.isNaN
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Number.isNaN
- en: ES5 has a global method-`isNaN()`. It determines if a value is `NaN` or not.
    ES6 provides a very similar method-`Number.isNaN()` (Notice that this method is
    not global).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ES5 拥有一个全局方法-`isNaN()`。它用于判断一个值是否为 `NaN`。ES6 提供了一个非常类似的方法-`Number.isNaN()`（注意，这个方法不是全局的）。
- en: 'The difference between the global `isNaN()` and `Number.isNaN()` is that global
    `isNaN()` casts non-numeric values before evaluating them to be `NaN`. Let''s
    look at the following example. We are using the ES6 `Number.isNaN()` method to
    test if something is a `NaN` or not:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 `isNaN()` 和 `Number.isNaN()` 之间的区别在于，全局 `isNaN()` 在评估为 `NaN` 之前会将非数字值转换为数字。让我们看看以下例子。我们使用
    ES6 的 `Number.isNaN()` 方法来测试某个值是否是 `NaN`：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We saw that ES5''s global `isNaN()` method first casts non-numeric values and
    then does the comparison; the following result will be different from its ES6
    counterpart:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 ES5 的全局 `isNaN()` 方法首先将非数字值转换为数字，然后进行比较；以下结果将与其 ES6 对应版本不同：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In general, compared to its global variant, `Number.isNaN()` is more correct.
    However, neither of them can be used to figure out if something is not a number-they
    just answer if the value is a `NaN` or not. Practically, you are interested in
    knowing if a value identifies as a number or not. Mozilla suggests the following
    polyfill method to do just that:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，与它的全局版本相比，`Number.isNaN()` 更准确。然而，它们都不能用来判断一个值是否不是数字——它们只是回答值是否是 `NaN`。实际上，你可能更感兴趣的是知道一个值是否被识别为数字。Mozilla
    建议使用以下 polyfill 方法来实现这一点：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Number.isInteger
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Number.isInteger
- en: 'This is a new method in ES6\. It returns `true` if the number is finite and
    does not contain any decimal points (is an integer):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 ES6 中的新方法。如果数字是有限的且不包含任何小数点（是一个整数），它会返回 `true`：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Strings
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A string is a sequence of characters used to represent text. In JavaScript,
    any value placed between single or double quotes is considered a string. This
    means that `1` is a number, but `"1"` is a string. When used with strings, `typeof`
    returns the string `"string"`, for example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一系列用于表示文本的字符。在 JavaScript 中，任何放在单引号或双引号之间的值都被认为是字符串。这意味着 `1` 是一个数字，但 `"1"`
    是一个字符串。当与字符串一起使用时，`typeof` 返回字符串 `"string"`，例如：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here''s an example of a number used in the string context:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在字符串上下文中使用数字的例子：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you put nothing in quotes, it''s still a string (an empty string), for example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你什么也不在引号里放，它仍然是一个字符串（一个空字符串），例如：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you already know, when you use the plus sign with two numbers, this is the
    arithmetic addition operation. However, if you use the plus sign with strings,
    this is a string concatenation operation, and it returns the two strings glued
    together:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，当您使用两个数字的加号时，这是算术加法运算。然而，如果您使用字符串的加号，这将是一个字符串连接操作，并返回两个粘合在一起的字符串：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The dual purpose of the `+` operator is a source of errors. Therefore, if you
    intend to concatenate strings, it's always best to make sure that all of the operands
    are strings. The same applies for addition; if you intend to add numbers then
    make sure the operands are numbers. You'll learn various ways to do so further
    in the chapter and the book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符的双重用途是错误的一个来源。因此，如果您打算连接字符串，最好确保所有的运算符都是字符串。同样适用于加法；如果您打算加数，请确保运算符是数字。您将在本章和书中进一步了解如何做到这一点。'
- en: String conversions
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串转换
- en: 'When you use a number-like string, for example, `"1"`, as an operand in an
    arithmetic operation, the string is converted to a number behind the scenes. This
    works for all arithmetic operations except addition, because of its ambiguity.
    Consider the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用类似数字的字符串，例如 `"1"`，作为算术运算的运算符时，字符串在幕后被转换为数字。这适用于所有算术运算，除了加法，因为它具有歧义。考虑以下示例：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A lazy way to convert any number-like string to a number is to multiply it
    by `1` (another way is to use a function called `parseInt()`, as you''ll see in
    the next chapter):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何类似数字的字符串转换为数字的一种懒惰方法是将其乘以 `1`（另一种方法是使用名为 `parseInt()` 的函数，您将在下一章中看到）：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the conversion fails, you''ll get `NaN`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换失败，您将得到 `NaN`：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can convert a string to a number by multiplying it by `1`. The opposite-converting
    anything to a string-can be done by concatenating it with an empty string, as
    follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其乘以 `1` 将字符串转换为数字。相反的转换——将任何内容转换为字符串——可以通过将其与空字符串连接来实现，如下所示：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Special strings
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊字符串
- en: 'There are also strings with special meanings, as listed in the following table:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了具有特殊含义的字符串：
- en: '| **String** | **Meaning** | **Example** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **字符串** | **含义** | **示例** |'
- en: '| `\\``''``"` | The `\` is the escape character. When you want to have quotes
    inside your string, you can escape them so that JavaScript doesn''t think they
    mean the end of the string.If you want to have an actual backslash in the string,
    escape it with another backslash. | `> var s = ''I don''t know'';`: This is an
    error because JavaScript thinks the string is `I don` and the rest is invalid
    code. The following codes are valid:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '| `\\``''``"` | `\` 是转义字符。当您想在字符串中包含引号时，您可以转义它们，这样 JavaScript 就不会认为它们是字符串的结尾。如果您想在字符串中包含实际的反斜杠，请使用另一个反斜杠来转义它。
    | `> var s = ''I don''t know'';`：这是一个错误，因为 JavaScript 认为字符串是 `I don`，其余部分是无效代码。以下代码是有效的：'
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `\n` | End of line. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 行尾。 |'
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `\r` | Carriage return. | Consider the following statements:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '| `\r` | 回车符。 | 考虑以下声明：'
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result of all of these is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果如下：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `\t` | Tab. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符。 |'
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `\u` | The `\u` followed by a character code allows you to use Unicode. |
    Here''s my name in Bulgarian written with Cyrillic characters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '| `\u` | `\u` 后跟一个字符码允许您使用 Unicode。 | 这里是我的名字，用西里尔字母在保加利亚语中写成：'
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'There are also additional characters that are rarely used: `\b` (backspace),
    `\v` (vertical tab), and `\f` (form feed).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些很少使用的附加字符：`\b`（退格），`\v`（垂直制表符），和 `\f`（换页符）。
- en: String template literals
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串模板字符串
- en: 'ES6 introduced template literals. If you are familiar with other programming
    languages, Perl and Python have supported template literals for a while now. Template
    literals allow expressions to be embedded within regular strings. ES6 has two
    kinds of literals: template literals and tagged literals.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了模板字符串。如果您熟悉其他编程语言，Perl 和 Python 已经支持模板字符串一段时间了。模板字符串允许在普通字符串中嵌入表达式。ES6
    有两种类型的字面量：模板字符串和标签模板字符串。
- en: 'Template literals are single or multiple line strings with embedded expressions.
    For example, you must have done something similar to this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串是包含嵌入表达式的单行或多行字符串。例如，您必须已经做过类似以下的事情：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can accomplish the same using template literals, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用模板字符串完成相同的事情，如下所示：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Template literals are enclosed by the back-tick ([PRE60]) (grave accent) character
    instead of the usual double or single quotes. Template literal place holders are
    indicated by the dollar sign and curly braces (`${expression}`). By default, they
    are concatenated to form a single string. The following example shows a template
    literal with a slightly complex expression:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量由反引号（[PRE60]）（重音符号）字符包围，而不是通常的双引号或单引号。模板字面量占位符由美元符号和花括号（`${expression}`）表示。默认情况下，它们被连接成一个单独的字符串。以下示例显示了一个带有稍微复杂表达式的模板字面量：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How about embedding a function call?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么嵌入一个函数调用如何？
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Template literals also simplify multiline string syntax. Instead of writing
    the following line of code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字面量还简化了多行字符串语法。而不是编写以下代码行：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can have a much cleaner syntax using template literals, which is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用模板字面量获得更干净的语法，如下所示：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'ES6 has another interesting literal type called **Tagged Template Literals**.
    Tagged templates allow you to modify the output of template literals using a function.
    If you prefix an expression to a template literal, that prefix is considered to
    be a function to be invoked. The function needs to be defined before we can use
    the tagged template literal. For example, the following expression:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 有另一种有趣的字面量类型，称为 **标签模板字面量**。标签模板允许您使用函数修改模板字面量的输出。如果您在模板字面量前缀一个表达式，那么该前缀被认为是将被调用的函数。在我们可以使用标签模板字面量之前，需要定义该函数。例如，以下表达式：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding expression is converted into a function call:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式被转换为函数调用：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The tag function, ''transform'', gets two parameters-template strings like
    `Name is` and substitutions defined by `${}`. The substitutions are only known
    at runtime. Let''s expand the `transform` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 标签函数 `transform` 接收两个参数——模板字符串，如 `Name is`，以及由 `${}` 定义的替换。替换仅在运行时才知道。让我们扩展
    `transform` 函数：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When template strings (`Name is`) are passed to the tag function, there are
    two forms of each template string, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板字符串（`Name is`）传递给标签函数时，每个模板字符串有两种形式，如下所示：
- en: The raw form where the backslashes are not interpreted
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反斜杠不被解释的原始形式
- en: The cooked form where the backslashes has special meaning
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反斜杠有特殊意义的已处理形式
- en: 'You can access the raw string form using raw property, as the following example
    shows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `raw` 属性访问原始字符串形式，如下例所示：
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Booleans
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'There are only two values that belong to the Boolean data type-the `true` and
    `false` values used without quotes:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个值属于布尔数据类型——不带引号的 `true` 和 `false` 值：
- en: '[PRE69]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you quote `true` or `false`, they become strings, as shown in the following
    example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您引用 `true` 或 `false`，它们将成为字符串，如下例所示：
- en: '[PRE70]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Logical operators
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'There are three operators, called logical operators, that work with Boolean
    values. These are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个运算符，称为逻辑运算符，它们与布尔值一起工作。这些如下：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You know that when something is not true, it must be false. Here''s how this
    is expressed using JavaScript and the logical `!` operator:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道当某事不是真的时，它必须是假的。以下是使用 JavaScript 和逻辑 `!` 运算符如何表达这一点：
- en: '[PRE72]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you use the logical `NOT` twice, you will get the original value, which
    is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用逻辑 `NOT` 两次，您将得到原始值，如下所示：
- en: '[PRE73]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you use a logical operator on a non-Boolean value, the value is converted
    to Boolean behind the scenes, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在非布尔值上使用逻辑运算符，则该值在幕后被转换为布尔值，如下所示：
- en: '[PRE74]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the preceding case, the string value `"one"` is converted to a Boolean,
    `true`, and then negated. The result of negating `true` is `false`. In the following
    example, there''s a double negation, so the result is `true`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，字符串值 `"one"` 被转换为布尔值 `true`，然后取反。取反 `true` 的结果是 `false`。在以下示例中，有一个双重取反，所以结果是
    `true`：
- en: '[PRE75]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can convert any value to its Boolean equivalent using a double negation.
    Understanding how any value converts to a Boolean is important. Most values convert
    to `true` with the exception of the following, which convert to `false`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用双重取反将任何值转换为它的布尔等价物。了解任何值如何转换为布尔值很重要。大多数值转换为 `true`，除了以下这些，它们转换为 `false`：
- en: The empty string `""`
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串 `""`
- en: 'null'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: undefined
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: The number `0`
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `0`
- en: The number `NaN`
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `NaN`
- en: The Boolean `false`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值 `false`
- en: These six values are referred to as falsy, while all others are truthy, (including,
    for example, the strings `"0"`, `" "`, and `"false"`).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个值被称为假值，而所有其他值都是真值（包括例如字符串 `"0"`、`" "` 和 `"false"`）。
- en: 'Let''s see some examples of the other two operators-the logical `AND` (`&&`)
    and the logical `OR` (`||`). When you use `&&`, the result is `true` only if all
    of the operands are `true`. When you use `||`, the result is `true` if at least
    one of the operands is `true`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他两个运算符的示例——逻辑`AND`（`&&`）和逻辑`OR`（`||`）。当你使用`&&`时，只有当所有操作数都为`true`时，结果才是`true`。当你使用`||`时，如果至少有一个操作数是`true`，则结果为`true`：
- en: '[PRE76]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here''s a list of the possible operations and their results:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可能的操作及其结果的列表：
- en: '| **Operation** | **Result** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **结果** |'
- en: '| `true && true` | `true` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `true && true` | `true` |'
- en: '| `true && false` | `false` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `true && false` | `false` |'
- en: '| `false && true` | `false` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `false && true` | `false` |'
- en: '| `false && false` | `false` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `false && false` | `false` |'
- en: '| `true &#124;&#124; true` | `true` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `true || true` | `true` |'
- en: '| `true &#124;&#124; false` | `true` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `true || false` | `true` |'
- en: '| `false &#124;&#124; true` | `true` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `false || true` | `true` |'
- en: '| `false &#124;&#124; false` | `false` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `false || false` | `false` |'
- en: 'You can use several logical operations one after the other, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以连续使用几个逻辑运算，如下所示：
- en: '[PRE77]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can also mix `&&` and `||` in the same expression. In such cases, you should
    use parentheses to clarify how you intend the operation to work. Consider the
    following example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在同一个表达式中混合使用`&&`和`||`。在这种情况下，你应该使用括号来明确你打算如何进行操作。考虑以下示例：
- en: '[PRE78]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Operator precedence
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: 'You might wonder why the previous expression (`false && false || true && true`)
    returned `true`. The answer lies in the operator precedence, as you know from
    mathematics:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么前面的表达式（`false && false || true && true`）返回了`true`。答案在于运算符优先级，正如你所知，来自数学：
- en: '[PRE79]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is because multiplication has a higher precedence over addition, so `2
    * 3` is evaluated first, as if you typed:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为乘法比加法具有更高的优先级，所以`2 * 3`首先被评估，就像你输入了：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Similarly for logical operations, `!` has the highest precedence and is executed
    first, assuming there are no parentheses that demand otherwise. Then, in the order
    of precedence, comes `&&` and finally, `||`. In other words, the following two
    code snippets are the same. The first one is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逻辑运算，同样，`!`具有最高的优先级，并且首先执行，前提是没有括号要求其他操作。然后，按照优先级顺序，是`&&`，最后是`||`。换句话说，以下两个代码片段是相同的。第一个如下所示：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And the second one is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码片段如下所示：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Use parentheses instead of relying on operator precedence. This makes your code
    easier to read and understand.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号而不是依赖运算符优先级。这使得你的代码更容易阅读和理解。
- en: The ECMAScript standard defines the precedence of operators. While it may be
    a good memorization exercise, this book doesn't offer it. First of all, you'll
    forget it, and second, even if you manage to remember it, you shouldn't rely on
    it. The person reading and maintaining your code will likely be confused.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript标准定义了运算符的优先级。虽然这可能是一个很好的记忆练习，但本书并不提供它。首先，你会忘记它，其次，即使你设法记住它，你也不应该依赖它。阅读和维护你代码的人可能会感到困惑。
- en: Lazy evaluation
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 惰性求值
- en: 'If you have several logical operations one after the other, but the result
    becomes clear at some point before the end, the final operations will not be performed
    because they don''t affect the end result. Consider the following line of code
    as an example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一系列逻辑运算一个接一个，但在某个点之前结果已经明确，则最终的操作将不会执行，因为它们不会影响最终结果。以下代码行可以作为示例：
- en: '[PRE83]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'As these are all `OR` operations and have the same precedence, the result will
    be `true` if at least, one of the operands is `true`. After the first operand
    is evaluated, it becomes clear that the result will be `true`, no matter what
    values follow. So, the JavaScript engine decides to be lazy (OK, efficient) and
    avoids unnecessary work by evaluating code that doesn''t affect the end result.
    You can verify this short-circuiting behavior by experimenting in the console,
    as shown in the following code block:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些都是`OR`运算，并且具有相同的优先级，因此如果至少有一个操作数是`true`，则结果将是`true`。在评估第一个操作数之后，很明显结果将是`true`，无论后续的值是什么。因此，JavaScript引擎决定采取惰性（好吧，高效）的策略，通过评估不影响最终结果的代码来避免不必要的操作。你可以通过在控制台中实验来验证这种短路行为，如下面的代码块所示：
- en: '[PRE84]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This example also shows another interesting behavior-if JavaScript encounters
    a non-Boolean expression as an operand in a logical operation, the non-Boolean
    is returned as a result:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还展示了另一个有趣的行为——如果JavaScript在逻辑运算中遇到非布尔表达式作为操作数，则非布尔值将作为结果返回：
- en: '[PRE85]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This behavior is not something you should rely on because it makes the code
    harder to understand. It''s common to use this behavior to define variables when
    you''re not sure whether they were previously defined. In the next example, if
    the `mynumber` variable is defined, its value is kept; otherwise, it''s initialized
    with the value `10`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为不应该依赖于它，因为它会使代码更难以理解。通常使用这种行为来定义变量，当你不确定它们是否之前已定义时。在下一个示例中，如果 `mynumber`
    变量已定义，其值将被保留；否则，它将被初始化为值 `10`：
- en: '[PRE86]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This is simple and looks elegant, but be aware that it''s not completely foolproof.
    If `mynumber` is defined and initialized to `0`, or to any of the six falsy values,
    this code might not behave as you expect, as shown in the following piece of code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，看起来也很优雅，但请注意，它并不完全万无一失。如果 `mynumber` 已定义并初始化为 `0`，或任何六个假值之一，这段代码可能不会按您期望的方式运行，如下所示：
- en: '[PRE87]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Comparison
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较操作
- en: 'There''s another set of operators that all return a Boolean value as a result
    of the operation. These are the comparison operators. The following table lists
    them together with example uses:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一组操作符，它们在操作后都会返回一个布尔值。这些是比较操作符。以下表格列出了它们以及示例用法：
- en: '| **Operator symbol** | **Description** | **Example** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **操作符符号** | **描述** | **示例** |'
- en: '| `==` | **Equality comparison**: This returns `true` when both operands are
    equal. The operands are converted to the same type before being compared. They''re
    also called loose comparison. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `==` | **等价比较**：当两个操作数相等时返回 `true`。在比较之前，操作数会被转换为相同的类型。它们也被称为松散比较。 |'
- en: '[PRE88]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '|'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `===` | **Equality and type comparison**: This returns `true` if both operands
    are equal and of the same type. It''s better and safer to compare this way because
    there''s no behind-the-scenes type conversions. It is also called strict comparison.
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `===` | **等价和类型比较**：如果两个操作数相等且类型相同，则返回 `true`。这种方式比较更好、更安全，因为没有幕后类型转换。它也被称为严格比较。
    |'
- en: '[PRE89]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `!=` | **Non-equality comparison**: This returns `true` if the operands are
    not equal to each other (after a type conversion). |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | **非等价比较**：如果操作数在类型转换后不相等，则返回 `true`。 |'
- en: '[PRE90]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '|'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `!==` | **Non-equality comparison without type conversion**: Returns `true`
    if the operands are not equal or if they are of different types. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `!==` | **无类型转换的非等价比较**：如果操作数不相等或它们是不同类型，则返回 `true`。 |'
- en: '[PRE91]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '|'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `>` | This returns `true` if the left operand is greater than the right one.
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 如果左操作数大于右操作数，则返回 `true`。 |'
- en: '[PRE92]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '|'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `>=` | This returns `true` if the left operand is greater than or equal to
    the right one. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 如果左操作数大于或等于右操作数，则返回 `true`。 |'
- en: '[PRE93]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '|'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `<` | This returns `true` if the left operand is less than the right one.
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 如果左操作数小于右操作数，则返回 `true`。 |'
- en: '[PRE94]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '|'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `<=` | This returns `true` if the left operand is less than or equal to the
    right one. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 如果左操作数小于或等于右操作数，则返回 `true`。 |'
- en: '[PRE95]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '|'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Note that `NaN` is not equal to anything, not even itself. Take a look at the
    following line of code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`NaN` 不等于任何值，甚至不等于它自己。看看以下代码行：
- en: '[PRE96]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Undefined and null
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未定义和空值
- en: 'If you try to use a non-existing variable, you''ll get the following error:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用一个不存在的变量，你会得到以下错误：
- en: '[PRE97]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Using the `typeof` operator on a non-existing variable is not an error. You
    will get the `"undefined"` string back, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个不存在的变量上使用 `typeof` 操作符不会产生错误。你将得到 `"undefined"` 字符串，如下所示：
- en: '[PRE98]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If you declare a variable without giving it a value, this is, of course, not
    an error. But, the `typeof` still returns `"undefined"`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个变量而没有给它赋值，这当然不是错误。但是，`typeof` 仍然返回 `"undefined"`：
- en: '[PRE99]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This is because, when you declare a variable without initializing it, JavaScript
    automatically initializes it with the `undefined` value, as shown in the following
    lines of code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，当你声明一个未初始化的变量时，JavaScript 会自动将其初始化为 `undefined` 值，如下所示：
- en: '[PRE100]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `null` value, on the other hand, is not assigned by JavaScript behind the
    scenes; it''s assigned by your code, which is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`null` 值不是由 JavaScript 在幕后分配的；它是由你的代码分配的，如下所示：
- en: '[PRE101]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Although the difference between `null` and `undefined` is small, it can be
    critical at times. For example, if you attempt an arithmetic operation, you will
    get different results:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `null` 和 `undefined` 之间的区别很小，但在某些时候可能是关键的。例如，如果你尝试进行算术运算，你会得到不同的结果：
- en: '[PRE102]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This is because of the different ways `null` and `undefined` are converted
    to the other primitive types. The following examples show the possible conversions:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`null`和`undefined`转换为其他原始类型的方式不同。以下示例显示了可能的转换：
- en: 'Conversion to a number:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为数字：
- en: '[PRE103]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Conversion to NaN:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为`NaN`：
- en: '[PRE104]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Conversion to a Boolean:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为布尔值：
- en: '[PRE105]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Conversion to a string:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为字符串：
- en: '[PRE106]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Symbols
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: 'ES6 introduced a new primitive type-symbols. Several languages have a similar
    notion. Symbols look very similar to regular strings, but they are very different.
    Let''s see how these symbols are created:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一种新的原始类型——符号。几种语言有类似的概念。符号看起来与普通字符串非常相似，但它们非常不同。让我们看看这些符号是如何创建的：
- en: '[PRE107]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Notice that we don''t use `new` operator while creating symbols. You will get
    an error when you do use it:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在创建符号时我们没有使用`new`运算符。当你使用它时，你会得到一个错误：
- en: '[PRE108]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You can describe `Symbol` as well:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样描述`符号`：
- en: '[PRE109]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Describing symbols comes in very handy while debugging large programs where
    there are lots of symbols scattered across.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试大型程序时，其中有很多符号散布各处，描述符号非常有用。
- en: 'The most important property of `Symbol` (and hence the reason of their existence)
    is that they are unique and immutable:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol`（因此它们存在的原因）最重要的属性是它们是唯一的且不可变的：'
- en: '[PRE110]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: For now, we will have to pause this discussion on symbols. Symbols are used
    as property keys and places where you need unique identifiers. We will discuss
    symbols in a later part of this book.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不得不暂停对符号的讨论。符号用作属性键和需要唯一标识符的地方。我们将在本书的后续部分讨论符号。
- en: Primitive data types recap
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型回顾
- en: 'Let''s quickly summarize some of the main points discussed so far:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下到目前为止讨论的一些主要观点：
- en: 'There are five primitive data types in JavaScript:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中有五种原始数据类型：
- en: Number
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Undefined
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: 'Null'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: Everything that is not a primitive data type is an object.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切不是原始数据类型的东西都是对象。
- en: The primitive number data type can store positive and negative integers or floats,
    hexadecimal numbers, octal numbers, exponents, and the special numbers-`NaN`,
    `Infinity`, and `-Infinity`.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始数字数据类型可以存储正数和负整数或浮点数、十六进制数、八进制数、指数和特殊数字——`NaN`、`Infinity`和`-Infinity`。
- en: The string data type contains characters in quotes. Template literals allow
    embedding of expressions inside a string.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串数据类型包含引号内的字符。模板字符串允许在字符串中嵌入表达式。
- en: The only values of the Boolean data type are `true` and `false`.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数据类型的唯一值是`true`和`false`。
- en: The only value of the null data type is the `null` value.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空数据类型的唯一值是`null`值。
- en: The only value of the undefined data type is the `undefined` value.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义数据类型的唯一值是`undefined`值。
- en: 'All values become `true` when converted to a Boolean, with the exception of
    the following six falsy values:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有值在转换为布尔值时都变为`true`，但有以下六个假值例外：
- en: '`""`'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`'
- en: '`null`'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`undefined`'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`0`'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`NaN`'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: '`false`'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: Arrays
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Now that you know about the basic primitive data types in JavaScript, it's time
    to move to a more powerful data structure-the array.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了JavaScript中的基本原始数据类型，是时候转向更强大的数据结构——数组了。
- en: So, what is an array? It's simply a list (a sequence) of values. Instead of
    using one variable to store one value, you can use one array variable to store
    any number of values as elements of the array.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是数组呢？它只是一个值列表（一个序列）。你不需要使用一个变量来存储一个值，而是可以使用一个数组变量来存储任何数量的值作为数组的元素。
- en: 'To declare a variable that contains an empty array, you can use square brackets
    with nothing between them, as shown in the following line of code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个包含空数组的变量，你可以使用没有任何内容之间的方括号，如下面的代码行所示：
- en: '[PRE111]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'To define an array that has three elements, you can write the following line
    of code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个包含三个元素的数组，你可以写下以下代码行：
- en: '[PRE112]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'When you simply type the name of the array in the console, you can get the
    contents of your array:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在控制台中简单地键入数组的名称时，你可以获取数组的全部内容：
- en: '[PRE113]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now the question is how to access the values stored in these array elements.
    The elements contained in an array are indexed with consecutive numbers, starting
    from zero. The first element has index (or position) 0, the second has index 1,
    and so on. Here''s the three-element array from the previous example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如何访问存储在这些数组元素中的值。数组中的元素使用连续的数字进行索引，从零开始。第一个元素的索引（或位置）是0，第二个是1，以此类推。以下是从上一个示例中的三个元素的数组：
- en: '| **Index** | **Value** |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| **索引** | **值** |'
- en: '| 0 | 1 |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 |'
- en: '| 1 | 2 |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 |'
- en: '| 2 | 3 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 |'
- en: 'To access an array element, you can specify the index of that element inside
    square brackets. So, `a[0]` gives you the first element of the array `a`, `a[1]`
    gives you the second, and so on, as shown in the following example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组元素，您可以在方括号中指定该元素的索引。因此，`a[0]`给您提供了数组`a`的第一个元素，`a[1]`给您提供了第二个，依此类推，如下面的示例所示：
- en: '[PRE114]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Adding/updating array elements
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加/更新数组元素
- en: 'Using the index, you can also update the values of the elements of the array.
    The next example updates the third element (index 2) and prints the contents of
    the new array, as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引，您还可以更新数组元素的值。下一个示例更新了第三个元素（索引2），并打印了新数组的内容，如下所示：
- en: '[PRE115]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'You can add more elements by addressing an index that didn''t exist before,
    as shown in the following lines of code:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过引用之前不存在的索引来添加更多元素，如下面的代码行所示：
- en: '[PRE116]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'If you add a new element but leave a gap in the array, those elements in between
    don''t exist and return the `undefined` value if accessed. Check out the following
    example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您添加了一个新元素，但在数组中留下了一个空隙，那么在之间的元素不存在，如果访问它们，将返回`undefined`值。查看以下示例：
- en: '[PRE117]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Deleting elements
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除元素
- en: 'To delete an element, you can use the `delete` operator. However, after the
    deletion, the length of the array does not change. In a sense, you may get a hole
    in the array:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除元素，您可以使用`delete`运算符。然而，删除后，数组的长度不会改变。在某种程度上，您可能在数组中有一个空隙：
- en: '[PRE118]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Arrays of arrays
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组数组
- en: 'Arrays can contain all types of values, including other arrays:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以包含所有类型的值，包括其他数组：
- en: '[PRE119]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `Array[3]` in the result is clickable in the console and it expands the
    array values. Let''s look at an example where you have an array of two elements,
    both of them being other arrays:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的`Array[3]`在控制台中是可点击的，并且展开数组值。让我们看看一个例子，其中您有一个包含两个元素的数组，这两个元素都是其他数组：
- en: '[PRE120]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The first element of the array is `[0]`, and it''s also an array:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的第一个元素是`[0]`，它也是一个数组：
- en: '[PRE121]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'To access an element in the nested array, you can refer to the element index
    in another set of square brackets, as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问嵌套数组中的元素，您可以在另一组方括号中引用该元素的索引，如下所示：
- en: '[PRE122]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Note that you can use the array notation to access individual characters inside
    a string, as shown in the following code block:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以使用数组符号来访问字符串内部的单个字符，如下面的代码块所示：
- en: '[PRE123]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Array access to strings was supported by many browsers for a while (not older
    IEs), but it was officially recognized only as late as ECMAScript 5.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对字符串的支持在许多浏览器中已经存在了一段时间（不是老版本的IE），但直到ECMAScript 5才被正式认可。
- en: 'There are more ways to have fun with arrays (and we get to those in [Chapter
    4](ch04.html "Chapter 4. Objects"), *Objects*), but let''s stop here for now,
    remembering the following points:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多方法可以与数组（我们在[第4章](ch04.html "第4章。对象")中介绍这些，*对象*），但现在让我们停下来，记住以下要点：
- en: An array is a data store
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是一个数据存储
- en: An array contains indexed elements
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组包含索引元素
- en: Indexes start from zero and increment by one for each element in the array
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引从零开始，并且对于数组中的每个元素递增一。
- en: To access an element of an array, you can use its index in square brackets
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问数组中的元素，您可以使用方括号中的索引
- en: An array can contain any type of data, including other arrays
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以包含任何类型的数据，包括其他数组
- en: Conditions and loops
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件和循环
- en: 'Conditions provide a simple but powerful way to control the flow of code execution.
    Loops allow you to perform repetitive operations with less code. Let''s take a
    look at:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 条件提供了一种简单但强大的方式来控制代码执行的流程。循环允许您用更少的代码执行重复操作。让我们看看：
- en: '`if` conditions'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`条件'
- en: '`switch` statements'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: '`while`, `do...while`, `for`, and `for...in` loops'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`、`do...while`、`for`和`for...in`循环'
- en: Note
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The examples in the following sections require you to switch to the multiline
    Firebug console. Or, if you use the WebKit console, press *Shift* + *Enter* instead
    of *Enter* to add a new line.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例需要您切换到多行Firebug控制台。或者，如果您使用WebKit控制台，请按*Shift* + *Enter*而不是*Enter*来添加新行。
- en: Code blocks
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码块
- en: In the preceding examples, you saw the use of code blocks. Let's take a moment
    to clarify what a block of code is, because you will use blocks extensively when
    constructing conditions and loops.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您看到了代码块的使用。让我们花一点时间来明确一下什么是代码块，因为在构建条件和循环时，您将广泛地使用代码块。
- en: 'A block of code consists of zero or more expressions enclosed in curly brackets,
    which is shown in the following lines of code:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块由零个或多个用大括号括起来的表达式组成，如下面的代码行所示：
- en: '[PRE124]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You can nest blocks within each other indefinitely, as shown in the following
    example:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在每个代码块内部无限嵌套其他代码块，如下面的示例所示：
- en: '[PRE125]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Note
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice tips**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践技巧**'
- en: Use end-of-line semicolons, as discussed previously in the chapter. Although
    the semicolon is optional when you have only one expression per line, it's good
    to develop the habit of using them. For best readability, the individual expressions
    inside a block should be placed one per line and separated by semicolons.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 使用行尾分号，如本章之前所述。虽然当每行只有一个表达式时，分号是可选的，但养成使用它们的习惯是好的。为了最佳的可读性，块内的单个表达式应放在每行一个，并用分号分隔。
- en: Indent any code placed within curly brackets. Some programmers like one tab
    indentation, some use four spaces, and some use two spaces. It really doesn't
    matter, as long as you're consistent. In the preceding example, the outer block
    is indented with two spaces, the code in the first nested block is indented with
    four spaces, and the innermost block is indented with six spaces.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在花括号内放置的任何代码都要缩进。一些程序员喜欢使用一个制表符缩进，一些使用四个空格，还有一些使用两个空格。这真的不重要，只要保持一致即可。在上面的示例中，外层代码块使用两个空格缩进，第一层嵌套代码使用四个空格缩进，最内层代码块使用六个空格缩进。
- en: Use curly brackets. When a block consists of only one expression, the curly
    brackets are optional, but for readability and maintainability, you should get
    into the habit of always using them, even when they're optional.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 使用花括号。当一个代码块只包含一个表达式时，花括号是可选的，但为了可读性和可维护性，你应该养成即使它们是可选的也始终使用它们的习惯。
- en: The if condition
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`if` 条件'
- en: 'Here''s a simple example of an `if` condition:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 `if` 条件示例：
- en: '[PRE126]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The parts of the `if` condition are as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 条件的各个部分如下：'
- en: The `if` statement
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: A condition in parentheses-`is a greater than 2`?
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号内的条件-`是否大于 2`？
- en: A block of code wrapped in `{}` that executes if the condition is satisfied
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代码块，如果条件满足则执行
- en: 'The condition (the part in parentheses) always returns a Boolean value, and
    may also contain the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 条件（括号内的部分）总是返回一个布尔值，并且可能还包含以下内容：
- en: A logical operation-`!`, `&&`, or `||`
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符-`!`、`&&` 或 `||`
- en: A comparison, such as `===`, `!=`, `>`, and so on
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符，如 `===`、`!=`、`>` 等
- en: Any value or variable that can be converted to a Boolean
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可以转换为布尔值的值或变量
- en: A combination of the above
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以上内容的组合
- en: The else clause
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`else` 子句'
- en: 'There can also be an optional else part of the `if` condition. The `else` statement
    is followed by a block of code that runs if the condition evaluates to `false`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 条件的可选部分也可以是 `else`。`else` 语句后面跟着一个代码块，如果条件评估为 `false` 则执行：'
- en: '[PRE127]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In between the `if` and the `else` statements, there can also be an unlimited
    number of `else...if` conditions. Here''s an example:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 和 `else` 语句之间，也可以有无限数量的 `else...if` 条件。以下是一个示例：
- en: '[PRE128]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You can also nest conditions by putting new conditions within any of the blocks,
    as shown in the following piece of code:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在任意代码块内放置新的条件来嵌套条件，如下面的代码片段所示：
- en: '[PRE129]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Checking if a variable exists
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查变量是否存在
- en: 'Let''s apply the new knowledge about conditions for something practical. It''s
    often necessary to check whether a variable exists. The laziest way to do this
    is to simply put the variable in the condition part of the `if` statement, for
    example, `if (somevar) {...}`. But, this is not necessarily the best method. Let''s
    take a look at an example that tests whether a variable called `somevar` exists,
    and if so, sets the `result` variable to `yes`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用关于条件的新知识来处理一些实际应用。通常需要检查变量是否存在。最懒惰的方法是将变量简单地放在 `if` 语句的条件部分，例如，`if (somevar)
    {...}`。但是，这不一定是最优的方法。让我们看看一个测试 `somevar` 变量是否存在，如果存在，则将 `result` 变量设置为 `yes` 的示例：
- en: '[PRE130]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This code obviously works because the end result was not `yes`. But firstly,
    the code generated an error-`somevar` is not defined, and you don't want your
    code to behave like that. Secondly, just because `if (somevar)` returns `false`,
    it doesn't mean that `somevar` is not defined. It could be that `somevar` is defined
    and initialized but contains a falsy value like `false` or `0`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显然是有效的，因为最终结果不是 `yes`。但是首先，代码生成了一个错误-`somevar` 未定义，你不想你的代码表现得像这样。其次，`if
    (somevar)` 返回 `false` 并不意味着 `somevar` 未定义。可能是 `somevar` 已定义并初始化，但包含一个假值，如 `false`
    或 `0`。
- en: 'A better way to check if a variable is defined is to use `typeof`:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 检查变量是否定义的更好方法是使用 `typeof`：
- en: '[PRE131]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The `typeof` operator always returns a string, and you can compare this string
    with the string `"undefined"`. Note that the `somevar` variable may have been
    declared but not assigned a value yet and you''ll still get the same result. So,
    when testing with `typeof` like this, you''re really testing whether the variable
    has any value other than the `undefined` value:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`运算符始终返回一个字符串，你可以将这个字符串与字符串`"undefined"`进行比较。注意，`somevar`变量可能已经被声明但尚未分配值，你仍然会得到相同的结果。所以，当用`typeof`进行测试时，你实际上是在测试变量是否有除了`undefined`值之外的任何值：'
- en: '[PRE132]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'If a variable is defined and initialized with any value other than `undefined`,
    its type returned by `typeof` is no longer `"undefined"`, as shown in the following
    piece of code:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量被定义并且用除了`undefined`之外的任何值初始化，那么`typeof`返回的类型就不再是`"undefined"`，如下面的代码片段所示：
- en: '[PRE133]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Alternative if syntax
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交替的`if`语法
- en: 'When you have a simple condition, you can consider using an alternative `if`
    syntax. Take a look at this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个简单条件时，你可以考虑使用交替的`if`语法。看看这个：
- en: '[PRE134]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'You can also write this as:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样写：
- en: '[PRE135]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: You should only use this syntax for simple conditions. Be careful not to abuse
    it, as it can easily make your code unreadable. Here's an example.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只为简单条件使用这种语法。小心不要滥用它，因为它很容易使你的代码难以阅读。以下是一个例子。
- en: 'Let''s say you want to make sure a number is within a certain range, say between
    `50` and `100`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要确保一个数字在某个范围内，比如说在`50`和`100`之间：
- en: '[PRE136]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'It may not be clear how this code works exactly because of the multiple ?.
    Adding parentheses makes it a little clearer, as shown in the following code block:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多个`?`，这段代码的工作原理可能不是很清楚。添加括号可以使它稍微清晰一些，如下面的代码块所示：
- en: '[PRE137]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '`?:` is called a ternary operator because it takes three operands.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`?:`被称为三元运算符，因为它有三个操作数。'
- en: Switch
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`switch`'
- en: 'If you find yourself using an `if` condition and having too many `else...if`
    parts, you can consider changing the `if` to a `switch`, as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在使用`if`条件并且有太多的`else...if`部分，你可以考虑将`if`改为`switch`，如下所示：
- en: '[PRE138]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The result after executing this is `"String 1"`. Let''s see what the parts
    of a `switch` are:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后的结果是`"String 1"`。让我们看看`switch`的各个部分：
- en: The `switch` statement.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句。'
- en: An expression in parentheses. The expression most often contains a variable,
    but can be anything that returns a value.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号中的表达式。这个表达式通常包含一个变量，但可以是任何返回值的任何东西。
- en: A number of `case` blocks enclosed in curly brackets.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在花括号中的一系列`case`块。
- en: Each `case` statement is followed by an expression. The result of the expression
    is compared to the expression found after the `switch` statement. If the result
    of the comparison is `true`, the code that follows the colon after the `case`
    is executed.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`case`语句后面跟着一个表达式。这个表达式的结果与`switch`语句后面的表达式进行比较。如果比较的结果是`true`，则执行冒号后面的`case`之后的代码。
- en: There is an optional `break` statement to signal the end of the `case` block.
    If this `break` statement is reached, the `switch` statement is all done. Otherwise,
    if the `break` is missing, the program execution enters the next `case` block.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个可选的`break`语句用来表示`case`块的结束。如果达到了这个`break`语句，`switch`语句就完成了。否则，如果缺少`break`，程序执行将进入下一个`case`块。
- en: There's an optional default case marked with the `default` statement and followed
    by a block of code. The `default` case is executed if none of the previous cases
    evaluated to `true`.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个可选的默认情况，用`default`语句标记，并跟随一个代码块。如果没有之前的任何情况评估为`true`，则执行默认情况。
- en: 'In other words, the step-by-step procedure to execute a `switch` statement
    is as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，执行`switch`语句的逐步过程如下：
- en: Evaluate the `switch` expression found in parentheses; remember it.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估括号中找到的`switch`表达式；记住它。
- en: Move to the first case and compare its value with the one from Step 1.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到第一个`case`，并将其值与第1步中的值进行比较。
- en: If the comparison in Step 2 returns `true`, execute the code in the `case` block.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第2步的比较返回`true`，则执行`case`块中的代码。
- en: After the `case` block is executed, if there's a `break` statement at the end
    of it, exit `switch`.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行完`case`块之后，如果它的末尾有一个`break`语句，则退出`switch`。
- en: If there's no `break` or Step 2 returned `false`, move on to the next `case`
    block.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有`break`或第2步返回`false`，则继续到下一个`case`块。
- en: Repeat steps 2 to 5.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到5。
- en: If you are still here (no exit in Step 4), execute the code following the `default`
    statement.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你仍然在这里（第4步没有退出），执行`default`语句之后的代码。
- en: Tip
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Indent the code that follows the case lines. You can also indent case from the
    switch, but that doesn't give you much in terms of readability.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进 `case` 行后面的代码。你也可以从 `switch` 中缩进 `case`，但这在可读性方面帮助不大。
- en: Don't forget to break
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要忘记使用 `break`
- en: Sometimes, you may want to omit the break intentionally, but that's rare. It's
    called a fall-through and should always be documented because it may look like
    an accidental omission. On the other hand, sometimes you may want to omit the
    whole code block following a case and have two cases sharing the same code. This
    is fine, but it doesn't change the rule that if there's code that follows a case
    statement, this code should end with a break. In terms of indentation, aligning
    the break with the case or with the code inside the case is a personal preference;
    again, being consistent is what matters.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能故意省略 `break`，但这很少见。这被称为“穿透”，应该始终记录下来，因为它可能看起来像是一个意外的遗漏。另一方面，有时候你可能想省略一个
    `case` 后面的整个代码块，让两个 `case` 共享相同的代码。这是可以的，但这并不改变规则：如果有一个 `case` 后面跟着代码，那么这段代码应该以
    `break` 结尾。至于缩进，将 `break` 与 `case` 或 `case` 内的代码对齐是个人喜好；再次强调，一致性才是关键。
- en: Use the default case. This helps you make sure that you always have a meaningful
    result after the switch statement, even if none of the cases matches the value
    being switched.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认情况。这有助于确保在 `switch` 语句之后，你总是有一个有意义的输出，即使没有 `case` 与被切换的值匹配。
- en: Loops
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: The `if...else` and `switch` statements allow your code to take different paths,
    as if you're at a crossroad, and decide which way to go depending on a condition.
    Loops, on the other hand, allow your code to take a few roundabouts before merging
    back into the main road. How many repetitions? That depends on the result of evaluating
    a condition before (or after) each iteration.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else` 和 `switch` 语句允许你的代码根据条件选择不同的路径，就像你站在一个十字路口，根据条件决定走哪条路。另一方面，循环允许你的代码在合并回主路之前绕几个弯。重复多少次？这取决于在每个迭代之前（或之后）评估条件的结果。'
- en: 'Let''s say you are (your program execution is) traveling from **A** to **B**.
    At some point, you will reach a place where you have to evaluate a condition,
    **C**. The result of evaluating **C** tells you whether you should go into a loop,
    **L**. You make one iteration and arrive at **C** again. Then, you evaluate the
    condition once again to see if another iteration is needed. Eventually, you move
    on your way to **B**:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在从 **A** 到 **B** 的旅途中（或者说你的程序执行正在旅途中）。在某个时刻，你将到达一个需要评估条件 **C** 的地方。评估 **C**
    的结果会告诉你是否应该进入循环 **L**。你进行一次迭代并再次到达 **C**。然后，你再次评估条件以查看是否需要另一个迭代。最终，你继续前往 **B**：
- en: '![Loops](img/image_02_003.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![循环](img/image_02_003.jpg)'
- en: An infinite loop is when the condition is always `true`, and your code gets
    stuck in the loop forever. This is, of course, a logical error, and you should
    look out for such scenarios.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环是指条件始终为 `true`，你的代码会永远卡在循环中。这当然是一个逻辑错误，你应该注意这种场景。
- en: 'In JavaScript, the following are the four types of loops:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，以下有四种循环类型：
- en: '`while` loops'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`do-while` loops'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do-while` 循环'
- en: '`for` loops'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`for-in` loops'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-in` 循环'
- en: While loops
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: 'The `while` loops are the simplest type of iteration. They look like the following:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环是最简单的一种迭代类型。它们看起来像这样：'
- en: '[PRE139]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The `while` statement is followed by a condition in parentheses and a code block
    in curly brackets. As long as the condition evaluates to `true`, the code block
    is executed over and over again.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句后面跟着一个括号中的条件和花括号中的代码块。只要条件评估为 `true`，代码块就会反复执行。'
- en: Do-while loops
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`do-while` 循环'
- en: 'The `do...while` loops are a slight variation of `while` loops. An example
    is shown as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`do...while` 循环是 `while` 循环的一种轻微变化。以下是一个示例：'
- en: '[PRE140]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here, the `do` statement is followed by a code block and a condition after the
    block. This means that the code block is always executed, at least once, before
    the condition is evaluated.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`do` 语句后面跟着一个代码块，然后在块后面跟着一个条件。这意味着代码块在评估条件之前（至少一次）总是被执行。
- en: If you initialize `i` to `11` instead of `0` in the last two examples, the code
    block in the first example (the `while` loop) will not be executed, and `i` will
    still be `11` at the end, while in the second (the `do...while` loop), the code
    block will be executed once and `i` will become `12`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将最后一个例子中的 `i` 初始化为 `11` 而不是 `0`，那么第一个例子（`while` 循环）中的代码块将不会执行，并且 `i` 在结束时仍然是
    `11`，而在第二个（`do...while` 循环）中，代码块将执行一次，`i` 将变为 `12`。
- en: For loops
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: 'The `for` loop is the most widely used type of loop, and you should make sure
    you''re comfortable with this one. It requires just a little bit more in terms
    of syntax:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环是最广泛使用的循环类型，你应该确保你对这个循环感到舒适。它在语法方面只需要稍微多一点：'
- en: '![For loops](img/image_02_004.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![For loops](img/image_02_004.jpg)'
- en: 'In addition to the **C** condition and the **L** code block, you have the following:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**C**条件语句和**L**代码块之外，你还有以下内容：
- en: '**Initialization**: This is the code that is executed before you even enter
    the loop (marked with **0** in the diagram)'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：这是在进入循环之前执行的代码（在图中标记为**0**）'
- en: '**Increment**: This is the code that is executed after every iteration (marked
    with **++** in the diagram)'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量**：这是在每次迭代后执行的代码（在图中标记为**++**）'
- en: 'The following is the most widely used `for` loop pattern:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用的`for`循环模式：
- en: In the initialization part, you can define a variable (or set the initial value
    of an existing variable), most often called `i`
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始化部分，你可以定义一个变量（或设置现有变量的初始值），通常称为`i`
- en: In the condition part, you can compare `i` to a boundary value, such as `i <
    100`
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在条件部分，你可以将`i`与一个边界值进行比较，例如`i < 100`
- en: In the increment part, you can increase `i` by `1`, such as `i++`
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在增量部分，你可以将`i`增加`1`，例如`i++`
- en: 'Here''s an example:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE141]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'All three parts (initialization, condition, and increment) can contain multiple
    expressions separated by commas. Say you want to rewrite the example and define
    the variable `punishment` inside the initialization part of the loop:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个部分（初始化、条件和增量）都可以包含由逗号分隔的多个表达式。比如说，你想重写示例并在循环的初始化部分定义变量`punishment`：
- en: '[PRE142]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Can you move the body of the loop inside the increment part? Yes, you can,
    especially as it''s a one-liner. This gives you a loop that looks a little awkward,
    as it has no body. Note that this is just an intellectual exercise; it''s not
    recommended that you write awkward-looking code:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将循环体移动到增量部分吗？是的，你可以，尤其是当它是一行代码时。这会使循环看起来有些不自然，因为它没有主体。请注意，这只是一个智力练习；不建议你编写看起来不自然的代码：
- en: '[PRE143]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'These three parts are all optional. Here''s another way of rewriting the same
    example:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个部分都是可选的。这里有另一种重写相同示例的方法：
- en: '[PRE144]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Although the last rewrite works exactly the same way as the original, it's longer
    and harder to read. It's also possible to achieve the same result using a `while`
    loop. But, the `for` loops make the code tighter and more robust because the mere
    syntax of the `for` loop makes you think about the three parts (initialization,
    condition, and increment), and thus helps you reconfirm your logic and avoid situations
    such as being stuck in an infinite loop.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最后的重写与原始版本完全一样，但它更长，更难阅读。也可以使用`while`循环达到相同的结果。但是，`for`循环使代码更紧凑、更健壮，因为`for`循环的语法本身就会让你思考三个部分（初始化、条件和增量），从而帮助你重新确认你的逻辑并避免陷入无限循环的情况。
- en: 'The `for` loops can be nested within each other. Here''s an example of a loop
    that is nested inside another loop and assembles a string containing ten rows
    and ten columns of asterisks. Think of `i` being the row and `j` being the column
    of an image:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可以嵌套在彼此内部。以下是一个嵌套在另一个循环内部的循环示例，它组装了一个包含十行十列星号的字符串。想象一下`i`是图像的行，`j`是列：'
- en: '[PRE145]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The result is a string, as shown here:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个字符串，如下所示：
- en: '[PRE146]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Here''s another example that uses nested loops and a modulo operation to draw
    a snowflake-like result:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个使用嵌套循环和取模运算来绘制类似雪花结果的示例：
- en: '[PRE147]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The result is as follows:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE148]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: For...in loops
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: For...in循环
- en: The `for...in` loop is used to iterate over the elements of an array, or an
    object, as you'll see later. This is its only use; it cannot be used as a general-purpose
    repetition mechanism to replace `for` or `while`. Let's see an example of using
    a `for-in` to loop through the elements of an array. But, bear in mind that this
    is for informational purposes only, as `for...in` is mostly suitable for objects
    and the regular `for` loop should be used for arrays.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...in`循环用于遍历数组或对象中的元素，正如你稍后将会看到的。这是它的唯一用途；它不能用作通用重复机制来替换`for`或`while`。让我们看看使用`for-in`遍历数组元素的示例。但请注意，这只是为了信息目的，因为`for...in`主要适用于对象，而常规的`for`循环应该用于数组。'
- en: 'In this example, you can iterate over all of the elements of an array and print
    out the index (the key) and the value of each element, for example:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以遍历数组的所有元素，并打印出每个元素的索引（键）和值，例如：
- en: '[PRE149]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Comments
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: One last thing for this chapter-comments. Inside your JavaScript program, you
    can put comments. These are ignored by the JavaScript engine and don't have any
    effect on how the program works. But they can be invaluable when you revisit your
    code after a few months, or transfer the code to someone else for maintenance.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一点——注释。在你的JavaScript程序中，你可以添加注释。这些注释被JavaScript引擎忽略，并且对程序的工作没有影响。但它们在你几个月后回顾代码或把代码转交给他人维护时非常有价值。
- en: 'The following two types of comments are allowed:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 允许以下两种类型的注释：
- en: Single line comments start with `//` and end at the end of the line.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行注释以 `//` 开始，并在行尾结束。
- en: Multiline comments start with `/*` and end with `*/` on the same line or any
    subsequent line. Note that any code in between the comment start and the comment
    end is ignored.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行注释以 `/*` 开始，以 `*/` 结束，可以在同一行或任何后续行。请注意，注释开始和结束之间的任何代码都将被忽略。
- en: 'Some examples are as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE150]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: There are even utilities, such as JSDoc and YUIDoc, that can parse your code
    and extract meaningful documentation based on your comments.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有一些工具，如JSDoc和YUIDoc，可以解析你的代码并根据你的注释提取有意义的文档。
- en: Exercises
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What is the result of executing each of these lines in the console? Why?
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行这些行在控制台中的结果是什么？为什么？
- en: '[PRE151]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: What is the value of v after the following?
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下操作之后，v的值是多少？
- en: '[PRE152]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Experiment by first setting `v` to `100`, `0`, or `null`.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过首先将`v`设置为`100`，`0`，或`null`来实验。
- en: 'Write a small program that prints out the multiplication table. Hint: use a
    loop nested inside another loop.'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小程序，打印出乘法表。提示：使用嵌套循环。
- en: Summary
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned a lot about the basic building blocks of a JavaScript
    program. Now you know the following primitive data types:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了JavaScript程序的基本构建块。现在你已知以下原始数据类型：
- en: Number
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Undefined
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: 'Null'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: 'You also know quite a few operators, which are as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解了很多运算符，如下所示：
- en: '**Arithmetic operators**: `+`, `-`, `*`, `/`, and `%`'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术运算符**：`+`, `-`, `*`, `/`, 和 `%`'
- en: '**Increment operators**: `++` and `-`'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量运算符**：`++` 和 `-`'
- en: '**Assignment operators**: `=`, `+=`, `-=`, `*=`, `/=`, and `%=`'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赋值运算符**：`=`, `+=`, `-=`, `*=`, `/=`, 和 `%=` '
- en: '**Special operators**: `typeof` and `delete`'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊运算符**：`typeof` 和 `delete`'
- en: '**Logical operators**: `&&`, `||`, and `!`'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑运算符**：`&&`, `||`, 和 `!`'
- en: '**Comparison operators**: `==`, `===`, `!=`, `!==`, `<`, `>`, `>=`, and `<=`'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较运算符**：`==`, `===`, `!=`, `!==`, `<`, `>`, `>=`, 和 `<=`'
- en: '**The ternary operator**: `?`'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三元运算符**：`?`'
- en: Then you learned how to use arrays to store and access data, and finally you
    saw different ways to control the flow of your program using conditions (`if...else`
    or `switch`) and loops (`while`, `do...while`, `for`, and `for...in`).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你学习了如何使用数组来存储和访问数据，最后你看到了使用条件（`if...else` 或 `switch`）和循环（`while`, `do...while`,
    `for`, 和 `for...in`）来控制程序流程的不同方法。
- en: This is quite a bit of information; give yourself a well-deserved pat on the
    back before diving into the next chapter. More fun is coming up!
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一大堆信息了；在进入下一章之前，给自己一个应得的掌声。更多乐趣即将到来！
