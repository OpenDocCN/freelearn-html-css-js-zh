- en: REST – What You Did Not Know
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST – 你不知道的
- en: Over the last few years, we have started taking for granted that data sources
    feeding for content, mobile device service feeds, or cloud computing are all driven
    by modern technologies, such as RESTful web services. Everybody has been talking
    about how their stateless model allows applications to scale easily and how it emphasizes
    on clear decoupling between data provisioning and data consumption. Nowadays,
    architects have started introducing the concept of microservices, aiming to reduce
    the complexity in systems by splitting their core components into small independent
    pieces that simply do a single task. So, enterprise-grade software is about to
    become a composite of such microservices. This makes it easy to maintain, and
    allows better life cycle management when new parts need to be introduced. Unsurprisingly,
    most of the microservices are serviced by RESTful frameworks. This fact may leave
    the impression that REST was invented sometime in the last decade, but that is
    far from the truth. In fact, REST has been around since the last decade of the
    previous century!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，我们已经开始认为数据源为内容、移动设备服务源或云计算提供动力都是现代技术，如 RESTful Web 服务驱动的。每个人都谈论他们的无状态模型如何使应用程序易于扩展，以及它如何强调数据提供与数据消费之间的清晰解耦。如今，架构师们已经开始引入微服务概念，目的是通过将核心组件拆分为执行单一任务的小型独立部分来降低系统的复杂性。因此，企业级软件即将成为此类微服务的组合。这使得维护变得容易，并在需要引入新部分时允许更好的生命周期管理。不出所料，大多数微服务都是由
    RESTful 框架提供的。这一事实可能会给人留下印象，认为 REST 是在上个十年中的某个时候发明的，但事实远非如此。实际上，REST 自上个世纪的最后十年起就已经存在了！
- en: This chapter will walk you through the foundation of **Representational State
    Transfer** (**REST**) and will explain how REST couples with the HTTP protocol.
    You will look into five key principles that have to be considered while turning
    any HTTP application into a RESTful service-enabled application. You will also
    look at the differences between describing RESTful and classic **Simple Object
    Access Protocol** (**SOAP**)-based web services. Finally, you will learn how to
    utilize already-existing infrastructure for your benefit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您了解 **表征状态转移** (**REST**) 的基础，并解释 REST 如何与 HTTP 协议相结合。您将探讨在将任何 HTTP 应用程序转换为
    RESTful 服务启用应用程序时必须考虑的五个关键原则。您还将了解描述 RESTful 和基于经典 **简单对象访问协议** (**SOAP**) 的 Web
    服务之间的区别。最后，您将学习如何利用现有的基础设施来造福自己。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: REST fundamentals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 基础知识
- en: REST with HTTP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 的 REST
- en: Essential differences in the description, discovery, and documentation of RESTful
    services compared to classical SOAP-based services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与经典 SOAP 基于服务相比，在描述、发现和文档化 RESTful 服务方面的基本差异
- en: Taking advantage of existing infrastructure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用现有基础设施
- en: REST fundamentals
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 基础知识
- en: 'It actually happened back in 1999, when a request for comments was submitted
    to the **Internet Engineering Task Force (IETF;** [http://www.ietf.org/](http://www.ietf.org/))
    via RFC 2616: *Hypertext Transfer Protocol-HTTP/1.1*. One of its authors, Roy
    Fielding, later defined a set of principles built around the HTTP and URI standards.
    This gave birth to REST as we know it today.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上发生在 1999 年，当时通过 RFC 2616 向 **互联网工程任务组 (IETF;** [http://www.ietf.org/](http://www.ietf.org/))
    提交了一个评论请求：*超文本传输协议-HTTP/1.1*。其作者之一，罗伊·菲尔德，后来定义了一套围绕 HTTP 和 URI 标准的原则。这诞生了我们今天所知道的
    REST。
- en: These definitions were given in [https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf ](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf)in
    the fifth chapter, *Representational State Transfer (REST)*, of Fielding's dissertation
    called *Architectural Styles and the Design of Network-Based Software Architectures*.
    The dissertation is still available at [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义在菲尔德的论文《网络软件架构的设计与架构风格》的第五章，*表征状态转移 (REST)* 中给出，该论文的标题为 *Architectural Styles
    and the Design of Network-Based Software Architectures*。这篇论文仍然可在 [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
    上找到。
- en: 'Let''s look at the key principles around the HTTP and URI standards, sticking
    to which will make your HTTP application a RESTful service-enabled application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看围绕HTTP和URI标准的关键原则，坚持这些原则将使您的HTTP应用程序成为一个支持RESTful服务的应用程序：
- en: Everything is a resource
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切都是资源
- en: Each resource is identifiable by a **unique identifier** (**URI**)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个资源都有一个**唯一的标识符**（**URI**）
- en: Resources are manipulated via standard HTTP methods
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源通过标准HTTP方法进行操作
- en: Resources can have multiple representations
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源可以有多个表示形式
- en: Communicate with resources in a stateless manner
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以无状态的方式与资源进行通信
- en: Principle 1 – Everything is a resource
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则1 – 一切都是资源
- en: 'To understand this principle, one must conceive of the idea of representing
    data by a specific format and not by a physical file containing a bunch of bytes.
    Each piece of data available on the internet has a format that describes it, known
    as the content type; for example, JPEG images, MPEG videos, HTML, XML, text documents,
    and binary data are all resources with the following content types: image/jpeg,
    video/mpeg, text/html, text/xml, and application/octet-stream.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个原则，必须设想通过特定的格式来表示数据，而不是通过包含大量字节的物理文件。互联网上可用的每一份数据都有一个描述它的格式，称为内容类型；例如，JPEG图像、MPEG视频、HTML、XML、文本文档和二进制数据都是具有以下内容类型的资源：image/jpeg、video/mpeg、text/html、text/xml和application/octet-stream。
- en: Principle 2 – Each resource is identifiable by a unique identifier
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则2 – 每个资源都有一个唯一的标识符
- en: Since the internet contains so many different resources, they all should be
    accessible via URIs and should be identified uniquely. Furthermore, the URIs can
    be in a human-readable format, despite the fact that their consumers are more
    likely to be software programs rather than ordinary humans.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于互联网包含如此多的不同资源，它们都应该可以通过URI访问，并且应该具有唯一的标识。此外，尽管它们的消费者更有可能是软件程序而不是普通人类，但这些URI可以以人类可读的格式存在。
- en: Human-readable URIs keep data self-descriptive and ease further development
    against it. This helps you to keep the risk of logical errors in your programs
    to a minimum.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 人类可读的URI使数据自我描述，并简化了对其的进一步开发。这有助于您将程序中的逻辑错误风险降到最低。
- en: 'Here are a few sample examples of such URIs representing different resources
    in a catalog application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些此类URI的示例，它们在目录应用程序中表示不同的资源：
- en: '[http://www.mycatalog.com/categories/watches](http://www.mycatalog.com/categories/watches)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.mycatalog.com/categories/watches](http://www.mycatalog.com/categories/watches)'
- en: '[http://www.mycatalog.com/categories/watches?collection=2018](http://www.mycatalog.com/categories/watches?collection=2018)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.mycatalog.com/categories/watches?collection=2018](http://www.mycatalog.com/categories/watches?collection=2018)'
- en: '[http://www.mycatalog.com/categories/watches/model-xyz/image](http://www.mycatalog.com/categories/watches/model-xyz/image)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.mycatalog.com/categories/watches/model-xyz/image](http://www.mycatalog.com/categories/watches/model-xyz/image)'
- en: '[http://www.mycatalog.com/categories/watches/model-xyz/video](http://www.mycatalog.com/categories/watches/model-xyz/video)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.mycatalog.com/categories/watches/model-xyz/video](http://www.mycatalog.com/categories/watches/model-xyz/video)'
- en: '[http://www.mycatalog.com/archives/2017/categories/watches.zip](http://www.mycatalog.com/archives/2017/categories/watches.zip)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.mycatalog.com/archives/2017/categories/watches.zip](http://www.mycatalog.com/archives/2017/categories/watches.zip)'
- en: 'These human-readable URIs expose different types of resources in a straightforward
    manner. In the preceding example URIs, it is quite clear the data is items in
    a catalog, which are categorized watches. The first link shows all the items in
    the category. The second shows only the ones that are part of the 2018 collection.
    Next is a link pointing to the image of the item, followed by a link to a sample
    video. The last link points to a resource containing items from the previous collection
    in a ZIP archive. The media types served per each URI are rather easy to identify,
    with the assumption that the data format of an item is either JSON or XML, so
    we can easily map the media type of a self-described URL to one of the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人类可读的URI以直接的方式揭示了不同类型的资源。在先前的示例URI中，数据是目录中的项目，这些项目被归类为手表。第一个链接显示了该类别的所有项目。第二个链接只显示2018系列中的项目。接下来是一个指向项目图片的链接，然后是一个指向示例视频的链接。最后一个链接指向一个包含前一个系列项目的ZIP存档的资源。每个URI提供的媒体类型很容易识别，假设项目的数据格式是JSON或XML，因此我们可以轻松地将自描述URL的媒体类型映射到以下之一：
- en: JSON or XML documents describing the items
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述项目的JSON或XML文档
- en: Images
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Videos
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频
- en: Binary archive documents
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制存档文档
- en: Principle 3 – Manipulate resources via standard HTTP methods
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则 3 – 通过标准 HTTP 方法操作资源
- en: 'The native HTTP protocol (RFC 2616) defines eight actions, also known as HTTP
    verbs:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 HTTP 协议（RFC 2616）定义了八个动作，也称为 HTTP 动词：
- en: '`GET`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`POST`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: '`DELETE`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: '`HEAD`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`'
- en: '`OPTIONS`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`'
- en: '`TRACE`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`'
- en: '`CONNECT`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONNECT`'
- en: 'The first four of them just feel natural in the context of resources, especially
    when defining actions for data manipulation. Let''s make a parallel with relative
    SQL databases where the native language for data manipulation is **CRUD** (short
    for **Create, Read, Update, and Delete**), originating from the different types
    of SQL statements, `INSERT`, `SELECT`, `UPDATE`, and `DELETE`, respectively. In
    the same manner, if you apply the REST principles correctly, the HTTP verbs should
    be used as shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的前四个在资源上下文中感觉自然，尤其是在定义数据操作的动作时。让我们将它们与相对 SQL 数据库进行比较，在 SQL 数据库中，数据操作的原生语言是
    **CRUD**（代表 **Create, Read, Update, and Delete**），分别源自不同的 SQL 语句类型，`INSERT`，`SELECT`，`UPDATE`
    和 `DELETE`。同样，如果您正确应用 REST 原则，HTTP 动词应按以下方式使用：
- en: '| **HTTP verb** | **Action** | **HTTP response status code** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 动词** | **动作** | **HTTP 响应状态码** |'
- en: '| `GET` | Retrieves an existing resource. | `200 OK` if the resource exists,
    `404 Not Found` if it does not exist, and `500 Internal Server Error` for other
    errors. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 获取现有资源。| `200 OK` 如果资源存在，`404 Not Found` 如果不存在，以及 `500 Internal Server
    Error` 对于其他错误。|'
- en: '| `PUT` | Updates a resource. If the resource does not exist, the server can
    either decide to create it with the provided identifer or return the appropriate
    status code. | `200 OK` if successfully updated, `201 Created` if a new resource
    is created, `404 Not found` if the resource to be updated does not exist, and `500
    Internal Server Error` for other unexpected errors. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 更新资源。如果资源不存在，服务器可以决定使用提供的标识符创建它，或者返回适当的状态码。| `200 OK` 如果成功更新，`201
    Created` 如果创建了新资源，`404 Not found` 如果要更新的资源不存在，以及 `500 Internal Server Error` 对于其他意外错误。|'
- en: '| `POST` | Creates a resource with an identifier generated at server side or
    updates a resource with an existing identifier provided from the client. If this
    verb is to be used only for creating but not for updating, return the appropriate
    status code. | `201 CREATED` if a new resource is created, `200 OK` if the resource
    has been updated successfully, `409 Conflict` if the resource already exists and
    update is not allowed, `404 Not Found` if the resource to be updated does not
    exist, and `500 Internal Server Error` for other errors. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 在服务器端生成标识符或使用客户端提供的现有标识符创建资源，或更新资源。如果此动词仅用于创建而不用于更新，则返回适当的状态码。|
    `201 CREATED` 如果创建了新资源，`200 OK` 如果资源已成功更新，`409 Conflict` 如果资源已存在且不允许更新，`404 Not
    Found` 如果要更新的资源不存在，以及 `500 Internal Server Error` 对于其他错误。|'
- en: '| `DELETE` | Deletes a resource. | `200 OK` or `204 No Content` if the resource
    has been deleted successfully, `404 Not Found` if the resource to be deleted does
    not exist, and `500 Internal Server Error` for other errors. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除资源。| `200 OK` 或 `204 No Content` 如果资源已成功删除，`404 Not Found` 如果要删除的资源不存在，以及
    `500 Internal Server Error` 对于其他错误。|'
- en: 'Note that a resource might be created by either the `POST` or `PUT` HTTP verbs,
    based on the policy of an application. However, if a resource has to be created
    under a specific URI with an identifier provided by the client, then `PUT` is
    the appropriate action:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，资源可能通过 `POST` 或 `PUT` HTTP 动词创建，这取决于应用程序的策略。然而，如果资源必须在客户端提供的特定 URI 下创建，并且提供标识符，那么
    `PUT` 是适当的操作：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, in your application, you may want to leave it up to the backend RESTful
    service to decide where to expose the newly created resource, and thus create
    it under an appropriate but still unknown or non-existent location.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在您的应用程序中，您可能希望将决定新创建资源暴露位置的任务留给后端 RESTful 服务，因此在新适当但未知或不存在的位置下创建它。
- en: 'For instance, in our example, we might want the server to define the identifier
    of newly created items. In such cases, just use the `POST` verb to a URL without
    providing an identifier parameter. Then it is up to the service itself to provide
    a new unique and valid identifier for the new resource and to expose back this
    URL via the `Location` header of the response:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的示例中，我们可能希望服务器定义新创建项的标识符。在这种情况下，只需向 URL 发送 `POST` 动词，而不提供标识符参数。然后，服务本身负责提供新资源的唯一有效标识符，并通过响应的
    `Location` 标头公开此 URL：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Principle 4 – Resources can have multiple representations
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则4 – 资源可以有多个表示
- en: 'A key feature of a resource is that it may be represented in a different format
    from the one in which it is stored. Thus, it can be requested or created in different
    representations. As long as the specified format is supported, the REST-enabled
    endpoint should use it. In the preceding example, we posted an XML representation
    of a watch item, but if the server had supported the JSON format, the following
    request would have been valid as well:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的一个关键特性是它可能以不同于存储格式的格式表示。因此，它可以以不同的表示形式请求或创建。只要指定的格式得到支持，启用REST的端点应该使用它。在先前的示例中，我们发布了一个手表项目的XML表示，但如果服务器支持JSON格式，以下请求也是有效的：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Principle 5 – Communicate with resources in a stateless manner
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则5 – 以无状态方式与资源通信
- en: Resource manipulation operations through HTTP requests should always be considered
    atomic. All modifications of a resource should be carried out within an HTTP request
    in an isolated manner. After the request execution, the resource is left in a
    final state; this implicitly means that partial resource updates are not supported.
    You should always send the complete state of the resource.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP请求进行的资源操作应始终被视为原子操作。对资源的所有修改都应在HTTP请求中独立进行。请求执行后，资源将处于最终状态；这隐含地意味着不支持部分资源更新。你应该始终发送资源的完整状态。
- en: Back to our catalog example, updating the price field of a given item would
    mean making a PUT request with a complete document (JSON or XML) that contains
    the entire data, including the updated price field. Posting only the updated price
    is not stateless, as it implies that the application is aware that the resource
    has a price field, that is, it knows its state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的目录示例，更新某个项目的价格字段意味着发送一个包含整个数据（JSON或XML格式）的完整文档的PUT请求，其中包括更新的价格字段。仅发送更新的价格不是无状态的，因为它意味着应用程序知道资源有一个价格字段，即它知道其状态。
- en: Another requirement for your RESTful application to be stateless is that once
    the service gets deployed on a production environment, it is likely that incoming
    requests are served by a load balancer, ensuring scalability and high availability.
    Once exposed via a load balancer, the idea of keeping your application state at
    server side gets compromised. This doesn't mean that you are not allowed to keep
    the state of your application. It just means that you should keep it in a RESTful
    way. For example, keep a part of the state within the URI, or use HTTP headers
    to provide additional state-related data
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你的RESTful应用程序要实现无状态，另一个要求是在服务部署到生产环境后，传入的请求很可能由负载均衡器提供服务，确保可扩展性和高可用性。一旦通过负载均衡器暴露，保持应用程序状态在服务器端的想法就会受到损害。这并不意味着你不允许保持应用程序的状态。这仅仅意味着你应该以RESTful的方式保持它。例如，将部分状态保留在URI中，或使用HTTP头提供额外的状态相关数据。
- en: The statelessness of your RESTful API isolates the caller against changes at
    the server side. Thus, the caller is not expected to communicate with the same
    server in consecutive requests. This allows easy application of changes within
    the server infrastructure, such as adding or removing nodes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你的RESTful API的无状态特性将调用者与服务器端的变更隔离开来。因此，调用者不需要在连续的请求中使用相同的服务器。这允许在服务器基础设施中轻松应用变更，例如添加或删除节点。
- en: Remember that it is your responsibility to keep your RESTful APIs stateless,
    as the consumers of the APIs would expect them to be.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，保持你的RESTful API无状态是你的责任，因为API的消费者期望它们是无状态的。
- en: Now that you know that REST is around 18 years old, a sensible question would
    be, "Why has it become so popular just quite recently?" Well, we the developers
    usually reject simple, straightforward approaches and, most of the time, prefer
    spending more time on turning already-complex solutions into even more complex
    and sophisticated ones.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道REST大约有18年的历史了，一个合理的问题可能是，“为什么它最近才变得如此流行？”好吧，我们作为开发者通常拒绝简单直接的方法，并且大多数时候，我们更喜欢花更多的时间将已经复杂的解决方案变得更加复杂和精致。
- en: Take classical SOAP web services, for example. Their various WS-* specifications
    are so many, and sometimes so loosely defined, that in order to make different
    solutions from different vendors interoperable, a separate specification, WS-Basic
    Profile, has been introduced. It defines extra interoperability rules in order
    to ensure that all WS-* specifications in SOAP-based web services can work together.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以经典的SOAP Web服务为例。它们的WS-*规范如此之多，有时定义得如此宽松，以至于为了使不同供应商的不同解决方案互操作，已经引入了一个单独的规范，即WS-Basic
    Profile。它定义了额外的互操作性规则，以确保基于SOAP的Web服务中的所有WS-*规范可以协同工作。
- en: When it comes to transporting binary data with classical web services over HTTP,
    things get even more complex, as SOAP-based web services provide different ways
    of transporting binary data. Each way is defined in other sets of specifications,
    such as **SOAP with** **Attachment References** (**SwaRef**) and **Message Transmission**
    **Optimization Mechanism (MTOM).** All this complexity was caused mainly because
    the initial idea of the web service was to execute business logic remotely, not
    to transport large amounts of data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到通过HTTP使用经典Web服务传输二进制数据时，事情变得更加复杂，因为基于SOAP的Web服务提供了不同的二进制数据传输方式。每种方式都在其他规范集中定义，例如**带有附件引用的SOAP**（**SwaRef**）和**消息传输优化机制（MTOM**）。所有这些复杂性主要是由于最初的想法是将业务逻辑远程执行，而不是传输大量数据。
- en: The real world has shown us that, when it comes to data transfer, things should
    not be that complex. This is where REST fits into the big picture—by introducing
    the concept of resources and a standard means for manipulating them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界已经向我们表明，在数据传输方面，事情不应该那么复杂。这就是REST在整体画面中发挥作用的地方——通过引入资源的概念和操作它们的标准方法。
- en: The REST goals
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST目标
- en: 'Now that we''ve covered the main REST principles, it is time to dive deeper
    into what can be achieved when they are followed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了主要的REST原则，是时候深入了解遵循它们时可以取得什么成果了：
- en: Separation of the representation and the resource
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示形式与资源的分离
- en: Visibility
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性
- en: Reliability
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性
- en: Scalability
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Performance
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Separation of the representation and the resource
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示形式与资源的分离
- en: 'A resource is just a set of information, and as defined by principle 4, it
    can have multiple representations; however, its state is atomic. It is up to the
    caller to specify the desired media type with the `Accept` header in the HTTP
    request, and then it is up to the server application to handle the representation
    accordingly, returning the appropriate content type of the resource together with
    a relevant HTTP status code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 资源只是一组信息，根据第4条原则，它可以有多种表示形式；然而，其状态是原子的。指定所需的媒体类型是调用者的责任，在HTTP请求中使用`Accept`头，然后服务器应用程序相应地处理表示形式，返回资源的适当内容类型以及相关的HTTP状态码：
- en: '`HTTP 200 OK` in the case of success'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时返回`HTTP 200 OK`
- en: '`HTTP 400 Bad Request` if an unsupported format is given or for any other invalid
    request information'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给出不支持格式或任何其他无效请求信息，则返回`HTTP 400 Bad Request`
- en: '`HTTP 406 Not Acceptable` if an unsupported media type is requested'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求不支持的媒体类型，则返回`HTTP 406 Not Acceptable`
- en: '`HTTP 500 Internal Server Error` when something unexpected happens during the
    request processing'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求处理过程中发生意外情况时，返回`HTTP 500 Internal Server Error`
- en: Let's assume that, at server side, we have items resources stored in an XML
    format. We can have an API that allows a consumer to request the item resources
    in various formats, such as `application/xml`, `application/json`, `application/zip`,
    `application/octet-stream`, and so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在服务器端以XML格式存储项目资源。我们可以有一个API，允许消费者以各种格式请求项目资源，例如`application/xml`、`application/json`、`application/zip`、`application/octet-stream`等。
- en: It would be up to the API itself to load the requested resource, transform it
    into the requested type (for example, JSON or XML), and either use ZIP to compress
    it or directly flush it to the HTTP response output.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: API本身将负责加载请求的资源，将其转换为请求的类型（例如，JSON或XML），然后使用ZIP进行压缩或直接将其刷新到HTTP响应输出。
- en: 'The caller would make use of the `Accept` HTTP header to specify the media
    type of the response they expect. So, if we want to request our item data inserted
    in the previous section in XML format, the following request should be executed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者将使用`Accept` HTTP头指定他们期望的媒体类型。因此，如果我们想以前面章节中插入的项目数据请求XML格式，应执行以下请求：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To request the same item in JSON format, the `Accept` header needs to be set
    to `application/json`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要以 JSON 格式请求相同的项，需要将 `Accept` 标头设置为 `application/json`：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Visibility
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性
- en: REST is designed to be visible and simple. Visibility of the service means that
    every aspect of it should self-descriptive and follow the natural HTTP language
    according to principles 3, 4, and 5.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: REST 被设计成可见和简单。服务的可见性意味着它的各个方面都应该具有自描述性，并遵循原则 3、4 和 5 的自然 HTTP 语言。
- en: Visibility in the context of the outer world would mean that monitoring applications
    would be interested only in the HTTP communication between the REST service and
    the caller. Since the requests and responses are stateless and atomic, nothing
    more is needed to flow the behavior of the application and to understand whether
    anything has gone wrong.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部世界的上下文中，可见性意味着监控应用程序只会对 REST 服务和调用者之间的 HTTP 通信感兴趣。由于请求和响应是无状态的且是原子的，不需要更多的信息来流应用程序的行为以及了解是否出现了错误。
- en: Remember that caching reduces the visibility of your RESTful applications and
    in general should be avoided, unless needed for serving resources subject to large
    amounts of callers. In such cases, caching may be an option, after carefully evaluating
    the possible consequences of serving obsolete data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，缓存会降低你的 RESTful 应用程序的可见性，通常应该避免，除非需要为大量调用者提供资源。在这种情况下，缓存可能是一个选项，但需要在仔细评估提供过时数据可能产生的后果后才能考虑。
- en: Reliability
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性
- en: 'Before talking about reliability, we need to define which HTTP methods are
    safe and which are idempotent in the REST context. So, let''s first define what
    safe and idempotent methods are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论可靠性之前，我们需要定义在 REST 上下文中哪些 HTTP 方法是安全的，哪些是幂等的。因此，让我们首先定义什么是安全方法和幂等方法：
- en: An HTTP method is considered to be safe provided that, when requested, it does
    not modify or cause any side effects on the state of the resource
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 HTTP 方法被认为是安全的，如果请求时它不会修改或对资源的任何状态产生任何副作用
- en: An HTTP method is considered to be idempotent if its response stays the same,
    regardless of the number of times it is requested, am idempotent request always
    gives back the same request, if repeated identically.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 HTTP 方法被认为是幂等的，如果它的响应在请求次数无论多少的情况下都保持不变，幂等请求在重复时总是返回相同的请求。
- en: 'The following table lists which HTTP methods are safe and which are idempotent:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了哪些 HTTP 方法是安全的，哪些是幂等的：
- en: '| **HTTP method** | **Safe** | **Idempotent** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 方法** | **安全** | **幂等** |'
- en: '| `GET` | Yes | Yes |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 是 | 是 |'
- en: '| `POST` | No | No |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 否 | 否 |'
- en: '| `PUT` | No | Yes |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 否 | 是 |'
- en: '| `DELETE` | No | Yes |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 否 | 是 |'
- en: Consumers should consider operation's safety and the idempotence features in
    order to be served reliably.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者应该考虑操作的安全性以及幂等特性，以确保可靠的服务。
- en: Scalability and performance
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性和性能
- en: So far, we stressed the importance of having stateless behavior for a RESTful
    web application. The **World Wide Web** (**WWW**) is an enormous universe, containing
    huge amount of data and a lot of users, eager to get that data. The evolution
    of the WWW has brought the requirement that applications should scale easily as
    their load increases. Scaling applications that have a state is difficult to achieve,
    especially when zero or close-to-zero operational downtime is expected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们强调了在 RESTful 网络应用程序中拥有无状态行为的重要性。万维网（**WWW**）是一个巨大的宇宙，包含大量数据和众多用户，他们渴望获取这些数据。万维网的演变带来了应用程序应该容易扩展以适应其负载增加的要求。具有状态的扩展应用程序很难实现，尤其是在期望零或接近零的运营中断时间的情况下。
- en: That's why staying stateless is crucial for any application that needs to scale.
    In the best-case scenario, scaling your application would require you to put another
    piece of hardware for a load balancer, or bring another instance in your cloud
    environment. There would be no need for the different nodes to sync between each
    other, as they should not care about the state at all. Scalability is all about
    serving all your clients in an acceptable amount of time. Its main idea is to
    keep your application running and to prevent **Denial of Service** (**DoS**) caused
    by a huge amount of incoming requests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么保持无状态对于任何需要扩展的应用程序来说至关重要。在最佳情况下，扩展你的应用程序可能需要你为负载均衡器添加另一块硬件，或者在云环境中添加另一个实例。不同的节点之间不需要同步，因为它们根本不需要关心状态。可扩展性完全是关于在可接受的时间内为所有客户端提供服务。其主要思想是保持应用程序运行，并防止由大量传入请求引起的
    **拒绝服务**（**DoS**）。
- en: Scalability should not be confused with the performance of an application. Performance
    is measured by the time needed for a single request to be processed, not by the
    total number of requests that the application can handle. The asynchronous non-blocking
    architecture and event-driven design of Node.js make it a logical choice for implementing
    an application that scales and performs well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性不应与应用程序的性能混淆。性能是通过处理单个请求所需的时间来衡量的，而不是应用程序可以处理的请求数量。Node.js 的异步非阻塞架构和事件驱动设计使其成为实现可扩展且性能良好的应用程序的合理选择。
- en: Working with WADL
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 WADL 一起工作
- en: If you are familiar with SOAP web services, you may have heard of the **Web
    Service Definition Language** (**WSDL**). It is an XML description of the interface
    of the service and defines an endpoint URL for invocation. It is mandatory for
    a SOAP web service to be described by such a WSDL definition.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 SOAP 网络服务，您可能听说过 **Web 服务定义语言** (**WSDL**)。它是对服务接口的 XML 描述，并定义了一个调用端点的
    URL。对于 SOAP 网络服务来说，有一个这样的 WSDL 定义是强制性的。
- en: Similar to SOAP web services, RESTful services can also make use of a description
    language, called WADL. **WADL** stands for **Web Application Definition Language**.
    Unlike WSDL for SOAP web services, a WADL description of a RESTful service is
    optional, that is, consuming the service has nothing to do with its description.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SOAP 网络服务类似，RESTful 服务也可以使用一种称为 WADL 的描述语言。**WADL** 代表 **Web 应用定义语言**。与用于
    SOAP 网络服务的 WSDL 不同，RESTful 服务的 WADL 描述是可选的，也就是说，使用服务与其描述无关。
- en: 'Here is a sample part of a WADL file that describes the `GET` operation of
    our catalog service:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 WADL 文件的一个示例部分，描述了我们的目录服务的 `GET` 操作：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This extract of a WADL file shows how application, exposing resources is described.
    Briefly, each resource must be part of an application. The resource provides a,
    where it is located with the `base` attribute, and describes each of its supported
    HTTP methods in a method. Additionally, an optional `doc` element can be used
    at resource and application to provide additional documentation about the service
    and its operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 WADL 文件的摘录展示了如何描述暴露资源的应用程序。简而言之，每个资源都必须是应用程序的一部分。资源通过 `base` 属性提供其位置，并在方法中描述其支持的每个
    HTTP 方法。此外，可以在资源和应用程序中使用可选的 `doc` 元素，以提供关于服务和其操作的额外文档。
- en: Though WADL is optional, it significantly reduces the efforts of discovering
    RESTful services.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管WADL是可选的，但它显著减少了发现RESTful服务的努力。
- en: Documenting RESTful APIs with Swagger
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swagger 记录 RESTful API
- en: 'Public APIs exposed on the web should be well documented, otherwise it would
    be difficult for developers to use them in their applications. While WADL definitions
    might be considered a source of documentation, they address a different problem—the
    discovery of the service. They serve metadata for the services to machines, not
    to humans. The Swagger project ([https://swagger.io/](https://swagger.io/)) addresses
    the need for neat documentation of RESTful APIs. It defines a meta description
    of an API from an almost human-readable JSON format. The following is a sample
    `swagger.json` file, partially describing the catalog service:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上公开的公共 API 应该有良好的文档，否则开发人员很难在他们的应用程序中使用它们。虽然 WADL 定义可能被认为是文档的来源，但它们解决了一个不同的问题——服务的发现。它们为机器提供服务的元数据，而不是为人类。Swagger
    项目 ([https://swagger.io/](https://swagger.io/)) 解决了 RESTful API 清晰文档的需求。它定义了一个
    API 的元描述，几乎以人类可读的 JSON 格式。以下是一个示例 `swagger.json` 文件，部分描述了目录服务：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `swagger.json` file is really straightforward: it defines a name and version
    of your API and gives a brief description of each operation it exposes, nicely
    coupled with a sample payload. But the real benefit from it comes in another subproject
    of Swagger, called `swagger-ui` ([https://swagger.io/swagger-ui/](https://swagger.io/swagger-ui/)),
    which actually renders this data from `swagger.json` nicely into an interactive
    web page that only provides documentation, but also allows interaction with the
    service:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`swagger.json` 文件非常简单：它定义了您的 API 的名称和版本，并为每个公开的操作提供了简短的描述，并与示例有效负载很好地结合在一起。但从中获得的真正好处来自于
    Swagger 的另一个子项目，称为 `swagger-ui` ([https://swagger.io/swagger-ui/](https://swagger.io/swagger-ui/))，它实际上将
    `swagger.json` 中的数据优雅地渲染成交互式网页，不仅提供文档，还允许与服务交互：'
- en: '![](img/44bb4441-4f88-4d96-93a8-76305dcfac7c.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44bb4441-4f88-4d96-93a8-76305dcfac7c.png)'
- en: We will have a look at and utilize the `swagger-ui` Node.js module to provide
    the API that we will develop later in the book, with up-to-date documentation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看并利用`swagger-ui` Node.js模块来提供本书后面将开发的API，并带有最新的文档。
- en: Taking advantage of the existing infrastructure
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用现有基础设施
- en: The best part of developing and distributing RESTful applications is that the
    infrastructure needed is already out there, available to you. As RESTful applications
    use the existing web space heavily, you need to do nothing more than follow the
    REST principles when developing. In addition, there are plenty of libraries available
    out there for any platform, and I do mean any platform. This eases the development
    of RESTful applications, so you just need to choose your preferred platform and
    start developing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和分发RESTful应用程序的最好部分是所需的基础设施已经存在，可供您使用。由于RESTful应用程序大量使用现有网络空间，您在开发时只需遵循REST原则即可。此外，任何平台都有大量的库可供选择，我确实是指任何平台。这简化了RESTful应用程序的开发，因此您只需选择您偏好的平台并开始开发。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about foundation of a REST, looking at five key
    principles that transform a web application into a REST-enabled application. We
    made a brief comparison between RESTful services and classical SOAP web services,
    and finally took a look at how RESTful services are documented and how we can
    simplify the discovery of the services we develop.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了REST的基础，通过查看将Web应用程序转变为REST启用应用程序的五个关键原则。我们简要比较了RESTful服务和经典SOAP Web服务，并最终探讨了RESTful服务的文档方式以及我们如何简化开发的服务发现。
- en: Now that you know the basics, we are ready to dive into the Node.js way of implementing
    RESTful services. In the next chapter, you will learn about the essentials of
    Node.js and the accompanying tools that it is necessary to use and understand
    in order to build a real-life fully-fledged web service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了基础知识，我们准备深入探讨Node.js实现RESTful服务的方式。在下一章中，您将学习Node.js的必要要素以及构建真实生活完整Web服务时必须使用和理解的配套工具。
