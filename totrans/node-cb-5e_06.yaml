- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Working with Fastify – The Web Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fastify – Web框架
- en: In [*Chapter 4*](B19212_04.xhtml#_idTextAnchor100) , we learned about the low-level
    APIs provided by Node.js core for building web applications. However, using those
    APIs can be challenging sometimes, demanding substantial effort to translate conceptual
    ideas into functional software. For this reason, web frameworks are pivotal for
    quickly developing robust HTTP servers within the Node.js ecosystem. A web framework
    abstracts web protocols into higher-level APIs, allowing you to implement your
    business logic without the need to address everyday tasks, such as parsing the
    body of an HTTP request or reinventing an internal router.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B19212_04.xhtml#_idTextAnchor100)中，我们学习了Node.js核心提供的低级API，用于构建Web应用程序。然而，使用这些API有时可能会具有挑战性，需要大量努力将概念性想法转化为功能性软件。因此，在Node.js生态系统中，Web框架对于快速开发健壮的HTTP服务器至关重要。Web框架将Web协议抽象为高级API，允许你在不需要处理日常任务的情况下实现业务逻辑，例如解析HTTP请求体或重新发明内部路由器。
- en: This chapter introduces Fastify, the fastest web framework with the lowest overhead
    available for Node.js. Fastify places a high emphasis on enhancing the developer’s
    experience, powering you to build APIs while ensuring outstanding application
    performance. It closely adheres to web standards, ensuring compatibility and reliability.
    Moreover, it boasts an impressive degree of extensibility, enabling you to customize
    your server to align precisely with your unique requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Fastify，这是目前Node.js中速度最快且开销最低的Web框架。Fastify高度重视提升开发者的体验，在确保卓越的应用程序性能的同时，帮助你构建API。它紧密遵循Web标准，确保兼容性和可靠性。此外，它具有令人印象深刻的可扩展性，允许你根据独特需求自定义服务器。
- en: 'We will explore Fastify through the following learning path:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下学习路径来探索Fastify：
- en: Creating an API starter using Fastify
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fastify创建API入门
- en: Splitting the code into small plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码拆分为小型插件
- en: Adding routes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加路由
- en: Implementing authentication with hooks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用钩子实现身份验证
- en: Breaking the encapsulation using hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用钩子破坏封装
- en: Implementing the business logic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现业务逻辑
- en: Validating the input data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入数据
- en: Enhancing application performance with serialization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用序列化提高应用程序性能
- en: Configuring and testing a Fastify application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和测试Fastify应用程序
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter successfully, you will need the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成本章，你需要以下内容：
- en: A Node.js v22 installation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Node.js v22
- en: An IDE such as VS Code from [https://code.visualstudio.com/](https://code.visualstudio.com/)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个IDE，例如VS Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
- en: A working command shell with **curl** from [https://curl.se/download.html](https://curl.se/download.html)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有**curl**的运行命令行 ([https://curl.se/download.html](https://curl.se/download.html))
- en: A MongoDB installation from [https://www.mongodb.com/](https://www.mongodb.com/)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://www.mongodb.com/](https://www.mongodb.com/)安装MongoDB
- en: All the snippets in this chapter are on GitHub at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06)
    .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码片段均可在GitHub上找到：[https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06)。
- en: Creating an API starter using Fastify
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fastify创建API入门
- en: '**Fastify** ( [https://fastify.dev/](https://fastify.dev/) ) is a Node.js web
    framework for constructing web applications. It facilitates the development of
    an HTTP server and the creation of your API in a straightforward, efficient, scalable,
    and secure manner. The first Fastify’s stable release dates back to 2018. Since
    then, it has garnered a substantial community, boasting over 7 million monthly
    downloads. Moreover, it maintains a consistent release schedule, with a major
    version update approximately every two years.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fastify** ([https://fastify.dev/](https://fastify.dev/)) 是一个用于构建Web应用程序的Node.js
    Web框架。它简化了HTTP服务器的开发以及API的创建，以简单、高效、可扩展和安全的方式进行。Fastify的第一个稳定版本发布于2018年。从那时起，它已经积累了庞大的社区，每月下载量超过700万。此外，它还保持着一致的发布计划，大约每两年进行一次主要版本更新。'
- en: Because practical experience is often the most effective way to learn, in this
    chapter, we will undertake the implementation of an API server for our brand-new
    fantasy restaurant! Our objectives encompass displaying the menu, allowing the
    chef to add or remove recipes, and enabling guests to place orders that the chef
    will receive and cook!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为实践经验通常是学习最有效的方法，所以在本章中，我们将承担实现我们全新的幻想餐厅 API 服务器的任务！我们的目标包括显示菜单、允许厨师添加或删除食谱，以及允许客人下单，厨师将接收并烹饪！
- en: So, let’s start our hands-on session with Fastify, and at the end of this chapter,
    you will evaluate whether Fastify is simple to use or not!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始我们的 Fastify 实践课程，并在本章结束时，您将评估 Fastify 是否易于使用！
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need to set up the developer environment. To do this, you can create
    a new Node.js project by running the following commands in your terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置开发环境。为此，您可以在终端中运行以下命令来创建一个新的 Node.js 项目：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have initiated the **fastify-restaurant** folder with the installed **fastify**
    module at this stage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经使用安装的 **fastify** 模块初始化了 **fastify-restaurant** 文件夹。
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To build a Fastify server, we need to follow these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个 Fastify 服务器，我们需要遵循以下步骤：
- en: 'Install the **fastify** version 5 module:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **fastify** 版本 5 模块：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new **index.js** file with the following content to import the dependency:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 **index.js** 文件以导入依赖项：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Thanks to the imported dependency, we can instantiate a Fastify instance by
    executing the **fastify** factory function. The **app** constant will be our **root
    application instance** that identifies the Fastify API at your disposal:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多亏了导入的依赖项，我们可以通过执行 **fastify** 工厂函数来实例化一个 Fastify 实例。**app** 常量将是我们 **根应用程序实例**，它标识您可用的
    Fastify API：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that we are passing the **serverOptions** object as an argument. It contains
    the **logger: true** property to turn on the application logger! The **fastify**
    factory accepts many options, which we will see later in this chapter.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '注意，我们正在将 **serverOptions** 对象作为参数传递。它包含 **logger: true** 属性以打开应用程序日志！**fastify**
    工厂接受许多选项，我们将在本章后面看到。'
- en: 'With the **app** instance, we can add routes to the server using the **get()**
    method. The handler returns the payload that we would like to return as a response.
    In this case, we add an HTTP **GET** handler to the **/** endpoint:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **app** 实例，我们可以通过 **get()** 方法向服务器添加路由。处理程序返回我们希望作为响应返回的有效负载。在这种情况下，我们向 **/**
    端点添加一个 HTTP **GET** 处理程序：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We create a **port** variable in order to select where the server listens for
    HTTP requests:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 **port** 变量，以便选择服务器监听 HTTP 请求的位置：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We read the variable from the environment settings or set a default value. This
    is useful because, usually, on the server where we install the application, the
    PORT setting is already set (for example, Heroku).
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从环境设置中读取变量或设置默认值。这很有用，因为通常在我们安装应用程序的服务器上，PORT 设置已经设置（例如，Heroku）。
- en: 'Finally, we can start our server by calling the **listen** method. The **host**
    parameter with the **0.0.0.0** value will configure your server to accept connections
    from any IPv4 address:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过调用 **listen** 方法来启动我们的服务器。具有 **0.0.0.0** 值的 **host** 参数将配置您的服务器以接受来自任何
    IPv4 地址的连接：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This setup is essential for applications running in Docker containers or any
    application directly accessible on the internet. Without this configuration, external
    clients won’t be able to access your HTTP server.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种设置对于在 Docker 容器中运行或任何直接可访问互联网的应用程序至关重要。没有这种配置，外部客户端将无法访问您的 HTTP 服务器。
- en: 'We are now ready to start the server with the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令启动服务器：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you may have noticed, we can see multiple IP addresses where the HTTP server
    is listening. This is due to the **0.0.0.0** host configuration, which listens
    for both the localhost name and the local IP address to handle external calls.
    If we change **0.0.0.0** to **localhost** , our HTTP server will be available
    only from the local PC, printing a single log message.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所注意到的，我们可以看到多个 HTTP 服务器正在监听的 IP 地址。这是由于 **0.0.0.0** 主机配置，它监听本地主机名和本地 IP 地址以处理外部调用。如果我们将
    **0.0.0.0** 更改为 **localhost**，我们的 HTTP 服务器将仅从本地 PC 可用，并打印一条日志消息。
- en: 'The console log tells us that the server has started successfully; therefore,
    if you open a new terminal and run a **curl** command, you will get the following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台日志告诉我们服务器已成功启动；因此，如果您打开一个新的终端并运行 **curl** 命令，您将得到以下结果：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In a few lines of code, you have created a Fastify server with a logger that
    is ready to use and responds with a JSON payload on the **/** route!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在几行代码中，你已经创建了一个带有日志记录器的 Fastify 服务器，该服务器已准备好使用，并且在 **/** 路由上响应 JSON 有效负载！
- en: As we saw, Fastify comes equipped with numerous built-in features, such as the
    application logger, by using the popular Node.js logger **pino** ( [https://getpino.io/](https://getpino.io/)
    ) and an automatic handling JSON format without additional dependencies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Fastify 配备了众多内置功能，例如应用程序日志记录器，通过使用流行的 Node.js 日志记录器 **pino** ([https://getpino.io/](https://getpino.io/))
    和自动处理 JSON 格式，无需额外的依赖项。
- en: In the next recipe, we will refactor the code to start giving shape to our project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将重构代码，开始为我们的项目赋予形状。
- en: Splitting the code into small plugins
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码拆分为小型插件
- en: We implemented the API root endpoint in the *Creating an API starter using Fastify*
    recipe, which is often used as a health check to verify whether the server started
    successfully. However, we can’t keep adding all the application’s routes to the
    **index.js** file; otherwise, it would become unreadable in no time. So, let’s
    split our **index.js** file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *使用 Fastify 创建 API 入门* 菜谱中实现了 API 根端点，这通常用作健康检查，以验证服务器是否成功启动。然而，我们不能不断地将所有应用程序的路由添加到
    **index.js** 文件中；否则，它很快就会变得难以阅读。因此，让我们将我们的 **index.js** 文件拆分。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To split our **index.js** file, follow these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要拆分我们的 **index.js** 文件，请按照以下步骤操作：
- en: 'Create an **app.js** file and move the **serverOptions** constant with the
    following server configuration:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **app.js** 文件，并将以下服务器配置的 **serverOptions** 常量移动到该文件中：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We define our first plugin interface:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义我们的第一个插件接口：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A plugin is an **async** function that accepts two arguments: the first is
    a Fastify server instance, and the second is an **options** object, which is empty
    for now. We will use it later in the *Implementing authentication with hooks*
    recipe. This function may assume a different declaration if it is not an **async**
    function. In this case, there would be a third argument: **function syncAppPlugin(app,
    opts, next){}** ; it is a function that we must call to tell the Fastify framework
    when the plugin is loaded.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 插件是一个接受两个参数的 **async** 函数：第一个是一个 Fastify 服务器实例，第二个是一个 **options** 对象，目前它是空的。我们将在
    *使用钩子实现身份验证* 菜谱中使用它。如果它不是一个 **async** 函数，这个函数可能会有不同的声明。在这种情况下，将会有第三个参数：**function
    syncAppPlugin(app, opts, next){}**；这是一个我们必须调用来告诉 Fastify 框架插件何时加载的函数。
- en: 'Finally, we need to export the plugin function as a default and the server
    configuration as named export options:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将插件函数作为默认导出，将服务器配置作为命名导出选项：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we need to create the **server.js** file as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 **server.js** 文件，如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we need to try out that we have completed the refactoring correctly; you
    can execute the **node server.js** command, and it should initiate the server,
    as it did in the previous *Creating an API starter using* *Fastify* recipe.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要尝试确保我们已经正确完成了重构；您可以执行 **node server.js** 命令，它应该启动服务器，就像在之前的 *使用 Fastify
    创建 API 入门* 菜谱中所做的那样。
- en: We’ve created our initial Fastify plugin in **app.js** .
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 **app.js** 中创建了我们的初始 Fastify 插件。
- en: How it works…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It’s important to note that the intention of this section is not to delve deeply
    into Fastify’s powerful plugin system, which we will explore comprehensively in
    the *Implementing authentication with hooks* recipe. At this juncture, we are
    primarily utilizing it as a tool to organize our code into manageable components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示，本节的目的不是深入探讨 Fastify 强大的插件系统，我们将在 *使用钩子实现身份验证* 菜谱中全面探索它。在此阶段，我们主要利用它作为组织代码为可管理组件的工具。
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **app.js** file serves as the entry point for our application. We have chosen
    to export the recipe’s code in a format that is compatible with **fastify-cli**
    ( [https://github.com/fastify/fastify-cli](https://github.com/fastify/fastify-cli)
    ). This tool is designed to facilitate application startup and enhance our developer
    experience. While we won’t delve into its details in this book, it’s worth noting
    that the code we write here will provide you with the flexibility to transition
    to **fastify-cli** seamlessly, should you choose to do so in the future.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**app.js** 文件作为我们应用程序的入口点。我们选择以与 **fastify-cli** 兼容的格式导出菜谱代码（[https://github.com/fastify/fastify-cli](https://github.com/fastify/fastify-cli)）。这个工具旨在简化应用程序启动并提高我们的开发者体验。虽然我们不会在本书中深入探讨其细节，但值得注意的是，我们在这里编写的代码将为您提供无缝过渡到
    **fastify-cli** 的灵活性，如果您将来选择这样做的话。'
- en: The **server.js** file has a singular purpose; it imports the **app.js** file
    and uses the options object to instantiate the root application instance, as we’ve
    done before in the *Creating an API starter using* *Fastify* recipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**server.js** 文件只有一个目的；它导入 **app.js** 文件并使用选项对象实例化根应用程序实例，就像我们在 *使用 * *Fastify*
    *创建 API 入门* *的食谱中所做的那样。'
- en: The noteworthy addition here is the **register()** method. This Fastify function
    attaches plugins to the Fastify server, ensuring that they are loaded sequentially
    according to the order in which they are registered. After registering a function
    plugin, it is not executed until we execute the **listen()** , **ready()** , or
    **inject()** methods. We will explore the latter two methods in the *Configuring
    and testing a Fastify* *Application* recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的添加是 **register()** 方法。这个 Fastify 函数将插件附加到 Fastify 服务器上，确保它们按照注册的顺序顺序加载。在注册一个函数插件后，它不会执行，直到我们执行
    **listen()** 、 **ready()** 或 **inject()** 方法。我们将在 *配置和测试 Fastify * *应用程序* *的食谱中探讨后两种方法。
- en: This minor refactoring represents a significant step forward, as it bolsters
    our confidence in understanding the Fastify plugin interface. Moreover, it neatly
    separates the business logic from the technical task of launching the web server.
    As a result, the **server.js** file will never change, allowing us to focus on
    the **app.js** file exclusively.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的微小重构代表了一个重要的进步，因为它增强了我们对 Fastify 插件接口的理解。此外，它巧妙地将业务逻辑与启动网络服务器的技术任务分开。因此，**server.js**
    文件将不再改变，使我们能够专注于**app.js** 文件。
- en: We will add our initial business logic routes in the forthcoming recipe, so
    stay tuned!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的食谱中添加我们的初始业务逻辑路由，所以请保持关注！
- en: Adding routes
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由
- en: 'To specify how the application responds to client requests, routes must be
    defined. Each route is identified mainly by an HTTP method and a URL pattern,
    which must align with the incoming request to execute the associated handler function.
    We are currently exposing only one single route: **GET /** . If you try to hit
    a different endpoint, you will receive a **404 Not** **Found** response:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定应用程序如何响应用户请求，必须定义路由。每个路由主要通过 HTTP 方法和一个 URL 模式来标识，这些必须与传入的请求相匹配以执行相关处理器函数。我们目前只公开了一个单独的路由：**GET
    /** 。如果你尝试访问不同的端点，你将收到 **404 Not** **Found** 响应：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Fastify automatically handles 404 responses. When a client attempts to access
    a non-existent route, Fastify will generate and send a 404 response by default.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Fastify 自动处理 404 响应。当客户端尝试访问不存在的路由时，Fastify 将默认生成并发送 404 响应。
- en: 'As we’re developing a web server to provide APIs for our fantasy restaurant,
    it’s essential to outline the routes we need to implement in order to fulfill
    our objectives. Some of the necessary routes may include the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在开发一个网络服务器以提供我们幻想餐厅的 API，因此概述我们需要实现的路由以实现我们的目标至关重要。一些必要的路由可能包括以下内容：
- en: '**GET /menu** : Retrieves the restaurant’s menu'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /menu** : 检索餐厅的菜单'
- en: '**GET /recipes** : This replies with the same logic as the **GET /** **menu**
    handler'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /recipes** : 与 **GET /** **menu** 处理器相同的逻辑进行响应'
- en: '**POST /recipes** : Enables the chef to add a new dish to the menu'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST /recipes** : 允许厨师向菜单添加新菜品'
- en: '**DELETE /recipes/:id** : Allows the chef to remove a recipe from the menu'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE /recipes/:id** : 允许厨师从菜单中删除一个菜谱'
- en: '**POST /orders** : Allows guests to place orders for dishes'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST /orders** : 允许客人点菜'
- en: '**GET /orders** : Returns a list of the pending orders'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET /orders** : 返回待处理订单列表'
- en: '**PATCH /orders/:orderId** : Enables the chef to update the status of an order'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH /orders/:orderId** : 允许厨师更新订单状态'
- en: 'To implement all these routes effectively, we should follow an iterative approach,
    continuously enhancing our code with each iteration. The steps for our development
    process will be as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地实现所有这些路由，我们应该遵循迭代方法，在每次迭代中持续增强我们的代码。我们的开发流程步骤如下：
- en: '**Define the route handlers** : Begin by defining the route with an empty handler.
    We will cover it in this recipe.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义路由处理器** : 首先通过一个空处理器定义路由。我们将在本食谱中介绍它。'
- en: '**Implement route logic** : Incorporate the necessary logic within your route
    handlers to handle tasks, such as retrieving the menu, adding new menu items,
    processing orders, and updating order statuses. We will do this in the *Implementing
    authentication with* *hooks* recipe.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现路由逻辑** : 在你的路由处理器中包含必要的逻辑以处理任务，例如检索菜单、添加新菜单项、处理订单和更新订单状态。我们将在 *使用 * *hooks*
    *实现身份验证* *的食谱中这样做。'
- en: '**Validation and error handling** : Implement validation checks to ensure that
    incoming data are accurate and handle errors gracefully by providing informative
    error messages and appropriate HTTP status codes.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证和错误处理**：实现验证检查以确保传入的数据准确无误，并通过提供有信息性的错误消息和适当的HTTP状态码来优雅地处理错误。'
- en: '**Testing** : Thoroughly test each route to confirm that it functions as expected.
    Consider various scenarios, including valid and invalid input. We will cover this
    in the *Configuring and testing a Fastify* *application* recipe.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试**：彻底测试每个路由以确认其按预期工作。考虑各种场景，包括有效和无效的输入。我们将在 *配置和测试Fastify应用程序* 菜谱中介绍这一点。'
- en: '**Documentation** : We must not forget to write up a comprehensive **README.md**
    file within our source code to ease our team’s work.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文档**：我们绝不能忘记在我们的源代码中编写一个全面的 **README.md** 文件，以简化我们团队的工作。'
- en: So, let’s begin with the first step.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从第一步开始。
- en: How to do it…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can discern two primary entities within our set of endpoints: **recipes**
    and **orders** . For defining route handlers, follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的端点集中，我们可以区分两个主要实体：**recipes** 和 **orders**。对于定义路由处理程序，请遵循以下步骤：
- en: To enhance code organization, we’ll create two distinct files, with one for
    each entity. Additionally, to maintain a structured approach, we’ll establish
    a **routes/** folder and create the **routes/recipes.js** file within it.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提高代码组织性，我们将创建两个不同的文件，每个实体一个。此外，为了保持结构化的方法，我们将建立一个 **routes/** 文件夹，并在其中创建 **routes/recipes.js**
    文件。
- en: 'The initial route we need to define is **GET /menu** . In this scenario, we
    employ the versatile **route()** method to construct it. This method requires
    an input object containing three obligatory parameters: **method** , **url** ,
    and **handler** , as illustrated in the following example:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义的初始路由是 **GET /menu**。在这种情况下，我们使用通用的 **route()** 方法来构建它。此方法需要一个包含三个必填参数的输入对象：**method**、**url**
    和 **handler**，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For a comprehensive list of the acceptable parameters, please consult the documentation
    at https://fastify.dev/docs/latest/Reference/Routes/#routes-options. Note that
    we must execute the **next** argument, as discussed in the *Splitting the code
    into small plugins* recipe. This is only another style with which to define plugins,
    and it is the most performant choice when we don’t need async operations during
    plugin loading. Moreover, it is important to remember that it must be the last
    operation to execute, and after calling it, it is not possible to add more routes.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于可接受参数的完整列表，请参阅 https://fastify.dev/docs/latest/Reference/Routes/#routes-options
    上的文档。请注意，我们必须执行 **next** 参数，如 *将代码拆分为小型插件* 菜谱中讨论的那样。这仅是定义插件的一种另一种风格，并且在我们不需要在插件加载期间进行异步操作时，这是性能最佳的选择。此外，重要的是要记住，它必须是最后一个执行的操作，并且在调用它之后，无法再添加更多路由。
- en: 'Define a new **menuHandler** function alongside the **plugin** function, which
    may prompt the question, How can we access the server’s resources? Fastify simplifies
    this process:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **plugin** 函数旁边定义一个新的 **menuHandler** 函数，这可能会引发问题，我们如何访问服务器的资源？Fastify简化了这一过程：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you define a named function, as demonstrated in the preceding code example,
    you can utilize the **this** keyword within its context. In this context, **this**
    is equivalent to the **app** variable, granting you access to all of the server’s
    resources, such as the database or the configuration settings, as we’ll explore
    in the *Adding routes* recipe. However, as shown in this particular example, we’re
    introducing **this.log** and the **request.log** property, which provide access
    to the logger object, enabling us to integrate logging into our application seamlessly.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你定义一个命名函数，如前一个代码示例所示，你可以在其上下文中使用 **this** 关键字。在这种情况下，**this** 等同于 **app** 变量，它让你可以访问所有服务器资源，例如数据库或配置设置，正如我们将在
    *添加路由* 菜谱中探讨的那样。然而，正如这个特定的例子所示，我们引入了 **this.log** 和 **request.log** 属性，它们提供了对日志对象的访问，使我们能够无缝地将日志集成到我们的应用程序中。
- en: 'Before continuing, we must not forget to update the **app.js** file when registering
    the new plugin:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，我们绝不能忘记在注册新插件时更新 **app.js** 文件：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can start the server with the **node server.js** command and execute
    a call against it:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 **node server.js** 命令启动服务器，并对它执行调用：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will discuss the source code for **routes/recipes.js** in detail in the *How
    it works…* section of this recipe. Now, we can define the remaining routes within
    the body of the **recipesPlugin** function. So, we can delve deeper into Fastify’s
    syntax by adding the new routes.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本食谱的 *如何工作…* 部分详细讨论 **routes/recipes.js** 的源代码。现在，我们可以在 **recipesPlugin**
    函数的主体中定义剩余的路由。因此，我们可以通过添加新路由来更深入地了解 Fastify 的语法。
- en: 'The **GET /recipes** endpoint combines elements from both the **get()** method
    that we saw previously in *Step 4* of the *Creating an API starter using Fastify*
    recipe and the generic **route()** method. You can designate the **url** as the
    first parameter and the route’s options as the second one:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GET /recipes** 端点结合了我们在 *创建 Fastify API 入门* 食谱的 *步骤 4* 中看到的 **get()** 方法和通用的
    **route()** 方法。你可以指定 **url** 作为第一个参数，以及路由的选项作为第二个参数：'
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The coolest thing here is that we’re utilizing the same **menuHandler** function
    for both the **/menu** and **/recipes** endpoints, aligning with the requirements
    we established earlier in the introduction of this recipe.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里最酷的事情是我们正在为 **/menu** 和 **/recipes** 端点使用相同的 **menuHandler** 函数，这与我们在本食谱介绍中早期设定的要求相一致。
- en: 'Now, defining a **POST /recipes** route appears to be a straightforward task
    in light of our previous work:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在之前的工作基础上，定义 **POST /recipes** 路由似乎是一个简单直接的任务：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, let’s discuss further the definition of the **DELETE /recipes/:id**
    route. Firstly, the **:id** pattern within the URL strin g serves as a **path
    parameter** . A path parameter is a positional variable segment of the URL. When
    a client makes a **DELETE** request to **/recipes/something** , the value of **something**
    will be assigned to the **request.params.id** property. It’s worth noting that
    **request.params** is a JSON object that contains all the path parameters you
    may define within the URL. Secondly, we’ve defined the **removeFromMenu** function
    as a synchronous function, meaning it is not **async** . In such cases, we cannot
    directly return or throw the desired response body. Instead, we must call the
    **reply.send()** method, which is responsible for transmitting the response payload
    to the client. This payload can be a string, a JSON object, a buffer, a stream,
    or an error object:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们进一步讨论 **DELETE /recipes/:id** 路由的定义。首先，URL 字符串中的 **:id** 模式充当 **路径参数**。路径参数是
    URL 的位置变量段。当客户端向 **/recipes/something** 发送 **DELETE** 请求时，**something** 的值将被分配给
    **request.params.id** 属性。值得注意的是，**request.params** 是一个 JSON 对象，它包含你可以在 URL 中定义的所有路径参数。其次，我们已将
    **removeFromMenu** 函数定义为同步函数，这意味着它不是 **async**。在这种情况下，我们不能直接返回或抛出所需的响应体。相反，我们必须调用
    **reply.send()** 方法，该方法负责将响应负载传输到客户端。这个负载可以是一个字符串、一个 JSON 对象、一个缓冲区、一个流或一个错误对象：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Don’t mix async with sync: It’s crucial to emphasize that you cannot mix the
    async and sync handler styles; otherwise, unexpected errors will appear on the
    console. As a key takeaway, remember the following guidelines: if the handler
    is asynchronous, return the desired payload; otherwise, if the handler is synchronous,
    you must use the **reply.send()** function to send the response. In my experience,
    it is more effective to stick to the async style in a project to avoid confusion
    across the team and with different backgrounds. Furthermore, the **reply** object
    is a fundamental component of Fastify that provides additional utilities, enabling
    you to customize the response code or append new response headers as needed. We
    will show an example in the *Implementing authentication with* *hooks* recipe.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混合异步和同步：强调一点，你不能混合异步和同步处理程序风格；否则，控制台上将出现意外的错误。作为一个关键要点，请记住以下指南：如果处理程序是异步的，则返回所需的负载；否则，如果处理程序是同步的，你必须使用
    **reply.send()** 函数来发送响应。根据我的经验，在项目中坚持异步风格更有效，这样可以避免团队和不同背景之间的混淆。此外，**reply**
    对象是 Fastify 的一个基本组件，它提供了额外的实用工具，使你能够根据需要自定义响应代码或附加新的响应头。我们将在 *使用钩子实现身份验证* 的食谱中展示一个示例。
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In the preceding code snippet, we find ourselves re-iterating a procedure similar
    to what we’ve previously executed for the **GET /** route in the *Creating an
    API starter using Fastify* recipe. However, in this instance, we’re employing
    an alternative syntax provided by Fastify. In this new plugin, for the **./routes/recipes.js**
    declaration, we use the callback style. It is crucial to note that we are calling
    the **next()** function at the end of the plugin. If you omit it, Fastify will
    fail its startup and will trigger an **FST_ERR_PLUGIN_TIMEOUT - Plugin did not
    start in time: ''recipesPlugin''. You may have forgotten to call ''done'' function
    or to resolve a** **Promise** error.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们发现自己在重复执行与我们在*使用Fastify创建API入门*食谱中为**GET /**路由执行的过程类似的过程。然而，在这个例子中，我们正在使用Fastify提供的替代语法。在这个新的插件中，对于**./routes/recipes.js**声明，我们使用回调风格。重要的是要注意，我们在插件的末尾调用**next()**函数。如果您省略了它，Fastify将失败启动，并触发**FST_ERR_PLUGIN_TIMEOUT
    - 插件未在指定时间内启动：'recipesPlugin'。您可能忘记了调用'done'函数或解析一个**Promise**错误。
- en: The **curl** request illustrates how Fastify employs a default error handler;
    it captures any thrown errors and responds with a 500 HTTP status code along with
    the error message.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**curl**请求说明了Fastify如何使用默认的错误处理器；它捕获任何抛出的错误，并返回带有错误消息的500 HTTP状态码。'
- en: 'In moving to the server’s log output instead, we should see the following alongside
    the logged error stack trace:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到服务器的日志输出，我们应该看到以下内容与记录的错误堆栈跟踪一起：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can observe the difference highlighted in the preceding code block. When
    you utilize the request’s **log** , the log entry will incorporate a **reqId**
    field. This feature proves quite useful in discerning which logs relate to a specific
    request, facilitating the reconstruction of the entire sequence of actions an
    HTTP request has undertaken within the application. Fastify assigns a unique identifier
    to each request by default, starting with **req-1** and incrementing the number.
    Additionally, this counter resets to its initial state with every server restart.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到前面代码块中突出显示的差异。当您使用请求的**log**时，日志条目将包含一个**reqId**字段。这个功能在区分哪些日志与特定请求相关，以及帮助重建HTTP请求在应用程序中执行的全部操作序列方面非常有用。Fastify默认为每个请求分配一个唯一的标识符，从**req-1**开始，并递增数字。此外，每次服务器重启后，这个计数器都会重置到初始状态。
- en: Important note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want to customize the request id, you have two options. You can configure
    the **requestIdHeader** server option, instructing Fastify to extract the id from
    a specific HTTP header. Alternatively, you can supply a **genReqId** function,
    granting you full control over the id generation process. For further information,
    please refer to the official documentation at [https://fastify.dev/docs/latest/Reference/Server](https://fastify.dev/docs/latest/Reference/Server)
    .
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自定义请求ID，您有两个选择。您可以配置**requestIdHeader**服务器选项，指示Fastify从特定的HTTP头中提取ID。或者，您可以提供一个**genReqId**函数，让您完全控制ID生成过程。有关更多信息，请参阅官方文档[https://fastify.dev/docs/latest/Reference/Server](https://fastify.dev/docs/latest/Reference/Server)。
- en: There’s more...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Up to this point, we have established the scaffolding for the **recipes.js**
    file. It’s time to create a new **routes/orders.js** file and define the final
    three routes required to accomplish our objective. I encourage you to take on
    this task as an exercise. If you encounter any issues, you can check the following
    code to be inspired:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为**recipes.js**文件建立了框架。现在是时候创建一个新的**routes/orders.js**文件，并定义完成我们目标所需的最后三个路由。我鼓励您将这项任务作为一个练习来承担。如果您遇到任何问题，您可以检查以下代码以获得灵感：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don’t forget to update the **app.js** file to expose the new empty routes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新**app.js**文件以公开新的空路由。
- en: Following this recipe, you should be well equipped to declare various routes
    and return plain data, such as strings or JSON objects. In the upcoming recipe,
    we will delve into implementing the fundamental business logic of our APIs by
    exploring the Fastify plugin system and its components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个食谱，您应该已经准备好声明各种路由并返回纯数据，例如字符串或JSON对象。在下一个食谱中，我们将通过探索Fastify插件系统和其组件来实现我们API的基本业务逻辑。
- en: Implementing authentication with hooks
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用钩子实现身份验证
- en: 'We’ve already utilized Fastify plugins to organize routes and enhance the maintainability
    of our project, but these are just some of the advantages that the Fastify **plugin
    system** provides. The key features of the plugin system are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经利用 Fastify 插件来组织路由并增强我们项目的可维护性，但这些只是 Fastify **插件系统**提供的优势中的一部分。插件系统的关键特性如下：
- en: '**Encapsulation** : All the hooks, plugins, and decorators added to a plugin
    are bound to the plugin context, ensuring they remain encapsulated within the
    plugin’s scope.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：所有添加到插件中的钩子、插件和装饰器都绑定到插件上下文，确保它们保持在插件的范围内。'
- en: '**Isolation** : Each plugin instance is self-contained and operates independently,
    avoiding any modifications to sibling plugins. This isolation ensures that changes
    or issues in one plugin do not affect others.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：每个插件实例都是自包含的，独立运行，避免对同级插件的任何修改。这种隔离确保了一个插件中的更改或问题不会影响其他插件。'
- en: '**Inheritance** : A plugin inherits the configuration of its parent plugin,
    allowing for a hierarchical and modular organization of plugins, making it easier
    to manage complex application structures.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：插件继承其父插件的配置，允许插件以分层和模块化的方式组织，使得管理复杂的应用程序结构更加容易。'
- en: These concepts might appear complex at first, but in this recipe, we will put
    them into practical use. Specifically, we will implement protection mechanisms
    for routes that only a chef should be able to access. This is a crucial step to
    prevent misuse by unauthorized users who might attempt to make destructive changes
    to the fantasy restaurant’s menu.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念一开始可能看起来很复杂，但在这个食谱中，我们将它们付诸实践。具体来说，我们将实现只有厨师才能访问的路由保护机制。这是防止未经授权的用户尝试对幻想餐厅的菜单进行破坏性更改的关键步骤。
- en: 'The authentication must grant access to a chef user to these endpoints:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 认证必须允许厨师用户访问这些端点：
- en: '**POST /recipes**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST /recipes**'
- en: '**DELETE /recipes/:id**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE /recipes/:id**'
- en: '**PATCH /orders/:orderId**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH /orders/:orderId**'
- en: To streamline the logic, we define a chef as any HTTP request that includes
    the **x-api-key** header with a valid secret value. The server must return a **401
    – Unauthorized** HTTP response if the authentication fails. This approach simplifies
    the verification process for chef access.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化逻辑，我们定义厨师为任何包含有效密钥值的 **x-api-key** 标头的 HTTP 请求。如果认证失败，服务器必须返回 **401 – 未授权**
    的 HTTP 响应。这种方法简化了厨师访问的验证过程。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before getting into the code, I recommend testing all the listed endpoints
    to confirm that you can access them and receive the expected **Not implemented**
    error message. By the end of this recipe, we anticipate that executing the following
    **curl** commands will result in an **Unauthorized** error:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我建议测试所有列出的端点，以确认您可以访问它们并收到预期的 **未实现** 错误消息。在本食谱结束时，我们预计执行以下 **curl**
    命令将导致 **未授权** 错误：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are going to explore all the plugin system features right now with a trial-and-error
    example. So, be ready to restart the server and execute the **curl** commands.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过一个试错示例来探索所有插件系统特性。因此，请准备好重新启动服务器并执行 **curl** 命令。
- en: Important note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Restarting the Fastify server by manually killing the Node.js process can be
    cumbersome. To streamline this process, you can run the application using the
    **node --watch server.js** argument. Node.js 20 introduces the watch mode feature,
    which automatically restarts the process whenever a file changes, making development
    more efficient.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过手动终止 Node.js 进程来重新启动 Fastify 服务器可能很麻烦。为了简化此过程，您可以使用 **node --watch server.js**
    参数运行应用程序。Node.js 20 引入了监视模式功能，该功能在文件更改时自动重新启动进程，使开发更加高效。
- en: How to do it…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To implement the authentication, we need to follow these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现认证，我们需要遵循以下步骤：
- en: 'Edit the **routes/recipes.js** file by adding an **onRequest** **hook** :'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加 **onRequest** **钩子** 编辑 **routes/recipes.js** 文件：
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A hook is a function that executes, as required, throughout the lifecycle of
    the application or during a single request and response cycle. It provides the
    capability to inject custom logic into the framework itself, enhancing reusability
    and allowing for tailored **behavior** at specific points in the application’s
    execution.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 钩子是一个函数，它在应用程序的生命周期中或在单个请求和响应周期中按需执行。它提供了将自定义逻辑注入框架本身的能力，增强了可重用性，并允许在应用程序执行的特定点上定制
    **行为**。
- en: 'Let’s see it in action by running these **curl** commands:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行以下 **curl** 命令来观察其效果：
- en: '[PRE25]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We have introduced the **onRequest** hook. This means the **isChef** function
    will run whenever a new HTTP request comes into the server. The logic of this
    hook is to verify the property of **request.headers** to check whether the expected
    header has the **fastify-rocks** value. If the check is unsuccessful, the hook
    throws an error after setting the HTTP response status code using the **reply.code()**
    method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了**onRequest**钩子。这意味着每当有新的HTTP请求进入服务器时，**isChef**函数都会运行。这个钩子的逻辑是验证**request.headers**属性，检查预期的头是否具有**fastify-rocks**值。如果检查失败，钩子会在使用**reply.code()**方法设置HTTP响应状态码后抛出错误。
- en: 'If we analyze the console output, we can see the plugin system in action:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析控制台输出，我们可以看到插件系统正在运行：
- en: '**Encapsulation** : We have incorporated a hook within the **recipesPlugin**
    function, and this hook’s function is executed for every route defined within
    the same plugin scope. As a result, the **GET /recipes** route returns a 401 error,
    demonstrating how hooks can encapsulate and apply logic consistently within a
    plugin’s context.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：我们在**recipesPlugin**函数中集成了一个钩子，并且这个钩子的功能会在同一插件作用域内定义的每个路由上执行。因此，**GET
    /recipes**路由返回了一个401错误，展示了钩子如何在插件上下文中封装并一致地应用逻辑。'
- en: '**Isolation** : Whenever Fastify executes the **register()** method, it generates
    a new **plugin instance** , analogous to the **app** argument in the **plugin**
    function declaration. This instance acts as a child object of the **root application**
    instance, ensuring isolation from sibling plugins and enabling the construction
    of independent components. This isolation is why the **PATCH /orders/fake-id**
    request remains unaffected and continues to return the old **Not implemented**
    error. It highlights that the scope of **ordersPlugin** remains isolated from
    that of the **recipesPlugin** .'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：每当Fastify执行**register()**方法时，它会生成一个新的**插件实例**，类似于**plugin**函数声明中的**app**参数。这个实例作为**根应用程序**实例的子对象，确保与兄弟插件隔离，并允许构建独立的组件。这种隔离是为什么**PATCH
    /orders/fake-id**请求不受影响，并继续返回旧的**未实现**错误。这突出了**ordersPlugin**的作用域与**recipesPlugin**的作用域保持隔离。'
- en: To evaluate the **Inheritance** feature, you must move the **onRequest** hook
    from the **routes/recipes.js** file to the **app.js** file. After this modification,
    executing the previous curl commands will indeed result in an **Unauthorized**
    error. This outcome occurs because both **ordersPlugin** and **recipesPlugin**
    are children of the **appPlugin** plugin instance and inherit all of its hooks,
    including the **onRequest** hook.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估**继承**功能，你必须将**onRequest**钩子从**routes/recipes.js**文件移动到**app.js**文件。经过这次修改后，执行之前的curl命令确实会导致**未授权**错误。这种结果发生是因为**ordersPlugin**和**recipesPlugin**都是**appPlugin**插件实例的子实例，并继承了其所有钩子，包括**onRequest**钩子。
- en: There’s more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: How can we resolve the current scenario where all our routes are protected?
    Exploring the plugin system offers a multitude of approaches to achieve this objective,
    as it heavily relies on your project’s structure and the contexts you need to
    consider. Let’s see two approaches for each plugin in the **routes/** folder.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决当前所有路由都受保护的场景？探索插件系统提供了多种方法来实现这一目标，因为它严重依赖于您的项目结构和您需要考虑的上下文。让我们看看**routes/**文件夹中每个插件的两个方法。
- en: 'The initial step involves centralizing the authentication logic; to facilitate
    this, we introduce **Decorators** . Decorators empower you to enhance the default
    functionalities of Fastify components, minimizing code duplication and providing
    rapid access to the application’s resources, such as a database connection. A
    decorator can be attached to the server instance, the request, or the reply object;
    this depends on the context it belongs to. Let’s add this to **app.js** after
    removing the **onRequest** hook:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是集中认证逻辑；为了实现这一点，我们引入了**装饰器**。装饰器使您能够增强Fastify组件的默认功能，减少代码重复，并提供快速访问应用程序资源，如数据库连接。装饰器可以附加到服务器实例、请求或回复对象；这取决于它所属的上下文。让我们在移除**onRequest**钩子后将其添加到**app.js**中：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We’ve defined an **isChef** request decorator, enabling the execution of the
    **request.isChef()** function within the **appPlugin** context and its child plugin
    instances. The logic within the **isChef** function is straightforward, returning
    a Boolean value of **true** only when a valid header is detected. It’s important
    to note that when we define a request or reply decorator, the **this** context
    refers to the request or reply object, respectively. This context is crucial for
    accessing these objects within the decorator function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个**isChef**请求装饰器，使得在**appPlugin**上下文及其子插件实例中执行**request.isChef()**函数成为可能。**isChef**函数中的逻辑很简单，只有当检测到有效的头信息时，才返回**true**的布尔值。需要注意的是，当我们定义请求或回复装饰器时，**this**上下文分别指向请求或回复对象。这个上下文对于在装饰器函数中访问这些对象至关重要。
- en: Next, we introduced an instance decorator named **authOnlyChef** . This decorator
    exposes a function with an identical API to the **onRequest** hook we previously
    defined. It can be accessed through the **app.authOnlyChef** property, offering
    a convenient way to apply authentication logic specific to chefs across various
    routes and plugins only when needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入了一个名为**authOnlyChef**的实例装饰器。这个装饰器提供了一个与之前定义的**onRequest**钩子相同的API。它可以通过**app.authOnlyChef**属性访问，提供了一个方便的方式来在需要时为厨师在各个路由和插件中应用特定的认证逻辑。
- en: 'Defining decorators doesn’t execute any logic; for them to execute on their
    own, we need to utilize them within our routes. Let’s proceed to the **routes/orders.js**
    file and modify the **/orders/:orderId** route to implement protection:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 定义装饰器不会执行任何逻辑；为了使它们独立执行，我们需要在路由中使用它们。让我们转到**routes/orders.js**文件并修改**/orders/:orderId**路由以实现保护：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ve configured the **onRequest** route’s option property to define a hook
    specific to this route. Fastify provides you with granularity in hook attachment;
    you can assign a hook function to an entire server instance or to an individual
    route. Additionally, you have the flexibility to set the **onRequest** field as
    an array of hook functions, which will be executed in the order they are added.
    This allows for precise control over the request processing flow.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了**onRequest**路由的选项属性来定义一个特定于该路由的钩子。Fastify为你提供了钩子附加的粒度控制；你可以将钩子函数分配给整个服务器实例或单个路由。此外，你可以将**onRequest**字段设置为钩子函数的数组，这些函数将按添加的顺序执行。这允许对请求处理流程进行精确控制。
- en: 'This syntax is perfect when you have a few routes to set up, but what if we
    have a lot of routes to protect? Let’s see what we can do in the **routes/recipes.js**
    file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要设置少量路由时，这种语法是完美的，但如果我们有很多路由需要保护呢？让我们看看在**routes/recipes.js**文件中我们能做什么：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To streamline the protection of the recipes routes, which consists of both protected
    and public routes, you can create a new **protectRoutesPlugin** plugin instance
    in **recipesPlugin** . Within this context, you can add the **onRequest** hook
    to all the routes defined in that context. In this case, I’ve named the first
    argument **plugin** to distinguish it from the **app** context. The **plugin**
    parameter serves as a child context of **app** , inheriting all the hooks and
    decorators up to the root application instance. This allows it to access the **authOnlyChef**
    function. Furthermore, we’ve moved only the routes that require protection into
    this new **plugin** function, effectively isolating them from the parent’s scope.
    Keep in mind that inheritance flows from parent to child contexts, not the other
    way around. This approach enhances code organization and maintains the benefits
    of encapsulation, isolation, and inheritance within the Fastify plugin system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化对包含受保护路由和公开路由的食谱路由的保护，你可以在**recipesPlugin**中创建一个新的**protectRoutesPlugin**插件实例。在这个上下文中，你可以将**onRequest**钩子添加到在该上下文中定义的所有路由。在这种情况下，我将第一个参数命名为**plugin**，以区分**app**上下文。**plugin**参数作为**app**的子上下文，继承所有直到根应用程序实例的钩子和装饰器。这使得它可以访问**authOnlyChef**函数。此外，我们只将需要保护的路线移动到这个新的**plugin**函数中，有效地将它们从父作用域中隔离出来。请记住，继承是从父上下文流向子上下文，而不是相反。这种方法增强了代码组织，并保持了Fastify插件系统中封装、隔离和继承的好处。
- en: With the changes we’ve made, you can now execute the **curl** commands that
    were initially tested in this recipe. You should expect to receive an **Unauthorized**
    error only for the routes that require protection, while the other routes should
    remain freely accessible. This demonstrates the successful implementation of authentication
    logic for selective route protection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们所做的更改，你现在可以执行在此配方中最初测试的**curl**命令。你应该只期望为需要保护的路线收到**未授权**错误，而其他路线应保持自由访问。这证明了选择性路线保护中身份验证逻辑的成功实现。
- en: 'Fastify has two distinct systems that govern its internal workflow: the **application
    lifecycle** and the **request lifecycle** . While Fastify manages these two lifecycles
    internally, it provides the flexibility for you to inject your custom logic by
    listening to and responding to the events associated with these lifecycles. This
    capability enables you to tailor the data flow around the endpoints according
    to your specific application requirements and use cases.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Fastify有两个不同的系统来管理其内部工作流程：**应用程序生命周期**和**请求生命周期**。虽然Fastify内部管理这两个生命周期，但它提供了灵活性，允许你通过监听和响应与这些生命周期相关的事件来注入自定义逻辑。这种能力使你能够根据特定的应用程序需求和用例调整端点周围的数据流。
- en: 'When you are listening for events triggered by the application lifecycle, you
    should refer to the **application hooks** (https://fastify.dev/docs/latest/Reference/Hooks#application-hooks).
    These hooks allow you to intervene during server startup and shutdown. Here is
    a quick list of these hooks and when they are emitted:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在监听由应用程序生命周期触发的事件时，你应该参考**应用程序钩子**（https://fastify.dev/docs/latest/Reference/Hooks#application-hooks）。这些钩子允许你在服务器启动和关闭期间进行干预。以下是一个这些钩子的快速列表以及它们何时触发：
- en: '| **Hook name** | **Emitted when…** | **Interface** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **钩子名称** | **在以下情况下触发** | **接口** |'
- en: '| **onRoute** | a new endpoint is added to the server instance | It must be
    a sync function |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **onRoute** | 服务器实例添加了一个新的端点 | 它必须是一个同步函数 |'
- en: '| **onRegister** | a new encapsulated context is created | It must be a sync
    function |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **onRegister** | 创建了一个新的封装上下文 | 它必须是一个同步函数 |'
- en: '| **onReady** | the application loaded by the HTTP server is not yet listening
    for incoming requests | It can be a sync or an async function |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **onReady** | 通过HTTP服务器加载的应用程序尚未监听传入的请求 | 它可以是同步或异步函数 |'
- en: '| **onListen** | the application is loaded, and the HTTP server is listening
    for incoming requests | It can be a sync or an async function. It does not block
    the application startup if it throws an error |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **onListen** | 应用程序加载，HTTP服务器正在监听传入的请求 | 它可以是同步或异步函数。如果它抛出错误，则不会阻塞应用程序启动
    |'
- en: '| **preClose** | the server starts the close phase and is still listening for
    incoming requests | It can be a sync or an async function |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **preClose** | 服务器开始关闭阶段，仍在监听传入的请求 | 它可以是同步或异步函数 |'
- en: '| **onClose** | the server has stopped listening for new HTTP requests and
    is in the process of stopping, allowing you to perform cleanup or finalization
    tasks, such as closing a database connection | It can be a sync or an async function.
    This hook is executed in reverse order |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **onClose** | 服务器已停止监听新的HTTP请求并正在停止，允许你执行清理或最终化任务，例如关闭数据库连接 | 它可以是同步或异步函数。此钩子按相反顺序执行
    |'
- en: Table 6.1 – Application hooks overview
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 – 应用程序钩子概述
- en: '*Table 6.1* provides a comprehensive overview of all the application hooks.
    It’s important to note that these hooks are executed in the order of their registration,
    except for the **onClose** hook, which follows a reverse order of execution because
    it ensures that the resources created last are the first to be closed, similar
    to how a **last-in-first-out** ( **LIFO** ) queue operates. This sequencing is
    essential for proper resource cleanup during server shutdown. Another important
    aspect that Fastify ensures is that if any of these hooks fail to execute successfully,
    the server will not start. This feature is valuable, as these hooks can be used
    to verify the readiness of essential external resources before they are consumed
    by the application’s handlers. It ensures that your application starts in a reliable
    state, enhancing robustness and stability. It’s important to note that the rule
    of preventing server startup upon hook failure does not apply to the **onListen**
    and **onClose** hooks. In these particular cases, Fastify guarantees that all
    registered hook functions will be executed, regardless of whether one of them
    encounters an error. This behavior ensures that necessary cleanup and finalization
    tasks are carried out during server startup and shutdown, even in the presence
    of errors in some hooks.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*表6.1*提供了所有应用程序钩子的全面概述。需要注意的是，这些钩子按照它们的注册顺序执行，除了**onClose**钩子，它按照执行的反向顺序执行，因为它确保最后创建的资源首先关闭，类似于**后进先出**（**LIFO**）队列的操作。这种顺序对于在服务器关闭期间正确清理资源至关重要。另一个重要的方面是，Fastify确保如果这些钩子中的任何一个未能成功执行，服务器将不会启动。这个特性非常有价值，因为这些钩子可以用来在应用程序处理器使用之前验证关键外部资源的就绪状态。这确保了你的应用程序以可靠的状态启动，增强了健壮性和稳定性。需要注意的是，防止服务器启动的规则不适用于**onListen**和**onClose**钩子。在这些特定情况下，Fastify保证所有注册的钩子函数都将被执行，无论其中一个是否遇到错误。这种行为确保了在存在某些钩子错误的情况下，在服务器启动和关闭期间执行必要的清理和最终化任务。'
- en: 'The application hooks serve various purposes, but the main ones include the
    following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序钩子服务于各种目的，但主要目的包括以下内容：
- en: '**Cache warm-up** : You can use the **onReady** hook to prepare and preload
    a cache when the server is about to start, which can significantly enhance the
    performance of your handlers.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存预热**：你可以在服务器即将启动时使用**onReady**钩子来准备和预加载缓存，这可以显著提高处理器性能。'
- en: '**Resource Check** : If your handlers rely on a third-party server or external
    resource, you can use these hooks to verify that the resource is up and running
    during server startup, ensuring that your application’s dependencies are available.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源检查**：如果你的处理器依赖于第三方服务器或外部资源，你可以在服务器启动时使用这些钩子来验证资源是否正常运行，确保你的应用程序的依赖项可用。'
- en: '**Monitoring** : These hooks are valuable for logging and monitoring server
    startup information, such as configuration details or reasons for server shutdown,
    aiding in debugging and observability.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：这些钩子对于记录和监控服务器启动信息非常有价值，例如配置细节或服务器关闭的原因，有助于调试和可观察性。'
- en: '**Aspect-oriented programming** : By leveraging the **onRegister** and **onRoute**
    hooks, you can apply aspect-oriented programming techniques to manipulate route
    options and inject additional properties or behavior into your routes. This allows
    for the powerful customization and modularization of your application logic.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向方面编程**：通过利用**onRegister**和**onRoute**钩子，你可以应用面向方面编程技术来操作路由选项，并将额外的属性或行为注入到你的路由中。这允许对应用程序逻辑进行强大的定制和模块化。'
- en: 'As an exercise, try to add these hooks into every application’s files:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，尝试将这些钩子添加到每个应用程序的文件中：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Indeed, the **this** keyword in the context of these hooks represents the Fastify
    instance, granting you access to all of the server’s decorators and resources.
    This includes the application logger, which can be accessed in the common and
    well-established Fastify style. It’s worth noting that, similar to plugin declarations,
    the hooks in Fastify support both asynchronous and synchronous interfaces. In
    the case of asynchronous hooks, you don’t need to take any specific actions. However,
    in the case of synchronous hooks, you have access to a **done** argument, as shown
    in the **onClose** hook in the previous code snippet. It’s essential to call this
    function within the synchronous hook to indicate successful execution; otherwise,
    the hook pipeline will be blocked, and it will not complete until a timeout occurs,
    potentially leading to the server’s shutdown.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在这些钩子上下文中，**this** 关键字代表 Fastify 实例，这使您能够访问服务器上的所有装饰器和资源。这包括应用程序日志记录器，它可以通过常见的、已建立的
    Fastify 风格进行访问。值得注意的是，与插件声明类似，Fastify 的钩子支持异步和同步接口。在异步钩子的情况下，您不需要采取任何特定行动。然而，在同步钩子的情况下，您有一个访问
    **done** 参数的权限，如前一个代码片段中的 **onClose** 钩子所示。在同步钩子中调用此函数是必要的，以指示成功执行；否则，钩子管道将被阻塞，并且它将不会完成，直到超时发生，这可能导致服务器关闭。
- en: 'After this comprehensive overview of the application hooks, let’s now shift
    our focus to the **request hooks** ( [https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks](https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks)
    ), which are associated with the request lifecycle. This lifecycle delineates
    the various steps that an HTTP request undergoes when it enters the server. You
    can visualize this process in the following diagram:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在对应用程序钩子进行了全面的概述之后，现在让我们将注意力转向与请求生命周期相关的 **请求钩子**（[https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks](https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks)），这些钩子与请求生命周期相关联。这个生命周期定义了
    HTTP 请求进入服务器时经历的各个步骤。您可以在以下图中可视化此过程：
- en: '![Figure 6.1 – The request lifecycle](img/B19212_06_01.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 请求生命周期](img/B19212_06_01.jpg)'
- en: Figure 6.1 – The request lifecycle
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 请求生命周期
- en: 'In *Figure 6* *.1* , the request lifecycle steps are represented with dashed
    boxes containing the hook names triggered during that specific phase. Let’s follow
    the path of an incoming HTTP request and describe what happens inside Fastify
    in the order of occurrence:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 6* *.1* 中，请求生命周期步骤用包含在该特定阶段触发的钩子名称的虚线框表示。让我们跟随一个传入的 HTTP 请求的路径，并按发生的顺序描述
    Fastify 内部发生的事情：
- en: '**Route selection** : When an HTTP request is received, Fastify routes it to
    a specific handler based on the requested URL and HTTP method. If no matching
    route is found, Fastify’s default 404 handler is executed.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路由选择**：当收到 HTTP 请求时，Fastify 根据请求的 URL 和 HTTP 方法将其路由到特定的处理程序。如果没有找到匹配的路由，Fastify
    将执行默认的 404 处理程序。'
- en: '**Request initiation** : After the route handler is determined, the **onRequest**
    hook is executed. During this phase, the request’s body has not been parsed yet.
    The request object does not contain the **body** property. This is an appropriate
    point to discard any requests that should not be processed, such as unauthorized
    ones. Since the request payload has yet to be read, server resources are not wasted
    on unnecessary processing.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求初始化**：在确定路由处理程序之后，执行 **onRequest** 钩子。在这个阶段，请求体尚未解析。请求对象不包含 **body** 属性。这是一个丢弃不应处理的请求（如未经授权的请求）的合适点。由于请求有效载荷尚未读取，服务器资源不会浪费在不必要的处理上。'
- en: '**Request payload manipulation** : If the HTTP request is deemed processable,
    the **preParsing** hook provides access to the request’s payload stream, which
    can be manipulated. Common use cases include decrypting an encrypted request payload
    or decompressing user input.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求有效载荷操作**：如果 HTTP 请求被认为是可以处理的，**preParsing** 钩子提供了对请求有效载荷流的访问，可以进行操作。常见的用例包括解密加密的请求有效载荷或解压缩用户输入。'
- en: '**Payload validation** : Fastify includes a built-in validation system, which
    we will explore further in the *Validating the input data* recipe of this chapter.
    You can modify the parsed payload before it undergoes validation by listening
    to the **preValidation** hook.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有效载荷验证**：Fastify 包含一个内置的验证系统，我们将在本章的 *验证输入数据* 菜单中进一步探讨。您可以通过监听 **preValidation**
    钩子来修改在验证之前解析的有效载荷。'
- en: '**Full request parsing** : Just before executing the route handler, which contains
    the business logic, the **preHandler** hook is executed. During this phase, the
    request is fully parsed, and you can access its content via the **request.body**
    field.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完整请求解析**：在执行包含业务逻辑的路由处理程序之前，会执行**preHandler**钩子。在此阶段，请求被完全解析，你可以通过**request.body**字段访问其内容。'
- en: '**Route handler execution** : The request enters the main route handler to
    execute the function associated with the route definition. When you use **reply.send()**
    or return a payload as the response, the last phase begins to send the response
    payload to the client.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路由处理程序执行**：请求进入主路由处理程序以执行与路由定义关联的函数。当你使用**reply.send()**或返回有效载荷作为响应时，响应的最后一个阶段开始向客户端发送响应有效载荷。'
- en: '**Payload serialization** : Before the serialization process occurs, the **preSerialization**
    hook is triggered. Here, you can manipulate the payload, adapt it to a specific
    format, or convert non-serializable objects into plain JSON objects.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有效载荷序列化**：在序列化过程开始之前，会触发**preSerialization**钩子。在这里，你可以操作有效载荷，将其适配到特定格式，或将不可序列化的对象转换为纯JSON对象。'
- en: '**Response preparation** : The **onSend** hook is called just before sending
    the response payload to the client. It can access the serialized payload content
    and apply additional manipulations, such as encryption or compression.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**响应准备**：在向客户端发送响应有效载荷之前，会调用**onSend**钩子。它可以访问序列化的有效载荷内容并应用额外的操作，例如加密或压缩。'
- en: '**Request completion** : Finally, the last step in the request lifecycle is
    the **onResponse** hook. This hook is executed after the payload has been successfully
    sent to the client, marking the completion of the HTTP request.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求完成**：最后，请求生命周期中的最后一步是**onResponse**钩子。此钩子在成功将有效载荷发送到客户端后执行，标志着HTTP请求的完成。'
- en: 'Indeed, many things are involved when a simple HTTP request enters the Fastify
    server, as highlighted in the request lifecycle. Moreover, *Figure 6* *.1* illustrates
    three additional hooks dedicated to managing errors that may occur throughout
    the entire request lifecycle. These error-specific hooks provide the means to
    handle errors gracefully and effectively, ensuring the reliability and robustness
    of your Fastify application. These three error-specific hooks in Fastify provide
    ways to manage different error scenarios:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，当简单的HTTP请求进入Fastify服务器时，涉及许多事情，如请求生命周期中所示。此外，*图6.1*展示了三个专门用于管理在整个请求生命周期中可能发生的错误的额外钩子。这些特定错误的钩子提供了优雅和有效地处理错误的方法，确保了Fastify应用程序的可靠性和健壮性。Fastify中的这三个特定错误的钩子提供了管理不同错误场景的方法：
- en: '**onTimeout** : This hook is triggered when a connection socket is in an idle
    state. To enable this hook, you must set the server’s **connectionTimeout** option
    (the default value is **0** , which means disabled). The value you specify in
    milliseconds determines the maximum time the application has to complete the request
    lifecycle. If this time limit is exceeded, the **onTimeout** hook kicks in and
    closes the connection.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onTimeout**：当连接套接字处于空闲状态时，此钩子会被触发。要启用此钩子，你必须设置服务器的**connectionTimeout**选项（默认值为**0**，表示禁用）。你指定的毫秒数决定了应用程序完成请求生命周期的最大时间。如果超过此时间限制，**onTimeout**钩子就会启动并关闭连接。'
- en: '**onError** : The hook is triggered when the server sends an error as the response
    payload to the client. It allows you to perform custom actions when errors occur
    during request processing.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onError**：当服务器将错误作为响应有效载荷发送给客户端时，此钩子会被触发。它允许你在请求处理过程中发生错误时执行自定义操作。'
- en: '**onRequestAbort** : This hook is executed when a client prematurely closes
    the connection before the request is fully processed. In such cases, you won’t
    be able to send data to the client since the connection has already been closed.
    This hook is useful for cleaning up any resources associated with the aborted
    request.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onRequestAbort**：当客户端在请求完全处理之前提前关闭连接时，此钩子会被执行。在这种情况下，由于连接已经关闭，你将无法向客户端发送数据。此钩子对于清理与已中止请求关联的任何资源非常有用。'
- en: You’ve now gained a comprehensive understanding of Fastify’s hooks, which will
    be invaluable as you dive deeper into using the plugin system. So, let’s start
    to use all of Fastify’s powerful features, including hooks, decorators, and plugins,
    to implement the fantasy restaurant business logic.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经全面了解了Fastify的钩子，这将在你深入使用插件系统时非常有价值。因此，让我们开始使用Fastify的所有强大功能，包括钩子、装饰器和插件，来实现幻想餐厅的业务逻辑。
- en: Breaking the encapsulation
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破封装
- en: In this new recipe, we’ll delve deeper into the world of the Fastify plugin
    system, expanding our understanding beyond what we’ve explored so far. Fastify
    offers a wide array of tools, each serving specific purposes, and gaining familiarity
    with them will greatly enhance your ability to customize and control various aspects
    of your application’s lifecycle and behavior.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的菜谱中，我们将更深入地探讨 Fastify 插件系统，扩展我们对之前所探索内容的理解。Fastify 提供了一系列工具，每个工具都服务于特定的目的，熟悉它们将大大增强你自定义和控制应用程序生命周期和行为各个方面的能力。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous *Implementing authentication with hooks* recipe, we learned
    about various hooks, but we didn’t see their practical application. Now, let’s
    apply our knowledge by developing a custom authentication plugin. Currently, our
    authentication logic is dispersed across the **app.js** file, which is then utilized
    by both **orders.js** and **recipes.js** . While it works, it lacks centralization.
    To address this, we aim to create a company-wide plugin that can be easily integrated
    into all our projects, providing standardized authentication logic right out of
    the box when registering the plugin.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 *使用钩子实现身份验证* 菜谱中，我们学习了各种钩子，但并未看到它们的实际应用。现在，让我们通过开发一个自定义身份验证插件来应用我们的知识。目前，我们的身份验证逻辑分散在
    **app.js** 文件中，然后被 **orders.js** 和 **recipes.js** 所使用。虽然它可行，但缺乏集中化。为了解决这个问题，我们旨在创建一个公司范围内的插件，可以轻松集成到所有我们的项目中，在注册插件时直接提供标准化的身份验证逻辑。
- en: How to do it…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To create a common plugin by breaking the **encapsulation** , we need to follow
    these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过打破 **封装** 创建一个通用插件，我们需要遵循以下步骤：
- en: 'Create a new **plugins/auth.js** instance in a new folder and then move the
    decorators from **app.js** to this new file:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件夹中创建一个新的 **plugins/auth.js** 实例，然后将 **app.js** 中的装饰器移动到这个新文件中：
- en: '[PRE30]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As usual, register the plugin in the **app.js** file:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，在 **app.js** 文件中注册插件：
- en: '[PRE31]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is nothing new so far, but if you try to start the server, it won’t work.
    Let me show you why by drawing the Fastify contexts structure:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，这没有什么新意，但如果你尝试启动服务器，它将无法工作。让我通过绘制 Fastify 上下文结构来展示原因：
- en: '![Figure 6.2 – Fastify tree structure](img/B19212_06_02.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Fastify 树结构](img/B19212_06_02.jpg)'
- en: Figure 6.2 – Fastify tree structure
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Fastify 树结构
- en: In *Figure 6* *.2* , every node represents a self-contained context. Thanks
    to the plugin system, each of these contexts can possess its own hooks, decorators,
    and plugins. On the left side of the figure, you can observe the current structure
    of our application. Notably, the decorators defined within the **authPlugin**
    function are not accessible to either the **recipesPlugin** or **ordersPlugin**
    functions due to isolation. To rectify this, we should consider relocating the
    **authPlugin** node higher up in the tree structure. By doing so, the recipes
    and orders plugins would inherit the decorators, allowing for seamless integration
    and functionality. Implementing this action would entail having **server.js**
    register **authPlugin** and, subsequently, **authPlugin** register **appPlugin**
    . While this approach would work, it leads to a source code that is challenging
    to comprehend due to its complexity and nested dependencies. For this reason,
    in this case, we want to **break the encapsulation** , as shown on the right side
    of *Figure* *6* *.2* .
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 6.2* 中，每个节点代表一个自包含的上下文。多亏了插件系统，这些上下文中的每一个都可以拥有自己的钩子、装饰器和插件。在图形的左侧，你可以观察到我们应用程序的当前结构。值得注意的是，由于隔离，定义在
    **authPlugin** 函数中的装饰器对 **recipesPlugin** 或 **ordersPlugin** 函数不可用。为了纠正这一点，我们应该考虑将
    **authPlugin** 节点在树结构中向上移动。通过这样做，食谱和订单插件将继承装饰器，从而实现无缝集成和功能。实施这一行动将涉及让 **server.js**
    注册 **authPlugin**，然后 **authPlugin** 注册 **appPlugin**。虽然这种方法可行，但由于其复杂性和嵌套依赖，源代码难以理解。因此，在这种情况下，我们想要
    **打破封装**，如图 *6.2* 的右侧所示。
- en: Install a new module by running **npm** **install fastify-plugin@5** .
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 **npm install fastify-plugin@5** 安装一个新的模块。
- en: 'Wrap the **authPlugin** function with the **fastify-plugin** , as shown in
    the following code snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **authPlugin** 函数用 **fastify-plugin** 包装，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Upon restarting the server, everything should function as it did previously.
    This is because breaking the encapsulation context is like using the parent Fastify
    instance. If we were to apply **fastify-plugin** to every file we’ve implemented
    thus far, we would essentially consolidate everything into a single context, equivalent
    to the root application context. Unfortunately, this would result in the loss
    of all the capabilities provided by the plugin system. As a general rule of thumb,
    you may use **fastify-plugin** exclusively for those plugins that you intend to
    reuse across your organization.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重新启动服务器后，一切应该像之前一样正常工作。这是因为打破封装上下文就像使用父Fastify实例一样。如果我们将**fastify-plugin**应用到迄今为止我们实现的每个文件上，我们实际上会将所有内容合并到一个上下文中，相当于根应用程序上下文。不幸的是，这会导致丢失插件系统提供的所有功能。一般来说，您可能只将**fastify-plugin**用于那些您打算在组织内重用的插件。
- en: 'Our work is not yet complete, as we have only moved the decorators. Now, our
    objective is to centralize how the routes apply the authentication logic. To achieve
    this, we will utilize the **onRoute** hook. Add this code to the **auth.js** file:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的工作还没有完成，因为我们只移动了装饰器。现在，我们的目标是集中管理路由如何应用身份验证逻辑。为了实现这一点，我们将利用**onRoute**钩子。将以下代码添加到**auth.js**文件中：
- en: '[PRE33]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As mentioned in the *There’s more...* section of the *Implement authentication
    with hooks* recipe, the **onRoute** hook must be a synchronous function. It receives
    the route’s options as its first argument. The purpose of this function is to
    check whether **routeOptions** includes an **auth** flag set to true. If this
    condition is met, we inject the **authOnlyChef** decorator function into **routeOptions.onRequest**
    .
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如在*更多内容...*部分所述的*使用钩子实现身份验证*食谱中提到，**onRoute**钩子必须是一个同步函数。它将路由的选项作为其第一个参数接收。这个函数的目的是检查**routeOptions**是否包含设置为true的**auth**标志。如果满足这个条件，我们将**authOnlyChef**装饰器函数注入到**routeOptions.onRequest**中。
- en: It’s worth emphasizing that the code ensures **authOnlyChef** is the first function
    in the **onRequest** chain. This is significant because Fastify executes these
    functions in the order they appear. Additionally, it’s worth mentioning that the
    input **routeOption.onRequest** can either be an array of hooks or a single function.
    The code example handles both scenarios seamlessly using the **Array.concat()**
    function.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得强调的是，代码确保**authOnlyChef**是**onRequest**链中的第一个函数。这很重要，因为Fastify会按照它们出现的顺序执行这些函数。此外，值得一提的是，输入的**routeOption.onRequest**可以是钩子数组或单个函数。代码示例使用**Array.concat()**函数无缝处理这两种情况。
- en: 'Now, we can go back to the **orders.js** file and update the **PATCH /orders/:orderId**
    handler as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以回到**orders.js**文件，并更新**PATCH /orders/:orderId**处理器如下：
- en: '[PRE34]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have replaced the previous **onRequest** **[app.authOnlyChef]** configuration
    with the new approach.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经用新的方法替换了之前的**onRequest** **[app.authOnlyChef]**配置。
- en: By utilizing the route’s **config** property, we isolate your application’s
    properties from Fastify’s fields to prevent conflicts. This updated setup offers
    several advantages, including the ability of **authPlugin** to evolve over time
    without necessitating changes to your routes’ configurations with every update.
    This pattern aligns with **aspect-oriented programming** , as it dynamically introduces
    a feature through a straightforward Boolean configuration.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用路由的**config**属性，我们将应用程序的属性与Fastify的字段隔离开来，以防止冲突。这种更新的设置提供了几个优点，包括**authPlugin**能够在不要求每次更新都更改路由配置的情况下随着时间的推移而发展。这种模式与**面向方面编程**相一致，因为它通过简单的布尔配置动态引入功能。
- en: There’s more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'As an exercise, try to update the **recipes.js** file by yourself now, and
    then compare your code with the following solution:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，现在尝试自己更新**recipes.js**文件，然后比较您的代码与以下解决方案：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As was previously carried out, we have set the **config.auth** option, and we
    deleted the **protectRoutesPlugin** code because creating an encapsulated context
    is no longer necessary.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们已经设置了**config.auth**选项，并且删除了**protectRoutesPlugin**代码，因为创建封装的上下文不再必要。
- en: Well done! In this recipe, we’ve covered a lot, beginning with hooks, moving
    on to decorators, and learning how to manage encapsulated contexts and break them
    when necessary. In the next recipe, we’ll dive into implementing the business
    logic for our routes, which we’ve only declared up to this point. So, let’s gear
    up and get started!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在这个菜谱中，我们涵盖了大量的内容，从钩子开始，然后转到装饰器，学习如何管理封装的上下文，并在必要时将其打破。在下一个菜谱中，我们将深入实现我们直到现在为止只声明的路由的业务逻辑。所以，让我们做好准备，开始吧！
- en: Implementing business logic using hooks
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用钩子实现业务逻辑
- en: 'The APIs for the fantasy restaurant have a specific goal: to serve our restaurant’s
    needs. In the *Adding* *routes* recipe, we examined the general flow but didn’t
    delve into details, such as the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假想餐厅的API有一个特定的目标：满足我们餐厅的需求。在*添加* *路由*的菜谱中，我们考察了整体流程，但没有深入细节，例如以下内容：
- en: What constitutes the input for each endpoint?
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个端点的输入是什么？
- en: What should be the expected output of each service?
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务的预期输出应该是什么？
- en: Where should we store the data?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在哪里存储数据？
- en: In this recipe, we will explore these crucial aspects in greater detail. So,
    let’s start with the data and its storage!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将更详细地探讨这些关键方面。所以，让我们从数据和它的存储开始！
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We require a database to store and retrieve application data. For this purpose,
    we will employ the well-known NoSQL database **MongoDB** ( [https://www.mongodb.com/](https://www.mongodb.com/)
    ). MongoDB is a popular NoSQL database that stores data in flexible, JSON-like
    documents, providing scalability and high performance for various applications.
    It’s important to note that the details of MongoDB are not the primary focus of
    this chapter, so I won’t delve into extensive descriptions of its inner workings.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个数据库来存储和检索应用程序数据。为此，我们将使用知名的NoSQL数据库**MongoDB**（[https://www.mongodb.com/](https://www.mongodb.com/)）。MongoDB是一个流行的NoSQL数据库，它以灵活的、类似JSON的文档形式存储数据，为各种应用程序提供可扩展性和高性能。需要注意的是，MongoDB的细节不是本章的重点，因此我不会深入描述其内部工作原理。
- en: Important note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you have a Docker installation, you can run a MongoDB server by running
    this command line: **docker run -d -p 27017:27017 --name fastify-mongo mongo:5**
    . It will start a container using the official MongoDB image, and it will be ready
    to use. Finally, to stop it, you can run this command instead: **docker container**
    **stop fastify-mongo** .'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了Docker，你可以通过运行以下命令来运行MongoDB服务器：**docker run -d -p 27017:27017 --name
    fastify-mongo mongo:5**。它将使用官方的MongoDB镜像启动一个容器，并准备好使用。最后，要停止它，你可以运行这个命令代替：**docker
    container stop fastify-mongo**。
- en: How to do it…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To connect our application to MongoDB, we need to follow these steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的应用程序连接到MongoDB，我们需要遵循以下步骤：
- en: 'Install the official Fastify module:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装官方的Fastify模块：
- en: '[PRE36]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we can create a new plugin in the **plugins/datasource.js** file, where
    we will connect to the database:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在**plugins/datasource.js**文件中创建一个新的插件，我们将连接到数据库：
- en: '[PRE37]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Update **app.js** , adding the **app.register(datasourcePlugin)** code, as was
    carried out in *Step 2* of the *Breaking the* *encapsulation* recipe.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新**app.js**，添加**app.register(datasourcePlugin)**代码，就像在*打破* *封装*菜谱的*步骤2*中执行的那样。
- en: If you launch the application with a properly initialized database, it should
    start as usual, and you should observe the new log line we added to confirm that
    our plugin is being loaded.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用正确初始化的数据库启动应用程序，它应该像往常一样启动，你应该观察到我们添加的新日志行，以确认我们的插件正在被加载。
- en: 'Next, we must establish a data layer between the MongoDB data source and our
    business logic. This allows us to identify the essential actions our routes must
    execute and extract a subset of these actions to be defined as decorators:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须在MongoDB数据源和我们的业务逻辑之间建立一个数据层。这允许我们确定我们的路由必须执行的基本操作，并从中提取一个子集作为装饰器：
- en: '[PRE38]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the previous code snippet, we added a new **source** object decorator. Each
    object’s field references an **async** function that will perform only what the
    name says. So, let’s start to implement the first function:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了一个新的**source**对象装饰器。每个对象的字段引用一个**async**函数，它将只执行其名称所表示的操作。所以，让我们开始实现第一个函数：
- en: '[PRE39]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This function inserts the input JSON object **recipe** into the **menu** collection
    and returns the generated id. As said, this data layer should not perform any
    business logic. **app.mongo** is a decorator created by the **@fastify/mongodb**
    module, as documented here: [https://github.com/fastify/fastify-mongodb](https://github.com/fastify/fastify-mongodb)
    , and this refers to the MongoDB Client, so you have total control over it.'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将输入JSON对象**recipe**插入到**menu**集合中，并返回生成的id。如前所述，这一数据层不应执行任何业务逻辑。**app.mongo**是由**@fastify/mongodb**模块创建的装饰器，如在此处所述：[https://github.com/fastify/fastify-mongodb](https://github.com/fastify/fastify-mongodb)，这指的是MongoDB客户端，因此你可以完全控制它。
- en: Important note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the preceding code block, the **_id** property in **recipe._id = _id;** and
    the **id** property in **recipe.id = _id.toString()** have the same value. We
    introduce the **id** property to prevent the exposure of any information related
    to our database. While we utilize the **_id** property, it is primarily defined
    and employed by MongoDB servers for internal purposes, and we opt to use **id**
    to maintain a level of abstraction and security in our application’s data.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，**recipe._id = _id;**中的**_id**属性和**recipe.id = _id.toString()**中的**id**属性具有相同的值。我们引入**id**属性是为了防止暴露与我们的数据库相关的任何信息。当我们使用**_id**属性时，它主要是由MongoDB服务器为内部目的定义和使用的，我们选择使用**id**以保持应用程序数据的一定抽象和安全级别。
- en: 'To use the **insertRecipe** function, we need to implement the **POST /recipes**
    endpoint as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用**insertRecipe**函数，我们需要实现**POST /recipes**端点，如下所示：
- en: '[PRE40]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When the **addToMenu** function handler runs, we are 100% sure that the authentication
    hook is successful and only a valid chef is executing it. So, the function logic
    reads from the **request.body** input data to compose a new JSON object. This
    step is required to avoid inserting unexpected fields (into the database) that
    a client may submit to our endpoint. Then, the **app.source.insertRecipe** decorator
    is called to save the data. As the last operations, we set the HTTP response status
    to **201 – Created** (for a complete list of the standard HTTP status codes, refer
    to the list here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
    ).'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当**addToMenu**函数处理器运行时，我们100%确信认证钩子是成功的，并且只有有效的厨师在执行它。因此，函数逻辑从**request.body**输入数据读取以组成一个新的JSON对象。这一步是必要的，以避免插入客户端可能提交给我们的端点的意外字段（到数据库中）。然后，调用**app.source.insertRecipe**装饰器来保存数据。作为最后的操作，我们将HTTP响应状态设置为**201
    – 已创建**（对于标准HTTP状态码的完整列表，请参阅此处：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)）。
- en: 'We can try it now by running this **curl** command:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过运行以下**curl**命令来尝试：
- en: '[PRE41]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our test is not over yet. You must try to run the same **curl** command, but
    you need to remove the **x-api-key** header or change its value. We expect a **401
    – Unauthorize** error in these cases.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的测试还没有结束。你必须尝试运行相同的**curl**命令，但你需要删除**x-api-key**头信息或更改其值。在这些情况下，我们期望出现**401
    – 未授权**错误。
- en: Important note
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Instead of using **curl** to run HTTP requests against the application server,
    adopting an HTTP Client with a **graphic user interface** ( **GUI** ) may be easier.
    Here is a complete list where you may choose your favorite one: [https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui](https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui)
    .'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用**curl**向应用程序服务器运行HTTP请求相比，采用具有**图形用户界面**（**GUI**）的HTTP客户端可能更容易。以下是一个完整的列表，你可以选择你喜欢的：[https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui](https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui)。
- en: 'Before considering this section completed, we need to read from the database,
    so let’s implement the **readRecipes** function in the **plugins/datasource.js**
    file:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在考虑本节完成之前，我们需要从数据库中读取，因此让我们在**plugins/datasource.js**文件中实现**readRecipes**函数：
- en: '[PRE42]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this search function, we are using the standard MongoDB APIs ( [https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/](https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/)
    ). We may want to filter the data, so we expect a **filters** parameter. The **sort**
    argument, instead, is needed to return the dishes array in the right order, whereby,
    e.g., the appetizer will have **order=0** , the first course will have **order=1**
    , and so on.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个搜索函数中，我们使用的是标准的 MongoDB API（[https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/](https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/)）。我们可能想要过滤数据，因此我们期望有一个
    **filters** 参数。而 **sort** 参数则是为了以正确的顺序返回菜品数组，例如，开胃菜将具有 **order=0**，主菜将具有 **order=1**，依此类推。
- en: 'Finally, we can update the **routes/recipes.js** file with the new **menuHandler**
    code:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以更新 **routes/recipes.js** 文件，添加新的 **menuHandler** 代码：
- en: '[PRE43]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As usual, we can try to see if this code is working as expected by calling
    the server to see the result:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们可以通过调用服务器来查看结果，以检查此代码是否按预期工作：
- en: '[PRE44]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The **/menu** endpoint should answer with an array of all the dishes we stored
    in the menu collection during our testing phase!
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**/menu** 端点应该返回一个数组，包含我们在测试阶段存储在菜单集合中的所有菜品！'
- en: Important note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Should we implement pagination? Our **GET /menu** endpoint provides a list
    of data, and it’s considered a best practice to assess whether the list might
    be excessively large to return in a single HTTP call. In this specific case, it’s
    deemed acceptable to return the entire menu. However, if the menu were to contain
    hundreds of recipes, you might want to consider implementing pagination logic
    to break the data into manageable chunks. You can find guidance on how to implement
    two different pagination patterns in this article: [https://backend.cafe/streaming-postgresql-data-with-fastify](https://backend.cafe/streaming-postgresql-data-with-fastify)
    . Although the article discusses PostgreSQL, these pagination patterns can also
    be adapted for use with MongoDB.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该实现分页？我们的 **GET /menu** 端点提供了一个数据列表，通常认为评估列表是否过大，以至于无法在一次 HTTP 请求中返回是一个最佳实践。在这个特定案例中，返回整个菜单被认为是可接受的。然而，如果菜单包含数百个菜谱，你可能需要考虑实现分页逻辑，将数据分成可管理的块。你可以在本文中找到如何实现两种不同分页模式的指导：[https://backend.cafe/streaming-postgresql-data-with-fastify](https://backend.cafe/streaming-postgresql-data-with-fastify)。尽管文章讨论的是
    PostgreSQL，但这些分页模式也可以用于 MongoDB。
- en: In this recipe, we’ve learned how to establish a connection to a database. It’s
    worth noting that Fastify contributors provide support for various popular databases,
    including **PostgreSQL** , **MySQL** , and **Redis** , among others. You can find
    a comprehensive list of supported databases at [https://fastify.dev/ecosystem](https://fastify.dev/ecosystem)
    . In the upcoming recipe, we will discuss the data validation used to protect
    our endpoints from malicious users, and we will keep on implementing the missing
    routes’ handlers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何建立数据库连接。值得注意的是，Fastify 贡献者支持各种流行的数据库，包括 **PostgreSQL**、**MySQL**
    和 **Redis** 等。你可以在 [https://fastify.dev/ecosystem](https://fastify.dev/ecosystem)
    找到支持的数据库的完整列表。在接下来的菜谱中，我们将讨论用于保护我们的端点免受恶意用户攻击的数据验证，并且我们将继续实现缺失的路由处理程序。
- en: Validating the input data
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证输入数据
- en: In the *Implementing the business logic* recipe, we stored input data from the
    **POST /recipes** endpoint in the database. However, we did not implement any
    validation logic, which means we could potentially insert a string into the **price**
    field or a recipe without **name** . Furthermore, it’s important to consider security
    concerns, as a malicious user could potentially insert a recipe with a description
    that’s excessively large, posing a risk to your application’s performance and
    storage.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *实现业务逻辑* 的菜谱中，我们将来自 **POST /recipes** 端点的输入数据存储到了数据库中。然而，我们没有实现任何验证逻辑，这意味着我们可能将字符串插入到
    **price** 字段，或者插入一个没有 **name** 的菜谱。此外，考虑到安全问题，恶意用户可能会插入描述过于庞大的菜谱，这可能会对你的应用程序的性能和存储造成风险。
- en: 'In the backend world, there is a rule: never trust the user’s input. Fastify
    knows it well, so it integrates a powerful and feature-complete validation process.
    Let’s see it in action.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端世界中，有一条规则：永远不要信任用户的输入。Fastify 非常了解这一点，因此它集成了一个强大且功能齐全的验证过程。让我们看看它是如何发挥作用的。
- en: How to do it…
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to integrate the validation process:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤集成验证过程：
- en: 'Add the **schema** property to the **POST /recipes** route option:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**schema**属性添加到**POST /recipes**路由选项中：
- en: '[PRE45]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The **jsonSchemaBody** constant is an object defined in the **JSON schema**
    format. This format adheres to the specifications outlined in the JSON schema
    standard, which provides a framework for describing the structure and constraints
    of JSON documents, including those in request bodies. By employing a JSON schema
    interpreter, you can assess whether a given JSON object conforms to a predefined
    structure and constraints, enhancing the validation process for your API requests.
    Fastify includes the AJV ( [https://ajv.js.org/](https://ajv.js.org/) ) module
    to process the JSON schemas and validate the request’s components.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**jsonSchemaBody**常量是在**JSON schema**格式中定义的对象。此格式遵循JSON schema标准中概述的规范，该标准为描述JSON文档的结构和约束提供了一个框架，包括请求体中的文档。通过使用JSON
    schema解释器，你可以评估给定的JSON对象是否符合预定义的结构和约束，从而增强API请求的验证过程。Fastify包括AJV ([https://ajv.js.org/](https://ajv.js.org/))模块来处理JSON模式并验证请求的组件。'
- en: 'The route option **schema** property accepts these fields:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由选项**schema**属性接受以下字段：
- en: '**body** : This schema is used to validate the **request.body** during the
    request evaluation, as we saw in *Figure 6.2* .'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**body**：此模式用于在请求评估期间验证**request.body**，正如我们在*图6.2*中看到的。'
- en: '**params** : This schema validates **request.params** , which contains the
    path parameters of the request URL.'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**params**：此模式验证**request.params**，它包含请求URL的路径参数。'
- en: '**headers** : It is possible to validate **request.headers** ; therefore, we
    may improve the routes protected by the authentication by adding a JSON schema
    that requires the **x-api-key** header to be set.'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**headers**：可以验证**request.headers**；因此，我们可以通过添加一个需要设置**x-api-key**头部的JSON模式来提高受认证的路由的安全性。'
- en: '**query** : We can validate the **request.query** object that contains all
    the query string parameters by using this.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**query**：我们可以使用这个来验证包含所有查询字符串参数的**request.query**对象。'
- en: '**response** : This field is a special one, and it does not accept a JSON schema
    out of the box. We will see it in action in the next *Enhancing application performance
    with* *serialization* recipe.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**response**：这是一个特殊的字段，它不接受默认的JSON模式。我们将在下一个*通过序列化增强应用程序性能*菜谱中看到它的实际应用。'
- en: 'Now, if we restart the server with the new route’s configuration, we will hit
    our first **400 –** **Bad Request** response by running the same command as in
    *Step 8* of the *Implementing the business* *logic* recipe:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们用新的路由配置重新启动服务器，我们将通过运行与*实现业务逻辑*菜谱中的*步骤8*相同的命令来遇到第一个**400 –** **Bad Request**响应：
- en: '[PRE46]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It’s worth noting that, in your scenario, you received only a single error
    message when you expected two errors to be reported:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，在你的场景中，当你预期报告两个错误时，你只收到了一个错误消息：
- en: The first error should relate to the incorrect **country** value. The JSON schema
    specifies an enumeration of just two ISO codes, and the provided value doesn’t
    match either of them.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个错误应该与不正确的**country**值相关。JSON模式指定了仅两个ISO代码的枚举，而提供的数据不匹配任何一个。
- en: The second error pertains to the missing **order** property, but it seems that
    only this error is being displayed in the output message.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个错误与缺少**order**属性有关，但似乎只有这个错误在输出消息中被显示。
- en: 'This situation occurs due to the default AJV configuration that Fastify uses.
    You can check the default setup at [https://github.com/fastify/ajv-compiler#ajv-configuration](https://github.com/fastify/ajv-compiler#ajv-configuration)
    :'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种情况是由于Fastify使用的默认AJV配置引起的。你可以在[https://github.com/fastify/ajv-compiler#ajv-configuration](https://github.com/fastify/ajv-compiler#ajv-configuration)查看默认设置：
- en: '[PRE47]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To resolve the issue and enable the **allErrors** option, you should configure
    the server’s option object that is exported in the **app.js** file. Here’s how
    you can modify the configuration:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决此问题并启用**allErrors**选项，你应该配置在**app.js**文件中导出的服务器选项对象。以下是你可以如何修改配置：
- en: '[PRE48]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'By restarting the application and re-running the **curl** command, we should
    get this new output:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重新启动应用程序并重新运行**curl**命令，我们应该得到这个新的输出：
- en: '[PRE49]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that the **ajv.customOptions** field will be merged with the default configuration,
    so verify each option and set it as it best fits your needs. The validation step
    is one of the most important and requires additional care to secure your APIs.
    Let me suggest my preferred configuration:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，**ajv.customOptions**字段将与默认配置合并，因此请验证每个选项，并将其设置为最适合你需求的方式。验证步骤是最重要的，需要额外的关注来保护你的API。让我建议我首选的配置：
- en: '[PRE50]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The **removeAdditional** option will enforce the removal of all input fields
    that are not explicitly listed in the route’s JSON schemas. This feature is a
    valuable addition to enhance security. It’s important to note that if you do not
    specify a JSON schema for a particular route, the removal logic will not be applied,
    and all input fields will be retained as-is.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**removeAdditional** 选项将强制删除所有在路由的 JSON 模式中未明确列出的输入字段。这个特性是一个有价值的补充，可以增强安全性。重要的是要注意，如果您未为特定路由指定
    JSON 模式，则不会应用删除逻辑，并且所有输入字段将保持原样。'
- en: 'We must implement the **deleteRecipe** function first; therefore, we go into
    the **plugins/datasource.js** file and write the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须首先实现 **deleteRecipe** 函数；因此，我们进入 **plugins/datasource.js** 文件并编写以下代码：
- en: '[PRE51]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To delete the item from MongoDB, we encapsulate the input for **id** within
    **ObjectId** . This is necessary because MongoDB expects the **_id** field to
    be an **ObjectId** when performing document deletions.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要从 MongoDB 中删除项目，我们将 **id** 的输入封装在 **ObjectId** 中。这是必要的，因为 MongoDB 在执行文档删除时期望
    **_id** 字段是一个 **ObjectId**。
- en: 'We can proceed to implement the **DELETE /recipes/:id** handler using all the
    new things we have learned:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以继续实现 **DELETE /recipes/:id** 处理程序，使用我们所学到的所有新知识：
- en: '[PRE52]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The route’s definition incorporates a JSON schema in the **schema.params** property
    to validate the input **id** . We perform a strict check to ensure that **id**
    is exactly 24 characters in length, which is a security measure to prevent potential
    long code injection attacks. Note that this validation is strictly related to
    MongoDB, and it demonstrates how you can protect your routes from bad actors.
    So, tweak this configuration based on your needs.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由的定义在 **schema.params** 属性中包含一个 JSON 模式以验证输入的 **id**。我们执行严格的检查以确保 **id** 的长度正好是
    24 个字符，这是一项安全措施，旨在防止潜在的长期代码注入攻击。请注意，此验证严格相关于 MongoDB，并且它展示了您如何保护您的路由免受恶意行为者的影响。因此，根据您的需求调整此配置。
- en: Meanwhile, in the **removeFromMenu** function implementation, we retrieve the
    recipe from the database by first reading it. Note the use of array destructuring
    because the **readRecipes** function returns an array. If the item is missing
    in the database, we will return a **404 - Not Found** error. Otherwise, we delete
    the record and return a **204** response status code, indicating a successful
    deletion.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，在 **removeFromMenu** 函数实现中，我们首先读取数据库中的食谱。注意使用数组解构，因为 **readRecipes** 函数返回一个数组。如果数据库中缺少项目，我们将返回一个
    **404 - Not Found** 错误。否则，我们删除记录并返回一个 **204** 响应状态码，表示删除成功。
- en: 'It is time to test our code. Therefore, we can try the **curl** commands as
    usual:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候测试我们的代码了。因此，我们可以像往常一样尝试使用 **curl** 命令：
- en: '[PRE53]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this recipe, we’ve successfully implemented all the routes defined in the
    **routes/recipes.js** file. In the upcoming recipe, we will continue by implementing
    the routes defined in **routes/orders.js** while also introducing another exciting
    Fastify feature: serialization!'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们已经成功实现了在 **routes/recipes.js** 文件中定义的所有路由。在下一个食谱中，我们将继续实现 **routes/orders.js**
    中定义的路由，同时介绍另一个令人兴奋的 Fastify 功能：序列化！
- en: Enhancing application performance with serialization
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用序列化提高应用程序性能
- en: The serialization step converts the high-level data generated by business logic,
    including JSON objects or errors, into low-level data, such as strings or buffers,
    which are then sent as responses to the client’s requests. It involves the transformation
    of intricate objects into an appropriate data type that can be effectively transmitted
    to the client. In fact, as mentioned in the *Implementing authentication with
    hooks* recipe, the serialization process is initiated only if the route handler
    doesn’t return a string, stream, or buffer, as these objects are already serialized
    and prepared for transmission as HTTP responses to the client. Nevertheless, this
    process can’t be avoided when you work with JSON objects.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化步骤将业务逻辑生成的高级数据（包括 JSON 对象或错误）转换为低级数据，例如字符串或缓冲区，然后作为对客户端请求的响应发送。它涉及将复杂对象转换为适当的数据类型，以便有效地传输到客户端。实际上，正如在
    *使用钩子实现身份验证* 食谱中提到的，只有当路由处理程序不返回字符串、流或缓冲区时，才会启动序列化过程，因为这些对象已经序列化并准备好作为对客户端的 HTTP
    响应进行传输。尽管如此，当您处理 JSON 对象时，此过程是无法避免的。
- en: Fastify incorporates a serialization module that facilitates the conversion
    of an object into a JSON string, leveraging a JSON schema definition. This module,
    known as **fast-json-stringify** , offers a notable performance boost when compared
    to the standard **JSON.stringify()** function. In fact, it accelerates the serialization
    process by a factor of two for small payloads. Its performance advantage shrinks
    as payload grows, as demonstrated in their benchmark, which is available at [https://github.com/fastify/fast-json-stringify/](https://github.com/fastify/fast-json-stringify/)
    .
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Fastify集成了一个序列化模块，它通过利用JSON模式定义来简化对象到JSON字符串的转换。这个模块被称为**fast-json-stringify**，与标准的**JSON.stringify()**函数相比，提供了显著的性能提升。实际上，对于小型负载，它将序列化过程加速了两倍。随着负载的增长，其性能优势会缩小，这在他们的基准测试中有所体现，基准测试可在[https://github.com/fastify/fast-json-stringify/](https://github.com/fastify/fast-json-stringify/)找到。
- en: How to do it…
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will apply the serialization to the **/orders** endpoints, but first, we
    must create an order. For this recipe, follow these steps:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对**/orders**端点应用序列化，但首先，我们必须创建一个订单。为此，请遵循以下步骤：
- en: 'Let’s implement the **insertOrder** function:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现**insertOrder**函数：
- en: '[PRE54]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The code snippet should be familiar to you. We insert the input object into
    the **orders** collection straight away. Then, we can implement the route handler
    in **routes/orders.js** .
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码片段应该对你来说很熟悉。我们立即将输入对象插入到**orders**集合中。然后，我们可以在**routes/orders.js**中实现路由处理器。
- en: 'Since we need to deal with user input, we can define this JSON schema:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要处理用户输入，我们可以定义这个JSON模式：
- en: '[PRE55]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It defines two properties:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它定义了两个属性：
- en: '**table** : This helps us understand which customer ordered.'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**table**：这有助于我们了解哪个客户下了订单。'
- en: '**dishes** : This is a JSON object array that must have at least one item.
    Every item must contain the recipe **id** and **quantity** .'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dishes**：这是一个必须至少包含一个项目的JSON对象数组。每个项目都必须包含食谱的**id**和**quantity**。'
- en: Thanks to the JSON schema, we can avoid a lot of boring **if** statements and
    checks such as checking if the **quantity** input field is a negative value!
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多亏了JSON模式，我们可以避免很多无聊的**if**语句和检查，例如检查**quantity**输入字段是否为负值！
- en: 'Finally, we can move on to the route implementation:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以继续进行路由实现：
- en: '[PRE56]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You’re likely familiar with the **createOrder** function by now. For the sake
    of simplicity, we’ll store the **request.body.dishes** array as-is without validating
    the IDs. However, I recommend implementing a **preHandler** hook to handle this
    validation step, which the JSON schema can’t perform, and I encourage you to consider
    it as an exercise.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你可能已经熟悉了**createOrder**函数。为了简化，我们将直接存储**request.body.dishes**数组而不验证ID。然而，我建议实现一个**preHandler**钩子来处理这个验证步骤，这是JSON模式无法完成的，我鼓励你将其作为练习来考虑。
- en: 'We are ready to try the route out:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好尝试这个路由：
- en: '[PRE57]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Well done! We have consolidated what we have learned in the *Implementing the
    business logic* recipe. We are now ready to move on to the **GET /orders** route
    to see the serialization process in action.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 干得好！我们已经巩固了在*实现业务逻辑*食谱中学到的知识。我们现在可以继续到**GET /orders**路由，看看序列化过程是如何实际工作的。
- en: 'As usual, we should implement the database access first; therefore, in **plugins/datasource.js**
    , we can write the following:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们应该首先实现数据库访问；因此，在**plugins/datasource.js**中，我们可以编写以下代码：
- en: '[PRE58]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the provided code snippet, there isn’t anything substantially new, except
    that we’re configuring a default sorting by using **createdAt** in reverse order.
    This arrangement prioritizes older orders, ensuring they are fulfilled first.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在提供的代码片段中，并没有什么实质性的新内容，除了我们正在使用**createdAt**进行反向排序来配置默认排序。这种安排优先处理旧订单，确保它们首先得到履行。
- en: 'Then, we can move to the endpoint handler:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以转向端点处理器：
- en: '[PRE59]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The **readOrders** function introduces a more comprehensive logic compared
    to what we saw earlier in *Step 5* . Here’s an overview of the steps it takes:'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**readOrders**函数引入了比我们在*步骤5*中看到的更复杂的逻辑。以下是它所采取的步骤概述：'
- en: Initially, it reads all the pending orders.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，它读取所有待处理的订单。
- en: Then, it collects all the recipe IDs used across all the orders to optimize
    performance by running a single query to select only those recipes that are actually
    used.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它收集所有订单中使用的食谱ID，通过运行单个查询来选择实际使用的那些食谱，从而优化性能。
- en: Finally, it iterates through the orders array to replace the items array, which
    was initially read from the database, with the corresponding recipe items from
    the database.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它遍历订单数组，用从数据库中最初读取的项目数组替换相应的食谱项目。
- en: It’s worth mentioning that we have seen how to use multiple datasource methods
    in one handler. If we would like to optimize the code even further, we could use
    a MongoDB **$lookup** to run a single query to the database instead of two, as
    we did.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，我们已经展示了如何在单个处理程序中使用多个数据源方法。如果我们想进一步优化代码，我们可以使用 MongoDB 的 **$lookup**
    来执行单个数据库查询，而不是我们之前所做的两个查询。
- en: 'One notable detail is the use of a filter to skip recipes that were not found
    in the system. This is an edge case consideration because an order may include
    a recipe that was deleted after it was created, and in such cases, we want to
    ensure that these deleted recipes are not displayed in the output. We are ready
    to test this implementation by executing a command in the shell:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个值得注意的细节是使用过滤器跳过系统中未找到的食谱。这是一个边缘情况考虑，因为订单可能包含在创建后已删除的食谱，在这种情况下，我们希望确保这些已删除的食谱不会显示在输出中。我们准备通过在
    shell 中执行命令来测试此实现：
- en: '[PRE60]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We expect a big output displaying the orders in our system. Here is an example
    of one order output:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们期望在系统中显示大量订单的输出。以下是一个订单输出的示例：
- en: '[PRE61]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see, the provided information contains more details than the target
    user requires. It’s time to configure the serialization process to ensure that
    the data presented to the user is concise and relevant to their needs.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，提供的信息包含比目标用户所需更多的细节。现在是时候配置序列化过程，以确保呈现给用户的数据简明扼要且与其需求相关。
- en: 'In the **routes/orders.js** file, add this JSON schema:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **routes/orders.js** 文件中，添加此 JSON 模式：
- en: '[PRE62]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**orderListSchema** specifically outlines the fields we desire in the response
    payload, mapping only the properties’ types without specifying attributes to define
    the maximum string length or valid number ranges. It’s worth noting the **format**
    attribute, which allows for the customization of the output for a date field.
    However, it’s important to clarify that this concept can sometimes be misunderstood:
    the JSON schema used for serialization does not apply any validation but solely
    filters the data. Therefore, any additional validation rules added to the JSON
    schema will be ignored during the serialization process.'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**orderListSchema** 专门说明了我们希望在响应有效载荷中获得的字段，仅映射属性类型，而不指定属性以定义最大字符串长度或有效数字范围。值得注意的是
    **format** 属性，它允许对日期字段的输出进行自定义。然而，重要的是要澄清，这个概念有时可能会被误解：用于序列化的 JSON 模式不执行任何验证，而仅过滤数据。因此，添加到
    JSON 模式中的任何附加验证规则在序列化过程中都将被忽略。'
- en: 'To apply the JSON schema to the endpoint, we must edit the route’s option as
    follows:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 JSON 模式应用于端点，我们必须按照以下方式编辑路由的选项：
- en: '[PRE63]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To use a JSON schema during serialization, it’s essential to configure the **schema.response**
    object. Notably, you can specify the HTTP status codes to which the particular
    schema should be applied. You have the flexibility to define different schemas
    for various status codes. Additionally, there’s another convenient Fastify pattern
    that you can utilize. By setting the **"2xx"** property within the schema, it
    will be used for all HTTP status codes ranging from 200 to 299, simplifying the
    schema configuration for a range of successful responses.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在序列化过程中使用 JSON 模式时，配置 **schema.response** 对象是至关重要的。值得注意的是，您可以指定特定模式应应用的 HTTP
    状态码。您有灵活性来为不同的状态码定义不同的模式。此外，还有一个方便的 Fastify 模式可供利用。通过在模式中设置 **"2xx"** 属性，它将用于从
    200 到 299 的所有 HTTP 状态码，从而简化了一组成功响应的方案配置。
- en: 'If we run the **curl** command from *Step 7* , we will get even better output:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从 *步骤 7* 运行 **curl** 命令，我们将得到更好的输出：
- en: '[PRE64]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: By successfully implementing a JSON schema for serializing the output of the
    order endpoint, you’ve enhanced both the speed and security of your application.
    This approach ensures that only the designated fields are returned, safeguarding
    against the inadvertent exposure of sensitive data as the database evolves over
    time. Specifying a JSON schema as part of your response is consistently considered
    good practice for maintaining control over the data exposed to clients and enhancing
    overall security.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过成功实现订单端点的 JSON 模式以序列化输出，您已经提高了应用程序的速度和安全性。这种方法确保只返回指定的字段，防止随着时间的推移数据库演变时意外泄露敏感数据。将
    JSON 模式作为响应的一部分指定，始终被认为是维护对客户端暴露的数据的控制并提高整体安全性的良好实践。
- en: With the knowledge and tools we’ve covered thus far, you should be well equipped
    to complete the implementation of the final **PATH /orders/:orderId** route. If
    you encounter any doubts or need further guidance, you can refer to the complete
    source code available in the book’s repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06)
    .
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过到目前为止我们所了解的知识和工具，您应该已经准备好完成最终 **PATH /orders/:orderId** 路由的实现。如果您遇到任何疑问或需要进一步指导，可以参考书中仓库中提供的完整源代码
    [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06)。
- en: Once you’ve finished this route, you can consider the overall application complete.
    While there is room for further improvements, such as adding a JSON schema to
    all the routes, it might be considered optional to delve into this in detail since
    we’ve already covered the fundamental concepts behind it. Now, you are ready to
    move on to the next section, where you’ll learn how to write tests for your Fastify
    application.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成这个路由，您可以考虑整个应用程序已经完成。虽然还有进一步改进的空间，例如为所有路由添加 JSON 模式，但由于我们已经涵盖了其背后的基本概念，因此详细研究这一点可能被认为是可选的。现在，您已经准备好进入下一部分，在那里您将学习如何为您的
    Fastify 应用程序编写测试。
- en: Configuring and testing a Fastify application
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和测试 Fastify 应用程序
- en: In the previous recipe, I mentioned that the application could be considered
    complete. However, as an application truly achieves completeness only when it
    has a comprehensive test suite, in this recipe, our focus shifts to testing our
    endpoints to assert their functionality and correctness. This testing ensures
    that as we make changes to the code in the future, we can reliably verify that
    we have not introduced any new bugs or regressions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我提到该应用程序可以被认为是完整的。然而，一个应用程序只有在拥有全面的测试套件时才真正达到完整，在这个菜谱中，我们的重点转向测试我们的端点，以断言其功能和正确性。这种测试确保了当我们未来对代码进行更改时，我们可以可靠地验证我们没有引入任何新的错误或回归。
- en: We will use the new Node.js test runner in this recipe, providing a sneak peek
    into [*Chapter 8*](B19212_08.xhtml#_idTextAnchor243) , where we will delve deeper
    into this subject and do so in a more focused manner. For now, we will cover the
    basics to get you started with testing. So, let’s start this new goal!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用新的 Node.js 测试运行器，提前预览[*第 8 章*](B19212_08.xhtml#_idTextAnchor243)，我们将更深入地探讨这个主题，并以更专注的方式进行。目前，我们将介绍基础知识，以便您开始测试。所以，让我们开始这个新目标！
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will begin this recipe by reading the application’s configuration, followed
    by writing application tests.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个菜谱开始，先读取应用程序的配置，然后编写应用程序测试。
- en: 'Up until now, we’ve hardcoded certain elements in our code, including the following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在代码中硬编码了某些元素，包括以下内容：
- en: The database connection URL
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接 URL
- en: The API key for authentication
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于身份验证的 API 密钥
- en: However, this approach isn’t ideal for our application because we should have
    the flexibility to change these values as needed, especially in different environments.
    The best practice in such cases is to access the environment variables provided
    by the system. Additionally, this is a requirement for writing tests, allowing
    us to inject different configurations as necessary for testing various scenarios
    and environments.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并不适合我们的应用程序，因为我们应该有灵活性，根据需要更改这些值，尤其是在不同的环境中。在这种情况下，最佳实践是访问系统提供的环境变量。此外，这是编写测试的要求，允许我们根据需要注入不同的配置，以测试各种场景和环境。
- en: How to do it…
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To achieve this task, we need to follow these steps:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们需要遵循以下步骤：
- en: 'Install a new Fastify module:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个新的 Fastify 模块：
- en: '[PRE65]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we need to create a new file, **plugins/config.js** , with the following
    content:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个新的文件，**plugins/config.js**，内容如下：
- en: '[PRE66]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The plugin code should be fairly understandable, even if you’re encountering
    it for the first time. This plugin defines an **envSchema** constant with a JSON
    schema. This schema is subsequently used as a configuration for the **@fastify/env**
    module. This module validates the **process.env** object against the provided
    input schema. Consequently, if the required configuration is missing or incorrect,
    the application will not start successfully. Moreover, the **confKey** option
    lets you set a custom name for the server decorator that this module is going
    to add.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使你是第一次遇到这段插件代码，它也应该相当容易理解。此插件定义了一个带有 JSON 模式的 **envSchema** 常量。此模式随后用作 **@fastify/env**
    模块的配置。此模块将提供的输入模式与 **process.env** 对象进行验证。因此，如果缺少或配置错误所需的配置，应用程序将无法成功启动。此外，**confKey**
    选项允许你为该模块将要添加的服务器装饰器设置一个自定义名称。
- en: 'If you register this plugin in the **app.js** file and attempt to restart the
    server, you will encounter an error during the startup process:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将此插件注册到 **app.js** 文件中并尝试重启服务器，你将在启动过程中遇到错误：
- en: '[PRE67]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To fix this configuration issue, we need to begin passing the **opts** argument
    in our plugin declarations. Let’s address this problem using a top-down approach.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了修复这个配置问题，我们需要开始在插件声明中传递 **opts** 参数。让我们使用自顶向下的方法来解决这个问题。
- en: 'Start by opening the **server.js** file and making the following updates:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 **server.js** 文件并执行以下更新：
- en: '[PRE68]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We introduced a configuration object during the registration of **appPlugin**
    . The **applicationEnv** property is derived from merging **process.env** with
    the default values specified in the code. In cases where **process.env** contains
    values for **API_KEY** or **DATABASE_URL** , these environment-specific values
    take precedence over the defaults defined in the code.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在注册 **appPlugin** 时引入了一个配置对象。**applicationEnv** 属性是通过将 **process.env** 与代码中指定的默认值合并而得到的。在
    **process.env** 包含 **API_KEY** 或 **DATABASE_URL** 的值的情况下，这些特定于环境的值将优先于代码中定义的默认值。
- en: 'Now, we need to go back to **app.js** and update it accordingly:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要回到 **app.js** 并相应地更新它：
- en: '[PRE69]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this context, the **opts** argument corresponds to the second object parameter
    we recently added in the **server.js** file. Consequently, **configPlugin** also
    receives the same object because we added it during the registration. If we refer
    back to the initial code snippet in this recipe, which showcases the **configPlugin**
    implementation, you’ll observe that we’ve already supplied the **opts.applicationEnv**
    option to **@fastify/env** . This indicates that it’s now reading the correct
    configuration.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此上下文中，**opts** 参数对应于我们在 **server.js** 文件中最近添加的第二个对象参数。因此，**configPlugin** 也接收相同的对象，因为我们是在注册时添加的。如果我们回顾这个菜谱中的初始代码片段，它展示了
    **configPlugin** 的实现，你会注意到我们已经向 **@fastify/env** 提供了 **opts.applicationEnv** 选项。这表明它现在正在读取正确的配置。
- en: With these adjustments, we should be able to restart the server successfully.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些调整，我们应该能够成功重启服务器。
- en: 'We have changed a lot of code but still need to remove the hardcoded configuration
    from the plugins. Let’s do it now, starting with the **app.js** file:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经更改了很多代码，但仍需要从插件中删除硬编码的配置。现在，让我们从 **app.js** 文件开始做：
- en: '[PRE70]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this code snippet, you’ll notice a new syntax: **await app.register()**
    . Now, **await** is crucial because, without it, your server won’t start. As a
    reminder, in the *Splitting the code into small plugins* recipe, we discussed
    that plugin functions are not executed until one of the following methods is called:
    **app.listen()** , **app.ready()** , or **app.inject()** . While this principle
    remains accurate, using **await app.register()** effectively triggers Fastify
    to initiate the loading process up to the awaited line, ensuring the necessary
    setup occurs before further execution. In fact, we use the **app.appConfig** decorator
    in the following line, and this field will remain undefined if we don’t wait for
    ( await) **configPlugin** .'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你会注意到一个新的语法：**await app.register()**。现在，**await** 是至关重要的，因为没有它，你的服务器将无法启动。作为提醒，在
    *将代码拆分为小插件* 的菜谱中，我们讨论了插件函数只有在以下方法之一被调用时才会执行：**app.listen()**、**app.ready()** 或
    **app.inject()**。虽然这个原则仍然是正确的，但使用 **await app.register()** 有效地触发了 Fastify 在等待行之前启动加载过程，确保在进一步执行之前完成必要的设置。实际上，我们在下一行使用了
    **app.appConfig** 装饰器，并且如果不在（await）**configPlugin** 中等待，这个字段将保持未定义状态。
- en: 'In the **plugins/datasource.js** file, we can update the MongoDB setup:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**plugins/datasource.js**文件中，我们可以更新MongoDB的设置：
- en: '[PRE71]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In **plugins/auth.js** , we can remove the hardcoded API key as follows:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**plugins/auth.js**文件中，我们可以按照以下方式移除硬编码的API密钥：
- en: '[PRE72]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Great job! You’ve now achieved a dynamic application that adapts its configuration
    based on the environment, validates prerequisites before starting, and leverages
    another feature of Fastify’s plugin system by utilizing the ability to await a
    plugin. Additionally, you’ve improved the authentication and data source plugins,
    making them more configurable and suitable for use across your organization’s
    projects. By configuring the plugins via the **register** method, we can create
    plugins that are decoupled from the rest of the application and do not require
    the **app.appConfig** decorator to work.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 干得好！你现在已经实现了一个动态应用程序，它根据环境调整其配置，在启动前验证先决条件，并通过利用等待插件的能力，利用Fastify插件系统的另一个特性。此外，你改进了身份验证和数据源插件，使它们更具可配置性，并适合在组织内的项目中使用。通过通过**register**方法配置插件，我们可以创建与应用程序其余部分解耦的插件，并且不需要**app.appConfig**装饰器即可工作。
- en: With all these pieces in place, you’re well prepared to begin writing your test
    suite. The dynamic configuration you’ve created will prove invaluable as you embark
    on the testing phase of your project.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有这些组件就绪的情况下，你已充分准备开始编写你的测试套件。你创建的动态配置在你开始项目的测试阶段将证明非常有价值。
- en: Your Fastify application can be effectively represented by the **appPlugin**
    instance and the server’s configuration exported by the **app.js** file. In fact,
    there is minimal value in testing the **server.js** file, as it primarily serves
    as a straightforward runner that can be readily replaced by the **fastify-cli**
    module when necessary.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的Fastify应用程序可以有效地由**appPlugin**实例和由**app.js**文件导出的服务器配置来表示。实际上，测试**server.js**文件的价值很小，因为它主要是一个简单的运行器，当需要时可以很容易地由**fastify-cli**模块替换。
- en: 'The initial step of writing tests for a Fastify application is to enable the
    creation of a **test/helper.js** file:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Fastify应用程序编写测试的第一步是启用创建一个**test/helper.js**文件：
- en: '[PRE73]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We are ready to write our first test file: **test/app.test.js** .'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经准备好编写我们的第一个测试文件：**test/app.test.js**。
- en: 'We must import the new **Node.js test** **runner** modules:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须导入新的**Node.js测试****runner**模块：
- en: '[PRE74]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: A complete list of its APIs can be found in the official documentation at [https://nodejs.org/api/test.html](https://nodejs.org/api/test.html)
    .
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它的完整API列表可以在官方文档[https://nodejs.org/api/test.html](https://nodejs.org/api/test.html)中找到。
- en: 'We need to import the **buildApplication** utility:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入**buildApplication**实用工具：
- en: '[PRE75]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We need to define a test case using the **test** function. The first parameter
    is a descriptive string that helps identify which test is currently executing.
    The second argument is an asynchronous function that takes a test context parameter:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用**test**函数定义一个测试用例。第一个参数是一个描述性字符串，有助于识别当前正在执行的哪个测试。第二个参数是一个异步函数，它接受一个测试上下文参数：
- en: '[PRE76]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To run the test file, we need to execute this command:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行测试文件，我们需要执行以下命令：
- en: '[PRE77]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How it works…
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '**test/helper.js** exports a **buildApplication** function that instantiates
    the Fastify root server instance and registers **appPlugin** , as carried out
    by the **server.js** file. The differences are the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**test/helper.js**导出一个**buildApplication**函数，该函数实例化Fastify根服务器实例并注册**appPlugin**，正如**server.js**文件所执行的那样。以下是一些差异：'
- en: The **app** constant is just returned, and we do not call the **listen()** method.
    In this way, we are not blocking a host’s port.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**app**常量只是返回，我们没有调用**listen()**方法。这样，我们就不会阻塞主机的端口。'
- en: The default server’s options are the same as **server.js** with the logger turned
    off. Anyway, we can customize them by providing a second argument to the factory
    function.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认服务器的选项与**server.js**相同，只是关闭了日志记录。无论如何，我们可以通过向工厂函数提供第二个参数来自定义它们。
- en: The default environment setup does not read the **process.env** object, but
    it defines good defaults with which to run the application in every local development
    environment.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的环境设置不读取**process.env**对象，但它定义了良好的默认值，以便在每一个本地开发环境中运行应用程序。
- en: As we are running the application, a connection to the database will be established.
    To ensure the test completes successfully, it’s essential to close the server
    and database connection after the test has executed all the assertions. This cleanup
    step is crucial for the proper functioning of subsequent tests and to avoid resource
    leaks.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在运行应用程序，将建立与数据库的连接。为了确保测试成功完成，在测试执行所有断言之后关闭服务器和数据库连接是至关重要的。这个清理步骤对于后续测试的正确运行和避免资源泄漏至关重要。
- en: Lastly, we can use Fastify’s **app.inject()** method. Unlike calling the **listen**
    method, this approach starts the server without actively listening for incoming
    HTTP requests, enabling faster execution. The **inject** method then generates
    a simulated HTTP request and sends it to the server, which processes it in the
    same way it would a genuine request, producing an HTTP response. This method returns
    the HTTP response, allowing us to verify its content to validate our expectations.
    The **inject** method accepts an object parameter for specifying various HTTP
    request components. We’ll explore more examples in the *There’s more...* section
    of this recipe.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 Fastify 的 **app.inject()** 方法。与调用 **listen** 方法不同，这种方法启动服务器时不会主动监听传入的
    HTTP 请求，从而实现更快的执行。然后，**inject** 方法生成一个模拟的 HTTP 请求并将其发送到服务器，服务器会以处理真实请求相同的方式处理它，生成
    HTTP 响应。此方法返回 HTTP 响应，使我们能够验证其内容以验证我们的预期。**inject** 方法接受一个对象参数，用于指定各种 HTTP 请求组件。我们将在本食谱的
    *还有更多...* 部分中探索更多示例。
- en: At the end of the test case, we assert that the response has the correct status
    code and payload.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例结束时，我们断言响应具有正确的状态码和有效载荷。
- en: The test output provides a summary of the entire execution process. In the event
    of an error, it displays a detailed message indicating the failed assertion. For
    experimental purposes, you can attempt to break the test by modifying the **deepStrictEqual**
    check, for instance, by editing the **version** property. This will help you observe
    how tests respond to changes and failures, allowing you to refine and improve
    them as needed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 测试输出提供了整个执行过程的摘要。在发生错误的情况下，它会显示一个详细的消息，指出失败的断言。出于实验目的，你可以尝试通过修改 **deepStrictEqual**
    检查来破坏测试，例如，通过编辑 **version** 属性。这将帮助你观察测试如何对更改和失败做出响应，从而允许你根据需要对其进行优化和改进。
- en: There’s more...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Before wrapping up this recipe, it would be useful to check a more complex
    test case, so let’s quickly analyze this code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这个食谱之前，检查一个更复杂的测试用例可能会有所帮助，所以让我们快速分析一下这段代码：
- en: '[PRE78]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This new test case examines the **A unknown user cannot create a recipe** condition.
    In this scenario, we inject a custom API key within the **buildApplication** function
    and subsequently confirm that if the **POST /recipes** request lacks the valid
    header, it will be rejected. We saw also that the **inject** method accepts the
    **payload** and **headers** fields to control every request’s aspect.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的测试用例检查了 **未知用户不能创建食谱** 的条件。在这种情况下，我们在 **buildApplication** 函数中注入一个自定义 API
    密钥，然后确认如果 **POST /recipes** 请求缺少有效的头信息，它将被拒绝。我们还看到，**inject** 方法接受 **payload**
    和 **headers** 字段来控制每个请求的各个方面。
- en: 'Furthermore, we can enhance the code by introducing an additional test case
    to ensure that a valid chef can, indeed, create a recipe and that the newly created
    recipes appear on the menu. This additional test will further validate the application’s
    functionality:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过引入一个额外的测试用例来增强代码，以确保有效的厨师确实可以创建食谱，并且新创建的食谱会出现在菜单上。这个额外的测试将进一步验证应用程序的功能：
- en: '[PRE79]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that the **app.inject()** method has a shortcut to run simple **GET** requests
    also. It requires the URL string only.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**app.inject()** 方法还有一个快捷方式来运行简单的 **GET** 请求。它只需要 URL 字符串。
- en: Implementing tests for the application’s routes to cover all use cases is a
    valuable exercise for becoming proficient with the APIs and the test suite. You
    now have the fundamental knowledge needed to tackle this task by drawing upon
    what you’ve learned. Refer to the book’s source code repository for additional
    code examples and guidance. Good luck, and well done on your progress!
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序的路由实现测试以覆盖所有用例是熟练掌握 API 和测试套件的有价值练习。你现在拥有了完成这项任务所需的基本知识，可以通过运用你所学的知识来应对。请参考书籍的源代码仓库以获取更多代码示例和指导。祝你好运，恭喜你在进步上取得的成就！
- en: Throughout this chapter, you’ve delved into some of Fastify’s most crucial features,
    including the plugin system and the wide number of hooks. You’ve also gained insights
    into the essential aspects of a Fastify application, such as configuration and
    code reusability. Moreover, your proficiency in working with MongoDB has undoubtedly
    improved.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你深入研究了Fastify的一些最关键特性，包括插件系统和大量的钩子。你还对Fastify应用程序的基本方面有了深入了解，例如配置和代码复用。此外，你在使用MongoDB方面的熟练度无疑也得到了提高。
- en: If you’re enthusiastic about Fastify and eager to explore more, you might find
    the book *Accelerating Server-Side Development with Fastify* by *Packt Publishing*
    at [https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582](https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582)
    to be an invaluable resource for furthering your knowledge and skills in this
    powerful framework. Keep up the great work!
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你热衷于Fastify并渴望探索更多，你可能会发现由*Packt Publishing*出版的书籍《*使用Fastify加速服务器端开发*》[https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582](https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582)是进一步深化你在这一强大框架中的知识和技能的无价资源。继续保持你的出色工作！
