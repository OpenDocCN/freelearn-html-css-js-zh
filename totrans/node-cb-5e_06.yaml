- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Fastify – The Web Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19212_04.xhtml#_idTextAnchor100) , we learned about the low-level
    APIs provided by Node.js core for building web applications. However, using those
    APIs can be challenging sometimes, demanding substantial effort to translate conceptual
    ideas into functional software. For this reason, web frameworks are pivotal for
    quickly developing robust HTTP servers within the Node.js ecosystem. A web framework
    abstracts web protocols into higher-level APIs, allowing you to implement your
    business logic without the need to address everyday tasks, such as parsing the
    body of an HTTP request or reinventing an internal router.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces Fastify, the fastest web framework with the lowest overhead
    available for Node.js. Fastify places a high emphasis on enhancing the developer’s
    experience, powering you to build APIs while ensuring outstanding application
    performance. It closely adheres to web standards, ensuring compatibility and reliability.
    Moreover, it boasts an impressive degree of extensibility, enabling you to customize
    your server to align precisely with your unique requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore Fastify through the following learning path:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API starter using Fastify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting the code into small plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication with hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking the encapsulation using hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the input data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing application performance with serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and testing a Fastify application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter successfully, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Node.js v22 installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE such as VS Code from [https://code.visualstudio.com/](https://code.visualstudio.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working command shell with **curl** from [https://curl.se/download.html](https://curl.se/download.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A MongoDB installation from [https://www.mongodb.com/](https://www.mongodb.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the snippets in this chapter are on GitHub at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API starter using Fastify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fastify** ( [https://fastify.dev/](https://fastify.dev/) ) is a Node.js web
    framework for constructing web applications. It facilitates the development of
    an HTTP server and the creation of your API in a straightforward, efficient, scalable,
    and secure manner. The first Fastify’s stable release dates back to 2018. Since
    then, it has garnered a substantial community, boasting over 7 million monthly
    downloads. Moreover, it maintains a consistent release schedule, with a major
    version update approximately every two years.'
  prefs: []
  type: TYPE_NORMAL
- en: Because practical experience is often the most effective way to learn, in this
    chapter, we will undertake the implementation of an API server for our brand-new
    fantasy restaurant! Our objectives encompass displaying the menu, allowing the
    chef to add or remove recipes, and enabling guests to place orders that the chef
    will receive and cook!
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s start our hands-on session with Fastify, and at the end of this chapter,
    you will evaluate whether Fastify is simple to use or not!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to set up the developer environment. To do this, you can create
    a new Node.js project by running the following commands in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have initiated the **fastify-restaurant** folder with the installed **fastify**
    module at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a Fastify server, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **fastify** version 5 module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **index.js** file with the following content to import the dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Thanks to the imported dependency, we can instantiate a Fastify instance by
    executing the **fastify** factory function. The **app** constant will be our **root
    application instance** that identifies the Fastify API at your disposal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we are passing the **serverOptions** object as an argument. It contains
    the **logger: true** property to turn on the application logger! The **fastify**
    factory accepts many options, which we will see later in this chapter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the **app** instance, we can add routes to the server using the **get()**
    method. The handler returns the payload that we would like to return as a response.
    In this case, we add an HTTP **GET** handler to the **/** endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a **port** variable in order to select where the server listens for
    HTTP requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We read the variable from the environment settings or set a default value. This
    is useful because, usually, on the server where we install the application, the
    PORT setting is already set (for example, Heroku).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can start our server by calling the **listen** method. The **host**
    parameter with the **0.0.0.0** value will configure your server to accept connections
    from any IPv4 address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This setup is essential for applications running in Docker containers or any
    application directly accessible on the internet. Without this configuration, external
    clients won’t be able to access your HTTP server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are now ready to start the server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you may have noticed, we can see multiple IP addresses where the HTTP server
    is listening. This is due to the **0.0.0.0** host configuration, which listens
    for both the localhost name and the local IP address to handle external calls.
    If we change **0.0.0.0** to **localhost** , our HTTP server will be available
    only from the local PC, printing a single log message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The console log tells us that the server has started successfully; therefore,
    if you open a new terminal and run a **curl** command, you will get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a few lines of code, you have created a Fastify server with a logger that
    is ready to use and responds with a JSON payload on the **/** route!
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, Fastify comes equipped with numerous built-in features, such as the
    application logger, by using the popular Node.js logger **pino** ( [https://getpino.io/](https://getpino.io/)
    ) and an automatic handling JSON format without additional dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will refactor the code to start giving shape to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the code into small plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implemented the API root endpoint in the *Creating an API starter using Fastify*
    recipe, which is often used as a health check to verify whether the server started
    successfully. However, we can’t keep adding all the application’s routes to the
    **index.js** file; otherwise, it would become unreadable in no time. So, let’s
    split our **index.js** file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To split our **index.js** file, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **app.js** file and move the **serverOptions** constant with the
    following server configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define our first plugin interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A plugin is an **async** function that accepts two arguments: the first is
    a Fastify server instance, and the second is an **options** object, which is empty
    for now. We will use it later in the *Implementing authentication with hooks*
    recipe. This function may assume a different declaration if it is not an **async**
    function. In this case, there would be a third argument: **function syncAppPlugin(app,
    opts, next){}** ; it is a function that we must call to tell the Fastify framework
    when the plugin is loaded.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to export the plugin function as a default and the server
    configuration as named export options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create the **server.js** file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to try out that we have completed the refactoring correctly; you
    can execute the **node server.js** command, and it should initiate the server,
    as it did in the previous *Creating an API starter using* *Fastify* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve created our initial Fastify plugin in **app.js** .
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to note that the intention of this section is not to delve deeply
    into Fastify’s powerful plugin system, which we will explore comprehensively in
    the *Implementing authentication with hooks* recipe. At this juncture, we are
    primarily utilizing it as a tool to organize our code into manageable components.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **app.js** file serves as the entry point for our application. We have chosen
    to export the recipe’s code in a format that is compatible with **fastify-cli**
    ( [https://github.com/fastify/fastify-cli](https://github.com/fastify/fastify-cli)
    ). This tool is designed to facilitate application startup and enhance our developer
    experience. While we won’t delve into its details in this book, it’s worth noting
    that the code we write here will provide you with the flexibility to transition
    to **fastify-cli** seamlessly, should you choose to do so in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The **server.js** file has a singular purpose; it imports the **app.js** file
    and uses the options object to instantiate the root application instance, as we’ve
    done before in the *Creating an API starter using* *Fastify* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The noteworthy addition here is the **register()** method. This Fastify function
    attaches plugins to the Fastify server, ensuring that they are loaded sequentially
    according to the order in which they are registered. After registering a function
    plugin, it is not executed until we execute the **listen()** , **ready()** , or
    **inject()** methods. We will explore the latter two methods in the *Configuring
    and testing a Fastify* *Application* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: This minor refactoring represents a significant step forward, as it bolsters
    our confidence in understanding the Fastify plugin interface. Moreover, it neatly
    separates the business logic from the technical task of launching the web server.
    As a result, the **server.js** file will never change, allowing us to focus on
    the **app.js** file exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: We will add our initial business logic routes in the forthcoming recipe, so
    stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To specify how the application responds to client requests, routes must be
    defined. Each route is identified mainly by an HTTP method and a URL pattern,
    which must align with the incoming request to execute the associated handler function.
    We are currently exposing only one single route: **GET /** . If you try to hit
    a different endpoint, you will receive a **404 Not** **Found** response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Fastify automatically handles 404 responses. When a client attempts to access
    a non-existent route, Fastify will generate and send a 404 response by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’re developing a web server to provide APIs for our fantasy restaurant,
    it’s essential to outline the routes we need to implement in order to fulfill
    our objectives. Some of the necessary routes may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET /menu** : Retrieves the restaurant’s menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET /recipes** : This replies with the same logic as the **GET /** **menu**
    handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST /recipes** : Enables the chef to add a new dish to the menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE /recipes/:id** : Allows the chef to remove a recipe from the menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST /orders** : Allows guests to place orders for dishes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET /orders** : Returns a list of the pending orders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATCH /orders/:orderId** : Enables the chef to update the status of an order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement all these routes effectively, we should follow an iterative approach,
    continuously enhancing our code with each iteration. The steps for our development
    process will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define the route handlers** : Begin by defining the route with an empty handler.
    We will cover it in this recipe.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement route logic** : Incorporate the necessary logic within your route
    handlers to handle tasks, such as retrieving the menu, adding new menu items,
    processing orders, and updating order statuses. We will do this in the *Implementing
    authentication with* *hooks* recipe.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Validation and error handling** : Implement validation checks to ensure that
    incoming data are accurate and handle errors gracefully by providing informative
    error messages and appropriate HTTP status codes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Testing** : Thoroughly test each route to confirm that it functions as expected.
    Consider various scenarios, including valid and invalid input. We will cover this
    in the *Configuring and testing a Fastify* *application* recipe.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Documentation** : We must not forget to write up a comprehensive **README.md**
    file within our source code to ease our team’s work.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let’s begin with the first step.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can discern two primary entities within our set of endpoints: **recipes**
    and **orders** . For defining route handlers, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To enhance code organization, we’ll create two distinct files, with one for
    each entity. Additionally, to maintain a structured approach, we’ll establish
    a **routes/** folder and create the **routes/recipes.js** file within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initial route we need to define is **GET /menu** . In this scenario, we
    employ the versatile **route()** method to construct it. This method requires
    an input object containing three obligatory parameters: **method** , **url** ,
    and **handler** , as illustrated in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a comprehensive list of the acceptable parameters, please consult the documentation
    at https://fastify.dev/docs/latest/Reference/Routes/#routes-options. Note that
    we must execute the **next** argument, as discussed in the *Splitting the code
    into small plugins* recipe. This is only another style with which to define plugins,
    and it is the most performant choice when we don’t need async operations during
    plugin loading. Moreover, it is important to remember that it must be the last
    operation to execute, and after calling it, it is not possible to add more routes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a new **menuHandler** function alongside the **plugin** function, which
    may prompt the question, How can we access the server’s resources? Fastify simplifies
    this process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you define a named function, as demonstrated in the preceding code example,
    you can utilize the **this** keyword within its context. In this context, **this**
    is equivalent to the **app** variable, granting you access to all of the server’s
    resources, such as the database or the configuration settings, as we’ll explore
    in the *Adding routes* recipe. However, as shown in this particular example, we’re
    introducing **this.log** and the **request.log** property, which provide access
    to the logger object, enabling us to integrate logging into our application seamlessly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before continuing, we must not forget to update the **app.js** file when registering
    the new plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start the server with the **node server.js** command and execute
    a call against it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will discuss the source code for **routes/recipes.js** in detail in the *How
    it works…* section of this recipe. Now, we can define the remaining routes within
    the body of the **recipesPlugin** function. So, we can delve deeper into Fastify’s
    syntax by adding the new routes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **GET /recipes** endpoint combines elements from both the **get()** method
    that we saw previously in *Step 4* of the *Creating an API starter using Fastify*
    recipe and the generic **route()** method. You can designate the **url** as the
    first parameter and the route’s options as the second one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The coolest thing here is that we’re utilizing the same **menuHandler** function
    for both the **/menu** and **/recipes** endpoints, aligning with the requirements
    we established earlier in the introduction of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, defining a **POST /recipes** route appears to be a straightforward task
    in light of our previous work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, let’s discuss further the definition of the **DELETE /recipes/:id**
    route. Firstly, the **:id** pattern within the URL strin g serves as a **path
    parameter** . A path parameter is a positional variable segment of the URL. When
    a client makes a **DELETE** request to **/recipes/something** , the value of **something**
    will be assigned to the **request.params.id** property. It’s worth noting that
    **request.params** is a JSON object that contains all the path parameters you
    may define within the URL. Secondly, we’ve defined the **removeFromMenu** function
    as a synchronous function, meaning it is not **async** . In such cases, we cannot
    directly return or throw the desired response body. Instead, we must call the
    **reply.send()** method, which is responsible for transmitting the response payload
    to the client. This payload can be a string, a JSON object, a buffer, a stream,
    or an error object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t mix async with sync: It’s crucial to emphasize that you cannot mix the
    async and sync handler styles; otherwise, unexpected errors will appear on the
    console. As a key takeaway, remember the following guidelines: if the handler
    is asynchronous, return the desired payload; otherwise, if the handler is synchronous,
    you must use the **reply.send()** function to send the response. In my experience,
    it is more effective to stick to the async style in a project to avoid confusion
    across the team and with different backgrounds. Furthermore, the **reply** object
    is a fundamental component of Fastify that provides additional utilities, enabling
    you to customize the response code or append new response headers as needed. We
    will show an example in the *Implementing authentication with* *hooks* recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, we find ourselves re-iterating a procedure similar
    to what we’ve previously executed for the **GET /** route in the *Creating an
    API starter using Fastify* recipe. However, in this instance, we’re employing
    an alternative syntax provided by Fastify. In this new plugin, for the **./routes/recipes.js**
    declaration, we use the callback style. It is crucial to note that we are calling
    the **next()** function at the end of the plugin. If you omit it, Fastify will
    fail its startup and will trigger an **FST_ERR_PLUGIN_TIMEOUT - Plugin did not
    start in time: ''recipesPlugin''. You may have forgotten to call ''done'' function
    or to resolve a** **Promise** error.'
  prefs: []
  type: TYPE_NORMAL
- en: The **curl** request illustrates how Fastify employs a default error handler;
    it captures any thrown errors and responds with a 500 HTTP status code along with
    the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In moving to the server’s log output instead, we should see the following alongside
    the logged error stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can observe the difference highlighted in the preceding code block. When
    you utilize the request’s **log** , the log entry will incorporate a **reqId**
    field. This feature proves quite useful in discerning which logs relate to a specific
    request, facilitating the reconstruction of the entire sequence of actions an
    HTTP request has undertaken within the application. Fastify assigns a unique identifier
    to each request by default, starting with **req-1** and incrementing the number.
    Additionally, this counter resets to its initial state with every server restart.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to customize the request id, you have two options. You can configure
    the **requestIdHeader** server option, instructing Fastify to extract the id from
    a specific HTTP header. Alternatively, you can supply a **genReqId** function,
    granting you full control over the id generation process. For further information,
    please refer to the official documentation at [https://fastify.dev/docs/latest/Reference/Server](https://fastify.dev/docs/latest/Reference/Server)
    .
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, we have established the scaffolding for the **recipes.js**
    file. It’s time to create a new **routes/orders.js** file and define the final
    three routes required to accomplish our objective. I encourage you to take on
    this task as an exercise. If you encounter any issues, you can check the following
    code to be inspired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget to update the **app.js** file to expose the new empty routes.
  prefs: []
  type: TYPE_NORMAL
- en: Following this recipe, you should be well equipped to declare various routes
    and return plain data, such as strings or JSON objects. In the upcoming recipe,
    we will delve into implementing the fundamental business logic of our APIs by
    exploring the Fastify plugin system and its components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication with hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve already utilized Fastify plugins to organize routes and enhance the maintainability
    of our project, but these are just some of the advantages that the Fastify **plugin
    system** provides. The key features of the plugin system are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** : All the hooks, plugins, and decorators added to a plugin
    are bound to the plugin context, ensuring they remain encapsulated within the
    plugin’s scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation** : Each plugin instance is self-contained and operates independently,
    avoiding any modifications to sibling plugins. This isolation ensures that changes
    or issues in one plugin do not affect others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance** : A plugin inherits the configuration of its parent plugin,
    allowing for a hierarchical and modular organization of plugins, making it easier
    to manage complex application structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These concepts might appear complex at first, but in this recipe, we will put
    them into practical use. Specifically, we will implement protection mechanisms
    for routes that only a chef should be able to access. This is a crucial step to
    prevent misuse by unauthorized users who might attempt to make destructive changes
    to the fantasy restaurant’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'The authentication must grant access to a chef user to these endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '**POST /recipes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE /recipes/:id**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATCH /orders/:orderId**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To streamline the logic, we define a chef as any HTTP request that includes
    the **x-api-key** header with a valid secret value. The server must return a **401
    – Unauthorized** HTTP response if the authentication fails. This approach simplifies
    the verification process for chef access.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before getting into the code, I recommend testing all the listed endpoints
    to confirm that you can access them and receive the expected **Not implemented**
    error message. By the end of this recipe, we anticipate that executing the following
    **curl** commands will result in an **Unauthorized** error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are going to explore all the plugin system features right now with a trial-and-error
    example. So, be ready to restart the server and execute the **curl** commands.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the Fastify server by manually killing the Node.js process can be
    cumbersome. To streamline this process, you can run the application using the
    **node --watch server.js** argument. Node.js 20 introduces the watch mode feature,
    which automatically restarts the process whenever a file changes, making development
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the authentication, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **routes/recipes.js** file by adding an **onRequest** **hook** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A hook is a function that executes, as required, throughout the lifecycle of
    the application or during a single request and response cycle. It provides the
    capability to inject custom logic into the framework itself, enhancing reusability
    and allowing for tailored **behavior** at specific points in the application’s
    execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see it in action by running these **curl** commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have introduced the **onRequest** hook. This means the **isChef** function
    will run whenever a new HTTP request comes into the server. The logic of this
    hook is to verify the property of **request.headers** to check whether the expected
    header has the **fastify-rocks** value. If the check is unsuccessful, the hook
    throws an error after setting the HTTP response status code using the **reply.code()**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we analyze the console output, we can see the plugin system in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** : We have incorporated a hook within the **recipesPlugin**
    function, and this hook’s function is executed for every route defined within
    the same plugin scope. As a result, the **GET /recipes** route returns a 401 error,
    demonstrating how hooks can encapsulate and apply logic consistently within a
    plugin’s context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation** : Whenever Fastify executes the **register()** method, it generates
    a new **plugin instance** , analogous to the **app** argument in the **plugin**
    function declaration. This instance acts as a child object of the **root application**
    instance, ensuring isolation from sibling plugins and enabling the construction
    of independent components. This isolation is why the **PATCH /orders/fake-id**
    request remains unaffected and continues to return the old **Not implemented**
    error. It highlights that the scope of **ordersPlugin** remains isolated from
    that of the **recipesPlugin** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To evaluate the **Inheritance** feature, you must move the **onRequest** hook
    from the **routes/recipes.js** file to the **app.js** file. After this modification,
    executing the previous curl commands will indeed result in an **Unauthorized**
    error. This outcome occurs because both **ordersPlugin** and **recipesPlugin**
    are children of the **appPlugin** plugin instance and inherit all of its hooks,
    including the **onRequest** hook.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we resolve the current scenario where all our routes are protected?
    Exploring the plugin system offers a multitude of approaches to achieve this objective,
    as it heavily relies on your project’s structure and the contexts you need to
    consider. Let’s see two approaches for each plugin in the **routes/** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial step involves centralizing the authentication logic; to facilitate
    this, we introduce **Decorators** . Decorators empower you to enhance the default
    functionalities of Fastify components, minimizing code duplication and providing
    rapid access to the application’s resources, such as a database connection. A
    decorator can be attached to the server instance, the request, or the reply object;
    this depends on the context it belongs to. Let’s add this to **app.js** after
    removing the **onRequest** hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We’ve defined an **isChef** request decorator, enabling the execution of the
    **request.isChef()** function within the **appPlugin** context and its child plugin
    instances. The logic within the **isChef** function is straightforward, returning
    a Boolean value of **true** only when a valid header is detected. It’s important
    to note that when we define a request or reply decorator, the **this** context
    refers to the request or reply object, respectively. This context is crucial for
    accessing these objects within the decorator function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced an instance decorator named **authOnlyChef** . This decorator
    exposes a function with an identical API to the **onRequest** hook we previously
    defined. It can be accessed through the **app.authOnlyChef** property, offering
    a convenient way to apply authentication logic specific to chefs across various
    routes and plugins only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining decorators doesn’t execute any logic; for them to execute on their
    own, we need to utilize them within our routes. Let’s proceed to the **routes/orders.js**
    file and modify the **/orders/:orderId** route to implement protection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We’ve configured the **onRequest** route’s option property to define a hook
    specific to this route. Fastify provides you with granularity in hook attachment;
    you can assign a hook function to an entire server instance or to an individual
    route. Additionally, you have the flexibility to set the **onRequest** field as
    an array of hook functions, which will be executed in the order they are added.
    This allows for precise control over the request processing flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax is perfect when you have a few routes to set up, but what if we
    have a lot of routes to protect? Let’s see what we can do in the **routes/recipes.js**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To streamline the protection of the recipes routes, which consists of both protected
    and public routes, you can create a new **protectRoutesPlugin** plugin instance
    in **recipesPlugin** . Within this context, you can add the **onRequest** hook
    to all the routes defined in that context. In this case, I’ve named the first
    argument **plugin** to distinguish it from the **app** context. The **plugin**
    parameter serves as a child context of **app** , inheriting all the hooks and
    decorators up to the root application instance. This allows it to access the **authOnlyChef**
    function. Furthermore, we’ve moved only the routes that require protection into
    this new **plugin** function, effectively isolating them from the parent’s scope.
    Keep in mind that inheritance flows from parent to child contexts, not the other
    way around. This approach enhances code organization and maintains the benefits
    of encapsulation, isolation, and inheritance within the Fastify plugin system.
  prefs: []
  type: TYPE_NORMAL
- en: With the changes we’ve made, you can now execute the **curl** commands that
    were initially tested in this recipe. You should expect to receive an **Unauthorized**
    error only for the routes that require protection, while the other routes should
    remain freely accessible. This demonstrates the successful implementation of authentication
    logic for selective route protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fastify has two distinct systems that govern its internal workflow: the **application
    lifecycle** and the **request lifecycle** . While Fastify manages these two lifecycles
    internally, it provides the flexibility for you to inject your custom logic by
    listening to and responding to the events associated with these lifecycles. This
    capability enables you to tailor the data flow around the endpoints according
    to your specific application requirements and use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are listening for events triggered by the application lifecycle, you
    should refer to the **application hooks** (https://fastify.dev/docs/latest/Reference/Hooks#application-hooks).
    These hooks allow you to intervene during server startup and shutdown. Here is
    a quick list of these hooks and when they are emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hook name** | **Emitted when…** | **Interface** |'
  prefs: []
  type: TYPE_TB
- en: '| **onRoute** | a new endpoint is added to the server instance | It must be
    a sync function |'
  prefs: []
  type: TYPE_TB
- en: '| **onRegister** | a new encapsulated context is created | It must be a sync
    function |'
  prefs: []
  type: TYPE_TB
- en: '| **onReady** | the application loaded by the HTTP server is not yet listening
    for incoming requests | It can be a sync or an async function |'
  prefs: []
  type: TYPE_TB
- en: '| **onListen** | the application is loaded, and the HTTP server is listening
    for incoming requests | It can be a sync or an async function. It does not block
    the application startup if it throws an error |'
  prefs: []
  type: TYPE_TB
- en: '| **preClose** | the server starts the close phase and is still listening for
    incoming requests | It can be a sync or an async function |'
  prefs: []
  type: TYPE_TB
- en: '| **onClose** | the server has stopped listening for new HTTP requests and
    is in the process of stopping, allowing you to perform cleanup or finalization
    tasks, such as closing a database connection | It can be a sync or an async function.
    This hook is executed in reverse order |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – Application hooks overview
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 6.1* provides a comprehensive overview of all the application hooks.
    It’s important to note that these hooks are executed in the order of their registration,
    except for the **onClose** hook, which follows a reverse order of execution because
    it ensures that the resources created last are the first to be closed, similar
    to how a **last-in-first-out** ( **LIFO** ) queue operates. This sequencing is
    essential for proper resource cleanup during server shutdown. Another important
    aspect that Fastify ensures is that if any of these hooks fail to execute successfully,
    the server will not start. This feature is valuable, as these hooks can be used
    to verify the readiness of essential external resources before they are consumed
    by the application’s handlers. It ensures that your application starts in a reliable
    state, enhancing robustness and stability. It’s important to note that the rule
    of preventing server startup upon hook failure does not apply to the **onListen**
    and **onClose** hooks. In these particular cases, Fastify guarantees that all
    registered hook functions will be executed, regardless of whether one of them
    encounters an error. This behavior ensures that necessary cleanup and finalization
    tasks are carried out during server startup and shutdown, even in the presence
    of errors in some hooks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The application hooks serve various purposes, but the main ones include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cache warm-up** : You can use the **onReady** hook to prepare and preload
    a cache when the server is about to start, which can significantly enhance the
    performance of your handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Check** : If your handlers rely on a third-party server or external
    resource, you can use these hooks to verify that the resource is up and running
    during server startup, ensuring that your application’s dependencies are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring** : These hooks are valuable for logging and monitoring server
    startup information, such as configuration details or reasons for server shutdown,
    aiding in debugging and observability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming** : By leveraging the **onRegister** and **onRoute**
    hooks, you can apply aspect-oriented programming techniques to manipulate route
    options and inject additional properties or behavior into your routes. This allows
    for the powerful customization and modularization of your application logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an exercise, try to add these hooks into every application’s files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, the **this** keyword in the context of these hooks represents the Fastify
    instance, granting you access to all of the server’s decorators and resources.
    This includes the application logger, which can be accessed in the common and
    well-established Fastify style. It’s worth noting that, similar to plugin declarations,
    the hooks in Fastify support both asynchronous and synchronous interfaces. In
    the case of asynchronous hooks, you don’t need to take any specific actions. However,
    in the case of synchronous hooks, you have access to a **done** argument, as shown
    in the **onClose** hook in the previous code snippet. It’s essential to call this
    function within the synchronous hook to indicate successful execution; otherwise,
    the hook pipeline will be blocked, and it will not complete until a timeout occurs,
    potentially leading to the server’s shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this comprehensive overview of the application hooks, let’s now shift
    our focus to the **request hooks** ( [https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks](https://fastify.dev/docs/latest/Reference/Hooks#requestreply-hooks)
    ), which are associated with the request lifecycle. This lifecycle delineates
    the various steps that an HTTP request undergoes when it enters the server. You
    can visualize this process in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The request lifecycle](img/B19212_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The request lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 6* *.1* , the request lifecycle steps are represented with dashed
    boxes containing the hook names triggered during that specific phase. Let’s follow
    the path of an incoming HTTP request and describe what happens inside Fastify
    in the order of occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route selection** : When an HTTP request is received, Fastify routes it to
    a specific handler based on the requested URL and HTTP method. If no matching
    route is found, Fastify’s default 404 handler is executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Request initiation** : After the route handler is determined, the **onRequest**
    hook is executed. During this phase, the request’s body has not been parsed yet.
    The request object does not contain the **body** property. This is an appropriate
    point to discard any requests that should not be processed, such as unauthorized
    ones. Since the request payload has yet to be read, server resources are not wasted
    on unnecessary processing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Request payload manipulation** : If the HTTP request is deemed processable,
    the **preParsing** hook provides access to the request’s payload stream, which
    can be manipulated. Common use cases include decrypting an encrypted request payload
    or decompressing user input.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Payload validation** : Fastify includes a built-in validation system, which
    we will explore further in the *Validating the input data* recipe of this chapter.
    You can modify the parsed payload before it undergoes validation by listening
    to the **preValidation** hook.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Full request parsing** : Just before executing the route handler, which contains
    the business logic, the **preHandler** hook is executed. During this phase, the
    request is fully parsed, and you can access its content via the **request.body**
    field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Route handler execution** : The request enters the main route handler to
    execute the function associated with the route definition. When you use **reply.send()**
    or return a payload as the response, the last phase begins to send the response
    payload to the client.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Payload serialization** : Before the serialization process occurs, the **preSerialization**
    hook is triggered. Here, you can manipulate the payload, adapt it to a specific
    format, or convert non-serializable objects into plain JSON objects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Response preparation** : The **onSend** hook is called just before sending
    the response payload to the client. It can access the serialized payload content
    and apply additional manipulations, such as encryption or compression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Request completion** : Finally, the last step in the request lifecycle is
    the **onResponse** hook. This hook is executed after the payload has been successfully
    sent to the client, marking the completion of the HTTP request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Indeed, many things are involved when a simple HTTP request enters the Fastify
    server, as highlighted in the request lifecycle. Moreover, *Figure 6* *.1* illustrates
    three additional hooks dedicated to managing errors that may occur throughout
    the entire request lifecycle. These error-specific hooks provide the means to
    handle errors gracefully and effectively, ensuring the reliability and robustness
    of your Fastify application. These three error-specific hooks in Fastify provide
    ways to manage different error scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**onTimeout** : This hook is triggered when a connection socket is in an idle
    state. To enable this hook, you must set the server’s **connectionTimeout** option
    (the default value is **0** , which means disabled). The value you specify in
    milliseconds determines the maximum time the application has to complete the request
    lifecycle. If this time limit is exceeded, the **onTimeout** hook kicks in and
    closes the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onError** : The hook is triggered when the server sends an error as the response
    payload to the client. It allows you to perform custom actions when errors occur
    during request processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onRequestAbort** : This hook is executed when a client prematurely closes
    the connection before the request is fully processed. In such cases, you won’t
    be able to send data to the client since the connection has already been closed.
    This hook is useful for cleaning up any resources associated with the aborted
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve now gained a comprehensive understanding of Fastify’s hooks, which will
    be invaluable as you dive deeper into using the plugin system. So, let’s start
    to use all of Fastify’s powerful features, including hooks, decorators, and plugins,
    to implement the fantasy restaurant business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this new recipe, we’ll delve deeper into the world of the Fastify plugin
    system, expanding our understanding beyond what we’ve explored so far. Fastify
    offers a wide array of tools, each serving specific purposes, and gaining familiarity
    with them will greatly enhance your ability to customize and control various aspects
    of your application’s lifecycle and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous *Implementing authentication with hooks* recipe, we learned
    about various hooks, but we didn’t see their practical application. Now, let’s
    apply our knowledge by developing a custom authentication plugin. Currently, our
    authentication logic is dispersed across the **app.js** file, which is then utilized
    by both **orders.js** and **recipes.js** . While it works, it lacks centralization.
    To address this, we aim to create a company-wide plugin that can be easily integrated
    into all our projects, providing standardized authentication logic right out of
    the box when registering the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a common plugin by breaking the **encapsulation** , we need to follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **plugins/auth.js** instance in a new folder and then move the
    decorators from **app.js** to this new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As usual, register the plugin in the **app.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is nothing new so far, but if you try to start the server, it won’t work.
    Let me show you why by drawing the Fastify contexts structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Fastify tree structure](img/B19212_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Fastify tree structure
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6* *.2* , every node represents a self-contained context. Thanks
    to the plugin system, each of these contexts can possess its own hooks, decorators,
    and plugins. On the left side of the figure, you can observe the current structure
    of our application. Notably, the decorators defined within the **authPlugin**
    function are not accessible to either the **recipesPlugin** or **ordersPlugin**
    functions due to isolation. To rectify this, we should consider relocating the
    **authPlugin** node higher up in the tree structure. By doing so, the recipes
    and orders plugins would inherit the decorators, allowing for seamless integration
    and functionality. Implementing this action would entail having **server.js**
    register **authPlugin** and, subsequently, **authPlugin** register **appPlugin**
    . While this approach would work, it leads to a source code that is challenging
    to comprehend due to its complexity and nested dependencies. For this reason,
    in this case, we want to **break the encapsulation** , as shown on the right side
    of *Figure* *6* *.2* .
  prefs: []
  type: TYPE_NORMAL
- en: Install a new module by running **npm** **install fastify-plugin@5** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wrap the **authPlugin** function with the **fastify-plugin** , as shown in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon restarting the server, everything should function as it did previously.
    This is because breaking the encapsulation context is like using the parent Fastify
    instance. If we were to apply **fastify-plugin** to every file we’ve implemented
    thus far, we would essentially consolidate everything into a single context, equivalent
    to the root application context. Unfortunately, this would result in the loss
    of all the capabilities provided by the plugin system. As a general rule of thumb,
    you may use **fastify-plugin** exclusively for those plugins that you intend to
    reuse across your organization.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our work is not yet complete, as we have only moved the decorators. Now, our
    objective is to centralize how the routes apply the authentication logic. To achieve
    this, we will utilize the **onRoute** hook. Add this code to the **auth.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As mentioned in the *There’s more...* section of the *Implement authentication
    with hooks* recipe, the **onRoute** hook must be a synchronous function. It receives
    the route’s options as its first argument. The purpose of this function is to
    check whether **routeOptions** includes an **auth** flag set to true. If this
    condition is met, we inject the **authOnlyChef** decorator function into **routeOptions.onRequest**
    .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s worth emphasizing that the code ensures **authOnlyChef** is the first function
    in the **onRequest** chain. This is significant because Fastify executes these
    functions in the order they appear. Additionally, it’s worth mentioning that the
    input **routeOption.onRequest** can either be an array of hooks or a single function.
    The code example handles both scenarios seamlessly using the **Array.concat()**
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can go back to the **orders.js** file and update the **PATCH /orders/:orderId**
    handler as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have replaced the previous **onRequest** **[app.authOnlyChef]** configuration
    with the new approach.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By utilizing the route’s **config** property, we isolate your application’s
    properties from Fastify’s fields to prevent conflicts. This updated setup offers
    several advantages, including the ability of **authPlugin** to evolve over time
    without necessitating changes to your routes’ configurations with every update.
    This pattern aligns with **aspect-oriented programming** , as it dynamically introduces
    a feature through a straightforward Boolean configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an exercise, try to update the **recipes.js** file by yourself now, and
    then compare your code with the following solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As was previously carried out, we have set the **config.auth** option, and we
    deleted the **protectRoutesPlugin** code because creating an encapsulated context
    is no longer necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! In this recipe, we’ve covered a lot, beginning with hooks, moving
    on to decorators, and learning how to manage encapsulated contexts and break them
    when necessary. In the next recipe, we’ll dive into implementing the business
    logic for our routes, which we’ve only declared up to this point. So, let’s gear
    up and get started!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing business logic using hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The APIs for the fantasy restaurant have a specific goal: to serve our restaurant’s
    needs. In the *Adding* *routes* recipe, we examined the general flow but didn’t
    delve into details, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What constitutes the input for each endpoint?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What should be the expected output of each service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should we store the data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will explore these crucial aspects in greater detail. So,
    let’s start with the data and its storage!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We require a database to store and retrieve application data. For this purpose,
    we will employ the well-known NoSQL database **MongoDB** ( [https://www.mongodb.com/](https://www.mongodb.com/)
    ). MongoDB is a popular NoSQL database that stores data in flexible, JSON-like
    documents, providing scalability and high performance for various applications.
    It’s important to note that the details of MongoDB are not the primary focus of
    this chapter, so I won’t delve into extensive descriptions of its inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a Docker installation, you can run a MongoDB server by running
    this command line: **docker run -d -p 27017:27017 --name fastify-mongo mongo:5**
    . It will start a container using the official MongoDB image, and it will be ready
    to use. Finally, to stop it, you can run this command instead: **docker container**
    **stop fastify-mongo** .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect our application to MongoDB, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the official Fastify module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can create a new plugin in the **plugins/datasource.js** file, where
    we will connect to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update **app.js** , adding the **app.register(datasourcePlugin)** code, as was
    carried out in *Step 2* of the *Breaking the* *encapsulation* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you launch the application with a properly initialized database, it should
    start as usual, and you should observe the new log line we added to confirm that
    our plugin is being loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we must establish a data layer between the MongoDB data source and our
    business logic. This allows us to identify the essential actions our routes must
    execute and extract a subset of these actions to be defined as decorators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous code snippet, we added a new **source** object decorator. Each
    object’s field references an **async** function that will perform only what the
    name says. So, let’s start to implement the first function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function inserts the input JSON object **recipe** into the **menu** collection
    and returns the generated id. As said, this data layer should not perform any
    business logic. **app.mongo** is a decorator created by the **@fastify/mongodb**
    module, as documented here: [https://github.com/fastify/fastify-mongodb](https://github.com/fastify/fastify-mongodb)
    , and this refers to the MongoDB Client, so you have total control over it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code block, the **_id** property in **recipe._id = _id;** and
    the **id** property in **recipe.id = _id.toString()** have the same value. We
    introduce the **id** property to prevent the exposure of any information related
    to our database. While we utilize the **_id** property, it is primarily defined
    and employed by MongoDB servers for internal purposes, and we opt to use **id**
    to maintain a level of abstraction and security in our application’s data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the **insertRecipe** function, we need to implement the **POST /recipes**
    endpoint as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the **addToMenu** function handler runs, we are 100% sure that the authentication
    hook is successful and only a valid chef is executing it. So, the function logic
    reads from the **request.body** input data to compose a new JSON object. This
    step is required to avoid inserting unexpected fields (into the database) that
    a client may submit to our endpoint. Then, the **app.source.insertRecipe** decorator
    is called to save the data. As the last operations, we set the HTTP response status
    to **201 – Created** (for a complete list of the standard HTTP status codes, refer
    to the list here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
    ).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can try it now by running this **curl** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our test is not over yet. You must try to run the same **curl** command, but
    you need to remove the **x-api-key** header or change its value. We expect a **401
    – Unauthorize** error in these cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using **curl** to run HTTP requests against the application server,
    adopting an HTTP Client with a **graphic user interface** ( **GUI** ) may be easier.
    Here is a complete list where you may choose your favorite one: [https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui](https://github.com/mrmykey/awesome-http-clients/blob/main/Readme.md#gui)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before considering this section completed, we need to read from the database,
    so let’s implement the **readRecipes** function in the **plugins/datasource.js**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this search function, we are using the standard MongoDB APIs ( [https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/](https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/)
    ). We may want to filter the data, so we expect a **filters** parameter. The **sort**
    argument, instead, is needed to return the dishes array in the right order, whereby,
    e.g., the appetizer will have **order=0** , the first course will have **order=1**
    , and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can update the **routes/recipes.js** file with the new **menuHandler**
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As usual, we can try to see if this code is working as expected by calling
    the server to see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **/menu** endpoint should answer with an array of all the dishes we stored
    in the menu collection during our testing phase!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Should we implement pagination? Our **GET /menu** endpoint provides a list
    of data, and it’s considered a best practice to assess whether the list might
    be excessively large to return in a single HTTP call. In this specific case, it’s
    deemed acceptable to return the entire menu. However, if the menu were to contain
    hundreds of recipes, you might want to consider implementing pagination logic
    to break the data into manageable chunks. You can find guidance on how to implement
    two different pagination patterns in this article: [https://backend.cafe/streaming-postgresql-data-with-fastify](https://backend.cafe/streaming-postgresql-data-with-fastify)
    . Although the article discusses PostgreSQL, these pagination patterns can also
    be adapted for use with MongoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ve learned how to establish a connection to a database. It’s
    worth noting that Fastify contributors provide support for various popular databases,
    including **PostgreSQL** , **MySQL** , and **Redis** , among others. You can find
    a comprehensive list of supported databases at [https://fastify.dev/ecosystem](https://fastify.dev/ecosystem)
    . In the upcoming recipe, we will discuss the data validation used to protect
    our endpoints from malicious users, and we will keep on implementing the missing
    routes’ handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the input data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Implementing the business logic* recipe, we stored input data from the
    **POST /recipes** endpoint in the database. However, we did not implement any
    validation logic, which means we could potentially insert a string into the **price**
    field or a recipe without **name** . Furthermore, it’s important to consider security
    concerns, as a malicious user could potentially insert a recipe with a description
    that’s excessively large, posing a risk to your application’s performance and
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the backend world, there is a rule: never trust the user’s input. Fastify
    knows it well, so it integrates a powerful and feature-complete validation process.
    Let’s see it in action.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to integrate the validation process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the **schema** property to the **POST /recipes** route option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **jsonSchemaBody** constant is an object defined in the **JSON schema**
    format. This format adheres to the specifications outlined in the JSON schema
    standard, which provides a framework for describing the structure and constraints
    of JSON documents, including those in request bodies. By employing a JSON schema
    interpreter, you can assess whether a given JSON object conforms to a predefined
    structure and constraints, enhancing the validation process for your API requests.
    Fastify includes the AJV ( [https://ajv.js.org/](https://ajv.js.org/) ) module
    to process the JSON schemas and validate the request’s components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The route option **schema** property accepts these fields:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**body** : This schema is used to validate the **request.body** during the
    request evaluation, as we saw in *Figure 6.2* .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**params** : This schema validates **request.params** , which contains the
    path parameters of the request URL.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**headers** : It is possible to validate **request.headers** ; therefore, we
    may improve the routes protected by the authentication by adding a JSON schema
    that requires the **x-api-key** header to be set.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**query** : We can validate the **request.query** object that contains all
    the query string parameters by using this.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**response** : This field is a special one, and it does not accept a JSON schema
    out of the box. We will see it in action in the next *Enhancing application performance
    with* *serialization* recipe.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if we restart the server with the new route’s configuration, we will hit
    our first **400 –** **Bad Request** response by running the same command as in
    *Step 8* of the *Implementing the business* *logic* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s worth noting that, in your scenario, you received only a single error
    message when you expected two errors to be reported:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first error should relate to the incorrect **country** value. The JSON schema
    specifies an enumeration of just two ISO codes, and the provided value doesn’t
    match either of them.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second error pertains to the missing **order** property, but it seems that
    only this error is being displayed in the output message.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This situation occurs due to the default AJV configuration that Fastify uses.
    You can check the default setup at [https://github.com/fastify/ajv-compiler#ajv-configuration](https://github.com/fastify/ajv-compiler#ajv-configuration)
    :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To resolve the issue and enable the **allErrors** option, you should configure
    the server’s option object that is exported in the **app.js** file. Here’s how
    you can modify the configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By restarting the application and re-running the **curl** command, we should
    get this new output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the **ajv.customOptions** field will be merged with the default configuration,
    so verify each option and set it as it best fits your needs. The validation step
    is one of the most important and requires additional care to secure your APIs.
    Let me suggest my preferred configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **removeAdditional** option will enforce the removal of all input fields
    that are not explicitly listed in the route’s JSON schemas. This feature is a
    valuable addition to enhance security. It’s important to note that if you do not
    specify a JSON schema for a particular route, the removal logic will not be applied,
    and all input fields will be retained as-is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must implement the **deleteRecipe** function first; therefore, we go into
    the **plugins/datasource.js** file and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To delete the item from MongoDB, we encapsulate the input for **id** within
    **ObjectId** . This is necessary because MongoDB expects the **_id** field to
    be an **ObjectId** when performing document deletions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can proceed to implement the **DELETE /recipes/:id** handler using all the
    new things we have learned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The route’s definition incorporates a JSON schema in the **schema.params** property
    to validate the input **id** . We perform a strict check to ensure that **id**
    is exactly 24 characters in length, which is a security measure to prevent potential
    long code injection attacks. Note that this validation is strictly related to
    MongoDB, and it demonstrates how you can protect your routes from bad actors.
    So, tweak this configuration based on your needs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Meanwhile, in the **removeFromMenu** function implementation, we retrieve the
    recipe from the database by first reading it. Note the use of array destructuring
    because the **readRecipes** function returns an array. If the item is missing
    in the database, we will return a **404 - Not Found** error. Otherwise, we delete
    the record and return a **204** response status code, indicating a successful
    deletion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is time to test our code. Therefore, we can try the **curl** commands as
    usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this recipe, we’ve successfully implemented all the routes defined in the
    **routes/recipes.js** file. In the upcoming recipe, we will continue by implementing
    the routes defined in **routes/orders.js** while also introducing another exciting
    Fastify feature: serialization!'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing application performance with serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The serialization step converts the high-level data generated by business logic,
    including JSON objects or errors, into low-level data, such as strings or buffers,
    which are then sent as responses to the client’s requests. It involves the transformation
    of intricate objects into an appropriate data type that can be effectively transmitted
    to the client. In fact, as mentioned in the *Implementing authentication with
    hooks* recipe, the serialization process is initiated only if the route handler
    doesn’t return a string, stream, or buffer, as these objects are already serialized
    and prepared for transmission as HTTP responses to the client. Nevertheless, this
    process can’t be avoided when you work with JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Fastify incorporates a serialization module that facilitates the conversion
    of an object into a JSON string, leveraging a JSON schema definition. This module,
    known as **fast-json-stringify** , offers a notable performance boost when compared
    to the standard **JSON.stringify()** function. In fact, it accelerates the serialization
    process by a factor of two for small payloads. Its performance advantage shrinks
    as payload grows, as demonstrated in their benchmark, which is available at [https://github.com/fastify/fast-json-stringify/](https://github.com/fastify/fast-json-stringify/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will apply the serialization to the **/orders** endpoints, but first, we
    must create an order. For this recipe, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the **insertOrder** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code snippet should be familiar to you. We insert the input object into
    the **orders** collection straight away. Then, we can implement the route handler
    in **routes/orders.js** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we need to deal with user input, we can define this JSON schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It defines two properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**table** : This helps us understand which customer ordered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dishes** : This is a JSON object array that must have at least one item.
    Every item must contain the recipe **id** and **quantity** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to the JSON schema, we can avoid a lot of boring **if** statements and
    checks such as checking if the **quantity** input field is a negative value!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can move on to the route implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’re likely familiar with the **createOrder** function by now. For the sake
    of simplicity, we’ll store the **request.body.dishes** array as-is without validating
    the IDs. However, I recommend implementing a **preHandler** hook to handle this
    validation step, which the JSON schema can’t perform, and I encourage you to consider
    it as an exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are ready to try the route out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Well done! We have consolidated what we have learned in the *Implementing the
    business logic* recipe. We are now ready to move on to the **GET /orders** route
    to see the serialization process in action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As usual, we should implement the database access first; therefore, in **plugins/datasource.js**
    , we can write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the provided code snippet, there isn’t anything substantially new, except
    that we’re configuring a default sorting by using **createdAt** in reverse order.
    This arrangement prioritizes older orders, ensuring they are fulfilled first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we can move to the endpoint handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **readOrders** function introduces a more comprehensive logic compared
    to what we saw earlier in *Step 5* . Here’s an overview of the steps it takes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initially, it reads all the pending orders.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it collects all the recipe IDs used across all the orders to optimize
    performance by running a single query to select only those recipes that are actually
    used.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it iterates through the orders array to replace the items array, which
    was initially read from the database, with the corresponding recipe items from
    the database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s worth mentioning that we have seen how to use multiple datasource methods
    in one handler. If we would like to optimize the code even further, we could use
    a MongoDB **$lookup** to run a single query to the database instead of two, as
    we did.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One notable detail is the use of a filter to skip recipes that were not found
    in the system. This is an edge case consideration because an order may include
    a recipe that was deleted after it was created, and in such cases, we want to
    ensure that these deleted recipes are not displayed in the output. We are ready
    to test this implementation by executing a command in the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We expect a big output displaying the orders in our system. Here is an example
    of one order output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the provided information contains more details than the target
    user requires. It’s time to configure the serialization process to ensure that
    the data presented to the user is concise and relevant to their needs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **routes/orders.js** file, add this JSON schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**orderListSchema** specifically outlines the fields we desire in the response
    payload, mapping only the properties’ types without specifying attributes to define
    the maximum string length or valid number ranges. It’s worth noting the **format**
    attribute, which allows for the customization of the output for a date field.
    However, it’s important to clarify that this concept can sometimes be misunderstood:
    the JSON schema used for serialization does not apply any validation but solely
    filters the data. Therefore, any additional validation rules added to the JSON
    schema will be ignored during the serialization process.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To apply the JSON schema to the endpoint, we must edit the route’s option as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To use a JSON schema during serialization, it’s essential to configure the **schema.response**
    object. Notably, you can specify the HTTP status codes to which the particular
    schema should be applied. You have the flexibility to define different schemas
    for various status codes. Additionally, there’s another convenient Fastify pattern
    that you can utilize. By setting the **"2xx"** property within the schema, it
    will be used for all HTTP status codes ranging from 200 to 299, simplifying the
    schema configuration for a range of successful responses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we run the **curl** command from *Step 7* , we will get even better output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By successfully implementing a JSON schema for serializing the output of the
    order endpoint, you’ve enhanced both the speed and security of your application.
    This approach ensures that only the designated fields are returned, safeguarding
    against the inadvertent exposure of sensitive data as the database evolves over
    time. Specifying a JSON schema as part of your response is consistently considered
    good practice for maintaining control over the data exposed to clients and enhancing
    overall security.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the knowledge and tools we’ve covered thus far, you should be well equipped
    to complete the implementation of the final **PATH /orders/:orderId** route. If
    you encounter any doubts or need further guidance, you can refer to the complete
    source code available in the book’s repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter06)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished this route, you can consider the overall application complete.
    While there is room for further improvements, such as adding a JSON schema to
    all the routes, it might be considered optional to delve into this in detail since
    we’ve already covered the fundamental concepts behind it. Now, you are ready to
    move on to the next section, where you’ll learn how to write tests for your Fastify
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and testing a Fastify application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, I mentioned that the application could be considered
    complete. However, as an application truly achieves completeness only when it
    has a comprehensive test suite, in this recipe, our focus shifts to testing our
    endpoints to assert their functionality and correctness. This testing ensures
    that as we make changes to the code in the future, we can reliably verify that
    we have not introduced any new bugs or regressions.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the new Node.js test runner in this recipe, providing a sneak peek
    into [*Chapter 8*](B19212_08.xhtml#_idTextAnchor243) , where we will delve deeper
    into this subject and do so in a more focused manner. For now, we will cover the
    basics to get you started with testing. So, let’s start this new goal!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin this recipe by reading the application’s configuration, followed
    by writing application tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up until now, we’ve hardcoded certain elements in our code, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The database connection URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API key for authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this approach isn’t ideal for our application because we should have
    the flexibility to change these values as needed, especially in different environments.
    The best practice in such cases is to access the environment variables provided
    by the system. Additionally, this is a requirement for writing tests, allowing
    us to inject different configurations as necessary for testing various scenarios
    and environments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To achieve this task, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a new Fastify module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to create a new file, **plugins/config.js** , with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The plugin code should be fairly understandable, even if you’re encountering
    it for the first time. This plugin defines an **envSchema** constant with a JSON
    schema. This schema is subsequently used as a configuration for the **@fastify/env**
    module. This module validates the **process.env** object against the provided
    input schema. Consequently, if the required configuration is missing or incorrect,
    the application will not start successfully. Moreover, the **confKey** option
    lets you set a custom name for the server decorator that this module is going
    to add.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you register this plugin in the **app.js** file and attempt to restart the
    server, you will encounter an error during the startup process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To fix this configuration issue, we need to begin passing the **opts** argument
    in our plugin declarations. Let’s address this problem using a top-down approach.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start by opening the **server.js** file and making the following updates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We introduced a configuration object during the registration of **appPlugin**
    . The **applicationEnv** property is derived from merging **process.env** with
    the default values specified in the code. In cases where **process.env** contains
    values for **API_KEY** or **DATABASE_URL** , these environment-specific values
    take precedence over the defaults defined in the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to go back to **app.js** and update it accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this context, the **opts** argument corresponds to the second object parameter
    we recently added in the **server.js** file. Consequently, **configPlugin** also
    receives the same object because we added it during the registration. If we refer
    back to the initial code snippet in this recipe, which showcases the **configPlugin**
    implementation, you’ll observe that we’ve already supplied the **opts.applicationEnv**
    option to **@fastify/env** . This indicates that it’s now reading the correct
    configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these adjustments, we should be able to restart the server successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have changed a lot of code but still need to remove the hardcoded configuration
    from the plugins. Let’s do it now, starting with the **app.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code snippet, you’ll notice a new syntax: **await app.register()**
    . Now, **await** is crucial because, without it, your server won’t start. As a
    reminder, in the *Splitting the code into small plugins* recipe, we discussed
    that plugin functions are not executed until one of the following methods is called:
    **app.listen()** , **app.ready()** , or **app.inject()** . While this principle
    remains accurate, using **await app.register()** effectively triggers Fastify
    to initiate the loading process up to the awaited line, ensuring the necessary
    setup occurs before further execution. In fact, we use the **app.appConfig** decorator
    in the following line, and this field will remain undefined if we don’t wait for
    ( await) **configPlugin** .'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **plugins/datasource.js** file, we can update the MongoDB setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **plugins/auth.js** , we can remove the hardcoded API key as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great job! You’ve now achieved a dynamic application that adapts its configuration
    based on the environment, validates prerequisites before starting, and leverages
    another feature of Fastify’s plugin system by utilizing the ability to await a
    plugin. Additionally, you’ve improved the authentication and data source plugins,
    making them more configurable and suitable for use across your organization’s
    projects. By configuring the plugins via the **register** method, we can create
    plugins that are decoupled from the rest of the application and do not require
    the **app.appConfig** decorator to work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With all these pieces in place, you’re well prepared to begin writing your test
    suite. The dynamic configuration you’ve created will prove invaluable as you embark
    on the testing phase of your project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your Fastify application can be effectively represented by the **appPlugin**
    instance and the server’s configuration exported by the **app.js** file. In fact,
    there is minimal value in testing the **server.js** file, as it primarily serves
    as a straightforward runner that can be readily replaced by the **fastify-cli**
    module when necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The initial step of writing tests for a Fastify application is to enable the
    creation of a **test/helper.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are ready to write our first test file: **test/app.test.js** .'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must import the new **Node.js test** **runner** modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A complete list of its APIs can be found in the official documentation at [https://nodejs.org/api/test.html](https://nodejs.org/api/test.html)
    .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to import the **buildApplication** utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to define a test case using the **test** function. The first parameter
    is a descriptive string that helps identify which test is currently executing.
    The second argument is an asynchronous function that takes a test context parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the test file, we need to execute this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**test/helper.js** exports a **buildApplication** function that instantiates
    the Fastify root server instance and registers **appPlugin** , as carried out
    by the **server.js** file. The differences are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **app** constant is just returned, and we do not call the **listen()** method.
    In this way, we are not blocking a host’s port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default server’s options are the same as **server.js** with the logger turned
    off. Anyway, we can customize them by providing a second argument to the factory
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default environment setup does not read the **process.env** object, but
    it defines good defaults with which to run the application in every local development
    environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we are running the application, a connection to the database will be established.
    To ensure the test completes successfully, it’s essential to close the server
    and database connection after the test has executed all the assertions. This cleanup
    step is crucial for the proper functioning of subsequent tests and to avoid resource
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we can use Fastify’s **app.inject()** method. Unlike calling the **listen**
    method, this approach starts the server without actively listening for incoming
    HTTP requests, enabling faster execution. The **inject** method then generates
    a simulated HTTP request and sends it to the server, which processes it in the
    same way it would a genuine request, producing an HTTP response. This method returns
    the HTTP response, allowing us to verify its content to validate our expectations.
    The **inject** method accepts an object parameter for specifying various HTTP
    request components. We’ll explore more examples in the *There’s more...* section
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the test case, we assert that the response has the correct status
    code and payload.
  prefs: []
  type: TYPE_NORMAL
- en: The test output provides a summary of the entire execution process. In the event
    of an error, it displays a detailed message indicating the failed assertion. For
    experimental purposes, you can attempt to break the test by modifying the **deepStrictEqual**
    check, for instance, by editing the **version** property. This will help you observe
    how tests respond to changes and failures, allowing you to refine and improve
    them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before wrapping up this recipe, it would be useful to check a more complex
    test case, so let’s quickly analyze this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This new test case examines the **A unknown user cannot create a recipe** condition.
    In this scenario, we inject a custom API key within the **buildApplication** function
    and subsequently confirm that if the **POST /recipes** request lacks the valid
    header, it will be rejected. We saw also that the **inject** method accepts the
    **payload** and **headers** fields to control every request’s aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can enhance the code by introducing an additional test case
    to ensure that a valid chef can, indeed, create a recipe and that the newly created
    recipes appear on the menu. This additional test will further validate the application’s
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note that the **app.inject()** method has a shortcut to run simple **GET** requests
    also. It requires the URL string only.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing tests for the application’s routes to cover all use cases is a
    valuable exercise for becoming proficient with the APIs and the test suite. You
    now have the fundamental knowledge needed to tackle this task by drawing upon
    what you’ve learned. Refer to the book’s source code repository for additional
    code examples and guidance. Good luck, and well done on your progress!
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ve delved into some of Fastify’s most crucial features,
    including the plugin system and the wide number of hooks. You’ve also gained insights
    into the essential aspects of a Fastify application, such as configuration and
    code reusability. Moreover, your proficiency in working with MongoDB has undoubtedly
    improved.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re enthusiastic about Fastify and eager to explore more, you might find
    the book *Accelerating Server-Side Development with Fastify* by *Packt Publishing*
    at [https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582](https://www.packtpub.com/product/accelerating-server-side-development-with-fastify/9781800563582)
    to be an invaluable resource for furthering your knowledge and skills in this
    powerful framework. Keep up the great work!
  prefs: []
  type: TYPE_NORMAL
