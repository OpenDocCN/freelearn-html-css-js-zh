<html><head></head><body><div><h1 class="header-title">Frontend Development with React and TypeScript</h1>
                
            
            
                
<p>In the preceding chapter, we learned how to implement web services with Node.js. In this chapter, we are going to learn how to implement a <strong>single-page application</strong> (<strong>SPA</strong>) that consumes the web services that we created in the preceding chapter. The web services might change slightly in this chapter, but the changes should be small enough not to require us to cover them in this chapter.</p>
<p>The companion source code includes an updated version of the backend application that we implemented in the preceding chapter. The new upgraded version contains new controllers and web services that allow us to manage a catalog of movies and actors, as opposed to just movies.</p>
<p>In this chapter, we are going to learn how to consume a web service from a React application and how we can use React components to display the data fetched from the backend in a web user interface. We are also going to learn how to implement client-side routing powered by the <kbd>react-router</kbd> and how to implement smart components powered by MobX.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with React</h1>
                
            
            
                
<p>React is a library that allows us to implement web user interfaces. In this chapter, we are going to create a small frontend application using React and MobX. A frontend web application is quite different from a Node.js backend web application. It is true that both the web browser and Node.js can understand JavaScript natively, but the environments are quite different. For example, in the Node.js environment, we can access system resources like the filesystem, and we can use CommonJS modules natively. On the other hand, in a web browser, we cannot access resources like the filesystem and CommonJS modules are not supported natively. Also, the performance of a frontend web application is extremely influenced by its loading times. This means that in a frontend web application we must pay special attention to the number of HTTP requests and the size of the contents being loaded through the network.</p>
<p>The lack of native support for modules and the need for size optimization explains the need for a module bundler when we are working on a frontend web application. Throughout this book, we have been using Webpack as our module bundler, and we will do the same once more in this chapter.</p>
<p>We are going to use the following Webpack configuration:</p>
<pre>const { CheckerPlugin } = require("awesome-typescript-loader"); 
const webpack = require("webpack"); 
const ExtractTextPlugin = require("extract-text-webpack-plugin"); 
const CopyWebpackPlugin = require("copy-webpack-plugin"); 
 
const corePlugins = [ 
    new CheckerPlugin(), 
    new webpack.DefinePlugin({ 
        "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "development") 
    }), 
    new ExtractTextPlugin({ 
        filename: "main.css", 
        allChunks: true 
    }), 
    new CopyWebpackPlugin([ 
        { from: "./web/frontend/index.html", to: "index.html" } 
    ]) 
]; 
 
const devPlugins = []; 
 
const prodPlugins = [ 
    new webpack.optimize.UglifyJsPlugin({ output: { comments: false } }) 
]; 
 
const isProduction = process.env.NODE_ENV === "production"; 
const plugins = isProduction ? corePlugins.concat(prodPlugins) : corePlugins.concat(devPlugins); 
 
module.exports = { 
    entry: "./web/frontend/index.tsx", 
    devServer: { 
        inline: true 
    }, 
    output: { 
        filename: "bundle.js", 
        path: __dirname + "/public", 
        publicPath: "/public" 
    }, 
    devtool: isProduction ? "source-map" : "eval-source-map", 
    resolve: { 
        extensions: [".webpack.js", ".ts", ".tsx", ".js"] 
    }, 
    module: { 
        rules: [ 
            { 
                enforce: "pre", 
                test: /.js$/, 
                loader: "source-map-loader", 
                exclude: [/node_modules/] 
            }, 
            { 
                test: /.(ts|tsx)$/, 
                loader: "awesome-typescript-loader", 
                exclude: [/node_modules/] 
            }, 
            { 
                test: /.scss$/, 
                use: ExtractTextPlugin.extract({ 
                    fallback: "style-loader", 
                    use: ["css-loader", "resolve-url-loader", "sass-loader"] 
                }) 
            } 
        ] 
    }, 
    plugins: plugins 
}; </pre>
<p>We have used some plugins to compile the SCSS files into one unique CSS file and to copy the HTML files into the build output directory (the <kbd>public</kbd> directory). If the build is successful, we should end up with three files under the <kbd>public</kbd> directory: <kbd>index.html</kbd>, <kbd>bundle.js</kbd>, and <kbd>main.css</kbd>.</p>
<p>Please refer to <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, to learn more about Webpack.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">About the sample application</h1>
                
            
            
                
<p>The same application included in the companion source code is a very small web application that allows us to manage a database or movies and actors. The application is going to be divided into two main units: pages and components. In this section, we are going to learn about each of the pages and components used in the application.</p>
<p>The <em>home</em> page allows us to access the Movies and Actors pages. The Home page uses the Layout, Header, Container, Row, Column, Card, Card image, and Link components:</p>
<div><img class="alignnone size-full wp-image-257 image-border" src="img/c7ec162f-f13d-4e34-a0d1-b4524fa7b885.png" style="width:115.92em;height:35.75em;" width="1391" height="429"/></div>
<p>The Movies page allows us to see a list of existing movies in the database as well as to add and delete movies and uses the Layout, Header, Container, Row, Column, Modal, Button, Text field, and List Group components:</p>
<div><img class="alignnone size-full wp-image-258 image-border" src="img/e3ff8eed-3f34-490b-be0e-279760ee54da.png" style="width:150.00em;height:64.58em;" width="1800" height="775"/></div>
<p>The following screenshot shows what the page looks like when the Movie Editor is active:</p>
<div><img class="alignnone size-full wp-image-259 image-border" src="img/f84f7483-e0c8-46ae-9a65-d1cfcb267940.png" style="width:150.00em;height:63.92em;" width="1800" height="767"/></div>
<p>The following screenshot shows what the page looks like when we try to Delete a movie:</p>
<div><img class="alignnone size-full wp-image-260 image-border" src="img/35404f8c-3ea5-45d9-8134-b918d8c4d422.png" style="width:150.00em;height:74.08em;" width="1800" height="889"/></div>
<p>The Actors page allows us to see a list of existing actors in the database as well as to add and delete actors and uses the Layout, Header, Container, Row, Column, Modal, Button, Text field, and List Group components:</p>
<div><img class="alignnone size-full wp-image-261 image-border" src="img/02e4a8f4-946b-4412-a90d-dd9242fec21f.png" style="width:150.00em;height:55.42em;" width="1800" height="665"/></div>
<p>Creating or deleting an actor is almost identical to creating or deleting a movie. The following screenshot shows what the page looks like when the Actor Editor is active:</p>
<div><img src="img/133ad93b-a82e-42f5-9692-7436c83ee531.png" style="width:64.17em;height:24.25em;" width="1800" height="681"/></div>
<p>As you can see in the preceding screenshots, multiple pages can consume the same React components. The level of reusability of a component is one of the main strengths of React as a library for the development of user interfaces. React allows us to develop reusable <em>units of work</em> known as components that can later be reused across multiple applications.</p>
<p>The sample application included in the companion source code implements both a backend and a frontend web application and uses the following dependencies:</p>
<pre>"dependencies": {<br/>    "body-parser": "1.18.2",<br/>    "bootstrap": "4.0.0",<br/>    "express": "4.16.2",<br/>    "inversify": "4.11.1",<br/>    "inversify-binding-decorators": "3.2.0",<br/>    "inversify-express-utils": "5.2.1",<br/>    "inversify-inject-decorators": "3.1.0",<br/>    "mobx": "4.1.0",<br/>    "mobx-react": "5.0.0",<br/>    "pg": "7.4.1",<br/>    "react": "16.2.0",<br/>    "react-dom": "16.2.0",<br/>    "react-router-dom": "4.2.2",<br/>    "reflect-metadata": "0.1.12",<br/>    "typeorm": "0.1.14"<br/>  },<br/>  "devDependencies": {<br/>    "@types/body-parser": "1.16.8",<br/>    "@types/express": "4.11.1",<br/>    "@types/node": "9.4.6",<br/>    "@types/react": "16.0.40",<br/>    "@types/react-dom": "16.0.4",<br/>    "@types/react-router-dom": "4.2.5",<br/>    "awesome-typescript-loader": "3.4.1",<br/>    "copy-webpack-plugin": "4.5.1",<br/>    "css-loader": "0.28.8",<br/>    "extract-text-webpack-plugin": "3.0.2",<br/>    "node-sass": "4.7.2",<br/>    "resolve-url-loader": "2.2.1",<br/>    "sass-loader": "6.0.6",<br/>    "style-loader": "0.19.1",<br/>    "ts-node": "5.0.1",<br/>    "tslint": "5.9.1",<br/>    "typescript": "2.8.1",<br/>    "webpack": "3.10.0",<br/>    "webpack-dev-server": "2.11.0"<br/>  } </pre>
<p>We are also going to implement a very basic compilation pipeline using the following npm scripts commands:</p>
<pre>"scripts": { 
    "start": "ts-node ./web/backend/index.ts", 
    "build": "webpack", 
    "lint": "tslint --project tsconfig.json -c tslint.json ./web/**/*.ts ./web/**/*.tsx" 
  }, </pre>
<p>We can use the preceding command using the following <kbd>npm</kbd> commands:</p>
<pre>    <strong>npm run start</strong>
    <strong>npm run build</strong>
    <strong>npm run lint</strong></pre>
<p>To run the application, we must first run the build command, which will build our frontend application and transform it into bundled JavaScript and CSS files located under the directory named <kbd>public</kbd>. We can then run the application using the <kbd>npm run start</kbd> command. The Node.js server will then start listening to our API calls. The Node.js will also serve the files under the <kbd>public</kbd> directory as we will see in the following section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Serving a React application with Node.js</h1>
                
            
            
                
<p>In this chapter, we are going to try to avoid introducing changes to our existing Node.js backend. Some changes have been introduced to the web services declared by the controllers. We will not spend any time going through those changes in this chapter because they are trivial.</p>
<p>However, we are going to focus on some changes in the Express.js configuration required to serve the JavaScript and CSS files under the public directory. If we want our Express.js application to serve the static files of our frontend application, we are going to need to configure what is known as the <strong>static middleware</strong>.</p>
<p>The following code snippet contains the entire source code of the application's entry point:</p>
<pre>import "reflect-metadata"; 
import * as express from "express"; 
import { Container } from "inversify"; 
import * as bodyParser from "body-parser"; 
import * as path from "path"; 
import { InversifyExpressServer } from "inversify-express-utils"; 
import { bindings } from "./inversify.config"; 
 
(async () =&gt; { 
 
    try { 
 
        const port = 3000; 
        const container = new Container(); 
        await container.loadAsync(bindings); 
        const app = new InversifyExpressServer(container); 
 
        app.setConfig((a) =&gt; { 
            a.use(bodyParser.json()); 
            a.use(bodyParser.urlencoded({ extended: true })); 
            const appPath = path.join(__dirname, "../../public"); 
            a.use("/", express.static(appPath)); 
        }); 
 
        const server = app.build(); 
 
        server.listen(port, () =&gt; { 
            console.log(`Server running at http://127.0.0.1:${port}/`); // tslint:disable-line 
        }); 
 
    } catch (e) { 
        console.log(e); // tslint:disable-line 
    } 
 
})(); </pre>
<p>The preceding code snippet creates a new Express.js application. The key point to focus on here is the invocation to the <kbd>setConfig</kbd> method. We have configured the Express.js static middleware to serve all the files located under the <kbd>public</kbd> directory when the default path (<kbd>"/"</kbd>) is invoked. This means that if we run the application using <kbd>npm start</kbd> and we access <kbd>http://127.0.0.1:3000/</kbd>, the <kbd>index.html</kbd> file located under the <kbd>public</kbd> directory will be served. The <kbd>index.html</kbd> file will then request the JavaScript and CSS files; these files are also located under the <kbd>public</kbd> directory and can be accessed using <kbd>http://127.0.0.1:3000/main.css</kbd> and <kbd>http://127.0.0.1:3000/bundle.js</kbd> respectively.</p>
<p>Please note that we have also configured our application to use the body-parser middleware. This is required to be able to parse JSON data contained in the body of an HTTP request. Please refer to <a href="18001bfb-4043-425e-bf6d-7f5625dff5f5.xhtml">Chapter 10</a>, <em>Node.js Development with TypeScript</em>, if you need additional help with Node.js and Express.js.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with react-dom and JSX</h1>
                
            
            
                
<p>Now that we know how we can use Webpack to build our frontend application and how we can use Express.js to serve its static files, we can focus on the code of the React application. We are going to start by examining the entry point of our frontend application. The application's entry point is located at <kbd>/web/frontend/index.tsx</kbd>.</p>
<p>As you can see, we have used the file extension .tsx instead of the .ts extension. This is the case because we are going to use a template system known as JSX. TypeScript supports JSX natively, but it requires us to use the .tsx file extension and to configure the JSX settings in our <kbd>tsconfig.json</kbd> file:</p>
<pre>"jsx": "react" </pre>
<p>The JSX setting determines if the JSX code should be compiled into JavaScript by TypeScript or by an external tool. In this case, we are working to set the JSX setting to <kbd>react</kbd>, which means that the JSX code will be compiled into JavaScript by TypeScript.</p>
<p>The application's entry point uses the <kbd>react-dom</kbd> module to render the application's root component. At this point, we don't know what a React component is yet. However, we don't need to go into detail just yet. All we need to understand here is that the <kbd>Layout</kbd> variable is a React component and that it is rendered into an HTML element using the <kbd>render</kbd> method from the <kbd>react-dom</kbd> library.</p>
<p>We use the <kbd>querySelector</kbd> to find an existing DOM element in our <kbd>index.html</kbd> file and then we use the <kbd>render</kbd> function to render the output of the <kbd>Layout</kbd> component into the selected DOM element:</p>
<pre>import "reflect-metadata"; 
import * as React from "react"; 
import * as ReacDOM from "react-dom"; 
import "../../node_modules/bootstrap/scss/bootstrap.scss"; 
import { Layout } from "./config/layout"; 
 
const selector = "#root"; 
const $element = document.querySelector(selector); 
 
if (!$element) { 
    throw new Error(`Node ${selector} not found!`); 
} else { 
    ReacDOM.render( 
        &lt;Layout/&gt;, 
        $element 
    ); 
} </pre>
<p>The first argument of the render function is a JSX element. As you can see, the JSX syntax is very similar to the HTML syntax, however it has some differences that we will explore throughout the rest of this chapter.</p>
<p>It is also worth mentioning that the preceding file is also importing some files required by the entire frontend application. For example, the file imports the <kbd>bootstrap.css</kbd> and the <kbd>reflect-metadata</kbd> modules. The first file contains the CSS required by the React components in this application, and the <kbd>reflect-metadata</kbd> module declares a polyfill required to implement dependency injection in some of our components.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with the react-router</h1>
                
            
            
                
<p>In the preceding section, we learned how to use the <kbd>render</kbd> method from the <kbd>react-dom</kbd> module to render the <kbd>Layout</kbd> component. In this section, we are going to take a closer look at the <kbd>Layout</kbd> component.</p>
<p>As we can see in the code snippet below, the <kbd>Layout</kbd> component is a function that returns a series of nested JSX elements; some of these JSX elements are other React components (such as <kbd>BrowserRouter</kbd>, <kbd>Header</kbd>, and <kbd>Switch</kbd> components). This is the first time that we have seen the actual implementation of a React component. In this case, a React component is a function that returns some JSX. However, it is important to mention that this is not always the case as a component can also be a class.</p>
<p>React is a component-based frontend development framework. This means that in React, everything is a component. Our application is a component, the pages within the application are components, and the elements in each of the pages are components.</p>
<p>The <kbd>Layout</kbd> component is the application's root component. The <kbd>Layout</kbd> component is always rendered on screen. However, the pages within the application are conditionally rendered as a child of the <kbd>Layout</kbd> component.</p>
<p>The <kbd>Layout</kbd> component uses the <kbd>react-router</kbd> module to implement routing in our React application. The <kbd>react-router</kbd> module includes the following React components:</p>
<ul>
<li>The <kbd>BrowserRouter</kbd> module is used to provide other components with access to some browser APIs required to implement client-side navigation (such as the History API).</li>
<li>The <kbd>Switch</kbd> component allows us to define the routes available in our application.</li>
<li>The <kbd>Route</kbd> component allows us to define a route in our application. The <kbd>Route</kbd> component takes a <kbd>path</kbd> and a <kbd>component</kbd> as properties. When the browser URL matches one of the routes, the respective component is rendered.</li>
<li>The <kbd>Link</kbd> component is not used by the <kbd>Layout</kbd> component directly. However, it is the component used to declare a link to one of the existing routes.</li>
</ul>
<p>The following code snippet showcases how the <kbd>Layout</kbd> component declares three different routes:</p>
<pre>import { Route, Switch, BrowserRouter } from "react-router-dom"; 
import * as React from "react"; 
import { Header } from "../components/header_component"; 
import { HomePage } from "../pages/home_page"; 
import { MoviePage } from "../pages/movies_page"; 
import { ActorPage } from "../pages/actors_page"; 
import "../stores/movie_store"; 
import "../stores/actor_store"; 
 
export const Layout = () =&gt; ( 
    &lt;BrowserRouter&gt; 
        &lt;div&gt; 
            &lt;Header 
                bg="primary" 
                title="TsMovies" 
                rootPath="/" 
                links={[ 
                    { path: "/movies", text: "Movies"}, 
                    { path: "/actors", text: "Actors"} 
                ]} 
            /&gt; 
            &lt;main style={{ paddingTop: "60px" }}&gt; 
                &lt;Switch&gt; 
                    &lt;Route exact path="/" component={HomePage}/&gt; 
                    &lt;Route path="/movies" component={MoviePage}/&gt; 
                    &lt;Route path="/actors" component={ActorPage}/&gt; 
                &lt;/Switch&gt; 
            &lt;/main&gt; 
        &lt;/div&gt; 
    &lt;/BrowserRouter&gt; 
); </pre>
<p>As we have already mentioned, the <kbd>Link</kbd> component is not used by the <kbd>Layout</kbd> component, but it can be used as follows:</p>
<pre>&lt;Link className="btn btn-primary" to={props.linkPath} &gt; 
    {props.linkText} 
&lt;/Link&gt; </pre>
<p>As we have already mentioned, the JSX syntax is almost identical to the HTML syntax. However, some attributes are not available or are named differently (for example, <kbd>className</kbd>). Another significant difference is that we must use a special syntax (<kbd>{}</kbd>) to bind the value of a variable to one of the properties of a component.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with React components</h1>
                
            
            
                
<p>In this section, we are going to take a close look at some of the components used by the application included in the companion source code. We will use multiple components to demonstrate multiple concepts.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Components as classes</h1>
                
            
            
                
<p>The following code snippet declares three components named <kbd>Container</kbd>, <kbd>Row</kbd>, and <kbd>Column</kbd>. These components extend the <kbd>Component</kbd> class, which is imported from the <kbd>React</kbd> module. There are a few methods that we can implement in a class that extends the <kbd>Component</kbd> class, but at a bare minimum, we must implement the <kbd>render</kbd> method.</p>
<p>The <kbd>Container</kbd>, <kbd>Row</kbd>, and <kbd>Column</kbd> components are used to control the layout of a page. These components use the CSS classes from the Bootstrap (a library that allow us to style our application with ease) grid system. In Bootstrap, the layout has a maximum of 12 columns, and a different size can be declared for a given screen size:</p>
<pre>import * as React from "react"; 
 
export class Container extends React.Component { 
    public render() { 
        return ( 
            &lt;div className="container"&gt; 
                {this.props.children} 
            &lt;/div&gt; 
        ); 
    } 
} 
 
export class Row extends React.Component { 
    public render() { 
        return ( 
            &lt;div className="row"&gt; 
                {this.props.children} 
            &lt;/div&gt; 
        ); 
    } 
} 
 
type ColumnWidth = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12; 
type DeviceSize = "s" | "m" | "l" | "xl"; 
 
interface ColumnProps { 
    width: ColumnWidth; 
    size?: DeviceSize; 
    style?: React.CSSProperties; 
} 
 
export class Column extends React.Component&lt;ColumnProps&gt; { 
    public render() { 
        return ( 
            &lt;div className={this._getClass()} style={this.props.style ? this.props.style : {}}&gt; 
                {this.props.children} 
            &lt;/div&gt; 
        ); 
    } 
    private _getClass() { 
        if (this.props.size !== undefined) { 
            return `col-${this.props.size}-${this.props.width}`; 
        } else { 
            return `col-${this.props.width}`; 
        } 
    } 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Properties and state</h1>
                
            
            
                
<p>As we can see in the preceding code snippet, the <kbd>Component</kbd> class is a generic class with two optional generic types: <kbd>Component&lt;TProps, TState&gt;</kbd>. These two generic types allow us to specify the type of the properties and state used in a React component.</p>
<p>As you can see, the <kbd>Container</kbd> and the <kbd>Row</kbd> components don't have any properties or state. However, the <kbd>Column</kbd> component defines the type of its properties because we need some additional data to be provided by its consumers. For example, when we declare the <kbd>Column</kbd> component, we don't know if the consumers will set its size to 1 or 12.</p>
<p>Properties are passed to a component via its constructor by the consumers of the component. For example, the following code snippet demonstrates how we can pass the property <kbd>width</kbd> to the <kbd>Column</kbd> component. The code snippet also demonstrates how we can pass other properties to the <kbd>Card</kbd> component:</p>
<pre>import * as React from "react"; 
import { Card } from "../components/card_component"; 
import { Container, Row, Column } from "../components/grid_component"; 
 
export const HomePage = () =&gt; ( 
    &lt;Container&gt; 
        &lt;Row&gt; 
            &lt;Column width={6}&gt; 
                &lt;Card 
                    title="Movies" 
                    description="Explore our database of movies" 
                    linkPath="/movies" 
                    linkText="Movies" 
                    img={null} 
                /&gt; 
            &lt;/Column&gt; 
            &lt;Column width={6}&gt; 
                &lt;Card 
                    title="Actors" 
                    description="Explore our actors of movies" 
                    linkPath="/actors" 
                    linkText="Actors" 
                    img={null} 
                /&gt; 
            &lt;/Column&gt; 
        &lt;/Row&gt; 
    &lt;/Container&gt; 
); </pre>
<p>A component can also have an internal state. The main difference between properties and states is that properties are immutable. In other words, the value of the properties of a component cannot change (be mutated) after the component instantiation. On the other hand, the state of a component mutates through the <kbd>setState</kbd> function. For example, the following code snippet declares a component that uses both properties and states. The component displays a basic numeric counter that increments when the users click on a button. The component properties are used to set the initial state of the component (the value of the counter). The state is then mutated by the <kbd>setState</kbd> function when the users click on the button:</p>
<pre>import * as React from "react"; 
import { Button } from "./button_component"; 
 
interface CounterProps { 
    initialValue: number; 
} 
 
interface CounterState { 
    value: number; 
} 
 
export class Component extends React.Component&lt;CounterProps, CounterState&gt; { 
    public constructor(props: CounterProps) { 
        super(props); 
        this.state = { value: this.props.initialValue }; 
    } 
    public render() { 
        return ( 
            &lt;div&gt; 
                The value is: {this.state.value} 
                &lt;Button onClick={() =&gt; this._increment()}&gt; 
                    Increment 
                &lt;/Button&gt; 
            &lt;/div&gt; 
        ); 
    } 
    private _increment() { 
        this.setState({ value: this.state.value + 1 }) 
    } 
} </pre>
<p>The preceding component can be consumed as follows:</p>
<pre>&lt;Counter initialValue={1} /&gt; </pre>
<p>The state of a component can only be changed by the component itself. In general, properties are preferred over internal states because it can lead to maintainability issues in very large projects. This is mainly because when we use an internal state, it is slightly more complicated to keep track of state mutations and the current state. We are going to learn more about this topic later in this chapter in the <em>Smart components and dumb components</em> section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Functional stateless components</h1>
                
            
            
                
<p>A <strong>functional stateless component</strong> (<strong>FSC</strong>) is a component that doesn't use an internal state, and it is a simple function, as opposed to a class that extends the <kbd>Component</kbd> class. For example, the <kbd>Header</kbd> component is an FSC:</p>
<pre>import { Link } from "react-router-dom"; 
import * as React from "react"; 
 
type BgColor = "primary" | "secondary" | "success" | 
               "danger" | "warning" | "info" | "light" | 
               "dark" | "white"; 
 
interface HeaderProps { 
    bg: BgColor; 
    title: string; 
    rootPath: string; 
    links: { path: string; text: string }[]; 
} 
 
export const Header = (props: HeaderProps) =&gt; ( 
    &lt;nav className={`navbar navbar-expand-lg navbar-light bg-${props.bg}`}&gt; 
        &lt;Link className="navbar-brand" to={props.rootPath}&gt; 
            {props.title} 
        &lt;/Link&gt; 
        &lt;ul className="navbar-nav"&gt; 
            { 
                props.links.map((link, linkIndex) =&gt; ( 
                    &lt;Link 
                        className="navbar-brand" 
                        to={link.path} 
                        key={linkIndex} 
                    &gt; 
                        {link.text} 
                    &lt;/Link&gt; 
                )) 
            } 
        &lt;/ul&gt; 
    &lt;/nav&gt; 
); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">React component life cycle</h1>
                
            
            
                
<p>When a component extends the <kbd>Component</kbd> class, it is possible to implement some component life cycle hooks. The companion source code includes a component named <kbd>MoviePage</kbd> that declares a component life cycle hook named <kbd>componentWillMount</kbd>:</p>
<pre>class MoviePage extends React.Component { 
    // ... 
    public componentWillMount() { 
        this.movieStore.getAll(); 
    } 
    public render() { 
        // ... </pre>
<p>React allows us to declare multiple component life cycle hooks. Covering all the available React component life cycle hooks is out of the scope of this book. However, it is important to understand that the events are organized into three main phases:</p>
<ul>
<li>The mounting phase takes place before the component is rendered</li>
<li>The updating phase included the rendering and the moment immediately before and after the component has been rendered</li>
<li>The unmounting phase takes place when the component is about to stop being rendered</li>
</ul>
<p>The following diagram showcases the order in which the main events are executed:</p>
<div><img class="alignnone size-full wp-image-263 image-border" src="img/80051090-0f69-4212-a831-c2ec76fd1cd3.png" style="width:155.75em;height:62.92em;" width="1869" height="755"/></div>
<p>Please refer to the official React documentation at <a href="https://reactjs.org/docs/react-component.html">https://reactjs.org/docs/react-component.html</a> to learn more about the component life cycle events.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Smart components and dumb components</h1>
                
            
            
                
<p>In a real-world React application, we will have many stateless React components, but somewhere in our tree of components, a component must be responsible for the management of the application state. This means that we can group them into two main categories:</p>
<ul>
<li><strong>Dumb components</strong> are also known as presentational components because their only responsibility is to present something to the DOM. Dumb components may be functional stateless components or not.</li>
<li><strong>Smart components</strong> are also known as container components because they are the ones that keep track of states and care about how the app works.</li>
</ul>
<p>The separation between smart and dumb components can be achieved in many ways, and it is sometimes coupled to some implementation details. The most simplistic way to achieve this is to have a smart component that uses an internal state and the <kbd>setState</kbd> function and some dumb components that take their parent's internal state as their properties. However, it is also very common to use external state container libraries (such as Redux or MobX) to implement smart components.</p>
<p>The application included in the companion source code declares a lot of dumb components (under the <kbd>components</kbd> directory) and some smart components (under the <kbd>pages</kbd> directory). The smart components are the ones responsible for the management of the application state. However, instead of using the <kbd>setState</kbd> function we are using MobX and some design patterns to ensure that our application can scale in a predictable and maintainable way.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with MobX</h1>
                
            
            
                
<p>MobX is a library that helps us to manage and mutate the state in a React application. In this section, we are going to understand the MobX architecture. We will also learn how to install and configure it, what its main components are, and its APIs.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding the MobX architecture</h1>
                
            
            
                
<p>The MobX architecture introduces an entity known as the <kbd>Store</kbd>. A <kbd>Store</kbd> is an object that contains some state and provides access to some actions that allow us to mutate its internal state:</p>
<ul>
<li>The state is observable; this means that when its value changes, an event is emitted and other parts of the application can subscribe to state changes</li>
<li>The actions allow us to mutate the current state</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with actions and observables</h1>
                
            
            
                
<p>In this section, we are going to learn to use observables and actions. The following code snippet declares a <kbd>Store</kbd> named <kbd>ActorStore</kbd>:</p>
<pre>import { ActorInterface } from "../../universal/entities/actor"; 
import * as mobx from "mobx"; 
import { provide } from "../config/ioc"; 
import { TYPE } from "../contants/types"; 
import * as interfaces from "../interfaces"; 
 
const { observable, action, runInAction, configure } = mobx; 
configure({ enforceActions: true }); 
 
@provide(TYPE.ActorStore) 
export class ActorStore implements interfaces.ActorStore { </pre>
<p>The <kbd>ActorStore</kbd> is a class that is decorated with the <kbd>@provide</kbd> decorators. This decorator is used to allow us to inject the <kbd>Store</kbd> into other elements in the application.</p>
<p>Please note that we will learn more about the <kbd>@provide</kbd> decorator later in this chapter in the <em>Dependency injection in MobX</em> section.</p>
<p>The <kbd>Store</kbd> class also declares some properties that are decorated with the <kbd>@observable</kbd> decorator. This decorator allows other elements in our application to subscribe to the changes in the properties:</p>
<pre>    // Contains the actors that have been already loaded from the server 
    @observable public actors: ActorInterface[] = []; 
 
    // Used to represent the status of the HTTP GET calls 
    @observable public loadStatus: interfaces.Status = "pending"; 
 
    // Used to represent the status of the HTTP DELETE call 
    @observable public deleteStatus: interfaces.Status = "idle"; 
 
    // Used to represent the status of the HTTP POST and HTTP PUT calls 
    @observable public saveStatus: interfaces.Status = "idle"; 
 
    // Used to display the confirmation dialog before deleting an actor 
    // null hides the modal and number display the modal 
    @observable public deleteActorId: null | number = null; 
 
    // Used to hold the values of the actor editor or null 
    // when nothing is being edited 
    @observable public editorValue: null | Partial&lt;ActorInterface&gt; = null; </pre>
<p>After declaring the properties of the <kbd>Store</kbd>, we are going to declare its actions. As you can see in the following code snippet, an action is a method decorated with the <kbd>@action</kbd> decorator:</p>
<pre>    @action 
    public focusEditor() { 
        runInAction(() =&gt; { 
            this.editorValue = {}; 
        }); 
    } 
 
    @action 
    public focusOutEditor() { 
        runInAction(() =&gt; { 
            this.editorValue = null; 
        }); 
    } 
 
    @action 
    public focusDeleteDialog(id: number) { 
        runInAction(() =&gt; { 
            this.deleteActorId = id; 
        }); 
    } 
 
    @action 
    public focusOutDeleteDialog() { 
        runInAction(() =&gt; { 
            this.deleteActorId = null; 
        }); 
    } 
 
    @action 
    public edit&lt;T extends ActorInterface, K extends keyof T&gt;( 
        key: K, val: T[K] 
    ) { 
        runInAction(() =&gt; { 
            const actor = {...(this.editorValue || {}), ...{[key]: val}}; 
            this.editorValue = actor; 
        }); 
    } </pre>
<p>The <kbd>@action</kbd> decorator can be used to decorate methods that perform state mutations like the preceding methods, but we are not limited to only this kind of operation. The following methods perform state mutations, but they also send some HTTP requests to the server using the Fetch API. There is an action to fetch all actors from the actors REST API:</p>
<pre>    @action 
    public async getAll() { 
        try { 
            const response = await fetch( 
                "/api/v1/actors/", 
                { method: "GET" } 
            ); 
            const actors: ActorInterface[] = await response.json(); 
            // We use setTimeout to simulate a slow request 
            // this should allow us to see the loading component 
            setTimeout( 
                () =&gt; { 
                    runInAction(() =&gt; { 
                        this.loadStatus = "done"; 
                        this.actors = actors; 
                    }); 
                }, 
                1500 
            ); 
        } catch (error) { 
            runInAction(() =&gt; { 
                this.loadStatus = "error"; 
            }); 
        } 
    } </pre>
<p>There is also an action to create a new actor:</p>
<pre>    @action 
    public async create(actor: Partial&lt;ActorInterface&gt;) { 
        try { 
            const response = await fetch( 
                "/api/v1/actors/", 
                { 
                    body: JSON.stringify(actor), 
                    headers: { 
                        "Accept": "application/json, text/plain, */*", 
                        "Content-Type": "application/json" 
                    }, 
                    method: "POST" 
                } 
            ); 
            const newActor: ActorInterface = await response.json(); 
            runInAction(() =&gt; { 
                this.loadStatus = "done"; 
                this.actors.push(newActor); 
                this.editorValue = null; 
            }); 
        } catch (error) { 
            runInAction(() =&gt; { 
                this.loadStatus = "error"; 
            }); 
        } 
    } </pre>
<p>There is also an action to delete an actor:</p>
<pre>    @action 
    public async delete(id: number) { 
        try { 
            const response = await fetch( 
                `/api/v1/actors/${id}`, 
                { method: "DELETE" } 
            ); 
            await response.json(); 
            runInAction(() =&gt; { 
                this.deleteStatus = "done"; 
                this.actors = this.actors.filter((m) =&gt; m.id !== id); 
                this.deleteActorId = null; 
            }); 
        } catch (error) { 
            runInAction(() =&gt; { 
                this.deleteStatus = "error"; 
            }); 
        } 
    } 
 
} </pre>
<p>We use the <kbd>runInAction</kbd> function to wrap the state mutations. Using the <kbd>runInAction</kbd> function is required because we previously configured MobX to enforce that state mutations must only take place in actions:</p>
<pre>configure({ enforceActions: true }); </pre>
<p>At this point, our <kbd>Store</kbd> is ready to be injected into one of our React smart components using the <kbd>@lazyInject</kbd> decorator.</p>
<p>Please note that we will learn more about the <kbd>@lazyInject</kbd> decorator later in this chapter in the <em>Dependency injection in MobX</em> section.</p>
<p>The following code snippet declares a smart component named <kbd>MoviePages</kbd>. In our React application, the pages are smart components and the components are simply dumb components:</p>
<pre>import * as React from "react"; 
import { observer } from "mobx-react"; 
import { MovieInterface } from "../../universal/entities/movie"; 
import { Container, Row, Column } from "../components/grid_component"; 
import { ListGroup } from "../components/list_group_component"; 
import { Modal } from "../components/modal_component"; 
import { TextField } from "../components/textfield_component"; 
import { Button } from "../components/button_component"; 
import { lazyInject } from "../config/ioc"; 
import { TYPE } from "../contants/types"; 
import * as interfaces from "../interfaces"; 
 
function isValidNewMovie(o: any) { 
    if ( 
        o === null || 
        o === undefined || 
        // new movies don't have ID 
        o.id !== undefined || 
        typeof o.title !== "string" || 
        isNaN(o.year) 
    ) { 
        return false; 
    } 
    return true; 
} </pre>
<p>This smart component is implemented using a class that extends the <kbd>Component</kbd> class and is decorated with the <kbd>@observer</kbd> decorator. The <kbd>@observer</kbd> decorator binds the React component to the state changes in the <kbd>Store</kbd>:</p>
<pre>@observer 
export class MoviePage extends React.Component { </pre>
<p>The <kbd>MovieStore</kbd> is injected into the <kbd>Component</kbd> after an instance of it has been created by React. We can ignore the details about this for now because it will be explained in the following section:</p>
<pre>    @lazyInject(TYPE.MovieStore) public movieStore!: interfaces.MovieStore; </pre>
<p>We use then the <kbd>componentWillMount</kbd> event hook to trigger the initial data-fetching action:</p>
<pre>    public componentWillMount() { 
        this.movieStore.getAll(); 
    } </pre>
<p>Finally, we render the page. The <kbd>render</kbd> method accesses some of the properties (<kbd>@observables</kbd>) of the <kbd>Store</kbd>. Because our component is an observer (<kbd>@observer</kbd>), if an action (<kbd>@action</kbd>) is triggered, our component will be re-rendered. The component renders a list of movies:</p>
<pre>    public render() { 
        const error = this.movieStore.loadStatus === "error" ? new Error("Movies could not be loaded!") : null; 
        const movies = this.movieStore.loadStatus === "pending" ? null : this.movieStore.movies; 
        return ( 
            &lt;Container&gt; 
                &lt;Row&gt; 
                    &lt;Column width={12} style={{ textAlign: "right", marginBottom: "10px" }}&gt; 
                        &lt;Button 
                            onClick={() =&gt; { 
                                this.movieStore.focusEditor(); 
                            }} 
                        &gt; 
                            Add Movie 
                        &lt;/Button&gt; 
                    &lt;/Column&gt; 
                &lt;/Row&gt; 
                &lt;Row&gt; 
                    &lt;Column width={12}&gt; 
                        &lt;ListGroup 
                            error={error} 
                            items={movies} 
                            itemComponent={(movie: MovieInterface) =&gt; ( 
                                &lt;Row&gt; 
                                    &lt;Column width={8}&gt; 
                                        &lt;h5&gt;{movie.title}&lt;/h5&gt; 
                                        &lt;p&gt;{movie.year}&lt;/p&gt; 
                                    &lt;/Column&gt; 
                                    &lt;Column width={4} style={{ textAlign: "right" }}&gt; 
                                        &lt;Button 
                                            kind="danger" 
                                            onClick={() =&gt; { 
                                                this.movieStore.focusDeleteDialog(movie.id); 
                                            }} 
                                        &gt; 
                                            Delete 
                                        &lt;/Button&gt; 
                                    &lt;/Column&gt; 
                                &lt;/Row&gt; 
                            )} 
                        /&gt; 
                    &lt;/Column&gt; 
                &lt;/Row&gt; </pre>
<p>This component also renders a modal window that allows us to create a movie:</p>
<pre>                &lt;Modal 
                    title="Movie Editor" 
                    isVisible={this.movieStore.editorValue !== null} 
                    onAcceptLabel="Save" 
                    onAccept={() =&gt; { 
                        if (isValidNewMovie(this.movieStore.editorValue)) { 
                            const movie: any = this.movieStore.editorValue; 
                            this.movieStore.create(movie); 
                        } 
                    }} 
                    onCancelLabel="Cancel" 
                    onCancel={() =&gt; { 
                        this.movieStore.focusOutEditor(); 
                    }} 
                    error={this.movieStore.saveStatus === "error" ? new Error("Something went wrong") : undefined} 
                &gt; 
 
                    &lt;form&gt; 
                        &lt;TextField 
                            id="movie_title" 
                            value={this.movieStore.editorValue ? this.movieStore.editorValue.title : ""} 
                            title="Title" 
                            placeholder="Title" 
                            isValid={(val) =&gt; val !== undefined &amp;&amp; val !== ""} 
                            onChange={(val) =&gt; { 
                                this.movieStore.edit("title", val); 
                            }} 
                        /&gt; 
                        &lt;TextField 
                            id="movie_year" 
                            value={this.movieStore.editorValue ? this.movieStore.editorValue.year : 2018} 
                            title="Year" 
                            placeholder="Year" 
                            isValid={(val) =&gt; !isNaN(val as any)} 
                            onChange={(val) =&gt; { 
                                const n = parseInt(val); 
                                if (!isNaN(n)) { 
                                    this.movieStore.edit("year", n); 
                                } 
                            }} 
                        /&gt; 
                    &lt;/form&gt; 
                &lt;/Modal&gt; </pre>
<p>This component also renders a modal window that allows us to confirm that we wish to delete a movie from the database:</p>
<pre>                &lt;Modal 
                    title="Are you sure?" 
                    isVisible={this.movieStore.deleteMovieId !== null} 
                    onAcceptLabel="Delete" 
                    onAccept={() =&gt; { 
                        if (this.movieStore.deleteMovieId) { 
                            this.movieStore.delete(this.movieStore.deleteMovieId); 
                        } 
                    }} 
                    onCancelLabel="Cancel" 
                    onCancel={() =&gt; { 
                        this.movieStore.focusOutDeleteDialog(); 
                    }} 
                    error={this.movieStore.deleteStatus === "error" ? new Error("Something went wrong") : undefined} 
                &gt; 
                    The movie will be deleted permanently! 
                &lt;/Modal&gt; 
            &lt;/Container&gt; 
        ); 
    } 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Dependency injection in MobX</h1>
                
            
            
                
<p>In the preceding section, we decorated the <kbd>ActorStore</kbd> class with the <kbd>@provide</kbd> decorators:</p>
<pre>@provide(TYPE.ActorStore) 
export class ActorStore implements interfaces.ActorStore { </pre>
<p>This decorator is an alternative to the InversifyJS biding syntax and is equivalent to the following:</p>
<pre>container.bind&lt;ActorStore&gt;(TYPE.ActorStore).to(ActorStore); </pre>
<p>The <kbd>@provide</kbd> decorator is not required but it is more convenient than the binding API. The <kbd>@provide</kbd> decorator can be created using the <kbd>inversify-binding-decorators</kbd> module as follows:</p>
<pre>import { Container } from "inversify"; 
import { makeProvideDecorator } from "inversify-binding-decorators"; 
 
const container = new Container(); 
const provide = makeProvideDecorator(container); 
 
export { provide }; </pre>
<p>Note that the examples use the version 3.2.0 of the <kbd>inversify-binding-decorators</kbd> module and the upcoming version (4.0.0) will introduce some breaking changes. You can refer to the documentation at <a href="https://github.com/inversify/inversify-binding-decorators">https://github.com/inversify/inversify-binding-decorators</a> to learn more about the new API.</p>
<p>The <kbd>@provider</kbd> decorator declares a binding automatically for us when it is executed, and decorators are executed when a class is declared. This means that we need to import the files that use the <kbd>@provider</kbd> decorator at least once in our application to trigger the class declaration, or no bindings will be declared:</p>
<pre>import "../stores/movie_store"; 
import "../stores/actor_store"; </pre>
<p>After declaring the bindings, the <kbd>Store</kbd> is injected into a React component. However, we cannot use the <kbd>@injectable</kbd> and <kbd>@inject</kbd> annotations as we did in some of the preceding chapters because React components are instantiated by React. This means that our IoC container will not be able to create instances of our React components and will therefore not be able to perform any constructor injection. We can overcome this limitation by using the <kbd>@lazyInject</kbd> decorator:</p>
<pre>@lazyInject(TYPE.MovieStore) public movieStore!: interfaces.MovieStore; </pre>
<p>The <kbd>@lazyInject</kbd> decorator injects a dependency immediately before it is used instead of injecting it when an instance of its dependent is created. The <kbd>@lazyInject</kbd> decorator can be created using the <kbd>inversify-inject-decorators</kbd> module as follows:</p>
<pre>import { Container } from "inversify"; 
import getDecorators from "inversify-inject-decorators"; 
 
const container = new Container(); 
const { lazyInject } = getDecorators(container); 
 
export { lazyInject }; </pre>
<p>Please refer to <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml">Chapter 5</a>, <em>Working with Dependencies</em>, to learn more about dependency injection and InversifyJS.</p>
<p>Using dependency injection in MobX is useful because we can inject a different store with hardcoded results during the execution of the unit tests. This allows us to test the components in complete isolation.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">MobX alternatives</h1>
                
            
            
                
<p>We have been using MobX to manage the state of our application and the required state mutations (actions). MobX is a great library and it has great support for TypeScript. However, it is not the only option.</p>
<p>One of the best features of React is that we have the freedom to select many different state management tools and architectures. Freedom of choice can lead to confusion and is a problem for junior engineers because they don't have the experience required to judge if a library is better than another. On the other hand, freedom can lead to more innovation and better solutions.</p>
<p>The two most popular alternatives to MobX are Redux and Flux. You can learn more about Redux at <a href="https://redux.js.org">https://redux.js.org</a>. Please refer to <a href="https://facebook.github.io/flux/">https://facebook.github.io/flux</a> to learn more about Flux.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Development tools</h1>
                
            
            
                
<p>We can install the React development tools extensions for Google Chrome to help us to debug our frontend React applications. The extension can be downloaded at <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a>.</p>
<p>There is also a Google Chrome extension available that can help us to debug a MobX application. We can download the extension at the official installation page: <a href="https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod">https://chrome.google.com/webstore/detail/mobx-developer-tools/pfgnfdagidkfgccljigdamigbcnndkod</a>.</p>
<p>These tools allow us to see components being rendered, their properties and state, and the MobX actions:</p>
<div><img class="alignnone size-full wp-image-265 image-border" src="img/56b27ebe-b622-425a-bbe7-97205090ef17.png" style="width:100.00em;height:35.17em;" width="1200" height="422"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned the basic principles of component-based web development and how to use React. We have also learned about concepts like stateless functional components and dumb components.</p>
<p>In the next chapter, we are going to implement the same application one more time. However, we will use Angular instead of React and MobX as our application development framework. We will try to implement a copy of the application as close as possible to enable us to compare both frameworks.</p>


            

            
        
    </div>



  </body></html>