<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor173" class="pcalibre1 calibre6 pcalibre"/>5</h1>
<h1 id="_idParaDest-90" class="calibre5"><a id="_idTextAnchor174" class="pcalibre1 calibre6 pcalibre"/>Rendering Strategies and Page Hydration</h1>
<p class="calibre3">Rendering strategies and page hydration approaches allow us to leverage the JavaScript client and server ecosystem to serve performant and scalable web applications, depending on the needs of our end users. The React and JavaScript techniques covered in this chapter are another set of tools to augment the <a href="B19109_04.xhtml#_idTextAnchor130" class="pcalibre1 calibre6 pcalibre"><em class="italic">Chapter 4</em></a> chapter. We’ll use the strengths of the client (browser) and server (specifically, Node.js) runtimes to deliver fast and scalable React websites to users.</p>
<p class="calibre3">In this chapter, we’ll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">What the trade-offs are between client and server rendering of React applications by implementing pure client and server rendering applications</li>
<li class="calibre11">The types of advantages that frameworks such as Next.js can bring with static site generation functionality, alongside server-side rendering</li>
<li class="calibre11">Bridging the client-server rendering gap with a React page rehydration example and its gotchas</li>
<li class="calibre11">Streaming server rendering in React</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to select appropriate rendering and page hydration strategies with React and be able to implement framework-level functionality, enabling you to make better technology choices.</p>
<h1 id="_idParaDest-91" class="calibre5"><a id="_idTextAnchor175" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-92" class="calibre5"><a id="_idTextAnchor176" class="pcalibre1 calibre6 pcalibre"/>Client and server rendering with React</h1>
<p class="calibre3">In a web context, client-side rendering<a id="_idIndexMarker231" class="pcalibre1 calibre6 pcalibre"/> is the process by which JavaScript<a id="_idIndexMarker232" class="pcalibre1 calibre6 pcalibre"/> is used inside a user’s browser to generate<a id="_idIndexMarker233" class="pcalibre1 calibre6 pcalibre"/> or update the page<a id="_idIndexMarker234" class="pcalibre1 calibre6 pcalibre"/> contents. A fully client-side-rendered application will only display meaningful content when the relevant JavaScript code has completed downloading, parsing, and running.</p>
<p class="calibre3">In the following sequence diagram, we use the term “origin” instead of something such as “server,” since one benefit of full client-side rendering is that<a id="_idIndexMarker235" class="pcalibre1 calibre6 pcalibre"/> the resources “serving” our content can be what’s called <em class="italic">static hosting</em>. This includes services such as <strong class="bold">AWS Simple Storage Service</strong> (<strong class="bold">S3</strong>), Netlify, Cloudflare Pages, and GitHub<a id="_idIndexMarker236" class="pcalibre1 calibre6 pcalibre"/> Pages, among others. There’s no dynamic server-side component in these services.</p>
<div><div><img alt="Figure 5.1: A client-side-rendering sequence diagram" src="img/B19109_05_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1: A client-side-rendering sequence diagram</p>
<p class="calibre3">In contrast, server-side<a id="_idIndexMarker237" class="pcalibre1 calibre6 pcalibre"/> rendering<a id="_idIndexMarker238" class="pcalibre1 calibre6 pcalibre"/> denotes the process by which a server<a id="_idIndexMarker239" class="pcalibre1 calibre6 pcalibre"/> generates a full HTML document when a browser <a id="_idIndexMarker240" class="pcalibre1 calibre6 pcalibre"/>requests it and returns it.</p>
<div><div><img alt="Figure 5.2: A server-side-rendering sequence ﻿diagram" src="img/B19109_05_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2: A server-side-rendering sequence <a id="_idTextAnchor177" class="pcalibre1 calibre6 pcalibre"/>diagram</p>
<h2 id="_idParaDest-93" class="calibre7"><a id="_idTextAnchor178" class="pcalibre1 calibre6 pcalibre"/>Client-side rendering in React</h2>
<p class="calibre3">Client rendering<a id="_idIndexMarker241" class="pcalibre1 calibre6 pcalibre"/> is the default rendering <a id="_idIndexMarker242" class="pcalibre1 calibre6 pcalibre"/>method with React. Let’s build an application that renders client-side from scratch:</p>
<ol class="calibre15">
<li class="calibre11">We start with an <strong class="source-inline1">App</strong> component that renders some text and its <strong class="source-inline1">type</strong> prop:<pre class="source-code">
export function App({ type = '' }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
    &lt;/div&gt;
  );
}</pre></li> <li class="calibre11">We then create an entry point file, <strong class="source-inline1">client.jsx</strong>, which imports the app and uses <strong class="source-inline1">ReactDOM</strong> to render it, with the <strong class="source-inline1">type</strong> prop set to <strong class="source-inline1">"</strong><strong class="source-inline1">client render"</strong>.<pre class="source-code">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './src/app';
ReactDOM.createRoot(document.querySelector
  ('#app')).render(
  &lt;App type={`"client render"`} /&gt;
);</pre></li> <li class="calibre11">In order for this example<a id="_idIndexMarker243" class="pcalibre1 calibre6 pcalibre"/> to run, we need an HTML document<a id="_idIndexMarker244" class="pcalibre1 calibre6 pcalibre"/> that allows <strong class="source-inline1">ReactDOM.createRoot</strong> to run successfully. In other words, we need an HTML document that has an element with <strong class="source-inline1">id=app</strong> and references our entry point:<pre class="source-code">
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script src="img/client.js"&gt;&lt;/script&gt;</pre></li> <li class="calibre11">Note that the entry point is <strong class="source-inline1">dist/client.js</strong> instead of <strong class="source-inline1">client.jsx</strong>. That’s due to the fact that React’s JSX syntax can’t be run natively in the browser. Instead, we run our entry point file, <strong class="source-inline1">client.jsx</strong>, through a compilation and bundling step using <strong class="source-inline1">esbuild</strong>. Our build command looks something like this:<pre class="source-code">
<strong class="bold1">npx esbuild client.jsx --bundle --outdir=dist</strong></pre></li> </ol>
<p class="calibre3">Now, if we load the <code>index.html</code> file in the browser, we see the following:</p>
<div><div><img alt="Figure 5.3: Hello from the “client render” app rendered in t﻿he browser" src="img/B19109_05_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.3: Hello from the “client render” app rendered in t<a id="_idTextAnchor179" class="pcalibre1 calibre6 pcalibre"/>he browser</p>
<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor180" class="pcalibre1 calibre6 pcalibre"/>Server rendering in React</h2>
<p class="calibre3">Node.js, introduced on its website<a id="_idIndexMarker245" class="pcalibre1 calibre6 pcalibre"/> as “an open-source, cross-platform JavaScript<a id="_idIndexMarker246" class="pcalibre1 calibre6 pcalibre"/> runtime environment,” gives us the ability to run JavaScript on a server. A commonly used package to build servers in Node.js is Express.</p>
<p class="calibre3">In this section, we’ll see how to use Node.js and Express to server-render a React application.</p>
<p class="calibre3">A simple Express server that returns <code>'Server-rendered hello'</code> when the root path is loaded looks as follows:</p>
<pre class="source-code">
import express from 'express';
const app = express();
app.get('/', (_req, res) =&gt; {
  res.send('Server-rendered hello');
});
const { PORT = 3000 } = process.env;
app.listen(PORT, () =&gt; {
  console.log(`Server started on
    http://localhost:${PORT}`);
});</pre> <p class="calibre3">Again, we’ll use <code>esbuild</code> to bundle and compile the JSX to JavaScript:</p>
<pre class="console">
npx esbuild server.js --bundle --platform=node --outdir=dist</pre> <p class="calibre3">We can then start the server using the following:</p>
<pre class="console">
node dist/server.js</pre> <p class="calibre3">By default, it runs on port <code>3000</code>, but that can be overridden with environment variables.</p>
<p class="calibre3">When we load <code>localhost:3000</code>, we see this message in the browser.</p>
<div><div><img alt="Figure 5.4: Server-rendered hello rendered in the browser" src="img/B19109_05_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.4: Server-rendered hello rendered in the browser</p>
<p class="calibre3">This is a really minimal<a id="_idIndexMarker247" class="pcalibre1 calibre6 pcalibre"/> example of server-rendering<a id="_idIndexMarker248" class="pcalibre1 calibre6 pcalibre"/> using Node.js and Express.</p>
<p class="calibre3">Next, we’ll see how to leverage the <code>ReactDOM</code> package to take React components and server-render them:</p>
<ol class="calibre15">
<li class="calibre11">The <strong class="source-inline1">ReactDOM</strong> package provides both a <strong class="source-inline1">react-dom/client</strong> entry point (which we used in the previous section) and a <strong class="source-inline1">react-dom/server</strong> entry point. As the names allude to, the client entry point is meant to be used on the client (in the browser, “client-side” JavaScript), and the server entry point is meant to be used on the server (via Node.js or another server-side JavaScript runtime).</li>
<li class="calibre11">The two methods we’ll use are <strong class="source-inline1">ReactDOMServer.renderToStaticMarkup</strong> and <strong class="source-inline1">ReactDOMServer.renderToString</strong>; these two methods will allow us to server-render our React application to HTML.</li>
<li class="calibre11">In a <strong class="source-inline1">src/server-render.jsx</strong> file, we have the following <strong class="source-inline1">renderNav</strong> and <strong class="source-inline1">serverRenderApp</strong> functions, which use <strong class="source-inline1">ReactDOMServer.renderToStaticMarkup</strong> and <strong class="source-inline1">ReactDOMServer.renderToString</strong> to render <strong class="source-inline1">Nav</strong> and <strong class="source-inline1">App</strong>, respectively:<pre class="source-code">
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import { App } from './app';
import { Nav } from './nav';
export function renderNav() {
  return ReactDOMServer.renderToStaticMarkup(&lt;Nav /&gt;);
}
export function serverRenderApp() {
  return ReactDOMServer.renderToString(&lt;App
    type={`"server render"`} /&gt;);
}</pre><p class="calibre3">Here, <code>app.jsx</code> is the same<a id="_idIndexMarker249" class="pcalibre1 calibre6 pcalibre"/> as we had<a id="_idIndexMarker250" class="pcalibre1 calibre6 pcalibre"/> in the previous section, and <code>nav.jsx</code> is as follows:</p><pre class="source-code">import React from 'react';
export function Nav() {
  return (
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href="/"&gt;Server-render only&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</pre></li> <li class="calibre11">We can then use <strong class="source-inline1">renderNav</strong> and <strong class="source-inline1">serverRenderApp</strong> in <strong class="source-inline1">server.js</strong>. We modify the <strong class="source-inline1">app.get('/')</strong> handler<a id="_idIndexMarker251" class="pcalibre1 calibre6 pcalibre"/> to render the navigation<a id="_idIndexMarker252" class="pcalibre1 calibre6 pcalibre"/> and the app:<pre class="source-code">
// no other changes
app.get('/', (_req, res) =&gt; {
  res.send(`
    &lt;!DOCTYPE html&gt;
    ${renderNav()}
    &lt;h1&gt;Server-render only&lt;/h1&gt;
    &lt;div id="app"&gt;${serverRenderApp()}&lt;/div&gt;
  `);
});</pre></li> <li class="calibre11">When we rebuild the server, we run <strong class="source-inline1">node dist/server.js</strong> and open <strong class="source-inline1">localhost:3000</strong> to see the following:</li>
</ol>
<div><div><img alt="Figure 5.5: Hello from the “server render” app being rendered alongside a heading and the nav" src="img/B19109_05_5.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.5: Hello from the “server render” app being rendered alongside a heading and the nav</p>
<p class="calibre3">What’s the difference between <code>ReactDOMServer.renderToStaticMarkup</code> and <code>ReactDOMServer.renderToString?</code> The short answer is that <code>renderToStaticMarkup</code> can’t be rehydrated client-side; in other words, it can’t be used as the initial HTML, and then<a id="_idIndexMarker253" class="pcalibre1 calibre6 pcalibre"/> the same React application<a id="_idIndexMarker254" class="pcalibre1 calibre6 pcalibre"/> code can be run client-side to give a fully interactive experience. We’ll revisit this in a later secti<a id="_idTextAnchor181" class="pcalibre1 calibre6 pcalibre"/>on of the chapter.</p>
<h2 id="_idParaDest-95" class="calibre7"><a id="_idTextAnchor182" class="pcalibre1 calibre6 pcalibre"/>Trade-offs between client and server rendering</h2>
<p class="calibre3">So, what are the benefits<a id="_idIndexMarker255" class="pcalibre1 calibre6 pcalibre"/> and drawbacks of client and server rendering?</p>
<p class="calibre3">Client rendering’s main benefit is that the application’s “work” is done fully in the user’s browsers, which makes it highly scalable since the amount of users using the system will not put pressure on the origin servers. Client rendering’s main drawbacks relate to functionality that is only available on the server side – for example, server-side-only cookies or setting the <code>meta</code> tags for social media preview.</p>
<p class="calibre3">Server rendering’s main drawback is that work has to happen on the server. As stated previously, the server being a “controlled” environment has some benefits, namely its latency to other co-located systems will tend to be lower than a full browser-server round trip, since the server’s network is known and unlikely to have as much variance in performance as an end user’s network. By not waiting for a full-page load, followed by an asset load, followed<a id="_idIndexMarker256" class="pcalibre1 calibre6 pcalibre"/> by a JavaScript “parse and execute” cascade, server-rendering<a id="_idIndexMarker257" class="pcalibre1 calibre6 pcalibre"/> can improve “core web vitals”, such as <strong class="bold">largest </strong><strong class="bold">contentful</strong><strong class="bold"> paint</strong> (<strong class="bold">LCP</strong>) and <strong class="bold">cumulative layout </strong><strong class="bold">shift</strong> (<strong class="bold">CLS</strong>).</p>
<p class="calibre3">Ultimately, client-rendered functionality is a key reason we use JavaScript, which means removing that ability will only make sense in constrained use cases such as content sites (e.g., blogs, news sites, and documentation sites).</p>
<p class="calibre3">We’ve now seen the difference between client<a id="_idIndexMarker258" class="pcalibre1 calibre6 pcalibre"/> and server rendering, as well as how to implement both with React and Node.js. In the following section, we’ll look at rendering approaches enabled by the Next.j<a id="_idTextAnchor183" class="pcalibre1 calibre6 pcalibre"/>s framework for React.</p>
<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor184" class="pcalibre1 calibre6 pcalibre"/>Static rendering with Next.js</h1>
<p class="calibre3">Next.js is a React framework<a id="_idIndexMarker259" class="pcalibre1 calibre6 pcalibre"/> for creating full<a id="_idIndexMarker260" class="pcalibre1 calibre6 pcalibre"/> stack web applications. What this means is that it provides tools and opinions that will help developers be more productive in the short and long term.</p>
<p class="calibre3">Next.js includes a filesystem router for “pages”, a set of routing primitives for React, support for client and server rendering, and data fetching primitives, among others.</p>
<p class="calibre3">The features of Next.js we’ll focus on are the <strong class="bold">static site generation</strong> (<strong class="bold">SSG</strong>) ones. This type of rendering methodology<a id="_idIndexMarker261" class="pcalibre1 calibre6 pcalibre"/> resembles server rendering but mitigates some of its drawbacks, since the rendering pass is done at build time instead of at request time.</p>
<div><div><img alt="Figure 5.6: A sequence diagram for a pre-rendered/static site generation use case" src="img/B19109_05_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.6: A sequence diagram for a pre-rendered/static site generation use case</p>
<p class="calibre3">Now that we’ve looked<a id="_idIndexMarker262" class="pcalibre1 calibre6 pcalibre"/> at how static site generation changes the data flow when<a id="_idIndexMarker263" class="pcalibre1 calibre6 pcalibre"/> a user requests a website, we’ll look at Next.js aut<a id="_idTextAnchor185" class="pcalibre1 calibre6 pcalibre"/>omatic static generation.</p>
<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor186" class="pcalibre1 calibre6 pcalibre"/>Automatic static generation</h1>
<p class="calibre3">In Next.js, the filesystem-based routing<a id="_idIndexMarker264" class="pcalibre1 calibre6 pcalibre"/> means that each path in your web application corresponds to a file in the <code>pages</code> directory of your application. For example, <code>/</code> corresponds to <code>pages/index.js</code>.</p>
<p class="calibre3">Next.js defaults to static generation when no Next.js data fetching methods are used for a given page. You can find more information<a id="_idIndexMarker265" class="pcalibre1 calibre6 pcalibre"/> from the Next.js documentation – <em class="italic">Automatic Static </em><em class="italic">Optimization</em> (<a href="https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization" class="pcalibre1 calibre6 pcalibre">https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization</a>).</p>
<p class="author-quote">Next.js automatically determines that a page is static (i.e., can be prerendered) if it has no blocking data requirements. This determination is made by the absence of getServerSideProps and getInitialProps on the page.</p>
<p class="calibre3">For example, the following page in a Next.js application will be statically generated, since it only exports a page<a id="_idIndexMarker266" class="pcalibre1 calibre6 pcalibre"/> component (the default export of <code>Index</code>); no <code>getServerSideProps</code> or <code>getInitialProps</code> function is exported:</p>
<pre class="source-code">
import React from 'react';
import Head from 'next/head';
import Link from 'next/link';
export default function Index() {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Next Static Rendering - Automatic Static
          Generation&lt;/title&gt;
        &lt;meta name="viewport" content="width=device-width,
          initial-scale=1" /&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;Link href="/products"&gt;Products Page (SSG)
            &lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link href="/cart"&gt;Cart Page (SSR)&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">We can see this during <code>next build</code> in the following<a id="_idIndexMarker267" class="pcalibre1 calibre6 pcalibre"/> screenshot; <code>/ route (page)</code> is marked as <code>Static</code> in the output:</p>
<pre class="console">
npx next build
info  - Linting and checking validity of types
info  - Creating an optimized production build
info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (3/3)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      2.73 kB        75.8 kB
└ ○ /404                                   182 B          73.2 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
○  (Static)  automatically rendered as static HTML (uses no initial props)</pre> <p class="calibre3">When we run the built Next.js output<a id="_idIndexMarker268" class="pcalibre1 calibre6 pcalibre"/> with <code>next start</code>, the page behaves as expected.</p>
<div><div><img alt="Figure 5.7: Links to the Products and Cart pages rendering" src="img/B19109_05_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.7: Links to the Products and Cart pages rendering</p>
<p class="calibre3">This example is a relatively constrained use case since we have no dynamic data fetching requirements. It still showcases Next.js defaulting to static rendering if the page does not use any functionality that excludes static generation. For more advanced use cases, Next.js also allows use of “build-time” dynamic data, which means we can use a third-party data source to generate the page content, and more.</p>
<p class="calibre3">We’ve seen how Next.js defaults<a id="_idIndexMarker269" class="pcalibre1 calibre6 pcalibre"/> to automatic static generation. Next, we’ll see how to configure a Next.js page to load d<a id="_idTextAnchor187" class="pcalibre1 calibre6 pcalibre"/>ata to render a page as static.</p>
<h1 id="_idParaDest-98" class="calibre5"><a id="_idTextAnchor188" class="pcalibre1 calibre6 pcalibre"/>Static generation with a third-party data source</h1>
<p class="calibre3">Next.js has a <code>getStaticProps</code> data fetching method<a id="_idIndexMarker270" class="pcalibre1 calibre6 pcalibre"/> that allows us to load data<a id="_idIndexMarker271" class="pcalibre1 calibre6 pcalibre"/> at build time, which will be passed to a page.</p>
<p class="calibre3">The following sequence diagram illustrate what this involves:</p>
<div><div><img alt="Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps" src="img/B19109_05_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps</p>
<p class="calibre3">For example, if we want<a id="_idIndexMarker272" class="pcalibre1 calibre6 pcalibre"/> to build a “product list” page based on <code>fakestoreapi.com</code> data, we can write<a id="_idIndexMarker273" class="pcalibre1 calibre6 pcalibre"/> the following <code>getStaticProps</code> method in a <code>pages/products/index.js</code> page:</p>
<pre class="source-code">
export async function getStaticProps() {
  const products = await fetch
    ('https://fakestoreapi.com/products').then(
    (res) =&gt; res.json()
  );
  return {
    props: {
      products,
    },
  };
}</pre> <p class="calibre3">Here’s a <code>product</code> example in the response<a id="_idIndexMarker274" class="pcalibre1 calibre6 pcalibre"/> to illustrate the data<a id="_idIndexMarker275" class="pcalibre1 calibre6 pcalibre"/> shape:</p>
<pre class="source-code">
{
  id: 1,
  title: 'Fjallraven - Foldsack No. 1 Backpack, Fits 15
    Laptops',
  price: 109.95,
  description: 'Your perfect pack for everyday use and
  walks in the forest. Stash your laptop (up to 15 inches)
  in the padded sleeve, your everyday',
  category: "men's clothing",
  image: 'https://fakestoreapi.com/img/
    81fPKd-2AYL._AC_SL1500_.jpg',
  rating: { rate: 3.9, count: 120 }
}</pre> <p class="calibre3">Based on the data provided by <code>getStaticProps</code>, we can build a <code>ProductIndexPage</code> component. We’ll loop<a id="_idIndexMarker276" class="pcalibre1 calibre6 pcalibre"/> through each product<a id="_idIndexMarker277" class="pcalibre1 calibre6 pcalibre"/> from <code>props.products</code> and render them in an unordered list. Each item will include a link to the <code>/products/[id]</code> page (which doesn’t exist yet):</p>
<pre class="source-code">
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';
export default function ProductIndexPage({ products }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Products&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div&gt;
        &lt;h2&gt;Products&lt;/h2&gt;
        &lt;ul&gt;
          {products.map((product) =&gt; {
            return (
              &lt;li key={product.id}&gt;
                &lt;Link
                  href={{
                    pathname: '/products/[id]',
                    query: { id: product.id },
                  }}
                &gt;
                  {product.title}
                &lt;/Link&gt;
              &lt;/li&gt;
            );
          })}
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}
// no change to getStaticProps</pre> <p class="calibre3">This page will now be built<a id="_idIndexMarker278" class="pcalibre1 calibre6 pcalibre"/> when <code>next build</code> is run. As we can see<a id="_idIndexMarker279" class="pcalibre1 calibre6 pcalibre"/> from the output, the <code>/products</code> page is marked as <code>SSG</code> (static site generation):</p>
<pre class="console">
info  - Linting and checking validity of types...
info  - Creating an optimized production build...
info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (4/4)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      464 B          75.9 kB
├ ○ /404                                   182 B          73.2 kB
└ ● /products                              426 B          75.9 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)</pre> <p class="calibre3">When we start the Next.js server<a id="_idIndexMarker280" class="pcalibre1 calibre6 pcalibre"/> with <code>next start</code> and navigate to <code>/products</code>, we see<a id="_idIndexMarker281" class="pcalibre1 calibre6 pcalibre"/> the following. Note that the products on the page won’t change unless we rebuild the application.</p>
<div><div><img alt="Figure 5.9: The Products list page is statically pre-rendered with products from fakestoreapi.com" src="img/B19109_05_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.9: The Products list page is statically pre-rendered with products from fakestoreapi.com</p>
<p class="calibre3">We’ve seen how to use <code>getStaticProps</code> to generate pages based<a id="_idIndexMarker282" class="pcalibre1 calibre6 pcalibre"/> on a third-party API, but how would we generate<a id="_idIndexMarker283" class="pcalibre1 calibre6 pcalibre"/> the <code>/products/[id]</code> pages ahead of them being requested? To do that, we need to be able to provide the “required paths” (or URLs) that Next.js needs to generate. This is w<a id="_idTextAnchor189" class="pcalibre1 calibre6 pcalibre"/>hat we’ll look at in the following section.</p>
<h1 id="_idParaDest-99" class="calibre5"><a id="_idTextAnchor190" class="pcalibre1 calibre6 pcalibre"/>Static generation with dynamic paths</h1>
<p class="calibre3">It can be useful to pre-generate<a id="_idIndexMarker284" class="pcalibre1 calibre6 pcalibre"/> pages with dynamic paths<a id="_idIndexMarker285" class="pcalibre1 calibre6 pcalibre"/> and contents.</p>
<p class="calibre3">We could use <code>getServerSideProps</code> and render the pages on demand. In the context that we’re working in, that would be valid for a “cart” page.</p>
<p class="calibre3"><code>getServerSideProps</code> is server-side rendering, as we’ve seen previously. The reason a cart page should probably be server-rendered is that it can change very quickly, based on end user interaction. An example of a page that is dynamic but wouldn’t change quickly based on an end user action is a “view single product” page. We’ll see how to statically generate that after the cart page example.</p>
<p class="calibre3">We create a <code>pages/cart.js</code> file, where we provide the following <code>getServerSideProps</code>, which loads the cart, figures out the relevant product IDs (per cart content), and loads them (in order to display some information about them):</p>
<pre class="source-code">
export async function getServerSideProps({ query }) {
  const { cartId = 1 } = query;
  const cart = await fetch(`https://fakestoreapi.com/carts/${cartId}`).then(
    (res) =&gt; res.json()
  );
  const productsById = (
    await Promise.all(
      cart.products.map(async (product) =&gt; {
        return await fetch(
          `https://fakestoreapi.com/products/
            ${product.productId}`
        ).then((res) =&gt; res.json());
      })
    )
  ).reduce((acc, curr) =&gt; {
    acc[curr.id] = curr;
    return acc;
  }, {});
  return {
    props: {
      cart,
      productsById,
    },
  };
}</pre> <p class="calibre3">We can then build a page component<a id="_idIndexMarker286" class="pcalibre1 calibre6 pcalibre"/> and make it the default export. In the component, we loop<a id="_idIndexMarker287" class="pcalibre1 calibre6 pcalibre"/> through the cart products, rendering some count information and some product information, based on <code>props.productsById</code>:</p>
<pre class="source-code">
import Head from 'next/head';
import React from 'react';
export default function CartPage({ cart, productsById }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Cart Page&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div&gt;
        &lt;ul&gt;
          {cart.products.map((product) =&gt; {
            return (
              &lt;li key={product.productId}&gt;
                {product.quantity} x {productsById
                  [product.productId]?.title}
              &lt;/li&gt;
            );
          })}
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">We know this is a server-side rendered page<a id="_idIndexMarker288" class="pcalibre1 calibre6 pcalibre"/> because when we run <code>next build</code>, it gets marked<a id="_idIndexMarker289" class="pcalibre1 calibre6 pcalibre"/> as such (and doesn’t increase the <code>Generating static </code><code>pages</code> count):</p>
<pre class="source-code">
npx next build
info  - Linting and checking validity of types
info  - Creating an optimized production build
info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (4/4)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      464 B          75.9 kB
├ ○ /404                                   182 B          73.2 kB
├ λ /cart                                  445 B          73.5 kB
└ ● /products                              426 B          75.9 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
λ  (Server)  server-side renders at runtime (uses
  getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no
  initial props)
●  (SSG)     automatically generated as static HTML + JSON
   (uses getStaticProps)</pre> <p class="calibre3">We can load the <code>/carts</code> page<a id="_idIndexMarker290" class="pcalibre1 calibre6 pcalibre"/> with a <code>?cartId=1</code> query param<a id="_idIndexMarker291" class="pcalibre1 calibre6 pcalibre"/> and see Cart 1.</p>
<div><div><img alt="Figure 5.10: The cart page with Cart 1 loaded and contents displaying" src="img/B19109_05_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.10: The cart page with Cart 1 loaded and contents displaying</p>
<p class="calibre3">We can also load the <code>/carts</code> page with <code>cartId=3</code> query param and see Cart 3.</p>
<div><div><img alt="Figure 5.11: Cart page with Cart 3 loaded and contents displaying" src="img/B19109_05_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.11: Cart page with Cart 3 loaded and contents displaying</p>
<p class="calibre3">We’ve now seen how to render the cart page on demand; a page that we mentioned is a good fit for build-time pre-rendering (i.e., static site generation) is the <code>products/[id]</code> page. In order to render this page, we need to provide the “paths” that Next.js needs to attempt to pre-render, since <code>[id]</code> is dynamic.</p>
<p class="calibre3">The following diagram shows how <code>getStaticPaths</code> and <code>getStaticProps</code> interact with each other. In short, <code>getStaticPaths</code> returns a list of “paths”; <code>getStaticProps</code> is then called on each item in that list of paths and can make the relevant I/O calls to provide the page’s props.</p>
<div><div><img alt="Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths and getStaticProps" src="img/B19109_05_12a.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths and getStaticProps</p>
<div><div><img alt="Figure 5.13: Sequence of a request to a pre-rendered Next.js app" src="img/B19109_05_12b.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.13: Sequence of a request to a pre-rendered Next.js app</p>
<p class="calibre3">In our sample Next.js<a id="_idIndexMarker292" class="pcalibre1 calibre6 pcalibre"/> app, we can create a <code>pages/products/[id].js</code> file with<a id="_idIndexMarker293" class="pcalibre1 calibre6 pcalibre"/> the following <code>getStaticPaths</code> and <code>getStaticProps</code> functions:</p>
<pre class="source-code">
export async function getStaticPaths() {
  const products = await fetch('https://fakestoreapi.com/
    products')
    .then((res) =&gt; res.json())
    .then((json) =&gt; json);
  const paths = products.map((product) =&gt; ({
    params: { id: String(product.id) },
  }));
  return { paths, fallback: false };
}</pre> <p class="calibre3">One quirk of the <code>paths</code> generation<a id="_idIndexMarker294" class="pcalibre1 calibre6 pcalibre"/> is that we’re converting <code>product.id</code> from a number<a id="_idIndexMarker295" class="pcalibre1 calibre6 pcalibre"/> to a string, since the <code>[id]</code> path parameter needs to be a string. Next.js would error with <code>Error: A required parameter (id) was not provided as a string received number in getStaticPaths for /</code><code>products/[id]</code> otherwise.</p>
<p class="calibre3"><code>getStaticProps</code> takes the <code>params</code> object, which is contained in the objects returned from <code>getStaticPaths</code>, and makes further <code>fetch</code> calls to load the product by ID. Finally, it returns <code>product</code> for the <code>Page</code> component to use:</p>
<pre class="source-code">
export async function getStaticProps({ params }) {
  const product = await fetch(
    `https://fakestoreapi.com/products/${params.id}`
  ).then((res) =&gt; res.json());
  return {
    props: {
      product,
    },
  };
}</pre> <p class="calibre3">Our <code>ProductPage</code> component can then look like the following, where we use <code>product.title</code> both as the title of the page and as the page’s <code>h2</code> element content. From here, we could display<a id="_idIndexMarker296" class="pcalibre1 calibre6 pcalibre"/> anything contained<a id="_idIndexMarker297" class="pcalibre1 calibre6 pcalibre"/> in the product response, including price and stock information and images:</p>
<pre class="source-code">
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';
export default function ProductPage({ product }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;{product.title}&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div&gt;
        &lt;Link href={'/products'}&gt;Back&lt;/Link&gt;
        &lt;h2&gt;{product.title}&lt;/h2&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">When we run <code>next build</code>, the build will take longer, since each <code>products/[id]</code> page needs to make a request to <code>fakestoreapi.com</code>. Note that the <code>products/[id]</code> pages are marked as <code>SSG</code>. We also see the number of static pages being generated increasing<a id="_idIndexMarker298" class="pcalibre1 calibre6 pcalibre"/> to 24 and a truncated subset<a id="_idIndexMarker299" class="pcalibre1 calibre6 pcalibre"/> of <code>products/[id]</code> pages:</p>
<pre class="console">
npx next build
info  - Linting and checking validity of types
info  - Creating an optimized production build
info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (24/24)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      464 B          75.9 kB
├ ○ /404                                   182 B          73.2 kB
├ λ /cart                                  445 B          73.5 kB
├ ● /products                              426 B          75.9 kB
└ ● /products/[id]                         383 B          75.9 kB
    ├ /products/1
    ├ /products/2
    ├ /products/3
    └ [+17 more paths]
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)</pre> <p class="calibre3">After building and starting<a id="_idIndexMarker300" class="pcalibre1 calibre6 pcalibre"/> the server with <code>next start</code>, when we load<a id="_idIndexMarker301" class="pcalibre1 calibre6 pcalibre"/> the <code>/products/1</code> path, we see product 1’s name.</p>
<div><div><img alt="Figure 5.14: /products/1 content" src="img/B19109_05_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.14: /products/1 content</p>
<p class="calibre3">And when we load the <code>/products/8</code> path, we see product 8’s name.</p>
<div><div><img alt="Figure 5.15: /products/8 content" src="img/B19109_05_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.15: /products/8 content</p>
<p class="calibre3">We’ve now seen how to leverage Next.js features that automatically statically render pages with no data fetching, <code>getStaticProps</code> and <code>getStaticPaths</code> to render pages with dynamic content and with dynamic paths<a id="_idIndexMarker302" class="pcalibre1 calibre6 pcalibre"/> at build time, as well as how these approaches<a id="_idIndexMarker303" class="pcalibre1 calibre6 pcalibre"/> contrast with <code>getServerSideProps</code>.</p>
<p class="calibre3">Next, we’ll deep-dive into ho<a id="_idTextAnchor191" class="pcalibre1 calibre6 pcalibre"/>w to rehydrate a server-rendered react page on the client.</p>
<h1 id="_idParaDest-100" class="calibre5"><a id="_idTextAnchor192" class="pcalibre1 calibre6 pcalibre"/>Page hydration strategies</h1>
<p class="calibre3">As we’ve seen in the first section<a id="_idIndexMarker304" class="pcalibre1 calibre6 pcalibre"/> of the chapter, react provides primitives to render applications on the server and the client. However, we only looked at examples where we did exclusively client or server rendering. One key feature of React frameworks such as Next.js is that they allow you to seamlessly switch between static, client, and server rendering. We’ll look at how to achieve this using React primitives.</p>
<div><div><img alt="Figure 5.16: A sequence diagram for a server-rendered page that is subsequently rehydrated on the client" src="img/B19109_05_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.16: A sequence diagram for a server-rendered page that is subsequently rehydrated on the client</p>
<p class="calibre3">We’ll start by extending our React <a id="_idIndexMarker305" class="pcalibre1 calibre6 pcalibre"/>client/server rendering <code>app.jsx</code> with a <code>ClientCounter</code> component. Event handlers are one of the simplest ways to observe interactivity primitives. Our <code>ClientCounter</code> component displays a counter that initializes with <code>0</code>, and on every click of the <code>src/client-counter.jsx</code> file:</p>
<pre class="source-code">
import React, { useState } from 'react';
export function ClientCounter() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      Dynamic Counter, count: {count}
      &lt;br /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Add&lt;/button&gt;
    &lt;/div&gt;
  );
}</pre> <p class="calibre3">We can render<a id="_idIndexMarker306" class="pcalibre1 calibre6 pcalibre"/> it in our <code>app.jsx</code> component, like so:</p>
<pre class="source-code">
import React from 'react';
import { ClientCounter } from './client-counter';
export function App({ type = '' }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
        &lt;ClientCounter /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">If we build the client-side entry point and load it in the browser, it works correctly, incrementing on each <strong class="bold">Add</strong> click:</p>
<pre class="console">
npx esbuild client.jsx --bundle --outdir=dist</pre> <p class="calibre3">If we open the <code>index.html</code> file (which is unchanged), we’ll be able to see the counter and increment it, as shown<a id="_idIndexMarker307" class="pcalibre1 calibre6 pcalibre"/> in the following screenshot.</p>
<div><div><img alt="Figure 5.17: The React client-side rendered counter with an increment of 7 displayed" src="img/B19109_05_16.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.17: The React client-side rendered counter with an increment of 7 displayed</p>
<p class="calibre3">However, if we build and run our server-side entry point, the component remains at 0:</p>
<pre class="console">
npx esbuild server.js --bundle --platform=node --outdir=dist</pre> <p class="calibre3">We can then start the server using the following:</p>
<pre class="console">
node dist/server.js</pre> <p class="calibre3">As the following screenshot shows, no matter how many times we click <strong class="bold">Add</strong>, the component only ever displays <strong class="bold">0</strong>.</p>
<div><div><img alt="Figure 5.18: React server-rendering does not allow for interactive counter component, the count shows 0 despite multiple Add button clicks" src="img/B19109_05_17.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.18: React server-rendering does not allow for interactive counter component, the count shows 0 despite multiple Add button clicks</p>
<p class="calibre3">In order to “hydrate” our server-rendered<a id="_idIndexMarker308" class="pcalibre1 calibre6 pcalibre"/> page, we can create a new entry point, <code>rehydrate.jsx</code>. This uses <code>react-dom/client</code>’s <code>hydrateRoot</code> function on the element that contains our app:</p>
<pre class="source-code">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './src/app';
ReactDOM.hydrateRoot(
  document.querySelector('#app'),
  &lt;App type={`"server render"`} /&gt;
);</pre> <p class="calibre3">We’ll bundle the rehydration entry point using <code>esbuild</code>, in a similar fashion to previous entry points:</p>
<pre class="console">
npx esbuild rehydrate.jsx --bundle --outdir=dist</pre> <p class="calibre3">Once our new <code>dist/rehydrate.js</code> file is built, we need<a id="_idIndexMarker309" class="pcalibre1 calibre6 pcalibre"/> to use it in our server-rendered app. We modify <code>server.js</code> to statically serve <code>dist</code>, which means that <code>dist/rehydrate.js</code> is available as <code>rehydrate.js</code>. We then create a new <code>GET</code> route, <code>/rehydrate</code>. This route returns the navigation elements seen previously, but now the application also has a script that will load <code>rehydrate.js</code>:</p>
<pre class="source-code">
// no changes to other routes
app.use(express.static('./dist'));
app.get('/rehydrate', (_req, res) =&gt; {
  res.send(`
    &lt;!DOCTYPE html&gt;
    ${renderNav()}
    &lt;h1&gt;Server-render with client-side rehydration&lt;/h1&gt;
    &lt;div id="app"&gt;${serverRenderApp()}&lt;/div&gt;
    &lt;script src="img/rehydrate.js"&gt;&lt;/script&gt;
  `);
});
// no changes to server startup</pre> <p class="calibre3">We also include <code>/rehydrate</code> in the <code>nav.jsx</code>, which now looks as follows:</p>
<pre class="source-code">
import React from 'react';
export function Nav() {
  return (
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href="/"&gt;Server-render only&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/rehydrate"&gt;Server-render with client-side
          rehydration&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</pre> <p class="calibre3">We can then rebuild our entry points <a id="_idIndexMarker310" class="pcalibre1 calibre6 pcalibre"/>and start the server. When we navigate to <code>/rehydrate</code>, the counter is interactive, and we see the navigation and <code>h1</code> as rendered server-side.</p>
<div><div><img alt="Figure 5.19: The rehydrated server-rendered application allows the interactive u﻿se of a client-side counter, displayed here with a count of 5" src="img/B19109_05_18.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.19: The rehydrated server-rendered application allows the interactive u<a id="_idTextAnchor193" class="pcalibre1 calibre6 pcalibre"/>se of a client-side counter, displayed here with a count of 5</p>
<p class="calibre3">We’ve now seen how to rehydrate<a id="_idIndexMarker311" class="pcalibre1 calibre6 pcalibre"/> a server-rendered React application, next we’ll delve into common React rehydration issues.</p>
<h2 id="_idParaDest-101" class="calibre7"><a id="_idTextAnchor194" class="pcalibre1 calibre6 pcalibre"/>Common React rehydration issues</h2>
<p class="calibre3">Rehydration has some<a id="_idIndexMarker312" class="pcalibre1 calibre6 pcalibre"/> key gotchas.</p>
<p class="calibre3">It’s quite common to see the following runtime environment detection code in an application.</p>
<pre class="source-code">
export const isServer = () =&gt; typeof window ===
  'undefined';</pre> <p class="calibre3">Let’s say we placed <code>isServer</code> in a <code>src/rendering-utils.js</code> file; we can use it as follows to conditionally<a id="_idIndexMarker313" class="pcalibre1 calibre6 pcalibre"/> render content such as <code>'from client'</code> or <code>'not from client'</code>, or avoid rendering <code>ClientCounter</code> altogether when server-rendering:</p>
<pre class="source-code">
import React from 'react';
import { ClientCounter } from './client-counter';
import { isServer } from './rendering-utils';
export function App({ type = '' }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
        &lt;p&gt;Rendering: {isServer() ? 'not from client' :
           'from client'}&lt;/p&gt;
        {!isServer() &amp;&amp; &lt;ClientCounter /&gt;}
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">This works fine in the purely server-rendered use case, where we display <code>'not from client'</code> and hide <code>ClientCounter</code>.</p>
<div><div><img alt="Figure 5.20: isServer detection working successfully for server-side-only rendering" src="img/B19109_05_19.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.20: isServer detection working successfully for server-side-only rendering</p>
<p class="calibre3">At first glance, it looks to be working<a id="_idIndexMarker314" class="pcalibre1 calibre6 pcalibre"/> for the server-render followed by client-side rehydration use case. It displays <strong class="bold">from client</strong> and shows the client-side counter component.</p>
<div><div><img alt="Figure 5.21: isServer detection looking to work for server-side rendering followed rehydration" src="img/B19109_05_20.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.21: isServer detection looking to work for server-side rendering followed rehydration</p>
<p class="calibre3">However, if we look<a id="_idIndexMarker315" class="pcalibre1 calibre6 pcalibre"/> at the console, we can see that we have some errors.</p>
<div><div><img alt="Figure 5.22: Console errors during rehydration" src="img/B19109_05_21.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.22: Console errors during rehydration</p>
<p class="calibre3">The issue is client render versus server render<a id="_idIndexMarker316" class="pcalibre1 calibre6 pcalibre"/> mismatches – for example, <code>ReactDOM.rehydrateRoot</code> expects the application to render the same way on the server and the client. React, in this situation, falls back to full client-side rendering (<strong class="bold">An error occurred during hydration. The server HTML was replaced with client content in &lt;div&gt;.</strong>), meaning the server-rendered HTML is completely thrown away.</p>
<p class="calibre3">To fix this, a better detection of server versus client is required. A simple detection would involve a hook using <code>useEffect</code>. The <code>useClientRenderingOnly</code> function will always be <code>false</code> until the application runs our <code>useEffect</code>, which is only run client-side:</p>
<pre class="source-code">
export function useClientRenderingOnly() {
  const [hasMounted, setHasMounted] = useState(false);
  useEffect(() =&gt; {
    setHasMounted(true);
  });
  return hasMounted;
}</pre> <p class="calibre3">It can be used<a id="_idIndexMarker317" class="pcalibre1 calibre6 pcalibre"/> as follows in <code>src/client-counter.jsx</code> instead of <code>isServer</code> in <code>app.jsx</code>:</p>
<pre class="source-code">
import React, { useState } from 'react';
import { useClientRenderingOnly } from './rendering-utils';
export function ClientCounter() {
  const isClientRendering = useClientRenderingOnly();
  const [count, setCount] = useState(0);
  if (!isClientRendering) return null;
  // no change to JSX return
}</pre> <p class="calibre3"><code>app.jsx</code> can become the following, leveraging <code>isClientRendering</code> to display <code>'from client'</code> and <code>'not </code><code>from client'</code>:</p>
<pre class="source-code">
import React from 'react';
import { ClientCounter } from './client-counter';
import { isClientRendering } from './rendering-utils';
export function App({ type = '' }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
        &lt;p&gt;
          Rendering: {isClientRendering ? 'from client' :
            'not from client'}
        &lt;/p&gt;
        &lt;ClientCounter /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">In the server-rendering-only case, this works, and in the rehydration case, we now know whether to display something on the server or client without getting rehydration issues.</p>
<p class="calibre3">Other common issues that cause rehydration errors are invalid markup (some HTML tags are not supposed to be inside other HTML tags).</p>
<p class="calibre3">React provides one more rendering approach<a id="_idIndexMarker318" class="pcalibre1 calibre6 pcalibre"/> that allows the s<a id="_idTextAnchor195" class="pcalibre1 calibre6 pcalibre"/>erver to start returning data to the client earlier via streaming.</p>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor196" class="pcalibre1 calibre6 pcalibre"/>React streaming server-side rendering</h2>
<p class="calibre3">React streaming server-side rendering<a id="_idIndexMarker319" class="pcalibre1 calibre6 pcalibre"/> leverages streaming so that the server can start return data to the browser earlier (chunks in a stream instead of a one-off response). This also means that the browser can start working on rendering earlier.</p>
<p class="calibre3">There’s a major caveat to streaming, which is that one of its key advantages over non-streaming server-rendering is that it has support for the new suspense primitive. This primitive is supported by specific libraries and frameworks and is quite difficult to illustrate using React primitives.</p>
<p class="calibre3">According to the React documentation<a id="_idIndexMarker320" class="pcalibre1 calibre6 pcalibre"/> on suspense usage (<a href="https://react.dev/reference/react/Suspense#usage" class="pcalibre1 calibre6 pcalibre">https://react.dev/reference/react/Suspense#usage</a>):</p>
<p class="author-quote">Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.</p>
<p class="calibre3">When rehydrating a React streaming server rendered page, we need to replace the whole document, so we’ll create a new <code>&lt;Page&gt;</code> component, which will be a full page. We’ll also create a <code>streaming-rehydrate.jsx</code> entry point for use client-side.</p>
<p class="calibre3">The following are the contents<a id="_idIndexMarker321" class="pcalibre1 calibre6 pcalibre"/> of a new <code>src/page.jsx</code> file. The full page including <code>html</code> and <code>head</code> are necessary to do streaming server-side rendering:</p>
<pre class="source-code">
import React from 'react';
import { App } from './app';
import { Nav } from './nav';
export default function Page() {
  return (
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Streaming&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;Nav /&gt;
        &lt;h1&gt;Server-render with streaming&lt;/h1&gt;
        &lt;div id="app"&gt;
          &lt;App type={`"streaming server render"`} /&gt;
        &lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</pre> <p class="calibre3">Our <code>streaming-rehydrate.jsx</code> entry point<a id="_idIndexMarker322" class="pcalibre1 calibre6 pcalibre"/> is quite similar to our <code>rehydrate.jsx</code> entry point with the exception that it hydrates <code>document</code>, instead of an element with the <code>app</code> ID. This is due to the aforementioned limitation of streaming server-side rendering – the whole document has to be controlled by React:</p>
<pre class="source-code">
import React from 'react';
import ReactDOM from 'react-dom/client';
import Page from './src/page';
ReactDOM.hydrateRoot(document, &lt;Page /&gt;);;</pre> <p class="calibre3">We’ll build the entry point to JavaScript using the following:</p>
<pre class="console">
npx esbuild streaming-rehydrate.jsx.jsx --bundle --outdir=dist</pre> <p class="calibre3">We can now start working on the server rendering in <code>src/server-rendering.jsx</code>. We create a new <code>serverRenderAppStream</code> function that takes an Express/Node.js <code>res</code> object as a parameter. It calls <code>ReactDOMServer.renderToPipeableStream</code> with the <code>Page</code> component, and with <code>bootstrapScripts</code> set to include our <code>streaming-rehydrate.js</code> entry point:</p>
<pre class="source-code">
import React from 'react';
import ReactDOMServer from 'react-dom/server';
// no changes to other imports
import Page from './page';
export function serverRenderAppStream(res) {
  const { pipe } = ReactDOMServer.renderToPipeableStream
    (&lt;Page /&gt;, {
    bootstrapScripts: ['./streaming-rehydrate.js'],
  });
  pipe(res);
}</pre> <p class="calibre3">In <code>server.js</code>, we can create<a id="_idIndexMarker323" class="pcalibre1 calibre6 pcalibre"/> a new <code>GET</code> route for the <code>/streaming</code> path, which simply calls <code>serverRenderAppStream</code> with the <code>res</code> object per the Express route handler definition:</p>
<pre class="source-code">
// no change to other imports
import {
  // no change to other imports
  serverRenderAppStream,
} from './src/server-render';
// no change to other routes
app.get('/streaming', (_req, res) =&gt; {
  serverRenderAppStream(res);
});
// no change to startup logic</pre> <p class="calibre3">We’ll also add the <code>/streaming</code> route to <code>src/nav.jsx</code>:</p>
<pre class="source-code">
import React from 'react';
export function Nav() {
  return (
    &lt;ul&gt;
      {/* no change to the other li elements */}
      &lt;li&gt;
        &lt;a href="/streaming"&gt;Server-render with streaming
          &lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</pre> <p class="calibre3">We can now load the <code>/streaming</code> page and see<a id="_idIndexMarker324" class="pcalibre1 calibre6 pcalibre"/> it in action.</p>
<div><div><img alt="Figure 5.23: React streaming server rendering with rehydration" src="img/B19109_05_22.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.23: React streaming server rendering with rehydration</p>
<p class="calibre3">We’ve now s<a id="_idTextAnchor197" class="pcalibre1 calibre6 pcalibre"/>een how to implement<a id="_idIndexMarker325" class="pcalibre1 calibre6 pcalibre"/> React streaming server rendering with rehydration.</p>
<h1 id="_idParaDest-103" class="calibre5"><a id="_idTextAnchor198" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we covered how a deeper understanding of rendering and page hydration strategies can help us deliver optimal and scalable web user interfaces with React.</p>
<p class="calibre3">Client and server rendering have benefits and drawbacks that are complimentary to each other. Client rendering takes longer to start up but provides more interactivity and doesn’t require as much server-side computer power; server rendering can return content faster but requires infrastructure and doesn’t provide the same level of interactivity.</p>
<p class="calibre3">The static site generation functionality of Next.js can be leveraged alongside classic server rendering to judiciously decide on a rendering strategy for a given set of pages, based on the access pattern and how often the content changes.</p>
<p class="calibre3">Finally, page hydration and rehydration alongside streaming server-side rendering bridges the gap between server and client rendering, allowing the benefits of both to be included in one page.</p>
<p class="calibre3">Now that we’re familiar with rendering and page hydration strategies, we can look at implementing micro-frontends using both the “zones” and “islands” architectures in the next chapter.</p>
</div>
</body></html>