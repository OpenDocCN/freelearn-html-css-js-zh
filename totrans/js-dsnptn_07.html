<html><head></head><body>
<div id="_idContainer064" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor173" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-90" class="calibre5"><a id="_idTextAnchor174" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Rendering Strategies and Page Hydration</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Rendering strategies and page hydration approaches allow us to leverage the JavaScript client and server ecosystem to serve performant and scalable web applications, depending on the needs of our end users. </span><span class="kobospan" id="kobo.3.2">The React and JavaScript techniques covered in this chapter are another set of tools to augment the </span><a href="B19109_04.xhtml#_idTextAnchor130" class="pcalibre1 calibre6 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.4.1">Chapter 4</span></em></span></a><span class="kobospan" id="kobo.5.1"> chapter. </span><span class="kobospan" id="kobo.5.2">We’ll use the strengths of the client (browser) and server (specifically, Node.js) runtimes to deliver fast and scalable React websites </span><span><span class="kobospan" id="kobo.6.1">to users.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">In this chapter, we’ll cover the </span><span><span class="kobospan" id="kobo.8.1">following topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.9.1">What the trade-offs are between client and server rendering of React applications by implementing pure client and server </span><span><span class="kobospan" id="kobo.10.1">rendering applications</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">The types of advantages that frameworks such as Next.js can bring with static site generation functionality, alongside </span><span><span class="kobospan" id="kobo.12.1">server-side rendering</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Bridging the client-server rendering gap with a React page rehydration example and </span><span><span class="kobospan" id="kobo.14.1">its gotchas</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.15.1">Streaming server rendering </span><span><span class="kobospan" id="kobo.16.1">in React</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.17.1">By the end of this chapter, you’ll be able to select appropriate rendering and page hydration strategies with React and be able to implement framework-level functionality, enabling you to make better </span><span><span class="kobospan" id="kobo.18.1">technology choices.</span></span></p>
<h1 id="_idParaDest-91" class="calibre5"><a id="_idTextAnchor175" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.19.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.20.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.22.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<h1 id="_idParaDest-92" class="calibre5"><a id="_idTextAnchor176" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.23.1">Client and server rendering with React</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">In a web context, client-side rendering</span><a id="_idIndexMarker231" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.25.1"> is the process by which JavaScript</span><a id="_idIndexMarker232" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.26.1"> is used inside a user’s browser to generate</span><a id="_idIndexMarker233" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.27.1"> or update the page</span><a id="_idIndexMarker234" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.28.1"> contents. </span><span class="kobospan" id="kobo.28.2">A fully client-side-rendered application will only display meaningful content when the relevant JavaScript code has completed downloading, parsing, </span><span><span class="kobospan" id="kobo.29.1">and running.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">In the following sequence diagram, we use the term “origin” instead of something such as “server,” since one benefit of full client-side rendering is that</span><a id="_idIndexMarker235" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.31.1"> the resources “serving” our content can be what’s called </span><em class="italic"><span class="kobospan" id="kobo.32.1">static hosting</span></em><span class="kobospan" id="kobo.33.1">. </span><span class="kobospan" id="kobo.33.2">This includes services such as </span><strong class="bold"><span class="kobospan" id="kobo.34.1">AWS Simple Storage Service</span></strong><span class="kobospan" id="kobo.35.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.36.1">S3</span></strong><span class="kobospan" id="kobo.37.1">), Netlify, Cloudflare Pages, and GitHub</span><a id="_idIndexMarker236" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.38.1"> Pages, among others. </span><span class="kobospan" id="kobo.38.2">There’s no dynamic server-side component in </span><span><span class="kobospan" id="kobo.39.1">these services.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer041">
<span class="kobospan" id="kobo.40.1"><img alt="Figure 5.1: A client-side-rendering sequence diagram" src="image/B19109_05_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.41.1">Figure 5.1: A client-side-rendering sequence diagram</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">In contrast, server-side</span><a id="_idIndexMarker237" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.43.1"> rendering</span><a id="_idIndexMarker238" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.44.1"> denotes the process by which a server</span><a id="_idIndexMarker239" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.45.1"> generates a full HTML document when a browser </span><a id="_idIndexMarker240" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.46.1">requests it and </span><span><span class="kobospan" id="kobo.47.1">returns it.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer042">
<span class="kobospan" id="kobo.48.1"><img alt="Figure 5.2: A server-side-rendering sequence ﻿diagram" src="image/B19109_05_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.49.1">Figure 5.2: A server-side-rendering sequence </span><a id="_idTextAnchor177" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.50.1">diagram</span></p>
<h2 id="_idParaDest-93" class="calibre7"><a id="_idTextAnchor178" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.51.1">Client-side rendering in React</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.52.1">Client rendering</span><a id="_idIndexMarker241" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.53.1"> is the default rendering </span><a id="_idIndexMarker242" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.54.1">method with React. </span><span class="kobospan" id="kobo.54.2">Let’s build an application that renders client-side </span><span><span class="kobospan" id="kobo.55.1">from scratch:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.56.1">We start with an </span><strong class="source-inline1"><span class="kobospan" id="kobo.57.1">App</span></strong><span class="kobospan" id="kobo.58.1"> component that renders some text and its </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.59.1">type</span></strong></span><span><span class="kobospan" id="kobo.60.1"> prop:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.61.1">
export function App({ type = '' }) {
  return (
    &lt;div&gt;
      &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
    &lt;/div&gt;
  );
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.62.1">We then create an entry point file, </span><strong class="source-inline1"><span class="kobospan" id="kobo.63.1">client.jsx</span></strong><span class="kobospan" id="kobo.64.1">, which imports the app and uses </span><strong class="source-inline1"><span class="kobospan" id="kobo.65.1">ReactDOM</span></strong><span class="kobospan" id="kobo.66.1"> to render it, with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.67.1">type</span></strong><span class="kobospan" id="kobo.68.1"> prop set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.69.1">"</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.70.1">client render"</span></strong></span><span><span class="kobospan" id="kobo.71.1">.</span></span><pre class="source-code"><span class="kobospan1" id="kobo.72.1">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './src/app';
ReactDOM.createRoot(document.querySelector
  ('#app')).render(
  &lt;App type={`"client render"`} /&gt;
);</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.73.1">In order for this example</span><a id="_idIndexMarker243" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.74.1"> to run, we need an HTML document</span><a id="_idIndexMarker244" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.75.1"> that allows </span><strong class="source-inline1"><span class="kobospan" id="kobo.76.1">ReactDOM.createRoot</span></strong><span class="kobospan" id="kobo.77.1"> to run successfully. </span><span class="kobospan" id="kobo.77.2">In other words, we need an HTML document that has an element with </span><strong class="source-inline1"><span class="kobospan" id="kobo.78.1">id=app</span></strong><span class="kobospan" id="kobo.79.1"> and references our </span><span><span class="kobospan" id="kobo.80.1">entry point:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.81.1">
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script src="./dist/client.js"&gt;&lt;/script&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.82.1">Note that the entry point is </span><strong class="source-inline1"><span class="kobospan" id="kobo.83.1">dist/client.js</span></strong><span class="kobospan" id="kobo.84.1"> instead of </span><strong class="source-inline1"><span class="kobospan" id="kobo.85.1">client.jsx</span></strong><span class="kobospan" id="kobo.86.1">. </span><span class="kobospan" id="kobo.86.2">That’s due to the fact that React’s JSX syntax can’t be run natively in the browser. </span><span class="kobospan" id="kobo.86.3">Instead, we run our entry point file, </span><strong class="source-inline1"><span class="kobospan" id="kobo.87.1">client.jsx</span></strong><span class="kobospan" id="kobo.88.1">, through a compilation and bundling step using </span><strong class="source-inline1"><span class="kobospan" id="kobo.89.1">esbuild</span></strong><span class="kobospan" id="kobo.90.1">. </span><span class="kobospan" id="kobo.90.2">Our build command looks something </span><span><span class="kobospan" id="kobo.91.1">like this:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.92.1">npx esbuild client.jsx --bundle --outdir=dist</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.93.1">Now, if we load the </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">index.html</span></strong><span class="kobospan" id="kobo.95.1"> file in the browser, we see </span><span><span class="kobospan" id="kobo.96.1">the following:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer043">
<span class="kobospan" id="kobo.97.1"><img alt="Figure 5.3: Hello from the “client render” app rendered in t﻿he browser" src="image/B19109_05_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.98.1">Figure 5.3: Hello from the “client render” app rendered in t</span><a id="_idTextAnchor179" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.99.1">he browser</span></p>
<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor180" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.100.1">Server rendering in React</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">Node.js, introduced on its website</span><a id="_idIndexMarker245" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.102.1"> as “an open-source, cross-platform JavaScript</span><a id="_idIndexMarker246" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.103.1"> runtime environment,” gives us the ability to run JavaScript on a server. </span><span class="kobospan" id="kobo.103.2">A commonly used package to build servers in Node.js </span><span><span class="kobospan" id="kobo.104.1">is Express.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.105.1">In this section, we’ll see how to use Node.js and Express to server-render a </span><span><span class="kobospan" id="kobo.106.1">React application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.107.1">A simple Express server that returns </span><strong class="source-inline"><span class="kobospan" id="kobo.108.1">'Server-rendered hello'</span></strong><span class="kobospan" id="kobo.109.1"> when the root path is loaded looks </span><span><span class="kobospan" id="kobo.110.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.111.1">
import express from 'express';
const app = express();
app.get('/', (_req, res) =&gt; {
  res.send('Server-rendered hello');
});
const { PORT = 3000 } = process.env;
app.listen(PORT, () =&gt; {
  console.log(`Server started on
    http://localhost:${PORT}`);
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.112.1">Again, we’ll use </span><strong class="source-inline"><span class="kobospan" id="kobo.113.1">esbuild</span></strong><span class="kobospan" id="kobo.114.1"> to bundle and compile the JSX </span><span><span class="kobospan" id="kobo.115.1">to JavaScript:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.116.1">
npx esbuild server.js --bundle --platform=node --outdir=dist</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.117.1">We can then start the server using </span><span><span class="kobospan" id="kobo.118.1">the following:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.119.1">
node dist/server.js</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.120.1">By default, it runs on port </span><strong class="source-inline"><span class="kobospan" id="kobo.121.1">3000</span></strong><span class="kobospan" id="kobo.122.1">, but that can be overridden with </span><span><span class="kobospan" id="kobo.123.1">environment variables.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.124.1">When we load </span><strong class="source-inline"><span class="kobospan" id="kobo.125.1">localhost:3000</span></strong><span class="kobospan" id="kobo.126.1">, we see this message in </span><span><span class="kobospan" id="kobo.127.1">the browser.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer044">
<span class="kobospan" id="kobo.128.1"><img alt="Figure 5.4: Server-rendered hello rendered in the browser" src="image/B19109_05_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.129.1">Figure 5.4: Server-rendered hello rendered in the browser</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.130.1">This is a really minimal</span><a id="_idIndexMarker247" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.131.1"> example of server-rendering</span><a id="_idIndexMarker248" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.132.1"> using Node.js </span><span><span class="kobospan" id="kobo.133.1">and Express.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.134.1">Next, we’ll see how to leverage the </span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">ReactDOM</span></strong><span class="kobospan" id="kobo.136.1"> package to take React components and </span><span><span class="kobospan" id="kobo.137.1">server-render them:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.138.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.139.1">ReactDOM</span></strong><span class="kobospan" id="kobo.140.1"> package provides both a </span><strong class="source-inline1"><span class="kobospan" id="kobo.141.1">react-dom/client</span></strong><span class="kobospan" id="kobo.142.1"> entry point (which we used in the previous section) and a </span><strong class="source-inline1"><span class="kobospan" id="kobo.143.1">react-dom/server</span></strong><span class="kobospan" id="kobo.144.1"> entry point. </span><span class="kobospan" id="kobo.144.2">As the names allude to, the client entry point is meant to be used on the client (in the browser, “client-side” JavaScript), and the server entry point is meant to be used on the server (via Node.js or another server-side </span><span><span class="kobospan" id="kobo.145.1">JavaScript runtime).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.146.1">The two methods we’ll use are </span><strong class="source-inline1"><span class="kobospan" id="kobo.147.1">ReactDOMServer.renderToStaticMarkup</span></strong><span class="kobospan" id="kobo.148.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.149.1">ReactDOMServer.renderToString</span></strong><span class="kobospan" id="kobo.150.1">; these two methods will allow us to server-render our React application </span><span><span class="kobospan" id="kobo.151.1">to HTML.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.152.1">In a </span><strong class="source-inline1"><span class="kobospan" id="kobo.153.1">src/server-render.jsx</span></strong><span class="kobospan" id="kobo.154.1"> file, we have the following </span><strong class="source-inline1"><span class="kobospan" id="kobo.155.1">renderNav</span></strong><span class="kobospan" id="kobo.156.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.157.1">serverRenderApp</span></strong><span class="kobospan" id="kobo.158.1"> functions, which use </span><strong class="source-inline1"><span class="kobospan" id="kobo.159.1">ReactDOMServer.renderToStaticMarkup</span></strong><span class="kobospan" id="kobo.160.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">ReactDOMServer.renderToString</span></strong><span class="kobospan" id="kobo.162.1"> to render </span><strong class="source-inline1"><span class="kobospan" id="kobo.163.1">Nav</span></strong><span class="kobospan" id="kobo.164.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.165.1">App</span></strong></span><span><span class="kobospan" id="kobo.166.1">, respectively:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.167.1">
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import { App } from './app';
import { Nav } from './nav';
export function renderNav() {
  return ReactDOMServer.renderToStaticMarkup(&lt;Nav /&gt;);
}
export function serverRenderApp() {
  return ReactDOMServer.renderToString(&lt;App
    type={`"server render"`} /&gt;);
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.168.1">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.169.1">app.jsx</span></strong><span class="kobospan" id="kobo.170.1"> is the same</span><a id="_idIndexMarker249" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.171.1"> as we had</span><a id="_idIndexMarker250" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.172.1"> in the previous section, and </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">nav.jsx</span></strong><span class="kobospan" id="kobo.174.1"> is </span><span><span class="kobospan" id="kobo.175.1">as follows:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.176.1">import React from 'react';
export function Nav() {
  return (
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href="/"&gt;Server-render only&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.177.1">We can then use </span><strong class="source-inline1"><span class="kobospan" id="kobo.178.1">renderNav</span></strong><span class="kobospan" id="kobo.179.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.180.1">serverRenderApp</span></strong><span class="kobospan" id="kobo.181.1"> in </span><strong class="source-inline1"><span class="kobospan" id="kobo.182.1">server.js</span></strong><span class="kobospan" id="kobo.183.1">. </span><span class="kobospan" id="kobo.183.2">We modify the </span><strong class="source-inline1"><span class="kobospan" id="kobo.184.1">app.get('/')</span></strong><span class="kobospan" id="kobo.185.1"> handler</span><a id="_idIndexMarker251" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.186.1"> to render the navigation</span><a id="_idIndexMarker252" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.187.1"> and </span><span><span class="kobospan" id="kobo.188.1">the app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.189.1">
// no other changes
app.get('/', (_req, res) =&gt; {
  res.send(`
    &lt;!DOCTYPE html&gt;
    ${renderNav()}
    &lt;h1&gt;Server-render only&lt;/h1&gt;
    &lt;div id="app"&gt;${serverRenderApp()}&lt;/div&gt;
  `);
});</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.190.1">When we rebuild the server, we run </span><strong class="source-inline1"><span class="kobospan" id="kobo.191.1">node dist/server.js</span></strong><span class="kobospan" id="kobo.192.1"> and open </span><strong class="source-inline1"><span class="kobospan" id="kobo.193.1">localhost:3000</span></strong><span class="kobospan" id="kobo.194.1"> to see </span><span><span class="kobospan" id="kobo.195.1">the following:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer045">
<span class="kobospan" id="kobo.196.1"><img alt="Figure 5.5: Hello from the “server render” app being rendered alongside a heading and the nav" src="image/B19109_05_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.197.1">Figure 5.5: Hello from the “server render” app being rendered alongside a heading and the nav</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.198.1">What’s the difference between </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">ReactDOMServer.renderToStaticMarkup</span></strong><span class="kobospan" id="kobo.200.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.201.1">ReactDOMServer.renderToString?</span></strong><span class="kobospan" id="kobo.202.1"> The short answer is that </span><strong class="source-inline"><span class="kobospan" id="kobo.203.1">renderToStaticMarkup</span></strong><span class="kobospan" id="kobo.204.1"> can’t be rehydrated client-side; in other words, it can’t be used as the initial HTML, and then</span><a id="_idIndexMarker253" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.205.1"> the same React application</span><a id="_idIndexMarker254" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.206.1"> code can be run client-side to give a fully interactive experience. </span><span class="kobospan" id="kobo.206.2">We’ll revisit this in a later secti</span><a id="_idTextAnchor181" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.207.1">on of </span><span><span class="kobospan" id="kobo.208.1">the chapter.</span></span></p>
<h2 id="_idParaDest-95" class="calibre7"><a id="_idTextAnchor182" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.209.1">Trade-offs between client and server rendering</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.210.1">So, what are the benefits</span><a id="_idIndexMarker255" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.211.1"> and drawbacks of client and </span><span><span class="kobospan" id="kobo.212.1">server rendering?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.213.1">Client rendering’s main benefit is that the application’s “work” is done fully in the user’s browsers, which makes it highly scalable since the amount of users using the system will not put pressure on the origin servers. </span><span class="kobospan" id="kobo.213.2">Client rendering’s main drawbacks relate to functionality that is only available on the server side – for example, server-side-only cookies or setting the </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">meta</span></strong><span class="kobospan" id="kobo.215.1"> tags for social </span><span><span class="kobospan" id="kobo.216.1">media preview.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.217.1">Server rendering’s main drawback is that work has to happen on the server. </span><span class="kobospan" id="kobo.217.2">As stated previously, the server being a “controlled” environment has some benefits, namely its latency to other co-located systems will tend to be lower than a full browser-server round trip, since the server’s network is known and unlikely to have as much variance in performance as an end user’s network. </span><span class="kobospan" id="kobo.217.3">By not waiting for a full-page load, followed by an asset load, followed</span><a id="_idIndexMarker256" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.218.1"> by a JavaScript “parse and execute” cascade, server-rendering</span><a id="_idIndexMarker257" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.219.1"> can improve “core web vitals”, such as </span><strong class="bold"><span class="kobospan" id="kobo.220.1">largest </span></strong><strong class="bold"><span class="kobospan" id="kobo.221.1">contentful</span></strong><strong class="bold"><span class="kobospan" id="kobo.222.1"> paint</span></strong><span class="kobospan" id="kobo.223.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.224.1">LCP</span></strong><span class="kobospan" id="kobo.225.1">) and </span><strong class="bold"><span class="kobospan" id="kobo.226.1">cumulative layout </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.227.1">shift</span></strong></span><span><span class="kobospan" id="kobo.228.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.229.1">CLS</span></strong></span><span><span class="kobospan" id="kobo.230.1">).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.231.1">Ultimately, client-rendered functionality is a key reason we use JavaScript, which means removing that ability will only make sense in constrained use cases such as content sites (e.g., blogs, news sites, and </span><span><span class="kobospan" id="kobo.232.1">documentation sites).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.233.1">We’ve now seen the difference between client</span><a id="_idIndexMarker258" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.234.1"> and server rendering, as well as how to implement both with React and Node.js. </span><span class="kobospan" id="kobo.234.2">In the following section, we’ll look at rendering approaches enabled by the Next.j</span><a id="_idTextAnchor183" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.235.1">s framework </span><span><span class="kobospan" id="kobo.236.1">for React.</span></span></p>
<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor184" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.237.1">Static rendering with Next.js</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.238.1">Next.js is a React framework</span><a id="_idIndexMarker259" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.239.1"> for creating full</span><a id="_idIndexMarker260" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.240.1"> stack web applications. </span><span class="kobospan" id="kobo.240.2">What this means is that it provides tools and opinions that will help developers be more productive in the short and </span><span><span class="kobospan" id="kobo.241.1">long term.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.242.1">Next.js includes a filesystem router for “pages”, a set of routing primitives for React, support for client and server rendering, and data fetching primitives, </span><span><span class="kobospan" id="kobo.243.1">among others.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.244.1">The features of Next.js we’ll focus on are the </span><strong class="bold"><span class="kobospan" id="kobo.245.1">static site generation</span></strong><span class="kobospan" id="kobo.246.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.247.1">SSG</span></strong><span class="kobospan" id="kobo.248.1">) ones. </span><span class="kobospan" id="kobo.248.2">This type of rendering methodology</span><a id="_idIndexMarker261" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.249.1"> resembles server rendering but mitigates some of its drawbacks, since the rendering pass is done at build time instead of at </span><span><span class="kobospan" id="kobo.250.1">request time.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer046">
<span class="kobospan" id="kobo.251.1"><img alt="Figure 5.6: A sequence diagram for a pre-rendered/static site generation use case" src="image/B19109_05_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.252.1">Figure 5.6: A sequence diagram for a pre-rendered/static site generation use case</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.253.1">Now that we’ve looked</span><a id="_idIndexMarker262" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.254.1"> at how static site generation changes the data flow when</span><a id="_idIndexMarker263" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.255.1"> a user requests a website, we’ll look at Next.js aut</span><a id="_idTextAnchor185" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.256.1">omatic </span><span><span class="kobospan" id="kobo.257.1">static generation.</span></span></p>
<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor186" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.258.1">Automatic static generation</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.259.1">In Next.js, the filesystem-based routing</span><a id="_idIndexMarker264" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.260.1"> means that each path in your web application corresponds to a file in the </span><strong class="source-inline"><span class="kobospan" id="kobo.261.1">pages</span></strong><span class="kobospan" id="kobo.262.1"> directory of your application. </span><span class="kobospan" id="kobo.262.2">For example, </span><strong class="source-inline"><span class="kobospan" id="kobo.263.1">/</span></strong><span class="kobospan" id="kobo.264.1"> corresponds </span><span><span class="kobospan" id="kobo.265.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.266.1">pages/index.js</span></strong></span><span><span class="kobospan" id="kobo.267.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.268.1">Next.js defaults to static generation when no Next.js data fetching methods are used for a given page. </span><span class="kobospan" id="kobo.268.2">You can find more information</span><a id="_idIndexMarker265" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.269.1"> from the Next.js documentation – </span><em class="italic"><span class="kobospan" id="kobo.270.1">Automatic Static </span></em><span><em class="italic"><span class="kobospan" id="kobo.271.1">Optimization</span></em></span><span><span class="kobospan" id="kobo.272.1"> (</span></span><a href="https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.273.1">https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization</span></span></a><span><span class="kobospan" id="kobo.274.1">).</span></span></p>
<p class="author-quote"><span class="kobospan" id="kobo.275.1">Next.js automatically determines that a page is static (i.e., can be prerendered) if it has no blocking data requirements. </span><span class="kobospan" id="kobo.275.2">This determination is made by the absence of getServerSideProps and getInitialProps on the page.</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.276.1">For example, the following page in a Next.js application will be statically generated, since it only exports a page</span><a id="_idIndexMarker266" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.277.1"> component (the default export of </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">Index</span></strong><span class="kobospan" id="kobo.279.1">); no </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.281.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">getInitialProps</span></strong><span class="kobospan" id="kobo.283.1"> function </span><span><span class="kobospan" id="kobo.284.1">is exported:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.285.1">
import React from 'react';
import Head from 'next/head';
import Link from 'next/link';
export default function Index() {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Next Static Rendering - Automatic Static
          Generation&lt;/title&gt;
        &lt;meta name="viewport" content="width=device-width,
          initial-scale=1" /&gt;
      &lt;/Head&gt;
      &lt;main&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;Link href="/products"&gt;Products Page (SSG)
            &lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link href="/cart"&gt;Cart Page (SSR)&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/main&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.286.1">We can see this during </span><strong class="source-inline"><span class="kobospan" id="kobo.287.1">next build</span></strong><span class="kobospan" id="kobo.288.1"> in the following</span><a id="_idIndexMarker267" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.289.1"> screenshot; </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">/ route (page)</span></strong><span class="kobospan" id="kobo.291.1"> is marked as </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">Static</span></strong><span class="kobospan" id="kobo.293.1"> in </span><span><span class="kobospan" id="kobo.294.1">the output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.295.1">
npx next build
info  - Linting and checking validity of types
info  - Creating an optimized production build
info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (3/3)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      2.73 kB        75.8 kB
└ ○ /404                                   182 B          73.2 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
○  (Static)  automatically rendered as static HTML (uses no initial props)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.296.1">When we run the built Next.js output</span><a id="_idIndexMarker268" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.297.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">next start</span></strong><span class="kobospan" id="kobo.299.1">, the page behaves </span><span><span class="kobospan" id="kobo.300.1">as expected.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer047">
<span class="kobospan" id="kobo.301.1"><img alt="Figure 5.7: Links to the Products and Cart pages rendering" src="image/B19109_05_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.302.1">Figure 5.7: Links to the Products and Cart pages rendering</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.303.1">This example is a relatively constrained use case since we have no dynamic data fetching requirements. </span><span class="kobospan" id="kobo.303.2">It still showcases Next.js defaulting to static rendering if the page does not use any functionality that excludes static generation. </span><span class="kobospan" id="kobo.303.3">For more advanced use cases, Next.js also allows use of “build-time” dynamic data, which means we can use a third-party data source to generate the page content, </span><span><span class="kobospan" id="kobo.304.1">and more.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.305.1">We’ve seen how Next.js defaults</span><a id="_idIndexMarker269" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.306.1"> to automatic static generation. </span><span class="kobospan" id="kobo.306.2">Next, we’ll see how to configure a Next.js page to load d</span><a id="_idTextAnchor187" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.307.1">ata to render a page </span><span><span class="kobospan" id="kobo.308.1">as static.</span></span></p>
<h1 id="_idParaDest-98" class="calibre5"><a id="_idTextAnchor188" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.309.1">Static generation with a third-party data source</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.310.1">Next.js has a </span><strong class="source-inline"><span class="kobospan" id="kobo.311.1">getStaticProps</span></strong><span class="kobospan" id="kobo.312.1"> data fetching method</span><a id="_idIndexMarker270" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.313.1"> that allows us to load data</span><a id="_idIndexMarker271" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.314.1"> at build time, which will be passed to </span><span><span class="kobospan" id="kobo.315.1">a page.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.316.1">The following sequence diagram illustrate what </span><span><span class="kobospan" id="kobo.317.1">this involves:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer048">
<span class="kobospan" id="kobo.318.1"><img alt="Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps" src="image/B19109_05_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.319.1">Figure 5.8: A sequence diagram of Next.js pre-rendering using getStaticProps</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.320.1">For example, if we want</span><a id="_idIndexMarker272" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.321.1"> to build a “product list” page based on </span><strong class="source-inline"><span class="kobospan" id="kobo.322.1">fakestoreapi.com</span></strong><span class="kobospan" id="kobo.323.1"> data, we can write</span><a id="_idIndexMarker273" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.324.1"> the following </span><strong class="source-inline"><span class="kobospan" id="kobo.325.1">getStaticProps</span></strong><span class="kobospan" id="kobo.326.1"> method in a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.327.1">pages/products/index.js</span></strong></span><span><span class="kobospan" id="kobo.328.1"> page:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.329.1">
export async function getStaticProps() {
  const products = await fetch
    ('https://fakestoreapi.com/products').then(
    (res) =&gt; res.json()
  );
  return {
    props: {
      products,
    },
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.330.1">Here’s a </span><strong class="source-inline"><span class="kobospan" id="kobo.331.1">product</span></strong><span class="kobospan" id="kobo.332.1"> example in the response</span><a id="_idIndexMarker274" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.333.1"> to illustrate the </span><span><span class="kobospan" id="kobo.334.1">data</span></span><span><a id="_idIndexMarker275" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.335.1"> shape:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.336.1">
{
  id: 1,
  title: 'Fjallraven - Foldsack No. </span><span class="kobospan1" id="kobo.336.2">1 Backpack, Fits 15
    Laptops',
  price: 109.95,
  description: 'Your perfect pack for everyday use and
  walks in the forest. </span><span class="kobospan1" id="kobo.336.3">Stash your laptop (up to 15 inches)
  in the padded sleeve, your everyday',
  category: "men's clothing",
  image: 'https://fakestoreapi.com/img/
    81fPKd-2AYL._AC_SL1500_.jpg',
  rating: { rate: 3.9, count: 120 }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.337.1">Based on the data provided by </span><strong class="source-inline"><span class="kobospan" id="kobo.338.1">getStaticProps</span></strong><span class="kobospan" id="kobo.339.1">, we can build a </span><strong class="source-inline"><span class="kobospan" id="kobo.340.1">ProductIndexPage</span></strong><span class="kobospan" id="kobo.341.1"> component. </span><span class="kobospan" id="kobo.341.2">We’ll loop</span><a id="_idIndexMarker276" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.342.1"> through each product</span><a id="_idIndexMarker277" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.343.1"> from </span><strong class="source-inline"><span class="kobospan" id="kobo.344.1">props.products</span></strong><span class="kobospan" id="kobo.345.1"> and render them in an unordered list. </span><span class="kobospan" id="kobo.345.2">Each item will include a link to the </span><strong class="source-inline"><span class="kobospan" id="kobo.346.1">/products/[id]</span></strong><span class="kobospan" id="kobo.347.1"> page (which doesn’t </span><span><span class="kobospan" id="kobo.348.1">exist yet):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.349.1">
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';
export default function ProductIndexPage({ products }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Products&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div&gt;
        &lt;h2&gt;Products&lt;/h2&gt;
        &lt;ul&gt;
          {products.map((product) =&gt; {
            return (
              &lt;li key={product.id}&gt;
                &lt;Link
                  href={{
                    pathname: '/products/[id]',
                    query: { id: product.id },
                  }}
                &gt;
                  {product.title}
                &lt;/Link&gt;
              &lt;/li&gt;
            );
          })}
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}
// no change to getStaticProps</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.350.1">This page will now be built</span><a id="_idIndexMarker278" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.351.1"> when </span><strong class="source-inline"><span class="kobospan" id="kobo.352.1">next build</span></strong><span class="kobospan" id="kobo.353.1"> is run. </span><span class="kobospan" id="kobo.353.2">As we can see</span><a id="_idIndexMarker279" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.354.1"> from the output, the </span><strong class="source-inline"><span class="kobospan" id="kobo.355.1">/products</span></strong><span class="kobospan" id="kobo.356.1"> page is marked as </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">SSG</span></strong><span class="kobospan" id="kobo.358.1"> (static </span><span><span class="kobospan" id="kobo.359.1">site generation):</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.360.1">
info  - Linting and checking validity of types...
</span><span class="kobospan1" id="kobo.360.2">info  - Creating an optimized production build...
</span><span class="kobospan1" id="kobo.360.3">info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (4/4)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      464 B          75.9 kB
├ ○ /404                                   182 B          73.2 kB
└ ● /products                              426 B          75.9 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.361.1">When we start the Next.js server</span><a id="_idIndexMarker280" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.362.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.363.1">next start</span></strong><span class="kobospan" id="kobo.364.1"> and navigate to </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">/products</span></strong><span class="kobospan" id="kobo.366.1">, we see</span><a id="_idIndexMarker281" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.367.1"> the following. </span><span class="kobospan" id="kobo.367.2">Note that the products on the page won’t change unless we rebuild </span><span><span class="kobospan" id="kobo.368.1">the application.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer049">
<span class="kobospan" id="kobo.369.1"><img alt="Figure 5.9: The Products list page is statically pre-rendered with products from fakestoreapi.com" src="image/B19109_05_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.370.1">Figure 5.9: The Products list page is statically pre-rendered with products from fakestoreapi.com</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.371.1">We’ve seen how to use </span><strong class="source-inline"><span class="kobospan" id="kobo.372.1">getStaticProps</span></strong><span class="kobospan" id="kobo.373.1"> to generate pages based</span><a id="_idIndexMarker282" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.374.1"> on a third-party API, but how would we generate</span><a id="_idIndexMarker283" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.375.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.376.1">/products/[id]</span></strong><span class="kobospan" id="kobo.377.1"> pages ahead of them being requested? </span><span class="kobospan" id="kobo.377.2">To do that, we need to be able to provide the “required paths” (or URLs) that Next.js needs to generate. </span><span class="kobospan" id="kobo.377.3">This is w</span><a id="_idTextAnchor189" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.378.1">hat we’ll look at in the </span><span><span class="kobospan" id="kobo.379.1">following section.</span></span></p>
<h1 id="_idParaDest-99" class="calibre5"><a id="_idTextAnchor190" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.380.1">Static generation with dynamic paths</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.381.1">It can be useful to pre-generate</span><a id="_idIndexMarker284" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.382.1"> pages with dynamic paths</span><a id="_idIndexMarker285" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.383.1">and contents.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.384.1">We could use </span><strong class="source-inline"><span class="kobospan" id="kobo.385.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.386.1"> and render the pages on demand. </span><span class="kobospan" id="kobo.386.2">In the context that we’re working in, that would be valid for a “</span><span><span class="kobospan" id="kobo.387.1">cart” page.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.388.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.389.1"> is server-side rendering, as we’ve seen previously. </span><span class="kobospan" id="kobo.389.2">The reason a cart page should probably be server-rendered is that it can change very quickly, based on end user interaction. </span><span class="kobospan" id="kobo.389.3">An example of a page that is dynamic but wouldn’t change quickly based on an end user action is a “view single product” page. </span><span class="kobospan" id="kobo.389.4">We’ll see how to statically generate that after the cart </span><span><span class="kobospan" id="kobo.390.1">page example.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.391.1">We create a </span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">pages/cart.js</span></strong><span class="kobospan" id="kobo.393.1"> file, where we provide the following </span><strong class="source-inline"><span class="kobospan" id="kobo.394.1">getServerSideProps</span></strong><span class="kobospan" id="kobo.395.1">, which loads the cart, figures out the relevant product IDs (per cart content), and loads them (in order to display some information </span><span><span class="kobospan" id="kobo.396.1">about them):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.397.1">
export async function getServerSideProps({ query }) {
  const { cartId = 1 } = query;
  const cart = await fetch(`https://fakestoreapi.com/carts/${cartId}`).then(
    (res) =&gt; res.json()
  );
  const productsById = (
    await Promise.all(
      cart.products.map(async (product) =&gt; {
        return await fetch(
          `https://fakestoreapi.com/products/
            ${product.productId}`
        ).then((res) =&gt; res.json());
      })
    )
  ).reduce((acc, curr) =&gt; {
    acc[curr.id] = curr;
    return acc;
  }, {});
  return {
    props: {
      cart,
      productsById,
    },
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.398.1">We can then build a page component</span><a id="_idIndexMarker286" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.399.1"> and make it the default export. </span><span class="kobospan" id="kobo.399.2">In the component, we loop</span><a id="_idIndexMarker287" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.400.1"> through the cart products, rendering some count information and some product information, based </span><span><span class="kobospan" id="kobo.401.1">on </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.402.1">props.productsById</span></strong></span><span><span class="kobospan" id="kobo.403.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.404.1">
import Head from 'next/head';
import React from 'react';
export default function CartPage({ cart, productsById }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;Cart Page&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div&gt;
        &lt;ul&gt;
          {cart.products.map((product) =&gt; {
            return (
              &lt;li key={product.productId}&gt;
                {product.quantity} x {productsById
                  [product.productId]?.title}
              &lt;/li&gt;
            );
          })}
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.405.1">We know this is a server-side rendered page</span><a id="_idIndexMarker288" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.406.1"> because when we run </span><strong class="source-inline"><span class="kobospan" id="kobo.407.1">next build</span></strong><span class="kobospan" id="kobo.408.1">, it gets marked</span><a id="_idIndexMarker289" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.409.1"> as such (and doesn’t increase the </span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">Generating static </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">pages</span></strong></span><span><span class="kobospan" id="kobo.412.1"> count):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.413.1">
npx next build
info  - Linting and checking validity of types
info  - Creating an optimized production build
info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (4/4)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      464 B          75.9 kB
├ ○ /404                                   182 B          73.2 kB
├ λ /cart                                  445 B          73.5 kB
└ ● /products                              426 B          75.9 kB
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
λ  (Server)  server-side renders at runtime (uses
  getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no
  initial props)
●  (SSG)     automatically generated as static HTML + JSON
   (uses getStaticProps)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.414.1">We can load the </span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">/carts</span></strong><span class="kobospan" id="kobo.416.1"> page</span><a id="_idIndexMarker290" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.417.1"> with a </span><strong class="source-inline"><span class="kobospan" id="kobo.418.1">?cartId=1</span></strong><span class="kobospan" id="kobo.419.1"> query param</span><a id="_idIndexMarker291" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.420.1"> and see </span><span><span class="kobospan" id="kobo.421.1">Cart 1.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer050">
<span class="kobospan" id="kobo.422.1"><img alt="Figure 5.10: The cart page with Cart 1 loaded and contents displaying" src="image/B19109_05_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.423.1">Figure 5.10: The cart page with Cart 1 loaded and contents displaying</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.424.1">We can also load the </span><strong class="source-inline"><span class="kobospan" id="kobo.425.1">/carts</span></strong><span class="kobospan" id="kobo.426.1"> page with </span><strong class="source-inline"><span class="kobospan" id="kobo.427.1">cartId=3</span></strong><span class="kobospan" id="kobo.428.1"> query param and see </span><span><span class="kobospan" id="kobo.429.1">Cart 3.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer051">
<span class="kobospan" id="kobo.430.1"><img alt="Figure 5.11: Cart page with Cart 3 loaded and contents displaying" src="image/B19109_05_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.431.1">Figure 5.11: Cart page with Cart 3 loaded and contents displaying</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.432.1">We’ve now seen how to render the cart page on demand; a page that we mentioned is a good fit for build-time pre-rendering (i.e., static site generation) is the </span><strong class="source-inline"><span class="kobospan" id="kobo.433.1">products/[id]</span></strong><span class="kobospan" id="kobo.434.1"> page. </span><span class="kobospan" id="kobo.434.2">In order to render this page, we need to provide the “paths” that Next.js needs to attempt to pre-render, since </span><strong class="source-inline"><span class="kobospan" id="kobo.435.1">[id]</span></strong> <span><span class="kobospan" id="kobo.436.1">is dynamic.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.437.1">The following diagram shows how </span><strong class="source-inline"><span class="kobospan" id="kobo.438.1">getStaticPaths</span></strong><span class="kobospan" id="kobo.439.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.440.1">getStaticProps</span></strong><span class="kobospan" id="kobo.441.1"> interact with each other. </span><span class="kobospan" id="kobo.441.2">In short, </span><strong class="source-inline"><span class="kobospan" id="kobo.442.1">getStaticPaths</span></strong><span class="kobospan" id="kobo.443.1"> returns a list of “paths”; </span><strong class="source-inline"><span class="kobospan" id="kobo.444.1">getStaticProps</span></strong><span class="kobospan" id="kobo.445.1"> is then called on each item in that list of paths and can make the relevant I/O calls to provide the </span><span><span class="kobospan" id="kobo.446.1">page’s props.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer052">
<span class="kobospan" id="kobo.447.1"><img alt="Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths and getStaticProps" src="image/B19109_05_12a.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.448.1">Figure 5.12: Sequence diagram of Next.js pre-rendering using getStaticPaths and getStaticProps</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer053">
<span class="kobospan" id="kobo.449.1"><img alt="Figure 5.13: Sequence of a request to a pre-rendered Next.js app" src="image/B19109_05_12b.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.450.1">Figure 5.13: Sequence of a request to a pre-rendered Next.js app</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.451.1">In our sample Next.js</span><a id="_idIndexMarker292" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.452.1"> app, we can create a </span><strong class="source-inline"><span class="kobospan" id="kobo.453.1">pages/products/[id].js</span></strong><span class="kobospan" id="kobo.454.1"> file with</span><a id="_idIndexMarker293" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.455.1"> the following </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">getStaticPaths</span></strong><span class="kobospan" id="kobo.457.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">getStaticProps</span></strong></span><span><span class="kobospan" id="kobo.459.1"> functions:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.460.1">
export async function getStaticPaths() {
  const products = await fetch('https://fakestoreapi.com/
    products')
    .then((res) =&gt; res.json())
    .then((json) =&gt; json);
  const paths = products.map((product) =&gt; ({
    params: { id: String(product.id) },
  }));
  return { paths, fallback: false };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.461.1">One quirk of the </span><strong class="source-inline"><span class="kobospan" id="kobo.462.1">paths</span></strong><span class="kobospan" id="kobo.463.1"> generation</span><a id="_idIndexMarker294" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.464.1"> is that we’re converting </span><strong class="source-inline"><span class="kobospan" id="kobo.465.1">product.id</span></strong><span class="kobospan" id="kobo.466.1"> from a number</span><a id="_idIndexMarker295" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.467.1"> to a string, since the </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">[id]</span></strong><span class="kobospan" id="kobo.469.1"> path parameter needs to be a string. </span><span class="kobospan" id="kobo.469.2">Next.js would error with </span><strong class="source-inline"><span class="kobospan" id="kobo.470.1">Error: A required parameter (id) was not provided as a string received number in getStaticPaths for /</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">products/[id]</span></strong></span><span><span class="kobospan" id="kobo.472.1"> otherwise.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.473.1">getStaticProps</span></strong><span class="kobospan" id="kobo.474.1"> takes the </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">params</span></strong><span class="kobospan" id="kobo.476.1"> object, which is contained in the objects returned from </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">getStaticPaths</span></strong><span class="kobospan" id="kobo.478.1">, and makes further </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">fetch</span></strong><span class="kobospan" id="kobo.480.1"> calls to load the product by ID. </span><span class="kobospan" id="kobo.480.2">Finally, it returns </span><strong class="source-inline"><span class="kobospan" id="kobo.481.1">product</span></strong><span class="kobospan" id="kobo.482.1"> for the </span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">Page</span></strong><span class="kobospan" id="kobo.484.1"> component </span><span><span class="kobospan" id="kobo.485.1">to use:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.486.1">
export async function getStaticProps({ params }) {
  const product = await fetch(
    `https://fakestoreapi.com/products/${params.id}`
  ).then((res) =&gt; res.json());
  return {
    props: {
      product,
    },
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.487.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.488.1">ProductPage</span></strong><span class="kobospan" id="kobo.489.1"> component can then look like the following, where we use </span><strong class="source-inline"><span class="kobospan" id="kobo.490.1">product.title</span></strong><span class="kobospan" id="kobo.491.1"> both as the title of the page and as the page’s </span><strong class="source-inline"><span class="kobospan" id="kobo.492.1">h2</span></strong><span class="kobospan" id="kobo.493.1"> element content. </span><span class="kobospan" id="kobo.493.2">From here, we could display</span><a id="_idIndexMarker296" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.494.1"> anything contained</span><a id="_idIndexMarker297" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.495.1"> in the product response, including price and stock information </span><span><span class="kobospan" id="kobo.496.1">and images:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.497.1">
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';
export default function ProductPage({ product }) {
  return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;title&gt;{product.title}&lt;/title&gt;
      &lt;/Head&gt;
      &lt;div&gt;
        &lt;Link href={'/products'}&gt;Back&lt;/Link&gt;
        &lt;h2&gt;{product.title}&lt;/h2&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.498.1">When we run </span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">next build</span></strong><span class="kobospan" id="kobo.500.1">, the build will take longer, since each </span><strong class="source-inline"><span class="kobospan" id="kobo.501.1">products/[id]</span></strong><span class="kobospan" id="kobo.502.1"> page needs to make a request to </span><strong class="source-inline"><span class="kobospan" id="kobo.503.1">fakestoreapi.com</span></strong><span class="kobospan" id="kobo.504.1">. </span><span class="kobospan" id="kobo.504.2">Note that the </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">products/[id]</span></strong><span class="kobospan" id="kobo.506.1"> pages are marked as </span><strong class="source-inline"><span class="kobospan" id="kobo.507.1">SSG</span></strong><span class="kobospan" id="kobo.508.1">. </span><span class="kobospan" id="kobo.508.2">We also see the number of static pages being generated increasing</span><a id="_idIndexMarker298" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.509.1"> to 24 and a truncated subset</span><a id="_idIndexMarker299" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.510.1"> of </span><span><strong class="source-inline"><span class="kobospan" id="kobo.511.1">products/[id]</span></strong></span><span><span class="kobospan" id="kobo.512.1"> pages:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.513.1">
npx next build
info  - Linting and checking validity of types
info  - Creating an optimized production build
info  - Compiled successfully
info  - Collecting page data
info  - Generating static pages (24/24)
info  - Finalizing page optimization
Route (pages)                              Size     First Load JS
┌ ○ /                                      464 B          75.9 kB
├ ○ /404                                   182 B          73.2 kB
├ λ /cart                                  445 B          73.5 kB
├ ● /products                              426 B          75.9 kB
└ ● /products/[id]                         383 B          75.9 kB
    ├ /products/1
    ├ /products/2
    ├ /products/3
    └ [+17 more paths]
+ First Load JS shared by all              73.1 kB
  ├ chunks/framework-fcfa81c6fe8caa42.js   45.2 kB
  ├ chunks/main-7039e34bfb6f1a68.js        26.9 kB
  ├ chunks/pages/_app-c7a111f3ee9d686c.js  195 B
  └ chunks/webpack-8fa1640cc84ba8fe.js     750 B
λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.514.1">After building and starting</span><a id="_idIndexMarker300" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.515.1"> the server with </span><strong class="source-inline"><span class="kobospan" id="kobo.516.1">next start</span></strong><span class="kobospan" id="kobo.517.1">, when we load</span><a id="_idIndexMarker301" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.518.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">/products/1</span></strong><span class="kobospan" id="kobo.520.1"> path, we see product </span><span><span class="kobospan" id="kobo.521.1">1’s name.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer054">
<span class="kobospan" id="kobo.522.1"><img alt="Figure 5.14: /products/1 content" src="image/B19109_05_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.523.1">Figure 5.14: /products/1 content</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.524.1">And when we load the </span><strong class="source-inline"><span class="kobospan" id="kobo.525.1">/products/8</span></strong><span class="kobospan" id="kobo.526.1"> path, we see product </span><span><span class="kobospan" id="kobo.527.1">8’s name.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer055">
<span class="kobospan" id="kobo.528.1"><img alt="Figure 5.15: /products/8 content" src="image/B19109_05_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.529.1">Figure 5.15: /products/8 content</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.530.1">We’ve now seen how to leverage Next.js features that automatically statically render pages with no data fetching, </span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">getStaticProps</span></strong><span class="kobospan" id="kobo.532.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.533.1">getStaticPaths</span></strong><span class="kobospan" id="kobo.534.1"> to render pages with dynamic content and with dynamic paths</span><a id="_idIndexMarker302" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.535.1"> at build time, as well as how these approaches</span><a id="_idIndexMarker303" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.536.1"> contrast </span><span><span class="kobospan" id="kobo.537.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.538.1">getServerSideProps</span></strong></span><span><span class="kobospan" id="kobo.539.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.540.1">Next, we’ll deep-dive into ho</span><a id="_idTextAnchor191" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.541.1">w to rehydrate a server-rendered react page on </span><span><span class="kobospan" id="kobo.542.1">the client.</span></span></p>
<h1 id="_idParaDest-100" class="calibre5"><a id="_idTextAnchor192" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.543.1">Page hydration strategies</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.544.1">As we’ve seen in the first section</span><a id="_idIndexMarker304" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.545.1"> of the chapter, react provides primitives to render applications on the server and the client. </span><span class="kobospan" id="kobo.545.2">However, we only looked at examples where we did exclusively client or server rendering. </span><span class="kobospan" id="kobo.545.3">One key feature of React frameworks such as Next.js is that they allow you to seamlessly switch between static, client, and server rendering. </span><span class="kobospan" id="kobo.545.4">We’ll look at how to achieve this using </span><span><span class="kobospan" id="kobo.546.1">React primitives.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer056">
<span class="kobospan" id="kobo.547.1"><img alt="Figure 5.16: A sequence diagram for a server-rendered page that is subsequently rehydrated on the client" src="image/B19109_05_15.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.548.1">Figure 5.16: A sequence diagram for a server-rendered page that is subsequently rehydrated on the client</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.549.1">We’ll start by extending our React </span><a id="_idIndexMarker305" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.550.1">client/server rendering </span><strong class="source-inline"><span class="kobospan" id="kobo.551.1">app.jsx</span></strong><span class="kobospan" id="kobo.552.1"> with a </span><strong class="source-inline"><span class="kobospan" id="kobo.553.1">ClientCounter</span></strong><span class="kobospan" id="kobo.554.1"> component. </span><span class="kobospan" id="kobo.554.2">Event handlers are one of the simplest ways to observe interactivity primitives. </span><span class="kobospan" id="kobo.554.3">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.555.1">ClientCounter</span></strong><span class="kobospan" id="kobo.556.1"> component displays a counter that initializes with </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">0</span></strong><span class="kobospan" id="kobo.558.1">, and on every click of the </span><strong class="bold"><span class="kobospan" id="kobo.559.1">Add</span></strong><span class="kobospan" id="kobo.560.1"> button, it increments the count value. </span><span class="kobospan" id="kobo.560.2">We put this component in a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">src/client-counter.jsx</span></strong></span><span><span class="kobospan" id="kobo.562.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.563.1">
import React, { useState } from 'react';
export function ClientCounter() {
  const [count, setCount] = useState(0);
  return (
    &lt;div&gt;
      Dynamic Counter, count: {count}
      &lt;br /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Add&lt;/button&gt;
    &lt;/div&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.564.1">We can render</span><a id="_idIndexMarker306" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.565.1"> it in our </span><strong class="source-inline"><span class="kobospan" id="kobo.566.1">app.jsx</span></strong><span class="kobospan" id="kobo.567.1"> component, </span><span><span class="kobospan" id="kobo.568.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.569.1">
import React from 'react';
import { ClientCounter } from './client-counter';
export function App({ type = '' }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
        &lt;ClientCounter /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.570.1">If we build the client-side entry point and load it in the browser, it works correctly, incrementing on each </span><span><strong class="bold"><span class="kobospan" id="kobo.571.1">Add</span></strong></span><span><span class="kobospan" id="kobo.572.1"> click:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.573.1">
npx esbuild client.jsx --bundle --outdir=dist</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.574.1">If we open the </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">index.html</span></strong><span class="kobospan" id="kobo.576.1"> file (which is unchanged), we’ll be able to see the counter and increment it, as shown</span><a id="_idIndexMarker307" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.577.1"> in the </span><span><span class="kobospan" id="kobo.578.1">following screenshot.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer057">
<span class="kobospan" id="kobo.579.1"><img alt="Figure 5.17: The React client-side rendered counter with an increment of 7 displayed" src="image/B19109_05_16.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.580.1">Figure 5.17: The React client-side rendered counter with an increment of 7 displayed</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.581.1">However, if we build and run our server-side entry point, the component remains </span><span><span class="kobospan" id="kobo.582.1">at 0:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.583.1">
npx esbuild server.js --bundle --platform=node --outdir=dist</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.584.1">We can then start the server using </span><span><span class="kobospan" id="kobo.585.1">the following:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.586.1">
node dist/server.js</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.587.1">As the following screenshot shows, no matter how many times we click </span><strong class="bold"><span class="kobospan" id="kobo.588.1">Add</span></strong><span class="kobospan" id="kobo.589.1">, the component only ever </span><span><span class="kobospan" id="kobo.590.1">displays </span></span><span><strong class="bold"><span class="kobospan" id="kobo.591.1">0</span></strong></span><span><span class="kobospan" id="kobo.592.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer058">
<span class="kobospan" id="kobo.593.1"><img alt="Figure 5.18: React server-rendering does not allow for interactive counter component, the count shows 0 despite multiple Add button clicks" src="image/B19109_05_17.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.594.1">Figure 5.18: React server-rendering does not allow for interactive counter component, the count shows 0 despite multiple Add button clicks</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.595.1">In order to “hydrate” our server-rendered</span><a id="_idIndexMarker308" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.596.1"> page, we can create a new entry point, </span><strong class="source-inline"><span class="kobospan" id="kobo.597.1">rehydrate.jsx</span></strong><span class="kobospan" id="kobo.598.1">. </span><span class="kobospan" id="kobo.598.2">This uses </span><strong class="source-inline"><span class="kobospan" id="kobo.599.1">react-dom/client</span></strong><span class="kobospan" id="kobo.600.1">’s </span><strong class="source-inline"><span class="kobospan" id="kobo.601.1">hydrateRoot</span></strong><span class="kobospan" id="kobo.602.1"> function on the element that contains </span><span><span class="kobospan" id="kobo.603.1">our app:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.604.1">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './src/app';
ReactDOM.hydrateRoot(
  document.querySelector('#app'),
  &lt;App type={`"server render"`} /&gt;
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.605.1">We’ll bundle the rehydration entry point using </span><strong class="source-inline"><span class="kobospan" id="kobo.606.1">esbuild</span></strong><span class="kobospan" id="kobo.607.1">, in a similar fashion to previous </span><span><span class="kobospan" id="kobo.608.1">entry points:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.609.1">
npx esbuild rehydrate.jsx --bundle --outdir=dist</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.610.1">Once our new </span><strong class="source-inline"><span class="kobospan" id="kobo.611.1">dist/rehydrate.js</span></strong><span class="kobospan" id="kobo.612.1"> file is built, we need</span><a id="_idIndexMarker309" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.613.1"> to use it in our server-rendered app. </span><span class="kobospan" id="kobo.613.2">We modify </span><strong class="source-inline"><span class="kobospan" id="kobo.614.1">server.js</span></strong><span class="kobospan" id="kobo.615.1"> to statically serve </span><strong class="source-inline"><span class="kobospan" id="kobo.616.1">dist</span></strong><span class="kobospan" id="kobo.617.1">, which means that </span><strong class="source-inline"><span class="kobospan" id="kobo.618.1">dist/rehydrate.js</span></strong><span class="kobospan" id="kobo.619.1"> is available as </span><strong class="source-inline"><span class="kobospan" id="kobo.620.1">rehydrate.js</span></strong><span class="kobospan" id="kobo.621.1">. </span><span class="kobospan" id="kobo.621.2">We then create a new </span><strong class="source-inline"><span class="kobospan" id="kobo.622.1">GET</span></strong><span class="kobospan" id="kobo.623.1"> route, </span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">/rehydrate</span></strong><span class="kobospan" id="kobo.625.1">. </span><span class="kobospan" id="kobo.625.2">This route returns the navigation elements seen previously, but now the application also has a script that will </span><span><span class="kobospan" id="kobo.626.1">load </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">rehydrate.js</span></strong></span><span><span class="kobospan" id="kobo.628.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.629.1">
// no changes to other routes
app.use(express.static('./dist'));
app.get('/rehydrate', (_req, res) =&gt; {
  res.send(`
    &lt;!DOCTYPE html&gt;
    ${renderNav()}
    &lt;h1&gt;Server-render with client-side rehydration&lt;/h1&gt;
    &lt;div id="app"&gt;${serverRenderApp()}&lt;/div&gt;
    &lt;script src="./rehydrate.js"&gt;&lt;/script&gt;
  `);
});
// no changes to server startup</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.630.1">We also include </span><strong class="source-inline"><span class="kobospan" id="kobo.631.1">/rehydrate</span></strong><span class="kobospan" id="kobo.632.1"> in the </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">nav.jsx</span></strong><span class="kobospan" id="kobo.634.1">, which now looks </span><span><span class="kobospan" id="kobo.635.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.636.1">
import React from 'react';
export function Nav() {
  return (
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href="/"&gt;Server-render only&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/rehydrate"&gt;Server-render with client-side
          rehydration&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.637.1">We can then rebuild our entry points </span><a id="_idIndexMarker310" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.638.1">and start the server. </span><span class="kobospan" id="kobo.638.2">When we navigate to </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">/rehydrate</span></strong><span class="kobospan" id="kobo.640.1">, the counter is interactive, and we see the navigation and </span><strong class="source-inline"><span class="kobospan" id="kobo.641.1">h1</span></strong><span class="kobospan" id="kobo.642.1"> as </span><span><span class="kobospan" id="kobo.643.1">rendered server-side.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer059">
<span class="kobospan" id="kobo.644.1"><img alt="Figure 5.19: The rehydrated server-rendered application allows the interactive u﻿se of a client-side counter, displayed here with a count of 5" src="image/B19109_05_18.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.645.1">Figure 5.19: The rehydrated server-rendered application allows the interactive u</span><a id="_idTextAnchor193" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.646.1">se of a client-side counter, displayed here with a count of 5</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.647.1">We’ve now seen how to rehydrate</span><a id="_idIndexMarker311" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.648.1"> a server-rendered React application, next we’ll delve into common React </span><span><span class="kobospan" id="kobo.649.1">rehydration issues.</span></span></p>
<h2 id="_idParaDest-101" class="calibre7"><a id="_idTextAnchor194" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.650.1">Common React rehydration issues</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.651.1">Rehydration has some</span><a id="_idIndexMarker312" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.652.1">key gotchas.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.653.1">It’s quite common to see the following runtime environment detection code in </span><span><span class="kobospan" id="kobo.654.1">an application.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.655.1">
export const isServer = () =&gt; typeof window ===
  'undefined';</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.656.1">Let’s say we placed </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">isServer</span></strong><span class="kobospan" id="kobo.658.1"> in a </span><strong class="source-inline"><span class="kobospan" id="kobo.659.1">src/rendering-utils.js</span></strong><span class="kobospan" id="kobo.660.1"> file; we can use it as follows to conditionally</span><a id="_idIndexMarker313" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.661.1"> render content such as </span><strong class="source-inline"><span class="kobospan" id="kobo.662.1">'from client'</span></strong><span class="kobospan" id="kobo.663.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.664.1">'not from client'</span></strong><span class="kobospan" id="kobo.665.1">, or avoid rendering </span><strong class="source-inline"><span class="kobospan" id="kobo.666.1">ClientCounter</span></strong><span class="kobospan" id="kobo.667.1"> altogether </span><span><span class="kobospan" id="kobo.668.1">when server-rendering:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.669.1">
import React from 'react';
import { ClientCounter } from './client-counter';
import { isServer } from './rendering-utils';
export function App({ type = '' }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
        &lt;p&gt;Rendering: {isServer() ? </span><span class="kobospan1" id="kobo.669.2">'not from client' :
           'from client'}&lt;/p&gt;
        {!isServer() &amp;&amp; &lt;ClientCounter /&gt;}
      &lt;/div&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.670.1">This works fine in the purely server-rendered use case, where we display </span><strong class="source-inline"><span class="kobospan" id="kobo.671.1">'not from client'</span></strong><span class="kobospan" id="kobo.672.1"> and </span><span><span class="kobospan" id="kobo.673.1">hide </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.674.1">ClientCounter</span></strong></span><span><span class="kobospan" id="kobo.675.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer060">
<span class="kobospan" id="kobo.676.1"><img alt="Figure 5.20: isServer detection working successfully for server-side-only rendering" src="image/B19109_05_19.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.677.1">Figure 5.20: isServer detection working successfully for server-side-only rendering</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.678.1">At first glance, it looks to be working</span><a id="_idIndexMarker314" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.679.1"> for the server-render followed by client-side rehydration use case. </span><span class="kobospan" id="kobo.679.2">It displays </span><strong class="bold"><span class="kobospan" id="kobo.680.1">from client</span></strong><span class="kobospan" id="kobo.681.1"> and shows the client-side </span><span><span class="kobospan" id="kobo.682.1">counter component.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer061">
<span class="kobospan" id="kobo.683.1"><img alt="Figure 5.21: isServer detection looking to work for server-side rendering followed rehydration" src="image/B19109_05_20.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.684.1">Figure 5.21: isServer detection looking to work for server-side rendering followed rehydration</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.685.1">However, if we look</span><a id="_idIndexMarker315" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.686.1"> at the console, we can see that we have </span><span><span class="kobospan" id="kobo.687.1">some errors.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer062">
<span class="kobospan" id="kobo.688.1"><img alt="Figure 5.22: Console errors during rehydration" src="image/B19109_05_21.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.689.1">Figure 5.22: Console errors during rehydration</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.690.1">The issue is client render versus server render</span><a id="_idIndexMarker316" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.691.1"> mismatches – for example, </span><strong class="bold"><span class="kobospan" id="kobo.692.1">Warning: Text content did not match. </span><span class="kobospan" id="kobo.692.2">Server: “from client” Client: “not from client”</span></strong><span class="kobospan" id="kobo.693.1">. </span><strong class="source-inline"><span class="kobospan" id="kobo.694.1">ReactDOM.rehydrateRoot</span></strong><span class="kobospan" id="kobo.695.1"> expects the application to render the same way on the server and the client. </span><span class="kobospan" id="kobo.695.2">React, in this situation, falls back to full client-side rendering (</span><strong class="bold"><span class="kobospan" id="kobo.696.1">An error occurred during hydration. </span><span class="kobospan" id="kobo.696.2">The server HTML was replaced with client content in &lt;div&gt;.</span></strong><span class="kobospan" id="kobo.697.1">), meaning the server-rendered HTML is completely </span><span><span class="kobospan" id="kobo.698.1">thrown away.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.699.1">To fix this, a better detection of server versus client is required. </span><span class="kobospan" id="kobo.699.2">A simple detection would involve a hook using </span><strong class="source-inline"><span class="kobospan" id="kobo.700.1">useEffect</span></strong><span class="kobospan" id="kobo.701.1">. </span><span class="kobospan" id="kobo.701.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.702.1">useClientRenderingOnly</span></strong><span class="kobospan" id="kobo.703.1"> function will always be </span><strong class="source-inline"><span class="kobospan" id="kobo.704.1">false</span></strong><span class="kobospan" id="kobo.705.1"> until the application runs our </span><strong class="source-inline"><span class="kobospan" id="kobo.706.1">useEffect</span></strong><span class="kobospan" id="kobo.707.1">, which is only </span><span><span class="kobospan" id="kobo.708.1">run client-side:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.709.1">
export function useClientRenderingOnly() {
  const [hasMounted, setHasMounted] = useState(false);
  useEffect(() =&gt; {
    setHasMounted(true);
  });
  return hasMounted;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.710.1">It can be used</span><a id="_idIndexMarker317" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.711.1"> as follows in </span><strong class="source-inline"><span class="kobospan" id="kobo.712.1">src/client-counter.jsx</span></strong><span class="kobospan" id="kobo.713.1"> instead of </span><strong class="source-inline"><span class="kobospan" id="kobo.714.1">isServer</span></strong> <span><span class="kobospan" id="kobo.715.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.716.1">app.jsx</span></strong></span><span><span class="kobospan" id="kobo.717.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.718.1">
import React, { useState } from 'react';
import { useClientRenderingOnly } from './rendering-utils';
export function ClientCounter() {
  const isClientRendering = useClientRenderingOnly();
  const [count, setCount] = useState(0);
  if (!isClientRendering) return null;
  // no change to JSX return
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.719.1">app.jsx</span></strong><span class="kobospan" id="kobo.720.1"> can become the following, leveraging </span><strong class="source-inline"><span class="kobospan" id="kobo.721.1">isClientRendering</span></strong><span class="kobospan" id="kobo.722.1"> to display </span><strong class="source-inline"><span class="kobospan" id="kobo.723.1">'from client'</span></strong><span class="kobospan" id="kobo.724.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.725.1">'not </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.726.1">from client'</span></strong></span><span><span class="kobospan" id="kobo.727.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.728.1">
import React from 'react';
import { ClientCounter } from './client-counter';
import { isClientRendering } from './rendering-utils';
export function App({ type = '' }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;p&gt;Hello from the {type + ' '}app&lt;/p&gt;
        &lt;p&gt;
          Rendering: {isClientRendering ? </span><span class="kobospan1" id="kobo.728.2">'from client' :
            'not from client'}
        &lt;/p&gt;
        &lt;ClientCounter /&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.729.1">In the server-rendering-only case, this works, and in the rehydration case, we now know whether to display something on the server or client without getting </span><span><span class="kobospan" id="kobo.730.1">rehydration issues.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.731.1">Other common issues that cause rehydration errors are invalid markup (some HTML tags are not supposed to be inside other </span><span><span class="kobospan" id="kobo.732.1">HTML tags).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.733.1">React provides one more rendering approach</span><a id="_idIndexMarker318" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.734.1"> that allows the s</span><a id="_idTextAnchor195" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.735.1">erver to start returning data to the client earlier </span><span><span class="kobospan" id="kobo.736.1">via streaming.</span></span></p>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor196" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.737.1">React streaming server-side rendering</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.738.1">React streaming server-side rendering</span><a id="_idIndexMarker319" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.739.1"> leverages streaming so that the server can start return data to the browser earlier (chunks in a stream instead of a one-off response). </span><span class="kobospan" id="kobo.739.2">This also means that the browser can start working on </span><span><span class="kobospan" id="kobo.740.1">rendering earlier.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.741.1">There’s a major caveat to streaming, which is that one of its key advantages over non-streaming server-rendering is that it has support for the new suspense primitive. </span><span class="kobospan" id="kobo.741.2">This primitive is supported by specific libraries and frameworks and is quite difficult to illustrate using </span><span><span class="kobospan" id="kobo.742.1">React primitives.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.743.1">According to the React documentation</span><a id="_idIndexMarker320" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.744.1"> on suspense </span><span><span class="kobospan" id="kobo.745.1">usage (</span></span><a href="https://react.dev/reference/react/Suspense#usage" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.746.1">https://react.dev/reference/react/Suspense#usage</span></span></a><span><span class="kobospan" id="kobo.747.1">):</span></span></p>
<p class="author-quote"><span class="kobospan" id="kobo.748.1">Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. </span><span class="kobospan" id="kobo.748.2">The requirements for implementing a Suspense-enabled data source are unstable and undocumented. </span><span class="kobospan" id="kobo.748.3">An official API for integrating data sources with Suspense will be released in a future version of React.</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.749.1">When rehydrating a React streaming server rendered page, we need to replace the whole document, so we’ll create a new </span><strong class="source-inline"><span class="kobospan" id="kobo.750.1">&lt;Page&gt;</span></strong><span class="kobospan" id="kobo.751.1"> component, which will be a full page. </span><span class="kobospan" id="kobo.751.2">We’ll also create a </span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">streaming-rehydrate.jsx</span></strong><span class="kobospan" id="kobo.753.1"> entry point for </span><span><span class="kobospan" id="kobo.754.1">use client-side.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.755.1">The following are the contents</span><a id="_idIndexMarker321" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.756.1"> of a new </span><strong class="source-inline"><span class="kobospan" id="kobo.757.1">src/page.jsx</span></strong><span class="kobospan" id="kobo.758.1"> file. </span><span class="kobospan" id="kobo.758.2">The full page including </span><strong class="source-inline"><span class="kobospan" id="kobo.759.1">html</span></strong><span class="kobospan" id="kobo.760.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.761.1">head</span></strong><span class="kobospan" id="kobo.762.1"> are necessary to do streaming </span><span><span class="kobospan" id="kobo.763.1">server-side rendering:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.764.1">
import React from 'react';
import { App } from './app';
import { Nav } from './nav';
export default function Page() {
  return (
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Streaming&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;Nav /&gt;
        &lt;h1&gt;Server-render with streaming&lt;/h1&gt;
        &lt;div id="app"&gt;
          &lt;App type={`"streaming server render"`} /&gt;
        &lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.765.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.766.1">streaming-rehydrate.jsx</span></strong><span class="kobospan" id="kobo.767.1"> entry point</span><a id="_idIndexMarker322" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.768.1"> is quite similar to our </span><strong class="source-inline"><span class="kobospan" id="kobo.769.1">rehydrate.jsx</span></strong><span class="kobospan" id="kobo.770.1"> entry point with the exception that it hydrates </span><strong class="source-inline"><span class="kobospan" id="kobo.771.1">document</span></strong><span class="kobospan" id="kobo.772.1">, instead of an element with the </span><strong class="source-inline"><span class="kobospan" id="kobo.773.1">app</span></strong><span class="kobospan" id="kobo.774.1"> ID. </span><span class="kobospan" id="kobo.774.2">This is due to the aforementioned limitation of streaming server-side rendering – the whole document has to be controlled </span><span><span class="kobospan" id="kobo.775.1">by React:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.776.1">
import React from 'react';
import ReactDOM from 'react-dom/client';
import Page from './src/page';
ReactDOM.hydrateRoot(document, &lt;Page /&gt;);;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.777.1">We’ll build the entry point to JavaScript using </span><span><span class="kobospan" id="kobo.778.1">the following:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.779.1">
npx esbuild streaming-rehydrate.jsx.jsx --bundle --outdir=dist</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.780.1">We can now start working on the server rendering in </span><strong class="source-inline"><span class="kobospan" id="kobo.781.1">src/server-rendering.jsx</span></strong><span class="kobospan" id="kobo.782.1">. </span><span class="kobospan" id="kobo.782.2">We create a new </span><strong class="source-inline"><span class="kobospan" id="kobo.783.1">serverRenderAppStream</span></strong><span class="kobospan" id="kobo.784.1"> function that takes an Express/Node.js </span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">res</span></strong><span class="kobospan" id="kobo.786.1"> object as a parameter. </span><span class="kobospan" id="kobo.786.2">It calls </span><strong class="source-inline"><span class="kobospan" id="kobo.787.1">ReactDOMServer.renderToPipeableStream</span></strong><span class="kobospan" id="kobo.788.1"> with the </span><strong class="source-inline"><span class="kobospan" id="kobo.789.1">Page</span></strong><span class="kobospan" id="kobo.790.1"> component, and with </span><strong class="source-inline"><span class="kobospan" id="kobo.791.1">bootstrapScripts</span></strong><span class="kobospan" id="kobo.792.1"> set to include our </span><strong class="source-inline"><span class="kobospan" id="kobo.793.1">streaming-rehydrate.js</span></strong> <span><span class="kobospan" id="kobo.794.1">entry point:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.795.1">
import React from 'react';
import ReactDOMServer from 'react-dom/server';
// no changes to other imports
import Page from './page';
export function serverRenderAppStream(res) {
  const { pipe } = ReactDOMServer.renderToPipeableStream
    (&lt;Page /&gt;, {
    bootstrapScripts: ['./streaming-rehydrate.js'],
  });
  pipe(res);
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.796.1">In </span><strong class="source-inline"><span class="kobospan" id="kobo.797.1">server.js</span></strong><span class="kobospan" id="kobo.798.1">, we can create</span><a id="_idIndexMarker323" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.799.1"> a new </span><strong class="source-inline"><span class="kobospan" id="kobo.800.1">GET</span></strong><span class="kobospan" id="kobo.801.1"> route for the </span><strong class="source-inline"><span class="kobospan" id="kobo.802.1">/streaming</span></strong><span class="kobospan" id="kobo.803.1"> path, which simply calls </span><strong class="source-inline"><span class="kobospan" id="kobo.804.1">serverRenderAppStream</span></strong><span class="kobospan" id="kobo.805.1"> with the </span><strong class="source-inline"><span class="kobospan" id="kobo.806.1">res</span></strong><span class="kobospan" id="kobo.807.1"> object per the Express route </span><span><span class="kobospan" id="kobo.808.1">handler definition:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.809.1">
// no change to other imports
import {
  // no change to other imports
  serverRenderAppStream,
} from './src/server-render';
// no change to other routes
app.get('/streaming', (_req, res) =&gt; {
  serverRenderAppStream(res);
});
// no change to startup logic</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.810.1">We’ll also add the </span><strong class="source-inline"><span class="kobospan" id="kobo.811.1">/streaming</span></strong><span class="kobospan" id="kobo.812.1"> route </span><span><span class="kobospan" id="kobo.813.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.814.1">src/nav.jsx</span></strong></span><span><span class="kobospan" id="kobo.815.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.816.1">
import React from 'react';
export function Nav() {
  return (
    &lt;ul&gt;
      {/* no change to the other li elements */}
      &lt;li&gt;
        &lt;a href="/streaming"&gt;Server-render with streaming
          &lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.817.1">We can now load the </span><strong class="source-inline"><span class="kobospan" id="kobo.818.1">/streaming</span></strong><span class="kobospan" id="kobo.819.1"> page and see</span><a id="_idIndexMarker324" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.820.1"> it </span><span><span class="kobospan" id="kobo.821.1">in action.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer063">
<span class="kobospan" id="kobo.822.1"><img alt="Figure 5.23: React streaming server rendering with rehydration" src="image/B19109_05_22.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.823.1">Figure 5.23: React streaming server rendering with rehydration</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.824.1">We’ve now s</span><a id="_idTextAnchor197" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.825.1">een how to implement</span><a id="_idIndexMarker325" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.826.1"> React streaming server rendering </span><span><span class="kobospan" id="kobo.827.1">with rehydration.</span></span></p>
<h1 id="_idParaDest-103" class="calibre5"><a id="_idTextAnchor198" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.828.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.829.1">In this chapter, we covered how a deeper understanding of rendering and page hydration strategies can help us deliver optimal and scalable web user interfaces </span><span><span class="kobospan" id="kobo.830.1">with React.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.831.1">Client and server rendering have benefits and drawbacks that are complimentary to each other. </span><span class="kobospan" id="kobo.831.2">Client rendering takes longer to start up but provides more interactivity and doesn’t require as much server-side computer power; server rendering can return content faster but requires infrastructure and doesn’t provide the same level </span><span><span class="kobospan" id="kobo.832.1">of interactivity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.833.1">The static site generation functionality of Next.js can be leveraged alongside classic server rendering to judiciously decide on a rendering strategy for a given set of pages, based on the access pattern and how often the </span><span><span class="kobospan" id="kobo.834.1">content changes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.835.1">Finally, page hydration and rehydration alongside streaming server-side rendering bridges the gap between server and client rendering, allowing the benefits of both to be included in </span><span><span class="kobospan" id="kobo.836.1">one page.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.837.1">Now that we’re familiar with rendering and page hydration strategies, we can look at implementing micro-frontends using both the “zones” and “islands” architectures in the </span><span><span class="kobospan" id="kobo.838.1">next chapter.</span></span></p>
</div>
</body></html>