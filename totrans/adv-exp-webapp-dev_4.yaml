- en: Chapter 4. Real-time Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 实时通信
- en: 'Our application is beginning to take shape. We have a list of projects and
    a form that allows us to add, delete, and update projects. We are also able to
    assign repositories to these projects, which allows us to view a list of issues/commits
    for all repositories in a project. This chapter will guide you through the next
    phase of our client setup: displaying a list of project repository commits and
    issues in real time using Redis and Socket.IO.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序开始成形。我们有一个项目列表和一个表单，允许我们添加、删除和更新项目。我们还能将这些仓库分配给这些项目，这样我们就可以查看项目中的所有仓库的问题/提交列表。本章将指导你完成客户端设置的下一阶段：使用
    Redis 和 Socket.IO 实时显示项目仓库提交和问题列表。
- en: We would ideally like the application to continue working with Socket.IO/Redis
    switched off, leaving the application without a real-time element. We will attempt
    to implement these features with this in mind.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理想情况下希望应用程序在 Socket.IO/Redis 关闭的情况下继续工作，这样应用程序就没有实时元素。我们将尝试考虑这些功能来实现这些特性。
- en: Caching data with Redis
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 缓存数据
- en: Redis is an extremely fast, open source, in-memory key value store. Redis has
    a useful Pub/Sub mechanism that we will use to push messages to a Socket.IO subscriber
    that will emit events to the client.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个极快、开源的内存键值存储。Redis 有一个有用的 Pub/Sub 机制，我们将使用它将消息推送到一个 Socket.IO 订阅者，该订阅者将向客户端发出事件。
- en: 'Visit this website in order to download and install Redis: [http://redis.io/download](http://redis.io/download).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 访问此网站以下载和安装 Redis：[http://redis.io/download](http://redis.io/download)。
- en: 'Once Redis is installed, you can start it with the following command:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Redis 安装完成，你可以使用以下命令启动它：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to start the Redis command-line interface, CLI issues the following
    command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动 Redis 命令行界面，CLI 会发出以下命令：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following commands can be issued from the CLI:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从 CLI 发出以下命令：
- en: 'To monitor activity on Redis:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要监控 Redis 上的活动：
- en: '[PRE2]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To clear the Redis store:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要清除 Redis 存储：
- en: '[PRE3]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To view all the keys stored in Redis:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看 Redis 中存储的所有键：
- en: '[PRE4]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get the value of a key:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取键的值：
- en: '[PRE5]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to use Redis in our application, install the `node-redis` client,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中使用 Redis，按照以下步骤安装 `node-redis` 客户端：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s configure our application to use Redis by updating the`./lib/config/*.json`
    config files with the following configuration:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新 `./lib/config/*.json` 配置文件来配置我们的应用程序以使用 Redis，如下所示：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we create a simple module, `Redis`, that wraps up the Redis connection
    `./lib/cache/redis.js`. We start by importing the `redis` module. We define a
    `Redis` module, which calls `createClient` in order to create a Redis client.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的模块，`Redis`，它封装了 Redis 连接 `./lib/cache/redis.js`。我们首先导入 `redis` 模块。我们定义一个
    `Redis` 模块，它调用 `createClient` 来创建 Redis 客户端。
- en: 'We pull in the Redis configuration data from the preceding:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前面拉取 Redis 配置数据：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's extend our `Redis` module and create a `Publisher` module that will publish
    messages using the Redis Pub/Sub feature, `./lib/cache/publisher/index.js`. We
    start by importing our `Redis` module and use the `util` module to extend the
    `Redis` module with the `Publisher` module. We then define our `Publisher` module,
    which includes a `save` function, which saves an object as a string to Redis and
    a `publish` function, which publishes a message to Redis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的 `Redis` 模块并创建一个 `Publisher` 模块，该模块将使用 Redis Pub/Sub 功能发布消息，`./lib/cache/publisher/index.js`。我们首先导入我们的
    `Redis` 模块，并使用 `util` 模块将 `Publisher` 模块扩展到 `Redis` 模块中。然后我们定义我们的 `Publisher`
    模块，它包括一个 `save` 函数，该函数将对象作为字符串保存到 Redis 中，以及一个 `publish` 函数，该函数将消息发布到 Redis 中。
- en: 'The `Publisher` module is defined as shown in the following code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher` 模块的定义如下所示：'
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we extend our `Redis` module and create a `Subscribe` `r./lib/cache/subscriber/index.js`,
    which consumes published messages. We start by importing our `Redis` module and
    use the `util` module to extend the `Redis` module with the `Subscriber` module.
    We then define our `Subscriber` module, which includes a `subscribe` function.
    This allows the user to subscribe to messages on a `key`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们扩展我们的 `Redis` 模块并创建一个 `Subscribe` 模块 `./lib/cache/subscriber/index.js`，它消费发布的消息。我们首先导入我们的
    `Redis` 模块，并使用 `util` 模块将 `Subscriber` 模块扩展到 `Redis` 模块中。然后我们定义我们的 `Subscriber`
    模块，它包括一个 `subscribe` 函数。这允许用户订阅 `key` 上的消息：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Populating Redis
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充 Redis
- en: The `./lib/cache/populate.js` script populates a Redis store with new commits/issues
    using our preceding modules. We will demonstrate scheduling this script later
    in the chapter. We start by importing the `Publisher` module, and use `util.inherits`
    to extend the `Publisher` module with a `Populate` function, giving our `Populate`
    module the ability to publish messages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`./lib/cache/populate.js`脚本使用我们前面的模块将新的提交/问题填充到Redis存储中。我们将在本章后面演示如何安排此脚本。我们首先导入`Publisher`模块，并使用`util.inherits`来扩展`Publisher`模块，添加一个`Populate`函数，使我们的`Populate`模块具有发布消息的能力。'
- en: We then define the `Populate` function and add a `run` function, that gets all
    projects from MongoDB. We use `async.each` to loop through each project, using
    the projects `user` and `token` to instantiate a `GitHubRepo` module. We then
    call `git.commits`, passing a list of `repositories`; the response returned is
    a sorted list of the 10 latest commits. We save the response to Redis using `project._id`
    as the key. We then publish the `project._id` and `commits`, via the `publish`
    function to activate a refresh. We then repeat the whole process for `issues`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后定义`Populate`函数并添加一个`run`函数，该函数从MongoDB获取所有项目。我们使用`async.each`遍历每个项目，使用项目的`user`和`token`来实例化一个`GitHubRepo`模块。然后我们调用`git.commits`，传递一个`repositories`列表；返回的是按顺序排列的最近10个提交的列表。我们使用`project._id`作为键将响应保存到Redis中。然后我们通过`publish`函数发布`project._id`和`commits`，以激活刷新。然后我们重复整个过程以处理`issues`。
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Socket.IO
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO
- en: Socket.IO is a real-time application framework that allows for cross-browser,
    real-time communication between a browser and server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO是一个实时应用程序框架，它允许浏览器和服务器之间进行跨浏览器的实时通信。
- en: The lack of browser and server support for the emerging WebSocket standard means
    we cannot easily achieve real-time communication across browsers. In order to
    achieve this, Socket.IO supports multiple transport protocols including WebSockets,
    long polling, XHR, and flashsockets, that function as a fallback mechanism for
    older browsers. Browsers that do not support WebSockets will simply fall back
    to a transport protocol they do support.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器和服务器对新兴的WebSocket标准的支持不足，我们无法轻松地在浏览器之间实现实时通信。为了实现这一点，Socket.IO支持包括WebSockets、长轮询、XHR和flashsockets在内的多种传输协议，这些协议作为旧浏览器的后备机制。不支持WebSockets的浏览器将简单地回退到它们支持的传输协议。
- en: 'Socket.IO comes in two parts: a server-side module and a client-side script.
    Both parts need to be installed in order for our application to support bidirectional
    duplex communication. Let''s install the server piece via NPM:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO由两部分组成：服务器端模块和客户端脚本。为了使我们的应用程序支持双向全双工通信，两部分都需要安装。让我们通过NPM安装服务器部分：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s configure our application to use Socket.IO by updating our `./config/*.json`
    config files with the following configuration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新我们的`./config/*.json`配置文件来配置我们的应用程序使用Socket.IO，如下所示：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step is to wire up Socket.IO to Express. Let''s create and configure
    a typical Socket.IO server: `./lib/socket/index.js`. We define our `Socket` module,
    which accepts a single argument: `server`. We require the `socket.io` module and
    create a new Socket.IO server, passing our Express-enabled HTTP server to it.
    We then configure our Socket.IO server by setting sensible values for `log level`,
    `transports`, and `polling duration`, as defined previously in our config files,
    and return the Socket.IO server.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将Socket.IO连接到Express。让我们创建并配置一个典型的Socket.IO服务器：`./lib/socket/index.js`。我们定义我们的`Socket`模块，它接受一个参数：`server`。我们引入`socket.io`模块并创建一个新的Socket.IO服务器，将我们的Express启用HTTP服务器传递给它。然后我们通过设置合理的`日志级别`、`传输协议`和`轮询持续时间`来配置我们的Socket.IO服务器，这些值在之前的配置文件中已定义，并返回Socket.IO服务器。
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Setting `log level` is useful for debugging. Socket.IO supports the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`日志级别`对调试很有用。Socket.IO支持以下几种：
- en: '`0`: Error'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`: 错误'
- en: '`1`: Warn'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`: 警告'
- en: '`2`: Info'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`: 信息'
- en: '`3`: Debug and defaults to `3`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`: 调试，默认为`3`'
- en: Further information on configuring Socket.IO can be found at:[https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO](https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置Socket.IO的更多信息可以在[https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO](https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO)找到。
- en: Let's now use our Socket.IO server and create a handler for Socket.IO `./lib/socket/handler.js`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用我们的Socket.IO服务器并创建一个Socket.IO处理器`./lib/socket/handler.js`。
- en: We start by importing the `Socket` module, instantiating it, and passing it
    an Express-enabled `httpServer` parameter. We create a Redis `Subscriber` module
    and define a `SocketHandler` function that accepts `httpServer` as input. We set
    up a Socket.IO handler for the connection event. When ready, this will return
    the connected socket.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`Socket`模块，实例化它，并传递一个启用了Express的`httpServer`参数。我们创建一个Redis `Subscriber`模块，并定义一个接受`httpServer`作为输入的`SocketHandler`函数。我们为连接事件设置一个Socket.IO处理程序。当准备就绪时，这将返回已连接的socket。
- en: We then subscribe to two Redis channels—`issues` and `commits`—and define a
    Redis handler for the new message event. This handler broadcasts a channel and
    a message to clients listening on the channel defined by `message.projectId`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们订阅两个Redis频道——`issues`和`commits`——并为新消息事件定义一个Redis处理程序。此处理程序将频道和消息广播到监听由`message.projectId`定义的频道的客户端。
- en: 'We define a Socket.IO `subscribe` handler, which allows a client to join or
    subscribe to events on a given project. We also define a Socket.IO `unsubscribe`
    handler that allows a client to leave or unsubscribe to events on a given project.
    We also define an `error` handler on Socket.IO, which logs any errors to `logger`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个Socket.IO `subscribe`处理程序，允许客户端加入或订阅给定项目的事件。我们还定义了一个Socket.IO `unsubscribe`处理程序，允许客户端离开或取消订阅给定项目的事件。我们还在Socket.IO上定义了一个`error`处理程序，将任何错误记录到`logger`：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can wire up Socket.IO to our `./lib/express/index.js` Express server.
    Let''s import the `SocketHandler` module, passing to it an Express server called
    `httpServer`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将Socket.IO连接到我们的`./lib/express/index.js` Express服务器。让我们导入`SocketHandler`模块，将其传递给一个名为`httpServer`的Express服务器：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Socket.IO on the client
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端的Socket.IO
- en: 'In order to display these Socket.IO published messages, we need to make some
    client changes. Let''s install the Socket.IO client piece using bower:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示这些Socket.IO发布的消息，我们需要对客户端进行一些更改。让我们使用bower安装Socket.IO客户端组件：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s make a single change to our `./lib/express/index.js` Express server
    and simplify the location of our `socket.io-client` using the `static` middleware:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`./lib/express/index.js` Express服务器进行一次性的更改，并简化我们的`socket.io-client`位置，使用`static`中间件：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will now add the Socket.IO client scripts to `./views/index.html`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将Socket.IO客户端脚本添加到`./views/index.html`：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we integrate Socket.IO into our backbone piece. Let''s update our `Backbone.js
    Router`. The router `initialise` method now accepts `socket` as an argument and
    contains two Socket.IO event handlers: one for issues which calls the issues method
    and one for commits which calls the commits method. The join method will now emit
    an Socket.IO `unsubscribe` event unsubscribing the user from any currently subscribed
    projects. It will then emit a Socket.IO `subscribe` event which subscribes the
    user to the newly selected project. The project selected is passed to the join
    method via the `args` parameter.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将Socket.IO集成到我们的backbone组件中。让我们更新我们的`Backbone.js Router`。现在，路由`initialise`方法接受`socket`作为参数，并包含两个Socket.IO事件处理程序：一个用于问题，调用问题方法；一个用于提交，调用提交方法。`join`方法现在将发出一个Socket.IO
    `unsubscribe`事件，取消用户对任何当前已订阅项目的订阅。然后它将发出一个Socket.IO `subscribe`事件，将用户订阅到新选择的项目。所选项目通过`args`参数传递给`join`方法。
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now need to pass an instance of our Socket.IO client to our `Router`. We
    call `io.connect`, create a socket, and pass this into our `Router`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将我们的Socket.IO客户端实例传递给我们的`Router`。我们调用`io.connect`，创建一个socket，并将其传递给我们的`Router`。
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Scheduling Redis population
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度Redis人口统计
- en: The only thing that remains is to create a scheduler that polls our Redis `populate`
    script, `./populate.js`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是创建一个调度器，轮询我们的Redis `populate`脚本，`./populate.js`。
- en: 'First, let''s install a scheduler named `node-schedule` via NPM:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过NPM安装一个名为`node-schedule`的调度程序：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We start by importing `node-schedule`, which allows us to do cron-like scheduling.
    We call `schedule.scheduleJob` every five minutes using `*/5`; however, it will
    also run as soon as the script starts. We then call `populate.run` to start population:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`node-schedule`，它允许我们进行类似于cron的调度。我们使用`*/5`每五分钟调用`schedule.scheduleJob`；然而，它也会在脚本启动时立即运行。然后我们调用`populate.run`来启动人口统计：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to run the application with real-time updates, open a new terminal
    and run the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用实时更新运行应用程序，打开一个新的终端并运行以下命令：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, open another terminal to run the Redis population script.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开另一个终端来运行Redis人口统计脚本。
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We configured the previous script to run every five minutes, so go and add some
    issues/commits to your GitHub project repository in order to see the results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将之前的脚本配置为每五分钟运行一次，因此请前往您的GitHub项目仓库添加一些问题/提交，以便查看结果。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Socket.IO and Redis are powerful tools. We have barely scratched the surface
    of what can be achieved with them. We will revisit Redis and Socket.IO in the
    following chapters of this book as Redis is also used to scale Express sessions
    and the Socket.IOs Pub/Sub mechanism.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 和 Redis 是强大的工具。我们几乎只是触及了它们所能实现的功能的表面。在本书的后续章节中，我们将重新探讨 Redis 和 Socket.IO，因为
    Redis 也被用于扩展 Express 会话和 Socket.IOs 的 Pub/Sub 机制。
- en: The next chapter will focus on securing our application when we implement an
    authentication strategy via GitHub, using Passport, and add SSL support.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于在我们通过 GitHub 使用 Passport 实现身份验证策略并添加 SSL 支持时，如何确保我们的应用程序的安全。
