- en: Chapter 4. Real-time Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application is beginning to take shape. We have a list of projects and
    a form that allows us to add, delete, and update projects. We are also able to
    assign repositories to these projects, which allows us to view a list of issues/commits
    for all repositories in a project. This chapter will guide you through the next
    phase of our client setup: displaying a list of project repository commits and
    issues in real time using Redis and Socket.IO.'
  prefs: []
  type: TYPE_NORMAL
- en: We would ideally like the application to continue working with Socket.IO/Redis
    switched off, leaving the application without a real-time element. We will attempt
    to implement these features with this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is an extremely fast, open source, in-memory key value store. Redis has
    a useful Pub/Sub mechanism that we will use to push messages to a Socket.IO subscriber
    that will emit events to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit this website in order to download and install Redis: [http://redis.io/download](http://redis.io/download).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Redis is installed, you can start it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to start the Redis command-line interface, CLI issues the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands can be issued from the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To monitor activity on Redis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To clear the Redis store:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view all the keys stored in Redis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the value of a key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to use Redis in our application, install the `node-redis` client,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s configure our application to use Redis by updating the`./lib/config/*.json`
    config files with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a simple module, `Redis`, that wraps up the Redis connection
    `./lib/cache/redis.js`. We start by importing the `redis` module. We define a
    `Redis` module, which calls `createClient` in order to create a Redis client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pull in the Redis configuration data from the preceding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's extend our `Redis` module and create a `Publisher` module that will publish
    messages using the Redis Pub/Sub feature, `./lib/cache/publisher/index.js`. We
    start by importing our `Redis` module and use the `util` module to extend the
    `Redis` module with the `Publisher` module. We then define our `Publisher` module,
    which includes a `save` function, which saves an object as a string to Redis and
    a `publish` function, which publishes a message to Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Publisher` module is defined as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we extend our `Redis` module and create a `Subscribe` `r./lib/cache/subscriber/index.js`,
    which consumes published messages. We start by importing our `Redis` module and
    use the `util` module to extend the `Redis` module with the `Subscriber` module.
    We then define our `Subscriber` module, which includes a `subscribe` function.
    This allows the user to subscribe to messages on a `key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Populating Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `./lib/cache/populate.js` script populates a Redis store with new commits/issues
    using our preceding modules. We will demonstrate scheduling this script later
    in the chapter. We start by importing the `Publisher` module, and use `util.inherits`
    to extend the `Publisher` module with a `Populate` function, giving our `Populate`
    module the ability to publish messages.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `Populate` function and add a `run` function, that gets all
    projects from MongoDB. We use `async.each` to loop through each project, using
    the projects `user` and `token` to instantiate a `GitHubRepo` module. We then
    call `git.commits`, passing a list of `repositories`; the response returned is
    a sorted list of the 10 latest commits. We save the response to Redis using `project._id`
    as the key. We then publish the `project._id` and `commits`, via the `publish`
    function to activate a refresh. We then repeat the whole process for `issues`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO is a real-time application framework that allows for cross-browser,
    real-time communication between a browser and server.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of browser and server support for the emerging WebSocket standard means
    we cannot easily achieve real-time communication across browsers. In order to
    achieve this, Socket.IO supports multiple transport protocols including WebSockets,
    long polling, XHR, and flashsockets, that function as a fallback mechanism for
    older browsers. Browsers that do not support WebSockets will simply fall back
    to a transport protocol they do support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Socket.IO comes in two parts: a server-side module and a client-side script.
    Both parts need to be installed in order for our application to support bidirectional
    duplex communication. Let''s install the server piece via NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s configure our application to use Socket.IO by updating our `./config/*.json`
    config files with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to wire up Socket.IO to Express. Let''s create and configure
    a typical Socket.IO server: `./lib/socket/index.js`. We define our `Socket` module,
    which accepts a single argument: `server`. We require the `socket.io` module and
    create a new Socket.IO server, passing our Express-enabled HTTP server to it.
    We then configure our Socket.IO server by setting sensible values for `log level`,
    `transports`, and `polling duration`, as defined previously in our config files,
    and return the Socket.IO server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `log level` is useful for debugging. Socket.IO supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: Error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Warn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: Info'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: Debug and defaults to `3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further information on configuring Socket.IO can be found at:[https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO](https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now use our Socket.IO server and create a handler for Socket.IO `./lib/socket/handler.js`.
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the `Socket` module, instantiating it, and passing it
    an Express-enabled `httpServer` parameter. We create a Redis `Subscriber` module
    and define a `SocketHandler` function that accepts `httpServer` as input. We set
    up a Socket.IO handler for the connection event. When ready, this will return
    the connected socket.
  prefs: []
  type: TYPE_NORMAL
- en: We then subscribe to two Redis channels—`issues` and `commits`—and define a
    Redis handler for the new message event. This handler broadcasts a channel and
    a message to clients listening on the channel defined by `message.projectId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a Socket.IO `subscribe` handler, which allows a client to join or
    subscribe to events on a given project. We also define a Socket.IO `unsubscribe`
    handler that allows a client to leave or unsubscribe to events on a given project.
    We also define an `error` handler on Socket.IO, which logs any errors to `logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can wire up Socket.IO to our `./lib/express/index.js` Express server.
    Let''s import the `SocketHandler` module, passing to it an Express server called
    `httpServer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Socket.IO on the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to display these Socket.IO published messages, we need to make some
    client changes. Let''s install the Socket.IO client piece using bower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a single change to our `./lib/express/index.js` Express server
    and simplify the location of our `socket.io-client` using the `static` middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now add the Socket.IO client scripts to `./views/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we integrate Socket.IO into our backbone piece. Let''s update our `Backbone.js
    Router`. The router `initialise` method now accepts `socket` as an argument and
    contains two Socket.IO event handlers: one for issues which calls the issues method
    and one for commits which calls the commits method. The join method will now emit
    an Socket.IO `unsubscribe` event unsubscribing the user from any currently subscribed
    projects. It will then emit a Socket.IO `subscribe` event which subscribes the
    user to the newly selected project. The project selected is passed to the join
    method via the `args` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now need to pass an instance of our Socket.IO client to our `Router`. We
    call `io.connect`, create a socket, and pass this into our `Router`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling Redis population
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only thing that remains is to create a scheduler that polls our Redis `populate`
    script, `./populate.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s install a scheduler named `node-schedule` via NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by importing `node-schedule`, which allows us to do cron-like scheduling.
    We call `schedule.scheduleJob` every five minutes using `*/5`; however, it will
    also run as soon as the script starts. We then call `populate.run` to start population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run the application with real-time updates, open a new terminal
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, open another terminal to run the Redis population script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We configured the previous script to run every five minutes, so go and add some
    issues/commits to your GitHub project repository in order to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO and Redis are powerful tools. We have barely scratched the surface
    of what can be achieved with them. We will revisit Redis and Socket.IO in the
    following chapters of this book as Redis is also used to scale Express sessions
    and the Socket.IOs Pub/Sub mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on securing our application when we implement an
    authentication strategy via GitHub, using Passport, and add SSL support.
  prefs: []
  type: TYPE_NORMAL
