<html><head></head><body>
        

                            
                    <h1 class="header-title">Immutability, Optics, and Laziness</h1>
                
            
            
                
<p>In the preceding chapters, we learned the most fundamental functional programming techniques and patterns, including some of the most commonly known algebraic data types.</p>
<p class="mce-root">In this chapter, we are going to learn about a number of additional functional programming techniques and patterns, including the following:</p>
<ul>
<li>Immutability</li>
<li>Optics</li>
<li>Lenses</li>
<li>Prims</li>
<li>Lazy evaluation</li>
</ul>
<p>Once more, we will try to build everything from scratch, trying to avoid the use of third-party libraries. Our goal is to take a look at the internal implementation of some of these techniques and patterns so we can fully understand how they work. Let's get started!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Immutability</h1>
                
            
            
                
<p>In this section, we are going to learn about immutable data structures. An immutable data structure is an object that doesn't allow us to change its value. The easiest way to implement an immutable data structure in TypeScript is to use classes and the <kbd>readonly</kbd> keyword:</p>
<pre>class Person {<br/><br/>    public readonly name: string;<br/>    public readonly age: number;<br/><br/>    public constructor(name: string, age: number) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/><br/>}<br/><br/>const person = new Person("Remo", 29);<br/>person.age = 30; // Error<br/>person.name = "Remo Jansen"; // Error</pre>
<p>The preceding code snippet declares a class named <kbd>Person</kbd>. The class has two public properties, named <kbd>name</kbd> and <kbd>age</kbd>. These two properties have been flagged as <kbd>readonly</kbd>. As we can see in the code snippet, when we try to update the values of the class properties, a compilation error is thrown.</p>
<p>The <kbd>readonly</kbd> properties can make our code more secure because it protects us from state mutations. For example, if we pass some immutable objects to a function as its arguments, the function will not be able to mutate the original objects. This means that our function will be more likely to be a pure function. However, not everything is good about immutable objects. Working with immutable objects can sometimes feel very tedious and verbose, particularly when we wish to generate a new state. Let's take a look at an example:</p>
<pre>class Street {<br/><br/>    public readonly num: number;<br/>    public readonly name: string;<br/><br/>    public constructor(num: number, name: string) {<br/>        this.num = num;<br/>        this.name = name;<br/>    }<br/><br/>}<br/><br/>class Address {<br/><br/>    public readonly city: string;<br/>    public readonly street: Street;<br/><br/>    public constructor(city: string, street: Street) {<br/>        this.city = city;<br/>        this.street = street;<br/>    }<br/><br/>}<br/><br/>class Company {<br/><br/>    public readonly name: string;<br/>    public readonly addresses: Address[];<br/><br/>    public constructor(name: string, addresses: Address[]) {<br/>        this.name = name;<br/>        this.addresses = addresses;<br/>    }<br/><br/>}</pre>
<p>The preceding code snippet declares three classes named <kbd>Street</kbd>, <kbd>Address</kbd>, and <kbd>Company</kbd>. All the properties in the three classes are <kbd>readonly</kbd>, which means that the classes are immutable. We can create a new instance of the <kbd>Company</kbd> class as follows:</p>
<pre>const company1 = new Company(<br/>   "Facebook",<br/>   [<br/>       new Address(<br/>           "London",<br/>           new Street(1, "rathbone square")<br/>       ),<br/>       new Address(<br/>           "Dublin",<br/>           new Street(5, "grand canal square")<br/>       )<br/>   ]<br/>);</pre>
<p>When we say that an object is immutable, it means that we cannot change the original object, but it doesn't mean that we don't want to create derivative versions of it. For example, if we try to create a new version of a <kbd>Company</kbd> by transforming its street name into upper case, we will get an error, as shown in the following code snippet:</p>
<pre>company1.addresses = company1.addresses.map(a =&gt; R.toUpper(a.street.name)); // Error</pre>
<p>However, we might need to generate a new version with an uppercase street name. We can generate an updated version of the <kbd>Company</kbd> instance by creating a new <kbd>Company</kbd> instance. To create a new copy, we need to copy all the properties from the original instance into a new instance and use new values for the properties that we wish to mutate:</p>
<pre>const company2 = new Company(<br/>   company1.name,<br/>   company1.addresses.map((a) =&gt;<br/>       new Address(<br/>           a.city,<br/>           new Street(<br/>               a.street.num,<br/>               R.toUpper(a.street.name)<br/>           )<br/>       )<br/>   )<br/>);</pre>
<p>Immutable data structures can help us to implement pure functions and make our code free of side effects. Mutating external variables is one of the most common causes of side effects, and using immutable data structures can help us to prevent such a mutation.</p>
<p>Please note that you can refer to <a href="65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml" target="_blank">Chapter 1</a>, <em>Functional Programming Fundamentals</em>, to learn more about side effects.</p>
<p>However, as we can see in the previous code snippet, immutable data structures also have a negative side: they can lead to verbose and tedious code. The good news is that the minds behind the functional programming paradigm have found a solution to this problem known as <strong>optics</strong>. We are going to learn about optics in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optics</h1>
                
            
            
                
<p>Optics is a functional programming concept that can help us to reduce the amount of code that we need to write and make operations more readable. The benefits of using optics are particularly noticeable when we are working with immutable data structures. All optics are a way to get and set properties in an object. In fact, we can think about optics as an alternative to getters and setters in object-oriented programming.</p>
<p>Optics can be categorized into two main groups—<strong>lenses</strong> and <strong>prisms</strong>. As we learned in <a href="ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml" target="_blank">Chapter 7</a>, <em>Category Theory</em>, algebraic data types can be defined in terms of sum and product types. A lens is used to work with product types (for example, tuples and objects) and a prism is used to work with sum types (for example, discriminated unions). During the remainder of this section, we are going to focus on the use of lenses.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Lenses</h1>
                
            
            
                
<p>A lens is just a pair of functions that allow us to get and set a value in an object. The interface of a lens could be declared as follows:</p>
<pre>interface Lens&lt;T1, T2&gt; {<br/>    get(o: T1): T2;<br/>    set(o: T2, v: T1): T1;<br/>}</pre>
<p>As we can see in the previous code snippet, the lens generic interface declares two methods. The <kbd>get</kbd> method can be used to get the value of a property of type <kbd>T2</kbd> in an object of type <kbd>T1</kbd>. The <kbd>set</kbd> method can be used for the value of a property with type <kbd>T2</kbd> in an object of type <kbd>T1</kbd>. The following code snippet implements the <kbd>Lens</kbd> interface: </p>
<pre>const streetLens: Lens&lt;Address, Street&gt; = {<br/>    get: (o: Address) =&gt; o.street,<br/>    set: (v: Street, o: Address) =&gt; new Address(o.city, v)<br/>};</pre>
<p>The preceding implementation of the <kbd>Lens</kbd> interface is named <kbd>streetLens</kbd> and it allows us to set the value of a property with the <kbd>Street</kbd> type in an object of type <kbd>Object</kbd>. We can use the <kbd>streetLens</kbd> object to get the <kbd>Street</kbd> instance in an <kbd>Address</kbd> instance:</p>
<pre>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const street = streetLens.get(address);</pre>
<p>We can also use the <kbd>Lens</kbd> implementation to set the <kbd>Street</kbd> instance in the <kbd>Address</kbd> instance:</p>
<pre>const address2 = streetLens.set(<br/>    new Street(<br/>        address.street.num,<br/>        R.toUpper(address.street.name)<br/>    ),<br/>    address<br/>);</pre>
<p>It is important to note that the <kbd>set</kbd> method updates the <kbd>Street</kbd> instance and returns a new <kbd>Address</kbd> instance, as opposed to mutating the original <kbd>Address</kbd> instance. Now that we know the basics of how lenses work, we are going to take a look at some of the properties.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>One of the main characteristics of lenses is that they can be composed. As we learned in the preceding chapters, function composition is one of the main techniques in functional programming, and lenses are just functions, so they can be composed in a very similar way. The following code snippet declares a higher-order function that allows us to compose two lenses:</p>
<pre>function composeLens&lt;A, B, C&gt;(<br/>    ab: Lens&lt;A, B&gt;,<br/>    bc: Lens&lt;B, C&gt;<br/>): Lens&lt;A, C&gt; {<br/>    return {<br/>        get: (a: A) =&gt; bc.get(ab.get(a)),<br/>        set: (c: C, a: A) =&gt; ab.set(bc.set(c, ab.get(a)), a)<br/>    };<br/>}</pre>
<p>Now that we have declared a higher-order function that allows us to compose lenses, we are going to compose two lenses named <kbd>streetLens</kbd> and <kbd>nameLens</kbd>:</p>
<pre>const streetLens: Lens&lt;Address, Street&gt; = {<br/>    get: (o: Address) =&gt; o.street,<br/>    set: (v: Street, o: Address) =&gt; new Address(o.city, v)<br/>};<br/><br/>const nameLens: Lens&lt;Street, string&gt; = {<br/>    get: (o: Street) =&gt; o.name,<br/>    set: (v: string, o: Street) =&gt; new Street(o.num, v)<br/>};<br/><br/>const streetNameLens = composeLens(streetLens, nameLens);</pre>
<p>The return of the <kbd>composeLens</kbd> function creates a new lens named <kbd>streetName</kbd>. The new lens can be used to get the name of a <kbd>Street</kbd> instance within an <kbd>Address</kbd> instance:</p>
<pre>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const streetName = streetNameLens.get(address);</pre>
<p>The lens can also be used to create a new <kbd>Address</kbd> instance with an updated <kbd>Street</kbd> name:</p>
<pre>const address2 = streetNameLens.set(R.toUpper(address.street.name), address);</pre>
<p class="mce-root"/>
<p>Many functional programming libraries also implement a function that allows us to map a given property in an object to a new value using a lens. The function is sometimes named <kbd>over</kbd>, but we are going to name it <kbd>overLens</kbd> to be clearer:</p>
<pre>function overLens&lt;S, A&gt;(<br/>    lens: Lens&lt;S, A&gt;,<br/>    func: (a: A) =&gt; A,<br/>    s: S<br/>): S {<br/>    return lens.set(func(lens.get(s)), s)<br/>}</pre>
<p>The preceding function takes a lens as its first argument, a mapping function as its second argument, and an object as its third argument. The function uses the lens to focus and update one of the properties of the objects using the mapping function:</p>
<pre>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const address2 = overLens(streetNameLens, R.toUpper, address);</pre>
<p>As you can see, generating new versions of immutable objects using lenses can be much less verbose and tedious than using standard property accessors and class constructors. Now that we know the basics about lenses, we are going to implement some lenses again. The previous implementation was simplified to facilitate understanding. This time however, we are going to implement lenses in a way that is closer to the implementation of some popular libraries such as Ramda.</p>
<p>This time, we are going to declare two functions that are used as a getter and a setter. The function that is used as a getter is going to implement an interface named <kbd>Prop</kbd>. On the other hand, the function used as a setter is going to implement an interface named <kbd>Assoc</kbd>. The signature of the <kbd>Prop</kbd> and <kbd>Assoc</kbd> interfaces appears as follows:</p>
<pre>type Prop&lt;T, K extends keyof T&gt; = (o: T) =&gt; T[K];<br/>type Assoc&lt;T, K extends keyof T&gt; = (v: T[K], o: T) =&gt; T;</pre>
<p class="mce-root"/>
<p>The following code snippet declares functions that implement the <kbd>Prop</kbd> and <kbd>Assoc</kbd> interfaces. Both implementations are used to access a property named <kbd>street</kbd> in an object of type <kbd>Address</kbd>:</p>
<pre>const propStreet: Prop&lt;Address, "street"&gt; = (o: Address) =&gt; o.street;<br/><br/>const assocStreet: Assoc&lt;Address, "street"&gt; = (v: Address["street"], o: Address) =&gt; {<br/>    return new Address(o.city, v);<br/>};</pre>
<p>One of the main differences in the new implementation is that we are going to declare a higher-order function named <kbd>lens</kbd>, and we are going to use it to generate a lens instance. The <kbd>lens</kbd> function takes two functions, a getter and a setter, which implement the <kbd>Prop</kbd> and <kbd>Assoc</kbd> interfaces accordingly. The lens function then returns an implementation of the <kbd>Lens</kbd> interface:</p>
<pre>const lens = &lt;T1, K extends keyof T1&gt;(<br/>    getter: Prop&lt;T1, K&gt;,<br/>    setter: Assoc&lt;T1, K&gt;,<br/>): Lens&lt;T1, T1[K]&gt; =&gt; {<br/>    return {<br/>        get: (obj: T1) =&gt; getter(obj),<br/>        set: (val: T1[K], obj: T1) =&gt; setter(val, obj),<br/>    };<br/>}</pre>
<p>At this point, we can invoke the <kbd>lens</kbd> function using the getter function, <kbd>propStreet</kbd>,  and the setter function, <kbd>assocStreet</kbd>, that we declared previously:</p>
<pre>const streetLens = lens(propStreet, assocStreet);</pre>
<p class="mce-root">Another significant difference is that the new implementation uses two more functions, named <kbd>view</kbd> and <kbd>set</kbd>, as the getter and setter respectively. Both the <kbd>view</kbd> and <kbd>set</kbd> functions take a lens instance:</p>
<pre>const view = &lt;T1, T2&gt;(lens: Lens&lt;T1, T2&gt;, obj: T1) =&gt; lens.get(obj);<br/><br/>const set = &lt;T1, K extends keyof T1&gt;(<br/>    lens: Lens&lt;T1, T1[K]&gt;,<br/>    val: T1[K],<br/>    obj: T1<br/>) =&gt; lens.set(val, obj);</pre>
<p class="mce-root"/>
<p>The preceding functions use the lens <kbd>get</kbd> and <kbd>set</kbd> methods internally. However, we will use the <kbd>view</kbd> and <kbd>set</kbd> functions instead. The following code snippet demonstrates how to use the <kbd>view</kbd> function to get the <kbd>Street</kbd> instance within an <kbd>Address</kbd> instance:</p>
<pre>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const street = view(streetLens, address);</pre>
<p>The following code snippet demonstrates how to use the set function to set the value of the <kbd>Street</kbd> instance within an <kbd>Address</kbd> instance:</p>
<pre>const address2 = set(<br/>    streetLens,<br/>    new Street(<br/>        address.street.num,<br/>        R.toUpper(address.street.name)<br/>    ),<br/>    address<br/>);</pre>
<p class="mce-root">In this section, we have learned the basics regarding lenses. In the following section, we are going to learn about another kind of functional optic, known as <strong>prisms</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Prisms</h1>
                
            
            
                
<p>Prisms are almost identical to lenses. We can think about a prism as a kind of lens that allows us to get and set an optional property in an object. The most significant difference between lenses and prisms is that prisms can work with optional types.</p>
<p>The following code snippet declares the <kbd>Prism</kbd> interface. As we can see, the <kbd>Prism</kbd> interface is very similar to the <kbd>Lens</kbd> interface. However, the <kbd>get</kbd> method returns an optional type, <kbd>Maybe&lt;T&gt;</kbd>:</p>
<pre>type Maybe&lt;T&gt; = T | null;<br/><br/>interface Prism&lt;T1, T2&gt; {<br/>    get(o: T1): Maybe&lt;T2&gt;,<br/>    set(a: T2, o: T1): T1;<br/>}</pre>
<p class="mce-root">Just like lenses, prisms can be composed. The following code snippet declares a higher-order function that allows us to compose two prisms:</p>
<pre>function composePrism&lt;A, B, C&gt;(ab: Prism&lt;A, B&gt;, bc: Prism&lt;B, C&gt;): Prism&lt;A, C&gt; {<br/>    return {<br/>        get: (a: A) =&gt; {<br/>            const b = ab.get(a)<br/>            return b == null ? null : bc.get(b)<br/>        },<br/>        set: (c: C, a: A) =&gt; {<br/>            const b = ab.get(a)<br/>            return b == null ? a : ab.set(bc.set(c, b), a)<br/>        }<br/>    }<br/>}</pre>
<p>The preceding function takes two prisms, <kbd>ab</kbd> with type <kbd>Prism&lt;A, B&gt;</kbd>, and <kbd>bc</kbd> with type <kbd>Prism&lt;B, C&gt;</kbd>, and returns the composition of both prisms with type <kbd>Prism&lt;A, C&gt;</kbd>.</p>
<p>Prisms also allow us to implement a function that allows us to map a property given an object and a prism. The function is usually named <kbd>over</kbd> in real-world libraries but, just as we did in the section about lenses, we are going to name it <kbd>overPrism</kbd> for clarity:</p>
<pre>function overPrism&lt;S, A&gt;(<br/>    prism: Prism&lt;S, A&gt;,<br/>    func: (a: A) =&gt; A,<br/>    s: S<br/>): S {<br/>    const a = prism.get(s)<br/>    return a ? prism.set(func(a), s) : s<br/>}</pre>
<p>In the preceding snippet, we have declared the main building blocks required to work with prisms, including the <kbd>Prism</kbd> interface and the <kbd>composePrism</kbd> and <kbd>overPrism</kbd> functions. In the following section, we are going to demonstrate how to use a <kbd>prism</kbd> named <kbd>firstCharacterPrism</kbd> to focus on the first character of an optional string. The code snippet also declares a <kbd>prism</kbd> to access the <kbd>street</kbd> property in an <kbd>Address</kbd> instance and the <kbd>name</kbd> property in a <kbd>Street</kbd> instance.</p>
<p class="mce-root"/>
<p>The <kbd>composePrism</kbd> is then used to compose the three <kbd>firstCharacterPrism</kbd>, <kbd>streetPrism</kbd>, and <kbd>namePrism</kbd> prisms into a new prism named <kbd>streetNameFirstCharater</kbd>. Finally, the <kbd>overPrism</kbd> function is used to map the value selected by <kbd>streetNameFirstCharacter</kbd> using the <kbd>R.toUpper</kbd> function. The result is a new instance of <kbd>Address</kbd> that contains a new instance of <kbd>Street</kbd> with a capitalized name. If the name is <kbd>null</kbd>, the new <kbd>Street</kbd> instance will contain <kbd>null</kbd> as its <kbd>name</kbd>:</p>
<pre>const firstCharacterPrism: Prism&lt;string, string&gt; = {<br/>    get: s =&gt; s ? s.substring(0, 1) : null,<br/>    set: (a, s) =&gt; s.length ? a + s.substring(1) : ""<br/>}<br/><br/>const streetPrism: Prism&lt;Address, Street&gt; = {<br/>    get: (o: Address) =&gt; o.street,<br/>    set: (v: Street, o: Address) =&gt; new Address(o.city, v)<br/>};<br/><br/>const namePrism: Prism&lt;Street, string&gt; = {<br/>    get: (o: Street) =&gt; o.name,<br/>    set: (v: string, o: Street) =&gt; new Street(o.num, v)<br/>};<br/><br/>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const streetNameFirstCharacterPrism = composePrism(<br/>    composePrism(streetPrism, namePrism),<br/>    firstCharacterPrism<br/>);<br/><br/>const address2 = overPrism(streetNameFirstCharacterPrism, R.toUpper, address);</pre>
<p>Prisms are also useful when we want to work with other kinds of optional types, such as discriminated unions like the <kbd>Either</kbd> type:</p>
<pre>type Either&lt;T1, T2&gt; = T1 | T2;<br/><br/>type Domicile = Either&lt;<br/>    { type: "office", address: Address },<br/>    { type: "personal", address: string }<br/>&gt;;<br/><br/>const addressPrism: Prism&lt;Domicile, Address&gt; = {<br/>    get: d =&gt; d.type === "office" ? d.address : null,<br/>    set: (address, d) =&gt; d.type === "office" ? { type: "office", address } : d<br/>}</pre>
<p>The preceding code snippet declares an optional type named <kbd>Either</kbd> and a type named <kbd>Domicile</kbd>, which uses the <kbd>Either</kbd> type to declare the union of two types. The code snippet also declares a <kbd>prism</kbd> named <kbd>addressPrism</kbd> that allows us to get or set the property <kbd>address</kbd> in an object of type <kbd>Domicile</kbd>. The property <kbd>address</kbd> can either be a <kbd>string</kbd> or an <kbd>Address</kbd> instance, and the <kbd>addressPrism</kbd> can handle both cases, as demonstrated by the following code snippet:</p>
<pre>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const domicile1: Domicile = { type: "office", address: address };<br/>const domicile2: Domicile = { type: "personal", address: "23 high street" };<br/><br/>const address1 = addressPrism.get(domicile1);<br/>const address2 = addressPrism.get(domicile2);</pre>
<p>At this point, we should understand the main characteristics of both lenses and prisms. In this chapter, we have created our own implementations of lenses and prisms because our main goal was to understand how they work. However, using a custom implementation is not recommended for professional software development projects. In <a href="35e51290-b4e7-44e8-bc7f-b9fbbe3bc94c.xhtml" target="_blank">Chapter 10</a>, <em>Real-World Functional Programming</em>, we will learn how to use production-ready optics with Ramda.</p>
<p>In the following section, we are going to learn about lazy evaluation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Laziness</h1>
                
            
            
                
<p>Lazy evaluation is a technique or pattern that delays the evaluation of an expression until its value is needed. We are going to take a look at an example that doesn't use lazy evaluation first so that we can compare it with one that uses lazy evaluation later.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following code snippet declares an interface named <kbd>Dog</kbd> and an array of <kbd>Dog</kbd> that contains ten items. The <kbd>Dog</kbd> instances have two properties, named <kbd>size</kbd> and <kbd>name</kbd>. The code snippet also declares two functions, named <kbd>isLarge</kbd> and <kbd>isOld</kbd>. The <kbd>isLarge</kbd> function is used to find the <kbd>Dog</kbd> instances, with their <kbd>size</kbd> being equal to <kbd>"L"</kbd>. The <kbd>isOld</kbd> function is used to find the <kbd>Dog</kbd> instances with an <kbd>age</kbd> greater than <kbd>5</kbd>:</p>
<pre>interface Dog {<br/>   size: "L" | "S";<br/>   age: number;<br/>   name: string;<br/>}<br/><br/>const dogs: Dog[] = [<br/>   { size: "S", age: 4, name: "Alice" },<br/>   { size: "L", age: 2, name: "Bob", },<br/>   { size: "S", age: 7, name: "Carol" },<br/>   { size: "L", age: 6, name: "Dan" },<br/>   { size: "L", age: 2, name: "Eve" },<br/>   { size: "S", age: 2, name: "Frank" },<br/>   { size: "S", age: 1, name: "Grant" },<br/>   { size: "S", age: 9, name: "Hans" },<br/>   { size: "L", age: 8, name: "Inga" },<br/>   { size: "L", age: 4, name: "Julia" }<br/>];<br/><br/>const isLarge = (dog: Dog) =&gt; dog.size === "L";<br/>const isOld = (dog: Dog) =&gt; dog.age &gt; 5;<br/>dogs.filter(isLarge).find(isOld); // Dan</pre>
<p>The preceding code snippet uses the array methods, <kbd>filter</kbd> and <kbd>find</kbd>. The <kbd>filter</kbd> method iterates all the elements in the <kbd>dogs</kbd> array. The result of filtering all the <kbd>Dog</kbd> instances using the <kbd>isLarge</kbd> function is a new array with five elements (all the elements with a <kbd>size</kbd> equal to <kbd>"L"</kbd>). We then use the <kbd>find</kbd> method to search a <kbd>Dog</kbd> instance in the new array using the <kbd>isOld</kbd> function. The <kbd>find</kbd> method iterates two items before the first item with an <kbd>age</kbd> greater than <kbd>5</kbd> is found. The final result is that we need to iterate 12 items before we can find an item that matches both the <kbd>isLarge</kbd> and <kbd>isOld</kbd> constraints.</p>
<p>Lazy evaluation is a technique that delays the execution of some operations until they can no longer be delayed. Lazy evaluation can sometimes lead to performance gains.</p>
<p class="mce-root"/>
<p>The following code snippet implements a function named <kbd>filter</kbd> and a function named <kbd>find</kbd>. Both functions are the equivalent of the array <kbd>filter</kbd> and <kbd>find</kbd> methods respectively. However, the <kbd>filter</kbd> function uses a generator (<kbd>function*</kbd>) and the <kbd>find</kbd> function uses a <kbd>for ... of</kbd> statement, which is used to iterate the items returned by the iterator created by the preceding generator:</p>
<pre>const filter = &lt;T&gt;(f: (item: T) =&gt; boolean) =&gt; {<br/>   return function* (arr: T[]) {<br/>       for (const item of arr) {<br/>           if (f(item)) {<br/>               yield item;<br/>           }<br/>       }<br/>   };<br/>};<br/><br/>const find = &lt;T&gt;(f: (item: T) =&gt; boolean) =&gt;(arr: IterableIterator&lt;T&gt;) =&gt; {<br/>   for (const item of arr) {<br/>       if (f(item)) {<br/>           return item;<br/>       }<br/>   }<br/>};</pre>
<p>Please remember that using iterators requires the compilation setting <kbd>downlevelIteration</kbd> to be true in the <kbd>tsconfig.json</kbd> file. Please refer to <a href="3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml" target="_blank">Chapter 3</a>,<em> Mastering Asynchronous</em> <em>Programming</em>, if you need additional help with generators.</p>
<p>The code snippet uses the <kbd>compose</kbd> function from Ramda to compose the return of <kbd>find(isOld)</kbd> and <kbd>filter(isLarge)</kbd>. The result is a new function named <kbd>findLargeOldDog</kbd>. We can use this function to find the <kbd>Dog</kbd> instances in the <kbd>dogs</kbd> array that matches both the <kbd>isLarge</kbd> and <kbd>isOld</kbd> constraints:</p>
<pre>const findLargeOldDog = R.compose(find(isOld), filter(isLarge));<br/>findLargeOldDog(dogs);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The result of this function is identical to the result of the example that didn't use lazy evaluation. However, this example only iterates four items instead of twelve. This is the case because when we execute the filter function, filtering doesn't take place. We delay its evaluation by returning an iterator. The evaluation is delayed until the iterator's <kbd>next</kbd> method is invoked by the <kbd>for ... of</kbd> statement. The find function iterates one item at a time and invokes both the <kbd>isOld</kbd> and <kbd>isLarge</kbd> functions, one item at a time. When the iterator returns the fourth item, it matches both the <kbd>isLarge</kbd> and <kbd>isOld</kbd> constraints and no more items need to be iterated. The lazy evaluated version is therefore much more efficient.</p>
<p>In the preceding example, we have used generators and iterators to implement lazy evaluation, but this is not the only way to implement lazy evaluation. Lazy evaluation can be implemented using several JavaScript APIs, such as proxies or promises.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned how we can leverage functional programming techniques, such as lazy evaluation and immutability, to prevent some potential issues. We have also learned how to use optics to be able to work with immutable objects in a less verbose and tedious way.</p>
<p>In the next chapter, we are going to learn about <strong>Functional Reactive Programming</strong> (<strong>FRP</strong>). We will learn what reactive programming is and how it is connected to functional programming.</p>


            

            
        
    </body></html>