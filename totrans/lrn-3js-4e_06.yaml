- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Advanced Geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), *Learning to Work with Geometries*,
    we showed you all the basic geometries provided by Three.js. Besides these basic
    geometries, Three.js also offers a set of more advanced and specialized objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll show you these advanced geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use advanced geometries such as `THREE.ConvexGeometry`, `THREE.LatheGeometry`,
    `THREE.BoxLineGeometry`, `THREE.RoundeBoxGeometry`, `THREE.TeapotGeometry`, and
    `THREE.TubeGeometry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create 3D shapes from 2D shapes using `THREE.ExtrudeGeometry`. We’ll
    create a 3D shape from a 2D SVG image, and we will extrude from 2D Three.js shapes
    to create novel 3D shapes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to create custom shapes yourself, you can continue playing with
    the ones we’ve discussed in the previous chapters. Three.js, however, also offers
    a `THREE.ParametricGeometry` object. With parametric geometry, you can create
    geometry with parameters you can change to effect the shape of the geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll also show how you can create 3D text effects using `THREE.TextGeometry`,
    and show you how to use the Troika library for when you want to add 2D text labels
    to your scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we’ll show you how you can use two helper geometries, `THREE.WireframeGeometry`
    and `THREE.EdgesGeometry`. These helpers allow you to see more details about other
    geometries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with the first one from this list, `THREE.ConvexGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning advanced geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at a number of advanced Three.js geometries. We
    will start with `THREE.ConvexGeometry`, which you can use to create convex hulls.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.ConvexGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `THREE.ConvexGeometry`, we can create a convex hull from a set of points.
    A convex hull is the minimal shape that encompasses all these points. The easiest
    way to understand this is by looking at an example. If you open up the `convex-geometry.html`
    example, you’ll see the convex hull for a random set of points. The following
    screenshot shows this geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The convex hull encompassing all the points](img/Figure_6.1_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The convex hull encompassing all the points
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we generate a random set of points, and based on these points,
    we create `THREE.ConvexGeometry`. In the example, you can use the `1` to see the
    points that are used to create this geometry. These points are created as small
    `THREE.SphereGeometry` objects for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `THREE.ConvexGeometry`, we need a set of points. The following code
    fragment shows how we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this snippet of code, we create 20 random points (`THREE.Vector3`),
    which we push into an array. Next, we iterate this array and create `THREE.SphereGeometry`,
    whose position we set to one of these points (`position.copy(point)`). All the
    points are added to a group, so we can easily replace them once we do a redraw.
    Once you have this set of points, creating a `THREE.ConvexGeometry` from them
    is very easy, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An array containing vertices (of the `THREE.Vector3` type) is the only argument
    `THREE.ConvexGeometry` takes. Note that if you want to render a smooth `THREE.ConvexGeometry`,
    you should call `computeVertexNormals`, as we explained in [*Chapter 2*](B18726_02.xhtml#_idTextAnchor028),
    *The Basic Components that Make up a* *Three.js Application*.
  prefs: []
  type: TYPE_NORMAL
- en: The next complex geometry is `THREE.LatheGeometry`, which, for example, can
    be used to create vase-like shapes.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.LatheGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.LatheGeometry` allows you to create shapes from a set of points that
    together form a curve. If you look at *Figure 6**.2*, you can see that we created
    a number of points (the red dots), which Three.js uses to create `THREE.LatheGeometry`.
    Once again, the easiest way to understand what `THREE.LatheGeometry` looks like
    is by looking at an example. This geometry is shown in `lathe-geometry.html`.
    The following screenshot taken from the example shows this geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – A lathe for vase-like meshes](img/Figure_6.2_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – A lathe for vase-like meshes
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can see the points used to create this geometry
    as a set of small red spheres. The positions of these points are passed into `THREE.LatheGeometry`,
    together with arguments that define the shape of the geometry. Before we look
    at all the arguments, let’s look at the code used to create the individual points
    and how `THREE.LatheGeometry` uses these points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this piece of JavaScript, we can see that we generate 25 points whose *x*
    coordinate is based on a combination of sine and cosine functions, while the *y*
    coordinate is based on the `i` and `count` variables. This creates a spline visualized
    by the red dots in the preceding screenshot. Based on these points, we can create
    `THREE.LatheGeometry`. Besides the array of vertices, `THREE.LatheGeometry` takes
    a couple of other arguments. The following list explains these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`points`: These are the points that make up the spline used to generate the
    bell/vase shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`segments`: These are the number of segments used when creating the shape.
    The higher this number, the more round and smooth the resulting shape will be.
    The default value for this is `12`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phiStart`: This determines where to start on a circle when generating the
    shape. This can range from `0` to `2*PI`. The default value is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phiLength`: This defines how fully generated the shape is. For instance, a
    quarter shape will be `0.5*PI`. The default value is the full 360 degrees or `2*PI`.
    This shape will start at the position of the `phiStart` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), we’ve already seen `BoxGeometry`.
    Three.js also provides two other box-like geometries, which we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: BoxLineGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you just want to show the outline, you can use `THREE.BoxLineGeometry`.
    This geometry works exactly like `THREE.BoxGeometry`, but instead of rendering
    a solid object, it renders the box using lines like this (from `box-line-geometry.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – A box rendered using lines](img/Figure_6.3_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – A box rendered using lines
  prefs: []
  type: TYPE_NORMAL
- en: 'You use this geometry in the same way as `THREE.BoxGeometry`, but instead of
    creating `THREE.Mesh`, we need to create `THREE.LineSegments`, using one of the
    available line-specific materials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For an explanation of the properties you can pass into this geometry, refer
    to the `THREE.BoxGeometry` section of [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081).
  prefs: []
  type: TYPE_NORMAL
- en: Three.js also provides a slightly more advanced `THREE.BoxGeometry`, where you
    can have nicely rounded corners. You can do this with `RoundedBoxGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.RoundedBoxGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This geometry uses the same properties as `THREE.BoxGeometry`, but it also
    allows you to specify how round the corners should be. In the `rounded-box-geometry`
    example, you can see how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – A box with rounded corners](img/Figure_6.4_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – A box with rounded corners
  prefs: []
  type: TYPE_NORMAL
- en: 'For this geometry, we can specify the dimensions of the box by specifying `width`,
    `height`, and `depth`. Besides these properties, this geometry provides two additional
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`radius`: This is the size of the rounded corners. The higher this value, the
    more rounded the corners will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`segments`: This property defines how detailed the corners will be. If this
    is set to a low value, Three.js will use fewer vertices for the definition of
    the rounded corners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we move on to showing how you can create 3D geometries from a 2D object,
    we’ll look at the final geometry provided by Three.js, `TeapotGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: TeapotGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TeapotGeometry` is a geometry that you can use to render, not very surprisingly,
    a teapot. This teapot is a standard reference model for 3D renders and has been
    used since 1975\. More information on the history of this model can be found here:
    [https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206](https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this model works in exactly the same way as all the other models we’ve
    seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You specify the specific properties and then create the geometry, which you
    assign to `THREE.Mesh`. The result, depending on the properties, looks like this
    (in the `teapot-geometry.html` example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The Utah teapot](img/Figure_6.5_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The Utah teapot
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure this geometry, you can use the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size`: This is the size of the teapot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`segments`: This defines how many segments are used to create the wireframe
    of this teapot. The more segments you use, the more smooth the teapot will look.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom`: If set to `true`, the bottom of the teapot will be rendered. If `false`,
    the bottom won’t be rendered, which you could use when the teapot is located on
    a surface and there is no need to render the bottom of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lid`: If set to `true`, the lid of the teapot will be rendered. If `false`,
    the lid won’t be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: If set to `true`, the body of the teapot will be rendered. If `false`,
    the body won’t be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fitLid`: If set to `true`, the lid will exactly fit the teapot. If `false`,
    there will be a small space between the lid and the body of the teapot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blinn`: This defines whether to use the same aspect ratio of the teapot as
    the original 1975 model this teapot is based on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, we’ll look at an alternative way of creating geometries
    by extracting a 3D geometry from a 2D shape.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a geometry by extruding a 2D shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js provides a way in which we can extrude a 2D shape into a 3D shape.
    By extruding, we mean stretching out a 2D shape along its *z* axis to convert
    it to 3D. For instance, if we extrude `THREE.CircleGeometry`, we get a shape that
    looks like a cylinder, and if we extrude `THREE.PlaneGeometry`, we get a cube-like
    shape. The most versatile way of extruding a shape is using `THREE.ExtrudeGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.ExtrudeGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `THREE.ExtrudeGeometry`, you can create a 3D object from a 2D shape. Before
    we dive into the details of this geometry, let’s first look at an example, `extrude-geometry.html`.
    The following screenshot taken from the example shows this geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Creating a 3D geometry from a 2D shape](img/Figure_6.6_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Creating a 3D geometry from a 2D shape
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we took the 2D shape we created in the *2D geometries* section
    in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), and used `THREE.ExtrudeGeometry`
    to convert it to 3D. As you can see in the preceding screenshot, the shape is
    extruded along the *z* axis, which results in a 3D shape. The code to create `THREE.ExtrudeGeometry`
    is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we created the shape with the `drawShape()` function, just as
    we did in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081). This shape is passed
    on to the `THREE.ExtrudeGeometry` constructor together with a set of properties.
    With these properties, you can define exactly how the shape should be extruded.
    The following list explains the options you can pass into `THREE.ExtrudeGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shapes`: One or more shapes (`THREE.Shape` objects) are required to extrude
    the geometry. See [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), on how to create
    such a shape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depth`: This determines how far the shape should be extruded (the depth).
    The default value is 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelThickness`: This determines the depth of the bevel. The bevel is the
    rounded corner between the front and back faces and the extrusion. This value
    defines how deep into the shape the bevel goes. The default value is `6`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelSize`: This determines the height of the bevel. This is added to the
    normal height of the shape. The default value is `bevelThickness -` `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelSegments`: This defines the number of segments that will be used by the
    bevel. The more the number of segments used, the smoother the bevel will look.
    The default value is `3`. Note that if you add more segments, you’re also increasing
    the vertex count, which could have an adverse effect on performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelEnabled`: If this is set to `true`, a bevel is added. The default value
    is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelOffset`: The distance from the outline of the shape where the bevel starts.
    The default value is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curveSegments`: This determines how many segments will be used when extruding
    the curves of shapes. The higher the number of segments used, the smoother the
    curves will look. The default value is `12`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`steps`: This defines the number of segments the shape will be divided into
    along the extrusion depth. The default value is `1`, which means it will have
    a single segment along its depth, without unnecessary additional vertices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extrudePath`: This is the path (`THREE.CurvePath`) along which the shape should
    be extruded. If this isn’t specified, the shape is extruded along the *z* axis.
    Note that if you’ve got a curving path, you also need to make sure to set a higher
    value for the `steps` property so that it can follow the curve accurately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uvGenerator`: When you use a texture with your material, the UV mapping determines
    what part of a texture is used for a specific face. With the `uvGenerator` property,
    you can pass in your own object, which will create the UV settings for the faces
    that are created for the passed-in shapes. More information on UV settings can
    be found in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171), *Loading and Working
    with Textures*. If nothing is specified, `THREE.ExtrudeGeometry.WorldUVGenerator`
    is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to use a different material for the faces and the sides, you can
    pass in an array of materials to `THREE.Mesh`. The first material passed in will
    be applied to the face, and the second material will be used for the sides. You
    can experiment with these options using the menu from the `extrude-geometry.html`
    example. In this example, we extruded the shape along its *z* axis. As you can
    see in the options listed earlier in this section, you can also extrude a shape
    along a path with the `extrudePath` option. In the following geometry, `THREE.TubeGeometry`,
    we’ll do just that.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.TubeGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.TubeGeometry` creates a tube that extrudes along a 3D spline. You specify
    the path using a number of vertices, and `THREE.TubeGeometry` will create the
    tube. An example that you can experiment with can be found in the sources for
    this chapter (`tube-geometry.html`). The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – TubeGeometry based on random 3D vertices](img/Figure_6.7_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – TubeGeometry based on random 3D vertices
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in this example, we generate a number of random points and use
    those points to draw the tube. With the controls in the menu, we can define how
    the tube looks. The code needed to create a tube is very simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What we need to do first is get a set of vertices (the `points` variable) of
    the `THREE.Vector3` type, just like we did for `THREE.ConvexGeometry` and `THREE.LatheGeometry`.
    Before we can use these points, however, to create the tube, we first need to
    convert these points to `THREE.Curve`. In other words, we need to define a smooth
    curve through the points we defined. We can do this simply by passing in the array
    of vertices to the constructor of `THREE.CatmullRomCurve3`, or any of the other
    `Curve` implementations provided by Three.js. With this curve and the other arguments
    (which we’ll explain in this section), we can create the tube and add it to the
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ve used `THREE.CatmullRomCurve3`. Three.js provides a number
    of other curves you can use as well that take slightly different arguments, but
    they can be used to create different curve implementations. Out of the box, Three.js
    comes with the following curves: `ArcCurve`, `CatmullRomCurve3`,`CubicBezierCurve`,`Cub``icBezierCurve3`,`EllipseCurve`,`LineCurve`,`LineCurve3`,`QuadraticBezierCurve`,     `QuadraticBezierCurve3`, and `SplineCurve`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.TubeGeometry` takes some other arguments besides the curve. The following
    lists all the arguments for `THREE.TubeGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: This is `THREE.SplineCurve3`, which describes the path this tube should
    follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tubularSegments`: These are the segments used to build up the tube. The default
    value is `64`. The longer the path, the more segments you should specify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radius`: This is the radius of the tube. The default value is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radiusSegments`: This is the number of segments to be used along the length
    of the tube. The default value is `8`. The more you use, the more round the tube
    will look.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closed`: If this is set to `true`, the start and the end of the tube will
    be connected. The default value is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last extrude example we’ll show in this chapter isn’t really a different
    type of geometry, but we’ll use `THREE.ExtrudeGeometry` to create extrusions from
    an SVG image.
  prefs: []
  type: TYPE_NORMAL
- en: What is SVG?
  prefs: []
  type: TYPE_NORMAL
- en: SVG is an XML-based standard that can be used to create vector-based 2D images
    for the web. This is an open standard that is supported by all modern browsers.
    Directly working with SVG and manipulating it from JavaScript, however, isn’t
    very straightforward. Luckily, there are a couple of open source JavaScript libraries
    that make working with SVG a lot easier. `Paper.js`, `Snap.js`, `D3.js`, and `Raphael.js`
    are some of the best. If you want a graphical editor, you can also use the open
    source Inkscape product.
  prefs: []
  type: TYPE_NORMAL
- en: Extruding 3D shapes from an SVG element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we discussed `THREE.ShapeGeometry` in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081),
    we mentioned that SVG follows pretty much the same approach to drawing shapes.
    In this section, we’ll look at how you can use SVG images together with `THREE.SVGLoader`
    to extrude SVG images. We’ll use the Batman logo as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The Batman SVG base image](img/Figure_6.8_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The Batman SVG base image
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at what the original SVG code looks like (you can also see
    this for yourself when looking at the source code of the `assets/svg/batman.svg`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you’re an SVG guru, this probably won’t mean too much to you. Basically
    though, what you see here is a set of drawing instructions. For instance, `C 277.987
    119.348 279.673 116.786 279.673 115.867` tells the browser to draw a cubic Bezier
    curve, and `L 489.242 111.787` tells us that we should draw a line to that specific
    position. Luckily though, we won’t have to write the code to interpret this ourselves
    and can use `THREE.SVGLoader` instead, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this code fragment, you can see that we use `SVGLoader` to load the SVG file.
    We use `loadAsync` here, which will return a JavaScript `Promise`. When that `Promise`
    resolves, we get access to the loaded `svg` data. This data can contain a list
    of `path` elements, each representing the `path` element of the original SVG.
    In our example, we’ve only got one, so we use `svg.paths[0]` and pass it into
    `SVGLoader.createShapes` to convert it into an array of `THREE.Shape` objects.
    Now that we’ve got the shapes, we can use the same approach we used earlier when
    we extruded our custom-created 2D geometry and use `THREE.ExtrudeGeometry` to
    create a 3D model from the 2D-loaded SVG shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result can be seen when you open the `extrude-svg.html` example in
    the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image](img/Figure_6.9_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image
  prefs: []
  type: TYPE_NORMAL
- en: The last geometry we’ll discuss in this section is `THREE.ParametricGeometry`.
    With this geometry, you can specify a couple of functions that are used to programmatically
    create geometries.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.ParametricGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `THREE.ParametricGeometry`, you can create a geometry based on an equation.
    Before we dive into our own example, a good thing to start with is to look at
    the examples already provided by Three.js. When you download the Three.js distribution,
    you get the `examples/js/ParametricGeometries.js` file. In this file, you can
    find a couple of examples of equations you can use together with `THREE.ParametricGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic example is the function to create a plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function is called by `THREE.ParametricGeometry`. The `u` and `v` values
    will range from `0` to `1` and will be called a large number of times, for all
    the values from `0` to `1`. In this example, the `u` value is used to determine
    the `x` coordinate of the vector, and the `v` value is used to determine the `z`
    coordinate. When this is run, you’ll have a basic plane with a width of `width`
    and a depth of `depth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we do something similar. However, instead of creating a flat
    plane, we create a wave-like pattern, as you can see in the `parametric-geometry.html`
    example. The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – A wave-like plane using a parametric geometry](img/Figure_6.10_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – A wave-like plane using a parametric geometry
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this shape, we passed the following function to `THREE.ParametricGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this example, with a few lines of code, we can create some
    really interesting geometries. In this example, you can also see the arguments
    we can pass to `THREE.ParametricGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function`: This is the function that defines the position of each vertex based
    on the `u` and `v` values provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slices`: This defines the number of parts the `u` value should be divided
    into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stacks`: This defines the number of parts the `v` value should be divided
    into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By changing the function, we can easily use the exact same approach to render
    a completely different object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – A Klein bottle rendered using a parametric geometry](img/Figure_6.11_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – A Klein bottle rendered using a parametric geometry
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a final note on how to use the `slices` and `stacks` properties before
    moving on to the next part of this chapter. We mentioned that the `u` and `v`
    properties are passed into the function argument provided and that the values
    of these two properties range from `0` to `1`. With the `slices` and `stacks`
    properties, we can define how often the passed-in function is called. If, for
    instance, we set `slices` to `5` and `stacks` to `4`, the function will be called
    with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, the higher these values are, the more vertices you get to specify and the
    smoother your created geometry will be. You can use the menu at the right of the
    `parametric-geometry.html` example to see this effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more examples, you can look at the `examples/js/ParametricGeometries.js`
    file in the Three.js distribution. This file contains functions to create the
    following geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: Klein bottle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flat Mobius strip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D Mobius strip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Torus knot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, you need to see more details about your geometry, and you don’t care
    too much about materials and how the mesh will be rendered. If you want to look
    at the vertices and the faces, or even just the outline, Three.js provides a couple
    of geometries that can help you with this (besides enabling the `wireframe` property
    of the material you use for the mesh). We’ll explore these in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Geometries you can use for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three.js comes with two helper geometries out of the box that make it easier
    to see the details or just the outline of a geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.EdgesGeometry`, which provides a geometry that only renders the edges
    of a geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.WireFrameGeometry`, which renders just the geometry without showing
    any faces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let’s look at `THREE.EdgesGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.EdgesGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `THREE.EdgesGeometry`, you wrap an existing geometry, which is then rendered
    by just showing the edges and not the individual vertices and faces. An example
    of this is shown in the `edges-geometry.html` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces](img/Figure_6.12_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see that the outline of `RoundedBoxGeometry`
    is shown, where we just see the edges. Since `RoundedBoxGeometry` has smooth corners,
    those are shown when using `THREE.EdgesGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this geometry, you just wrap an existing geometry like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The only property `THREE.EdgesGeometry` takes is `thresholdAngle`. With this
    property, you can determine when this geometry draws an edge. In `edges-geometry.html`,
    you can control this property to see the effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve got an existing geometry and want to see the wireframe, you can configure
    a material to show this wireframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Three.js also provides a different way of using `THREE.WireFrameGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.WireFrameGeometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This geometry simulates the behavior you see when you set the `wireframe` property
    of a material to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry](img/Figure_6.13_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this material works in the same way as using `THREE.EdgesGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This geometry doesn’t take any additional properties.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this chapter deals with creating 3D text objects. We’ll show
    you two different approaches, one with the `THREE.Text` object and one where we
    use an external library.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 3D text mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll have a quick look at how you can create 3D text. First,
    we’ll look at how to render text using the fonts provided by Three.js, and how
    you can use your own fonts for this. Then, we’ll show a quick example of using
    an external library called Troika ([https://github.com/protectwise/troika](https://github.com/protectwise/troika))
    that makes it really easy to create labels and 2D text elements and add them to
    your scene.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rendering text in Three.js is very easy. All you have to do is define the font
    you want to use and use the same extrude properties we saw when we discussed `THREE.ExtrudeGeometry`.
    The following screenshot shows a `text-geometry.html` example of how to render
    text in Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Rendering text in Three.js](img/Figure_6.14_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Rendering text in Three.js
  prefs: []
  type: TYPE_NORMAL
- en: 'The code required to create this 3D text is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code fragment, you can see that we first have to load the font. For
    this, Three.js provides `FontLoader()`, where we provide the name of the font
    to load, just like we did with `SVGLoader`, where we get back a JavaScript `Promise`.
    Once that `Promise` resolves, we use the loaded font to create `TextGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options we can pass into `THREE.TextGeometry` match those that we can pass
    into `THREE.ExtrudeGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`font`: The loaded font to use for the text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: This is the size of the text. The default value is `100`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This is the length (depth) of the extrusion. The default value is
    `50`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curveSegments`: This defines the number of segments used when extruding the
    curves of shapes. The more segments there are, the smoother the curves will look.
    The default value is `4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelEnabled`: If this is set to `true`, a bevel is added. The default value
    is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelThickness`: This is the depth of the bevel. The bevel is the rounded
    corner between the front and back faces and the extrusion. The default value is
    `10`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelSize`: This is the height of the bevel. The default value is `8`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelSegments`: This defines the number of segments that will be used by the
    bevel. The more segments there are, the smoother the bevel will look. The default
    value is `3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevelOffset`: This is the distance from the outline of the shape where the
    bevel starts. The default value is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `THREE.TextGeometry` is also `THREE.ExtrudeGeometry`, the same approach
    applies if you want to use a different material for the front and the sides of
    the material. If you pass in an array of two materials when creating `THREE.Mesh`,
    Three.js will apply the first material to the front and the back of the text,
    and the second one to the sides.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to use other fonts with this geometry, but you first need
    to convert them to JSON – how to do this is shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of fonts provided by Three.js that you can use in your scenes.
    These fonts are based on the fonts provided by the `TypeFace.js` library. `TypeFace.js`
    is a library that can convert TrueType and OpenType fonts to JavaScript. The resulting
    JavaScript file or JSON file can be included in your page, and the font can then
    be used in Three.js. In older versions, the JavaScript file was used, but in later
    Three.js versions, Three.js switched to using the JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert an existing OpenType or TrueType font, you can use the web page
    at [https://gero3.github.io/facetype.js/](https://gero3.github.io/facetype.js/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Converting a font to a typeface-supported format](img/Figure_6.15_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Converting a font to a typeface-supported format
  prefs: []
  type: TYPE_NORMAL
- en: 'On this page, you can upload a font, and it will be converted to JSON for you.
    Note that this won’t work so well for all types of fonts. The simpler the font
    (more straight lines), the better the chance that it will be rendered correctly
    when used in Three.js. The resulting file looks like this, where each of the characters
    (or glyphs) is described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve got the JSON file, you can use `FontLoader` (as we showed previously
    in the *Rendering text* section) to load this font and assign it to the `font`
    property of the options you can pass into `TextGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: For the final example of this chapter, we’re going to look at a different way
    to create text with Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Creating text using the Troika library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create labels or 2D text marks for certain parts of your scene,
    there is an alternative option to using the `THREE.Text` geometry. You can also
    use an external library called Troika: [https://github.com/protectwise/troika](https://github.com/protectwise/troika).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a fairly big library that provides lots of functionalities to add interactivity
    to your scenes. For this example, we’ll only look at the text module of that library.
    An example of what we’re going to create is shown in the `troika-text.html` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Troika text for 2D labels](img/Figure_6.16_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Troika text for 2D labels
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this library, we first have to install it (if you followed the instructions
    from [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D
    Scene with Three.js*, you can already use this library): `$ yarn add troika-three-text`.
    Once installed, we can import it and use it just like we do with the rest of the
    modules provided by Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragment, we showed how you can use Troika to create a
    simple text element. You only need to call the `Text()` constructor and set the
    properties. One thing to keep in mind, however, is that whenever you change a
    property in the `Text()` object, you have to call `troikaText.sync()`. That will
    make sure that the changes are also applied to the model rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw a lot in this chapter. We introduced a couple of advanced geometries
    and showed you how you can create and render text elements with Three.js. We showed
    you how you can create really beautiful shapes using advanced geometries such
    as `THREE.ConvexGeometry`, `THREE.TubeGeometry`, and `THREE.LatheGeometry` and
    how can you experiment with these geometries to get the results you’re looking
    for. A very nice feature is that we can also convert existing SVG paths to Three.js
    using `THREE.ExtrudeGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also quickly looked at a couple of geometries that are very useful for
    debugging purposes. `THREE.EdgesGeometry` shows just the edges of another geometry,
    and `THREE.WireframeGeometry` can be used to show the wireframe of some other
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you want to create 3D text, Three.js provides `TextGeometry`, where
    you can pass in a font that you want to use. Three.js comes with a couple of fonts,
    but you can also create your own fonts. However, remember that complex fonts often
    won’t convert correctly. An alternative to using `TextGeometry` is using the Troika
    library, which makes it very easy to create 2D text labels and place them anywhere
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we looked at solid (or wireframe) geometries, where vertices are
    connected to each other to form faces. In the upcoming chapter, we’ll look at
    an alternative way of visualizing geometries using something called particles
    or points. With particles, we don’t render complete geometries — we just render
    the individual vertices as points in space. This allows you to create great-looking
    3D effects that perform well.
  prefs: []
  type: TYPE_NORMAL
