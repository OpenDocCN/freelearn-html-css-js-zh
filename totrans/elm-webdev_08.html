<html><head></head><body>
        

                            
                    <h1 class="header-title">Adding More Features to the Weather App</h1>
                
            
            
                
<p>Welcome to <a href="5fdf7617-7e2c-4ff4-a7eb-28033a281ad5.xhtml">Chapter 8</a>, <em>Adding More Features to the Weather App</em>. The goal of this chapter is to improve our simple weather app by adding more features to it.</p>
<p>The topics we will cover include:</p>
<ul>
<li>Adding <kbd>elm-mdl</kbd> to our app</li>
<li>Converting the temperature display from Kelvin to Celsius</li>
<li>Working with the Round module</li>
</ul>
<p>After completing this chapter, you will:</p>
<ul>
<li>Be able to use the Material Design library for Elm, <kbd>elm-mdl</kbd></li>
<li>Understand how the Round module works</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Importing Material and Round modules</h1>
                
            
            
                
<p>To start, let's create a new folder, call it <kbd>chapter8</kbd>, point the console inside this newly-created folder, and run the following command:</p>
<pre>create-elm-app improved-weather-app-ch8</pre>
<p>Once the app is prepared, simply copy all the code we had in <kbd>Main.elm</kbd> at the end of <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>, into this new <kbd>Main.elm</kbd>. This will be our starting point (rather than beginning with the boilerplate app, like we did in the last few chapters).</p>
<p>However, there is a slight issue that we need to resolve. Currently, our new app will not compile. Instead, we will get the following warning:</p>
<pre><strong>Failed to compile</strong><br/><strong>./src/Main.elm</strong><br/><br/><strong>I cannot find module 'Http'.</strong><br/><br/><strong>Module 'Main' is trying to import it.</strong><br/><br/><strong>Potential problems could be:</strong><br/><strong>  * Misspelled the module name</strong><br/><strong>  * Need to add a source directory or new dependency to elm-package.json</strong></pre>
<p>The issue stems from the fact that we did not update the Elm packages. Let's quickly fix that by running the following command:</p>
<pre><strong>elm package install elm-lang/http 1.0.0</strong></pre>
<p>After we approve the upgrades, we'll be greeted with the following message output to the console:</p>
<pre><strong>Packages configured successfully!</strong></pre>
<p>Now we can start serving our Elm app and watch for changes as we update our app. To start serving the app, let's point our console to the <kbd>improved-weather-app-ch8</kbd> folder and run the following command:</p>
<pre><strong>elm-app start </strong></pre>
<p>We will begin adding improvements to our app by using the <kbd>elm-mdl</kbd> module. The preview of this module in action is available at <a href="https://debois.github.io/elm-mdl/">https://debois.github.io/elm-mdl/</a> and the official documentation can be found at <a href="https://github.com/debois/elm-mdl">https://github.com/debois/elm-mdl</a>.</p>
<p>To start off, let's import all the dependencies we will be using. Open <kbd>Main.elm</kbd>, and locate the beginning section of the code, where the imports are:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/>import Http<br/>import Json.Decode as Decode</pre>
<p>At the bottom of the imports, we will be importing <kbd>elm-mdl</kbd> module dependencies, and then, at the very bottom, the <kbd>Round</kbd> package:</p>
<pre>import Material<br/>import Material.Button as Button<br/>import Material.Card as Card<br/>import Material.Color as Color<br/>import Material.Elevation as Elevation<br/>import Material.Options as Options<br/>import Material.Scheme<br/>import Material.Textfield as Textfield<br/>import Material.Typography as Typography<br/>import Round exposing (..)</pre>
<p>The official <kbd>elm-mdl</kbd> package is also listed on the elm packages website, at <a href="http://package.elm-lang.org/packages/debois/elm-mdl/latest">http://package.elm-lang.org/packages/debois/elm-mdl/latest</a>, and the <kbd>Round</kbd> package is located at <a href="http://package.elm-lang.org/packages/myrho/elm-round/latest">http://package.elm-lang.org/packages/myrho/elm-round/latest</a>.</p>
<p>Unfortunately, at this point our app is again not compiling. The reason is similar to the issue we fixed a bit earlier: we need to install the missing packages. We can verify that that is the case by looking at the compiler's error message:</p>
<pre><strong>Failed to compile</strong><br/><strong>./src/Main.elm</strong><br/><br/><strong>I cannot find module 'Material'.</strong><br/><br/><strong>Module 'Main' is trying to import it.</strong><br/><br/><strong>Potential problems could be:</strong><br/><strong>  * Misspelled the module name</strong><br/><strong>  * Need to add a source directory or new dependency to elm-package.json</strong></pre>
<p>To fix the issue, let's run the following command in our console:</p>
<pre><strong>elm package install debois/elm-mdl</strong></pre>
<p>Next, let's try running our app again, with <kbd>elm-app start</kbd>.</p>
<p>Again, our app does not compile; this time, we are missing the <kbd>Round</kbd> module. Let's add it with the following command in the console:</p>
<pre><strong>elm package install myrho/elm-round</strong></pre>
<p>After successfully installing the dependencies needed to run our app, we can now see it successfully compiling and being served to the browser by running <kbd>elm-app start</kbd> once again. Right now, the app looks exactly as it did at the end of <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding elm-mdl to our Model</h1>
                
            
            
                
<p>While our main function will remain unchanged—meaning it will still use <kbd>Html.program</kbd> in exactly the same way as in the previous chapter, we will have to add changes to our <kbd>Model</kbd> type alias.</p>
<p>In <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>, our <kbd>Model</kbd> looked as follows:</p>
<pre>type alias Model =<br/>    { temperatureInfo : TemperatureInfo<br/>    , city : String<br/>    }</pre>
<p>The only thing we need to do is add another entry to the <kbd>Model</kbd>'s record, as follows:</p>
<pre>type alias Model =<br/>    { temperatureInfo : TemperatureInfo<br/>    , city : String<br/>    , mdl : Material.Model<br/>    }</pre>
<p>This new entry, <kbd>mdl : Material.Model</kbd>, is the type of data that holds everything we need to display the <kbd>mdl</kbd> element. Our <kbd>TemperatureInfo</kbd> type alias will remain unchanged.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the init function</h1>
                
            
            
                
<p>We will need to update the <kbd>init</kbd> function so that we take into account the initial value of <kbd>Material.model</kbd>. The <kbd>init</kbd> function we ended up with in <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>, looked as follows:</p>
<pre>init : ( Model, Cmd Msg )<br/>init =<br/>    ( Model (TemperatureInfo "Did not load" 0 0 0 0) ""<br/>    , Cmd.none<br/>    )</pre>
<p>The update is simple, and it will reflect the change we made to the <kbd>Model</kbd> type alias:</p>
<pre>init : ( Model, Cmd Msg )<br/>init =<br/>    ( Model (TemperatureInfo "Did not load" 0 0 0 0) "" Material.model<br/>    , Cmd.none<br/>    )</pre>
<p>With this update, we have sorted out the initial values that our weather app needs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the Msg union type and the update function</h1>
                
            
            
                
<p>In order to reflect the improvements we made with the introduction of the <kbd>elm-mdl</kbd> package, we need to add another type constructor to our <kbd>Msg</kbd> union type. The <kbd>Msg</kbd> union type will look exactly as it did in <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>, save for the new <kbd>Mdl</kbd> type constructor, which we'll simply append to the end of the union type, as follows:</p>
<pre>type Msg<br/>    = GetTemp<br/>    | CityInput String<br/>    | NewTemp (Result Http.Error String)<br/>    | Mdl (Material.Msg Msg)</pre>
<p>The <kbd>Mdl</kbd> type constructor is simply the message that will be generated by <kbd>mdl</kbd>.</p>
<p>Let's now add improvements to our <kbd>update</kbd> function, which looked like this at the end of <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>:</p>
<pre>update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        GetTemp -&gt;<br/>            ( model, getTemperature model.city )<br/><br/>        NewTemp (Ok json) -&gt;<br/>            let<br/>                newTemperatureInfo =<br/>                    decodeTemperatureInfo json<br/>            in<br/>                ( { model | temperatureInfo = newTemperatureInfo }, Cmd.none )<br/><br/>        NewTemp (Err _) -&gt;<br/>            ( model, Cmd.none )<br/><br/>        CityInput city -&gt;<br/>            ( { model | city = city }, Cmd.none )</pre>
<p>As we can see in the preceding code snippet, we pattern-matched for <kbd>GetTemp</kbd>, <kbd>NewTemp</kbd>, and <kbd>CityInput</kbd>, which was explained in <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>. The change that we need to make to the <kbd>update</kbd> function at this point has to do with pattern matching for the new <kbd>Msg</kbd> type constructor, namely, <kbd>Mdl</kbd>.</p>
<p>Practically, this means that the <kbd>update</kbd> function will remain exactly as it was, with just one simple addition: <kbd>Mdl</kbd> branch for our <kbd>case-of</kbd> expression:</p>
<pre>update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        Mdl msg_ -&gt;<br/>            Material.update Mdl msg_ model<br/><br/>        GetTemp -&gt;<br/>            ( model, getTemperature model.city )<br/><br/>        NewTemp (Ok json) -&gt;<br/>            let<br/>                newTemperatureInfo =<br/>                    decodeTemperatureInfo json<br/>            in<br/>            ( { model | temperatureInfo = newTemperatureInfo }, Cmd.none )<br/><br/>        NewTemp (Err _) -&gt;<br/>            ( model, Cmd.none )<br/><br/>        CityInput city -&gt;<br/>            ( { model | city = city }, Cmd.none )</pre>
<p>In the next section, we will add updates to our <kbd>view</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the view function</h1>
                
            
            
                
<p>The <kbd>view</kbd> function at the end of <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>, looked as follows:</p>
<pre>view : Model -&gt; Html Msg<br/>view model =<br/>    div []<br/>        [ input [ placeholder "City", onInput CityInput ] []<br/>        , br [] []<br/>        , button [ onClick GetTemp ] [ text "Get temperature" ]<br/>        , br [] []<br/>        , div [] [ text "Name: ", text (model.temperatureInfo.name) ]<br/>        , div [] [ text "Temp: ", text (toString model.temperatureInfo.temperature) ]<br/>        , div [] [ text "Wind: ", text (toString model.temperatureInfo.windSpeed) ]<br/>        , div [] [ text "Pressure: ", text (toString model.temperatureInfo.pressure) ]<br/>        , div [] [ text "Humidity: ", text (toString model.temperatureInfo.humidity) ]<br/>        ]</pre>
<p>Since we basically had no styles in the preceding code, the updated <kbd>view</kbd> function might seem a bit daunting at first glance:</p>
<pre>view : Model -&gt; Html Msg<br/>view model =<br/>    div []<br/>        [ Textfield.render Mdl<br/>            [ 0 ]<br/>            model.mdl<br/>            [ Textfield.label "City"<br/>            , Textfield.floatingLabel<br/>            , Textfield.text_<br/>            , Textfield.value model.city<br/>            , Options.onInput CityInput<br/>            ]<br/>            []<br/>        , Button.render Mdl<br/>            [ 1 ]<br/>            model.mdl<br/>            [ Button.raised<br/>            , Button.colored<br/>            , Button.ripple<br/>            , Options.onClick GetTemp<br/>            ]<br/>            [ text "Get temperature" ]<br/>        , br [] []<br/>        , Card.view<br/>            [ Options.css "width" "256px"<br/>            , Options.css "margin" "20px"<br/>            , Elevation.e8<br/>            , Elevation.transition 250<br/>            , Color.background (Color.color Color.LightBlue Color.S50)<br/>            ]<br/>            [ Card.title<br/>                [ Options.css "flex-direction" "column" ]<br/>                [ Card.head [] [ text model.city ]<br/>                , Options.div<br/>                    [ Options.css "padding" "2rem 2rem 0 2rem" ]<br/>                    [ Options.span<br/>                        [ Typography.display4<br/>                        , Typography.contrast 0.87<br/>                        , Color.text Color.primary<br/>                        ]<br/>                        [ text (Round.round 0 model.temperatureInfo.temperature ++ "°") ]<br/>                    ]<br/>                ]<br/>            , Card.actions []<br/>                [ div [] [ text "Wind: ", text (toString model.temperatureInfo.windSpeed) ]<br/>                , div [] [ text "Pressure: ", text (toString model.temperatureInfo.pressure) ]<br/>                , div [] [ text "Humidity: ", text (toString model.temperatureInfo.humidity) ]<br/>                ]<br/>            ]<br/>        ]<br/>        |&gt; Material.Scheme.top</pre>
<p>Check the look of your app in the browser, since at this point we are successfully applying <kbd>elm-mdl</kbd> to it.</p>
<p>Luckily, the preceding code is pretty straightforward once you understand how it works. Let's go through it step by step. Since the code in <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>, did not have any styles, the functions we used were easy enough to understand from the get-go. We simply had an <kbd>input</kbd>, a <kbd>button</kbd>, and four <kbd>divs</kbd> containing text nodes. As we did not use any styles, we used <kbd>br</kbd> functions to visually separate the <kbd>input</kbd>, the <kbd>button</kbd>, and the four <kbd>divs</kbd>.</p>
<p>The improvements in <a href="5fdf7617-7e2c-4ff4-a7eb-28033a281ad5.xhtml">Chapter 8</a>, <em>Adding More Features to the Weather App</em>, involve adding <kbd>mdl</kbd> specific elements, including <kbd>mdl</kbd> specific <kbd>Textfield</kbd>, <kbd>Button</kbd>, and <kbd>Card</kbd>. Let's look at <kbd>Textfield</kbd> a bit closer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Textfield function</h1>
                
            
            
                
<p>The code for our <kbd>Textfield</kbd> is as follows:</p>
<pre>Textfield.render Mdl<br/>            [ 0 ]<br/>            model.mdl<br/>            [ Textfield.label "City"<br/>            , Textfield.floatingLabel<br/>            , Textfield.text_<br/>            , Textfield.value model.city<br/>            , Options.onInput CityInput<br/>            ]<br/>            []</pre>
<p>We start off with <kbd>Textfield.render Mdl</kbd>, which means that its message type is <kbd>Mdl</kbd> and that it simply renders the <kbd>Textfield</kbd> component. Every <kbd>mdl</kbd> component that we use needs to have a unique ID, simply marked with a number. In the preceding example, we are assigning a unique ID to <kbd>Textfield</kbd> using a zero: <kbd>[ 0 ]</kbd>.</p>
<p>Next, we specify the part of the model that this will apply to, which is <kbd>model.mdl</kbd>. In the second list, we provide the specifics on the appearance we want our <kbd>Textfield</kbd> to have.</p>
<p>All the options that have to do with appearance for our <kbd>Textfield</kbd> component are available at the following URL, <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Textfield">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Textfield</a>. </p>
<p>To understand how the appearance changes in the second list provided to our <kbd>Textfield</kbd>, we can simply turn off some of the members of the list, like so:</p>
<pre>Textfield.render Mdl<br/>            [ 0 ]<br/>            model.mdl<br/>            [ --Textfield.label "City"<br/>              --, Textfield.floatingLabel<br/>              --, Textfield.text_<br/>              Textfield.value model.city<br/>            , Options.onInput CityInput<br/>            ]<br/>            []</pre>
<p>By commenting out <kbd>Textfield.label</kbd>, <kbd>Textfield.floatingLabel</kbd>, and <kbd>Textfield.text_</kbd>, we effectively turned them off, leaving only the bare minimum of the functionality needed for our app to still work. If we were to comment out either <kbd>Textfield.value model.city</kbd>, or <kbd>Options.onInput CityInput</kbd>, our app would stop working, so in the preceding case, we had to keep these two, while we were able to comment out the rest.</p>
<p>The reason our app would stop working is that we would break the model that the update function expects from the view.</p>
<p>As mentioned earlier in this section, we can refer to the <em>Options</em>, <em>Appearance</em>, and <em>Html attributes</em> sections of the official documentation for <kbd>Textfield</kbd> in order to get different results and styling. For example, we could set the <kbd>maxlength</kbd> of our <kbd>Textfield</kbd> to, say, five characters. In that case, our <kbd>Textfield</kbd> will need to look as follows:</p>
<pre>Textfield.render Mdl<br/>            [ 0 ]<br/>            model.mdl<br/>            [ Textfield.maxlength 5<br/>            , Textfield.text_<br/>            , Textfield.value model.city<br/>            , Options.onInput CityInput<br/>            ]<br/>            []</pre>
<p>Now, we will be able to type a city whose name is up to five characters long. For example, we can still look for weather information for Paris, but we would not be able to look up London, since we would not be able to type all six characters of that city's name.</p>
<p>Next, we'll go through the <kbd>Button</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Button function</h1>
                
            
            
                
<p>Looking at the <kbd>Button</kbd> after the <kbd>Textfield</kbd>, we can see the following code:</p>
<pre>Button.render Mdl<br/>            [ 1 ]<br/>            model.mdl<br/>            [ Button.raised<br/>            , Button.colored<br/>            , Button.ripple<br/>            , Options.onClick GetTemp<br/>            ]<br/>            [ text "Get temperature" ]</pre>
<p>Armed with our understanding of how <kbd>Textfield</kbd> works, we can figure out the preceding section of our <kbd>view</kbd> function almost at a glance: our <kbd>Button</kbd> gets rendered with an <kbd>Mdl</kbd> message. We give our <kbd>Button</kbd> an id of <kbd>1</kbd>, and we use the appearance options of <kbd>Button.raised</kbd>, <kbd>Button.colored</kbd>, and <kbd>Button.ripple</kbd>. We top it off by sending the <kbd>GetTemp</kbd> message, by using elm-mdl's <kbd>Options.onClick</kbd>. There is also a third list, which reads:</p>
<pre>[ text "Get temperature" ]</pre>
<p>Why did we use an empty list in <kbd>Textfield</kbd>, if we were not going to use it? The reason is, of course, to satisfy Elm's static type system. For example, if we were to erase the last, empty list from the <kbd>Textfield</kbd> function, the compiler would throw an error. Next, we'll look at the <kbd>Card</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Card function</h1>
                
            
            
                
<p>As a component, <kbd>Card</kbd> is relatively complex, as it is made up of several subsections, since its role is to display related information in a coherent way. The official documentation for the <kbd>Card</kbd> function is available at the following URL, <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Card">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Card</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the use of Card.view</h1>
                
            
            
                
<p>Let's look at the first several lines where we are using the <kbd>Card</kbd> function:</p>
<pre>        , br [] []<br/>        , Card.view<br/>            [ Options.css "width" "256px"<br/>            , Options.css "margin" "20px"<br/>            , Elevation.e8<br/>            , Elevation.transition 250<br/>            , Color.background (Color.color Color.LightBlue Color.S50)<br/>            ]</pre>
<p>First thing to note, the <kbd>br</kbd> function is completely redundant here, so we can simply erase it without any changes in the functionality or layout of our weather app. We begin the next line with <kbd>Card.view</kbd>.</p>
<p>As the official documentation reads, the <kbd>Card.view</kbd> function is used to construct a card. While <kbd>Textfield</kbd> and <kbd>Button</kbd> were constructed using the <kbd>render</kbd> function, here we are using <kbd>view</kbd>. We add additional styling using <kbd>Options.css</kbd>, followed with two <kbd>Strings</kbd>, the former setting the property of our CSS, and the latter setting the value for the property.</p>
<p><kbd>Material.Elevation</kbd> is used to give the shadow effect to our <kbd>mdl</kbd> components. For a full description of available <kbd>Elevations</kbd>, refer to the official documentation at <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Elevation">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Elevation</a>.  For example, to get the maximum possible shadow using <kbd>Elevation</kbd>, we can change the line that reads <kbd>Elevation.e8</kbd> to a new value, <kbd>Elevation.e24</kbd>. Similar to shadow, we can set the time it takes for our transition, in milliseconds. We set our transition to a quarter of a second with <kbd>Elevation.transition 250</kbd>.</p>
<p>The next line sets the color for our card:</p>
<pre>, Color.background (Color.color Color.LightBlue Color.S50)</pre>
<p>The official documentation of the <kbd>elm-mdl</kbd> package that deals with <kbd>Material.Color</kbd> is available at <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Color">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Color</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rendering the Card.title content block</h1>
                
            
            
                
<p>Next, we render a <kbd>Card.title</kbd>, as follows:</p>
<pre>            [ Card.title<br/>                [ Options.css "flex-direction" "column" ]<br/>                [ Card.head [] [ text model.city ]<br/>                , Options.div<br/>                    [ Options.css "padding" "2rem 2rem 0 2rem" ]<br/>                    [ Options.span<br/>                        [ Typography.display4<br/>                        , Typography.contrast 0.87<br/>                        , Color.text Color.primary<br/>                        ]<br/>                        [ text (Round.round 0 model.temperatureInfo.temperature ++ "°") ]<br/>                    ]<br/>                ]</pre>
<p>Before going through each of the preceding lines, it is important to note that each <kbd>Card </kbd> in <kbd>elm-mdl</kbd> consists of content blocks. Content blocks can be <kbd>Card.title</kbd>, <kbd>Card.media</kbd>, <kbd>Card.text</kbd>, and <kbd>Card.actions</kbd>. </p>
<p>The type signature for the <kbd>Card.title</kbd> content block is as follows:</p>
<pre>title : List (Style a) -&gt; List (Html a) -&gt; Block a</pre>
<p>This means that each title content block takes two <kbd>Lists</kbd> and returns a <kbd>Block</kbd>.</p>
<p>All the other content blocks (<kbd>media</kbd>, <kbd>text</kbd>, and <kbd>actions</kbd>) have identical type signatures, save for the name of the content block function.</p>
<p>Since we know that the <kbd>title</kbd> content block needs to have two <kbd>Lists</kbd>, and that the first <kbd>List</kbd> needs to specify styles, it's now easy to understand what this line of code does:</p>
<pre>[ Options.css "flex-direction" "column" ]</pre>
<p>The preceding line of code simply specifies the style to be used on our <kbd>Card.title</kbd>. If we wanted to, we could, for example, add another style here:</p>
<pre>  [ Options.css "flex-direction" "column"<br/>  , Options.css "padding-left" "100px"<br/>  ]</pre>
<p>Obviously, with the preceding change, our card will get a left padding of 100 pixels. The second <kbd>List</kbd> inside our <kbd>Card.title</kbd> content block specifies the <kbd>Html</kbd>:</p>
<pre>[ Card.head [] [ text model.city ]<br/>                , Options.div<br/>                    [ Options.css "padding" "2rem 2rem 0 2rem" ]<br/>                    [ Options.span<br/>                        [ Typography.display4<br/>                        , Typography.contrast 0.87<br/>                        , Color.text Color.primary<br/>                        ]<br/>                        [ text (Round.round 0 model.temperatureInfo.temperature ++ "°") ]<br/>                    ]<br/>                ]</pre>
<p>In the first line, we can see <kbd>Card.head</kbd> being used. The official documentation for <kbd>Card.head</kbd> is available at <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Card#head">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Card#head</a>. The <kbd>Card.head</kbd> function behaves as we expect—it takes two <kbd>Lists</kbd> and returns an <kbd>Html a</kbd>. The first <kbd>List</kbd> lets us specify <kbd>Style</kbd>, and the second one lets us specify <kbd>Html</kbd>. </p>
<p>Looking at the official documentation for <kbd>Material.Options</kbd>, available at <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Options">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Options</a>, we can navigate to the <em>Elements</em> section, which begins with <kbd>div</kbd>. As the official documentation reads, <kbd>div</kbd> is a:</p>
<p>"Convenience function for the ultra-common case of apply elm-mdl styling to a div element."</p>
<p>Inside <kbd>Options.div</kbd>, we specify the styles in the first <kbd>List</kbd>, then <kbd>Html</kbd> with <kbd>Options.span</kbd> in the second <kbd>List</kbd>. Following the same pattern, the <kbd>Options.span</kbd> itself holds two <kbd>Lists</kbd>. Inside the first <kbd>List</kbd> we specify the styles to use by calling <kbd>Material.Typography</kbd> and <kbd>Material.Color</kbd>—all together three separate styles. Then, in the second <kbd>List</kbd>, expectedly, we render a <kbd>text</kbd> node.</p>
<p>The contents of the <kbd>text</kbd> node, inside parentheses, might look a bit complicated, so let's pick it apart. To begin with, we can see that we are calling <kbd>Round.round</kbd>. Let's refer to the official documentation for more information on this package. To do that, point your browser to the following URL, <a href="http://package.elm-lang.org/packages/myrho/elm-round/latest/Round">http://package.elm-lang.org/packages/myrho/elm-round/latest/Round</a>.</p>
<p>As it says on the official page of the <kbd>Round</kbd> package, it allows us to convert a <kbd>Float</kbd> to a <kbd>String</kbd>, with the additional benefit of setting the number of digits after the decimal point. It also lets us specify how we want to round the rest of the digits on our <kbd>Float</kbd>.</p>
<p>The first example we see on the official page is this one:</p>
<pre>x = 3.141592653589793<br/><br/>round 2 x -- "3.14"</pre>
<p>The preceding code shows that <kbd>round</kbd> takes an <kbd>Int</kbd> and a <kbd>Float</kbd>, and returns a <kbd>String</kbd>. You can find the exact type signature at the following link, <a href="http://package.elm-lang.org/packages/myrho/elm-round/latest/Round#round">http://package.elm-lang.org/packages/myrho/elm-round/latest/Round#round</a>.</p>
<p>In our case, we have this code:</p>
<pre>Round.round 0 model.temperatureInfo.temperature ++ "°"</pre>
<p>Looking at the <kbd>temperatureInfo</kbd> type alias, we can see that <kbd>temperatureInfo.temperature</kbd> is a <kbd>Float</kbd>. So, we are indeed taking an <kbd>Int</kbd> and a <kbd>Float</kbd>, and returning a <kbd>String</kbd>. One caveat here is the concatenated degree symbol, which, although a <kbd>String</kbd>, gets concatenated with a <kbd>Float</kbd>, all thanks to <kbd>Round.round</kbd>.</p>
<p>The value of the first parameter is zero, meaning we do not want to have any decimal points when displaying the temperature. We can change that to, for example, one digit after the decimal point, by simply replacing the zero, like so:</p>
<pre>Round.round 1 model.temperatureInfo.temperature ++ "°"</pre>
<p>Next, we'll look at the <kbd>Card.actions</kbd> code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the Card.actions code</h1>
                
            
            
                
<p>Finally, it's time to discuss the <kbd>Card.actions</kbd> part of our <kbd>Card</kbd> component:</p>
<pre>, Card.actions []<br/>    [ div [] [ text "Wind: ", text (toString model.temperatureInfo.windSpeed) ]<br/>    , div [] [ text "Pressure: ", text (toString model.temperatureInfo.pressure) ]<br/>    , div [] [ text "Humidity: ", text (toString model.temperatureInfo.humidity) ]<br/>    ]</pre>
<p>The official documentation of <kbd>Material.Card</kbd> specifies <kbd>Card.actions</kbd> as allowing us to generate an <kbd>actions</kbd> block. As we have seen before, the <kbd>actions</kbd> block is simply one of the four possible content blocks for our <kbd>mdl</kbd> components.</p>
<p>The official documentation for the Material Design Language—that is, Google documentation, not Elm package documentation—states that a card action is to be used as a way to interact with our card. In essence, it's a call to an action button. For example, if we displayed a listing of blog post excerpts in the form of MDL cards on a website, the card action could be the button that holds the <em>Read More</em> text node.</p>
<p>However, in our example, we are not really interacting with the information provided under the temperature in our card component. In other words, we do not have the intention for the user to click on the <em>wind</em>, <em>pressure</em>, and <em>humidity</em> information that is listed below the temperature reading.</p>
<p>Therefore, it is safe to change the line that reads <kbd>, Card.actions []</kbd> with this code: <kbd>, Card.text []</kbd>. We can leave all the other code as is, and the app will still work. The only change that will happen has to do with the compiled HTML structure of our weather app. In order to see the change, we will need to inspect the code in the <kbd>dev</kbd> tools, which can be accessed in most major browsers by pressing the <em>F12</em> button.</p>
<p>If using <kbd>Card.action</kbd> in our Elm app, the resultant <kbd>div</kbd> in the browser will have this CSS class attribute: <kbd>mdl-card__actions</kbd>. If we instead switch to using <kbd>Card.text</kbd> in our view, the resultant <kbd>div</kbd> of the running app in the browser will have the CSS class attribute of <kbd>mdl-card__supporting-text</kbd>.</p>
<p>We finish our <kbd>view</kbd> function's code by piping the <kbd>Material.Scheme.top</kbd> at the very bottom. This will add the <kbd>mdl</kbd> CSS to our app. To find out more about this, refer to the official documentation at <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Scheme#top">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Scheme#top</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding color schemes</h1>
                
            
            
                
<p>We can change the way our mdl-styled app looks, almost effortlessly, by utilizing color schemes. To understand how to do that, we will first need to refer to the official documentation of the elm-mdl package. More specifically, we are interested in <kbd>topWithScheme</kbd>, a function that is made available in the <kbd>elm-mdl</kbd> package. The official documentation for this function is available at <a href="http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Scheme#topWithScheme">http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Scheme#topWithScheme</a>. If you visit the referenced URL, you will see that all we need to do to make it work is provide the primary and accent colors as parameters to the <kbd>topWithScheme</kbd> function.</p>
<p>To better understand how the color schemes work in mdl, refer to the color scheme customizer at <kbd>https://getmdl.io/customize/index.html</kbd>. </p>
<p>Practically, this means that we can update our <kbd>view</kbd> function with a number of color schemes, just by changing one line of code. Until now, the first few lines of our <kbd>view</kbd> function looked as follows:</p>
<pre>view : Model -&gt; Html Msg<br/>view model =<br/>    div []<br/>        [ Textfield.render Mdl</pre>
<p>To update the view so that it uses the <kbd>topWithScheme</kbd> function, we simply add the following:</p>
<pre>view : Model -&gt; Html Msg<br/>view model =<br/>    div []
        [ Material.Scheme.topWithScheme Color.Orange Color.Red &lt;|<br/>            Textfield.render Mdl</pre>
<p>As we can see, the primary color is now orange, and the accent color is red. At this point, we have nearly finished updating our weather app. There are no changes to be made to either the <kbd>subscriptions</kbd> function or to the <kbd>getTemperature</kbd> function.</p>
<p>The only function that still needs updating is the <kbd>decodeTemperatureInfo</kbd> function, in which we need to make just some minor tweaks, which we will be doing in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating decodeTemperatureInfo</h1>
                
            
            
                
<p>We left off in <a href="db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml">Chapter 7</a>, <em>Making a Weather App in Elm</em>, with the following code for <kbd>decodeTemperatureInfo</kbd>:</p>
<pre>decodeTemperatureInfo : String -&gt; TemperatureInfo<br/>decodeTemperatureInfo json =<br/>    let<br/>        name =<br/>            Result.withDefault "Error decoding data!" (Decode.decodeString (Decode.field "name" Decode.string) json)<br/><br/>        windSpeed =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "wind", "speed" ] Decode.float) json)<br/><br/>        temperature =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "temp" ] Decode.float) json)<br/><br/>        pressure =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "pressure" ] Decode.float) json)<br/><br/>        humidity =<br/>            Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "humidity" ] Decode.float) json)<br/>    in<br/>        TemperatureInfo name windSpeed temperature pressure humidity</pre>
<p>The only thing to update in the <kbd>decodeTemperatureInfo</kbd> function is that we need to convert the temperature from Kelvin to Celsius. Luckily, this conversion is very straightforward: in order to convert to Celsius, we simply need to subtract <kbd>273.15</kbd> from the Kelvin-based value. In other words, if the current temperature is <kbd>293.15</kbd> Kelvins, the conversion to Celsius will look as follows:</p>
<pre>293.15 - 273.15 = 20</pre>
<p>Thus, <kbd>293.15</kbd> degrees Kelvin is <kbd>20</kbd> degrees Celsius. This makes it pretty straightforward to update our <kbd>decodeTemperatureInfo</kbd>. We simply need to replace the existing code with this one:</p>
<pre>temperature =<br/>     Result.withDefault 0 (Decode.decodeString (Decode.at [ "main", "temp" ] Decode.float) json) - 273.15</pre>
<p>We will leave the rest of the code the same as in the previous version of our app.</p>
<p>In this section, we updated the temperature so as to display Celsius to Kelvin. If you view the app in the browser, you will be able to see this change.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned how to improve the styling of an existing app with the wonderful <kbd>elm-mdl</kbd> package. We have looked at using <kbd>Result</kbd> and <kbd>Maybe</kbd> to deal with operations that might fail and to deal with possibly missing data. We looked at using decoders, and mapping over them. We also looked at using the HTTP package to get remote JSON data.</p>
<p class="mce-root">In the next chapter, we will look at how to write tests for our Elm apps.</p>
<p> </p>
<p class="mce-root"/>


            

            
        
    </body></html>