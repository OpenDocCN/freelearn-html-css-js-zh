- en: Colors, Depth Testing, and Alpha Blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered global versus local transformations, matrix
    stacks, animation timers, and various interpolation techniques. In this chapter,
    we start by examining how colors are structured and handled in WebGL and ESSL.
    We will discuss the use of colors in objects, lights, and scenes. Then, we will
    see how WebGL leverages the depth buffer for object occlusion when one object
    is in front of another, blocking it from view. Lastly, we will cover alpha blending,
    which allows us to combine the colors of objects when one is occluding the other,
    while also allowing us to create translucent objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using colors in objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning colors to light sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with several light sources in the ESSL program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use the depth test and the z-buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to blend functions and equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transparent objects with face-culling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Colors in WebGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebGL supplies a fourth attribute to the RGB model. This attribute is called
    the **alpha channel**. The extended model then is known as the **RGBA** model,
    where A stands for alpha. The alpha channel contains a value between the range
    of `0.0` to `1.0`, just like the other three channels (red, green, and blue).
    The following diagram shows the RGBA color space. On the horizontal axis, you
    can see the different colors that can be obtained by combining the `R`, `G`, and
    `B` channels. The vertical axis corresponds to the alpha channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/704d0e52-ba79-4864-b414-e77852adb878.png)'
  prefs: []
  type: TYPE_IMG
- en: The alpha channel carries extra information about a color. This information
    affects the way the color is rendered on the screen. In most cases, the alpha
    value will refer to the amount of opacity that the color contains. A completely
    opaque color will have an alpha value of `1.0`, whereas a completely transparent
    color will have an alpha value of `0.0`. This is the general case, but as we will
    see, we need to take other factors into account when we obtain translucent colors.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent Versus Translucent
  prefs: []
  type: TYPE_NORMAL
- en: Glass, for example, is transparent to all visible light. Translucent objects
    allow some light to travel through them. Materials such as frosted glass and some
    plastics are called translucent. When light strikes translucent materials, only
    some of the light passes through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use colors everywhere in our WebGL 3D scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects**: 3D objects can be colored by selecting one color for every pixel
    (fragment) or by selecting the color that the object will have based on the material''s
    diffuse property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lights**: Even though we have been using white lights, there is no reason
    we can''t have lights whose ambient or diffuse properties contain other colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scene**: The background of our scene has a color that we can change by calling
    `gl.clearColor`. Also, as we will see later on, there are special operations that
    need to be performed on objects'' colors to achieve translucent effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of Color in Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As earlier chapters have addressed, the final color of a pixel is assigned in
    the fragment shader by setting an out ESSL variable. If all the fragments in the
    object have the same color, we can say the object has a constant color. Otherwise,
    the object is generally understood as having per-vertex color.
  prefs: []
  type: TYPE_NORMAL
- en: Constant Coloring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To obtain a constant color, we store the desired color in a uniform that is
    passed to the fragment shader. This uniform is usually called the object's **diffuse
    material property**. We can also combine object normals and light-source information
    to obtain a Lambert coefficient. We can use the Lambert coefficient to proportionally
    change the reflecting color depending on the angle on which the light hits the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the following diagram demonstrates, we lose depth perception when we do
    not use information about the normals to obtain a Lambert coefficient. Please
    note that we are using a diffusive lighting model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ae4717b-fd2b-48e5-b0b3-42c9dc57f24a.png)'
  prefs: []
  type: TYPE_IMG
- en: Per-Vertex Coloring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In medical and engineering visualization applications, it is common to find
    color maps that are associated with the vertices of the models we are rendering.
    These maps assign each vertex a color depending on its scalar value. An example
    of this idea includes the temperature charts that indicate cold temperatures as
    blue, and hot temperatures as red overlaid on a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement per-vertex coloring, we need to define an attribute that stores
    the color for the vertex in the vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to assign the `aVertexColor` attribute to a varying so that
    it can be passed to the fragment shader. Remember that varyings are automatically
    interpolated. Therefore, each fragment will have a color that is the weighted
    result of its contributing vertices.
  prefs: []
  type: TYPE_NORMAL
- en: If we want our color map to be sensitive to lighting conditions, we can multiply
    each vertex color by the diffuse component of the light. The result is then assigned
    to the varying that will transfer the result to the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates two different possibilities for this case:
    on the left, the vertex color is multiplied by the light diffuse term without
    any weighting from the position of the light; on the right, the Lambert coefficient
    generates the expected shadows and gives information about the relative location
    of the light source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b06ccc1-13ff-4af5-9c29-3b75e32dd3a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we are using a vertex buffer object that is mapped to the `aVertexColor`
    vertex shader attribute. We learned how to map VBOs in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml),
    *Rendering*.
  prefs: []
  type: TYPE_NORMAL
- en: Per-Fragment Coloring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also assign a random color to each pixel of the object we are rendering.
    Although ESSL does not have a pre-built random function, there are algorithms
    we can use to generate pseudo-random numbers. That being said, the purpose and
    usefulness of this technique are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Coloring the Cube'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover a simple example of coloring a geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch06_01_cube.html` file using your browser. You will see a page similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/401dcbc1-d1ef-4cbd-8df5-8bd4e4a6eac4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this exercise, weâ€™re going to compare constant versus per-vertex coloring.
    Let''s talk about the page''s widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lambert: When selected, it will include the Lambert coefficient in the calculation
    of the final color.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Per Vertex: The two different coloring methods explained before: per-vertex
    or constant.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complex Cube: Loads a JSON object where the vertices are repeated with the
    goal of obtaining multiple normals and multiple colors per vertex. We will explain
    how this works later on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alpha Value: This slider is mapped to the `uAlpha` float uniform in the vertex
    shader. `uAlpha` sets the alpha value for the vertex color.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disable the use of the Lambert coefficient by clicking on Lambert. Rotate the
    cube by clicking and dragging. Notice the loss of depth perception when the Lambert
    coefficient is not included in the final color calculation. The Lambert button
    is mapped to the `uUseLambert` Boolean uniform. The code that calculates the Lambert
    coefficient can be found in the vertex shader included in the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `uUseLambert` uniform is `false`, then `lambertTerm` remains as `1.0`,
    not affecting the final diffuse term here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, `Id` will have the Lambert coefficient factored in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Having Lambert disabled, click on the Per Vertex button. Rotate the cube to
    see how ESSL interpolates the vertex colors. The vertex shader key code fragment
    that allows us to switch from a constant diffuse color to per-vertex colors uses
    the `uUseVertexColors` Boolean uniform and the `aVertexColor` attribute. This
    fragment is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the `common/models/geometries/cube-simple.json` file. There,
    the eight vertices of the cube are defined in the vertices array and there is
    an element in the scalars array for every vertex. As you may expect, each one
    of these elements corresponds to a respective vertex color, as shown in the following
    diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/736f4d9b-81e0-4180-81ee-f3d13bf0f369.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure that the Lambert button is not active and then click on the Complex
    Cube button. By repeating vertices in the vertex array in the corresponding JSON
    file, `common/models/geometries/cube-complex.json`, we can achieve independent
    face-coloring. The following diagram explains how the vertices are organized in
    `cube-complex.json`. Note that as the definition of colors occurs by vertex (since
    we are using the shader attribute), we need to repeat each color four times, because
    each face has four vertices. This idea is depicted in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/700279ed-b6ed-45c6-8799-5cdd1b5ea217.png)'
  prefs: []
  type: TYPE_IMG
- en: Activate the Lambert button to see how the Lambert coefficient affects the color
    of the object. Try different button configurations to see what happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s quickly explore the effect of changing the alpha channel to a value
    less than `1.0`. What do you see? Notice that the object does not become transparent
    but instead starts losing its color. To obtain transparency, we need to activate
    blending. We will discuss blending in depth later in this chapter. For now, uncomment
    these lines in the `configure` function, in the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the page and reload it in your internet browser. If you select Per-Vertex,
    Complex Cube and reduce the alpha value to `0.5`, you will see something like
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/85d1a4d8-b3ee-4108-ab5a-a2aff15d10a3.png)'
  prefs: []
  type: TYPE_IMG
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have studied two different ways of coloring objects: **constant coloring**
    and **per-vertex coloring**. In both cases, the final color of each fragment is
    assigned by exporting a color variable via an `out` qualifier in the fragment
    shader.'
  prefs: []
  type: TYPE_NORMAL
- en: We saw that by activating the calculation of the Lambert coefficient, we obtain
    sensory depth information.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that repeating vertices in our object allows us to obtain different
    coloring effects. For instance, we can color an object by faces instead of by
    vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Use of Color in Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Colors are light properties. In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml),
    *Lights*, we learned that the number of light properties depends on the lighting-reflection
    model selected for a scene. For instance, using a Lambertian reflection model,
    we would only need to model one shader uniform: the light diffuse property/color.
    In contrast, if the Phong reflection model were selected, each light source would
    need to have three properties: the ambient, diffuse, and specular colors.'
  prefs: []
  type: TYPE_NORMAL
- en: Positional Lights
  prefs: []
  type: TYPE_NORMAL
- en: 'The light position is usually modeled as a uniform when the shader needs to
    know the position of the light. Therefore, a Phong model with a positional light
    would have four uniforms: ambient, diffuse, specular, and position.'
  prefs: []
  type: TYPE_NORMAL
- en: For directional lights, the fourth uniform is the light direction. For more
    information, refer to [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml),
    *Lights*.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that each light property is represented by a JavaScript four-element
    array with mappings to `vec4` uniforms in the shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick reminder, which WebGL methods should we use to retrieve and set
    a uniform? In our case, the two methods we use to pass lights to the shaders are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getUniformLocation`: Locates the uniform in the program and returns an index
    we can use to set the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniform4fv`: Since the light components are RGBA, we need to pass a four-element
    float vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the desire to use more than one light in our scene, we need to define
    and map the number of appropriate uniforms of the lighting model of choice. If
    we have four properties per light (ambient, diffuse, specular, and location),
    we need to define four uniforms for each light. If we want to have three lights,
    we need to write, use, and map twelve uniforms! We need to resolve this complexity
    before it gets out of hand.
  prefs: []
  type: TYPE_NORMAL
- en: How Many Uniforms Can We Use?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenGL Shading Language ES specification delineates the number of uniforms
    that we are allowed to use.
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.3.4 Uniforms
  prefs: []
  type: TYPE_NORMAL
- en: There is an implementation dependent limit on the amount of storage for uniforms
    that can be used for each type of shader. If this is exceeded, it will cause a
    compile-time or link-time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the limit for your WebGL implementation, you can query WebGL using
    the `gl.getParameter` function with these constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The implementation limit is given by your browser and heavily depends on your
    graphics hardware. That said, even though your machine may have enough variable
    space, it does not necessarily mean that the problem is solved. We still have
    to define and map each of the uniforms and that can often lead to brittle and
    verbose code, as we will see in a later exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to simplify the problem, we can assume that the ambient component is
    the same for all of the lights. This will reduce the number of uniformsâ€”one fewer
    uniform for each light. However, this is not an extensible solution for more general
    cases where we cannot assume that the ambient light is constant.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start diving deeper into our scene with multiple lights, let's update
    our architecture to cover some of the concepts we've addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress through this book, we continue to refine our architecture where
    appropriate to reflect what weâ€™ve learned. On this occasion, we will improve how
    we pass uniforms to our program and add support for handling a large number of
    uniforms to define multiple lights.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Support for Light Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover these changes in detail. We have created a new JavaScript module,
    `Lights.js`, that has two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Light`: Aggregates light properties (position, diffuse, specular, and so on)
    in a single entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LightsManager`: Contains the lights in our scene. This allows us to retrieve
    each light by `index` or `name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LightsManager` also contains the `getArray` method to flatten the arrays of
    properties by type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will be useful when we use uniform arrays later on.
  prefs: []
  type: TYPE_NORMAL
- en: Improving How We Pass Uniforms to the Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have also improved the way we pass uniforms to the program. In `configure`,
    we can see how we pass attributes and uniforms to `program.load` rather than manually
    attaching them to the instance like in the introductory chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `configure` function is the appropriate place to load the program. We are
    also going to create a dynamic mapping between JavaScript variables and uniforms.
    With this in mind, we have updated the `program.load` method to receive two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attributes`: An array containing the names of the attributes that we will
    map between JavaScript and ESSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniforms`: An array containing the names of the uniforms that we will map
    between JavaScript and ESSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the function now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines correspond to the two new functions, `setAttributeLocations`
    and `setUniformLocations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these functions look up the attribute and uniform lists, respectively,
    and then attach the location as a property to the `Program` instance.
  prefs: []
  type: TYPE_NORMAL
- en: In short, if we include the `uLightPosition` uniform name in the `uniforms`
    list to be passed to `program.load`, we will then have a `program.uLightPosition`
    property that will contain the location of the respective uniform! Neat!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we load the program in the `configure` function, we can initialize the
    values of the uniforms immediately with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Time for Action: Adding a Blue Light to a Scene'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Weâ€™re ready to take a look at the first example in this chapter. We will work
    on a scene with **per-fragment** lighting that has three light sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each light has a position and a diffuse color property. This means we have
    two uniforms per light. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, we have assumed that the ambient color is the same for
    all three light sources. We have also removed the specular property. Open the
    `ch06_02_wall_initial.html` file in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a scene such as the one displayed in the following screenshot
    where two lights (red and green) illuminate a black wall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/93aa40c3-3f69-485a-b1e6-247ca3900007.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the `ch06_02_wall-initial.html` file using your code editor. We will update
    the vertex shader, the fragment shader, the JavaScript code, and the HTML code
    to add the blue light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Updating the vertex shader**: Go to the vertex shader where you can see these
    two uniforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the third uniform here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define a varying to carry the interpolated light ray direction
    to the fragment shader. Remember here that we are using per-fragment lighting.
    Check where the varyings are defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And, add the third varying there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the body of the vertex shader. We need to update each
    of the light locations according to our position in the scene. We achieve this
    by writing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the positions for the other two lights are also being calculated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s calculate the light ray for the updated position from our blue light
    to the current vertex. We do that by writing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That is all we need to modify in the vertex shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, weâ€™ve included a new light position and we have calculated the light
    rays in the vertex shader. These rays will be interpolated by the fragment shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s work out how the colors on the wall will change by including our new
    blue source of light. Scroll down to the fragment shader and add a new uniformâ€”the
    blue diffuse property. Look for these uniforms declared right before the `main`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the contribution of the blue light to the final color, we need
    to obtain the light ray we defined previously in the vertex shader. This varying
    is available in the fragment shader. You also need to declare it before the `main`
    function. Look for the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the following code right under it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is assumed that the ambient component is the same for all the lights. This
    is reflected in the code by having only one `uLightAmbient` variable. The ambient
    term, `Ia`, is the product of `uLightAmbient` and the wall''s material ambient
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If `uLightAmbient` is set to `(1.0, 1.0, 1.0, 1.0)` and `uMaterialAmbient` is
    set to `(0.1, 0.1, 0.1, 1.0)`, then the resulting ambient term, `Ia`, will be
    really small. This means the contribution of the ambient light will be low in
    this scene. In contrast, the diffuse component will be different for every light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add the effect of the blue diffuse term. In the fragment shader main
    function, look for the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line immediately under it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line of code right under it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the following code after it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `fragColor` so that it includes `Id3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all we need to do in the fragment shader. Let''s move on to our JavaScript
    code. So far, we have written the code that is needed to handle one more light
    inside our shaders. Let''s see how we create the blue light from the JavaScript
    side and how we map it to the shaders. Scroll down to the `configure` function
    and look for the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll to the point where the `uniforms` list is defined. As mentioned earlier,
    this new mechanism makes it easier to obtain locations for the uniforms. Add the
    two new uniforms that we are using for the blue light: `uDiffuseBlueLight` and
    `uPositionBlueLight`. The list should look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s pass the position and diffuse values of our newly defined light to `program`.
    Find the following lines, after the line that loads `program`, and make these
    necessary changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Uniform Arrays
  prefs: []
  type: TYPE_NORMAL
- en: Coding one uniform per light makes the code quite verbose. Later on, we will
    cover how to simplify the code using uniform arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `load` function. We need a new sphere to represent the blue
    light, the same way we have two spheres in the scene: one for the red light and
    the other for the green light. Append the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in the `load` function, we are loading the same geometry (sphere)
    three times. To differentiate the sphere that represents the light source, we
    are using local transforms for the sphere (initially centered at the origin).
    Scroll to the `render` function and find the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Thatâ€™s it! Save the page with a different name and test it in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a945b06-e22f-48aa-8eaa-aae7adc1d908.png)'
  prefs: []
  type: TYPE_IMG
- en: If you do not obtain the expected result, please go back and check the steps.
    You will find the completed exercise in the `ch06_03_wall-final.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have modified our sample scene by adding one more light: a blue light. We
    have updated the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fragment shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `configure` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `load` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `draw` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, handling light properties one uniform at a time is not very
    efficient. Later in this chapter, we will study a more effective way to handle
    lights in a WebGL scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Adding Interactivity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add an additional slider to our controls widget to interactively
    change the position of the blue light we just added.
  prefs: []
  type: TYPE_NORMAL
- en: We will use **dat.GUI**, one for each one of the blue light coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: dat.GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about dat.GUI on GitHub: [https://github.com/dataarts/dat.gui](https://github.com/dataarts/dat.gui).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create three sliders: one for the `X` coordinate, one for the `Y` coordinate,
    and a third one for the `Z` coordinate for the blue light.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final GUI should include the new blue light sliders, which should look
    like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d92cd7e-8479-404e-ade0-37c642d68ea6.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the sliders present in the page to guide your work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will find the completed exercise in the `ch06_03_wall-final.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Uniform Arrays to Handle Multiple Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, handling light properties with individual uniforms makes the
    code verbose and difficult to maintain. Fortunately, ESSL provides several mechanisms
    we can use to solve the problem of handling multiple lights. One of them is **uniform
    arrays**.
  prefs: []
  type: TYPE_NORMAL
- en: This technique allows us to handle multiple lights by introducing enumerable
    arrays of vectors in the shaders. This allows us to calculate light contributions
    by iterating through the light arrays in the shaders. We still need to define
    each light in JavaScript, but the mapping to ESSL becomes simpler since we arenâ€™t
    defining one uniform per light property. Let's see how this technique works. We
    just need to make two simple changes in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform Array Declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to declare the light uniforms as arrays inside our ESSL shaders.
    For example, the light position that contains three lights would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Itâ€™s important to note that ESSL does not support dynamic initialization of
    uniform arrays. We could try something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If so, the shader will not compile, and you will obtain the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this construct is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare one uniform array per light property, regardless of how many lights
    weâ€™re going to have. As a result, if we want to pass information about diffuse
    and specular components of five lights, for example, we need to declare two uniform
    arrays, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript Array Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to map the JavaScript variables where we have the light property
    information to the program. For example, we may want to map these three light
    positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If so, we need to retrieve the uniform array location (just like in any other
    case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The one difference is that we map these positions as a concatenated flat array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important points here:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the uniform that is passed to `getUniformLocation` is the same as
    before. The fact that `uPositionLight` is now an array does not change a thing
    when you locate the uniform with `getUniformLocation`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JavaScript array that we are passing to the uniform is a flat array. If
    you write something as follows, the mapping will not work:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: So, if you have one variable per light, you should ensure that you concatenate
    them before passing them to the shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Adding a White Light to a Scene'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of how we''d add a new light to our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch06_04_wall-light-arrays.html` file in your browser. This scene looks
    exactly like `ch06_03_wall-final.html`; however, the code is far less complex
    since we are now using uniform arrays. Let's see how using uniform arrays changes
    our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ch06_04_wall-light-arrays.html` file in your code editor. Let's take
    a look at the vertex shader. Note the use of the constant integer expression const
    int, `numLights = 3;`, to declare the number of lights that the shader will handle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There, you can also see that a uniform array is being used to operate on light
    positions. Note that we are using a varying array to pass the light rays (for
    each light) to the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This fragment of code calculates one varying light ray per light. Recall that
    the same code in the `ch06_03_wall-final.html` file looks like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Once you compare these two snippets, the advantage of using uniform arrays (and
    varying arrays) should be clear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fragment shader also uses uniform arrays. In this case, the fragment shader
    iterates through the light diffuse properties to calculate the contribution of
    each one to the final color on the wall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of brevity, we wonâ€™t cover the verbose version from the `ch06_03_wall-final.html`
    exercise, but you should check it out for yourself and compare it with this one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `configure` function, the size of the JavaScript array containing the
    uniform names has decreased considerably by omitting the other unnecessary light
    attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The mapping between JavaScript lights and uniform arrays is now simpler because
    of the `getArray` method from the `LightsManager` class. As we described earlier,
    the `getArray` method concatenates the lights' data into one flat array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `load` and `render` functions look exactly the same. If we want to add a
    new light, we still need to load a new sphere with the `load` function (to represent
    the light source in our scene), and we still need to translate the sphere to the
    appropriate location in the `render` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how much effort we need to add a new light. Go to the `configure`
    function and create a new light object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `whiteLight` to the `lights` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Move to the `load` function and append this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in the previous *Time for Action* section, add this to the `render`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the webpage with a different name and open it using your browser. We have
    also included the completed exercise in `ch06_05_wall-light-arrays-final.html`,
    including some minor improvements on keeping the light configuration more declarative.
    The following diagram shows the final result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86bfe41a-08aa-4cac-b642-ba986109db16.png)'
  prefs: []
  type: TYPE_IMG
- en: Thatâ€™s all you need to do! If you want to control the white light properties
    with the controls widget, you would need to write the corresponding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Directional Point Lights'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml), *Lights*, we compared
    directional and positional lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f69327e-711a-452e-8a94-e6aafcd98af6.png)'
  prefs: []
  type: TYPE_IMG
- en: In point lighting, for every point on the surface of our object, we compute
    the direction from the light to that point on the surface. We then do the same
    thing we did for directional lighting. Remember that we took the dot product of
    the surface normal (the direction the surface is facing) and the light direction.
    This gave us a value of `1` if the two directions matched, which means the fragment
    should be fully lit, `0` if the two directions were perpendicular, and `-1` if
    they were opposite. We directly used that value to multiply the color of the surface,
    which gave us lighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will combine directional and positional lights. We are
    going to create a third type of light: a **directional point light**, commonly
    referred to as a **spot light**. This light has both positional and directional
    properties. We are ready to do this since our shaders can easily handle lights
    with multiple properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/440f89a6-bcc1-4444-97bb-89827e6cb9dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The trick to creating these lights is to subtract the light-direction vector
    from the normal for each vertex. The resulting vector will create a different
    Lambert coefficient that will reflect into the cone generated by the light source:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ch06_06_wall-spot-light.html` in your browser. As you can see, the three
    light sources now have a direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47c83dde-1688-4bdd-9428-4c54e6c5cd90.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `ch06_06_wall-spot-light.html` in your source code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a light cone, we need to obtain one Lambert coefficient per fragment.
    As we did in previous examples, we obtain these coefficients in the fragment shader
    by calculating the dot product between the inverted light ray and the normal that
    has been interpolated. Thus far, we have been using one varying to do this: `vNormal`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So far, one varying has sufficed since we did not need to update the normals,
    regardless of how many lights we have in the scene. However, to create directional
    point lights, we do have to update the normals as the direction of each light
    will create a different normal. Therefore, we replace `vNormal` with a **varying
    array**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The line that subtracts the light direction from the normal occurs inside the
    `for` loop. This is because we do this for every light in the scene, as every
    light has its own light direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, the light direction is transformed by the Normal matrix while the light
    position is transformed by the Model-View matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the fragment shader, we calculate the Lambert coefficients: one per light
    and fragment. The key difference is this line in the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we obtain the interpolated updated normal per light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a cut-off by restricting the allowed Lambert coefficients. There
    are at least two different ways to obtain a light cone in the fragment shader.
    The first one consists of restricting the Lambert coefficient to be higher than
    the `uCutOff` uniform (cut-off value). Let''s take a look at the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The Lambert coefficient is the cosine of the angle between the reflected light
    and the surface normal. If the light ray is perpendicular to the surface, we obtain
    the highest Lambert coefficient, and as we move away from the center, the Lambert
    coefficients change following the cosine function until the light rays are completely
    parallel to the surface. This creates a cosine of `90` degrees between the normal
    and the light ray. This produces a Lambert coefficient of zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b57e091-9bea-41b5-893f-7166d1123723.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `ch06_06_wall-spot-light.html` in your browser if you havenâ€™t done so
    yet. Use the cut-off slider on the page. Notice how this affects the light cone
    by making it wider or narrower. After playing with the slider, youâ€™ll probably
    notice that these lights donâ€™t look very realistic. The reason is that the final
    color is the same regardless of what Lambert coefficient you obtained: as long
    as the Lambert coefficient is higher than the set cut-off value, you will obtain
    the full diffuse contribution from the three light sources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To refine the result, open the web page using your source code editor. Then,
    go to the fragment shader and multiply the Lambert coefficient in the line that
    calculates the final color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the web page with a different name (so you can keep the original) and
    then load it in your web browser. You will notice that the light colors are attenuated
    as you depart from the center of each light reflection on the wall. This may look
    better, but thereâ€™s a simpler way to create more realistic light cut-offs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a2fd092-74bf-4e9e-8572-1300cc67dd78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a cut-off by using an **exponential attenuation factor**. In
    the fragment shader, find the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Notice that weâ€™ve removed the `if` condition. This time, the attenuation factor
    is `pow(lambertTerm, 10.0 * uCutOff);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This modification works as the factor attenuates the final color exponentially.
    If the Lambert coefficient is close to zero, the final color will be heavily attenuated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a826c9ba-bc82-4ed7-b8eb-07be54f5b86e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the web page with a different name and load it in your browser. The improvement
    is dramatic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2302d070-2526-44fb-bbf2-aeff5ac0a930.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Weâ€™ve included the completed exercises here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ch06_07_wall-spot-light-proportional.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch06_08_wall-spot-light-exponential.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: Weâ€™ve learned how to implement directional point lights. We have also discussed
    attenuation factors that improve lighting effects.
  prefs: []
  type: TYPE_NORMAL
- en: Use of Color in the Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Itâ€™s time to discuss transparency and alpha blending. As mentioned before, the
    alpha channel can carry information about the opacity of the object color. However,
    as we saw in the cube example, itâ€™s not possible to obtain a translucent object
    unless alpha blending is activated. Things get a bit more complicated when we
    have several objects in the scene. To manage these difficulties, we need to learn
    what to do in order to have a consistent scene with translucent and opaque objects.
  prefs: []
  type: TYPE_NORMAL
- en: Transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first approach to render transparent objects is to use **polygon stippling**.
    This technique consists of discarding some fragments so that you can see through
    the object. Think of this as punching little holes in the surface of your object.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL supports polygon stippling through the `glPolygonStipple` function. This
    function is not available in WebGL. You could try to replicate this functionality
    by dropping some fragments in the fragment shader using the ESSL discard command.
  prefs: []
  type: TYPE_NORMAL
- en: More commonly, we can use the alpha channel information to obtain translucent
    objects. However, as weâ€™ve seen in the cube example, modifying the alpha values
    does not produce transparency automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Creating transparency corresponds to altering the fragments that weâ€™ve already
    written to the framebuffer. Think, for instance, of a scene where there is one
    translucent object in front of an opaque object (from our camera view). In order
    for the scene to be rendered correctly, we need to be able to see the opaque object
    through the translucent object. Therefore, the fragments that overlap between
    the far and near objects need to be combined somehow to create the transparency
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: The same idea applies when there is only one translucent object in the scene.
    The only difference is that the far fragments correspond to the back face of the
    object and the near fragments correspond to the front face of the object. To produce
    the transparency effect in this case, the far and near fragments need to be combined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly render transparent surfaces, we need to learn about two important
    WebGL concepts: **depth testing** and **alpha blending**.'
  prefs: []
  type: TYPE_NORMAL
- en: Updated Rendering Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depth testing and alpha blending are two optional stages for fragments once
    theyâ€™ve been processed by the fragment shader. If the depth test is not activated,
    all the fragments are automatically available for alpha blending. If the depth
    test is enabled, those fragments that fail the test will automatically be discarded
    by the pipeline and will no longer be available for any other operation. This
    means that discarded fragments will not be rendered. This behavior is similar
    to using the ESSL discard command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the order in which depth testing and alpha blending
    are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c72ca62c-eab7-4c54-bc9a-019313562a72.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's see what depth testing is about and why itâ€™s relevant to alpha blending.
  prefs: []
  type: TYPE_NORMAL
- en: Depth Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each fragment that has been processed by the fragment shader carries an associated
    depth value. Though fragments are two-dimensional since theyâ€™re rendered on the
    screen, the depth value keeps the information of how far the fragment is from
    the camera (screen). Depth values are stored in a special WebGL buffer named **depth
    buffer** or **z-buffer**. The `z` comes from the fact that `x` and `y` values
    correspond to the screen coordinates of the fragment, while the `z` value measures
    distance perpendicular to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the fragment has been calculated by the fragment shader, it becomes available
    for depth testing. This only occurs if the depth test is enabled. Assuming that
    `gl` is the JavaScript variable that contains our WebGL context, we can enable
    depth testing by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The depth test takes the depth value of a fragment into consideration and compares
    it to the depth value for the same fragment coordinates already stored in the
    depth buffer. The depth test determines whether that fragment is accepted for
    further processing in the rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Only the fragments that pass the depth test will be processed. Any fragment
    that does not pass the depth test will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: In normal circumstances, when the depth test is enabled, only those fragments
    with a lower depth value than the corresponding fragments present in the depth
    buffer will be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Depth testing is a commutative operation with respect to the rendering order.
    This means that no matter which object gets rendered first, as long as depth testing
    is enabled, we will always have a consistent scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate this with an example. The following diagram contains a cone
    and a sphere. The depth test is disabled using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The sphere is rendered first. As expected, the cone fragments that overlap
    the cone are not discarded when the cone is rendered. This occurs because there
    is no depth test between the overlapping fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25fad2cf-dab4-4ab0-89aa-f0926626d235.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's enable the depth test and render the same scene. The sphere is rendered
    first. Since all the cone fragments that overlap the sphere have a higher depth
    value (they are farther from the camera), these fragments fail the depth test
    and are discarded, creating a consistent scene.
  prefs: []
  type: TYPE_NORMAL
- en: Depth Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some applications, we may be interested in changing the default behavior
    of depth testing, which discards fragments with a higher depth value than those
    fragments in the depth buffer. For that purpose, WebGL provides the `gl.depthFunc(function)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method has only one parameter, the `function` to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.NEVER` | The depth test always fails. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.LESS` | Only fragments with a depth lower than current fragments on the
    depth buffer will pass the test. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.LEQUAL` | Fragments with a depth less than or equal to corresponding
    current fragments in the depth buffer will pass the test. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.EQUAL` | Only fragments with the same depth as current fragments on the
    depth buffer will pass the test. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.NOTEQUAL` | Only fragments that do not have the same depth value as fragments
    on the depth buffer will pass the test. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.GEQUAL` | Fragments with greater or equal depth value will pass the test.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.GREATER` | Only fragments with a greater depth value will pass the test.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.ALWAYS` | The depth test always passes. |'
  prefs: []
  type: TYPE_TB
- en: The depth test is disabled by default in WebGL. When enabled, if no depth function
    is set, the `gl.LESS` function is selected by default.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha Blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fragment is available for alpha blending only if it has passed the depth test.
    By default, depth testing is disabled and makes all fragments available for alpha
    blending.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alpha blending is enabled using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: For each available fragment, the alpha blending operation reads the color from
    the framebuffer by the appropriate fragment coordinates and creates a new color
    based on a linear interpolation between the previously calculated color in the
    fragment shader and the color from the framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha Blending
  prefs: []
  type: TYPE_NORMAL
- en: Alpha blending is disabled by default in WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: The Blending Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With blending enabled, the next step is to define a blending function. This
    function will determine how fragment colors from the object (source) are combined
    with the fragment colors present in the framebuffer (destination).
  prefs: []
  type: TYPE_NORMAL
- en: 'We combine source and destination colors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'More precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`S`: Source color (vec4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: Destination color (vec4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sW`: Source scaling factor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dW`: Destination scaling factor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S.rgb`: RGB components of the source color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S.a`: Alpha component of the source color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D.rgb`: RGB components of the destination color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D.a`: Alpha component of the destination color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Itâ€™s important to note that the rendering order will determine the source and
    the destination fragments. Following the example from the previous section, if
    the sphere is rendered first, it will then become the destination of the blending
    operation because the sphere fragments are stored in the framebuffer at the time
    that the cone is rendered. In other words, alpha blending is a non-commutative
    operation with respect to rendering order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/feef0be1-26ef-465c-b513-28e00b8bc4ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Separate Blending Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also possible to determine how the RGB channels are going to be combined
    independently from the alpha channels. For that, we use the `gl.blendFuncSeparate`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define two independent functions this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'More precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sW.rgb`: Source scaling factor (only RGB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dW.rgb`: Destination scaling factor (only RGB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sW.a`: Source scaling factor for the source alpha value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dW.a`: Destination scaling factor for the destination alpha value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we could have something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be translated into code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The parameters for the `gl.blendFuncSeparate` function are the same as `gl.blendFunc`.
    You can find more information on these functions later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The Blend Equation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could have a case where we do not want to interpolate the source and destination
    fragment colors with scale or add operations. For example, we may want to subtract
    one from the other. In this case, WebGL provides the `gl.blendEquation` function.
    This function receives one parameter that determines the operation on the scaled
    source and destination fragment colors. For example, `gl.blendEquation(gl.FUNC_ADD)`
    is calculated as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And, `gl.blendEquation(gl.FUNC_SUBTRACT)` corresponds to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a third option, `gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT)`, that
    corresponds to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As expected, you can define the blending equation separately for the RGB channels
    and for the alpha channel. For that, we use the `gl.blendEquationSeparate` function.
  prefs: []
  type: TYPE_NORMAL
- en: The Blend Color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebGL provides the `gl.CONSTANT_COLOR` and `gl.ONE_MINUS_CONSTANT_COLOR` scaling
    factors. These scaling factors can be used with `gl.blendFunc` and `gl.blendFuncSeparate`.
    However, we need to first establish the blend color. We do so by invoking `gl.blendColor`.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL Alpha-Blending API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table summarizes the WebGL functions that are relevant to performing
    alpha-blending operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **WebGL function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.enable&#124;disable(gl.BLEND)` | Enable/disable blending. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.blendFunc(sW, dW)` | Specify pixel arithmetic. Accepted values for `sW`
    and `dW` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ZERO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRC_COLOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DST_COLOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRC_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DST_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONSTANT_COLOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONSTANT_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONE_MINUS_SRC_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONE_MINUS_DST_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONE_MINUS_SRC_COLOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONE_MINUS_DST_COLOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONE_MINUS_CONSTANT_COLOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONE_MINUS_CONSTANT_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, `sW` can also be `SRC_ALPHA_SATURATE`. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `gl.blendFuncSeparate(sW_rgb, dW_rgb, sW_a, dW_a)` | Specify pixel arithmetic
    for RGB and alpha components separately. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.blendEquation(mode)` | Specify the equation used for both the RGB blend
    equation and the alpha blend equation. Accepted values for mode are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gl.FUNC_ADD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.FUNC_SUBTRACT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.FUNC_REVERSE_SUBTRACT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `gl.blendEquationSeparate(modeRGB, modeAlpha)` | Set the RGB blend equation
    and the alpha blend equation separately. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.blendColor(red, green, blue, alpha)` | Set the blend color. |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.getParameter(name)` | Just like with other WebGL variables, it is possible
    to query blending parameters using `gl.getParameter`. Relevant parameters are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gl.BLEND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.BLEND_COLOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.BLEND_DST_RGB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.BLEND_SRC_RGB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.BLEND_DST_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.BLEND_SRC_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.BLEND_EQUATION_RGB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gl.BLEND_EQUATION_ALPHA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Alpha Blending Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on the parameter selection for `sW` and `dW`, we can create different
    blending modes. In this section, we will see how to create additive, subtractive,
    multiplicative, and interpolative blending modes. All blending modes are derived
    from the previous formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The Blending Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Additive blending simply adds the colors of the source and destination fragments,
    creating a lighter image. We obtain additive blending by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This assigns the weights for source and destination fragments `sW` and `dW`
    to `1`. The color output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Since each color channel is in the `[0, 1]` range, blending will clamp all values
    over `1`. When all channels are `1`, this results in a white color.
  prefs: []
  type: TYPE_NORMAL
- en: Subtractive Blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, we can obtain subtractive blending by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This will change the blending equation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: All negative values will be set to `0`. When all channels are negative, the
    result is black.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplicative Blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We obtain multiplicative blending by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be reflected in the blending equation as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The result will always be a darker blending.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolative Blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we set `sW` to `S.a` and `dW` to `1 - S.a`, then we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a linear interpolation between the source and destination
    color using the source alpha color, `S.a`, as the scaling factor. In code, this
    is translated as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Interpolative blending allows us to create a transparency effect as long as
    the destination fragments have passed the depth test. As expected, this requires
    that the objects be rendered from back to front.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will play with different blending modes on a simple
    scene composed of a cone and sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Blending Workbench'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of these various blending functions in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch06_09_blending.html` file in your browser. You will see an interface
    like the one in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26723570-509d-46d5-95fe-a2093208bd24.png)'
  prefs: []
  type: TYPE_IMG
- en: This interface has most of the parameters that allow you to configure alpha
    blending. The default settings are source `gl.SRC_ALPHA` and destination `gl.ONE_MINUS_SRC_ALPHA`.
    These are parameters for interpolative blending. Which slider do you need to use
    to change the scaling factor for interpolative blending? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the sphere alpha slider to `0.5`. You will see some shadow-like artifacts
    on the surface of the sphere. This occurs because the sphere back face is now
    visible. To get rid of the back face, click on Back Face Culling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Reset button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the Lambert Term and Floor buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the Back Face Culling button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's implement multiplicative blending. What values do source and destination
    need to have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the `canvas`. Check that the multiplicative blending creates
    dark regions where the objects overlap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the blending function to `gl.FUNC_SUBTRACT` using the provided drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change Source to `gl.ONE` and Destination to `gl.ONE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What blending mode is this? Click and drag the `canvas` to check the appearance
    of the overlapped regions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try different parameter configurations. Remember you can also change the blending
    function. If you decide to use a constant color or constant alpha, please use
    the color widget and the respective slider to modify the values of these parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how the additive, multiplicative, subtractive, and interpolative
    blending modes work with a simple exercise.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen that the combination of `gl.SRC_ALPHA` and `gl.ONE_MINUS_SRC_ALPHA`
    produces transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Transparent Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Weâ€™ve learned that in order to create transparency, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable alpha blending and select the interpolative blending function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the faces of objects back to front
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we create transparent objects when there is nothing to blend them against?
    In other words, if thereâ€™s only one object, how can we make it transparent? One
    solution is to use **face-culling**.
  prefs: []
  type: TYPE_NORMAL
- en: Face-culling allows us to *only* render the back or front face of an object.
    We used this technique in the previous section when we only rendered the front
    face by enabling the Back Face Culling button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the color cube from earlier in this chapter. We are going to make
    it transparent. For that effect, we will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable alpha blending and use the interpolative blending mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable face-culling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the back face (by culling the front face).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the front face (by culling the back face).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to other options in the pipeline, culling is disabled by default. We
    enable it by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: To render only the back faces of an object, we call `gl.cullFace(gl.FRONT)`
    before we call `drawArrays` or `drawElements`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, to render only the front face, we use `gl.cullFace(gl.BACK)` before
    the draw call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the steps needed to create a transparent object
    with alpha blending and face-culling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28bfd5b0-2acb-4e74-9e47-37c2673177dd.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following section, we will see the transparent cube in action and take
    a look at the code that makes it possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Culling'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example showcasing culling in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch06_10_culling.html` file in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see that the interface is similar to the blending workbench exercise.
    However, on the top row, you will see these three options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alpha Blending: Enables or disables alpha blending.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Render Front Face: If active, renders the front face.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Render Back Face: If active, renders the back face.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember that for blending to work, objects need to be rendered back to front.
    Therefore, the back face of the cube is rendered first. This is reflected in the
    `draw` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Going back to the web page, notice how the interpolative blending function produces
    the expected transparent effect. Move the alpha value slider that appears under
    the button options to adjust the scaling factor for interpolative blending.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the interpolative blending function. In this case, the destination is
    the back face (rendered first) and the source is the front face. If the alpha
    source equals `1`, what would you obtain according to the function? Test the result
    by moving the alpha slider to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s visualize the back face only. For that, disable the Render Front Face
    button. Increase the alpha value using the alpha value slider. Your screen should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f601e12-975a-4aa6-b666-9ead2fbc6c8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Click and drag the cube on the `canvas`. Notice how the back face is calculated
    every time you move the camera around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Render Front Face again to activate it. Change the blending function
    so you can obtain subtractive blending.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try different blending configurations using the controls provided in this exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how face-culling and the alpha-blending interpolative mode can
    help us properly blend the faces of translucent objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to implement transparency when there are two objects on the
    screen. In this case, we have a wall that we want to make transparent. Behind
    it is a cone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Creating a Transparent Wall'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of how we''d make an object transparent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ch06_11_transparency-initial.html` in your browser. We have two completely
    opaque objects: a cone behind a wall. Click and drag the `canvas` to move the
    camera behind the wall and see the cone, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a5ebfd61-ef0b-48fa-b084-e039c0ff0e7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the wall alpha value by using the provided slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, modifying the alpha value does not produce any transparency.
    The reason for this is that alpha blending is not enabled. Let''s edit the source
    code to include alpha blending. Open the `ch06_11_transparency-initial.html` file
    in your source code editor. Scroll to the `configure` function and find these
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Below them, append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Save your changes as `ch06_12_transparency-final.html` and load this page on
    your web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As expected, the wall changes its transparency as you modify its alpha value
    using the respective slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that in order for transparency to be effective, the objects need to
    be rendered back to front. Let's take a look at the source code. Open `ch06_12_transparency-final.html`
    in your source code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The cone is the farthest object in the scene. Hence, it is loaded first. You
    can check that by looking at the `load` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'It occupies a lower index in the `scene.objects` list. In the `render` function,
    the objects are rendered in the order in which they appear in the `scene.objects`
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we rotate the scene so that the cone is closer to the camera
    and the wall is farther away?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `ch06_12_transparency-final.html` in your browser and rotate the scene
    such that the cone appears in front of the wall. Decrease the alpha value of the
    cone while the alpha value of the wall remains at `1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, the blending is inconsistent. This does not have to do with
    alpha blending because in `ch06_12_transparency-final.html`, the blending is enabled.
    It has to do with the **rendering order**. Click on the Wall First button. The
    scene should appear consistent now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9dee8429-19a6-42ab-bd95-067b32bfe57f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Cone First and Wall First buttons use a couple of new functions that we
    have included in the `Scene` class to change the rendering order. These functions
    are `renderSooner` and `renderFirst`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In total, we have added these functions to the `Scene` object to deal with
    rendering order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`renderSooner(objectName)`: Moves the `objectName` object one position higher
    in the `Scene.objects` list.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderLater(objectName)`: Moves the `objectName` object one position lower
    in the `Scene.objects` list.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderFirst(objectName)`: Moves the `objectName` object to the first position
    of the list (index 0).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderLast(objectName)`: Moves the `objectName` object to the last position
    of the list.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderOrder()`: Lists the objects in the `Scene.objects` list in the order
    in which they are rendered. This is the same order in which they are stored in
    the list. For any two given objects, the object with the lower index will be rendered
    first.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use these functions from the JavaScriptÂ consoleÂ in your browser and
    see what effect these have on the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We took a simple scene where we implemented alpha blending. After that, we analyzed
    the importance of the rendering order in creating consistent transparencies. Finally,
    we presented the new methods of the `Scene` object that control the rendering
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Letâ€™s summarize what we learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to extensively use colors with objects, lights, and in the scene.
    Specifically, weâ€™ve learned that an object can be colored per vertex, per fragment,
    or can have a constant color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We reviewed lights and the various approaches to lighting models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered how to create lights of different colors and leveraged concepts from
    directional and point lights to create spot lights. By introducing several light
    sources in our scene, we updated our architectural patterns and used uniform arrays
    to reduce the complexity of creating and mapping uniforms between JavaScript and
    ESSL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned that proper translucency requires more than just using alpha values
    in our color vectors. Because of this, we explored various blending behaviors,
    render sequences, and WebGL functions to create translucent objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how face-culling can help produce better results when there are multiple
    translucent objects present in the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to leverage textures to help us render
    images in our scene.
  prefs: []
  type: TYPE_NORMAL
