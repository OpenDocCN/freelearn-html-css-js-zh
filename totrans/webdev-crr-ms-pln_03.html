<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-82"><a id="_idTextAnchor082"/>3</h1>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Expanding the Foundations – Building a User Registration Page, Front to Back!</h1>
<p>At this point, you’ve started building the technical foundations and have some context around web development. You’ve also seen some of the frontend (the client) and some of the backend (the server), but so far, you haven’t seen them put together. Let’s address that now!</p>
<p>In the process, you’ll first learn a little bit about networking, since the internet and websites are all built on top of networking. You’ll then get some exposure to more HTML, CSS, JS, and Node, and you’ll do this by building another simple web page and seeing how it communicates with the server side now.</p>
<p>The goal here is to see how the client and server connect, how information is transmitted to the server, and how the server handles it and returns a response. This is part and parcel of what we do every day in web development, so clearly, it’s of paramount importance. Not only will you get some exposure to this but you’ll also do so in two different ways, ensuring that you can see that there is more than one way to skin a cat in web development.</p>
<p>You’ll also learn a little bit about the tools available to you that come with your web browser and how valuable they are, as they are tools you’ll interact with constantly as you work to debug and get things working exactly right.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>Connecting over a network</li>
<li>Building an interactive web app – the frontend</li>
<li>Building an interactive web app – the backend</li>
<li>Exploring a different approach – single-page apps</li>
<li>Loving your new best friend – DevTools</li>
</ul>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Technical requirements</h1>
<p>For the purposes of this chapter, the only thing you’ll require is having Node installed and working, which you should have done in the previous chapter. You’ll also want to be sure you’ve downloaded all of the source code for this book from GitHub (<a href="https://github.com/PacktPublishing/Web-Development-Career-Master-Plan">https://github.com/PacktPublishing/Web-Development-Career-Master-Plan</a>), which you can find in the <em class="italic">Technical requirements</em> section of <a href="B18315_02.xhtml#_idTextAnchor061"><em class="italic">Chapter 2</em></a>. As you’ve probably noticed by now, each chapter has its own directory in the downloaded code, so you’re interested in the <code>ch-03/1-form</code> and <code>ch-03/2-spa</code> directories for this chapter.</p>
<p>That’s really all you need for this chapter, so now, let’s build ourselves a user registration page!</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Connecting over a network</h1>
<p>Before we actually get<a id="_idIndexMarker180"/> to developing code, let’s first talk about something more fundamental, networking, and how the web communicates over a network.</p>
<p>I mentioned <strong class="bold">IP</strong> (<strong class="bold">Internet Protocol</strong>) in the last chapter, but I didn’t go<a id="_idIndexMarker181"/> into too much detail. I really won’t go into it too much here either because when we talk about network protocols, which include IP, it quickly becomes an expansive topic. However, as a web developer, you should know at least the basics.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>Understanding IP</h2>
<p>IP, as the second word in the<a id="_idIndexMarker182"/> acronym states, is a protocol. A protocol is simply an agreed-upon standard for how two things communicate. In this case, IP<a id="_idIndexMarker183"/> describes how small bits of data called <strong class="bold">datagrams</strong> are transmitted between two machines over a network. As you saw in <a href="B18315_02.xhtml#_idTextAnchor061"><em class="italic">Chapter 2</em></a>, it’s also what is responsible for giving each machine an IP address that uniquely identifies them on the network.</p>
<p>However, it may surprise you to learn that IP doesn’t guarantee the delivery, order, or integrity of the datagrams it transmits. In other words, if you want to send a picture from one machine to another, that picture will be broken up into many datagrams, and they will be transmitted over the network using IP, but they may or may not reach the destination, may or may not be in the proper order for the other machine to reconstruct the image (in fact, the receiving machine wouldn’t even have a way to know what order they should go in), and may or may not be corrupted in some way. IP is considered a “best-effort” protocol, meaning it’ll <em class="italic">try</em> to get data from machine A to machine B, but it’s not guaranteed.</p>
<p>If that sounds like a recipe<a id="_idIndexMarker184"/> for disaster, you’re right! But the benefit of it is that it is very simple and fast, and when you have something simple and fast in technology, it’s almost always easy to extend it or build something on top of it (we’re big on layers in software engineering). And that’s exactly where TCP comes in.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Understanding TCP</h2>
<p><strong class="bold">TCP</strong>, which stands for <strong class="bold">Transmission Control Protocol</strong>, works in conjunction<a id="_idIndexMarker185"/> with – or <em class="italic">on top of</em> – IP by ensuring that when information is sent, it is sent reliably. It begins by breaking the data<a id="_idIndexMarker186"/> to be sent down into <strong class="bold">packets</strong> (which IP will then further break down into datagrams), and it ensures that the packets all arrive at the destination, that they are error-free, and that they tell the receiver what order everything all goes in. It does this by establishing a connection between machines and then sending the packets, which the receiver will then examine. The packets contain data that the receiver can use to validate that the data is correct. They also include sequence numbers, which tell the receiver what order they go in. If a packet is corrupt, or if the receiver finds some missing, it can request the sender to resend the data, which is another key thing that TCP provides.</p>
<p>TCP/IP is a great combination because, in a large network with a lot of machines (like the internet), there are a lot of routes between them and connections that packets can be transmitted across. If one connection is broken – maybe because someone accidentally cut a network cable while doing some roadwork – a different route can be chosen. In such a scenario, the fact that IP doesn’t provide concrete guarantees doesn’t matter because TCP on top of it has all the information it needs to request a retry from the sender as needed, and this can continue until all the data is received correctly and in the right order. This provides redundancy for the network. Yes, if packets suddenly must travel halfway around the world to get where they’re going, things will slow down a bit, but the data will still get there, and that’s the key thing TCP provides when working in conjunction with IP.</p>
<p>However, while TCP/IP serves<a id="_idIndexMarker187"/> as, conceptually, the foundational protocols of the internet, the web has its own protocol that sits on top of TCP/IP, and that’s HTTP.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>Understanding HTTP</h2>
<p>You can think of <strong class="bold">HTTP</strong>, which is an acronym for <strong class="bold">HyperText Transfer Protocol</strong>, as the foundation<a id="_idIndexMarker188"/> for data communication on the web.</p>
<p>HTTP works as a request-response model between two machines, one acting as a client and one acting as a server. HTTP<a id="_idIndexMarker189"/> is what we call a <strong class="bold">stateless</strong> protocol, which means that each request is independent. In other words, when you enter a URL in your browser, a connection is established from your machine to the server, but that connection ends once the HTML page is returned to you. When an image or style sheet needs to be retrieved, a new connection is established. Well, more modern versions of HTTP will actually reuse connections to some degree, but the connections still don’t last forever, which is what we mean by stateless – there is not a constant connection between the two machines.</p>
<p>When you use HTTP to connect from one machine to another, each request uses an HTTP method, which comprises a basic set of operations that can be used to interact with a server. They are meant to, at least generally, convey to the server what the client wants to do. Note that this is different from a JS method – a function that is attached to an object – and is really just a fancy way of saying that it tells us what <em class="italic">kind</em> of HTTP request is made.</p>
<p>HTTP defines several<a id="_idIndexMarker190"/> methods, where each one has a typical (although not concrete) intended use:</p>
<ul>
<li><strong class="bold">GET</strong>: Retrieve data from the server</li>
<li><strong class="bold">POST</strong>: Send data to be processed by the server</li>
<li><strong class="bold">PUT</strong>: Update existing data on the server</li>
<li><strong class="bold">DELETE</strong>: Remove data from the server</li>
<li><code>GET</code> but a more limited version</li>
<li><strong class="bold">OPTIONS</strong>: Discover allowed<a id="_idIndexMarker191"/> methods on a resource</li>
</ul>
<p>When you enter a URL in your browser, a <code>GET</code> request is made. That makes sense if you think about it – your browser is asking for data from the server, an HTML document usually. Other situations call for other methods – when you’re sending information to the server, you will probably use <code>POST</code> or <code>PUT</code>, depending on the situation – but you’ll see how choosing other methods comes into play in just a little while.</p>
<p>It’s worth noting <a id="_idIndexMarker192"/>that HTTP, being closely tied to HTML, has a similar concept to the head and body in HTML, instead called the <strong class="bold">headers</strong> and body. Headers<a id="_idIndexMarker193"/> are bits of data that provide some metadata to the receiver. There are a substantial number of headers, and you can create your own too, so I’m not going to go into any here; instead, I’ll opt to introduce headers when necessary later. However, one thing I <em class="italic">will</em> tell you<a id="_idIndexMarker194"/> is that they are sent in <strong class="bold">key-value pairs</strong>. This is a common programming idea that looks like this:</p>
<pre class="source-code">
first_name:Frank</pre> <p>Alternatively, it can look like this:</p>
<pre class="source-code">
first_name=Frank</pre> <p>Whether a colon or equal sign (or possibly some other character) is used depends on the context, but the key point is that you have a key (<code>first_name</code>) and a value (<code>Frank</code>). The value is identified by the key. You can almost think of them as variables in JS in that you can look up the value associated with a key when needed.</p>
<p>The body of an HTTP request can contain arbitrary data, whether that’s text, an image, an audio file, or anything else. When an HTTP request has a body and data in it, almost always it will use a <code>POST</code> method. You’re about to see an example of that, as part of a discussion of something else – HTML forms.</p>
<p class="callout-heading">HTTP versus HTTPS</p>
<p class="callout">Oh, and if that<a id="_idIndexMarker195"/> wasn’t enough, there’s also HTTPS. Fortunately, that’s simple – it’s just HTTP but encrypted, with the <strong class="bold">S</strong> standing for <strong class="bold">Secure</strong>. If you see a URL with HTTP, it means that all the content sent back and forth using that connection could potentially be looked at by other people on the network (it’s not quite that easy to do, but it’s also not especially difficult). With HTTPS though, all that content is encrypted, and without<a id="_idIndexMarker196"/> some secret information called <em class="italic">keys</em>, a person who intercepts the data would essentially see a lot of gibberish.</p>
<p class="callout">There was a time when HTTPS was only used for sensitive sites such as banking sites and shopping sites. That’s because, for a long time, the encryption and decryption process – which is based on some complex mathematics – was an expensive thing for computers to do. It was expensive in terms of money and, more importantly, in terms of performance. An HTTPS connection would simply be slower than an HTTP one. However, nowadays, that’s no longer the case. Computers are fast enough and often have specialized hardware specifically for encryption/decryption, so most connections are, in fact, HTTPS now. Browsers will even make you aware that a connection isn’t secure, and some will even disallow a non-HTTPS connection entirely.</p>
<p class="callout">For most intents and purposes, you can generally treat HTTP and HTTPS connections the same. However, in terms of development, setting up an HTTPS connection takes some additional configuration that can be non-trivial to set up. If you ever hear the term <em class="italic">certificates</em>, that’s what’s involved. That’s a whole other topic that can get rather complicated, so it won’t be covered in this book. When developing on your own machine, you can simply use HTTP, which is what will be used by default if you don’t explicitly set up HTTPS, and you needn’t worry about certificates and all that unless and until you really have to.</p>
<p>With this basic understanding of how things communicate over the internet (and most networks generally) in hand, we can now move on to building the aforementioned registration app.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Building an interactive web app – the frontend</h1>
<p>For this chapter, rather than just using<a id="_idIndexMarker197"/> simple HTML as you’ve previously seen, let’s create an application that looks somewhat more “real.” By that, I mean let’s create something you might actually have to build on the job someday – a user registration page.</p>
<p>The goal will be simple – give a user a way to enter a few key pieces of information (their title, first and last names, age, and email address) and then send that information to a server, where we’ll generate a response to confirm that the user is now registered. We won’t actually register the user in any fashion – we won’t even store the information they sent – but it’ll be enough<a id="_idIndexMarker198"/> to see how such a client-server interaction works.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>Building a registration page</h2>
<p>The first step is to build a page<a id="_idIndexMarker199"/> where the user enters<a id="_idIndexMarker200"/> their information.</p>
<p>Well, I take that back, because the <em class="italic">real</em> first step is to start a project. As you learned in the previous chapters, this can be as simple as creating an HTML file; however, you also saw how you can use NPM to create a new project. Since we know we’ll be building a server later for this project, let’s go ahead and do that now.</p>
<p>As before, simply create a directory, go to a command prompt, navigate to the directory, and execute <code>npm init</code>. For now, you can just press <em class="italic">Enter</em> for every question, as this will be sufficient for our needs.</p>
<p>Once that’s done, it’s time to write some HTML, the result of which will be what you see in <em class="italic">Figure 3</em><em class="italic">.1</em>.</p>
<div><div><img alt="Figure 3.1: The registration page we’re building" src="img/B18315_03_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: The registration page we’re building</p>
<p>You would begin this project by creating a file in your project directory, named <code>index.html</code>, and then get to work writing the code in it. Of course, I’ve already done that part for you! In the GitHub repo, you’ll find this file in the <code>ch-03/1-form</code> directory. Since there is a bit more to it than in the prior examples, we’ll tackle it bit by bit, breaking it down<a id="_idIndexMarker201"/> into manageable<a id="_idIndexMarker202"/> chunks, starting with <code>&lt;head&gt;</code>.</p>
<h3>Creating the head</h3>
<p>For our registration page, we start <a id="_idIndexMarker203"/>the HTML document, as before, with an <code>&lt;html&gt;</code> tag and then a <code>&lt;head&gt;</code> section within it:</p>
<pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;User Registration&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="styles.css" /&gt;
  &lt;/head&gt;</pre> <p>By now, the code should be starting to make some sense to you, since you’ve seen it before.</p>
<p>However, unlike the examples shown in the previous chapters, there is no <code>&lt;style&gt;</code> block in <code>&lt;head&gt;</code>. Instead, all the CSS is in an external <code>styles.css</code> file. I did this for one main reason – so that I could skip the CSS for now! There’s not much CSS to deal with at all; however, it will make more sense if you see how HTML styles it first, so we’ll be coming back to it at the end. For now, just know that the style sheet file gets imported by the <code>&lt;link&gt;</code> tag and acts as if it were a <code>&lt;style&gt;</code> block directly in <code>&lt;head&gt;</code>, as seen in the previous chapters.</p>
<p>There is also no JS in this project, so that’s actually all there is for <code>&lt;head&gt;</code>. Now, we can move on to creating <code>&lt;body&gt;</code>.</p>
<h3>Creating the body</h3>
<p>As with <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code> starts out very<a id="_idIndexMarker204"/> simply:</p>
<pre class="source-code">
&lt;body&gt;
    &lt;h1&gt;User Registration&lt;/h1&gt;
    &lt;p&gt;Please enter the following information to register for our website&lt;/p&gt;
&lt;/body&gt;</pre> <p>As you can see, we have a heading with a paragraph of text under it. Of course, you know there’s more – all those fields you saw in <em class="italic">Figure 3</em><em class="italic">.1</em> where the user can enter their information<a id="_idIndexMarker205"/> and the button to submit it – but all of those constitute a new concept that I’ll introduce now – forms.</p>
<h3>Getting to know forms</h3>
<p>In HTML, forms<a id="_idIndexMarker206"/> are how we provide a way for users to enter information. A form consists of one or more form fields, and these fields come in several types. You may not realize it, but unless you’ve literally never used a website, then you know many of these fields, even if you don’t realize you do. Putting that aside, it all starts with defining a form itself, and with HTML, that means a new tag:</p>
<pre class="source-code">
&lt;form action="/register" method="post"&gt;</pre> <p>The <code>&lt;form&gt;</code> tag is how we begin a form. This tag has several attributes, but the two key ones are <code>action</code> and <code>method</code>.</p>
<p>The <code>action</code> attribute tells the browser what URL to send the information the user enters. You can express this URL as an <em class="italic">absolute</em> URL or a <em class="italic">relative</em> URL.</p>
<p>An absolute URL contains all the information needed to get to a given resource. For example, www.packt.com/takeMyInfo is an absolute URL because it starts with a domain name and includes a full path to a resource on the server. <a href="http://www.packt.com/books/zammetti/forms/takeMyInfo ">www.packt.com/books/zammetti/forms/takeMyInfo </a>might be another (this is fake, for the record!) example of an absolute URL.</p>
<p>What, then, is a relative URL? A relative URL starts from an absolute URL or, more precisely, <em class="italic">part</em> of one. /takeMyInfo is an example of a relative URL. If the document that uses that URL is loaded from <a href="http://www.packt.com">www.packt.com</a>, the browser interprets all relative URLs as being relative to that base URL. So, the full URL that /takeMyInfo leads to is www.packt.com/takeMyInfo.</p>
<p>In a more complex example, /books/zammetti/forms/takeMyInfo could be a relative URL. If you loaded an HTML document from <a href="http://www.packt.com/books/zammetti">www.packt.com/books/zammetti</a>, then you could have a relative URL of /forms/takeMyInfo, since the two get joined together by the browser behind the scenes, forming the absolute URL that it will then request resources with.</p>
<p>In this <code>&lt;form&gt;</code> though, <code>/register</code> is the URL the form will be sent to, and you’ll see what is there waiting for it later when we talk about the server part of this project.</p>
<p>The other key attribute is <code>method</code>. This is the HTTP method used to transmit the form, and it will be either <code>GET</code> or <code>POST</code>. The difference is that when it’s <code>GET</code>, the information on the form<a id="_idIndexMarker207"/> is added to the URL as a <code>?aaa=bbb&amp;…</code> form, where <code>aaa</code> is a key and <code>bbb</code> is a value. For example, in this form, we’re going to ask the user for their first name and last name. If this information is sent via <code>GET</code>, a query string will be appended to the URL as <code>?first_name=Frank&amp;last_name=Zammetti</code>.</p>
<p>This is fine in some cases, but in most, it’s a bad<a id="_idIndexMarker208"/> idea because it has security implications and also because a URL has a size limit, and the information might be larger than you have space for. So, you can POST the information instead, which will cause the browser to send it in the body of the HTTP request, where there is effectively no limit and where it’s not <em class="italic">quite</em> as exposed to the world (it’s still quite easy to get, but every little bit helps).</p>
<p>Once we have <code>&lt;form&gt;</code>, we can start adding fields to it:</p>
<pre class="source-code">
&lt;p&gt;
  Title
  &lt;br&gt;
  &lt;input type="radio" name="title" value="Mr"&gt;Mr
  &lt;input type="radio" name="title" value="Mrs"&gt;Mrs
  &lt;input type="radio" name="title" value="Miss"&gt;Miss
&lt;/p&gt;</pre> <p>The <code>&lt;p&gt;</code> tag is, strictly speaking, not necessary in a form. In fact, you can define your HTML and your layout however you like, but here, I just want each field to go down the screen, so putting each field in <code>&lt;p&gt;</code> does the job simply. I want each field to have a text label too, and that’s where the <code>Title</code> text comes in. I want that label to be above the field itself, so <code>&lt;br&gt;</code>, a line break in other words, ensures this.</p>
<p>An <code>&lt;input&gt;</code> tag defines a field<a id="_idIndexMarker209"/> in the form where the user can enter information. In most cases, a single-entry field on the screen is also a single <code>&lt;input&gt;</code> tag in the HTML, with a <code>type</code> attribute that tells the browser what kind of field it is out of several choices. However, in the case of a <code>radio</code> button, which is the type of control where you can select one and only one from a set of options, there will be multiple <code>&lt;input&gt;</code> tags of type <code>radio</code>, one for each option. The <code>name</code> attribute tells the browser what the name – the key – of the input value should be in the form. Here, we’re saying that in this form, we want to have a key named <code>title</code>, and it will have one of the three values available (which are defined literally by the <code>value</code> attribute of each <code>&lt;input&gt;</code> element). When the user selects one of the three options, the <code>title</code> value in the form will reflect that selected <code>value</code>.</p>
<p>If that seems a bit confusing, don’t worry – I think you’ll find it makes more sense later in this chapter when you see the server interaction.</p>
<p>After that comes two <code>&lt;input&gt;</code> fields, for the first and last names:</p>
<pre class="source-code">
&lt;p&gt;
  First name
  &lt;br&gt;
  &lt;input type="text" name="first_name" size="20"&gt;
&lt;/p&gt;
&lt;p&gt;
  Last Name
  &lt;br&gt;
  &lt;input type="text" name="last_name" size="30"&gt;
&lt;/p&gt;</pre> <p>Here, we have another kind of <code>&lt;input&gt;</code> field – a <code>text</code> field. This allows the user to enter any arbitrary text they want to. Then, again, the <code>type</code> attribute tells the browser what kind of field we want, and <code>name</code> tells it what key will hold the value the user enters.</p>
<p>The <code>size</code> attribute tells the browser how large the field physically is, and it’s defined as how many characters wide the field should be. When we talk about non-proportional fonts – meaning that each character takes up a variable amount of space (the letter “I” doesn’t take us as much space<a id="_idIndexMarker210"/> horizontally as “W” does, for instance) – this value can be a little fungible. But, as a rule of thumb, if <code>size</code> is <code>20</code>, then you can generally see 20 characters at a time in it, give or take a little. Note that this does not set a limit on how many characters can actually be entered; the field will scroll if you enter more than the size attribute allows for (there is a <code>maxlength</code> attribute that sets a limit on how many can be entered).</p>
<p>Next, we have a different kind of input field:</p>
<pre class="source-code">
&lt;p&gt;
  Age
  &lt;br&gt;
  &lt;input type="number" name="age" min="13" max="100" step="1"&gt;
&lt;/p&gt;</pre> <p>A <code>type</code> of <code>number</code> ensures that only numeric values can be entered; if you try to enter a letter, the browser won’t allow it. In addition, most browsers will show up and down arrows to allow the user to scroll through available values. This tag allows us to set a limit on the numbers entered; here, 13–100 is allowed by setting the <code>min</code> and <code>max</code> attributes.</p>
<p>Next, the <code>step</code> attribute tells us by what increment the number changes when the arrow buttons are used (if the value were 2 instead of 1, then it would jump from 13 to 15 to 17 when the up arrow is clicked, for example).</p>
<p><em class="italic">Figure 3</em><em class="italic">.2</em> shows the presentation of the up and down arrows, which could be different depending on the browser (this example is from Chrome):</p>
<div><div><img alt="Figure 3.2: How Chrome shows the arrows in a number field" src="img/B18315_03_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: How Chrome shows the arrows in a number field</p>
<p>After that comes the final input field:</p>
<pre class="source-code">
&lt;p&gt;
  Email Address
  &lt;br&gt;
  &lt;input type="email" name="email"&gt;
&lt;/p&gt;</pre> <p>The <code>email</code> type ensures that the value<a id="_idIndexMarker211"/> entered is a valid email address. If you enter a value that isn’t valid (<code>none@@@nowhere</code>, for example), the field will be highlighted, and hovering over it will show a tooltip explaining the problem. Note that the presentation of this is browser-specific, but <em class="italic">Figure 3</em><em class="italic">.3</em> shows what you should see when hovering over the field in Chrome:</p>
<div><div><img alt="Figure 3.3: How Chrome shows errors in an email field" src="img/B18315_03_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: How Chrome shows errors in an email field</p>
<p>After the input fields, we need a button for the user to click to send the information to the server:</p>
<pre class="source-code">
&lt;button type="submit"&gt;Register Now&lt;/button&gt;</pre> <p>There are several types of buttons, and you’ll see another later in this chapter, but <code>submit</code> is perhaps the most important, as it literally tells the browser that, when clicked, it needs to send the information entered to the server. The text between the opening and closing <code>&lt;button&gt;</code> tags is the label that will be shown on the button.</p>
<p>Only one thing remains now, and that’s to close the form properly:</p>
<pre class="source-code">
&lt;/form&gt;</pre> <p>With all that done, we have ourselves<a id="_idIndexMarker212"/> a complete HTML form that will send its information to the specified <code>action</code> URL when the user clicks the button. But we’re not quite done yet; we still have an HTML document to complete!</p>
<h3>Finishing the body and the document</h3>
<p>Of course, we have to close the body<a id="_idIndexMarker213"/> of the document using the following:</p>
<pre class="source-code">
&lt;/body&gt;</pre> <p>Then, we have to close the document<a id="_idIndexMarker214"/> itself using the following:</p>
<pre class="source-code">
&lt;/html&gt;</pre> <p>With those tasks complete, we now<a id="_idIndexMarker215"/> have a complete HTML page.</p>
<p>Remember when I said we’d skip the style sheet earlier? Well, it’s time to look at that now!</p>
<h3>Adding some style</h3>
<p>Earlier, you saw<a id="_idIndexMarker216"/> that the <code>styles.css</code> file is imported in <code>&lt;head&gt;</code>. The content in this file isn’t very voluminous, but it demonstrates a few new CSS concepts:</p>
<pre class="source-code">
input:invalid {
  outline: 2px solid red;
}</pre> <p>The first new concept is <code>&lt;a&gt;</code> tag can be displayed in three different states – when the user has never clicked it (unvisited), when the user has clicked it before (visited), and when the user’s mouse pointer hovers over it. If you want a link to be red when unvisited, blue when visited, and green when hovered over, you can create a CSS class with the names <code>a:visited</code>, <code>a:unvisited</code>, and <code>a:hover</code>, setting the appropriate <code>color</code> property value on each. The colon and the word after it are the pseudo-class.</p>
<p>In this case, I want to ensure that the email field specifically will have a red border when an invalid email address is entered. Fortunately, there is a pseudo-class on the input selector for that, namely <code>:invalid</code>. So, <code>input:invalid</code> is the selector to use to target an invalid input field.</p>
<p>The second new concept is the <code>outline</code> property. This property allows us to draw a border around an element (it’s one of two ways to do this, and you’ll see the other later). This property also actually<a id="_idIndexMarker218"/> demonstrates a third bonus concept – <strong class="bold">shorthand properties</strong>. Let me explain that a bit.</p>
<p>You see, there are three things defined by this property:</p>
<ul>
<li>The width of the border to draw around the field (2 pixels – <code>px</code> is short for pixels, which are the dots that make up the picture on your monitor)</li>
<li>The style of the border (<code>solid</code> here)</li>
<li>The color of the border</li>
</ul>
<p>These could each be defined by independent properties too – <code>outline-width</code>, <code>outline-style</code>, and <code>outline-color</code>. However, just using the <code>outline</code> shorthand property allows us to set all three at once.</p>
<p>Several groups of related properties have shorthand properties like this in CSS, and you’ll see some more of them later too. However, to not keep you in suspense, some of the others<a id="_idIndexMarker219"/> include <code>margin</code> (shorthand for <code>margin-top</code>, <code>margin-bottom</code>, <code>margin-left</code>, and <code>margin-right</code>), <code>padding</code> (shorthand for <code>padding-top</code>, <code>padding-bottom</code>, <code>padding-left</code>, and <code>padding-right</code>), <code>background</code> (shorthand for <code>background-color</code>, <code>background-image</code>, <code>background-repeat</code>, <code>background-attachment</code>, and <code>background-position</code>), and <code>font</code> (shorthand for <code>font-style</code>, <code>font-weight</code>, <code>font-variant</code>, <code>font-size</code>/<code>line-height</code>, and <code>font-family</code>).</p>
<p>Now that we have a frontend (a client), let’s build a backend (a server) for it to talk to. This will require us to write some code that will accept the data the user enters on the form and return a response of some sort for the browser to display to them. Let’s get to work!</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Building an interactive web app – the backend</h1>
<p>To build the server for this little <a id="_idIndexMarker220"/>project, we’ll again use Node. However, rather than write a server from scratch as we did in the last chapter, this time we’ll use possibly the most popular package available for Node to take care of a lot of the basic details for us – Express.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Introducing Express</h2>
<p>When you write a Node<a id="_idIndexMarker221"/> server from scratch, you must take care of all of the details yourself. That means that, for example, if you want to have a server respond to multiple different URLs, in your handler function you’ll need to examine the URL that was requested and, based on it, branch to a piece of code to return the appropriate response. It doesn’t take too long for an application to become large enough that this becomes a real headache.</p>
<p>So, very often, we’ll use an add-on package for Node that handles a lot of that for us – one such package is called <strong class="bold">Express</strong>. Express is actually a very<a id="_idIndexMarker222"/> powerful module that can handle all sorts of things for us, including security, file uploads and downloads, the logging of operations, and templating (the ability to have HTML and other response types built in a generic way that can then have data plugged into an outline, or template, to return a full response).</p>
<p>Express is also the first <strong class="bold">framework</strong> you’re meeting. A framework<a id="_idIndexMarker223"/> is a pre-written code library that provides a foundation to build your own code. It offers a defined structure to your code, so you don’t have to guess and make it up yourself, and it pushes you to use best practices. In essence, they are meant to make it easier to develop software and allow you to write less code yourself, which as a general rule is a good thing, since it means fewer opportunities for you to make mistakes.</p>
<p>To be more specific, Express<a id="_idIndexMarker224"/> is what’s called an “unopinionated” framework. Whereas opinionated frameworks<a id="_idIndexMarker225"/> ensure that there’s really only one “right” way to do things, and you’d better do it that way or you’ll find yourself having a challenging time, unopinionated frameworks don’t force as much on you. Express, being unopinionated, allows you much more flexibility and, while saving you a lot of effort, still allows you to do things your way for the most part. The debate about whether opinionated or unopinionated frameworks are better is an age-old one that I’m not even going to attempt to answer here!</p>
<p>To get started with Express, we have to add it as a dependency of our project, so let’s do that now.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Adding dependencies</h2>
<p>Remember the <code>package.json</code> file that was created<a id="_idIndexMarker226"/> when you ran the <code>npm init</code> command? I said that it provides Node and NPM metadata about our project, but I also said we’d largely ignore it. Well, we <em class="italic">have</em> to look at it now!</p>
<p>Here’s what I got from the <code>npm init</code> command (remember, yours could look slightly different depending on the values you may have entered, but it should look <em class="italic">substantially</em> the same):</p>
<pre class="source-code">
{
  "name": "form-example",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "4.18.2"
  }
}</pre> <p>Most of this is still ignorable, but one thing we now have to care about is the <code>dependencies</code> element. This tells Node and NPM what packages our project depends on. Yours will be empty at this point, but I’ve already added the Express dependency in mine, and I’ve also specified exactly which version I want. If you<a id="_idIndexMarker227"/> head over to <a href="https://www.npmjs.com">https://www.npmjs.com</a>, you can explore all the different packages available. NPM uses this site to download the dependencies you add to your <code>package.json</code> file.</p>
<p>But how do you actually <a id="_idIndexMarker228"/>add a dependency into <code>package.json</code>? Well, given that this is just a text file, you could just go and edit it by hand. However, there is a better way. First, execute this command:</p>
<pre class="source-code">
npm install -save express@4.18.2</pre> <p>Then, open <code>package.json</code> again, and you should now find the same dependency entry as shown in that command. The <code>npm install</code> command tells NPM to install the package you name in your project (it gets added to <code>node_modules</code>).</p>
<p>Here, I’ve specified the version as <code>@4.18.2</code>. You don’t <em class="italic">have</em> to specify the version like this, and in fact, you usually will not want to. What will happen when you don’t is that NPM will install whatever the latest version of the package is. I’ve specified the version explicitly here because, with a book, you need to ensure that a reader, months or years after the book was written, will still get the exact right versions that are known to work with the code; otherwise, a newer version might possibly not work with the code as written and described by the text (I’ve learned this lesson the hard way!)</p>
<p>Finally, in order to update the <code>package.json</code> file, we need to specify the <code>–save</code> option. Not doing so will cause NPM to install Express in <code>node_modules</code> but not add it to the list of dependencies in the <code>package.json</code> file. When you’re just experimenting with a new package and don’t yet know whether you’ll continue to use it in your project, not specifying <code>–save</code> is good because nothing is permanently altered that way. But since we know we want Express to stick around, we <em class="italic">do</em> want to update the file, and the reason you want the file to be updated is that you can give another developer your <code>package.json</code> file, and all they have to do is execute this command:</p>
<pre class="source-code">
npm install</pre> <p>NPM will then look in <code>package.json</code> and install all the dependencies listed. That way, the developer is ready to work on your code and will have all the same dependencies as you.</p>
<p>It’s something you wouldn’t know<a id="_idIndexMarker229"/> unless you’ve experienced it, but setting up a new developer’s development environment hasn’t always been that easy. In the past, they would have to go to the internet and manually download all the dependencies – which weren’t always on one site – and that’s assuming they even had a list of what was needed. NPM, through its <code>package.json</code> file, solves all those problems!</p>
<p>The last thing I want to mention is that if you look in your project directory, you’ll find a new directory has been created, called <code>node_modules</code>. This is a directory that NPM creates to keep all the packages it downloads in. For the most part, you don’t need to look at this directory or care what’s in it; just let Node and NPM do their thing with it. You should also be aware that it can get rather large at times because if a package itself depends on another package, then that package will be downloaded, and that sort of chain of dependencies can keep going for a while. So, <code>node_modules</code> will be stuffed with packages you don’t recognize because they all have dependencies. That’s how it’s meant to work. If you ever delete <code>node_modules</code>, that’s fine; you can just run <code>npm install</code> again and it will be recreated.</p>
<p>Now that we have the dependencies added that we need, let’s address one issue that you may not have even realized in the code for the previous chapter – that of developer efficiency – and in the process, you’ll see<a id="_idIndexMarker230"/> a new capability that the <code>package.json</code> file provides for – scripts.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Adding scripts</h2>
<p>In the past, starting our server<a id="_idIndexMarker231"/> would be done with the <code>node index.js</code> command. However, when another developer wants to work on our project, they may not know that. With only a single JS file, it’s easy enough to guess, but imagine if we had hundreds of files, which definitely can be the case in larger projects – how would you know where to start?</p>
<p>Of course, you might guess it’s <code>index.js</code>, since that is the default value that NPM will set for the <code>main</code> property in <code>package.json</code> when you execute <code>npm init</code> in a project, but a) there might not be an <code>index.js</code> file at all, and b) that may not be the right answer even if it <em class="italic">is</em> there, as the developer of the project may have made a different choice. We can tell the developer which file it is of course, but shouldn’t there be a better way to communicate that information without explicitly having to tell someone?</p>
<p>There is, and it comes about due to another available element in the <code>package.json</code> file – <code>scripts</code>. The <code>scripts</code> element gives us a way to, in a sense, create custom NPM commands. Anything that appears in that element can be run with the <code>npm run XXX</code> command, where <code>XXX</code> is a key in <code>scripts</code>. NPM, by default, gives us a <code>test</code> command, so you can run that with <code>npm </code><code>run tests</code>.</p>
<p>We can use this capability to provide a way to start the server:</p>
<pre class="source-code">
"dev": "node index.js"</pre> <p>This way, we can execute <code>npm run dev</code> to start the server, and the <code>scripts</code> entry knows which file to run, so the developer doesn’t need to. This is a common command to include, so many developers will know it automatically. But even if they don’t, they can simply look in <code>package.json</code> and see the available commands. It is, in a sense, a way to document the proper start up command for our project.</p>
<p>Now that we have Express added to our project, and a start-up script to run it with, let’s use it to write our server code.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Writing the server code</h2>
<p>We start by creating<a id="_idIndexMarker232"/> an <code>index.js</code> file in the project directory. This will again be the server code from the previous chapter.</p>
<p>Any time you add a package to a Node project, you’ll almost certainly need to import it into your code, and that is indeed the first thing we have in <code>index.js</code>:</p>
<pre class="source-code">
const express = require("express");</pre> <p>This gives us an object named <code>express</code>, from which we can use several properties and methods. However, the object itself is a function in this case – in other words, the <code>express</code> variable points to a function, so we can execute it as a function:</p>
<pre class="source-code">
const app = express();</pre> <p>The result of the <code>express()</code> function is that a server object is returned to us. Express handles all the setup and creation of that server. However, because the object is returned to us, Express gives us the ability to configure the server to meet our specific needs, and the first thing we need to do is tell it that we want to be able to handle forms being sent in:</p>
<pre class="source-code">
app.use(express.urlencoded());</pre> <p>The <code>app.use()</code> function allows us to configure Express <strong class="bold">middleware</strong>. That’s really just a fancy way of saying that we can tell Express to execute one or more functions for every request that comes in. This comes in handy for things such as logging the incoming request to make debugging easier, implementing some sort of security, or, in this case, telling it to handle form data.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Adding Express middleware</h2>
<p>When a form is sent<a id="_idIndexMarker233"/> to a server via <code>POST</code>, it gets encoded<a id="_idIndexMarker234"/> in a unique way in the body of the request, such as the following:</p>
<pre class="source-code">
title=Mr&amp;first_name=James&amp;last_name=Kirk&amp;age=54&amp;email=jame.t.kirk%40starfleet.com</pre> <p>For the server to be able to make sense of that, it must know how to parse it and what middleware function to use to do so. Express provides several prebuilt middleware functions, one of which is given to us if we call the <code>express.urlencoded()</code> function. It returns the function, which we then add to Express as middleware by passing it to the <code>app.use()</code> function. Without this, Express wouldn’t be able to handle the form data that our client code will send to it.</p>
<p>You can add zero, one, or more middleware functions via calls to <code>app.use()</code>. Each time you call it, you give it a reference to a function, whether it’s one you create yourself, one that Express supplies, or one from a third-party source, and it gets added to the chain of middleware<a id="_idIndexMarker235"/> functions that Express<a id="_idIndexMarker236"/> will execute for each request that comes into it.</p>
<h3>Creating Express routes with JS arrow functions</h3>
<p>Perhaps the<a id="_idIndexMarker237"/> key concept<a id="_idIndexMarker238"/> of Express is the idea of <strong class="bold">routes</strong>. Routes are really<a id="_idIndexMarker239"/> just URLs. Defining a route in Express means defining the function to execute for a given URL. For our little app, we need two routes, beginning with the default route:</p>
<pre class="source-code">
app.get("/", (inRequest, inResponse) =&gt; {
  inResponse.sendFile(`${__dirname}/index.html`);
});</pre> <p>This is the default route because it’s what will execute when the URL has nothing after the domain. In other words, if you access <a href="http://localhost">http://localhost</a> with the server running, this is the route that will be hit because there’s nothing after the domain, which is <code>localhost</code> in this case. The <code>"/"</code> argument equates to “nothing after the domain.”</p>
<p>Calling the <code>app.get()</code> function registers a route with Express that will be accessed using the HTTP <code>GET</code> method, which you’ll recall is what the browser uses by default, so that’s what we need here. The second argument passed<a id="_idIndexMarker240"/> to this function is what we call a <strong class="bold">handler function</strong>, which is just a plain old JS function to execute when a request comes in via this route.</p>
<p>However, here, I’m using a different form of functions available<a id="_idIndexMarker241"/> to us in JS that you haven’t seen before – <code>app.get()</code> call so that we can look at it in isolation, it would be just this snippet of  code:</p>
<pre class="source-code">
(inRequest, inResponse) =&gt; {
  inResponse.sendFile(`${__dirname}/index.html`);
}</pre> <p>That is equivalent to this code:</p>
<pre class="source-code">
function(inRequest, inResponse) {
  inResponse.sendFile(`${__dirname}/index.html`);
}</pre> <p>So, we could write that <code>app.get()</code> call like this instead:</p>
<pre class="source-code">
app.get("/", function(inRequest, inResponse) {
  inResponse.sendFile(`${__dirname}/index.html`);
});</pre> <p>With arrow <a id="_idIndexMarker242"/>functions, you’re essentially<a id="_idIndexMarker243"/> trading the <code>function</code> keyword for the <code>=&gt;</code> characters. In most cases, these two are absolutely equivalent, but there are some subtle differences that can become large in more advanced situations. I’m going to skip that for now because there are some other concepts you would need to be introduced to before you could understand the explanation. At this point, I’ll just say that, at the time of writing, developers tend to use arrow functions more because they are shorter (although only by a character or two) and more aesthetically pleasing. Your opinion may be different, but at the end of the day, you can generally just choose whichever you prefer (at least until you hit the situations where it matters what you choose, which I’ll touch on in later chapters). Arrow functions can be written in some other forms as well depending on developer needs, but I’ll explain those when we get to them in other code.</p>
<p>Arrow function syntax aside, the function performs a simple task – sending a file back to the browser. The file that is sent back is <code>index.html</code>, sent by calling the <code>sendFile()</code> method that the <code>inResponse</code> argument provides to us. <code>inRequest</code> and <code>inResponse</code> are objects that Express and Node create and pass to the function that we can use to construct a response. They provide many methods and properties to examine the incoming request, get data from it, and produce a response, <code>sendFile()</code> being one of them.</p>
<p>However, let’s talk about what is passed to <code>sendFile()</code> a bit. In JS, the backtick character (<code>`</code>) is used to define<a id="_idIndexMarker244"/> a special kind of string, called a <code>${}</code>, with something between the braces. And what is the something? Well, it can be any valid JS! What happens is that the JS engine, when it encounters such a template literal string, will replace each of those expressions, resulting in the JS executing within it.</p>
<p>Here, the JS to execute<a id="_idIndexMarker245"/> is actually just the name of a variable<a id="_idIndexMarker246"/> that Express provides – <code>__dirname</code>. When JS sees just a variable name like this, it simply inserts the current value of that variable into the string. The <code>__dirname</code> variable contains the full path of the directory that the <code>index.js</code> file is in at runtime. When we append <code>/index.html</code> to it – which is what happens when this template literal is interpreted by JS – we get a full path to that file, which just so happens is what <code>sendFile()</code> needs to return that file to the browser.</p>
<p>We have to add another route specifically for the style sheet file that is imported; otherwise, you’ll find that the styles don’t work because the file can’t be loaded:</p>
<pre class="source-code">
app.get("/styles.css", (inRequest, inResponse) =&gt; {
  inResponse.sendFile(`${__dirname}/styles.css`);
});</pre> <p>In this case, we’re serving a specific file using a specific URL, the one specified in the <code>&lt;link&gt;</code> tag in <code>index.html</code>. Remember that our server won’t do anything we don’t specifically program it to do, including responding to the browser’s request for that stylesheet file.</p>
<p>That route will allow us to see the registration page, but we also need a route for the form to be submitted to, so we’ll define that next:</p>
<pre class="source-code">
app.post("/register", (inRequest, inResponse) =&gt; {
  inResponse.send(`
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;User Registration - SUCCESS&lt;/title&gt;
      &lt;style&gt;
        th { background-color: #e0e0e0; }
        tr { border: 1px solid #a0a0a0; }
        td { border: 1px solid #a0a0a0; }
      &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h2&gt;Thank you for registering! Here is the information we got:&lt;/h2&gt;</pre> <p>This time, remember that we’re going to send the form to the server with the HTTP <code>POST</code> method, so we have to call <code>app.post()</code> this time. The URL will be <a href="http://localhost/register">http://localhost/register</a> this time, so the route is <code>/register</code> (again, relative to the base URL, which in this case is just the domain name).</p>
<p>The handler function we pass along this time returns content directly from this code, not from a separate file, and the <code>inResponse.send()</code> function allows us to do that. We pass it a string, and that string is returned to the browser. The string, in this case, is the actual HTML document to return, our registration acknowledgment page. And here, you can see why being able to spread a template literal string onto multiple lines is nice – imagine if all that HTML was put on a single, lengthy line, which is what we’d have to do with plain old strings.</p>
<p>I would think that, at this<a id="_idIndexMarker247"/> point, most of that HTML looks<a id="_idIndexMarker248"/> pretty self-explanatory to you, save for the style classes defined there. You will know, based on the selectors, that the classes must style some HTML elements called <code>th</code>, <code>tr</code>, and <code>td</code>, but at this point, you don’t know what they are. Let’s remedy that situation now by talking about a new HTML concept – tables.</p>
<h3>Introducing tables</h3>
<p>Tables in HTML are a lot like<a id="_idIndexMarker249"/> spreadsheets – they allow us to organize data in rows and columns. We begin a table with, unsurprisingly, a <code>&lt;</code><code>table&gt;</code> tag:</p>
<pre class="source-code">
&lt;table style="border:4px solid black;"&gt;</pre> <p>By default, a table won’t have<a id="_idIndexMarker250"/> a border, but I want it to in this case, so I’ve added an inline style for it. The <code>border</code> property is very much like the <code>outline</code> property you saw earlier. It’s another of those shorthand properties I previously explained, and in this case, it has the same values as <code>outline</code> – the width of the border in pixels, the style of it, and the color.</p>
<p>Once we have a table, we can begin filling it with rows of data. Each<a id="_idIndexMarker251"/> row is defined with a <code>&lt;tr&gt;</code> element (short for <strong class="bold">Table Row</strong>):</p>
<pre class="source-code">
&lt;tr&gt;
  &lt;th&gt;Title&lt;/th&gt;
  &lt;th&gt;First Name&lt;/th&gt;
  &lt;th&gt;Last Name&lt;/th&gt;
  &lt;th&gt;Age&lt;/th&gt;
  &lt;th&gt;Email Address&lt;/th&gt;
&lt;/tr&gt;</pre> <p>Inside of a row, we define one or more columns, and here we have a choice:</p>
<ul>
<li>We can use a <code>&lt;th&gt;</code> tag, which stands for <code>&lt;th&gt;</code>.</li>
<li>We could use<a id="_idIndexMarker253"/> a <code>&lt;td&gt;</code> tag, which stands for <code>&lt;td&gt;</code> (or, if you don’t want a header row at all, you can just start with <code>&lt;td&gt;</code> right away).</li>
</ul>
<p>Whether we use <code>&lt;th&gt;</code> or <code>&lt;td&gt;</code>, we generically call either one a <em class="italic">cell</em>.</p>
<p>Each <code>&lt;th&gt;</code> element defines a column, and since this is the header row, the values inside the <code>&lt;th&gt;</code> elements are the header text for each column. In this case, we’re only going to have a single row after the header row:</p>
<pre class="source-code">
&lt;tr&gt;
  &lt;td&gt;${inRequest.body.title}&lt;/td&gt;
  &lt;td&gt;${inRequest.body.first_name}&lt;/td&gt;
  &lt;td&gt;${inRequest.body.last_name}&lt;/td&gt;
  &lt;td&gt;${inRequest.body.age}&lt;/td&gt;
  &lt;td&gt;${inRequest.body.email}&lt;/td&gt;
&lt;/tr&gt;</pre> <p>Again, <code>&lt;tr&gt;</code> creates a row, and then for each<a id="_idIndexMarker254"/> column, we have a <code>&lt;td&gt;</code> element. Remember that this HTML is being built inside of a template literal string in JS code, so we can use those expressions I mentioned earlier. For each cell, a property in the <code>inRequest</code> object is used – <code>body</code>. This will hold the information sent to the server from the form, so we can then grab each piece of data using properties named after the form fields.</p>
<p>Then, we just have to close the table:</p>
<pre class="source-code">
&lt;/table&gt;</pre> <p>The result of this is shown in <em class="italic">Figure 3</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 3.4: The registration acknowledgment screen, using an HTML table" src="img/B18315_03_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: The registration acknowledgment screen, using an HTML table</p>
<p class="callout-heading">A warning about table usage</p>
<p class="callout">Tables are often used<a id="_idIndexMarker255"/> in HTML, and they are sometimes even abused because tables can be used to lay out your pages if you want. The content inside a <code>&lt;td&gt;</code> element can be anything, even more HTML, so it’s possible to build tables nested inside <code>&lt;td&gt;</code> elements with all sorts of complex HTML and use the table structure to define the structure of the page. However, this practice is frowned upon for several reasons, including performance, the complexity of the markup, and a more philosophical “it’s just not what tables are meant for” arguments. There are preferable ways to do layout in CSS, some of which wind up looking an awful lot like tables anyway but with more flexibility. I only mention this so that you’re aware – tables shouldn’t be thought of as being used for layout, even though they can be (and for many years before CSS evolved<a id="_idIndexMarker256"/> into what it is today, it was extremely common to do so).</p>
<p>Now, you have the context to understand<a id="_idIndexMarker257"/> the CSS classes applied to <code>tr</code>, <code>th</code>, and <code>td</code> that you saw earlier when the response to the <code>/register</code> route was generated – these elements are the <code>&lt;tr&gt;</code>, <code>&lt;td&gt;</code>, and <code>&lt;th&gt;</code> tags that the styles apply to! Simply put, they put a background color on the <code>&lt;th&gt;</code> elements in the header row so that they stand out from the data, and then a border is put around each <code>&lt;tr&gt;</code> and <code>&lt;td&gt;</code> element, really just for aesthetic reasons so that the data doesn’t all run together.</p>
<h3>Completing the response</h3>
<p>To wrap things up properly, we need<a id="_idIndexMarker258"/> to close the body and the HTML document that our response constructs, as well as close the <code>inResponse.send()</code> call and the <code>app.post()</code> function call. That’s done here:</p>
<pre class="source-code">
    &lt;/body&gt;
  &lt;/html&gt;
  `);
});</pre> <p>With that done, the only thing left to do is to start the server.</p>
<h3>Starting the server</h3>
<p>Starting the server<a id="_idIndexMarker259"/> means telling the object that Express gave back to us to start listening for requests:</p>
<pre class="source-code">
app.listen(80, () =&gt; {
  console.log("Server listening on port 80");
});</pre> <p>The aptly named <code>listen()</code> method of the <code>app</code> object is what allows us to do that. We pass to it what port to listen to and, optionally, a function to execute when it starts up. Since there are no arguments we need to pass to it, an empty set of parentheses is all we need (because it’s still a function we’re defining, after all), and then we again use arrow notation for the function.</p>
<p>Go ahead and run the server (<code>npm run dev</code>) and play with it a bit to see it in action, including the start up text being displayed, as you can see in <em class="italic">Figure 3</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 3.5: The output of console.log()" src="img/B18315_03_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: The output of console.log()</p>
<p class="callout-heading">Deprecation warnings</p>
<p class="callout">By the way, the warning you<a id="_idIndexMarker260"/> can see in the preceding screenshot can be ignored. It’s a deprecation warning, which means that there is some change in process in a package that the server code depends on. The authors of that package alert us to the fact that, eventually, we’ll need to change our code in some way; otherwise, it will break (the change, in this case, is that the call to <code>express.urlencoded()</code> earlier will eventually require an object to be passed with an extended attribute – you can add <code>{extended:false}</code> as an argument to that call to get rid of the message now if you’d like, but it isn’t yet necessary, which is the point of a deprecation warning).</p>
<p>Speaking of that start up text, inside of the function passed to <code>app.listen()</code> is a call to the <code>log()</code> method of an object named <code>console</code>. It’s easy enough to surmise that <code>console</code> is an object representing the command-line <a id="_idIndexMarker261"/>output, frequently called the <em class="italic">console</em>. And it’s easy to guess that <code>log()</code> is the method that allows us to write text to that console. But all that opens up a whole new world of knowledge that we’ll explore a little bit later<a id="_idIndexMarker262"/> in the <em class="italic">Loving your new best friend – </em><em class="italic">DevTools</em> section.</p>
<p>Well, that wasn’t so bad, was it? Writing servers is easy! However, so far, you’ve only written one <em class="italic">type</em> of server. Let’s now talk about another way we could write this server and registration page that is a little more modern.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Exploring a different approach – single-page apps</h1>
<p>When you click the button<a id="_idIndexMarker263"/> on our registration page, the form is sent to the server, which then produces a new HTML document. This document is sent back to the browser, which replaces the entire registration page with the results page. This is what is often referred to – at least by (relative!) old-timers<a id="_idIndexMarker264"/> like me – as the “classic” model of the web. In short, for every user action, the server is contacted, generating a new page to be displayed.</p>
<p>That’s an inefficient model, frankly. Imagine thousands of users all doing the same thing – the server must handle all those requests, and quickly, because users hate to wait! But even if it’s almost instantaneous, think about it from the user’s perspective – the screen is constantly being redrawn. It just doesn’t <em class="italic">look</em> great, or at least it doesn’t look like an app they run on their operating system. Imagine if your web browser had to completely redraw itself every time you, say, click a menu item on the toolbar. However, that doesn’t happen; the menu simply appears. So, why can’t a website work the same?</p>
<p>In fact, it can! An approach referred to as <em class="italic">SPAs</em> does it. <strong class="bold">SPA</strong> stands for <strong class="bold">Single Page App</strong>, and what it means is that the HTML document you initially load is never thrown away and replaced with another. Instead, what happens is that when a request goes to the server, the server responds with just data, not a full HTML document. We then use JS to take that data and do something with it. It might be as simple as showing it on the page, which we can do through DOM functions. Alternatively, maybe we use it to do some calculations and display the result of those on the screen, or maybe we use it to modify the page somehow. In all cases, the main point is that the single HTML document that was loaded at the start is still there.</p>
<p>This may sound a bit confusing right now, but I think once you see what we’re going to do to our little registration page, it’ll make a lot of sense. However, before we touch the code at all, I want to solve one minor problem and make life a little easier for us developers!</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>Improving developer productivity through automation</h2>
<p>You may not have noticed<a id="_idIndexMarker265"/> this, but if you were to make a change to the <code>index.js</code> file, such as changing the HTML it returns when the form is submitted, you would find that the change doesn’t take effect immediately. You have to stop and restart the server for the changes to “kick in,” so to speak. That’s quite inconvenient if you ask me! If you were making a lot of changes, that would get annoying fast. Fortunately, there’s an<a id="_idIndexMarker266"/> easy solution – <strong class="bold">nodemon</strong>!</p>
<p>First, since <code>nodemon</code>’s an NPM package, we need to add it to our project. To do so, execute this command:</p>
<pre class="source-code">
npm install –save-dev nodemon</pre> <p>Earlier, you saw how Express was added with the <code>–save</code> option, which added it to the dependencies element in <code>package.json</code>. The <code>–save-dev</code> option is similar but a little different. You see, there is also a <code>devDependencies</code> element that may be present in <code>package.json</code>. This works the same as the <code>dependencies</code> element, with one key difference – these are dependencies that we need during development but which our code itself does not depend on; <code>nodemon</code> is one such dependency. So, after executing that command, you’ll find a <code>devDependencies</code> element has been added, and <code>nodemon</code> has been added as a dependency in it (note this time that I did not specify an explicit version number, so NPM will install the latest version of <code>nodemon</code> – since our code doesn’t depend on it, this is safe and most likely desired, since having the latest version gives us any new features it may offer).</p>
<p>Now, what <code>nodemon</code> does<a id="_idIndexMarker267"/> is watch (or <em class="italic">monitors</em>, hence the name <code>nodemon</code>) our files for changes and, when they are detected, restart our application for us. However, to make that happen, we have to start the server using <code>nodemon</code>. The way we do this is to modify the <code>dev</code> script we added to <code>package.json</code> earlier. Now, it should be as follows:</p>
<pre class="source-code">
"dev": "npx nodemon"</pre> <p>The <code>npx</code> command is an alternate version of <code>npm</code> that basically says, “<em class="italic">Run a program that is supplied by a dependency in our project.</em>” In this case, that of course means <code>nodemon</code>. But note how you would still, as a developer, execute the same <code>npm run dev</code> command to start the server. That command is what will start <code>nodemon</code>, using <code>npx</code> as per the script. And, by default, <code>nodemon</code> will simply monitor all the <code>.js</code> files in the project directory, and since we just have one, that’s all we need (you can configure <code>nodemon</code> to only monitor specific files, subdirectories, or many other options, but the defaults work just fine for us here).</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Writing a new kind of client</h2>
<p>Now, what we’re going<a id="_idIndexMarker268"/> to do is modify our registration page to work<a id="_idIndexMarker269"/> as an SPA. Rather than listing out all the code, I’m just going to show the changes required, just to save a few trees! If I don’t mention a specific change, then you can assume the code is the same as the original version.</p>
<p>The first change is a simple one:</p>
<pre class="source-code">
&lt;form id="theForm"&gt;</pre> <p>The <code>action</code> and <code>method</code> attributes have been removed and an <code>id</code> attribute added. Removing <code>action</code> and <code>method</code> is a change I didn’t technically need to make, but it makes obvious the fact that the form won’t be submitted like before. Instead, the information from the form will be sent to the server in an entirely different way, which we’ll get to shortly. Adding the <code>id</code> attribute though is necessary, as you’ll see shortly.</p>
<p>The only other change is to the button:</p>
<pre class="source-code">
&lt;button type="button" onClick="registerNow();"&gt;Register Now&lt;/button&gt;</pre> <p>Now, the <code>type</code> attribute’s value is just <code>button</code> instead of <code>submit</code>. That’s because the <code>submit</code> type creates a special button that knows to submit the form to the server when clicked. But since we don’t want that to happen now, it’s changed to a plain button, which has no intrinsic action when clicked. To give it an action, we need to attach an event handler to it. The <code>onClick</code> handler is what executes when the user clicks the button of course, and in that case, we need it to execute some JS, the <code>registerNow()</code> function specifically, which we’ll look at very soon.</p>
<p>But first, there is a new bit of markup that needs to be added.</p>
<h3>Embedding the response page</h3>
<p>Remember, the whole point<a id="_idIndexMarker270"/> of what we’re trying<a id="_idIndexMarker271"/> to accomplish here is to submit the form data to the server, get some data back, and display it on the screen, <em class="italic">without</em> overwriting what’s there already. So, we’re going to need a place to show that data, and that’s what we’ll discover next:</p>
<pre class="source-code">
&lt;div id="theResults" style="display:none;"&gt;
  &lt;h2&gt;Thank you for registering! Here is the information we got:&lt;/h2&gt;
  &lt;table style="border:4px solid black;"&gt;
    &lt;tr&gt;
      &lt;th&gt;Title&lt;/th&gt;
      &lt;th&gt;First Name&lt;/th&gt;
      &lt;th&gt;Last Name&lt;/th&gt;
      &lt;th&gt;Age&lt;/th&gt;
      &lt;th&gt;Email Address&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td id="results_title"&gt;&lt;/td&gt;
      &lt;td id="results_first_name"&gt;&lt;/td&gt;
      &lt;td id="results_last_name"&gt;&lt;/td&gt;
      &lt;td id="results_age"&gt;&lt;/td&gt;
      &lt;td id="results_email"&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;</pre> <p>This code should <a id="_idIndexMarker272"/>look rather familiar<a id="_idIndexMarker273"/> to you – it’s almost exactly identical to the markup that the server generates in the original version. The key differences are first that everything is wrapped up in a <code>&lt;div&gt;</code> now, the one with the <code>theResults</code> ID. In addition, an inline style is used here. The <code>display</code> property in CSS tells the browser whether the content inside this element should be visible or not. Setting it to <code>none</code>, as is done here, means that this entire <code>&lt;div&gt;</code> will not be seen, at least not at first. And, indeed, if you run this code now, you’ll find that it looks exactly like the original version, but none of the content inside <code>&lt;div&gt;</code> is shown.</p>
<p>Secondly, the content in the row where the data is displayed is different. No longer do we have expressions like in the original version because, remember, this isn’t a template literal string like it is there; this is just plain old HTML. Instead, each of the <code>&lt;td&gt;</code> elements is now given an <code>id</code>, which will allow us to reference them in code later. And I prefixed the <code>id</code> values with <code>results_</code> so they can be differentiated<a id="_idIndexMarker274"/> from the fields<a id="_idIndexMarker275"/> in the form at a glance.</p>
<p>And, speaking of the code, that’s exactly where we’re headed next!</p>
<h3>Executing the new JS code</h3>
<p>Coming back to<a id="_idIndexMarker276"/> that <code>registerNow()</code> function I mentioned<a id="_idIndexMarker277"/> earlier, you’ll find that it is contained within a <code>&lt;script&gt;</code> block that comes right before the closing <code>&lt;/html&gt;</code> tag. That’s something you haven’t seen before – you’ve only ever seen a <code>&lt;script&gt;</code> tag inside <code>&lt;head&gt;</code> before now.</p>
<p>As you can guess, you can put <code>&lt;script&gt;</code> tags anywhere because, remember, they aren’t content that is shown to the user, so they have no impact on your markup no matter where you put them. I put a <code>&lt;script&gt;</code> tag at the end for just one reason – so that I could discuss the markup changes first and not have to pull a “we’ll come back to this later” with the JS code, which is what I would have had to do if it was in <code>&lt;head&gt;</code>!</p>
<p>But now, we’re ready to look at it, and I’m going to break it up into pieces to make it easier to digest, starting with this:</p>
<pre class="source-code">
&lt;script&gt;
  async function registerNow() {</pre> <p>You’ve seen a function defined before, but that <code>async</code> thing is new. Normally, when a function executes, it completes from start to finish in one go. However, there are some cases where we might need to do something in a function that can take a while. A good example – the one in play here – is calling the server. We need a way to, in effect, make our function “pause” until the server responds, which it normally would not do. The <code>async</code> keyword tells JS that we’re doing something like that here. On its own, it’s only part of the equation, and you’ll see the other part soon.</p>
<p>But first, let’s return to the function’s code:</p>
<pre class="source-code">
const theForm = document.getElementById("theForm");</pre> <p>The <code>getElementById()</code> method of the <code>document</code> object, which is an object the browser always provides to us, allows us to get a reference to a DOM node based on its ID. In this case, the form has an <code>id</code> of <code>theForm</code>, so the <code>theForm</code> variable now references the form.</p>
<p>From there, we can pull out the data from the form:</p>
<pre class="source-code">
const userInfo = {
  title: theForm.elements["title"].value,
  first_name: theForm.elements["first_name"].value,
  last_name: theForm.elements["last_name"].value,
  age: theForm.elements["age"].value,
  email: theForm.elements["email"].value
};
console.log("userInfo to be sent to server", userInfo);</pre> <p>Every entry field in the form is an element in an object named <code>elements</code>, which is a property of the form object referenced by the <code>theForm</code> variable. So, we can access each of them using bracket notation, as you can any property of an object.</p>
<p>What we’re doing here is building an object with keys for each of the form fields. We define an object with an opening and closing brace and then list the properties we want in it, in a key-value pair form. Then, just to prove that worked, the object is displayed in the console using <code>console.log()</code>, as you saw on the server side. However, here, you see another capability of that method – the ability to pass multiple arguments. Each argument will be displayed separated by some space. And if we pass an object as an argument, as is the case for the second argument here, <code>console.log()</code> will display the contents of that object for us. Immensely helpful, isn’t it?</p>
<p>I’m going to talk more<a id="_idIndexMarker278"/> about <code>console</code> and the wider<a id="_idIndexMarker279"/> world it hints at near the end of this chapter, so just keep it in the back of your mind for now.</p>
<p>Once we have that object, we can then call on the server using JS:</p>
<pre class="source-code">
const response = await fetch("/register", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(userInfo)
});</pre> <p>This is where the second part of the <code>async</code> puzzle comes into play – the <code>await</code> keyword. This tells JS that whatever function or code follows may take some time to execute, and we <em class="italic">do not</em> want the rest of the function to execute until it does, as it normally would. We want to <em class="italic">await</em> the outcome of that call, in other words.</p>
<p>In this case, what we’re awaiting is the result of a call to the <code>fetch()</code> function. This is a function the browser provides that allows us to make an HTTP request to a remote system – in this case, our server. The <code>fetch()</code> function can take in a lot of information to do its job, but in its simplest form, it requires two arguments – the URL to send the request to (<code>/register</code> in this case, just like the original version of this page) and an object with several properties that provides the data needed to make the call. Here, we first specify the HTTP <code>method</code> to use as <code>POST</code> again, as with the original form. Then, we need to provide some <code>headers</code>. Recall from earlier that headers are metadata that can be sent on a request to tell the server something about that request. In this case, we’re telling it that we’re sending something called JSON. The <code>Content-Type</code> header is the key in a key-value pair that allows us to express that, and the value is <code>application/json</code>.</p>
<p>You’ll see strings like this frequently in headers, and when<a id="_idIndexMarker280"/> you do, this is something called a MIME type, where <code>application/json</code> value specifically<a id="_idIndexMarker281"/> is a common one these days, where <code>userInfo</code> object before, that was JSON! The server needs to know that the client is sending JSON, so this header and that specific MIME type do that.</p>
<p>After that, we of course<a id="_idIndexMarker282"/> have to include<a id="_idIndexMarker283"/> the <code>userInfo</code> object, and this becomes the <code>body</code> of the request. However, when you make an HTTP request, the body is always a string. At this point though, we only have <code>userInfo</code> as a JS object, not a string. Fortunately, the JS engine provides an object called <code>JSON</code>, which gives us access to several useful methods, <code>stringify()</code> being one of them. You simply pass this function to a JS object, and it will return a string version of it, which we can then make the body of the request.</p>
<p>Once the response comes<a id="_idIndexMarker284"/> back, it will be put<a id="_idIndexMarker285"/> into the <code>response</code> variable. However, it will be a string at this point, and we want a JS object so that we can get the values from it. To do that, we can call the <code>json()</code> method of the <code>response</code> object. This is another asynchronous call though, so we have to use <code>await</code> again, after which we can display the resultant object:</p>
<pre class="source-code">
const results = await response.json();
console.log("results from server", results);</pre> <p>Finally, now that we have an object with the data returned by the server, the last step is to show it on the screen (well, the last step after displaying it in the console, which is something you can do in a browser, just like in the server-side code):</p>
<pre class="source-code">
    document.getElementById("results_title").innerHTML =
      results.title;
    document.getElementById("results_first_name").innerHTML =
      results.first_name;
    document.getElementById("results_last_name").innerHTML =
      results.last_name;
    document.getElementById("results_age").innerHTML =
      results.age;
    document.getElementById("results_email").innerHTML =
      results.email;
    document.getElementById("theResults").style.display = "";
  }
&lt;/script&gt;</pre> <p>Here, the five data values are inserted into the page. Again, the <code>document.getElementById()</code> function is used, referencing the IDs assigned to the <code>&lt;td&gt;</code> elements from earlier. That gives us a DOM node object back, and many DOM node objects have an <code>innerHTML</code> property. This allows us to insert content between two tags – in this case, between the <code>&lt;td&gt;</code> and <code>&lt;/td&gt;</code> tags corresponding to a given <code>id</code> value. The text to insert is simply the value of the various properties of the <code>results</code> object that <code>response.json()</code> gave to us.</p>
<p>Now, it’s great<a id="_idIndexMarker286"/> that all the data<a id="_idIndexMarker287"/> is inserted at this point, but it’s still not visible. To make it visible, we have to change the display CSS property of the <code>&lt;div&gt;</code> tag that contains the table. DOM nodes almost always have a <code>style</code> property, which allows us to alter any CSS properties on that node that we want to, so we can set the <code>display</code> property to an empty string. This may seem weird, but by default, the <code>display</code> property has no value, which tells the browser that it <em class="italic">should</em> be displayed, so that’s what we do here.</p>
<p>As a result, you can now see the data that the server sent back, as shown in <em class="italic">Figure 3</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 3.6: The result of calling the server" src="img/B18315_03_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: The result of calling the server</p>
<p>Now that we’ve reworked<a id="_idIndexMarker288"/> the client-side code<a id="_idIndexMarker289"/> for this new SPA approach, let’s look at what changes are required on the server side to ensure that the client and the server can talk to each other properly in the new way.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Writing a new kind of server</h2>
<p>Okay, great, we’ve modified<a id="_idIndexMarker290"/> our frontend code to prepare for this great new SPA version; now, we need to make some changes on the server. Once again, I’ll just show the changes; however, in this case, I’d definitely suggest looking at the complete code from GitHub because the one thing you’ll find is that it’s shorter. And that makes sense if you think about it – the styles and HTML that the server returns in the original version are now effectively part of the <code>index.html</code> source.</p>
<p>First up, we must tell Express that it needs to be able to work with JSON:</p>
<pre class="source-code">
app.use(express.json());</pre> <p>The <code>express.json()</code> method returns a function – a bit of Express middleware again – that knows how to work with JSON. Cool, that was easy!</p>
<p>The next change comes in the handler function for a POST to the <code>/</code><code>register</code> route:</p>
<pre class="source-code">
app.post("/register", (inRequest, inResponse) =&gt; {
  console.log("Data sent from client", inRequest.body);
  const responseObj = {
    title: inRequest.body.title,
    first_name: inRequest.body.first_name,
    last_name: inRequest.body.last_name,
    age: inRequest.body.age,
    email: inRequest.body.email
  };
  inResponse.send(responseObj);
});</pre> <p>Like I said, it’s shorter! The only real purpose of the server in this app is to echo back to the client the information received. Normally, you’d probably validate this data somehow, store it in a database, and so on. But remember, I’m just trying to demonstrate a client-server interaction here, which is the whole point of the chapter, so none of that needs to come into play.</p>
<p>However, we will display the data that was received via the call to <code>console.log()</code> first, just so we have it ready if we need to debug. After that, an object is created, referenced by the <code>responseObj</code> variable, just like you saw earlier on the client side. This object is then passed to <code>inResponse.send()</code>, which results in a call to <code>JSON.stringify()</code>, as you saw earlier, being made automatically for us, since Express is aware that we want JSON – in the form of a string – returned.</p>
<p>Let’s walk through this whole flow from client to server, detailing the steps involved:</p>
<ul>
<li>The JS in <code>index.html</code> sent an object in the form of a JSON string to the server.</li>
<li>Express took that string and turned it into a JS object.</li>
<li>Our server-side code then used the properties of that JS object to construct another object, with the data that was sent copied into it.</li>
<li>That object was then returned to the JS running in the browser as a string of JSON.</li>
<li>The code in the browser converted the string back into an object.</li>
<li>We then used the data from that object to populate the hidden table cells on the screen.</li>
<li>We then showed the table by updating the style of the <code>&lt;div&gt;</code> containing <code>&lt;table&gt;</code>.</li>
</ul>
<p>Critically, note that the original registration<a id="_idIndexMarker291"/> form is still there, untouched by the response from the server. That, in a nutshell, is the entire point of this new SPA version of this small and simple app. If you imagine this on a much larger and grander scale, such as Google’s Gmail or Microsoft’s Office Online, then hopefully you can quickly start to see the benefits. There’s more code involved of course, but you get better performance (usually), less server load (usually), and less network traffic (usually) with this SPA approach rather than the “classic” web approach, and that’s why the former is actually the more common approach to web development today overall. There definitely is still a place for the classic web approach, but that place<a id="_idIndexMarker292"/> is shrinking as time goes on.</p>
<p>Now that you’ve seen these two approaches – the “classic” web model and the SPA model – let’s discuss the topic I hinted at when I mentioned the <code>console.log()</code> function – developer DevTools.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Loving your new best friend – DevTools</h1>
<p>While <code>console.log()</code> is available in Node code<a id="_idIndexMarker293"/> on the server side, it’s an exceedingly small part of a much larger palette of tools that are available on the client side in the browser. To begin exploring that palette, go to a random website of your choosing, maybe www.microsoft.com or some other well-known site, and press <em class="italic">F12</em> once the page loads. You should find a new area in your browser opens up that looks something like <em class="italic">Figure 3</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 3.7: Browser DevTools in “action”" src="img/B18315_03_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Browser DevTools in “action”</p>
<p>These are the browser DevTools, and they are available<a id="_idIndexMarker294"/> in some form in all modern web browsers. Here, you can dig into the guts of the site you’re viewing. As you can see, there are many different tabs, each containing a wealth of data:</p>
<ul>
<li>The <code>console.log()</code> statements. You can also see JS errors here, as well as network requests. In fact, now would be a good time to open DevTools while viewing our little user registration app and see what is output to the <code>console.log()</code> messages there, although remember that you’ll only see those for the code running in the browser, not those in the server-side code running in Node (those are output to the console).</li>
<li>The other tab that you’ll probably use most often is the <strong class="bold">Network</strong> tab. Here, you can also see network requests, but you’ll see a lot more of them than in the <strong class="bold">Console</strong> tab and a lot more details about them. In fact, assuming you’re looking at that tab now on some site, go ahead and click on a request and examine some of the details. You can see things such as the headers sent on the request and the body content, if there are any.</li>
<li>The <strong class="bold">Elements</strong> tab is another area of immense importance because it’s here that you can examine the DOM, examine individual nodes, and even alter their styles directly. Yes, you can actually change things about someone else’s web page! Not permanently of course, only in your own browser. But it’s a fantastic way to see how other developers have done things and how you can modify their work in numerous ways.</li>
<li>The <strong class="bold">Sources</strong> tab is where you can see all the various JS files, CSS files, and other resources that make up the website. And again, here you can actually edit that code, temporarily.</li>
<li>The other tab I’d say is most important is the <strong class="bold">Application</strong> tab. Here is where you can find things such as cookies (small bits of information stored on your computer by websites) and other data that some sites store on your machine to do their work.</li>
</ul>
<p>There are many other tabs, some<a id="_idIndexMarker295"/> of which are hidden by default unless and until you decide you need them, but I’d say those four are probably the ones you’ll find yourself using most commonly.</p>
<p>But let’s go back to that console object for a moment because <code>log()</code> isn’t the only method it offers. While not an exhaustive list, here are a few I think you’ll find most interesting:</p>
<ul>
<li><code>clear()</code>: Well, it’s no surprise but this clears the console! This comes in handy in sections of your code where you want to focus on some messages and get rid of older ones.</li>
<li><code>debug()</code>/<code>error(</code>)/<code>info()</code>/<code>warn()</code>: These are similar to <code>log()</code> except that they output messages that are usually colored or highlighted in some way, depending on the severity of the message. For example, you can call <code>console.error()</code> to display a message in bold red text so that an error stands out against messages that are just information that you might output with <code>console.info()</code> or <code>console.log()</code>.</li>
<li><code>time()</code>/<code>timeEnd(</code>)/<code>timeLog()</code>: Calling <code>console.time()</code> acts like you pressing the start button on a stopwatch, and then <code>console.timeEnd()</code> acts like you clicking it again, at which point you can call <code>console.timeLog()</code> to display the elapsed time between the (virtual) clicks. This is handy when you want to figure out how long some code takes to execute, usually to aid in performance tuning.</li>
<li><code>dir()</code>: This may not have the best name, but it’s very handy. It displays an interactive listing of the properties of a specified JS object. You can expand and collapse sections of it, making it much easier to navigate larger objects.</li>
</ul>
<p>As with the tabs in DevTools, there are several more methods, but these are probably the most common. Note that the <code>console</code> object available in your Node code has most of these same methods, although the logging functions may not output messages with the same styling as in the browser.</p>
<p>As a web developer, you’ll find yourself using browser DevTools <em class="italic">a lot</em>, so I would very much encourage you to explore some random sites with them and see what you can do with them. There is an awful lot of power there – you could write a whole book on browser DevTools alone if you wanted to – and the best way to learn what they’re capable of is to simply jump in and experiment.</p>
<p>To help you along though – and assuming you’re using a Chromium-based browser such as Chrome, Edge Opera, Vivaldi, or Brave – going right to the source is probably best, and that means the Google<a id="_idIndexMarker296"/> DevTools team’s website: <a href="https://developer.chrome.com/docs/devtools">https://developer.chrome.com/docs/devtools</a>. Note that non-Chromium browsers such as Firefox and Safari also have DevTools, and they’ll be substantially the same, although certainly with differences and perhaps their own capabilities.</p>
<p>Remember that you can’t do any harm<a id="_idIndexMarker297"/> playing around with DevTools because you’re not modifying the code of a website for anyone but yourself on your own machine, so there’s no reason not to mess around! If you get yourself into a pickle, you have only to reload the page, and everything will return to normal.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Reviewing the roadmap</h1>
<p>With this chapter <a id="_idIndexMarker298"/>concluded, we can now fill in a few more boxes in our web developer roadmap:</p>
<div><div><img alt="Figure 3.8: The roadmap, with a few more boxes filled in" src="img/B18315_03_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: The roadmap, with a few more boxes filled in</p>
<p>With this chapter, you opened up the <strong class="bold">Networking</strong> and <strong class="bold">Developer Tooling</strong> boxes on the roadmap. Of course, you also built up some knowledge about the boxes that were opened in the previous chapter too. Hopefully, the big picture is starting to form in your mind now, at least a little bit. The upcoming chapters will expand that picture of course – some a little, some a lot, but always expanding!</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Summary</h1>
<p>In this chapter, you built a simple user registration page and a server to work with it, using the “classic web” approach. You first built the frontend using some new concepts, including basic HTML forms to demonstrate submitting data to the server that way, and some new CSS properties, including shorthand properties. Then, you saw how to build a server that accepts that data and generates a response for the client that is then displayed in the browser using another new concept, HTML tables, to display tabular data.</p>
<p>Then, you saw an entirely different approach to transmitting data to a server and receiving a response, an approach that leads to the more modern SPA paradigm. This included building the frontend code that introduced some new JS concepts, including <code>async</code>/<code>await</code>, and <code>fetch()</code>. You saw how the server can handle a new kind of request from a client and generate a new kind of response using JSON, allowing the browser to display the results without overwriting the entire page. Finally, you saw how your web browser provides tools specifically for developers to examine pages, explore JS and CSS, and work with any website out there at the level of the code behind it.</p>
<p>In the next chapter, we’ll step back from code a little bit (not completely though!) and look at some other topics that a web developer should be familiar with, including source control, Linux, security, integrated development environments, and Python.</p>
</div>


<div><h1 id="_idParaDest-104" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor104"/>Part 2: Expanding Your  Knowledge Base</h1>
</div>
<div><p>In this part, you’ll continue to gain technical knowledge about web development, including things such as developer tooling, security concerns, cloud infrastructure, virtual machines and containers, and DevOps.</p>
<p>We’ll also talk about modern frontend frameworks such as React, Angular, and Vue, and see how they can be used to accelerate development, as well as talk about responsive design on the frontend.</p>
<p>We’ll then flip over to look at some backend concerns and technologies, including how to build servers with Node.js and Express, Java and Spring Boot, and PHP and Python.</p>
<p>Finally, we’ll begin to talk about some technologies that have the goal of allowing you to be a web developer while doing less coding. These include things such as content management systems (like WordPress and Drupal) and so-called “no-code” solutions such as GoDaddy’s Website Builder.</p>
<p>This part includes the following chapters:</p>
<ul>
<li><a href="B18315_04.xhtml#_idTextAnchor105"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing, Securing, and Working with Code</em></li>
<li><a href="B18315_05.xhtml#_idTextAnchor129"><em class="italic">Chapter 5</em></a>, <em class="italic">Understanding the User Experience, Deployment Options, and DevOps</em></li>
<li><a href="B18315_06.xhtml#_idTextAnchor159"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Modern Frontend Development</em></li>
<li><a href="B18315_07.xhtml#_idTextAnchor176"><em class="italic">Chapter 7</em></a>, <em class="italic">From Front to Back – More on Backend Tools and Technologies</em></li>
<li><a href="B18315_08.xhtml#_idTextAnchor203"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Less Code – CMSs, No-Code Solutions, and Generative AI</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>