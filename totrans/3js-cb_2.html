<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Geometries and Meshes</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rotating an object around its own axis</li><li class="listitem" style="list-style-type: disc">Rotating an object around a point in space</li><li class="listitem" style="list-style-type: disc">Informing Three.js about updates</li><li class="listitem" style="list-style-type: disc">Working with a large number of objects</li><li class="listitem" style="list-style-type: disc">Creating geometries from height maps</li><li class="listitem" style="list-style-type: disc">Pointing an object to another object</li><li class="listitem" style="list-style-type: disc">Writing text in 3D</li><li class="listitem" style="list-style-type: disc">Rendering 3D formulas as 3D geometries</li><li class="listitem" style="list-style-type: disc">Extending Three.js with a custom geometry object</li><li class="listitem" style="list-style-type: disc">Creating a spline curve between two points</li><li class="listitem" style="list-style-type: disc">Creating and exporting a model from Blender</li><li class="listitem" style="list-style-type: disc">Using OBJMTLLoader with multiple materials</li><li class="listitem" style="list-style-type: disc">Applying matrix transformations</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Introduction</h1></div></div></div><p>Three.js comes with a large number of geometries that you can use out of the box. In this chapter, we'll show you some recipes that explain how you can transform these standard geometries. Besides that, we'll also show you how to create your own custom geometries and load geometries from external sources.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>You can access all of the example code within all recipes in this cookbook from the GitHub repository created at <a class="ulink" href="https://github.com/josdirksen/threejs-cookbook">https://github.com/josdirksen/threejs-cookbook</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Rotating an object around its own axis</h1></div></div></div><p>There <a id="id102" class="indexterm"/>are many ways in which you can change the appearance of a mesh. For example, you can change its position, scale, or material. Often, you'll also need to change the rotation of <code class="literal">THREE.Mesh</code>. In this first recipe on rotation, we'll show you the simplest way to rotate an arbitrary mesh.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec70"/>Getting ready</h2></div></div></div><p>To rotate a mesh, we first need to create a scene that contains an object you can rotate. For this recipe, we provide an example, <code class="literal">02.01-rotate-around-axis.html</code>, that you can open in your browser. When you open this recipe, you'll see something similar to the following screenshot in your browser:</p><div><img src="img/1182OS_02_01.jpg" alt="Getting ready"/></div><p>In this demo, you can see a 3D cube slowly rotating around its axis. Using the control GUI in the upper-right corner, you can change the speed at which the object rotates.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec71"/>How to do it...</h2></div></div></div><p>To rotate the cube from this example around its axis like we showed you in the previous screenshot, you have to take a couple of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">For the first step in this recipe, we'll set up the control GUI, as we've shown in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>, in the <em>Controlling the variables used in the scene</em> recipe, which you can see in the top-right corner. This time, we'll use the following <a id="id103" class="indexterm"/>as the control object:<div><pre class="programlisting">  control = new function() {
    this.rotationSpeedX = 0.001;
    this.rotationSpeedY = 0.001;
    this.rotationSpeedZ = 0.001;
  };</pre></div><p>With this <code class="literal">control</code> object, we'll control the rotation around any of the three axes. We pass this control object to the <code class="literal">addControls</code> function:</p><div><pre class="programlisting">  function addControls(controlObject) {
    var gui = new dat.GUI();
    gui.add(controlObject, 'rotationSpeedX', -0.2, 0.2);
    gui.add(controlObject, 'rotationSpeedY', -0.2, 0.2);
    gui.add(controlObject, 'rotationSpeedZ', -0.2, 0.2);
  }</pre></div><p>Now when we call the <code class="literal">addControls</code> function, we'll get the nice GUI that you saw in the screenshot at the beginning of this recipe.</p></li><li class="listitem">Now that we can control the rotation through the GUI, we can use these values to directly set the rotation of our object. In this example, we continuously update the <code class="literal">rotation</code> property of the mesh, so you get the nice animation you can see in the example. For this, we define the <code class="literal">render</code> function like this:<div><pre class="programlisting">  function render() {
    var cube = scene.getObjectByName('cube');
    cube.rotation.x += control.rotationSpeedX;
    cube.rotation.y += control.rotationSpeedY;
    cube.rotation.z += control.rotationSpeedZ;
    renderer.render(scene, camera);
    requestAnimationFrame(render); 
  }</pre></div><p>In this function, you can see that we increase the <code class="literal">rotation</code> property of the <code class="literal">THREE.Mesh</code> object with the value set in the control GUI. This results in the animation you can see in the screenshot in the <em>Getting ready</em> section. Note that the rotation property is of the <code class="literal">THREE.Vector3</code> type. This means that you can also set the property in one statement using <code class="literal">cube.rotation.set(x, y, z)</code>.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec72"/>How it works...</h2></div></div></div><p>When you set the rotation property on <code class="literal">THREE.Mesh</code>, as we do in this example, Three.js doesn't directly calculate the new positions of the vertices of the geometry. If you print out these vertices to the console, you'll see that regardless of the <code class="literal">rotation</code> property, they will stay exactly the same. What happens is that when Three.js actually renders <code class="literal">THREE.Mesh</code> in the <code class="literal">renderer.render</code> function, it is at that exact point that its exact position and rotation is calculated. So when you translate, rotate, or scale <code class="literal">THREE.Mesh</code>, the <a id="id104" class="indexterm"/>underlying <code class="literal">THREE.Geometry</code> object stays the same.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec73"/>See also</h2></div></div></div><p>There are different ways to rotate an object besides the one we showed here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the upcoming <em>Rotating an object around a point in space</em> recipe, we'll show you how you can rotate an object around an arbitrary point in space instead of its own axis, as we showed in this recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Rotating an object around a point in space</h1></div></div></div><p>When <a id="id105" class="indexterm"/>you rotate an object using its rotate property, the object is rotated around its own center. In some scenarios, though, you might want to rotate an object around a different object. For instance, when modeling the solar system, you want to rotate the moon around the earth. In this recipe, we'll explain how you can set up Three.js objects in such a way that you can rotate them around one another or any point in space.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec74"/>Getting ready</h2></div></div></div><p>For this recipe, we've also provided an example you can experiment with. To load this example, just open <code class="literal">02.02-rotate-around-point-in-space.html</code> in a browser. When you open this file, you'll see something similar to the following screenshot:</p><div><img src="img/1182OS_02_02.jpg" alt="Getting ready"/></div><p>With<a id="id106" class="indexterm"/> the controls on the right-hand side, you can rotate various objects around. By changing the <strong>rotationSpeedX</strong>, <strong>rotationSpeedY</strong>, and <strong>rotationSpeedZ</strong> properties, you can rotate the red box around the center of the sphere.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>To best demonstrate the rotation of an object around another one, you should rotate around that object's <em>y</em> axis. To do this, change the <strong>rotationSpeedY</strong> property.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec75"/>How to do it...</h2></div></div></div><p>Rotating an object around another object takes a couple of additional steps compared to the rotation we showed in the previous recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's first create the central blue sphere you can see in the screenshot. This is the object that we'll rotate the little red box around:<div><pre class="programlisting">  // create a simple sphere
  var sphere = new THREE.SphereGeometry(6.5, 20, 20);
  var sphereMaterial = new THREE.MeshLambertMaterial({
    color: 0x5555ff
  });
  var sphereMesh = new THREE.Mesh(sphere, spherMaterial);
  sphereMesh.receiveShadow = true;
  sphereMesh.position.set(0, 1, 0);
  scene.add(sphereMesh);</pre></div><p>So far, there's nothing special in this code snippet. You can see a standard <code class="literal">THREE.Sphere</code> object from which we create <code class="literal">THREE.Mesh</code> and add it to the scene.</p></li><li class="listitem">The next step is to define a separate object, which we'll use as the pivot point for our box:<div><pre class="programlisting">  // add an object as pivot point to the sphere
  pivotPoint = new THREE.Object3D();
  sphereMesh.add(pivotPoint);</pre></div><p>The <code class="literal">pivotPoint</code> object is a <code class="literal">THREE.Object3D</code> object. This is the parent object of <code class="literal">THREE.Mesh</code> and can be added to a scene without a geometry or a material. In this recipe, however, we don't add it to the scene but add it to the sphere we created in step 1. So, if the sphere rotates or changes position, this <code class="literal">pivotPoint</code> object will also change its position and rotation since we added it as a child to the sphere.</p></li><li class="listitem">Now <a id="id107" class="indexterm"/>we can create the red box, and instead of adding it to the scene, we add it to the <code class="literal">pivotPoint</code> object we just created:<div><pre class="programlisting">  // create a box and add to scene
  var cubeGeometry = new THREE.BoxGeometry(2, 4, 2);
  var cubeMaterial = new THREE.MeshLambertMaterial();
  cubeMaterial.color = new THREE.Color('red');
  cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  // position is relative to it's parent
  cube.position.set(14, 4, 6);
  cube.name = 'cube';
  cube.castShadow = true;
  // make the pivotpoint the cube's parent.
  pivotPoint.add(cube);</pre></div><p>Now we can rotate <code class="literal">pivotPoint</code> and the cube will follow the rotation of <code class="literal">pivotPoint</code>. For this recipe, we do this by updating the <code class="literal">rotation</code> property of <code class="literal">pivotPoint</code> in the <code class="literal">render</code> function:</p><div><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    pivotPoint.rotation.x += control.rotationSpeedX;
    pivotPoint.rotation.y += control.rotationSpeedY;
    pivotPoint.rotation.z += control.rotationSpeedZ;
    requestAnimationFrame(render);
  }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec76"/>How it works...</h2></div></div></div><p>When<a id="id108" class="indexterm"/> you create <code class="literal">THREE.Mesh</code> in Three.js, you normally just add it to <code class="literal">THREE.Scene</code> and position it individually. In this recipe, however, we've made use of the <code class="literal">THREE.Mesh</code> feature, which extends from <code class="literal">THREE.Object3D</code> itself and can also contain children. So when the parent object is rotated, this will also affect the children.</p><p>A really interesting aspect of using the approach explained in this recipe is that we can now do a couple of interesting things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can rotate the box itself by updating the <code class="literal">cube.rotation</code> property like we did in the <em>Rotating an object around its own axis</em> recipe</li><li class="listitem" style="list-style-type: disc">We can also rotate the box around the sphere by changing the rotation property of the sphere, as we added <code class="literal">pivotPoint</code> as a child of the sphere mesh</li><li class="listitem" style="list-style-type: disc">We can even combine everything, we can rotate <code class="literal">pivotPoint</code>, <code class="literal">sphereMesh</code>, and <code class="literal">cube</code>—all separately—and create very interesting effects</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec77"/>See also</h2></div></div></div><p>In this recipe, we've used the fact that we can add children to meshes as a way to rotate an object around another object. However, after reading the following recipes, you will learn more about this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <em>Rotating an object around its own axis</em> recipe, we showed you how you can rotate an object around its own axis</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Informing Three.js about updates</h1></div></div></div><p>If you've<a id="id109" class="indexterm"/> worked a bit longer with Three.js, you'll probably have noticed that sometimes, it seems that changes you make to a certain geometry doesn't always result in a change onscreen. This is because for performance reasons, Three.js caches some objects (such as the vertices and faces of a geometry) and doesn't automatically detect updates. For these kinds of changes, you'll have to explicitly inform Three.js that something has changed. In this recipe, we'll show you what properties of a geometry are cached and require explicit notification to Three.js to be updated. These properties are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.vertices</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.faces</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.morphTargets</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.faceVertexUvs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.faces[i].normal</code> and <code class="literal">geometry.vertices[i].normal</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.faces[i].color</code> and <code class="literal">geometry.vertices[i].color</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.vertices[i].tangent</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">geometry.lineDistances</code></li></ul></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec78"/>Getting ready</h2></div></div></div><p>An example is available that allows you to change two properties that require an explicit update: face colors and vertex positions. If you open up the <code class="literal">02.04-update-stuff.html</code> example in your browser, you'll see something similar to the following screenshot:</p><div><img src="img/1182OS_02_03.jpg" alt="Getting ready"/></div><p>With the <a id="id110" class="indexterm"/>menu in the top-right section, you can change two properties of this geometry. With the <strong>changeColors</strong> button, you can set the colors of each individual face to a random color, and with <strong>changeVertices</strong>, you change the position of each vertex of this cube. To apply these changes, you have to push the <strong>setUpdateColors</strong> button or the <strong>setUpdateVertices</strong> button, respectively.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec79"/>How to do it...</h2></div></div></div><p>There are a number of properties where you have to explicitly tell Three.js about the update. This recipe will show you how to inform Three.js about all possible changes. Depending on the change you're making, you can jump in at any step of the recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, if you want to add vertices or change the values of an individual vertex of a geometry, you can use the <code class="literal">geometry.vertices</code> property. Once you've added or changed an element, you need to set the <code class="literal">geometry.verticesNeedUpdate</code> property to <code class="literal">true</code>.</li><li class="listitem">Following this, you might want the face definition within a geometry to be cached as well, which will require you to use the <code class="literal">geometry.faces</code> property. This means that when you add <code class="literal">THREE.Face</code> or update one of the existing properties, you need to set <code class="literal">geometry.elementsNeedUpdate</code> to <code class="literal">true</code>.</li><li class="listitem">You might then want to morph targets that can be used to create animations, where one set of vertices morph into another set of vertices. This will require the <code class="literal">geometry.morphTargets</code> property. To do this, when you add a new morph target or update an existing one, you need to set <code class="literal">geometry.morphTargetsNeedUpdate</code> to <code class="literal">true</code>.</li><li class="listitem">Then, the next step would be to add <code class="literal">geometry.faceVertexUvs</code>. With this property, you define how textures are mapped onto the geometry. If you add or change elements in this array, you need to set the <code class="literal">geometry.uvsNeedUpdate</code> property to <code class="literal">true</code>.</li><li class="listitem">You might also want to change the vertices or faces' normals by changing the <code class="literal">geometry.faces[i].normal</code> and <code class="literal">geometry.vertices[i].normal</code> properties. When you do this, you have to set <code class="literal">geometry.normalsNeedUpdate</code> to <code class="literal">true</code> to inform Three.js about this. Besides the normal, there is also a <code class="literal">geometry.vertices[i].tangent</code> property. This property is used to calculate shadows and also calculate when textures are rendered. If you make manual changes, you have to set <code class="literal">geometry.tangentsNeedUpdate</code> to <code class="literal">true</code>.</li><li class="listitem">Next, you<a id="id111" class="indexterm"/> can define individual colors on the vertices or the faces. You do this by setting these color properties: <code class="literal">geometry.faces[i].color</code> and <code class="literal">geometry.vertices[i].color</code>. Once you've made changes to these properties, you have to set <code class="literal">geometry.colorsNeedUpdate</code> to <code class="literal">true</code>.</li><li class="listitem">As a final step, you can choose to change textures and materials during runtime. When you want to change one of these properties of a material, you need to set <code class="literal">material.needsUpdate</code> to <code class="literal">true</code>: texture, fog, vertex colors, skinning, morphing, shadow map, alpha test, uniforms, and lights. If you want to update the data behind a texture, you need to set the <code class="literal">texture.needsUpdate</code> flag to <code class="literal">true</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec80"/>How it works...</h2></div></div></div><p>As a summary, steps 1 to 7 apply to geometries and any resulting Three.js objects that are based on geometries.</p><p>To get the most performance out of your 3D scene, Three.js caches certain properties and values that usually don't change. Especially when working with the WebGL renderer, a lot of performance is gained by caching all these values. When you set one of these flags to true, Three.js knows, very specifically, which part it needs to update.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec81"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are recipes within this book that are similar to this. If you look at the source code for the <em>Applying matrix transformations</em> recipe, you can see that we've used the <code class="literal">verticesNeedUpdate</code> property after we applied some matrix transformations to the geometry.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Working with a large number of objects</h1></div></div></div><p>If you<a id="id112" class="indexterm"/> have scenes with large numbers of objects, you will start noticing some performance issues. Each of the meshes you create and add to the scene will need to be managed by Three.js, which will cause slowdowns when you're working with thousands of objects. In this recipe, we'll show you how to merge objects together to improve performance.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec82"/>Getting ready</h2></div></div></div><p>There are no additional libraries or resources required to merge objects together. We've prepared an example that shows you the difference in performance when using separate objects compared to a merged object. When you open up the <code class="literal">02.05-handle-large-number-of-object.html</code> example, you can experiment with the different approaches. </p><p>You will see something similar to the following screenshot:</p><div><img src="img/1182OS_02_04.jpg" alt="Getting ready"/></div><p>In the preceding screenshot, you can see that with a merged object approach, we still get 60 fps when working with 120,000 objects.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec83"/>How to do it...</h2></div></div></div><p>Merging objects in Three.js is very easy. The following code snippet shows you how to merge the objects from the previous example together. The important step here is to create <a id="id113" class="indexterm"/>a new <code class="literal">THREE.Geometry()</code> object named <code class="literal">mergedGeometry</code> and then create a large number of <code class="literal">BoxGeometry</code> objects, as shown in the highlighted code sections:</p><div><pre class="programlisting">
<strong>  var mergedGeometry = new THREE.Geometry();</strong>
  for (var i = 0; i &lt; control.numberToAdd; i++) {
    var cubeGeometry = new THREE.BoxGeometry(
      4*Math.random(), 
      4*Math.random(), 
      4*Math.random());
    var translation = new THREE.Matrix4().makeTranslation(
      100*Math.random()-50, 
      0, 100*Math.random()-50);
    cubeGeometry.applyMatrix(translation);
<strong>    mergedGeometry.merge(cubeGeometry);</strong>
  }
  var mesh = new THREE.Mesh(mergedGeometry, new THREE.MeshNormalMaterial({
    opacity: 0.5,
    transparent: true
  }));
  scene.add(mesh);</pre></div><p>We merge each <code class="literal">cubeGeometry</code> object into the <code class="literal">mergedGeometry</code> object by calling the <code class="literal">merge</code> function. The result is a single geometry that we use to create <code class="literal">THREE.Mesh</code>, which we add to the scene.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec84"/>How it works...</h2></div></div></div><p>When you call the <code class="literal">merge</code> function on a geometry (let's call it <code class="literal">merged</code>) and pass in the geometry to be merged (let's call this one <code class="literal">toBeMerged</code>), Three.js takes the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, Three.js clones all the vertices from the <code class="literal">toBeMerged</code> geometry and adds them to the vertices array of the <code class="literal">merged</code> geometry.</li><li class="listitem">Next, it walks through the faces from the <code class="literal">toBeMerged</code> geometry and creates new faces in the <code class="literal">merged</code> geometry, copying the original normal and colors.</li><li class="listitem">As a final step, it copies the <code class="literal">uv</code> mapping from <code class="literal">toBeMerged</code> into the <code class="literal">uv</code> mapping of the <code class="literal">merged</code> geometry.</li></ol></div><p>The result is a single geometry that, when added to the scene, looks like multiple geometries.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec85"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The main issue with this approach is that it gets harder to color, style, animate, and transform the objects that are merged together independently. For <a id="id114" class="indexterm"/>Three.js, after the merge, it counts as a single object. It is, however, possible to apply specific materials to each face. We show you how to do this in the <em>Using separate materials for faces</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Materials and Textures">Chapter 4</a>, <em>Materials and Textures</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Creating geometries from height maps</h1></div></div></div><p>With<a id="id115" class="indexterm"/> Three.js, it is easy to create your own geometries. For<a id="id116" class="indexterm"/> this recipe, we're going to show you how to create your own geometry based on a terrain height map.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec86"/>Getting ready</h2></div></div></div><p>To convert a height map into a 3D geometry, we first need to have a height map. In the source files provided with this book, you can find a height map for a portion of the Grand Canyon. The following image shows you what this looks like:</p><div><img src="img/1182OS_02_05.jpg" alt="Getting ready"/></div><p>If <a id="id117" class="indexterm"/>you're familiar with the Grand Canyon, you'll <a id="id118" class="indexterm"/>probably recognize the distinct shape. The final result we'll have at the end of this recipe can be viewed by opening up the <code class="literal">02.06-create-terrain-from-heightmap.html</code> file in your browser. You'll see something similar to the following screenshot:</p><div><img src="img/1182OS_02_06.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec87"/>How to do it...</h2></div></div></div><p>To<a id="id119" class="indexterm"/> create a heightmap-based geometry, you <a id="id120" class="indexterm"/>need to perform these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Before we look at the required Three.js code, we first need to load the image and set some properties that determine the final size and height of the geometry. This can be done by adding the following code snippet and loading the image by setting the <code class="literal">img.src</code> property to the location of our height map. Once the image is loaded, the <code class="literal">img.onload</code> function will be called, where we convert the image data to <code class="literal">THREE.Geometry</code>:<div><pre class="programlisting">  var depth = 512;
  var width = 512;
  var spacingX = 3;
  var spacingZ = 3;
  var heightOffset = 2;
  var canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 512;
  var ctx = canvas.getContext('2d');
  var img = new Image();
  img.src = "../assets/other/grandcanyon.png";
  img.onload = function () {...}</pre></div></li><li class="listitem">Once the image is loaded in the <code class="literal">onload</code> function, we need the value of each pixel and convert it to <code class="literal">THREE.Vector3</code>:<div><pre class="programlisting">  // draw on canvas
  ctx.drawImage(img, 0, 0);
  var pixel = ctx.getImageData(0, 0, width, depth);
  var geom = new THREE.Geometry();
  var output = [];
  for (var x = 0; x &lt; depth; x++) {
    for (var z = 0; z &lt; width; z++) {
      // get pixel
      // since we're grayscale, we only need one element
      // each pixel contains four values RGB and opacity
      var yValue = pixel.data[z * 4 + (depth * x * 4)] / heightOffset;
      var vertex = new THREE.Vector3(x * spacingX, yValue, z * spacingZ);
      geom.vertices.push(vertex);
    }
  }</pre></div><p>As you can see in this code snippet, we process each of the image pixels, and based on the pixel value, we create <code class="literal">THREE.Vector3</code>, which we add to the vertices array of our custom geometry.</p></li><li class="listitem">Now<a id="id121" class="indexterm"/> that we've defined the vertices, the <a id="id122" class="indexterm"/>next step is to use these vertices to create faces:<div><pre class="programlisting">  // we create a rectangle between four vertices, and we do
  // that as two triangles.
  for (var z = 0; z &lt; depth - 1; z++) {
    for (var x = 0; x &lt; width - 1; x++) {
      // we need to point to the position in the array
      // a - - b
      // |  x  |
      // c - - d
      var a = x + z * width;
      var b = (x + 1) + (z * width);
      var c = x + ((z + 1) * width);
      var d = (x + 1) + ((z + 1) * width);
      var face1 = new THREE.Face3(a, b, d);
      var face2 = new THREE.Face3(d, c, a);
      geom.faces.push(face1);
      geom.faces.push(face2);
    }
  }</pre></div><p>As you can see, each set of four vertices is converted into two <code class="literal">THREE.Face3</code> elements and added to the <code class="literal">faces</code> array.</p></li><li class="listitem">Now<a id="id123" class="indexterm"/> all we need to do is to let Three.js<a id="id124" class="indexterm"/> calculate the vertex and face normals, and we can create <code class="literal">THREE.Mesh</code> from this geometry and add it to the scene:<div><pre class="programlisting">  geom.computeVertexNormals(true);
  geom.computeFaceNormals();
  var mesh = new THREE.Mesh(geom, new THREE.MeshLambertMaterial({color: 0x666666}));
  scene.add(mesh);</pre></div></li></ol></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>If you render this scene, you might need to play around with the camera position and the scale of the final mesh to get the correct size.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec88"/>How it works...</h2></div></div></div><p>Height maps<a id="id125" class="indexterm"/> are a way to embed the height information into an image. Each pixel value of the image represents the relative height measured at that point. In this recipe, we've processed this value, together with its <em>x</em> and <em>y</em> values, and converted it into a vertex. If we do this for each point, we get an exact 3D representation of the 2D height map. In this case, it results in a geometry that contains 512 * 512 vertices.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec89"/>There's more…</h2></div></div></div><p>When we create a geometry from scratch, there are a few interesting things we can add. We can, for instance, color each individual face. This can be done by doing the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, add<a id="id126" class="indexterm"/> the <code class="literal">chroma</code> library (you can download the source from <a class="ulink" href="https://github.com/gka/chroma.js">https://github.com/gka/chroma.js</a>):<div><pre class="programlisting">  &lt;script src="img/chroma.min.js"&gt;&lt;/script&gt;</pre></div></li><li class="listitem">You can then create a color scale:<div><pre class="programlisting">  var scale = chroma.scale(['blue', 'green', red]).domain([0, 50]);</pre></div></li><li class="listitem">Set the face colors based on the height of the face:<div><pre class="programlisting">  face1.color = new THREE.Color(
    scale(getHighPoint(geom, face1)).hex());
  face2.color = new THREE.Color(
    scale(getHighPoint(geom, face2)).hex())</pre></div></li><li class="listitem">Finally, set <code class="literal">vertexColors</code> of the material to <code class="literal">THREE.FaceColors</code>. The result looks something like this:</li></ol></div><div><img src="img/1182OS_02_07.jpg" alt="There's more…"/></div><p>You<a id="id127" class="indexterm"/> can also apply different kinds of materials <a id="id128" class="indexterm"/>to really create a terrain-like effect. For more information on this, see <a class="link" href="ch04.html" title="Chapter 4. Materials and Textures">Chapter 4</a>, <em>Materials and Textures</em>, on materials.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec90"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In this sample, we've used a height map to create a geometry. You can also use a heightmap as a bump map to add depth detail to a model. We show you how to do this in <a class="link" href="ch04.html" title="Chapter 4. Materials and Textures">Chapter 4</a>, <em>Materials and Textures</em>, in the <em>Adding depth to a mesh with bump map</em> recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Pointing an object to another object</h1></div></div></div><p>A <a id="id129" class="indexterm"/>common requirement for many games is that cameras and other objects follow each other or be aligned to one another. Three.js has standard support for this using the <code class="literal">lookAt</code> function. In this recipe, you'll learn how you can use the <code class="literal">lookAt</code> function to point an object to look at another object.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec91"/>Getting ready</h2></div></div></div><p>The <a id="id130" class="indexterm"/>example for this recipe can be found in the sources for this book. If you open <code class="literal">02.07-point-object-to-another.html</code> in your browser, you see something similar to the following screenshot:</p><div><img src="img/1182OS_02_08.jpg" alt="Getting ready"/></div><p>With the menu, you can point the large blue rectangle to look at any of the other meshes in the scene.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec92"/>How to do it...</h2></div></div></div><p>Creating the <code class="literal">lookAt</code> functionality is actually very simple. When you add <code class="literal">THREE.Mesh</code> to the scene, you can just call its <code class="literal">lookAt</code> function and point it to the position it should turn to. For the example provided for this recipe, this is done as follows:</p><div><pre class="programlisting">  control = new function() {
    this.lookAtCube = function() {
      cube.lookAt(boxMesh.position);
    };
    this.lookAtSphere = function() {
      cube.lookAt(sphereMesh.position);
    };
    this.lookAtTetra = function() {
      cube.lookAt(tetraMesh.position);
    };
  };</pre></div><p>So when you push the <code class="literal">lookAtSphere</code> button, the rectangle's <code class="literal">lookAt</code> function will be called with the sphere's position.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec93"/>How it works...</h2></div></div></div><p>Using<a id="id131" class="indexterm"/> this code, it is very easy to line up one object with another. With the <code class="literal">lookAt</code> function, Three.js hides the complexity that is needed to accomplish this. Internally, Three.js uses matrix calculations to determine the rotation it needs to apply to the object to align it correctly with the object you're looking at. The required rotations are then set on the object (to the <code class="literal">rotation</code> property) and shown in the next render loop.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec94"/>There's more…</h2></div></div></div><p>In this example, we showed you how to align one object to another. With Three.js, you can use the same approach for other types of objects. You can point the camera to center on a specific object using <code class="literal">camera.lookAt(object.position)</code>, and you can also direct a light to point to a specific object using <code class="literal">light.lookAt(object.position)</code>.</p><p>You can also use <code class="literal">lookAt</code> to follow a moving object. Just add the <code class="literal">lookAt</code> code in the render loop, and the object will follow the moving object around.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec95"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">lookAt</code> function<a id="id132" class="indexterm"/> uses matrix calculations internally. In the last recipe of this chapter, <em>Applying matrix transformations</em>, we show you how you can use matrix calculations to accomplish other effects.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec36"/>Writing text in 3D</h1></div></div></div><p>A<a id="id133" class="indexterm"/> cool feature of Three.js is that it allows you to write text in 3D. With <a id="id134" class="indexterm"/>a couple of simple steps, you can use any text, even with font support, as a 3D object in your scene. This recipe shows you how to create 3D text and explains the different configuration options available to style the result.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec96"/>Getting ready</h2></div></div></div><p>To work with 3D text, we need to include some additional JavaScript in our pages. Three.js provides a number of fonts you can use, and they are provided as individual JavaScript <a id="id135" class="indexterm"/>files. To add all the available fonts, include the following scripts:</p><div><pre class="programlisting">  &lt;script src="img/gentilis_bold.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src="img/gentilis_regular.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src="img/optimer_bold.typeface.js"&gt;&lt;/script&gt;
  &lt;script src="img/optimer_regular.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src="img/helvetiker_bold.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src="img/helvetiker_regular.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src= "../assets/fonts/droid/droid_sans_regular.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src= "../assets/fonts/droid/droid_sans_bold.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src= "../assets/fonts/droid/droid_serif_regular.typeface.js"&gt;
  &lt;/script&gt;
  &lt;script src="img/droid_serif_bold.typeface.js"&gt;
  &lt;/script&gt;</pre></div><p>We've <a id="id136" class="indexterm"/>already done this in the <code class="literal">02.09-write-text-in-3D.html</code> example. If you open this in your browser, you can play around with the various fonts and properties available when creating text in Three.js. When you open the specified example you will see something similar to the following screenshot:</p><div><img src="img/1182OS_02_09.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec97"/>How to do it...</h2></div></div></div><p>Creating <a id="id137" class="indexterm"/>3D text in Three.js is very easy. All you have to do is <a id="id138" class="indexterm"/>create <code class="literal">THREE.TextGeometry</code> like this:</p><div><pre class="programlisting">  var textGeo = new THREE.TextGeometry(text, params);
  textGeo.computeBoundingBox();
  textGeo.computeVertexNormals();</pre></div><p>The <code class="literal">text</code> property<a id="id139" class="indexterm"/> is the text we want to write, and <code class="literal">params</code> define how the text is rendered. The <code class="literal">params</code> object can have many different parameters, which you can look at in more detail in the <em>How it works…</em> section.</p><p>In our example, however, we've used the following set of parameters (which point to the GUI in the top-right section):</p><div><pre class="programlisting">  var params = {
    material: 0,
    extrudeMaterial: 1,
    bevelEnabled: control.bevelEnabled,
    bevelThickness: control.bevelThickness,
    bevelSize: control.bevelSize,
    font: control.font,
    style: control.style,
    height: control.height,
    size: control.size,
    curveSegments: control.curveSegments
  };</pre></div><p>This<a id="id140" class="indexterm"/> geometry can then be added to the scene like any other geometry:</p><div><pre class="programlisting">  var material = new THREE.MeshFaceMaterial([
    new THREE.MeshPhongMaterial({
      color: 0xff22cc,
      shading: THREE.FlatShading
    }), // front
    new THREE.MeshPhongMaterial({
    color: 0xff22cc,
    shading: THREE.SmoothShading
    }) // side
  ]);
  var textMesh = new THREE.Mesh(textGeo, material);
  textMesh.position.x = -textGeo.boundingBox.max.x / 2;
  textMesh.position.y = -200;
  textMesh.name = 'text';
  scene.add(textMesh);</pre></div><div><div><h3 class="title"><a id="note05"/>Note</h3><p>There is<a id="id141" class="indexterm"/> one thing you need to take into account when working with <code class="literal">THREE.TextGeometry</code> and materials. As you can see from the code snippet, we add two material objects instead of one. The first material is applied to the front of rendered text, and the second one is applied to the side of the rendered text. If you just pass in one material, it is applied to both the front and the side.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec98"/>How it works...</h2></div></div></div><p>As mentioned, there is a variety of different parameters: </p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">height</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<a id="id142" class="indexterm"/> height property defines the depth of the text, in other words, how far the text is extruded to make it 3D.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With<a id="id143" class="indexterm"/> this property, you set the size of the final text.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">curveSegments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If a<a id="id144" class="indexterm"/> character has curves (for example, the letter <em>a</em>), this property defines how smooth the curves will be.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelEnabled</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <a id="id145" class="indexterm"/>bevel provides a smooth transition from the front of the text to the side. If you set this value to true, a bevel will be added to the rendered text.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelThickness</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If <a id="id146" class="indexterm"/>you've set <code class="literal">bevelEnabled</code> to <code class="literal">true</code>, it defines how deep the bevel is.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelSize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If <a id="id147" class="indexterm"/>you've set <code class="literal">bevelEnabled</code> to <code class="literal">true</code>, it defines how high the bevel is.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">weight</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id148" class="indexterm"/> the weight of the font (normal or bold).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">font</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id149" class="indexterm"/>is the name of the font to be used.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">material</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When <a id="id150" class="indexterm"/>an array of materials is provided, this should contain the index of the material to be used for the front.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">extrudeMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When <a id="id151" class="indexterm"/>an array of materials is provided, this should contain the index of the materials to be used for the side.</p>
</td></tr></tbody></table></div><p>When<a id="id152" class="indexterm"/> you create <code class="literal">THREE.TextGeometry</code>, Three.js internally uses <code class="literal">THREE.ExtrudeGeometry</code> to create the 3D shapes. <code class="literal">THREE.ExtrudeGeometry</code> works<a id="id153" class="indexterm"/> by taking a 2D shape and extrudes it along the <em>Z</em> axis to make it 3D. To create a 2D shape from a text string, Three.js uses the JavaScript files that we included in the <em>Getting ready</em> section of this recipe. These JavaScript files, based on <a class="ulink" href="http://typeface.neocracy.org/fonts.html">http://typeface.neocracy.org/fonts.html</a>, allow you to render text as 2D paths, which we then can convert to 3D.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec99"/>There's more…</h2></div></div></div><p>If you <a id="id154" class="indexterm"/>want to use a different font, you can convert your own fonts at <a class="ulink" href="http://typeface.neocracy.org/fonts.html">http://typeface.neocracy.org/fonts.html</a>. All you need to do to use these fonts is include them on your page and pass in the correct <code class="literal">name</code> and <code class="literal">style</code> values as parameters to <code class="literal">THREE.TextGeometry</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec37"/>Rendering 3D formulas as 3D geometries</h1></div></div></div><p>Three.js<a id="id155" class="indexterm"/> offers many different ways to create <a id="id156" class="indexterm"/>geometries. You can use the standard Three.js objects, such as <code class="literal">THREE.BoxGeometry</code> and <code class="literal">THREE.SphereGeometry</code>, create geometries completely from scratch, or just load models created by external 3D modeling programs. In this recipe, we will show you another way to create geometries. This recipe shows you how to create geometries based on math formulas.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec100"/>Getting ready</h2></div></div></div><p>For this recipe, we'll be using the <code class="literal">THREE.ParametricGeometry</code> object. As this is available from the standard Three.js distribution, there is no need to include additional JavaScript files.</p><p>To see the end result of this recipe, you can look at <code class="literal">02.10-create-parametric-geometries.html</code>, you'll see something similar to the following screenshot:</p><div><img src="img/1182OS_02_10.jpg" alt="Getting ready"/></div><p>This figure shows you a <em>Gray's Kleinbottle</em>, which is rendered based on a couple of simple math formulas.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec101"/>How to do it...</h2></div></div></div><p>Generating geometries using math formulas with Three.js is very easy and only takes two steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create the function that will create the geometry for us. This function will take two arguments: <code class="literal">u</code> and <code class="literal">v</code>. When Three.js uses this function to generate a geometry, it will call this function with <code class="literal">u</code> and <code class="literal">v</code> values, starting at <code class="literal">0</code> and ending at <code class="literal">1</code>. For each of these <code class="literal">u</code> and <code class="literal">v</code> combinations, this function should return a <code class="literal">THREE.Vector3</code> object, which represents a single vertex in the final geometry. The function that creates the figure <a id="id157" class="indexterm"/>you saw in the previous <a id="id158" class="indexterm"/>section is shown next:<div><pre class="programlisting">  var paramFunction = function(u, v) {
    var a = 3;
    var n = 3;
    var m = 1;
    var u = u * 4 * Math.PI;
    var v = v * 2 * Math.PI;
    var x = (a + Math.cos(n * u / 2.0) * Math.sin(v) - Math.sin(n * u / 2.0) * Math.sin(2 * v)) * Math.cos(m * u / 2.0);
    var y = (a + Math.cos(n * u / 2.0) * Math.sin(v) - Math.sin(n * u / 2.0) * Math.sin(2 * v)) * Math.sin(m * u / 2.0);
    var z = Math.sin(n * u / 2.0) * Math.sin(v) + Math.cos(n * u / 2.0) * Math.sin(2 * v);
    return new THREE.Vector3(x, y, z);
  }</pre></div><p>You can provide functions of your own as long as you return a new <code class="literal">THREE.Vector3</code> object for each value of <code class="literal">u</code> and <code class="literal">v</code>.</p></li><li class="listitem">Now that we've got the function that creates our geometry, we can use this function to create <code class="literal">THREE.ParametricGeometry</code>:<div><pre class="programlisting">  var geom = new THREE.ParametricGeometry(paramFunction, 100, 100);
  var mat = new THREE.MeshPhongMaterial({
    color: 0xcc3333a,
    side: THREE.DoubleSide,
    shading: THREE.FlatShading
  });
  var mesh = new THREE.Mesh(geom, mat);
  scene.add(mesh);</pre></div></li></ol></div><p>You can clearly see that three arguments have been applied to the constructor of <code class="literal">THREE.ParametricObject</code>. This is discussed in more detail in the <em>How it works…</em> section.</p><p>All you have to do after creating the geometry is create <code class="literal">THREE.Mesh</code> and add it to the scene just like any other Three.js object.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec102"/>How it works...</h2></div></div></div><p>From step 2 in the preceding code snippet, you can see that we provide three arguments to the constructor of <code class="literal">THREE.ParametricObject</code>. The first one is the function we showed you in step 1, the second determines in how many steps we divide the <code class="literal">u</code> parameter, and the third one determines in how many steps we divide the <code class="literal">v</code> parameter. The<a id="id159" class="indexterm"/> higher the number, the more vertices<a id="id160" class="indexterm"/> will be created, and the smoother the final geometry will look. Note, though, that a very high amount of vertices has an adverse effect on performance.</p><p>When you create <code class="literal">THREE.ParametricGeometry</code>, Three.js will call the provided function a number of times. The amount of times the function is called is based on the second and third parameters. This results in a set of <code class="literal">THREE.Vector3</code> objects, which are then automatically combined into faces. This results in a geometry that you can use just like any other geometry.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec103"/>There's more…</h2></div></div></div><p>There are many different things you can do with these kinds of geometries than what is shown in this recipe. In the <code class="literal">02.10-create-parametric-geometries.html</code> source file, you can find a couple of other functions that create interesting-looking geometries such as the one shown in the following screenshot:</p><div><img src="img/1182OS_02_11.jpg" alt="There's more…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec38"/>Extending Three.js with a custom geometry object</h1></div></div></div><p>In <a id="id161" class="indexterm"/>the recipes you've seen so far, we <a id="id162" class="indexterm"/>create Three.js objects from scratch. We either build a new geometry from scratch with vertices and faces, or we reuse an existing one and configure it for our purpose. While this is good enough for most scenarios, it isn't the best solution when you need to maintain a large code base with lots of different geometries. In Three.js, you create geometries by just instantiating a <code class="literal">THREE.GeometryName</code> object. In this recipe, we'll show you how you can create a custom geometry object and instantiate it just like the other Three.js objects.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec104"/>Getting ready</h2></div></div></div><p>The example that you can use to experiment with this recipe can be found in the provided sources. Open up <code class="literal">02.11-extend-threejs-with-custom-geometry.html</code> in your browser to see the final result, which will be similar to the following screenshot:</p><div><img src="img/1182OS_02_12.jpg" alt="Getting ready"/></div><p>In <a id="id163" class="indexterm"/>this screenshot, you see a single <a id="id164" class="indexterm"/>rotating cube. This cube is created as a custom geometry and can be instantiated by using new <code class="literal">THREE.FixedBoxGeometry()</code>. In the upcoming section, we'll explain how to accomplish this.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec105"/>How to do it...</h2></div></div></div><p>Extending Three.js with a custom geometry is fairly easy and only takes a couple of simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create a new JavaScript object that contains the logic and properties of our new Three.js geometry. For this recipe, we'll create <code class="literal">FixedBoxGeometry</code>, which acts exactly like <code class="literal">THREE.BoxGeometry</code> but uses the same values for its height, width, and depth. For this recipe, we create this new object in the <code class="literal">setupCustomObject</code> function:<div><pre class="programlisting">  function setupCustomObject() {
    // First define the object.
    THREE.FixedBoxGeometry = function ( width, segments) {
      // first call the parent constructor
      THREE.Geometry.call( this );
      this.width = width;
      this.segments = segments;
      // we need to set
      //   - vertices in the parent object
      //   - faces in the parent object
      //   - uv mapping in the parent object
      // normally we'd create them here ourselves
      // in this case, we just reuse the once
      // from the boxgeometry.
      var boxGeometry = new THREE.BoxGeometry(
        this.width, 
        this.width, 
        this.width, this.segments, this.segments);
      this.vertices = boxGeometry.vertices;
      this.faces = boxGeometry.faces;
      this.faceVertexUvs = boxGeometry.faceVertexUvs;
    }
    // define that FixedBoxGeometry extends from 
    // THREE.Geometry
    THREE.FixedBoxGeometry.prototype= Object.create( THREE.Geometry.prototype );
  }</pre></div><p>In <a id="id165" class="indexterm"/>this function, we define a new JavaScript object using <code class="literal">THREE.FixedBoxGeometry = function ( width, segments) {..}</code>. In this function, we first call the constructor of the parent object (<code class="literal">THREE.Geometry.call( this )</code>). This makes sure that all properties are correctly initialized. Next, we wrap an existing <code class="literal">THREE.BoxGeometry</code> object and use information from that object to set <code class="literal">vertices</code>, <code class="literal">faces</code>, and <code class="literal">faceVertexUvs</code> for our own custom object.</p><p>Finally, we need to tell JavaScript that our <code class="literal">THREE.BoxGeometry</code> object extends from <code class="literal">THREE.Geometry</code>. This is done by setting a prototype property of <code class="literal">THREE.FixedBoxGeometry</code> to <code class="literal">Object.create(THREE.Geometry.prototype)</code>.</p></li><li class="listitem">After <code class="literal">setupCustomObject()</code> is called, we can now use the same approach to create this object like we do for the other Three.js-provided geometries:<div><pre class="programlisting">  var cubeGeometry = new THREE.FixedBoxGeometry(3, 5);
  var cubeMaterial = new THREE.MeshNormalMaterial();
  var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  scene.add(cube);</pre></div><p>At this point, we've created a custom Three.js geometry that you can instantiate just like the standard geometries provided by Three.js.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec106"/>How it works...</h2></div></div></div><p>In<a id="id166" class="indexterm"/> this recipe, we use one of the <a id="id167" class="indexterm"/>standard ways JavaScript provides to create objects that inherit from other objects. We defined the following:</p><div><pre class="programlisting">  THREE.FixedBoxGeometry.prototype= Object.create( THREE.Geometry.prototype );</pre></div><p>This code fragment tells JavaScript that <code class="literal">THREE.FixedBoxGeometry</code> is created, it inherits all the properties and functions from <code class="literal">THREE.Geometry</code>, which has its own constructor. This is the reason we also add the following call to our new object:</p><div><pre class="programlisting">  THREE.Geometry.call( this );</pre></div><p>This calls the constructor of the <code class="literal">THREE.Geometry</code> object whenever our own custom object is created.</p><p>There is more to prototype-based inheritance than what's explained in this short recipe. If you want to know more about prototype-based inheritance, the Mozilla guys have a great explanation <a id="id168" class="indexterm"/>on how inheritance using the prototype property works at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain</a>. </p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec107"/>There's more...</h2></div></div></div><p>In this recipe, we've wrapped an existing Three.js object to create our custom object. You can also apply this same approach for objects that are created completely from scratch. For instance, you can create <code class="literal">THREE.TerrainGeometry</code> from the JavaScript code we used in the <em>Creating geometries from heightmaps</em> recipe to create a 3D terrain.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec39"/>Creating a spline curve between two points</h1></div></div></div><p>When <a id="id169" class="indexterm"/>you create visualizations and, for instance, want to visualize the flight path of an airplane, drawing a curve between the start and end point is a good approach. In this recipe, we'll show you how you can do this using the standard <code class="literal">THREE.TubeGeometry</code> object.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec108"/>Getting ready</h2></div></div></div><p>When <a id="id170" class="indexterm"/>you open the example for this recipe, <code class="literal">02.12-create-spline-curve.html</code>, you can see a tube geometry that curves from start to end:</p><div><img src="img/1182OS_02_13.jpg" alt="Getting ready"/></div><p>In the upcoming section, we'll explain step by step how to create this curve.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec109"/>How to do it...</h2></div></div></div><p>To create a curved spline, like what is shown in the preceding example, we need to take a couple of simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is define some constants for this curve:<div><pre class="programlisting">  var numPoints = 100;
  var start = new THREE.Vector3(-20, 0, 0);
  var middle = new THREE.Vector3(0, 30, 0);
  var end = new THREE.Vector3(20, 0, 0);</pre></div><p>The <code class="literal">numPoints</code> object<a id="id171" class="indexterm"/> defines how many vertices we'll use to define the curve and the number of segments we use when rendering the tube. The <code class="literal">start</code> vector defines the position where <a id="id172" class="indexterm"/>we want to start the curve, the <code class="literal">end</code> vector determines <a id="id173" class="indexterm"/>the end point of our curve, and finally, the <a id="id174" class="indexterm"/>
<code class="literal">middle</code> vector defines the height and center point of our curve. If we, for instance, set <code class="literal">numPoints</code> to <code class="literal">5</code>, we get a different kind of curve.</p><div><img src="img/1182OS_02_14.jpg" alt="How to do it..."/></div></li><li class="listitem">Now<a id="id175" class="indexterm"/> that we've got the <code class="literal">start</code>, <code class="literal">end</code>, and <code class="literal">middle</code> vectors, we can use them to create a nice curve. For this, we can use an object provided by Three.js, called <code class="literal">THREE.QuadraticBezierCurve3</code>:<div><pre class="programlisting">  var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end);</pre></div><p>Based on this <code class="literal">curveQuad</code>, we can now create a simple tube geometry.</p></li><li class="listitem">To create a tube, we use <code class="literal">THREE.TubeGeometry</code> and pass in <code class="literal">curveQuad</code>, which we created in the previous step:<div><pre class="programlisting">  var tube = new THREE.TubeGeometry(curveQuad, numPoints, 2, 20, false);
  var mesh = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({
    opacity: 0.6,
    transparent: true
  }));
  scene.add(mesh);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec110"/>How it works...</h2></div></div></div><p>The <code class="literal">QuadraticBezierCurve3</code> object we created in this recipe has a number of different functions (<code class="literal">getTangentAt</code> and <code class="literal">getPointAt</code>) that determine the location somewhere along the path. These functions return information based on the <code class="literal">start</code>, <code class="literal">middle</code>, and <code class="literal">end</code> vectors passed in to the constructor. When we pass <code class="literal">QuadraticBezierCurve3</code> into <code class="literal">THREE.TubeGeometry</code>, <code class="literal">THREE.TubeGeometry</code> uses the <code class="literal">getTangentAt</code> function to determine <a id="id176" class="indexterm"/>where to position its vertices.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec111"/>There's more…</h2></div></div></div><p>In this recipe, we used <code class="literal">THREE.QuadraticBezierCurve3</code> to create our spline. Three.js also provides a <code class="literal">THREE.CubicBezierCurve3</code> and <code class="literal">THREE.SplineCurve3</code> curve, which you can use to define these kinds of splines. You can find more information on the differences <a id="id177" class="indexterm"/>between a quadratic Bezier curve and a cubic Bezier curve at <a class="ulink" href="http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c">http://stackoverflow.com/questions/18814022/what-is-the-difference-between-cubic-bezier-and-quadratic-bezier-and-their-use-c</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec40"/>Creating and exporting a model from Blender</h1></div></div></div><p>Blender, which you can download from <a class="ulink" href="http://www.blender.org/download/">http://www.blender.org/download/</a>, is a great <a id="id178" class="indexterm"/>tool to create 3D models and has excellent support<a id="id179" class="indexterm"/> for Three.js. With the right plugin, Blender <a id="id180" class="indexterm"/>can export models directly into Three.js' own <a id="id181" class="indexterm"/>JSON <a id="id182" class="indexterm"/>format, which can then easily be added to your scene.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec112"/>Getting ready</h2></div></div></div><p>Before we can use the JSON exporter in Blender, we first need to install the plugin in Blender. To install the plugin, take the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing you need to do is get the latest version of the plugin. We've added this to the source code of this book. You can find this plugin in the <code class="literal">assets/plugin</code> folder. In that directory, you'll find a single directory with the <code class="literal">io_mesh_threejs</code> name. To install the plugin, just copy this complete directory to the plugin location of Blender. As Blender is multiplatform, depending on your OS, this plugin directory might be stored in a different location.</li><li class="listitem">For Windows, copy the <code class="literal">io_mesh_threejs</code> directory to <code class="literal">C:\Users\USERNAME\AppData\Roaming\Blender Foundation\Blender\2.70a\scripts\addons</code>.</li><li class="listitem">For<a id="id183" class="indexterm"/> OS X users, it depends on where you<a id="id184" class="indexterm"/> installed Blender (extracted the ZIP file). You <a id="id185" class="indexterm"/>should copy the <code class="literal">io_mesh_threejs</code> directory to <code class="literal">/location/of/extracted/zip/blender.app/Contents/MacOS/2.6X/scripts/addons</code>.</li><li class="listitem">Finally, for <a id="id186" class="indexterm"/>Linux users, copy the <code class="literal">io_mesh_threejs</code> directory to <code class="literal">/home/USERNAME/.config/blender/2.70a/scripts/addons</code>.</li><li class="listitem">If you've installed Blender through apt-get, you should copy the <code class="literal">io_mesh_threejs</code> directory to <code class="literal">/usr/lib/blender/scripts/addons</code>.</li><li class="listitem">The next step is to enable the Three.js plugin. If Blender is already running, restart it and open <strong>User Preferences</strong>. You can find this by navigating to <strong>File</strong> | <strong>User Preferences</strong>. In the screen that opens, select the <strong>Addons</strong> tab, which lists all the plugins that are available.<div><img src="img/1182OS_02_15.jpg" alt="Getting ready"/></div></li><li class="listitem">At <a id="id187" class="indexterm"/>this point, the Three.js plugin is enabled. To<a id="id188" class="indexterm"/> make sure it stays enabled <a id="id189" class="indexterm"/>when you restart Blender, click <a id="id190" class="indexterm"/>on the <strong>Save User Settings</strong> button. Now, close this window and if you navigate to <strong>File</strong> | <strong>Export</strong>, you should see a Three.js export function as shown in the following screenshot:<div><img src="img/1182OS_02_16.jpg" alt="Getting ready"/></div></li></ol></div><p>Now, let's look at the rest of this recipe and see how we can export a model from Blender and <a id="id191" class="indexterm"/>load it in Three.js.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec113"/>How to do it...</h2></div></div></div><p>To<a id="id192" class="indexterm"/> export a model from Blender, we first have to create<a id="id193" class="indexterm"/> one. Instead of loading an existing one, in this <a id="id194" class="indexterm"/>recipe, we'll create one from scratch, export it, and load it in Three.js:</p><div><ol class="orderedlist arabic"><li class="listitem">To start off, when you open Blender, you'll see a cube. First, we delete this cube. You do this by pressing <em>x</em> and clicking on delete in the pop up.</li><li class="listitem">Now, we'll create a simple geometry that we can export with the Three.js plugin we installed. For this, click on <strong>Add</strong> in the bottom menu and select <strong>Monkey</strong>, as shown in the following screenshot:<div><img src="img/1182OS_02_17.jpg" alt="How to do it..."/></div><p>Now, you should have an empty scene in Blender with monkey geometry in the middle:</p><div><img src="img/1182OS_02_18.jpg" alt="How to do it..."/></div></li><li class="listitem">We can export this monkey to Three.js using the plugin we installed in the <em>Getting ready</em> section of this recipe. To do this, navigate to <strong>Export</strong> | <strong>Three.js</strong> in <a id="id195" class="indexterm"/>the <strong>File</strong> menu. This opens up the export <a id="id196" class="indexterm"/>dialog where you can determine <a id="id197" class="indexterm"/>the directory to export the model to. In this <strong>Export</strong> dialog, you can also set some additional Three.js-specific<a id="id198" class="indexterm"/> export properties, but the default properties usually are okay. For this recipe, we exported the model as <code class="literal">monkey.js</code>.</li><li class="listitem">At this point, we've exported the model and can now load it with Three.js. To load the model, we only have to add the following JavaScript to the <em>Getting started with the WebGL renderer</em> recipe we showed in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>:<div><pre class="programlisting">  function loadModel() {
    var loader = new THREE.JSONLoader();
    loader.load("../assets/models/monkey.js", function(model, material) {
      var mesh = new THREE.Mesh(model, material[0]);
      mesh.scale = new THREE.Vector3(3,3,3);
      scene.add(mesh);
    });
  }</pre></div></li></ol></div><p>The result is a rotating monkey, which we created in Blender, rendered by Three.js as shown in the following screenshot:</p><div><img src="img/1182OS_02_19.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec114"/>See also</h2></div></div></div><p>There <a id="id199" class="indexterm"/>are a few recipes that you will benefit from reading:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In<a id="id200" class="indexterm"/> the <em>Using OBJMTLLoader with multiple materials</em> recipe, we use a different format, which we load into Three.js</li><li class="listitem" style="list-style-type: disc">In <a class="link" href="ch07.html" title="Chapter 7. Animation and Physics">Chapter 7</a>, <em>Animation and Physics</em>, where we look at animations, we'll revisit the Three.js exporter plugin when we're working with skeleton-based animations in the <em>Animating with skeletons</em> recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec41"/>Using OBJMTLLoader with multiple materials</h1></div></div></div><p>Three.js<a id="id201" class="indexterm"/> provides a number of standard <a id="id202" class="indexterm"/>geometries that you can use to create your 3D scenes. Complex models, however, are more easily created in dedicated 3D modeling applications such as Blender or 3ds Max. Luckily, though, Three.js has great support for a large number of export formats, so you can easily load models created in these kinds of packages. A standard that is widely supported is the <code class="literal">OBJ</code> format. With this format, the model is described with two different files: an <code class="literal">.obj</code> file that defines the geometries and an <code class="literal">.mtl</code> file that defines the material. In this recipe, we'll show you the steps you need to take to successfully load a model using <code class="literal">OBJMTLLoader</code>, which is provided by Three.js.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec115"/>Getting ready</h2></div></div></div><p>To <a id="id203" class="indexterm"/>load models described in the <code class="literal">.obj</code> and <code class="literal">.mtl</code> format, we need to first include the correct JavaScript file, as these JavaScript<a id="id204" class="indexterm"/> objects aren't included in the standard Three.js JavaScript file. So, within the head section, you need to add the following script tags:</p><div><pre class="programlisting">  &lt;script src="img/MTLLoader.js"&gt;&lt;/script&gt;
  &lt;script src="img/OBJMTLLoader.js"&gt;&lt;/script&gt;</pre></div><p>The model we use in this example is a Lego mini figure. In Blender, the original model looks like this:</p><div><img src="img/1182OS_02_20.jpg" alt="Getting ready"/></div><p>You can see the final model by opening up <code class="literal">02.14-use-objmtlloader-with-multiple-materials.html</code> in your browser. The following screenshot shows you what the renderer model looks like:</p><div><img src="img/1182OS_02_21.jpg" alt="Getting ready"/></div><p>Let's <a id="id205" class="indexterm"/>walk you through the steps you<a id="id206" class="indexterm"/> need to take to load such a model.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec116"/>How to do it...</h2></div></div></div><p>Before we load the model in Three.js, we first need to check whether the correct paths are defined in the <code class="literal">.mtl</code> file. So, the first thing we need to do is open the <code class="literal">.mtl</code> file in a text editor:</p><div><ol class="orderedlist arabic"><li class="listitem">When you open the <code class="literal">.mtl</code> file for this example, you'll see the following:<div><pre class="programlisting">  newmtl Cap
  Ns 96.078431
  Ka 0.000000 0.000000 0.000000
  Kd 0.990000 0.120000 0.120000
  Ks 0.500000 0.500000 0.500000
  Ni 1.000000
  d 1.00000
  illum 2
  newmtl Minifig
  Ns 874.999998
  Ka 0.000000 0.000000 0.000000
  Kd 0.800000 0.800000 0.800000
  Ks 0.200000 0.200000 0.200000
  Ni 1.000000
  d 1.000000
  illum 2
<strong>  map_Kd ../textures/Mini-tex.png</strong>
</pre></div><p>This <code class="literal">.mtl</code> file defines two materials: one for the body of the mini figure <a id="id207" class="indexterm"/>and one for its cap. What we need to check is the <code class="literal">map_Kd</code> property. This property needs to contain the relative path, from where the <code class="literal">.obj</code> file is loaded to where Three.js can find the textures. In our example, this path is: <code class="literal">.../textures/Mini-tex.png</code>.</p></li><li class="listitem">Now <a id="id208" class="indexterm"/>that we've made sure <a id="id209" class="indexterm"/>the <code class="literal">.mtl</code> file contains the correct references, we can load the model using <code class="literal">THREE.OBJMTLLoader</code>:<div><pre class="programlisting">  var loader = new THREE.OBJMTLLoader();
  // based on model from:
  // http://www.blendswap.com/blends/view/69499
  loader.load("../assets/models/lego.obj",
  "../assets/models/lego.mtl", 
  function(obj) {
    obj.translateY(-3);
    obj.name='lego';
    scene.add(obj);
  });</pre></div><p>As you can see, we pass both <code class="literal">.obj</code> and <code class="literal">.mtl</code> files into the <code class="literal">load</code> function. The final argument of this <code class="literal">load</code> function is a <code class="literal">callback</code> function. This <code class="literal">callback</code> function will be called when the model is done loading.</p></li><li class="listitem">At this point, you can do everything you want with the loaded model. In this example, we add the scaling and rotation functionality through the menu in the top-right section and apply these properties to the <code class="literal">render</code> function:<div><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    var lego = scene.getObjectByName('lego');
    if (lego) {
      lego.rotation.y += control.rotationSpeed;
      lego.scale.set(control.scale, control.scale, control.scale);
    }
    requestAnimationFrame(render);
  }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec117"/>How it works...</h2></div></div></div><p>The <code class="literal">.obj</code> and <code class="literal">.mtl</code> file formats are well-documented formats. <code class="literal">OBJMTLLoader</code> parses the information from these two files and creates geometries and materials based on that information. It uses the <code class="literal">.obj</code> file to determine an object's geometry and uses information from the <code class="literal">.mtl</code> file to determine the material, which is <code class="literal">THREE.MeshLambertMaterial</code> in this case, to be used for each geometry.</p><p>Three.js<a id="id210" class="indexterm"/> then combines these together <a id="id211" class="indexterm"/>into <code class="literal">THREE.Mesh</code> objects and returns a single <code class="literal">THREE.Object3D</code> object that contains all the parts of the <code class="literal">Lego</code> figure, which you can then add to the scene.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec118"/>There's more…</h2></div></div></div><p>In this recipe, we showed you how to load objects defined in the <code class="literal">.obj</code> and <code class="literal">.mtl</code> format. Besides this format, Three.js also supports a wide range of other formats. For a good overview<a id="id212" class="indexterm"/> of the file formats supported by Three.js, refer to this directory on Three.js' GitHub repository: <a class="ulink" href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec119"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For this recipe, we assume we have a complete model in the correct format. If you want to create a model from scratch, a good open source 3D modeling tool is Blender. The the <em>Creating and Exporting a model from a Blender</em> recipe, explains how to create a new model in Blender and export it so that Three.js can load it.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec42"/>Applying matrix transformations</h1></div></div></div><p>In the<a id="id213" class="indexterm"/> first couple of recipes in this chapter, we used the <code class="literal">rotation</code> property and applied translations to get the desired rotational effect. Behind the scenes, Three.js uses matrix transformations to modify the shape and position of the mesh or the geometry. Three.js also provides the functionality to apply custom matrix transformations directly to a geometry or a mesh. In this recipe, we'll show you how you can apply your own custom matrix transformations directly to a Three.js object.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec120"/>Getting ready</h2></div></div></div><p>To view this recipe in action and experiment with the various transformations, open the <code class="literal">02.15-apply-matrix-transformations.html</code> example in your browser. You'll be presented with the following simple Three.js scene:</p><div><img src="img/1182OS_02_22.jpg" alt="Getting ready"/></div><p>In<a id="id214" class="indexterm"/> this scene, you can use the menu on the right-hand side to apply various transformations directly to the spinning cube. In the next section, we'll show you the steps you need to take to create this yourself.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec121"/>How to do it...</h2></div></div></div><p>Creating your own matrix transformation is very simple. </p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, let's look at the code that gets called when you click on the <strong>doTranslation</strong> button:<div><pre class="programlisting">  this.doTranslation = function() {
    // you have two options, either use the
    // helper function provided by three.js
    // new THREE.Matrix4().makeTranslation(3,3,3);
    // or do it yourself
    var translationMatrix = new THREE.Matrix4(
      1, 0, 0, control.x,
      0, 1, 0, control.y,
      0, 0, 1, control.z,
      0, 0, 0, 1
    );
    cube.applyMatrix(translationMatrix);
    // or do it on the geometry
    // cube.geometry applyMatrix(translationMatrix);
    // cube.geometry.verticesNeedUpdate = true;
  }</pre></div><p>As you can see in the code, creating a custom matrix transformation is very easy and requires only the following steps.</p></li><li class="listitem">First, you instantiate a new <code class="literal">THREE.Matrix4</code> object and pass in the values of the matrix as arguments to the constructor.</li><li class="listitem">Next, you use the <code class="literal">applyMatrix</code> function of either <code class="literal">THREE.Mesh</code> or <code class="literal">THREE.Geometry</code> to apply the transformation to that specific object.</li><li class="listitem">If you apply this on <code class="literal">THREE.Geometry</code> you have to set the <code class="literal">verticesNeedUpdate</code> property to <code class="literal">true</code>, as vertex changes aren't automatically propagated to the renderer (see the <em>Informing Three.js about updates</em> recipe).</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec122"/>How it works</h2></div></div></div><p>The <a id="id215" class="indexterm"/>transformations used in this recipe are based on matrix calculations. Matrix calculations by themselves are a rather complex subject. If you're interested in more information on how matrix calculations work and how they <a id="id216" class="indexterm"/>can be used for all different kinds of transformations, a good explanation can be found at <a class="ulink" href="http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices">http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec123"/>There's more…</h2></div></div></div><p>In the example for this chapter, you can apply a couple of transformations to the rotating cube. The following code snippet shows you the matrices used for these transformations:</p><div><pre class="programlisting">  this.doScale = function() {
    var scaleMatrix = new THREE.Matrix4(
      control.x, 0, 0, 0,
      0, control.y, 0, 0,
      0, 0, control.z, 0,
      0, 0, 0, 1
    );
    cube.geometry.applyMatrix(scaleMatrix);
    cube.geometry.verticesNeedUpdate = true;
  }
  this.doShearing = function() {
    var scaleMatrix = new THREE.Matrix4(
      1, this.a, this.b, 0,
      this.c, 1, this.d, 0,
      this.e, this.f, 1, 0,
      0, 0, 0, 1
    );
    cube.geometry.applyMatrix(scaleMatrix);
    cube.geometry.verticesNeedUpdate = true;
  }
  this.doRotationY = function() {
    var c = Math.cos(this.theta),
    s = Math.sin(this.theta);
    var rotationMatrix = new THREE.Matrix4(
      c, 0, s, 0,
      0, 1, 0, 0, -s, 0, c, 0,
      0, 0, 0, 1
    );
    cube.geometry.applyMatrix(rotationMatrix);
    cube.geometry.verticesNeedUpdate = true;
  }</pre></div><p>In this<a id="id217" class="indexterm"/> recipe, we created the matrix transformations from scratch. Three.js, however, also provides some helper functions in the <code class="literal">Three.Matrix4</code> class that you can use to more easily create these kinds of matrices:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">makeTranslation(x, y, z)</code>: This function returns a matrix, which when applied<a id="id218" class="indexterm"/> to a geometry or a mesh, translates the object by the specified x, y, and z values</li><li class="listitem" style="list-style-type: disc"><code class="literal">makeRotationX(theta)</code>: This returns a matrix that can be used to rotate a mesh<a id="id219" class="indexterm"/> or geometry by a certain amount of radians along the <em>x</em> axis</li><li class="listitem" style="list-style-type: disc"><code class="literal">makeRotationY(theta)</code>: This is the same as the previous one—this time around <a id="id220" class="indexterm"/>the <em>y</em> axis</li><li class="listitem" style="list-style-type: disc"><code class="literal">makeRotationZ(theta)</code>: This is the same as the previous one—this time around the <em>z</em> axis</li><li class="listitem" style="list-style-type: disc"><code class="literal">makeRotationAxis(axis, angle)</code>: This returns a rotation matrix based on<a id="id221" class="indexterm"/> the provided axis and angle</li><li class="listitem" style="list-style-type: disc"><code class="literal">makeScale(x, y, z)</code>: This function returns a matrix that can be used to scale<a id="id222" class="indexterm"/> an object along any of the three axes</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec124"/>See also</h2></div></div></div><p>We've also used matrix transformations in other recipes in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the first two recipes, <em>Rotating an object around its own axis</em> and <em>Rotating an object around a point in space</em>, the actual rotation is applied using a matrix transformation</li><li class="listitem" style="list-style-type: disc">In the <em>Rotating an object around its own axis</em> recipe, we used the helper functions from the <code class="literal">THREE.Matrix4</code> object to rotate an object around its axis</li></ul></div></div></div></body></html>