- en: Creating a Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s been quite a ride so far. We''ve gone through all the different aspects
    that encompass the creation of a map. We''ve touched on the basics of SVG, JavaScript,
    and D3\. Now, it''s time to put all the pieces together and actually have a final
    deliverable product. In this chapter, we will cover the following topics through
    a series of experiments:'
  prefs: []
  type: TYPE_NORMAL
- en: Foundation - creating your basic map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 1 - adjusting the bounding box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 2 - creating choropleths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 3 - adding click events to our visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 4 - using updates and transitions to enhance our visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 5 - adding points of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 6 - adding visualizations as a point of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundation - creating your basic map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will walk through the basics of creating a standard map.
  prefs: []
  type: TYPE_NORMAL
- en: The example can be viewed by opening the `example-1.html` file of this chapter
    provided with this book. If you already have the HTTP server running, you can
    point your browser to `http://localhost:8080/chapter-4/example-1.html`. On the
    screen is Mexico (Oscar's beloved country)!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea3f5f64-7d25-4a43-9eac-c4d892d1740b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's walk through the code to get a step-by-step explanation of how to create
    this map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `width` and `height` can be anything you want. Depending on where your
    map will be visualized (cellphones, tablets, or desktops), you might want to consider
    providing a different `width` and `height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next variable defines a projection algorithm that allows you to go from
    a cartographic space (latitude and longitude) to a Cartesian space (*x, y*)—basically
    a mapping of latitude and longitude to coordinates. You can think of a projection
    as a way to map the three-dimensional globe to a flat plane. There are many kinds
    of projections, but `geoMercator()` is normally the default value you will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were making a map of the USA, you could use a better projection called
    AlbersUsa. This is to better position Alaska and Hawaii. By creating a `geoMercator()`
    projection, Alaska would render proportionate to its size, rivaling that of the
    entire US. The `geoAlbersUsa()` projection grabs Alaska, makes it smaller, and
    puts it at the bottom of the visualization. The following screenshot is of `geoMercator()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cad1c5b8-d456-4c31-a56a-c14577435bc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This next screenshot is of `geoAlbersUsa()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d55e359-bcb2-4460-b97c-f2562494bb42.png)'
  prefs: []
  type: TYPE_IMG
- en: The D3 library currently contains many built-in projection algorithms. An overview
    of each one can be viewed at [https://github.com/d3/d3-geo/blob/master/README.md#projections](https://github.com/d3/d3-geo/blob/master/README.md#projections).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will assign the projection to our `geoPath()` function. This is a
    special D3 function that will map the JSON-formatted geographic data into SVG
    paths. The data format that the `geoPath()` function requires is named GeoJSON
    and will be covered in [Chapter 6](80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml),
    *Finding and Working with Geographic Data*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Including the dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The necessary data has been provided for you within the `data` folder, with
    the filename `geo-data.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We get the data from an AJAX call, as we saw in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After the data has been collected, we want to draw only those parts of the data
    that we are interested in. In addition, we want to automatically scale the map
    to fit the defined height and width of our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the console, you''ll see that `mexico` has an `objects` property.
    Nested inside the `objects` property is `MEX_adm1`. This stands for the administrative
    areas of Mexico. It is important to understand the geographic data you are using,
    because other data sources might have different names for the administrative areas
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/511285b8-5b6a-4f9b-b242-6d08df5913d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the `MEX_adm1` property contains a `geometries` array with 32 elements.
    Each of these elements represents a state in Mexico. Use this data to draw the
    D3 visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we pass all of the administrative areas to the `topojson.feature()` function
    in order to extract and create an array of GeoJSON objects. The preceding `states`
    variable now contains the `features` property. This `features` array is a list
    of 32 GeoJSON elements, each representing the geographic boundaries of a state
    in Mexico. We will set an initial scale and translation to `1` and `[0,0]` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This algorithm is quite useful. The bounding box is a spherical box that returns
    a two-dimensional array of min/max coordinates, inclusive of the geographic data
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To quote the D3 documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The bounding box is represented by a two-dimensional array: [[left, bottom],
    [right, top]], where left is the minimum longitude, bottom is the minimum latitude,
    right is maximum longitude, and top is the maximum latitude."'
  prefs: []
  type: TYPE_NORMAL
- en: This is very helpful if you want to programmatically set the scale and translation
    of the map. In this case, we want the entire country to fit in our `height` and
    `width`, so we determine the bounding box of every state in the country of Mexico.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scale is calculated by taking the longest geographic edge of our bounding
    box and dividing it by the number of pixels of this edge in the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be calculated by first computing the scale of the `width`, then the
    scale of the `height`, and, finally, taking the larger of the two. All of the
    logic is compressed into the single line given earlier. The three steps are explained
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ad83fa4-dff7-4993-a1ed-f0ff938b4805.png)'
  prefs: []
  type: TYPE_IMG
- en: The `95` value adjusts the scale because we are giving the map a bit of a breather
    at the edges in order to not have the paths intersect the edges of the SVG container
    item, basically reducing the scale by 5%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have an accurate scale of our map, given our set `width` and `height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in [Chapter 2](029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml), *Creating
    Images from Simple Text*, when we scale in SVG, it scales all the attributes (even
    *x* and *y*). In order to return the map to the center of the screen, we will
    use the `translate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `translate()` function receives an array with two parameters: the amount
    to translate in *x*, and the amount to translate in *y*. We will calculate *x*
    by finding the center *(topRight - topLeft)/2* and multiplying it by the scale.
    The result is then subtracted from the width of the SVG element.'
  prefs: []
  type: TYPE_NORMAL
- en: Our *y* translation is calculated similarly but using the *bottomRight - bottomLeft*
    values divided by 2, multiplied by the scale, then subtracted from the `height`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will reset the projection to use our new scale and translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will create a map variable that will group all of the following SVG
    elements into a `<g>` SVG tag. This will allow us to apply styles and better contain
    all of the proceeding paths'' elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are back to the classic D3 enter, update, and exit pattern. We
    have our data, the list of Mexico states, and we will join this data to the `path`
    SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Enter` section and the corresponding `path` functions are executed on every
    data element in the array. As a refresher, each element in the array represents
    a state in Mexico. The `path` function has been set up to correctly draw the outline
    of each state, as well as scale and translate it to fit in our SVG container.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have created your first map!
  prefs: []
  type: TYPE_NORMAL
- en: Experiment 1 – adjusting the bounding box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our foundation, let's start with our first experiment. For
    this experiment, we will manually zoom into a state of Mexico using what we learned
    in the previous section. The code can be found in `example-2.html` (`http://localhost:8080/chapter-4/example-2.html`);
    however, feel free to edit `example-1.html` to learn as you go.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this experiment, we will modify one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are telling the calculation to create a boundary based on the sixth
    element of the `features` array instead of every state in the country of Mexico.
    The boundaries data will now run through the rest of the scaling and translation
    algorithms to adjust the map to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7f20bfe-f9a6-4c5e-895a-60d03c6088a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have basically reduced the min/max of the boundary box to include the geographic
    coordinates for one state in Mexico (see the next screenshot), and D3 has scaled
    and translated this information for us automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4bc88ba-d830-4e64-ba46-31ae0abb8659.png)'
  prefs: []
  type: TYPE_IMG
- en: This can be very useful in situations where you might not have the data that
    you need in isolation from the surrounding areas. Hence, you can always zoom into
    your geography of interest and isolate it from the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment 2 – creating choropleths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common uses of D3.js maps is to make choropleths. This visualization
    gives you the ability to discern between regions, giving them a different color.
    Normally, this color is associated with some other value, for instance, levels
    of influenza or a company''s sales. The Choropleths are very easy to make in D3.js.
    In this experiment, we will create a quick choropleth based on the index value
    of the state in the array of all the states. Look at the following code, or use
    your browser and go here: `http://localhost:8080/chapter-4/example-3.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will only need to modify two lines of code in the `Update` section of our
    D3 code. Right after the `enter()` section, add the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `color` variable uses another valuable D3 function named `scale`. Scales
    are extremely powerful when creating visualizations in D3; much more detail on
    scales can be found at: [https://github.com/d3/d3/blob/master/API.md#scales-d3-scale](https://github.com/d3/d3/blob/master/API.md#scales-d3-scale).'
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's describe what this scale defines. Here, we created a new function
    called `color()`. This `color()` function looks for any number between `0` and
    `33` in an input domain. D3 linearly maps these input values to a color between
    red and yellow in the output range. D3 has included the capability to automatically
    map colors in a linear range to a gradient. This means that executing the new
    function, `color`, with `0` will return the color red, `color(15)` will return
    an orange color, and `color(33)` will return yellow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small table just for visual reference. It shows the color and its
    respective RGB value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82b7470e-4f6c-4bf4-a367-af9ce75323bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, in the update section, we will set the `fill` property of the path to the
    new `color()` function. This will provide a linear scale of colors and use the
    index value `i` to determine what color should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the color was determined by a different value of the datum, for instance `d.scales`,
    then you would have a choropleth where the colors actually represent sales. The
    preceding code should render something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d651273d-477a-41be-b137-488f9d9bb65d.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment 3 – adding click events to our visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen how to make a map and set different colors to the different regions
    of this map. Next, we will add a little bit of interactivity. This will illustrate
    a simple reference to bind click events to maps. For this experiment, we will
    build on the previous exercise, `example-3.html`. You can see the completed experiment
    at: `http://localhost:8080/chapter-4/example-4.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a quick reference to each state in the country. To accomplish
    this, we will create a new function called `geoID` right below the `mexico` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function takes in a `state` data element and generates a new selectable
    ID based on the `ID_1` property found in the data. The `ID_1` property contains
    a unique numeric value for every state in the array. If we insert this as an `id`
    attribute into the DOM, then we would create a quick and easy way to select each
    state in the country.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `geoID()` function, creating another function called `click`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method makes it easy to separate what the `click` is doing. The `click`
    method receives the datum and changes the fill opacity value of all the states
    to `0.2`. This is done so that when you click on one state and then on the other,
    the previous state does not maintain the *clicked* style. Notice that the function
    call is iterating through all the elements of the DOM using the D3 update pattern.
    After making all the states transparent, we will set a fill opacity of `1` for
    the given clicked item. This removes all the transparent styling from the selected
    state. Notice that we are reusing the `geoID()` function that we created earlier
    to quickly find the state element in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s update the `enter()` method to bind our new `click` method to
    every new DOM element that `enter()` appends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We also added an attribute called `id`; this inserts the results of the `geoID()`
    function into the `id` attribute. Again, this makes it very easy to find the clicked
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code base should produce a map as follows. Check it out and make sure that
    you click on any of the states. You will see its color turn a little brighter
    than the surrounding states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54243b10-e8eb-4950-b0ed-c572707fd5bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment 4 – using updates and transitions to enhance our visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our next experiment, we will take all of our combined knowledge and add
    some smooth transitions to the map. Transitions are a fantastic way to add style
    and smoothness to data changes.
  prefs: []
  type: TYPE_NORMAL
- en: This experiment will, again, require us to start with `example-3.html`. The
    complete experiment can be viewed at `http://localhost:8080/chapter-4/example-5.html`.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, we leveraged the JavaScript `setInterval()` function to execute
    updates at a regular timed frequency. We will go back to this method now to assign
    a random number between 1 and 33 to our existing `color()` function. We will then
    leverage a D3 method to smoothly transition between the random color changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right below the update section, add the following `setInterval()` block of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method indicates that, for every `2000` milliseconds (2 seconds), the `map`
    update section should be executed and the color set to a random number between
    `1` and `32`. The new `transition` and `duration` methods transition from the
    previous state to the new state over `500` milliseconds. Open `example-5.html`
    in your browser and you should see the initial color based on the index of the
    state. After 2 seconds, the colors should smoothly transition to new values.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment 5 – adding points of interest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything we have done has involved working directly with the geographic
    data and map. However, there are many cases where you will need to layer additional
    data on top of the map. We will begin slowly by first adding a few cities of interest
    to the map of Mexico.
  prefs: []
  type: TYPE_NORMAL
- en: 'This experiment will, again, require us to start with `example-3.html`. The
    complete experiment can be viewed at: `http://localhost:8080/chapter-4/example-6.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this experiment, we will add a `text` element to the page to identify the
    city. To make the text more visually appealing, we will first add some simple
    styling in the `<style>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need some data that will indicate the city name, the latitude, and
    longitude coordinates. For the sake of simplicity, we have added a file with a
    few starter cities. The file called `cities.csv` is in the same directory as the
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a few lines of code to bring in the data and plot the city locations
    and names on your map. Add the following block of code right below the exit section
    (if you are starting with `example-2.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's review what we just added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `d3.csv` function will make an AJAX call to our data file and automatically
    format the entire file into an array of JSON objects. Each property of the object
    will take on the corresponding name of the column in the `.csv` file. For example,
    take a look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define two variables to hold our data join to the circle and text the
    SVG elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will execute a typical enter pattern to place the points as circles
    and the names as text SVG tags on the map. The *x* and *y* coordinates are determined
    by calling our previous `projection()` function with the corresponding latitude
    and longitude coordinates from the data file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `projection()` function returns an array of *x* and *y* coordinates
    (*x, y*). The *x* coordinate is determined by taking the `0` index of the returned
    array. The *y* coordinate is determined from the index, `1`. For example, take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `[0]` indicates the *x* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your new map should look like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26281754-34bd-4a14-9183-4822e7b289af.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment 6 – adding visualizations as a point of interest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our final experiment, we will layer visualizations on top of visualizations!
    Starting from where we left off at `http://localhost:8080/chapter-4/example-6.html`,
    we will add a fictitious column to the data to indicate a metric of tequila consumption
    (the final version can be seen at `http://localhost:8080/chapter-4/example-7.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With just two more lines of code, we can have the city points portray meaning.
    In this experiment, we will scale the radius of the city circles in relation to
    the amount of tequila consumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will introduce a new scale that linearly distributes the input values
    from `1` to `100` to a radius length between `5` and `30`. This means that the
    minimum radius of a circle will be `5` and the maximum will be `30`, preventing
    the circles from growing too large or too small to be readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will change the preceding line of code to call the `radius` function
    instead of the hardcoded value of `4`. The code will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After these two small additions, your map should look like the one shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e4296a3-1638-4667-9d41-64816815a38f.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned how to build many different kinds of maps that cover different kinds
    of needs. The choropleths and data visualizations of maps are some of the most
    common geographic-based data representations that you will come across. We also
    added interactivity to our map through basic transitions and events. You will
    easily realize that, with all the information you've gathered so far, you can
    independently create engaging map visualizations. You can expand your knowledge
    by learning advanced interactivity techniques in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Hang on tight!
  prefs: []
  type: TYPE_NORMAL
