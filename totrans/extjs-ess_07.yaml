- en: Chapter 7. Constructing Common UI Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest features that draws developers to Ext JS is the vast array
    of UI widgets available out of the box. The ease with which they can be integrated
    with each other and the attractive and consistent visuals each of them offers
    is also a big attraction. No other framework can compete on this front, and this
    is a huge reason Ext JS leads the field of large-scale web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how UI widgets fit into the framework's structure,
    how they interact with each other, and how we can retrieve and reference them.
    We will then delve under the surface and investigate the lifecycle of a component
    and the stages it will go through during the lifetime of an application. Finally,
    we will add the first UI components to our BizDash application in the form of
    data grids, trees, data views, and forms.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a UI widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every UI element in Ext JS extends from the base component class `Ext.Component`.
    This class is responsible for rendering UI elements to the HTML document. They
    are generally sized and positioned by layouts used by their parent components
    and participate in the automatic component lifecycle process.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine an instance of `Ext.Component` as a single section of the user
    interface in a similar way that you might think of a DOM element when building
    traditional web interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Each subclass of `Ext.Component` builds upon this simple fact and is responsible
    for generating more complex HTML structures or combining multiple Ext.Components
    to create a more complex interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`Ext.Component` classes, however, can''t contain other Ext.Components. To combine
    components, one must use the `Ext.container.Container` class, which itself extends
    from `Ext.Component`. This class allows multiple components to be rendered inside
    it and have their size and positioning managed by the framework''s layout classes
    (see [Chapter 6](ch06.html "Chapter 6. Combining UI Widgets into the Perfect Layout"),
    *Combining UI Widgets into the Perfect Layout*, for more details).'
  prefs: []
  type: TYPE_NORMAL
- en: Components and HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating and manipulating UIs using components requires a slightly different
    way of thinking than you may be used to when creating interactive websites with
    libraries such as jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: The `Ext.Component` class provides a layer of abstraction from the underlying
    HTML and allows us to encapsulate additional logic to build and manipulate this
    HTML. This concept is different from the way other libraries allow you to manipulate
    UI elements and provides a hurdle for new developers to get over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Ext.Component` class generates HTML for us, which we rarely need to interact
    with directly; instead, we manipulate the configuration and properties of the
    component. The following code and screenshot show the HTML generated by a simple
    `Ext.Component` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Components and HTML](img/3717_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a simple `<DIV>` tag is created, which is given some CSS classes
    and an autogenerated ID, and has the HTML config displayed inside it.
  prefs: []
  type: TYPE_NORMAL
- en: This generated HTML is created and managed by the `Ext.dom.Element` class, which
    wraps a DOM element and its children, offering us numerous helper methods to interrogate
    and manipulate it. After it is rendered, each `Ext.Component` instance has the
    element instance stored in its `el` property. You can then use this property to
    manipulate the underlying HTML that represents the component.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the `el` property won't be populated until the component
    has been rendered to the DOM. You should put logic dependent on altering the raw
    HTML of the component in an `afterrender` event listener or override the `afterRender`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how you can manipulate the underlying HTML once
    the component has been rendered. It will set the background color of the element
    to red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that digging into and updating the HTML and CSS
    that Ext JS creates for you is a dangerous game to play and can result in unexpected
    results when the framework tries to update things itself. There is usually a *framework
    way* to achieve the manipulations you want to include, which we recommend you
    use first.
  prefs: []
  type: TYPE_NORMAL
- en: We always advise new developers to try not to fight the framework too much when
    starting out. Instead, we encourage them to follow its conventions and patterns,
    rather than having to wrestle it to do things in the way they may have previously
    done when developing traditional websites and web apps.
  prefs: []
  type: TYPE_NORMAL
- en: The component lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a component is created, it follows a lifecycle process that is important
    to understand, so as to have an awareness of the order in which things happen.
    By understanding this sequence of events, you will have a much better idea of
    where your logic will fit and ensure you have control over your components at
    the right points.
  prefs: []
  type: TYPE_NORMAL
- en: The creation lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following process is followed when a new component is instantiated and rendered
    to the document by adding it to an existing container. When a component is shown
    explicitly (for example, without adding to a parent, such as a floating component)
    some additional steps are included. These have been denoted with a * in the following
    process.
  prefs: []
  type: TYPE_NORMAL
- en: constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, the class' constructor function is executed, which triggers all of the
    other steps in turn. By overriding this function, we can add any setup code required
    for the component.
  prefs: []
  type: TYPE_NORMAL
- en: Config options processed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing to be handled is the config options that are present in the class
    (see [Chapter 2](ch02.html "Chapter 2. Mastering the Framework's Building Blocks"),
    *Mastering the Framework's Building Blocks*, for details). This involves each
    option's `apply` and `update` methods being called, if they exist, meaning the
    values are available via the getter from now onwards.
  prefs: []
  type: TYPE_NORMAL
- en: initComponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `initComponent` method is now called and is generally used to apply configurations
    to the class and perform any initialization logic.
  prefs: []
  type: TYPE_NORMAL
- en: render
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once added to a container, or when the `show` method is called, the component
    is rendered to the document.
  prefs: []
  type: TYPE_NORMAL
- en: boxready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this stage, the component is rendered and has been laid out by its parent's
    layout class, and is ready at its initial size. This event will only happen once
    on the component's first layout.
  prefs: []
  type: TYPE_NORMAL
- en: activate (*)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the component is a floating item, then the activate event will fire, showing
    that the component is the active one on the screen. This will also fire when the
    component is brought back to focus, for example, in a **Tab** panel when a tab
    is selected.
  prefs: []
  type: TYPE_NORMAL
- en: show (*)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the previous step, the show event will fire when the component is
    finally visible on screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![show (*)](img/3717_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The destruction process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are removing a component from the Viewport and want to destroy it, it
    will follow a destruction sequence that we can use to ensure things are cleaned
    up sufficiently, so as to avoid memory leaks and so on. The framework takes care
    of the majority of this cleanup for us, but it is important that we tidy up any
    additional things we instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: hide (*)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a component is manually hidden (using the hide method), this event will
    fire and any additional hide logic can be included here.
  prefs: []
  type: TYPE_NORMAL
- en: deactivate (*)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the activate step, this is fired when the component becomes inactive.
    As with the activate step, this will happen when floating and nested components
    are hidden and are no longer the items under focus.
  prefs: []
  type: TYPE_NORMAL
- en: destroy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the final step in the teardown process and is implemented when the component
    and its internal properties and objects are cleaned up. At this stage, it is best
    to remove event handlers, destroy subclasses, and ensure any other references
    are released.
  prefs: []
  type: TYPE_NORMAL
- en: '![destroy](img/3717_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Component Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ext JS boasts a powerful system to retrieve references to components called
    Component Queries. This is a CSS/XPath style query syntax that lets us target
    broad sets or specific components within our application. For example, within
    our controller, we may want to find a button with the text "Save" within a component
    of type MyForm.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will demonstrate the Component Query syntax and how it can
    be used to select components. We will also go into details about how it can be
    used within `Ext.container.Container` classes to scope selections.
  prefs: []
  type: TYPE_NORMAL
- en: xtypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive in, it is important to understand the concept of xtypes in Ext
    JS. An xtype is a shorthand name for an `Ext.Component` that allows us to identify
    its declarative component configuration objects. For example, we can create a
    new `Ext.Component` as a child of an `Ext.container.Container` using an xtype
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using xtypes allows you to lazily instantiate components when required, rather
    than having them all created upfront.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common component xtypes include:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Classes | xtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Ext.tab.Panel` | `tabpanel` |'
  prefs: []
  type: TYPE_TB
- en: '| `Ext.container.Container` | `container` |'
  prefs: []
  type: TYPE_TB
- en: '| `Ext.grid.Panel` | `gridpanel` |'
  prefs: []
  type: TYPE_TB
- en: '| `Ext.Button` | `button` |'
  prefs: []
  type: TYPE_TB
- en: xtypes form the basis of our Component Query syntax in the same way that element
    types (for example, `div`, `p`, `span`, and so on) do for CSS selectors. We will
    use these heavily in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: Sample component structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the following sample component structure—a panel with a child tab
    panel, form, and buttons—to perform our example queries on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Queries with Ext.ComponentQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Ext.ComponentQuery` class is used to perform Component Queries, with the
    `query` method primarily used. This method accepts two parameters: a query string
    and an optional `Ext.container.Container` instance to use as the root of the selection
    (that is, only components below this one in the hierarchy will be returned). The
    method will return an array of components or an empty array if none are found.'
  prefs: []
  type: TYPE_NORMAL
- en: We will work through a number of scenarios and use Component Queries to find
    a specific set of components.
  prefs: []
  type: TYPE_NORMAL
- en: Finding components based on xtype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen, we use xtypes like element types in CSS selectors. We can
    select all the `Ext.panel.Panel` instances using its xtype—`panel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add the concept of hierarchy by including a second xtype separated
    by a space. The following code will select all `Ext.Button` instances that are
    descendants (at any level) of an `Ext.panel.Panel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We could also use the `>` character to limit it to buttons that are direct descendants
    of a `panel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finding components based on attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is simple to select a component based on the value of a property. We use
    the XPath syntax to specify the attribute and the value. The following code will
    select buttons with an action attribute of `saveUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finding components based on itemIds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ItemIds are commonly used to retrieve components, and they are specially optimized
    for performance within the `ComponentQuery` class. They should be unique only
    within their parent container and not globally unique like the `id` config. To
    select a component based on itemId, we prefix the itemId with a `#` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finding components based on member functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also possible to identify matching components based on the result of
    a function of that component. For example, we can select all text fields whose
    values are valid (that is, when a call to the `isValid` method returns `true`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Scoped Component Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of our previous examples will search the entire component tree to find matches,
    but often we may want to keep our searches local to a specific container and its
    descendants. This can help reduce the complexity of the query and improve the
    performance, as fewer components have to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ext.Containers have three handy methods to do this: `up`, `down`, and `query`.
    We will take each of these in turn and explain their features.'
  prefs: []
  type: TYPE_NORMAL
- en: up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method accepts a selector and will traverse up the hierarchy to find a
    single matching parent component. This can be useful to find the grid panel that
    a button belongs to, so an action can be taken on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: down
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns the first descendant component that matches the given selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `query` method performs much like `Ext.ComponentQuery.query` but is automatically
    scoped to the current container. This means that it will search all descendant
    components of the current container and return all matching ones as an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Hierarchical data with trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know and understand components, their lifecycle, and how to retrieve
    references to them, we will move on to more specific UI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The tree panel component allows us to display hierarchical data in a way that
    reflects the data's structure and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we are going to use a tree panel to represent our navigation
    structure to allow users to see how the different areas of the app are linked
    and structured.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to a data source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like all other data-bound components, tree panels must be bound to a data store—in
    this particular case it must be an `Ext.data.TreeStore` instance or subclass,
    as it takes advantage of the extra features added to this specialist store class.
  prefs: []
  type: TYPE_NORMAL
- en: We will make use of the `BizDash.store.Navigation` TreeStore we created in [Chapter
    5](ch05.html "Chapter 5. Modeling Data Structures for Your UI"), *Modeling Data
    Structures for Your UI*, to bind to our tree panel.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a tree panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tree panel is defined in the `Ext.tree.Panel` class (which has an xtype
    of `treepanel`), which we will extend to create a custom class called `BizDash.view.navigation.NavigationTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We configure the tree to be bound to our TreeStore by using its storeId, in
    this case, Navigation.
  prefs: []
  type: TYPE_NORMAL
- en: A tree panel is a subclass of the `Ext.panel.Table` class (similar to the `Ext.grid.Panel`
    class), which means it must have a columns configuration present. This tells the
    component what values to display as part of the tree. In a simple, *traditional*
    tree, we might only have one column showing the item and its children; however,
    we can define multiple columns and display additional fields in each row. This
    would be useful if we were displaying, for example, files and folders and wanted
    to have additional columns to display the file type and file size of each item.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are only going to have one column, displaying the Label field.
    We do this by using the `treecolumn` xtype, which is responsible for rendering
    the tree's navigation elements. Without defining `treecolumn`, the component won't
    display correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `treecolumn` xtype''s configuration allows us to define which of the attached
    data model''s fields to use (`dataIndex`), the column''s header text (`text`),
    and the fact that the column should fill the horizontal space (flex: see the *Using
    the VBox layout* and *Using the HBox layout* sections in [Chapter 6](ch06.html
    "Chapter 6. Combining UI Widgets into the Perfect Layout"), *Combining UI Widgets
    into the Perfect Layout*, for more details on this concept).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we set the `rootVisible` to `false`, so the data's root is hidden,
    as it has no real meaning other than holding the rest of the data together. Finally,
    we set `useArrows` to `true`, so the items with children use an arrow instead
    of the +/- icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a tree panel](img/3717_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying tabular data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The grid component is one of the biggest reasons Ext JS is selected by developers.
    Its performance, features, and flexibility make it a powerful feature. In this
    section, we will work through an example of creating a grid to display our product
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Product data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into creating a grid component, we must create a data store
    that will hold the product data that our grid will display. In [Chapter 5](ch05.html
    "Chapter 5. Modeling Data Structures for Your UI"), *Modeling Data Structures
    for Your UI*, we defined the models that represent our product data, but we didn''t
    create a products store to hold a collection of product model instances. To do
    this, we create a new file called `Products.js` in the `store` folder of our project
    with the following class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple store definition with the only new configuration being the
    `autoLoad: true` setting, which will perform a load using the defined proxy as
    soon as the store is instantiated. In order to have this store automatically instantiated,
    we include it in the `stores` config of the `Application.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `products.json` file contains some simple product data, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Product grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a grid, we use the `Ext.grid.Panel` component which extends from the
    `Ext.panel.Panel` class and so can be used in the same way as a simple panel (for
    example, it can have docked items, be given dimensions, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define our product grid in a file called `ProductGrid.js` inside a
    new folder called `product` under the project''s view folder. We give it a basic
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You will recognize the `Ext.define` structure as the same as we have used throughout
    the book with the class name and parent class defined. The `xtype` config lets
    us define a string that can be used when lazily instantiating the product grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The grid component has only two required configurations which we have included
    in the previous example: a store containing the data to be displayed and an array
    of columns which define what data is shown.'
  prefs: []
  type: TYPE_NORMAL
- en: The store can be an actual store reference or a storeId that will be used to
    look up the store instance—in this case the products store we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Our columns definition contains an array of configuration objects that will
    be used to instantiate `Ext.grid.column.Column` classes (or subclasses thereof,
    for example, Date, Template, Number, and so on). The `text` property will define
    the column's header text and the `dataIndex` is the field to map to within the
    store's records. In our example, we have opted to display all the products' fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can include the new `ProductGrid` in our application and see it
    in action. We must first require the new component in the `views` array of `Application.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the xtype in the Main view''s items collection, placing it
    in the center region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Reloading our application should show a grid with three rows of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Product grid](img/3717_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Customizing column displays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our grid simply displays the data values as they are held in the model,
    which is fine for simple values but some data would benefit from more advanced
    formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways of achieving the same effect when it comes to formatting
    column values. We will cover the two main options: column renderers and template
    columns.'
  prefs: []
  type: TYPE_NORMAL
- en: Column renderers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start by adding a bit of color to our grid by customizing the styling
    of the **Quantity** column when it starts to get low. We will make the figures
    red when they drop to 3 or below, and orange when between 7 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'A column `renderer` is a function that allows us to manipulate the data value
    (without affecting the underlying stored value) before it is displayed. We add
    the `renderer` property to the column definition and give it a function with the
    following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**value**: The value of the bound model field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**metaData**: Additional attributes of the cell being rendered, for example,
    `tdCls`, `tdAttr`, and `tdStyle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**record**: The record for the current row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rowIndex**: The index of the current row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**colIndex**: The index of the current column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**store**: The store that is bound to the grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**view**: The grid view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The renderer function should return a string that will then be displayed in
    the cell. The following code shows our `renderer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Column renderers](img/3717_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Template columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, there are various other column types that offer additional
    features. The template column allows us to define an `Ext.XTemplate` that is merged
    with the row's record. This is particularly useful if we want to include more
    complex HTML in the cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows how we can include the `StockValue` field besides the
    `Price`. We start by adding an `xtype: ''templatecolumn''` property to the column
    definition and then by defining a `tpl` string which will be converted into an
    `Ext.XTemplate` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Template columns](img/3717_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Grid widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rendering complex components in grids has long been a desire of Ext JS developers
    and has now been made much easier with the introduction of grid widgets. These
    are components that are rendered inside grid cells and bound to a model field.
    Examples of grid widgets are buttons, mini graphs, form fields, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a simple button widget to our grid to allow each product''s
    details to be viewed. We start by adding a new `widgetcolumn` to our grid''s column
    array. The widget option defines the kind of widget displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will render a button on each row that we can then hook up to a click event
    to open up a product details view (see the next section for further details on
    doing this).
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid widgets](img/3717_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can hook into the widget''s events using the `listeners` config as we would
    if we were using the component anywhere else in our application. The following
    snippet shows how to attach a simple `click` handler to the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Inputting data with forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key aspect of web applications is forms. Being able to input data into our
    system is imperative, and as such, Ext JS has form components to suit all types
    of input that can be easily bound to our data models and related views.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will expand on our product grid and allow users to edit
    products through a simple form.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define our product form as we would any other view—by creating a file (in
    this case named view/product/ProductForm.js) and calling `Ext.define` within it.
    We extend the `Ext.form.Panel` class and give it an xtype of product—`ProductForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our form, we want to have input fields for the product''s name, description,
    quantity, and price. There are numerous specific `form` field types we can use
    to suit most data types: `text`, `number`, `textarea`, `combobox`, `time`, `file`,
    `date`, `html`, and more. Check out the `Ext.form.field.*` namespace for all the
    possibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make use of the `text`, `textarea`, and `number` fields for our form.
    We configure each using their xtypes and `fieldLabel`. Additionally, we will give
    our `textarea` an explicit height and tell our `Price` field that it can have
    a `decimalPrecision` of `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have our input fields ready we will also add two buttons: `Save` and
    `Cancel`. We use the `bbar` config, which is a shortcut to adding a bottom docked
    toolbar, and define two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Displaying our form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to open our form when a user clicks the **Details** button beside a
    product in the grid and we want it to be pre-populated with that product's information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a ViewController called `product.ProductGridController`,
    which will be attached to the `ProductGrid` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This class extends the `Ext.app.ViewController` class and we give it an alias
    of `ProductGrid`. We use this alias to tie it back to our `ProductGrid` view by
    adding `controller: ''ProductGrid''` to the `ProductGrid` class.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now use `ProductGridController` to listen for a click on the **Details**
    button and create and show our `ProductForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The click handler we added to the **Details** button in the previous section
    must be replaced with the name of the ViewController method that we want to execute
    when that event happens. We will call this `onDetailsClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onDetailsClick` method of ViewController will instantiate a `ProductForm`
    instance, with some extra configuration to size and float it above the existing
    UI, and then show it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If we run our app, we will see the form display as a modal window above our
    grid.
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying our form](img/3717_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Populating our form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, our product form is displayed but it isn't populated with the
    details of the product we clicked on. To do this, we must bind each of the form
    fields to the product model via a `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a `ProductFormModel` class with a very simple configuration.
    The class extends the `Ext.app.ViewModel` class and is given an alias of `ProductForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define the `data` property, which holds the data to be bound, with
    a `rec` property which will be a reference to the product model instance we want
    to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is then tied to our `ProductForm` class with its alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that these two are tied together, we can make use of the `bind` option
    of each form field to tell the framework to populate the field with a value from
    this `ViewModel`. We can also do this with the form''s title property, so it displays
    the product name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The final piece of the puzzle is to give the `ViewModel` a reference to the
    correct product model instance. We do this in the `onDetailsClick` method of `ProductGridController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we open the form, the fields will be prepopulated. You will also notice
    that when you edit the product name, for example, the grid and form title will
    automatically update in real time. Pretty clever.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, our `Save` and `Cancel` buttons don't do anything, so let's hook
    them up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining what happens when the buttons are clicked. We use the
    same pattern as we did with the product grid''s `Details` button and assign the
    click event a method name which correlates to a method in the ViewController:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must create a ViewController called `ProductFormController`. Just like
    we did with `ProductGrid`, we have to tell the view that the ViewController exists
    by adding `controller: ''ProductFormController''`. The ViewModel and ViewControllers
    must also be *required* by the view, so they are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inside the ViewController's handlers, we use the `getView` method to retrieve
    a reference to the form, so we can act on it. The `onSave` method will retrieve
    a reference to the product record (via the ViewModel) and commit it (alternatively,
    if you have a proper backend setup, you would call the `save` method). The `onCancel`
    method calls the `reject` method on the product model, so any changes that have
    been made are reverted. Both methods will then close the form and destroy it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Data-bound views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to display data sets in trees and grids, but what if
    we want a bit more flexibility in how things are displayed?
  prefs: []
  type: TYPE_NORMAL
- en: Data views give us this freedom and allow us to define custom HTML to be displayed
    for each item in the dataset but while retaining the powerful automatic binding
    setup. We can then apply our own custom CSS to this HTML to style it as we want.
  prefs: []
  type: TYPE_NORMAL
- en: We will work through an example where we create a data view for the users in
    our system.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our users' data view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, we create a new view class—`BizDash.view.user.UsersView`—extending
    the base framework class `Ext.view.View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A data view requires three properties to function fully: a `store`, a `tpl`,
    and an `itemSelector`.'
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In exactly the same way as the grid and tree we've looked at previously, this
    is the data source that the component will be bound to. Any changes made to this
    store or its records will automatically be reflected in the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this instance, we will use the users store and will configure it using the
    `storeId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A data view is based on the concept of rendering a piece of HTML for each record
    in the bound data store. The `tpl` config defines `Ext.XTemplate` that will be
    merged with a record to produce that piece of HTML. Without this, nothing will
    be rendered to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to display each user''s name, role, and photo. We define the data view
    with the following template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We start by using the `tpl` markup tag along with the `for` attribute. This
    tells the template to loop over the array it is given and merge the HTML within
    it with each record in turn. We mark data placeholders, whose names match the
    model's field names, using the `{{...}}` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Item selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, for our view component to know how to identify a single record's HTML,
    we must give it a CSS selector that can identify a single node. This is used to
    allow events to be raised on individual items (for example, click, double-click,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have given the wrapper div the `user-item` class, which we can use as the
    unique selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Styling the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you show our data view, it will look a bit poor, so we need to include some
    styling to make it pretty.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by creating a `.scss` file called `UsersView.scss` within the `sass/src`
    folder and mirroring the view folders structure, so the SASS is automatically
    picked up. In this case, we create it in `sass/src/view/user/UsersView.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Following a `sencha app build` command and a refresh, you should see a nicer-styled
    data view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling the view](img/3717_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learnt how Ext JS' components fit together and the
    lifecycle that they follow when created and destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then moved on to utilizing some of the most popular and useful components.
    We have explored the details of the following components within our BizDash application:'
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to explaining the main features and configuration options of these
    components, we linked them together within a simple MVVM architecture, taking
    advantage of two-way data binding and event listening.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce Ext JS themes and how they can be customized
    to make your application unique.
  prefs: []
  type: TYPE_NORMAL
