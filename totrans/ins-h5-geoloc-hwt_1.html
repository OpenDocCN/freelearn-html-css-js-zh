<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Instant HTML5 Geolocation How-to</h1></div></div></div><p>Welcome to <em>Instant HTML 5 Geolocation How-to</em>. This guide will help you make any web application aware of a user's location, quickly and easily. You will learn how to map a user's geographic location, integrate it with popular mapping platforms, and track the user over time. In the process, you will create a simple application that generates a KML file containing both a path and points that you choose to save along that path (which can then be imported into Google Maps).</p><p>The iPhone changed the way we use the web. It was the first mobile device that included web browsing as a primary function. Suddenly, with mobile data and a phone like the iPhone, the web could be in your pocket, wherever you went. Through HTML5 and APIs, web applications could be truly context sensitive; they could know where you were, if you wanted them to react accordingly.</p><p>The Geolocation API is not part of HTML5, and is, instead, a JavaScript API standard. However, it sits alongside the evolving HTML5 specification as an important part of any modern web development toolkit.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding the Geolocation API (Simple)</h1></div></div></div><p>At its core, the Geolocation API is a series of simple JavaScript calls that retrieve the following aspects of the user's location:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Latitude and longitude</li><li class="listitem" style="list-style-type: disc">Altitude</li><li class="listitem" style="list-style-type: disc">The accuracy of the latitude and longitude</li><li class="listitem" style="list-style-type: disc">The accuracy of the altitude information</li><li class="listitem" style="list-style-type: disc">Heading</li><li class="listitem" style="list-style-type: disc">Speed</li></ul></div><p>It's worth noting that because of the aforementioned differences in technical capabilities, not all of these values are always available, even when the Geolocation API is working perfectly. For example, a laptop does not know what its altitude is. This is because it determines location in a different way, for example, to a smartphone with GPS access. These differences are discussed in the next section.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>How to do it...</h2></div></div></div><p>The web can be accessed from different types of hardware, such as desktop computers, laptops, tablets, phones, and embedded systems.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>The <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) finalizes specifications in such a way that the web continues to support each of these platforms. Your operating system, Internet service provider, device type, and location all should not matter; the web is universal.</p></div></div><p>All of this means that the web may be the most important publishing medium in the history of human civilization—a medium that anyone can publish to and consume. However, because each device has slightly different capabilities, each feature may have slightly different characteristics from user to user. For example, in HTML5, some web browsers can play certain video formats, while other web browsers can play other video formats. In the Geolocation API, these changes relate to how location is computed, and as a result, how accurate it is.</p><p>Here's how the Geolocation API works from the user's perspective. You can see it in action by visiting my demo at <a class="ulink" href="http://benwerd.com/lab/geo.php">http://benwerd.com/lab/geo.php</a>.</p><div><ol class="orderedlist arabic"><li class="listitem">Visit an application or website that requires location information.</li><li class="listitem">The application attempts to determine your location with the Geolocation API.</li><li class="listitem">The browser asks you whether you want to reveal the location to the application.</li><li class="listitem">If you consent to sharing your location, your location is determined using available hardware and software, and sent to the application.</li><li class="listitem">If you do not consent to sharing your location, no location information is sent to the application, and it is notified that no location information will be sent.</li></ol></div><p>Your application needs the Geolocation API if:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You want to adjust the application's functionality based on the user's location</li><li class="listitem" style="list-style-type: disc">You want to adjust a site's content or redirect the user based on his/her location</li><li class="listitem" style="list-style-type: disc">You want to empower the user to track his/her location over time</li></ul></div><p>Your application cannot use the Geolocation API if:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You want to track the user without his/her explicit consent</li><li class="listitem" style="list-style-type: disc">You need real-time, extremely accurate location information</li></ul></div><p>We will discuss why in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How it works...</h2></div></div></div><p>The request for information is an important step to protect user privacy. The Geolocation API specification explicitly states, "User Agents must not send location information to Web sites without the express permission of the user." It's sadly true that the user's location can often still be determined without his/her consent through other means, such as IP geolocation or by sharing data between applications. However, these are unrelated to the Geolocation API, and we will not be discussing them here.</p><p>Here's what a location request looks like when using Google Chrome on my MacBook Pro using a home broadband Internet connection:</p><div><img src="img/5903_1_1.jpg" alt="How it works..."/></div><p>Note the ribbon above the main web page content. The entire content of the page has been sent to the browser; once location information has been sent, JavaScript could change the content of the page (for example, using the jQuery framework), submit the content elsewhere using a callback, or forward the browser to another page.</p><p>Here's what it looks like in the Android Chrome browser:</p><div><img src="img/5903_1_2.jpg" alt="How it works..."/></div><p>You can test your browser's geolocation capabilities by visiting <a class="ulink" href="http://benwerd.com/lab/geo.php">http://benwerd.com/lab/geo.php</a>.</p><p>Here's what it looks like when using Google Chrome on my MacBook Pro using cable Internet:</p><div><img src="img/5903_1_3.jpg" alt="How it works..."/></div><p>Here you can see that although my latitude and longitude have been calculated reasonably accurately, my altitude, heading, and speed details are not available. This is because these details are determined using <strong>GPS</strong> (<strong>Global Positioning System</strong>) technology, and my laptop does not have this capability. Instead, my web browser needs to guess my location based on various environmental factors.</p><p>Here's what the same Geolocation API test looks like on my Android Chrome browser on my cell phone:</p><div><img src="img/5903_1_4.jpg" alt="How it works..."/></div><p>You might be surprised to see that my altitude, heading, and speed information is still not present, despite having been determined on a cellphone that has hardware GPS support. In fact, this is because (if you use the default Geolocation API configuration) Chrome on Android attempts to use WiFi location first, where it's available, before resorting to the relatively battery-intensive (but more accurate) GPS location. </p><p>Here's what the test page looks like on an iPad:</p><div><img src="img/5903_1_5.jpg" alt="How it works..."/></div><p>Because the iPad did use GPS data to determine my location, altitude information is available. However, I wasn't moving, so there's no speed or heading information.</p><p>Only latitude, longitude, and accuracy are guaranteed to be there. The other fields are entirely dependent on the user's device, movement, and location context.</p><p>Where GPS is not available, the browser will use a process called trilateration to determine the location.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Trilateration looks at environmental factors such as available wireless networks and their relative signal strengths, proximity to cellphone towers, and current network IP address, and matches them against a remote database of environmental factors against known locations. For most browsers, this database turns out to be run by Google, but some providers use a solution from Skyhook Wireless, and there are others too. Apple maintains its own database for its products, for example, which have probably been crowdsourced from consumer iPhone and iPad usage. Database information could also have been gathered from special cars, such as those used to take photographs for Google StreetView, and other crowdsourcing techniques. It's important to note that the user's location is being sent to a third party in these instances, and that the returned location will only be as good as the service's database. How this location is determined is not part of the Geolocation API specification; all that is required for you to know is that some location information is returned.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>There's more...</h2></div></div></div><p>All modern browsers across both desktop and mobile platforms, except for Opera Mini, support the Geolocation API. Most have done so for enough time that you should be comfortable using the API in your web applications.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Microsoft Internet Explorer from Version 9.0 onwards (March 14, 2010)</li><li class="listitem" style="list-style-type: disc">Mozilla Firefox from Version 3.5 onwards (June 30, 2009)</li><li class="listitem" style="list-style-type: disc">Google Chrome from Version 5.0 onwards (May 25, 2010)</li><li class="listitem" style="list-style-type: disc">Android Browser from Version 2.1 onwards (January, 2010)</li><li class="listitem" style="list-style-type: disc">Apple Safari on the desktop from Version 5.1 onwards (July 20, 2011)</li><li class="listitem" style="list-style-type: disc">Apple Safari on iOS from Version 3.2 onwards (April 3, 2010)</li><li class="listitem" style="list-style-type: disc">Opera from Version 10.6 onwards (July 1, 2010)</li><li class="listitem" style="list-style-type: disc">BlackBerry Browser from Version 7.0 onwards (May, 2011)</li></ul></div><p>(Source: <a class="ulink" href="http://CanIUse.com">CanIUse.com</a>)</p><p>It's worth noting that because Microsoft Internet Explorer 9.0 was the first version to not support Windows XP, there remains a significant enterprise userbase—Internet Explorer users with Windows XP operating systems—that cannot use applications based on the Geolocation API. At the time of writing, this represents 24 percent of all web users worldwide according to <a class="ulink" href="http://theie8countdown.com">theie8countdown.com</a>. For this and a host of other reasons, including their own security, let's hope that they will upgrade soon.</p><p>The lack of Opera Mini support also means that many mobile phone users, particularly in developing nations or users with feature phones, are not able to use the Geolocation API. This situation is likely to change soon, as open source mobile operating systems such as Android and Firefox OS are gaining traction in those markets.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Further resources</h3></div></div></div><p>Here are some relevant resources for further research:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Can I Use Geolocation</strong>: An up-to-date list of browsers that support the Geolocation API (<a class="ulink" href="http://caniuse.com/#feat=geolocation">http://caniuse.com/#feat=geolocation</a>)</li><li class="listitem" style="list-style-type: disc"><strong>Geolocation API specification</strong>: <a class="ulink" href="http://dev.w3.org/geo/api/spec-source.html">http://dev.w3.org/geo/api/spec-source.html</a></li></ul></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Setting up the application (Simple)</h1></div></div></div><p>In this section, we will learn which server software we require to support the Geolocation API, which server software we require to support the application we will build in this book, and how to set up your server software to support the application.</p><p>In this book, we're going to build a simple application that creates a <strong>KML</strong> (<strong>Keyhole Markup Language</strong>) feed of the user's movements that can be imported into mapping applications such as Google Maps and Google Earth. In order to do this, we need to capture the user's geolocation coordinates, save them into a database, and then export the saved coordinates into a data feed.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Getting ready</h2></div></div></div><p>There are four core actions that will need to be supported:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Displaying the page containing the Geolocation API code</li><li class="listitem" style="list-style-type: disc">Capturing the user's location</li><li class="listitem" style="list-style-type: disc">Storing the user's location</li><li class="listitem" style="list-style-type: disc">Displaying the user's history of locations as a KML feed</li></ul></div><p>For the purposes of this book, we will support them in turn with:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Apache Web Server</li><li class="listitem" style="list-style-type: disc">Client-side JavaScript using jQuery (the Geolocation API itself requires no support on the server side; we'll use jQuery to simplify AJAX queries and manipulating content on the page)</li><li class="listitem" style="list-style-type: disc">A MySQL database and the PHP scripting language</li><li class="listitem" style="list-style-type: disc">A simple feed script written in PHP</li></ul></div><p>Note that you could use any web browser, any web scripting language, and virtually any database, to perform these tasks. I hope that the examples here are generalized enough to allow you to translate them into the languages and server software of your choice. For example, if PHP isn't to your taste, these examples should be relatively easy to translate into Ruby or Python.</p><p>We will assume that you are running a recent copy of Apache Web Server, configured to allow scripting using PHP 5.3 or later.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How to do it...</h2></div></div></div><p>Create the following files in a new location on your web server:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">index.php</code>: The main page that retrieves the user's location</li><li class="listitem" style="list-style-type: disc"><code class="literal">callback.php</code>: The code that our JavaScript will call behind the scenes to save the user's location</li><li class="listitem" style="list-style-type: disc"><code class="literal">feed.php</code>: The script that will echo the KML feed</li><li class="listitem" style="list-style-type: disc"><code class="literal">lib.php</code>: A common file to handle the database connection and any other configuration</li><li class="listitem" style="list-style-type: disc"><code class="literal">live.php</code>: A version of the main page that continuously retrieves the user's location</li><li class="listitem" style="list-style-type: disc"><code class="literal">livepath.php</code>: A version of the main page that continuously retrieves the user's location and displays his/her route as a path</li></ul></div><p>Create a new MySQL database table (and, if you like, a new database to house it in) for this example. This will store our retrieved geolocation coordinates, with a timestamp and an identifier for the user.</p><p>There are a number of different ways we could store the location information. Geolocation coordinates are returned as longitude and latitude; an angle on the surface of the Earth east and west of the Prime Meridian, and an angle north and south of the Equator, respectively. Recall the example data in the <em>Understanding the geolocation API (Simple)</em> recipe, the angles were returned to 14 decimal places. The more accurately we can store these numbers, the more accurately we can retrieve the user's location.</p><p>For the purposes of this tutorial, we are going to store our coordinates as a set of floating point numbers. This is because we're not performing any comparisons on the geographic data; we're simply storing and retrieving it.</p><p>All we need, then, is decimal point latitudes and longitudes with the required level of accuracy, as well as an integer identifier for the user, and another for the timestamp. As we'll be searching by user and timestamp, it's a good idea to maintain an index for each of these fields.</p><p>We'll call our database table <code class="literal">points</code>:</p><div><pre class="programlisting">--
Table structure for table 'points'
--

CREATE TABLE IF NOT EXISTS 'points' (
'id' int(11) NOT NULL AUTO_INCREMENT COMMENT 'Our primary index field',
'latitude' float NOT NULL COMMENT 'Our latitude coordinate',
'longitude' float NOT NULL COMMENT 'Our longitude coordinate',
'user_id' int(11) NOT NULL COMMENT 'The unique ID of the user',
'time' int(11) NOT NULL COMMENT 'The UNIX timestamp of the time when the point was recorded',
PRIMARY KEY ('id'),
KEY 'user_id' ('user_id'),
KEY 'time' ('time')
) ENGINE=InnoDB;</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>Note that I've also included a unique identifier for each row in the database, for ease of access later.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>There's more...</h2></div></div></div><p>One of the problems with geographic data is that it's very easy to store a huge amount of it, which can cause databases to slow down if you're not careful—particularly, if you're doing a lot of proximity queries, for example, to discover stored geographic points within a certain radius of a location. The mathematics behind this functionality, while not massively complicated, can become expensive in aggregate.</p><p>MySQL has a spatial support extension, which allows you to store, retrieve, and compare extensions based on an optimized geographic engine. This uses a standard set from the OpenGIS project to store sets of geographic data. It's often installed by default, and is worth getting to know for more sophisticated geo-aware applications.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Getting the user's location (Intermediate)</h1></div></div></div><p>In this section, we will detect geolocation support, use the Geolocation API to obtain the user's coordinates (if we can), save the coordinates to MySQL via our PHP callback, and handle any errors that might occur.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Getting ready</h2></div></div></div><p>Make sure you've set up the required files in the previous section: <code class="literal">index.php</code> to serve the main page, <code class="literal">callback.php</code> to serve as our callback, and <code class="literal">feed.php</code> to serve as our KML feed. In this section, we will be concentrating on <code class="literal">index.php</code> and <code class="literal">callback.php</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How to do it...</h2></div></div></div><p>Perform the following steps for getting the user's location:</p><div><ol class="orderedlist arabic"><li class="listitem">First, set up <code class="literal">lib.php</code> as discussed here. This will be the file that handles connections to the database for all components in the system.</li><li class="listitem">Fill in the blanks at the top of the page with your own database details. Note that for simplicity, I have used the built-in MySQL functions. For a fully fledged PHP application, I recommend using the built-in PDO library.<div><pre class="programlisting">&lt;?php

$server = '';		    // Enter your database server here
$username = '';		    // Enter your database username here
$password = '';		    // Enter your database password here
$database = '';	    // Enter your database name here

// Connect to the database

if (mysql_connect(
  $server,
  $username,
  $password
)) {
  mysql_select_db(
    $database
  );
} else {
  header($_SERVER['SERVER_PROTOCOL'] . 
  ' 500 Internal Server Error', true, 500);
  echo "Could not connect to the database.";
  exit;
}</pre></div></li><li class="listitem">Then, set up <code class="literal">callback.php</code>. This will accept longitude and latitude data from our location detection page via an HTTP <code class="literal">POST</code> request, and save it to our database:<div><pre class="programlisting">&lt;?php
// Load our common library file, and fail if it isn't present
require_once('lib.php');

// Check for the existence of longitude and latitude in our POST request
// variables; if they're present, continue attempting to save
if (isset($_POST['longitude']) &amp;&amp; isset($_POST['latitude'])) {
  // Cast variables to float 
  (never accept unsanitized input!)
  $longitude = (float) $_POST['longitude'];
  $latitude = (float) $_POST['latitude'];
  // For now, let's hard-code the user identifier to "1" - 
  we can
  // use PHP sessions and authentication to set this 
  differently later
  // on
  $user = 1;
  // Set the timestamp from the current system time
  $time = time();
  // Put our query together:
  $query = "insert into points set 'longitude' = 
  {$longitude}, 
  'latitude' = {$latitude},
  'user_id' = {$user},
  'time' = {$time}";
  // Run the query, and return an error if it fails
  if (!($result = mysql_query($query))) {
    header($_SERVER['SERVER_PROTOCOL'] . 
    ' 500 Internal Server Error', true, 500);
    echo "Could not save point.";
    exit;
  }

}</pre></div></li><li class="listitem">Finally, set up <code class="literal">index.php</code>. This is the page that users will access directly:<div><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;
      Location detector
    &lt;/title&gt;

    &lt;!-- We're using jQuery to simplify our JavaScript DOM-
    handling code --&gt;
    &lt;script src="//code.jquery.com/
    jquery-1.9.1.min.js"&gt;&lt;/script&gt;

    &lt;script language="javascript"&gt;

      // This function is called when the Geolocation API 
      successfully
      // retrieves the user's location
      function savePosition(point) {

        // Send the retrieved coordinates to 
        callback.php via a POST
        // request, and then set the page content to 
        "Location saved"
        // once this process is complete 
        (or "We couldn't save your
        // location" if it failed for some reason)
        $.ajax({
          url: 'callback.php',
          type: 'POST',
          data:   {
            latitude: point.coords.latitude,
            longitude: point.coords.longitude
          },
          statusCode: {
            500: function() {
              $('#locationpane').html
              ('&lt;p&gt;We couldn\'t save your location.&lt;/p&gt;');
            }
          }
        }).done(function() {
          $('#locationpane').html
          ('&lt;p&gt;Location saved.&lt;/p&gt;');
        }).fail(function() {
          $('#locationpane').html
          ('&lt;p&gt;We couldn\'t save your location.&lt;/p&gt;');
        });

      }

      // This function is called when there is a problem 
      retrieving
      // the user's location (but the Geolocation API is 
      supported in
      // his or her browser)
      function errorPosition(error) {
        switch(error.code) {

        // Error code 1: permission to access the user's 
        location
        // was denied
        case 1: $('#locationpane').html
        ('&lt;p&gt;No location was retrieved.&lt;/p&gt;');
        break;

        // Error code 2: the user's location could not be 
        determined
        case 2: $('#locationpane').html
        ('&lt;p&gt;We couldn\'t find you.&lt;/p&gt;');
        break;

        // Error code 3: the Geolocation API timed out
        case 3: $('#locationpane').html
        ('&lt;p&gt;We took too long 
        trying to find your location.&lt;/p&gt;');
        break;

      }
    }

    &lt;/script&gt;

  &lt;/head&gt;
  &lt;body&gt;

    &lt;div id="locationpane"&gt;

      &lt;p&gt;
        Waiting for location ...
      &lt;/p&gt;

    &lt;/div&gt;

    &lt;!-- We're including the Geolocation API code at the 
    bottom of the page
    so that page content will have loaded first --&gt;
    &lt;script language="javascript"&gt;

      // First, check if geolocation support is available
      if (navigator.geolocation) {

        // If it is, attempt to get the current position. 
        Instantiate
        // the savePosition function if the operation was 
        successful, or
        // errorPosition if it was not.
        navigator.geolocation.getCurrentPosition
        (savePosition, errorPosition);

      } else {

        // If the browser doesn't support the Geolocation 
        API, tell the user.
        $('#locationpane').html
        ('&lt;p&gt;No geolocation support is available.&lt;/p&gt;');

      }

    &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How it works...</h2></div></div></div><p>There are two large JavaScript blocks in <code class="literal">index.php</code>, which together interact with the Geolocation API. In the body of the page, we've included a simple <code class="literal">div</code> element with ID <code class="literal">locationpane</code>, which we'll use to give feedback to the user. Every time we give feedback, we do so by changing the HTML contents of <code class="literal">locationpane</code> to contain a paragraph with a different message.</p><p>In the header of the page, there are two functions: <code class="literal">savePosition</code> and <code class="literal">errorPosition</code>. <code class="literal">savePosition</code> will be called by the Geolocation API when a location is determined and <code class="literal">errorPosition</code> will be called when there has been an error determining the location.</p><p>
<code class="literal">savePosition</code> takes a single <code class="literal">Position</code> object as its first parameter. This has the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">coords</code>: An object encapsulating the location's coordinates, which in turn contains the following attributes:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">latitude</code>: This is the user's latitude in degrees. This is a double value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">longitude</code>: This is the user's longitude in degrees. This is a double value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">accuracy</code>: This is the margin of error, in meters. This can be a double or a null value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">altitude</code>: This is the number of meters above the mathematically defined surface of the Earth. This can be a double or a null value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">altitudeAccuracy</code>: This is the margin of error for the altitude, in meters. This can be double or a null value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">heading</code>: This is specified in degrees, clockwise relative to true north. This can be a double or a null value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">speed</code>: This is meters per second. This can be a double or a null value.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">timestamp</code> (<code class="literal">DOMTimeStamp</code>): This is the timestamp that the location was retrieved.</li></ul></div><p>Note that on some systems in certain contexts, the location won't be determined at the time of request; instead, a cached version will be returned. This is why the timestamp is important. However, we will discard it here.</p><p>
<code class="literal">savePosition</code> uses jQuery's AJAX function to take the latitude and longitude from the <code class="literal">coords</code> object and sends it to <code class="literal">callback.php</code>. It then checks the HTTP response code; if <code class="literal">callback.php</code> has returned an error 500, it tells the user that his/her location could not be saved. (More on this in a moment.)</p><p>Meanwhile, if there was an error determining the user's location with the Geolocation API, <code class="literal">errorPosition</code> is called. This takes a <code class="literal">PositionError</code> object as its parameter, which has the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">code</code> (short): A numeric error code</li><li class="listitem" style="list-style-type: disc"><code class="literal">message</code> (DOMstring): An internal error message</li></ul></div><p>Rather than output message, which isn't intended for end users, <code class="literal">errorPosition</code> looks at the error code to determine what kind of feedback to provide to the user:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Error code 1:  The user denied the application's request to track his/her location</li><li class="listitem" style="list-style-type: disc">Error code 2: The user's location could not be determined</li><li class="listitem" style="list-style-type: disc">Error code 3: The Geolocation API timed out</li></ul></div><p>At the bottom of the page is the code that actually runs the Geolocation API.</p><p>Before accessing the JavaScript API functions, it's important to check to make sure that the Geolocation API is supported in the current browser. To do this, you can simply check to make sure the <code class="literal">navigator.geolocation</code> object exists:</p><div><pre class="programlisting">if (navigator.geolocation) { /* The Geolocation API is supported */ }</pre></div><p>If it doesn't, we should give the user feedback to explain that his/her location cannot be determined. We could also attempt to retrieve the user's location using server-side technologies such as IP geolocation, but this is much less accurate and out of the scope of this book.</p><p>Once we're sure, we can use the Geolocation API, we can call <code class="literal">navigator.geolocation.getCurrentPosition</code>, with references to the success and failure functions as its parameters:</p><div><pre class="programlisting">navigator.geolocation.getCurrentPosition(savePosition, errorPosition);</pre></div><p>It's worth mentioning here that a third parameter is available, which takes a <code class="literal">PositionOptions</code> object. This may contain the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">enableHighAccuracy</code>: This is a Boolean value. It enables high accuracy mode (<code class="literal">default: off</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">timeout</code>: This is a Boolean value. This is the threshold beyond which the API times out (in milliseconds; the default is no limit).</li><li class="listitem" style="list-style-type: disc">maximumAge: This is a long value. The maximum age of a cached location that we'll accept, in milliseconds (<code class="literal">default: 0</code>).</li></ul></div><p>If we enable high accuracy mode, mobile devices with GPS units will attempt to use it to get the best possible location information (if their owner has allowed it); otherwise, they may default to using trilateration to determine the location. However, because not all devices have these units and because GPS signals are not always available, requesting the current position with high accuracy is more likely to fail.</p><p>While high accuracy, location detection will not automatically fall back to the standard method, you can achieve this yourself, if you like. First, call <code class="literal">getCurrentPosition</code> with <code class="literal">highAccuracy</code> set to <code class="literal">true</code> and with a reference to a new error handling function:</p><div><pre class="programlisting">navigator.geolocation.getCurrentPosition(savePosition, highAccuracyErrorPosition, {enableHighAccuracy: true});</pre></div><p>All this new error handler, <code class="literal">highAccuracyErrorPosition</code>, does is call <code class="literal">getCurrentPosition</code> with <code class="literal">highAccuracy</code> set to <code class="literal">false</code>:</p><div><pre class="programlisting">function highAccuracyErrorPosition(error) {

navigator.geolocation.getCurrentPosition(savePosition, errorPosition, {enableHighAccuracy: false});

}</pre></div><p>The result is that the browser attempts to use high-accuracy location detection, and falls back to the standard method if it is not available due to some reason. Should the user decline authorization for location information, this continues to be respected down the chain.</p><p>The callback script, <code class="literal">callback.php</code>, first loads the database functionality from <code class="literal">lib.php</code> and ensures that it can connect. If connection fails for some reason, it returns an HTTP error 500 (Internal Server Error), which tells <code class="literal">index.php</code> to display an error to the user, as previously described.</p><p>If <code class="literal">callback.php</code> is connected to the database successfully, it then sanitizes the input variables, <code class="literal">latitude</code> and <code class="literal">longitude</code>. It's important to make sure both are cast to floating point variables, to minimize the risk of SQL injection attacks. The script also retrieves the current UNIX epoch timestamp (represented as the number of seconds since 00:00 on January 1, 1970).</p><p>The script makes it possible to store location information for an unlimited number of users. However, because authentication and user handling are not within the scope for this book, we've hardcoded the user's unique ID to <code class="literal">1</code>. If you had a separate MySQL user table, for example, you would set this value to the ID of the currently logged-in user. This ID would be saved in the current browser session at the point of login. <code class="literal">callback.php</code> would use the version saved in the session rather than sent to it explicitly via a <code class="literal">GET</code> or <code class="literal">POST</code> variable, to prevent third parties from maliciously saving location information to a user's account.</p><p>Finally, <code class="literal">callback.php</code> attempts to save this data to the MySQL table we created in the previous section, using a standard MySQL insert call:</p><div><pre class="programlisting">$query =    "insert into points set 'longitude' = {$longitude}, 
    'latitude' = {$latitude},
    'user_id' = {$user},
    'time' = {$time}";</pre></div><p>Once again, if an error occurs, the script returns an HTTP 500 error so that the JavaScript on <code class="literal">index.php</code> can let the user know in a friendly way.</p><p>Otherwise, we can reasonably assume that the data was saved in our MySQL table. Because we saved it with timestamp information, and because we are also saving the user's unique ID in the same table row, we will be able to easily retrieve any individual user's locations in chronological order later on.</p><p>PHP's default HTTP response code is <code class="literal">200: OK</code>. This tells the jQuery call in <code class="literal">index.php</code> that the positioning data was saved without any problems. In turn, <code class="literal">index.php</code> lets the user know that his/her location was saved.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Displaying the user's location using the Google Maps API (Intermediate)</h1></div></div></div><p>Now that we've written the code to save the user's location at a particular time, we need to consider how we'll display it. In this section, we'll use the Google Maps API to display the user's location right now, as well as recent locations that we've saved for this user.</p><p>The Google Maps API is the most popular online mapping API in the world, which is why we will use it for this tutorial. Other mapping APIs are available, including offerings from Microsoft Bing, Nokia, and the open source OpenStreetMap project. My decision to pick the Google Maps API does not reflect on the quality of these other APIs, and you will want to carefully choose between them based on their merits and applicability for your project. I have included links to these projects at the end of this section, as well as to the Google Maps API documentation.</p><p>Use of the Google Maps API is free for non-profit websites at the time of writing. Commercial sites are limited to 25,000 map loads per day. Beyond that, you will need to acquire a Google Maps API for Business license by contacting Google directly.</p><p>We will be using the Google Maps API v3 for the purposes of this tutorial.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How to do it...</h2></div></div></div><p>Let's begin by retrieving all of our previously-saved points.</p><div><ol class="orderedlist arabic"><li class="listitem">First, alter <code class="literal">lib.php</code> as follows. Recall that this is the script file that connects to the database so that points can be saved. We're now expanding its role to include a helper function to retrieve all the previously saved points for a particular user.<div><pre class="programlisting">&lt;?php

$server = '';		    // Enter your database server here
$username = '';		    // Enter your database username here
$password = '';		    // Enter your database password here
$database = '';	    // Enter your database name here

// Connect to the database server, and then select $database as the database
if (mysql_connect	(
  $server,
  $username,
  $password
)) {
  mysql_select_db(
    $database
  );
} else {
  header($_SERVER['SERVER_PROTOCOL'] . 
  ' 500 Internal Server Error', true, 500);
  echo "Could not connect to the database.";
  exit;
}

/**
Retrieve all the stored locations in the database
@return array
*/
function getPreviousLocations($user_id) {

  // Initialize the array that we'll return
  $points = array();

  // It's always important to validate input, 
  and particularly when
  // we're using it in the context of a database query. 
  Here we make
  // sure $user_id is an integer.
  $user_id = (int) $user_id;

  // SQL query to simply return all points from our 
  database - over time
  // you may wish to add a limit clause
  $query = "select 'latitude', 'longitude', 'time' from 
  'points' where user_id = $user_id order by 'time' desc";

  // If we have points in the database, add them to the 
  $points array
  if ($result = mysql_query($query)) {
    while ($row = mysql_fetch_object($result)) {
      $points[] = $row;
    }
  } else {
  echo mysql_error();
}
// Finally, return the $points array
return $points;

}</pre></div></li><li class="listitem">Then, expand <code class="literal">index.php</code> to load the Google Maps API, retrieve any previous points, and display both the set of previous location points and the current location on a map:<div><pre class="programlisting">&lt;?php 

// Load our common library file, and fail if it isn't present
require_once('lib.php');

?&gt;
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;
      Location detector
    &lt;/title&gt;

    &lt;!-- We're using jQuery to simplify our JavaScript 
    DOM-handling code --&gt;
    &lt;script type="text/javascript" 
    src="img/"&gt;&lt;/script&gt;

      &lt;!-- We're using the Google Maps API v3; 
      note that we need to tell
      Google we're using a sensor for geolocation --&gt;
      &lt;script type="text/javascript" 
      src="//maps.googleapis.com/maps/api/js?v=3.
      exp&amp;sensor=true"&gt;&lt;/script&gt;

      &lt;script type="text/javascript"&gt;

        // This function is called when the Geolocation API 
        successfully
        // retrieves the user's location
        function savePosition(point) {

          // Save the current latitude and longitude as 
          properties
          // on the window object
          window.latitude = point.coords.latitude;
          window.longitude = point.coords.longitude;

          // Send the retrieved coordinates to callback.php 
          via a POST
          // request, and then set the page content to 
          "Location saved"
          // once this process is complete 
          (or "We couldn't save your
          // location" if it failed for some reason)
          $.ajax({
            url: 'callback.php',
            type: 'POST',
            data:   {
              latitude: window.latitude,
              longitude: window.longitude
            },
            statusCode: {
              500: function() {
              $('#location_pane').html
              ('&lt;p&gt;We couldn\'t save your location.&lt;/p&gt;');
            }
          }

        }).done(function() {
          // Let the user know the location's been 
          saved to the database
          $('#location_pane').html
          ('&lt;p&gt;Location saved.&lt;/p&gt;');

          // Center the map on the user's current location
          var currentLocation = 
          new google.maps.LatLng(window.latitude, 
          window.longitude);
          window.googleMap.setCenter(currentLocation);

          // Create a marker at the user's current location
          var marker = new google.maps.Marker({
            position: currentLocation,
            map: window.googleMap,
            title: 'Current location'
          });
        }).fail(function() {
        $('#location_pane').html
        ('&lt;p&gt;We couldn\'t save your location.&lt;/p&gt;');
      });

    }

    // This function is called when there is a problem 
    retrieving
    // the user's location (but the Geolocation API is 
    supported in
    // his or her browser)
    function errorPosition(error) {
      switch(error.code) {

      // Error code 1: permission to access the user's 
      location
      // was denied
      case 1: $('#location_pane').html('&lt;p&gt;No location was 
      retrieved.&lt;/p&gt;');
      break;

      // Error code 2: the user's location could not be 
      determined
      case 2: $('#location_pane').html
      ('&lt;p&gt;We couldn\'t find 
      you.&lt;/p&gt;');
      break;

      // Error code 3: the Geolocation API timed out
      case 3: $('#location_pane').html
      ('&lt;p&gt;We took too long trying to find your 
      location.&lt;/p&gt;');
      break;

    }
  }

  // This function is called when there is a problem 
  retrieving
  // The high-accuracy position. Instead of failing 
  outright, it
  // attempts to retrieve the low-accuracy position, 
  telling the
  // getCurrentPosition function to call errorPosition if 
  there is
  // an error this time.
  function highAccuracyErrorPosition(error) {

    navigator.geolocation.getCurrentPosition(savePosition, 
    errorPosition, {enableHighAccuracy: false});

    }

    &lt;/script&gt;

    &lt;/head&gt;
    &lt;body&gt;

      &lt;div id="location_pane"&gt;

        &lt;p&gt;
          Waiting for location ...
        &lt;/p&gt;

      &lt;/div&gt;
      &lt;div id="map_pane" style="width: 500px; 
      height: 500px"&gt;&lt;/div&gt;

      &lt;!-- We're including the Geolocation API code at the 
      bottom of the page
      so that page content will have loaded first --&gt;
      &lt;script language="javascript"&gt;

      // Set initial viewing options for the map
      var mapOptions = {
        zoom: 15,
        mapTypeId: google.maps.MapTypeId.HYBRID
      };

      // Initialize the map as a googleMap property on 
      the window object
      window.googleMap = 
      new google.maps.Map
      (document.getElementById('map_pane'), mapOptions);

      // Load any previous points into a JSON array, 
      which itself is written
      // to the page using PHP. We're hardcoding the user 
      ID to 1, as in
      // callback.php.
      var jsonPoints = 
      &lt;?=json_encode(getPreviousLocations(1));?&gt;;

      // If jsonPoints isn't empty, 
      iterate through and create new map points
      // for each geolocation point
      if (jsonPoints.length &gt; 0) {
        window.points = new Array();
        jsonPoints.forEach(function(point) {
          window.points.push(new google.maps.Marker({
            position: new google.maps.LatLng
            (point.latitude, point.longitude),
            map: window.googleMap
          }))
        });
      }

      // First, check if geolocation support is available
      if (navigator.geolocation) {

        // If it is, attempt to get the current position. 
        Instantiate
        // the savePosition function if the operation was 
        successful, or
        // errorPosition if it was not.
        navigator.geolocation.getCurrentPosition
        (savePosition, highAccuracyErrorPosition, 
        {enableHighAccuracy: true});

      } else {

        // If the browser doesn't support 
        the Geolocation API, tell the user.
        $('#location_pane').html
        ('&lt;p&gt;No geolocation support is available.&lt;/p&gt;');

      }

    &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How it works...</h2></div></div></div><p>To display our location data, we will use a MySQL function stored in <code class="literal">lib.php</code> to retrieve existing map points. We will also load the Google Maps API using Google's hosted JavaScript library and make use of the following Google Maps objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Map</code>: The Google Map itself</li><li class="listitem" style="list-style-type: disc"><code class="literal">Marker</code>: An individual point on a Google Map</li><li class="listitem" style="list-style-type: disc"><code class="literal">LatLng</code>: An object representing a pair of latitude and longitude coordinates</li></ul></div><p>There are three main structural changes we must make to <code class="literal">index.php</code>. First, we must require that <code class="literal">lib.php</code> is loaded. This will give us access to the database and a new function that we'll add to that library.</p><p>So far, we've only stored geolocation data; we haven't displayed it to the user at all. However, because we've been saving it to the database, we potentially have a rich history of location data that we can retrieve—organized by both user and time. A new function, <code class="literal">getPreviousLocations($user_id)</code>, returns this data as an array in chronological order using a simple MySQL select call:</p><div><pre class="programlisting">$query = "select 'latitude', 'longitude', 'time' from 'points' where user_id = $user_id order by 'time' asc";</pre></div><p>Recall that for the purposes of this tutorial, we're always setting <code class="literal">$user_id</code> to <code class="literal">1</code>. A more sophisticated application would substitute a user identifier from the current browser session, or another location.</p><p>By requiring <code class="literal">lib.php</code> at the top of <code class="literal">index.php</code>, we can ensure that we have reliable access to this information from the database:</p><div><pre class="programlisting">&lt;?php 
// Load our common library file, and fail if it isn't present
require_once('lib.php');
?&gt;</pre></div><p>Another new addition is the JavaScript library that Google provides for the Google Maps API. Note that by omitting the URI scheme (<code class="literal">http:</code> or <code class="literal">https:</code>), we can ensure that the browser will use the correct one, whether your page is accessed over a standard or secure HTTP connection. This is placed within the HTML <code class="literal">&lt;head&gt;</code> tag in <code class="literal">index.php</code>:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/js?v=3.exp&amp;sensor=true"&gt;&lt;/script&gt;</pre></div><p>Finally, we also need a place on the page to display our map. For this, we establish a new, empty <code class="literal">div</code> element with a unique ID (here I've used <code class="literal">map_pane</code>). The Google Maps API will populate this with a complete map later.</p><p>Now that we've set up the framework of the page, we can begin configuring the map. We do this in the JavaScript block at the bottom of the page:</p><div><pre class="programlisting">// Set initial viewing options for the map
var mapOptions = {
  zoom: 15,
  mapTypeId: google.maps.MapTypeId.HYBRID
};</pre></div><p>The zoom level for Google Maps starts at <code class="literal">0</code>, where you can see the entire globe. Theoretically, the zoom levels are infinite, but in practice, for most maps, the maximum level is <code class="literal">19</code>. Set the zoom level at <code class="literal">15</code>; it's close enough to be able to view your location with precision, but zoomed out enough to see a large amount of the surrounding neighborhood.</p><p>There are a number of different map types at your disposal:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">google.maps.MapTypeId.ROADMAP</code>: The street map view</li><li class="listitem" style="list-style-type: disc"><code class="literal">google.maps.MapTypeId.SATELLITE</code>: A satellite view of the Earth</li><li class="listitem" style="list-style-type: disc"><code class="literal">google.maps.MapTypeId.HYBRID</code>: Street map items overlaid on top of the satellite view</li><li class="listitem" style="list-style-type: disc"><code class="literal">google.maps.MapTypeId.TERRAIN</code>: Terrain information without road markings and so on</li></ul></div><p>For now, set the <code class="literal">mapTypeId</code> to <code class="literal">googlemaps.MapTypeId.HYBRID</code>.</p><p>Next, initialize the <code class="literal">Map</code> object with the options you've just defined, and the <code class="literal">map_pane</code> DOM element. This is enough to display the map inside the <code class="literal">map_pane</code> div. We'll save it to the <code class="literal">window.googleMap</code> global variable, which will come in handy.</p><div><pre class="programlisting">window.googleMap = new google.maps.Map(document.getElementById('map_pane'), mapOptions);</pre></div><p>However, there's every chance we've already got some location information to display. Here's where our PHP function, <code class="literal">getPreviousLocations($user_id)</code>, becomes useful. Recall that it's returning an array of database row objects containing latitude, longitude, and time.</p><p>JavaScript is a front-end language, interpreted in the web browser; PHP is a server-side language, interpreted before any HTML is received by the browser. They cannot directly interface with each other. As a result, we need a way to pre-process the array of coordinates so that it's readable by JavaScript. JSON is perfect for this task.</p><p>Luckily, PHP provides a very simple function to encode PHP variables as <code class="literal">JSON: json_encode</code>. We just need to use this on the result of <code class="literal">getPreviousLocations($user_id)</code>. Remembering that we're hardcoding the value <code class="literal">1</code> in place of <code class="literal">$user_id</code>, our hybrid JavaScript/PHP code looks like the following:</p><div><pre class="programlisting">var jsonPoints = &lt;?=json_encode(getPreviousLocations(1));?&gt;;</pre></div><p>If there was a single location point in the database, this might be rendered as follows:</p><div><pre class="programlisting">var jsonPoints = [{"latitude":"37.7595","longitude":"-122.463","time":"1362975429"}];</pre></div><p>In other words, <code class="literal">jsonPoints</code> is seen by JavaScript as an array of JavaScript objects. We can simply check that the array is non-empty, and iterate through any elements using the <code class="literal">Array.forEach</code> method:</p><div><pre class="programlisting">if (jsonPoints.length &gt; 0) {
  window.points = new Array();
  jsonPoints.forEach(function(point) {
    window.points.push(new google.maps.Marker({
      position: new google.maps.LatLng(point.latitude, 
      point.longitude),
      map: window.googleMap
    }))
  });
}  </pre></div><p>We establish <code class="literal">window.points</code> as a global JavaScript array of Marker objects, the objects used to represent individual geographic points in the Google Maps API. On instantiation, Marker objects are given a position in terms of a LatLng object containing latitude and longitude, and a reference to the Google Map that will display them. (We can simply supply the <code class="literal">window.googleMap</code> variable we created earlier for this purpose.)</p><p>Once the previously saved geographic points have been written to the map, we must ensure that the newly detected location, if it has been successfully obtained, is also added.</p><p>Previously, we had written a message to the screen—<code class="literal">Location saved</code>—once a location had been successfully processed. Now, we need to also draw it to the map.</p><p>First, we create a new LatLng object containing the latitude and longitude of the newly saved location:</p><div><pre class="programlisting">var currentLocation = new google.maps.LatLng(window.latitude, window.longitude);</pre></div><p>Next, we can center the map on it using the Map object's <code class="literal">setCenter</code> method:</p><div><pre class="programlisting">window.googleMap.setCenter(currentLocation);</pre></div><p>Finally, we create a new Marker object, containing a simple title, the newly created LatLng object, and a reference to our Map:</p><div><pre class="programlisting">var marker = new google.maps.Marker({
  position: currentLocation,
  map: window.googleMap,
  title: 'Current location'
});</pre></div><p>The location appears as a pin on the map, alongside previously saved locations.</p><div><img src="img/5903_2_1.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Google Maps API</strong>: <a class="ulink" href="https://developers.google.com/maps/">https://developers.google.com/maps/</a></li><li class="listitem" style="list-style-type: disc"><strong>Microsoft Bing Maps API</strong>: <a class="ulink" href="http://www.microsoft.com/maps/developers/web.aspx">http://www.microsoft.com/maps/developers/web.aspx</a></li><li class="listitem" style="list-style-type: disc"><strong>Nokia Here API</strong>: <a class="ulink" href="http://developer.here.com/">http://developer.here.com/</a></li><li class="listitem" style="list-style-type: disc"><strong>OpenStreetMap</strong>: <a class="ulink" href="http://www.openstreetmap.org/">http://www.openstreetmap.org/</a></li><li class="listitem" style="list-style-type: disc"><strong>CloudMade</strong>: <a class="ulink" href="http://cloudmade.com/">http://cloudmade.com/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Displaying the user's location using a KML feed (Intermediate)</h1></div></div></div><p>The <strong>Keyhole Markup Language</strong> (<strong>KML</strong>) is an XML-based markup language suitable for defining geographic data. Alongside GeoRSS, it's one of two main XML-based standards that Google Maps supports. It was originally developed for using with Google Earth, which was known as <strong>Keyhole Earth Viewer</strong> until Google acquired it. Because multiple applications support KML files, it's a good way to easily export your geographic data.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Getting ready</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Ensure that you have a recent version of PHP installed.</li><li class="listitem">Check that DOM extension of PHP 5 is installed. Specifically, this will use the XML <code class="literal">DOMDocument</code> class. For most installations of PHP 5, this will be installed by default, but it's worth checking, as not all installations are the same. You can read information about the DOM extension at <a class="ulink" href="http://php.net/manual/en/book.dom.php">http://php.net/manual/en/book.dom.php</a>.</li><li class="listitem">You may also wish to install Google Earth in order to test your KML feed. The website for Google Earth is listed at the end of this section.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How to do it…</h2></div></div></div><p>Perform the following steps to display the user's location using a KML feed:</p><div><ol class="orderedlist arabic"><li class="listitem">Set up <code class="literal">feed.php</code> as follows. This will retrieve the location items using the <code class="literal">getPreviousLocations($user_id)</code> function that we created in the <em>Displaying the user's location using the Google Maps API (Intermidiate)</em> recipe. Using the PHP DOM extension, it will create an XML feed in Keyhole Markup Language, which will encode the locations and timestamps of each saved point.<div><pre class="programlisting">&lt;?php 

// Load our common library file, and fail if it isn't present
require_once('lib.php');

// PHP's date function requires that the timezone is set. As I'm located on
// America's west coast, I'm setting this to America/Los_Angeles. You can
// also set this in your php.ini.
date_default_timezone_set('America/Los_Angeles');

// Create a new XML file using PHP's DOM extension.
$feed = new DOMDocument('1.0','UTF-8');
$feed-&gt;formatOutput = true;

// Create a root node for the XML document.
$rootNode = $feed-&gt;appendChild($feed-&gt;createElementNS('http://earth.google.com/kml/2.2', 'kml'));

// Create a document node inside the root node.
$documentNode = $rootNode-&gt;appendChild($feed-&gt;createElement('Document'));
$documentNameNode = $documentNode-&gt;appendChild($feed-&gt;createElement('name','Location detector feed'));

// Attempt to retrieve previous map points - and if they exist, iterate
// through them. Note that we're hardcoding $user_id to 1; in more complex
// implementations with user management, we might get $user_id from the
// current user session.
if ($points = getPreviousLocations(1)) {
  foreach($points as $point) {
    // Each place is stored inside a Placemark tag
    $placeNode = $documentNode-&gt;appendChild
    ($feed-&gt;createElement('Placemark'));
    // We're going to use the timestamp of the saved 
    // location as its title
    $nameNode = $placeNode-&gt;appendChild
    ($feed-&gt;createElement('name',date('r',$point-&gt;time)));
    // The actual coordinates are stored inside a Point tag
    $pointNode = $placeNode-&gt;appendChild
    ($feed-&gt;createElement('Point'));
    // Note that KML coordinates are longitude 
    // then latitude!
    $coordinatesNode = $pointNode-&gt;appendChild
    ($feed-&gt;createElement('coordinates',
    $point-&gt;longitude . ',' . $point-&gt;latitude));
    // Each place also has an actual TimeStamp tag
    $timeNode = $placeNode-&gt;appendChild
    ($feed-&gt;createElement('TimeStamp', date('c',$point-&gt;time)));
  }
}

// Make sure browsers know to render the feed as XML
header('Content-type: text/xml');

// Write the feed content to the page
echo $feed-&gt;saveXML();</pre></div></li><li class="listitem">Ensure that the resulting feed looks something like this in your browser:<div><img src="img/5903_2_2.jpg" alt="How to do it…"/></div></li><li class="listitem">If your feed is accessible to the public Internet, test it by entering its URL into the Google Maps search bar:<div><img src="img/5903_2_3.jpg" alt="How to do it…"/></div></li><li class="listitem">Select <strong>File</strong> | <strong>Save</strong> in your web browser while viewing the feed, and save it with a filename ending in <code class="literal">.kml</code>.</li><li class="listitem">You will be able to open the resulting KML file in Google Earth. If you have Google Earth installed, test the feed by double-clicking on the file.<div><img src="img/5903_2_4.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How it works...</h2></div></div></div><p>It's not a good idea to hand-code an XML-based file, or to use a static template to do so. Various tools and libraries are available, and the DOM extension that was introduced with PHP 5 is an easy way to get started.</p><p>Our KML file consists of a Document node, which in turn contains a series of Placemark nodes. We could include a large amount of data here, but our minimum viable KML file will list name, timestamp, and geographic point information inside each Placemark. These are contained within name, TimeStamp, and Point nodes respectively. The Point node in turn contains a coordinates node, which lists the geographic coordinates of the point. Note that KML coordinates list the latitude first, followed by a comma, followed by the longitude. Spaces should not be used.</p><p>Placemarks can include more than one Point, as well as a selection of other geographic elements, but for the purposes of this example, we'll stick to one Point per Placemark.</p><p>TimeStamps are listed in ISO 8601 format. The TimeStamp for 7:30 p.m. Pacific Time on March 11, 2013 would appear as follows:</p><div><pre class="programlisting">Mon, 11 Mar 2013 19:30:00 -0700</pre></div><p>Create a new XML file in PHP by instantiating a DOMDocument object, specifying XML Version 1.0 and the UTF-8 character set:</p><div><pre class="programlisting">$feed = new DOMDocument('1.0','UTF-8');</pre></div><p>Define it as being a KML file by including the KML namespace, and establishing a root node:</p><div><pre class="programlisting">$rootNode = $feed-&gt;appendChild($feed-&gt;createElementNS('http://earth.google.com/kml/2.2', 'kml'));</pre></div><p>New child nodes are added to a DOMDocument through use of the <code class="literal">appendChild</code> method; elements are created inside them using <code class="literal">createElement</code>. Now you have your root node, you can add the Document node:</p><div><pre class="programlisting">$documentNode = $rootNode-&gt;appendChild($feed-&gt;createElement('Document'));</pre></div><p>Using the <code class="literal">getPreviousLocations</code> function we created earlier, we can nest a series of Placemark nodes with the features as described in the preceding code line, using more calls to <code class="literal">appendChild</code> and <code class="literal">createElement</code>. The complete code is available in <code class="literal">feed.php</code> for you to peruse.</p><p>All of your data is now loaded into the feed. All that's left is to write it to the browser. First, you must tell it that this is an XML file, by setting the HTTP header appropriately:</p><div><pre class="programlisting">header('Content-type: text/xml');</pre></div><p>Finally, then, you can write it to the browser:</p><div><pre class="programlisting">echo $feed-&gt;saveXML();</pre></div><p>This is all you need to create a fully functional KML feed. There's much more available in the KML specification, including details about how to style map points, and other information that can be included inside the feed as a whole, as well as each individual Placemark. A link to the KML specification is included at the end of this section.</p><p>Because Google Maps natively supports KML, once you've made your system live on the web, you can simply paste the URL to your <code class="literal">feed.php</code> file into the Google Maps search box, and your geographic points will be displayed.</p><p>Additionally, you can choose to load your KML file into the map you created in <code class="literal">index.php</code>. This has the same effect as entering the address of your KML file into the Google Maps search bar, but on the map embedded in your own application.</p><p>You may remember that we created a global variable referencing the map called <code class="literal">window.googleMap</code>. Directly underneath, you can create a <code class="literal">KmlLayer</code> object as follows:</p><div><pre class="programlisting">window.kmlLayer = new google.maps.KmlLayer('http://your/kml/feed.php');
window.kmlLayer.setMap(window.googleMap);</pre></div><p>Of course, <code class="literal">http://your/kml/feed.php</code> must be replaced with the URL of your feed.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Keyhole Markup Language specification</strong>: <a class="ulink" href="https://developers.google.com/kml/">https://developers.google.com/kml/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Tracking and updating the user's location (Intermediate)</h1></div></div></div><p>While recording an individual location when the page loads is useful, in some situations you may wish to record the user's location continuously. The Geolocation API provides two functions for handling this use case—<code class="literal">watchPosition</code> and <code class="literal">clearWatch</code>—and in this section, we'll use them to modify our application to automatically resave the user's position when he/she moves.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Getting ready</h2></div></div></div><p>This section doesn't require any PHP programming; the modifications are all on the front end, using JavaScript. However, ensure that you have a compatible device with a GPS receiver and mobile data capability available to test your code. Most modern smartphones should suffice; we tested with the Chrome browser on a Samsung Galaxy S2, and in Safari on an iPhone 5.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How to do it...</h2></div></div></div><p>Perform the following steps to track and update the user's location:</p><div><ol class="orderedlist arabic"><li class="listitem">Take a copy of <code class="literal">index.php</code>, and save it as <code class="literal">live.php</code>. We're going to modify it to use <code class="literal">watchPosition</code> and save multiple map points as follows:<div><pre class="programlisting">&lt;?php 
// Load our common library file, and fail if it isn't present
require_once('lib.php');

?&gt;
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;
Continuous location detector
&lt;/title&gt;

&lt;script type="text/javascript" src="img/"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" 
  src="//maps.googleapis.com/maps/api/
  js?v=3.exp&amp;sensor=true"&gt;&lt;/script&gt;

&lt;script language="javascript"&gt;</pre></div><p>This function is called when the Geolocation API successfully retrieves the user's location. Note that we are now saving our map points to an array:</p><div><pre class="programlisting">function savePosition(point) {

  // Save the current latitude and longitude as properties
  // on the window object
  window.latitude = point.coords.latitude;
  window.longitude = point.coords.longitude;

  // Send the retrieved coordinates to 
  callback.php via a POST
  // request, and then set the page 
  content to "Location saved"
  // once this process is complete 
  (or "We couldn't save your
  // location" if it failed for some reason)
  $.ajax({
    url: 'callback.php',
    type: 'POST',
    data:   {
      latitude: window.latitude,
      longitude: window.longitude
    },
    statusCode: {
      500: function() {
        $('#location_pane').html
        ('&lt;p&gt;We couldn\'t save your location.&lt;/p&gt;');
      }
    }
  }).done(function() {
  // Let the user know the location's 
  been saved to the database
  $('#location_pane').html('&lt;p&gt;Location saved.&lt;/p&gt;');
  // Center the map on the user's current location
  var currentLocation = new 
  google.maps.LatLng(window.latitude, window.longitude);
  window.googleMap.setCenter(currentLocation);
  // Create a marker at the user's current 
  location and save it
  // to our array of map points
  window.geopath.push(new google.maps.LatLng(window.latitude, window.longitude));
}).fail(function() {
$('#location_pane').html('&lt;p&gt;We couldn\'t save your location.&lt;/p&gt;');
});
}</pre></div><p>This function is called when there is a problem retrieving the user's location (but the Geolocation API is supported in his/her browser):</p><div><pre class="programlisting">function errorPosition(error) {
  switch(error.code) {
    // Error code 1: permission to access the user's 
    location
    // was denied
    case 1: $('#location_pane').html('&lt;p&gt;No location was 
    retrieved.&lt;/p&gt;');
    break;
    // Error code 2: the user's location could not be 
    determined
    case 2: $('#location_pane').html('&lt;p&gt;We couldn\'t find 
    you.&lt;/p&gt;');
    break;
    // Error code 3: the Geolocation API timed out
    case 3: $('#location_pane').html('&lt;p&gt;We took too long 
    trying to find your location.&lt;/p&gt;');
    break;
  }
}</pre></div></li><li class="listitem">And finally, add a function to prevent automatic updating of user location:<div><pre class="programlisting">function stopWatching() {
  if (navigator.geolocation) {
    navigator.geolocation.clearWatch
    (window.watchLocationID);
    $('#watchingButton').hide();
  }
}</pre></div><p>Following this, we move onto the body of the page, incorporating a new "stop watching" button:</p><div><pre class="programlisting">&lt;/script&gt;
&lt;/head&gt;
  &lt;body&gt;
    &lt;div id="location_pane"&gt;
    &lt;p&gt;
      Waiting for location ...
    &lt;/p&gt;
    &lt;/div&gt;
    &lt;p&gt;
      &lt;button onclick="stopWatching()" 
      id="watchingButton"&gt;Stop watching position&lt;/button&gt;
    &lt;/p&gt;
      &lt;div id="map_pane" style="width: 500px; 
      height: 500px"&gt;&lt;/div&gt;
      &lt;!-- We're including the Geolocation API code 
      at the bottom of the page
      so that page content will have loaded first --&gt;
      &lt;script language="javascript"&gt;
      // Set initial viewing options for the map
      var mapOptions = {
        zoom: 15,
        mapTypeId: google.maps.MapTypeId.HYBRID
      };

      // Initialize the map as a googleMap property 
      on the window object
      window.googleMap = new 
      google.maps.Map(document.getElementById('map_pane'), 
      mapOptions);
      // Load any previous points into a JSON array, 
      which itself is written
      // to the page using PHP. We're hardcoding 
      the user ID to 1, as in
      // callback.php.
      var jsonPoints = 
      &lt;?=json_encode(getPreviousLocations(1));?&gt;;
      window.polyLine = new google.maps.Polyline({
      strokeColor: '#ff0000',
      strokeOpacity: 1.0,
      strokeWeight: 3
    });
      window.polyLine.setMap(window.googleMap);
      window.geopath = window.polyLine.getPath();

      // If jsonPoints isn't empty, iterate through and 
      create new map points
      // for each geolocation point
      if (jsonPoints.length &gt; 0) {
        jsonPoints.forEach(function(point) {
          window.geopath.push(new google.maps.LatLng
          (point.latitude, point.longitude))
        });
      }
      // First, check if geolocation support is available
      if (navigator.geolocation) {
        // If Geolocation API support is available:
        // Attempt to get the current position, and 
        // watch the user's location; 
        instantiate the savePosition 
        // function if the location was saved, 
        or errorPosition if 
        // it was not. Note that we don't ever want 
        low-accuracy
        // location measurements in this context.
        window.watchLocationID = 
        navigator.geolocation.watchPosition(savePosition, 
        errorPosition, {enableHighAccuracy: true});
      } else {
        // If the browser doesn't support the 
        Geolocation API, tell the user.
        $('#location_pane').html
        ('&lt;p&gt;No geolocation support is available.&lt;/p&gt;');
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How it works...</h2></div></div></div><p>The Geolocation API <code class="literal">watchPosition</code> method uses a very similar syntax to the <code class="literal">getCurrentPosition</code> method we used earlier. Its parameters are the same:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A callback function to call on success</li><li class="listitem" style="list-style-type: disc">A callback function to call on failure</li><li class="listitem" style="list-style-type: disc">An array of options</li></ul></div><p>The available options, in turn, are also the same:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">enableHighAccuracy</code>: This is a Boolean value, It enables high accuracy mode (<code class="literal">default: off</code>).</li><li class="listitem" style="list-style-type: disc">timeout: This is a long value. It is the threshold beyond which the API times out (in milliseconds; the default is no limit).</li><li class="listitem" style="list-style-type: disc">maximumAge: This is a long value. It is the maximum age of a cached location that we'll accept, in milliseconds (<code class="literal">default: 0</code>).</li></ul></div><p>However, rather than initiating a single check for the user's location, it instead establishes a "watch" that will load the callback functions as appropriate whenever the device has detected that the user has moved. Because you need to reference the watch process, <code class="literal">watchPosition</code> returns an identifier.</p><p>The identifier is obtained when the method is called, as follows:</p><div><pre class="programlisting">window.watchLocationID = navigator.geolocation.watchPosition(savePosition, errorPosition, {enableHighAccuracy: true});</pre></div><p>Note that we've used the <code class="literal">enableHighAccuracy</code> option, while not failing back to a lower-accuracy location method. That's because in a situation where you're continually retrieving the location, low-quality data will not be useful. Because the device falls back to estimating location through environmental factors, visibly erroneous data may be included in your dataset, sometimes hundreds of meters or more away from the user's actual location, making it harder to track the user's path. It's better to fail if a GPS signal cannot be found.</p><p>Sometimes, the user may wish to switch tracking off, while remaining on the page. To do this, we've created a simple button. This will trigger the <code class="literal">clearWatch</code> method, which takes the watch process ID as a single parameter as follows:</p><div><pre class="programlisting">navigator.geolocation.clearWatch(window.watchLocationID);</pre></div><p>In our implementation, we've also hidden the button using the jQuery <code class="literal">hide()</code> method once it has been pressed.</p><p>Finally, our <code class="literal">savePosition</code> function, which is called whenever a new location is successfully received, must display the new location.</p><p>In our previous implementation, we simply created a variable for the new Marker object to display a single point. However, we also created a <code class="literal">window.points</code> array to keep the Marker objects that were reloaded from the database. In order to display the full set of points that are displayed as the user moves around, we'll need to add each newly created Marker in the array too.</p><p>To do this, we can just push new Marker objects to the array as follows:</p><div><pre class="programlisting">window.points.push(new google.maps.Marker({
  position: currentLocation,
  map: window.googleMap,
  title: 'Detected location'
}));</pre></div><p>However, a series of individual points isn't necessarily the best way to display this data.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>There's more...</h2></div></div></div><p>Unfortunately, at the time of writing this book, there's no way to prevent the mobile device from switching its screen and GPS unit off. Consider the following screenshot from a walk I took around the Inner Sunset neighborhood in San Francisco:</p><div><img src="img/5903_2_5.jpg" alt="There's more..."/></div><p>Contrary to what the map might indicate, this was a continuous walk—I didn't suddenly leap two blocks in a single bound! However, while I was holding my device and ensuring that its screen didn't turn black on some of the streets (indicated by the vertical lines you can see here), on the others I chose to slip my device into my pocket, as an ordinary user might. The GPS receiver was deactivated automatically when the screen went black, in order to conserve battery life. As a result, no location points were saved for these portions of my journey.</p><p>We can further enhance our application by replacing the individual points on the map with a continuous line. This would also help smooth over any gaps in the dataset.</p><p>To achieve this, we need to replace the portions of the code that set points on the map using the Google Maps API. Google provides another element, <code class="literal">PolyLines</code>, which allows you to arbitrarily add coordinates to a continuous line. I've included the complete code as <code class="literal">livepath.php</code>.</p><p>In the portion of the page where we're setting up the map, just after we've loaded the <code class="literal">jsonPoints</code> JSON array, we need to create a polyline. We'll make it bright red (HTML color <code class="literal">#ff0000</code>) so that we can see it easily:</p><div><pre class="programlisting">window.polyLine = new google.maps.Polyline({
  strokeColor: '#ff0000',
  strokeOpacity: 1.0,
  strokeWeight: 3
});</pre></div><p>Now, we'll attach it to our existing map. <code class="literal">window.polyLine</code> will be the global variable that stores the polyline:</p><div><pre class="programlisting">window.polyLine.setMap(window.googleMap);</pre></div><p>And finally, we'll establish <code class="literal">window.geopath</code> as the array of points that make up the polyline. We're saving that as a global variable too, for convenience. You'll see why momentarily.</p><div><pre class="programlisting">window.geopath = window.polyLine.getPath();</pre></div><p>Now, let's load our JSON array of previously saved points onto it:</p><div><pre class="programlisting">// If jsonPoints isn't empty, iterate through and create new map 
// points for each geolocation point
if (jsonPoints.length &gt; 0) {
  jsonPoints.forEach(function(point) {
    window.geopath.push(new google.maps.LatLng
    (
      point.latitude, point.longitude
    ))
  });
}</pre></div><p>Finally, recall the AJAX <code class="literal">done()</code> function at the top of the page, which is called once a new location has been successfully processed. We can replace the Google Maps code in this function with a simple line to add the latest coordinates to our <code class="literal">PolyLine</code>:</p><div><pre class="programlisting">// Create a marker at the user's current location and save it
// to our array of map points
window.geopath.push(new google.maps.LatLng(window.latitude, window.longitude));</pre></div><p>Now, whenever a new location is detected, it will be added to the line rather than to the map as a new, individual point.</p><p>The Geolocation API is an important addition to any modern web developer's arsenal. Together with other new APIs, HTML 5 itself and the new breed of mobile devices, the web doesn't just allow you to build high quality network applications; it allows you to build new kinds of context-aware applications that have never been created before. Happy building.</p></div></div></body></html>