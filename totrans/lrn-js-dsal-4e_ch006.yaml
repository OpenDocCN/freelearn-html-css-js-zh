- en: 5 Queues and Deques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We have explored the inner workings of **stacks**, a data structure governed
    by the *LIFO* (Last in First out) principle. Now, let's turn our attention to
    **queues**, a similar yet distinct data structure. While stacks prioritize the
    most recent additions, queues operate on a *FIFO* (First in First out) basis,
    prioritizing the earliest entries. We will delve into the mechanics of queues
    and then explore **deques**, a versatile hybrid data structure that combines elements
    of both stacks and queues. By the end of this chapter, you will have a solid understanding
    of these fundamental data structures and their practical applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The queue data structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deque data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding elements to a queue and a deque
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing elements from a queue and a deque
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating circular queues with the *Hot Potato* game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether a phrase is a palindrome with a deque
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different problems we can resolve using queues and deques
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The queue data structure
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Queues are all around us in everyday life. Think of the line to buy a movie
    ticket, the cafeteria queue at lunchtime, or the checkout line at the grocery
    store. In each of these scenarios, the underlying principle is the same: the first
    person to join the queue is the first one to be served.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Real life queue example: a group of people standing in line to
    buy a ticket](img/file23.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Real life queue example: a group of people standing in line to
    buy a ticket'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: An extremely popular example in computer science is the printing line. Let's
    say we need to print five documents. We open each document and click on the *Print*
    button. Each document will be sent to the print line. The first document that
    we asked to be printed is going to be printed first and so on, until all the documents
    are printed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of data structures, a queue is a linear collection of elements
    that adheres to the *First In, First Out* (FIFO) principle, often referred to
    as *First Come, First Served*. New elements are always added at the rear (end)
    of the queue, while removal of elements always occurs at the front (beginning).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let's put these concepts into practice by creating our own Queue class using
    JavaScript and TypeScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Queue class
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create our own class to represent a queue. The source code for
    this chapter is available inside the `src/05-queue-deque` folder on GitHub. We
    will start by creating the `queue.js` file which will contain our class that represents
    a stack using an array-based approach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will take an incremental approach to building our understanding
    of data structures. We will leverage the concepts we mastered in the previous
    chapter and gradually increase the complexity as we progress (so make sure you
    do not skip chapters). This approach will allow us to build a solid foundation
    and tackle more intricate structures with confidence.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本书中，我们将采取渐进式的方法来构建我们对数据结构的理解。我们将利用我们在上一章中学到的概念，并在我们前进的过程中逐渐增加复杂性（因此请确保您不要跳过章节）。这种方法将使我们能够建立一个坚实的基础，并自信地处理更复杂的数据结构。
- en: 'First, we will declare our `Queue` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明我们的`Queue`类：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need a data structure that will store the elements of the queue. We can use
    an array to do this as we are already familiar with the array data structure,
    and we have also learned in the previous chapter that an array-based approach
    is preferred compared to an object-based approach.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个数据结构来存储队列的元素。我们可以使用数组来完成这项工作，因为我们已经熟悉数组数据结构，并且在上一章中我们已经了解到，基于数组的方案比基于对象的方案更受欢迎。
- en: And again, we will prefix the variable `items` with the hash `#` prefix to indicate
    this property is private and can only be referenced inside the `Queue` class,
    hence, allowing us to protect the data and follow the FIFO principle when it comes
    to the insertion and removal of elements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将变量`items`前缀为哈希`#`以表示此属性是私有的，并且只能在`Queue`类内部引用，因此，允许我们在元素插入和删除时遵循FIFO原则。
- en: 'The following methods will be available in the `Queue` class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将在`Queue`类中可用：
- en: '`enqueue(item)`: This method adds a new item at the end of the queue.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enqueue(item)`: 此方法将新项目添加到队列的末尾。'
- en: '`dequeue()`: This method removes the first item from the beginning of the queue.
    It also returns the removed item.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dequeue()`: 此方法从队列的开始处移除第一个项目。它还返回被移除的项目。'
- en: '`front()`: This method returns the first element from the beginning of the
    queue. The queue is not modified (it does not remove the element; it only returns
    the element for information purposes). This is like the `peek` method from the
    `Stack` class.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`front()`: 此方法从队列的开始处返回第一个元素。队列不会被修改（它不会移除元素；它仅返回元素以供信息用途）。这就像`Stack`类中的`peek`方法。'
- en: '`isEmpty()`: This method returns `true` if the queue does not contain any elements,
    and `false` if the size of the stack is bigger than 0.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 此方法返回`true`，如果队列不包含任何元素，如果栈的大小大于0则返回`false`。'
- en: '`clear()`: This method removes all the elements of the queue.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法移除队列中的所有元素。'
- en: '`size()`: This method returns the number of elements that the queue contains.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 此方法返回队列包含的元素数量。'
- en: We will code each method in the following subsections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下小节中为每个方法编写代码。
- en: Enqueueing elements to end of the queue
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将元素入队到队列的末尾
- en: 'The first method that we will implement is the `enqueue` method. This method
    is responsible for adding new elements to the queue, with one especially important
    detail: we can only add new items at the rear of the queue as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是`enqueue`方法。此方法负责向队列中添加新元素，有一个特别重要的细节：我们只能将新项目添加到队列的末尾，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we are using an array to store the elements of the queue, we can use the
    `push` method from the JavaScript `Array` class that will add a new item to the
    end of the array. The `enqueue` method has the same implementation as the `push`
    method from the `Stack` class; from a code standpoint, we are only changing the
    name of the method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用数组来存储队列的元素，我们可以使用JavaScript `Array`类的`push`方法，该方法将新项目添加到数组的末尾。`enqueue`方法与`Stack`类中的`push`方法具有相同的实现；从代码的角度来看，我们只是在更改方法名称。
- en: Dequeuing elements from beginning of the queue
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从队列的开始处出队元素
- en: 'Next, we are going to implement the `dequeue` method. This method is responsible
    for removing the items from the queue. As the queue uses the FIFO principle, the
    item at the beginning of the queue (index 0 of our internal array) is removed.
    For this reason, we can use the `shift` method from the JavaScript `Array` class
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`dequeue`方法。此方法负责从队列中移除项目。由于队列使用FIFO原则，队列开始处的项目（我们内部数组的索引0）将被移除。因此，我们可以使用JavaScript
    `Array`类的`shift`方法，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `shift` method from the `Array` class removes the first element from an
    array and returns it. If the array is empty, `undefined` is returned and the array
    is not modified. So this works perfectly with the behavior of the queue.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The `enqueue` method has constant time complexity (*O(1)*). The `dequeue` method
    can have linear time complexity (*O(n)*), since we are using the `shift` method
    to remove the first element of an array, it can lead to *O(n)* performance in
    the worst case as the remaining elements need to be shifted down.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Peeking the element from the front of the queue
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement additional helper methods in our class. If we would
    like to know what the front element of the queue is, we can use the `front` method.
    This method will return the item that is located at the index 0 of our internal
    array:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Verifying if it is empty, the size and clearing the queue
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next methods we will create are the `isEmpty` method, `size` getter, and
    the `clear` method. These three methods have the exact same implementation as
    the `Stack` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the `isEmpty` method, we can simply verify whether the length of the internal
    array is 0.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: For the size, we create a getter for the `size` of the queue, which is simply
    the length of the internal array.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: And for the `clear` method, we can simply assign a new empty array that will
    represent an empty queue.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `toString` method, with the same code as the `Stack` class
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exporting the Queue data structure as a library class
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have created a file src/05-queue-deque/queue.js with our `Queue` class. And
    we would like to use the `Queue` class in a different file for testing for easy
    maintainability of our code (`src/05-queue-deque/01-using-queue-class.js`). How
    can we achieve this?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered this in the previous chapter as well. We will use the `module.exports`
    from `CommonJS` Module to expose our class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the Queue class
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it is time to test and use our `Queue` class! As discussed in the previous
    subsection, let''s go ahead and create a separate file so we can write as many
    tests as we like: `src/05-queue-deque/01-using-queue-class.js`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to import the code from the `queue.js` file
    and instantiate the `Queue` class we just created:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we can verify whether it is empty (the output is` true`, because we have
    not added any elements to our queue yet):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s simulate a printer''s queue. Suppose we have three documents open
    in a computer. And we click on the print button in each document. By doing so,
    it will enqueue the documents to the queue in the order the print button was clicked:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we call the `front` method, it is going to return the file `Chapter05.docx`,
    because it was the first document that was added to the queue to be printed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s also check the queue size:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s "print" all documents in the queue by dequeuing them until the queue
    is empty:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following diagram shows the dequeue operation when printing the first document
    from the queue:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了从队列中打印第一个文档时的出队操作：
- en: '![Figure 5.2: Simulation of a printer queue](img/file24.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：打印机队列的模拟](img/file24.png)'
- en: 'Figure 5.2: Simulation of a printer queue'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：打印机队列的模拟
- en: Reviewing the efficiency of our Queue class
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查我们队列类的效率
- en: 'Let''s review the efficiency of each method of our queue class by considering
    the Big O notation in terms of time of execution:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑执行时间的大 O 符号来检查队列类中每个方法的效率：
- en: '| **Method** | **Complexity** | **Explanation** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **复杂度** | **说明** |'
- en: '| `enqueue` | *O(1)* | Adding an element to the end of an array is usually
    a constant-time operation. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `enqueue` | *O(1)* | 将元素添加到数组的末尾通常是一个常数时间操作。|'
- en: '| `dequeue` | *O(n)* | Removing the first element requires shifting all remaining
    elements, taking time proportional to the queue''s size. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `dequeue` | *O(n)* | 删除第一个元素需要将所有剩余元素进行移动，所需时间与队列的大小成比例。|'
- en: '| `front` | *O(1)* | Directly accessing the first element by index is a constant-time
    operation. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `front` | *O(1)* | 通过索引直接访问第一个元素是一个常数时间操作。|'
- en: '| `isEmpty` | *O(1)* | Checking the length property of an array is a constant-time
    operation. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `isEmpty` | *O(1)* | 检查数组的长度属性是一个常数时间操作。|'
- en: '| `size` | *O(1)* | Accessing the length property is a constant-time operation.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `size` | *O(1)* | 访问长度属性是一个常数时间操作。|'
- en: '| `clear` | *O(1)* | Overwriting the internal array with an empty array is
    considered constant time. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `clear` | *O(1)* | 使用空数组覆盖内部数组被认为是常数时间操作。|'
- en: '| `toString` | *O(n)* | Iterating over the elements, potentially stringifying
    them, and joining them into a string takes time proportional to the number of
    elements. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `toString` | *O(n)* | 遍历元素，可能将它们转换为字符串，并将它们连接成一个字符串，所需时间与元素数量成比例。|'
- en: 'Table 5.1:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：
- en: The `dequeue` operation is generally the most performance-sensitive operation
    for a queue implemented using an array. This is due to the need to shift elements
    after removing the first one. There are alternative queue implementations (for
    example using a linked list, which we will cover in the next chapter, or a **circular
    queue**) that can optimize the dequeue operation to have constant time complexity
    in most cases. We will create a circular queue later in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组实现的队列中，出队操作通常是性能最敏感的操作。这是由于在删除第一个元素后需要移动元素。有其他队列实现方式（例如使用链表，我们将在下一章中介绍，或者使用**循环队列**），这些方式可以在大多数情况下将出队操作优化为常数时间复杂度。我们将在本章后面创建循环队列。
- en: The deque data structure
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双端队列数据结构
- en: The **deque** data structure, also known as the **double**-**ended queue**,
    is a special queue that allows us to insert and remove elements from the end or
    from the front of the deque.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**deque** 数据结构，也称为**双端队列**，是一种特殊的队列，允许我们从队列的末尾或前端插入和删除元素。'
- en: A deque can be used to store a user's web browsing history. When a user visits
    a new page, it is added to the front of the deque. When the user navigates back,
    the most recent page is removed from the front, and when the user navigates forward,
    a page is added back to the front.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列可以用来存储用户的网页浏览历史。当用户访问新页面时，它被添加到双端队列的前端。当用户导航回退时，最近的页面从前端被移除，而当用户导航前进时，页面被重新添加到前端。
- en: Another application would be an undo/redo feature. We learned we can use two
    stacks for this feature in the last chapter, but we can also use a deque as an
    alternative. User actions are pushed onto the deque, and undo operations pop actions
    off the front, while redo operations push them back on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用将是撤销/重做功能。我们在上一章中了解到我们可以使用两个栈来实现此功能，但我们也可以使用双端队列作为替代。用户操作被推入双端队列，撤销操作从队列前端弹出操作，而重做操作将它们推回。
- en: Creating the Deque class
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Deque 类
- en: 'As usual, we will start by declaring the `Deque` class located in the file
    `src/05-queue-deque/deque.js`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将从声明位于文件 `src/05-queue-deque/deque.js` 中的 `Deque` 类开始：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will continue using an array-based implementation for our data structure.
    And given the deque data structure allows inserting and removing from both ends,
    we will have the following methods:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用基于数组的实现来构建我们的数据结构。鉴于双端队列数据结构允许从两端插入和删除元素，我们将有以下方法：
- en: '`addFront(item)`: This method adds a new element at the front of the deque.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addFront(item)`: 此方法将新元素添加到双端队列的前端。'
- en: '`addRear(item)`: This method adds a new element at the back of the deque.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addRear(item)`: 此方法将新元素添加到双端队列的后端。'
- en: '`removeFront()`: This method removes the first element from the deque.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeFront()`: 此方法从双端队列中移除第一个元素。'
- en: '`removeRear()`: This method removes the last element from the deque.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeRear()`: 此方法从双端队列中移除最后一个元素。'
- en: '`peekFront()`: This method returns the first element from the deque.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peekFront()`: 此方法返回双端队列中的第一个元素。'
- en: '`peekRear()`: This method returns the last element from the deque.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peekRear()`: 此方法返回双端队列中的最后一个元素。'
- en: The `Deque` class also implements the `isEmpty`, `clear`, `size`, and `toString`
    methods (you can check the complete source code by downloading the source code
    bundle for this book). The code for these is the same as for the `Queue` class.
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Deque` 类还实现了 `isEmpty`、`clear`、`size` 和 `toString` 方法（你可以通过下载本书的源代码包来查看完整的源代码）。这些方法的代码与
    `Queue` 类相同。'
- en: Adding elements to the deque
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向双端队列中添加元素
- en: 'Let''s check both methods that will allow us to add elements to the front and
    to the back of the deque:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两种方法，这些方法将允许我们向双端队列的前端和后端添加元素：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `addFront` method inserts an element at index 0 of the internal array by
    using the `Array.unshift` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`addFront` 方法通过使用 `Array.unshift` 方法在内部数组的索引 0 处插入一个元素。'
- en: The `addRear` method inserts an element at the end of the deque. It has the
    same implementation as the `enqueue` method from the `Queue` class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`addRear` 方法在双端队列的末尾插入一个元素。它的实现与 `Queue` 类的 `enqueue` 方法相同。'
- en: Removing elements from the deque
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从双端队列中删除元素
- en: 'The methods to remove from both the front and the back of the deque are presented
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从双端队列的前端和后端删除元素的方法如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `removeFront` method removes and returns the element at the beginning (front)
    of the deque. If the deque is empty, it returns `undefined`. It has the same implementation
    as the `dequeue` method from the `Queue` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeFront` 方法移除并返回双端队列开头（前端）的元素。如果双端队列为空，则返回 `undefined`。它的实现与 `Queue` 类的
    `dequeue` 方法相同。'
- en: The `removeRear` method removes and returns the element at the end (rear) of
    the deque. If the deque is empty, it returns `undefined`. It has the same implementation
    as the `pop` method from the `Stack` class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeRear` 方法移除并返回双端队列末尾（后端）的元素。如果双端队列为空，则返回 `undefined`。它的实现与 `Stack` 类的
    `pop` 方法相同。'
- en: Peeking elements of the deque
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看双端队列的元素
- en: 'Finally, let''s check the peek methods as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查以下 peek 方法：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `peekFront` method allows you to look at (peek) the element at the beginning
    (front) of the deque without removing it. It has the same implementation as the
    `peek` method from the `Queue` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`peekFront` 方法允许你在不删除它的情况下查看双端队列开头（前端）的元素。它的实现与 `Queue` 类的 `peek` 方法相同。'
- en: The `peekRear` method allows you to look at (peek) the element at the end (rear)
    of the deque without removing it. It has the same implementation as the `peek`
    method from the `Stack` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`peekRear` 方法允许你在不删除它的情况下查看双端队列末尾（后端）的元素。它的实现与 `Stack` 类的 `peek` 方法相同。'
- en: Note the similarities of the implementation of the deque methods with the Stack
    and Queue classes. We can say the deque data structure is a hybrid version of
    the stack and queue data structures. Please refer to the Queue and Stack efficiency
    review to check the time complexity for these methods.
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意双端队列方法实现与 `Stack` 和 `Queue` 类的相似性。我们可以认为双端队列数据结构是栈和队列数据结构的混合版本。请参考队列和栈效率回顾，以检查这些方法的时间复杂度。
- en: Using the Deque class
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `Deque` 类
- en: 'It is time to test our Deque class (`src/05-queue-deque/03-using-deque-class.js`).
    We will use it in the scenario of a browser''s "*Back*" and "*Forward*" button
    functionality. Let''s see how this could be implemented using our Deque class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试我们的 `Deque` 类了（`src/05-queue-deque/03-using-deque-class.js`）。我们将在浏览器的 "*后退*"
    和 "*前进*" 按钮功能场景中使用它。让我们看看如何使用我们的 `Deque` 类来实现这一点：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Following is the explanation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对其的解释：
- en: A `Deque` named `history` is created to store URLs of visited pages (`{1}`).
    The `currentPage` variable keeps track of the currently displayed page (`{2}`).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `history` 的 `Deque` 来存储已访问页面的 URL（`{1}`）。`currentPage` 变量跟踪当前显示的页面（`{2}`）。
- en: The `visit(url)` method adds the new `url` to the front of the `history` deque
    (`{3}`) and updates the `currentPage` to the new URL (`{4}`).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visit(url)` 方法将新的 `url` 添加到 `history` 双端队列的前端（`{3}`），并更新 `currentPage` 为新的
    URL（`{4}`）。'
- en: 'The `goBack()` method:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goBack()` 方法：'
- en: Checks if there are at least two pages in the `history` (current and previous
    - `{5}`).
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 `history` 中是否有至少两个页面（当前和上一个 - `{5}`）。
- en: If so, it removes the current page from the front of the history deque (`{6}`).
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是这样，它将从历史双端队列的前端移除当前页面（`{6}`）。
- en: Updates `currentPage` to the now-front element, which represents the previous
    page (`{7}`).
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`currentPage`更新为现在的前端元素，它代表上一页（`{7}`）。
- en: 'The `goForward()` method:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goForward()`方法：'
- en: Checks if the `currentPage` is different from the last element in the history
    deque (meaning there is a "next" page - `{8}`).
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`currentPage`是否与历史双端队列的最后一个元素不同（意味着存在“下一页”- `{8}`）。
- en: If so, adds the current page back to the front of the history deque (`{9}`).
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是这样，将当前页面重新添加到历史双端队列的前端（`{9}`）。
- en: Removes and sets `currentPage` to the now-front element, which was the "next"
    page (`{10}`).
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除并设置`currentPage`为现在的前端元素，即“下一页”（`{10}`）。
- en: 'With our browser simulation ready, we can use it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的浏览器模拟准备就绪后，我们可以使用它：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will simulate visiting the website [https://loiane.com](https://loiane.com),
    which is the author''s blog. Next, we will visit the About page so we can add
    another URL to the browser''s history. Then, we can click on the "Back" button
    to go back to the home page. And we can also click on the "Next" button to go
    back the About page. And of course, we can peek what is the current page or the
    history as well. The following image exemplifies this simulation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟访问[https://loiane.com](https://loiane.com)，这是作者的博客。接下来，我们将访问“关于”页面，这样我们就可以将另一个URL添加到浏览器的历史记录中。然后，我们可以点击“后退”按钮回到主页。我们还可以点击“前进”按钮回到“关于”页面。当然，我们还可以查看当前页面或历史记录。以下图像展示了这个模拟：
- en: '![Figure 5.3: Simulation of a browser Back and Next buttons](img/file25.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：浏览器后退和前进按钮的模拟](img/file25.png)'
- en: 'Figure 5.3: Simulation of a browser Back and Next buttons'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：浏览器后退和前进按钮的模拟
- en: Creating the Queue and Deque classes in TypeScript
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在TypeScript中创建Queue和Deque类
- en: 'With the JavaScript implementation done, we can rewrite our Queue and Deque
    classes using TypeScript:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成JavaScript实现后，我们可以使用TypeScript重写我们的Queue和Deque类：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And the `Deque` class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`Deque`类：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will use the generics to make our data structures flexible and have items
    of only one type. The code inside the methods is the same as the JavaScript implementation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用泛型使我们的数据结构更加灵活，并使项目仅包含一种类型。方法内部的代码与JavaScript实现相同。
- en: Solving problems using queues and deques
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用队列和双端队列解决问题
- en: Now that we know how to use the `Queue` and `Deque` classes, let's use them
    to solve some computer science problems. In this section, we will cover a simulation
    of the *Hot Potato* game with queues and how to check whether a phrase is a *palindrome*
    with deques.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用`Queue`和`Deque`类，让我们用它们来解决一些计算机科学问题。在本节中，我们将介绍使用队列模拟*热土豆*游戏以及如何使用双端队列检查一个短语是否是*回文*。
- en: 'The circular queue: the Hot Potato game'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环队列：热土豆游戏
- en: The Hot Potato game is a classic children's game where participants form a circle
    and pass around an object (the "hot potato") as fast as they can while music plays.
    When the music stops, the person holding the potato is eliminated. The game continues
    until only one person remains.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 热土豆游戏是一个经典的儿童游戏，参与者围成一圈，在音乐播放时尽可能快地传递一个物体（“热土豆”）。当音乐停止时，持有土豆的人被淘汰。游戏继续进行，直到只剩下一个人。
- en: The CircularQueue class
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CircularQueue类
- en: 'We can perfectly simulate this game using a **Circular Queue** implementation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**循环队列**的实现完美地模拟这个游戏：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A circular queue is a queue implemented using a fixed-size array, meaning a
    pre-defined capacity (`{1}`), where the front (`{2}`) and rear (`{3}`) pointers
    can "wrap around" to the beginning of the array when they reach the end. This
    efficiently reuses the space in the array, avoiding unnecessary resizing. The
    `front` pointer is initialized to 0, pointing to the first element's position.
    The `rear` pointer is initialized to -1, indicating an empty queue. The `size`
    property (`{4}`) tracks the current number of elements in the queue.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 循环队列是使用固定大小数组实现的队列，意味着一个预定义的容量（`{1}`），其中前端（`{2}`）和后端（`{3}`）指针可以在达到数组末尾时“环绕”到数组的开始。这有效地重用了数组空间，避免了不必要的调整大小。`front`指针初始化为0，指向第一个元素的位置。`rear`指针初始化为-1，表示一个空队列。`size`属性（`{4}`）跟踪队列中的当前元素数量。
- en: When we create a circular queue, we need to inform how many elements we are
    planning to store (`{5}`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建循环队列时，我们需要告知我们计划存储多少个元素（`{5}`）。
- en: 'Let''s review the `enqueue` and `isFull` methods next:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来回顾`enqueue`和`isFull`方法：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before we add any elements to queue, we need to check if it is not full, meaning
    the size is the same as the capacity (`{6}`). With a fixed capacity, this makes
    the circular queue predictable in terms of memory usage, but this can also be
    viewed as a limitation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在向队列添加任何元素之前，我们需要检查它是否未满，这意味着大小与容量相同（`{6}`）。由于容量固定，这使得循环队列在内存使用方面可预测，但这也可能被视为一种限制。
- en: If the queue is not full, we increment the `rear` pointer by 1\. The key point
    here is to use the modulo operator (`%`) to wrap rear back to 0 if it reaches
    the end of the array (`{7}`). Then we insert the item at the new rear position
    (`{8}`) and increment the size counter (`{9}`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列未满，我们将`rear`指针增加1。这里的关键点是使用取模运算符（`%`）将`rear`回绕到0，如果它达到数组的末尾（`{7}`）。然后我们在新的`rear`位置插入项，并增加大小计数器（`{9}`）。
- en: 'Finally, we have the `dequeue` and `isEmpty` methods:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`dequeue`和`isEmpty`方法：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To remove the item at the front of the queue, first, we need to check the queue
    size (`{10}`). If the queue is not empty, we can retrieve the item that is currently
    stored at the front position (`{11}`) so we can return it later (`{16}`). Then,
    we decrement the size counter (`{12}`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除队列前端的项，首先需要检查队列大小（`{10}`）。如果队列不为空，我们可以检索当前存储在队列前端位置的项（`{11}`），以便稍后返回（`{16}`）。然后，我们减少大小计数器（`{12}`）。
- en: If the queue is not empty after dequeuing, we need to increment the `front`
    pointer by 1 and wrap around it using the modulo operator (`{15}`). If the queue
    is empty after dequeuing, we reset both `front` (`{13}`) and `rear` (`{14}`) pointers
    to their initial values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出队后队列不为空，我们需要通过取模运算符（`{15}`）将`front`指针增加1并回绕。如果出队后队列为空，我们将`front`（`{13}`）和`rear`（`{14}`）指针重置为其初始值。
- en: The biggest advantage of the circular queue is both enqueueing and dequeuing
    operations are generally *O(1)* (constant time) due to direct manipulation of
    pointers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 循环队列最大的优点是入队和出队操作通常都是*O(1)*（常数时间），这是由于直接操作指针。
- en: The Hot Potato game simulation
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 热土豆游戏模拟
- en: 'With the new class ready to be used, let''s put it in practice the Hot Potato
    game simulation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类已经准备好使用，让我们将其应用于热土豆游戏的模拟：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function takes an array of players and a number `num` representing the
    number of times the "potato" is passed before a player is eliminated and it returns
    the winner.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个玩家数组和一个表示“土豆”传递次数的数字`num`，在玩家被淘汰之前，它返回获胜者。
- en: First, we create a circular queue (`{1}`) with the numbers of players and we
    enqueue all players (`{2}`).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含玩家数量的循环队列（`{1}`），并将所有玩家入队（`{2}`）。
- en: 'We run a loop until only one player remains (`{3}`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行循环直到只剩下一个玩家（`{3}`）：
- en: Another loop will pass the potato `numPasses` times (`{4}`) by dequeueing and
    then re-enqueueing the same player (`{5}`).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个循环将土豆通过出队然后重新入队的方式传递给同一个玩家`numPasses`次（`{4}`）。
- en: The player at the front is removed and announced as eliminated (`{6}`).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端的玩家被移除并宣布淘汰（`{6}`）。
- en: The last remaining player is dequeued and declared the winner (`{7}`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后剩下的玩家被出队并宣布为获胜者（`{7}`）。
- en: 'We can use the following code to try the `hotPotato` algorithm:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来尝试`hotPotato`算法：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The execution of the algorithm will have the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的执行将产生以下输出：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This output is simulated in the following diagram:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的模拟图：
- en: '![Figure 5.4: The Hot Potato game simulation using circular queue](img/file26.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：使用循环队列的热土豆游戏模拟](img/file26.png)'
- en: 'Figure 5.4: The Hot Potato game simulation using circular queue'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：使用循环队列的热土豆游戏模拟
- en: You can change the number of passes using the `hotPotato` function to simulate
    different scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`hotPotato`函数更改传递次数来模拟不同的场景。
- en: Palindrome checker
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回文检查器
- en: 'The following is the definition of a **palindrome** according to Wikipedia:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是根据维基百科的定义的**回文**：
- en: '*A palindrome is a word, phrase, number, or other sequence of characters which
    reads the same backward as forward, such as madam or racecar.*'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*回文是一个单词、短语、数字或其他字符序列，它从后向前读与从前向后读相同，例如madam或racecar。*'
- en: 'There are different algorithms we can use to verify whether a phrase or string
    is a palindrome. The easiest way is reversing the string and comparing it with
    the original string. If both strings are equal, then we have a palindrome. We
    can also use a stack to do this, but the easiest way of solving this problem using
    a data structure is using a deque: characters are added to the deque, and then
    removed from both ends simultaneously. If the removed characters match throughout
    the process, the string is a palindrome.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的算法来验证一个短语或字符串是否是回文。最简单的方法是将字符串反转并与原始字符串比较。如果两个字符串相等，那么我们有一个回文。我们也可以使用一个栈来做这件事，但使用数据结构解决此问题的最简单方法是使用双端队列：字符被添加到双端队列中，然后从两端同时移除。如果在整个过程中移除的字符匹配，则字符串是回文。
- en: 'The following algorithm uses a deque to solve this problem:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法使用双端队列来解决这个问题：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before we start with the algorithm logic, we need to verify whether the string
    that was passed as a parameter is valid with the edge cases (`{1}`). If it is
    not valid, then we return `false` because an empty string or non-existent word
    cannot be considered a palindrome.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始算法逻辑之前，我们需要验证传递给参数的字符串是否有效，包括边缘情况（`{1}`）。如果它无效，那么我们返回`false`，因为空字符串或不存在的单词不能被认为是回文。
- en: We will use the Deque class we implemented in this chapter (`{2}`). As we can
    receive a string with both lowercase and capital letters, we will transform all
    letters to lowercase, and we will also remove all the spaces (`{3}`). If you want
    to, you can also remove all special characters such as !?-() and so on. To keep
    this algorithm simple, we will skip this part. Next, we will enqueue all characters
    of the string to the deque (`{4}`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章实现的`Deque`类（`{2}`）。由于我们可以接收包含小写和大写字母的字符串，我们将所有字母转换为小写，并且我们还将删除所有空格（`{3}`）。如果您愿意，您还可以删除所有特殊字符，例如!?-()等。为了使此算法简单，我们将跳过这部分。接下来，我们将字符串的所有字符入队到双端队列（`{4}`）。
- en: While we have at least two elements in the deque (`{5}` - if only one character
    is left, it is a palindrome), we will remove one element from the front and one
    from the back (`{6}`). To be a palindrome, both characters removed from the deque
    need to match. If the characters do not match, then the string is not a palindrome
    (`{7}`).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当双端队列（`{5}` - 如果只剩下一个字符，它就是回文）中至少有两个元素时，我们将从前面和后面各移除一个元素（`{6}`）。为了成为回文，从双端队列中移除的两个字符需要匹配。如果字符不匹配，那么字符串就不是回文（`{7}`）。
- en: 'We can use the following code to try the `isPalindrome` algorithm:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来尝试`isPalindrome`算法：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Exercises
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We will resolve an exercise from **LeetCode** using the concepts we learned
    in this chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章学到的概念解决**LeetCode**的一个练习。
- en: Number of Students Unable to Eat Lunch
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无法吃午餐的学生数量
- en: The exercise we will resolve is the *1700\. Number of Students Unable to Eat
    Lunch* problem available at [https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/](https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决的练习是可在[https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/](https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/)找到的*1700.
    无法吃午餐的学生数量*问题。
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function countStudents(students: number[],
    sandwiches: number[]): number {}`, which receives a queue of `students` that would
    prefer to eat a sandwich 0 or 1 and a stack of `sandwiches`, which will have the
    same size.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用JavaScript或TypeScript解决问题时，我们将在`function countStudents(students: number[],
    sandwiches: number[]): number {}`函数内部添加我们的逻辑，该函数接收一个队列`students`，这些学生愿意吃0或1个三明治，以及一个三明治的堆，它们将具有相同的大小。'
- en: 'This is a simulation exercise, according to the problem''s description:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模拟练习，根据问题描述：
- en: If the student at the front of the queue prefers the sandwich on the top of
    the stack, they will take it and leave the queue.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果排在队首的学生喜欢栈顶的三明治，他们将取走它并离开队伍。
- en: Otherwise, they will leave it and go to the queue's end.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，他们将留下它并走到队伍的末尾。
- en: This continues until none of the queue students want to take the top sandwich
    and are thus unable to eat.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将继续，直到没有队列中的学生想要取走顶部的三明治，因此无法吃午餐。
- en: The key to resolve this problem is to also treat the stack of sandwiches as
    a queue (*FIFO*) instead of a stack (*LIFO*).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的关键是将三明治的堆也视为一个队列（*FIFO*）而不是一个栈（*LIFO*）。
- en: 'Let''s write the `countStudents` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`countStudents`函数：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The while loop keeps running as long as there are students in the queue (`{1}`).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列为空时，while 循环会继续运行（`{1}`）。
- en: If the first student's preference(`students[0]`) matches (`{2}`) the sandwich
    at the front (top sandwich `sandwiches[0]`), both the student (`{3}`) and sandwich
    (`{4}`) are removed from the front of their respective queues.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个学生的偏好（`students[0]`）与（`{2}`）队列前部的三明治（顶部三明治 `sandwiches[0]`）相匹配，那么学生（`{3}`）和三明治（`{4}`）都会从各自队列的前端移除。
- en: If there is not a match, we check for potential match using the `includes` method
    from the JavaScript `Array` class to see if any student in the queue would take
    the current top sandwich (`{5}`). If there is a potential match, the current student
    (`{6}`) is moved to the back of the queue (`{7}`).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配，我们使用 JavaScript `Array` 类的 `includes` 方法检查潜在的匹配，看看队列中的任何学生是否愿意接受当前顶部的三明治（`{5}`）。如果有潜在的匹配，当前学生（`{6}`）会被移动到队列的末尾（`{7}`）。
- en: If there is no one left in line who wants the current sandwich, the loop breaks
    (`{8}`). This indicates that the remaining students will not be able to eat.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列中没有剩下想要当前三明治的人，循环会中断（`{8}`）。这表明剩余的学生将无法吃到三明治。
- en: The function returns the length of the `students` array. This length represents
    the number of students still in line who could not get a sandwich they liked.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回 `students` 数组的长度。这个长度代表了仍然在队列中等待且未能得到他们喜欢三明治的学生数量。
- en: This solution passes all the tests and resolves the problem. The `includes`
    check (`{5}`) is important for efficiency. Without it, the code would unnecessarily
    rotate the queue even when no student would want the top sandwich, so we get bonus
    points, although this method is not native for a queue data structure.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案通过了所有测试并解决了问题。`includes` 检查（`{5}`）对于效率很重要。如果没有它，代码会在没有任何学生想要顶部的三明治时无谓地旋转队列，因此我们得到了额外的分数，尽管这种方法并不是队列数据结构的标准做法。
- en: The time and space complexity of this function is *O(nˆ2)*, where *n* is the
    number of `students`. This is because the outer loop runs until there are no students
    left, which in the worst case is *n* iterations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的时间复杂度和空间复杂度是 *O(n²)*，其中 *n* 是学生数量。这是因为外层循环会一直运行，直到没有学生为止，在最坏的情况下需要 *n* 次迭代。
- en: 'Inside the loop, there are two operations that can be costly: `students.shift()`,
    which is *O(n)*, and `students.includes(sandwiches[0])`, which is also *O(n)*.
    Since these operations are nested inside the loop, the total complexity is *O(nˆ2)*.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，有两个可能代价高昂的操作：`students.shift()`，其复杂度为 *O(n*)，以及 `students.includes(sandwiches[0])`，其复杂度也是
    *O(n*)。由于这些操作嵌套在循环内部，总复杂度是 *O(n²)*。
- en: The space complexity is *O(1)*, not counting the space needed for the input
    arrays. This is because the function only uses a fixed amount of additional space
    to store the `num` variable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度是 *O(1)*，不包括输入数组所需的额外空间。这是因为该函数仅使用固定数量的额外空间来存储 `num` 变量。
- en: Can you think of a more optimized approach to resolve this problem that might
    not involve the queue data structure? During technical interviews, it is important
    to also think about optimizations. Give it a try, and you will find the solution
    along with the explanation in the source code, along with the *2034\. Time Needed
    to Buy Tickets* problem resolution as well.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你能想到一个更优化的方法来解决这个问题，可能不涉及队列数据结构吗？在技术面试中，考虑优化也很重要。尝试一下，你将在源代码中找到解决方案以及解释，包括 *2034.
    买票所需时间* 问题解决方案。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the fundamental concept of queues and their
    versatile cousin, the deque. We crafted our own queue algorithm, mastering the
    art of adding (enqueue) and removing (dequeue) elements in a first-in, first-out
    (FIFO) manner. Exploring the deque, we discovered its flexibility in inserting
    and deleting elements from both ends, expanding the possibilities for creative
    solutions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了队列的基本概念及其多才多艺的表亲，双端队列（deque）。我们自行设计了一个队列算法，掌握了以先进先出（FIFO）的方式添加（入队）和移除（出队）元素的艺术。在探索双端队列时，我们发现其从两端插入和删除元素时的灵活性，这为创造性的解决方案提供了更多可能性。
- en: To solidify our understanding, we applied the knowledge to real-world scenarios.
    We simulated the classic Hot Potato game, leveraging a circular queue to model
    its cyclical nature. Additionally, we created a palindrome checker, demonstrating
    the deque's power in handling data from both directions. We also tackled a simulation
    challenge from LeetCode, reinforcing the practical applications of queues in problem-solving.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们的理解，我们将知识应用于现实世界的场景。我们模拟了经典的“热土豆”游戏，利用循环队列来模拟其循环性质。此外，我们还创建了一个回文检查器，展示了双端队列在处理来自两个方向的数据时的强大功能。我们还解决了来自LeetCode的模拟挑战，强化了队列在问题解决中的实际应用。
- en: Now, with a firm grasp of these linear data structures (arrays, stacks, queues
    and deques), we are ready to venture into the dynamic world of linked lists in
    the next chapter, where we will unlock even greater potential for complex data
    manipulation and management.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已牢固掌握了这些线性数据结构（数组、栈、队列和双端队列），我们准备进入下一章动态链表的世界，在那里我们将解锁更复杂的数据操作和管理潜力。
