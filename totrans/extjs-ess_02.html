<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Mastering the Framework's Building Blocks"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Mastering the Framework's Building Blocks</h1></div></div></div><p>The Ext JS class system forms the basis of the framework and provides us with an object-oriented structure to construct our applications. This chapter will introduce the fundamentals of the class system, and how we can use it to define the building blocks of our applications.</p><p>We will discuss the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How basic object-oriented principles, such as inheritance, are used</li><li class="listitem" style="list-style-type: disc">How to dynamically load our classes with the Ext.Loader class</li><li class="listitem" style="list-style-type: disc">How to override class methods</li><li class="listitem" style="list-style-type: disc">How to use Ext JS' configuration model</li></ul></div><div class="section" title="Defining classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Defining classes</h1></div></div></div><p>Our<a id="id45" class="indexterm"/> application's first class will be a configuration class to hold various options for our application. We define a class using the <code class="literal">Ext.define</code> method as shown here:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
},
function(){
  console.log('Config class created');
});</pre></div><p>The first parameter is a string defining the class' name, the second, an object containing all the class' members, and the third is an optional callback function, executed when the class has been defined.</p><p>Class names must follow a strict naming convention so that they can be auto loaded by the <code class="literal">Ext.Loader</code> class. This class automatically loads classes when they are needed and uses their fully qualified name to find them within the directory structure.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first part of our class name—<code class="literal">BizDash</code>—is our application's name and is our root namespace. This is mapped, by default, to the app folder inside our application folder.</li><li class="listitem" style="list-style-type: disc">The second part—<code class="literal">config</code>—is our class' subnamespace and is used to organize our classes into folders. This name maps to a subfolder inside the <code class="literal">app</code> folder. We can create namespaces to any depth we wish, to allow us to organize our code in a way that makes sense for the application.</li><li class="listitem" style="list-style-type: disc">Finally, <code class="literal">Config</code> is the name of our class and forms the file name where our class definition will live.</li></ul></div><p>The <a id="id46" class="indexterm"/>following screenshot shows how our fully qualified class name equates to its directory structure:</p><div class="mediaobject"><img src="graphics/6626_02_01.jpg" alt="Defining classes"/></div><p>The standard Sencha naming convention outlines that all subnamespaces should be lowercase, with all class names being upper camel case. For example, <code class="literal">BizDash.view.users.UserForm</code> is preferred over <code class="literal">BizDash.view.Users.userForm</code>.</p><p>We will now instantiate this class using the <code class="literal">Ext.create</code> method. This method accepts a class' fully qualified name and an object whose properties and values will be used to configure the class. We will talk about how to add our own configuration options later in this chapter.</p><p>Open the <a id="id47" class="indexterm"/>application in a web browser and run the following code in the Developer Tools' console:</p><div class="informalexample"><pre class="programlisting">Ext.create('BizDash.config.Config', {});</pre></div><p>Upon running the code, we should see a console similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/6626_02_02.jpg" alt="Defining classes"/></div><p>In the screenshot, we can see three things:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The source file loaded into the page automatically via a <code class="literal">GET</code> request</li><li class="listitem">The console log from the <code class="literal">Ext.define</code> callback</li><li class="listitem">Our new class instance logged in the console</li></ol></div><p>You will have noticed that we were able to instantiate our <code class="literal">BizDash.config.Config</code> class without ever referencing it in our application or HTML page. This is taken care of by the magic of the <code class="literal">Ext.Loader</code> class, which we will talk about next.</p></div></div>
<div class="section" title="The magic behind Ext.Loader"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>The magic behind Ext.Loader</h1></div></div></div><p>In the <a id="id48" class="indexterm"/>last section, we saw an example of how class source files can be automatically loaded into the application as and when they are needed. This is taken care of by the <code class="literal">Ext.Loader</code> class, which analyzes the dependencies of each class defined and ensures every reliant class is loaded in via AJAX. For more details on how this relates to creating production builds, see the <span class="emphasis"><em>Creating our application with Sencha Cmd</em></span> section of <a class="link" href="ch01.html" title="Chapter 1. Getting to Know Ext JS">Chapter 1</a>, <span class="emphasis"><em>Getting to Know Ext JS</em></span>.</p><div class="section" title="The class definition process"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>The class definition process</h2></div></div></div><p>The<a id="id49" class="indexterm"/> following diagram shows the process of how a class is defined, starting with the <code class="literal">Ext.define</code> method call, and how the <code class="literal">Loader</code> class fits into this process:</p><div class="mediaobject"><img src="graphics/6626_02_03.jpg" alt="The class definition process"/></div></div><div class="section" title="Defining dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Defining dependencies</h2></div></div></div><p>The best <a id="id50" class="indexterm"/>way to ensure that all necessary classes have loaded into the page is to build a dependency tree using the <code class="literal">requires</code> configuration option. This option accepts an array of fully qualified class names, which are then all loaded into the page before the class definition is deemed complete. Upon loading a dependent class, the process is repeated with the new class where all of its dependencies are loaded until all required classes are present.</p><p>We can extend our <code class="literal">Config</code> class by introducing a dependency in a new class called <code class="literal">BizDash.config.Constants</code>:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Constants', {
},
function(){
  console.log('BizDash.config.Constants defined.');
});</pre></div><p>We want our <code class="literal">Config</code> class to make use of this class, so we must ensure it is available to be instantiated when the class is defined. We do this by adding the <code class="literal">requires</code> configuration to the class definition, telling the framework to load it in automatically:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
  requires: ['BizDash.config.Constants']
},
function(){
  console.log('BizDash.config.Config defined');
});</pre></div><p>With <a id="id51" class="indexterm"/>this line in place, we can use <code class="literal">Ext.create</code> to instantiate our class again and see the <code class="literal">Constants</code> class being loaded in automatically:</p><div class="informalexample"><pre class="programlisting">Ext.create('BizDash.config.Config', {});</pre></div><div class="mediaobject"><img src="graphics/6626_02_04.jpg" alt="Defining dependencies"/></div></div><div class="section" title="Loader paths"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Loader paths</h2></div></div></div><p>By<a id="id52" class="indexterm"/> default, the root namespace of an app (in our case <code class="literal">BizDash</code>) is mapped to the <code class="literal">app</code> folder. This means that any subnamespace is mapped directly to a folder inside the <code class="literal">app</code> folder and the class name to the JavaScript file itself. It is important to keep to these naming conventions so that these source files can be found.</p><p>If you want to have the application load files from a different location, you can specify a custom path and namespace convention for the loader to follow, by adding a call to the <code class="literal">Ext.Loader.setConfig</code> method to the top of your <code class="literal">Application.js</code> file.</p><p>The <a id="id53" class="indexterm"/>default <code class="literal">paths</code> object map <code class="literal">Ext</code> and the application namespace, as the following snippet shows:</p><div class="informalexample"><pre class="programlisting">Ext.Loader.setConfig({
  paths: {
    Ext     : '../ext/src',
    BizDash : 'app'
  }
});</pre></div><p>You can customize this by adding your own namespace as the key (this can be more than one portion of a namespace; for example, <code class="literal">Custom.namespace</code>), and the path to the correct folder as the value:</p><div class="informalexample"><pre class="programlisting">Ext.Loader.setConfig({
  paths: {
    Ext             : '../ext/src',
    BizDash         : 'app',
    'Custom.path'   : '..CustomClasses/path'
  }
});</pre></div></div><div class="section" title="Ext.Loader and Sencha Cmd"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Ext.Loader and Sencha Cmd</h2></div></div></div><p>As <a id="id54" class="indexterm"/>we have seen, Sencha Cmd can concatenate all the<a id="id55" class="indexterm"/> required class files into a single file. This is achieved by producing this dependency graph and combining all the source files in the order that they are loaded when launching the application. This ensures that only the classes that are actually used are included in the application's final source file, making it much smaller than if the entire framework were always included.</p></div><div class="section" title="Our dependency root"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Our dependency root</h2></div></div></div><p>In our<a id="id56" class="indexterm"/> examples, we have forced our <code class="literal">Config</code> to be loaded via the <code class="literal">Ext.create</code> call, which synchronously loads the source file. By relying on this to load class files, the dependency tree is only established and fulfilled during runtime. This will mean Sencha Cmd will be unable to create a fully concatenated source file and will be forced to load missing classes at runtime.</p><p>To combat this, we should include our root classes as required classes in the <code class="literal">Application.js</code> file. This file is the entry point for the application, so from here we can establish the dependency graph all the way to the extremities, before the app is launched.</p><p>To ensure our <code class="literal">BizDash.config.Config</code> class is loaded and ready for use upon application launch, we would add it inside a <code class="literal">requires</code> array in the <code class="literal">Application.js</code> file:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.Application', {
  extend: 'Ext.app.Application',
  name: 'BizDash',
  requires: [ 'BizDash.config.Config' ],
  ...
});</pre></div></div></div>
<div class="section" title="Adding class members"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Adding class members</h1></div></div></div><p>So far, we <a id="id57" class="indexterm"/>have looked at defining and creating classes and getting these classes loaded into our page. We will now explore how to make them useful by adding class members such as properties, methods, and statics.</p><div class="section" title="Properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Properties</h2></div></div></div><p>Public<a id="id58" class="indexterm"/> properties can be added to a class by including a key-value pair to the class' definition object. The following code example shows how we add a version number property to our <code class="literal">Config</code> class:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
  requires: ['BizDash.config.Constants'],
  version: '0.0.1-0'
},
  function(){
  console.log('BizDash.config.Config defined');
});</pre></div><p>This property can be accessed by simply using the dot notation in an instance of the <code class="literal">Config</code> class; for example:</p><div class="informalexample"><pre class="programlisting">var config = Ext.create('BizDash.config.Config', {});
// logs 0.0.1-0 console.log(config.version);</pre></div></div><div class="section" title="Methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Methods</h2></div></div></div><p>Methods<a id="id59" class="indexterm"/> can be added in an identical way to properties. We can add a <code class="literal">getBuildNumber</code> method to the <code class="literal">Config</code> class, which will extract the build number from the version property, as shown here:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
  requires: ['BizDash.config.Constants'],
  version: '0.0.1-0',
  getBuildNumber: function(){
    var versionSplit = this.version.split('-');
    return versionSplit[1];
  }
},
function() {
  console.log('BizDash.config.Config defined');
});</pre></div><p>This method can be executed in the normal way:</p><div class="informalexample"><pre class="programlisting">// logs "0"
  console.log(config.getBuildNumber());</pre></div><p>Note that by default, the methods are executed in the scope of the class instance, allowing us to access the version property.</p></div><div class="section" title="Statics"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Statics</h2></div></div></div><p>The<a id="id60" class="indexterm"/> Ext JS class system provides us with the ability to include static properties and methods to our classes to remove the need to create class instances. These can be added inside an object assigned to the <code class="literal">statics</code> configuration option.</p><p>The following example shows a static property called <code class="literal">ENVIRONMENT</code> added to the <code class="literal">BizDash.config.Constants</code> class to track if we are in a development or production environment:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Constants', {
  statics: {
    ENVIRONMENT: 'DEV'
  }
},
function(){
  console.log('BizDash.config.Constants defined.');
});</pre></div><p>We can <a id="id61" class="indexterm"/>now access this static property using the following code:</p><div class="informalexample"><pre class="programlisting">// logs "DEV"
console.log(BizDash.config.Constants.ENVIRONMENT);</pre></div><p>Ext JS' naming conventions says that static property names should always be in uppercase.</p></div><div class="section" title="Statics in subclasses"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Statics in subclasses</h2></div></div></div><p>If you <a id="id62" class="indexterm"/>would like your class' static properties to be available in any subclasses, then they must be defined using the <code class="literal">inheritableStatics</code> property.</p></div><div class="section" title="Singletons"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Singletons</h2></div></div></div><p>As an <a id="id63" class="indexterm"/>alternative to using static methods, classes can be defined as singletons, which will, after successful definition, instantiate the class and assign it back to the class property. This can be done by simply adding the <code class="literal">singleton: true</code> configuration to the class:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
<span class="strong"><strong>  singleton: true, </strong></span>
  ...
},
function() {
  console.log('BizDash.config.Config defined');
  // logs "true"
  console.log(BizDash.config.Config.isInstance);
});</pre></div><p>The logging of the <code class="literal">isInstance</code> property, which is available in all class instances, shows that once defined, the <code class="literal">BizDash.config.Config</code> property is now an instance of the class.</p></div></div>
<div class="section" title="Extending classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Extending classes</h1></div></div></div><p>The<a id="id64" class="indexterm"/> Ext JS framework's architecture means the functionality is built up and shared using inheritance. It is extremely easy to have one of our custom classes or views inherit from another or from an existing framework class.</p><p>For example, when defining your view classes, you will likely extend from the base <code class="literal">Ext.Component</code> class or from one of its subclasses, such as <code class="literal">Ext.panel.Panel</code> or <code class="literal">Ext.grid.Panel</code>.</p><p>We<a id="id65" class="indexterm"/> define our class' superclass by including the <code class="literal">extend</code> configuration and giving it the name of the class to extend. In the following example, we will extend our <code class="literal">Config</code> class from the <code class="literal">Ext.util.Observable</code> class, allowing it to raise its own custom events. This will give our <code class="literal">Config</code> class access to all of the methods and properties of this class, such as the <code class="literal">on</code> method:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
  extend: 'Ext.util.Observable',
  ...
}, function() {
  // logs "function(){..}"
  console.log(BizDash.config.Config.on);
});</pre></div><p>The Ext JS documentation shows the inheritance tree of each class at the top right of its documentation page, as shown here, for the <code class="literal">Ext.panel.Panel</code> class:</p><div class="mediaobject"><img src="graphics/6626_02_05.jpg" alt="Extending classes"/></div><p>When omitted, as in our original <code class="literal">Config</code> class, the class will extend from the <code class="literal">Ext.Base</code> class by default, which is the root base class for all of the framework's classes.</p></div>
<div class="section" title="Overriding classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Overriding classes</h1></div></div></div><p>It is<a id="id66" class="indexterm"/> sometimes necessary to change the functionality of a class without directly modifying the original source. We can do this by defining a new class along with the <code class="literal">overrides</code> configuration option to tell Ext JS which class to modify.</p><p>This technique should always be used when altering the framework behavior (for example, to fix a bug in the framework's code) as the Ext JS code should never be modified directly. This will come back to bite you when making framework upgrades in the future.</p><p>In the<a id="id67" class="indexterm"/> following example, we will override our <code class="literal">getBuildNumber</code> method so that it returns the build number with a prefix of <span class="strong"><strong>Build Number:</strong></span>. You will have seen that Sencha Cmd has already created an <code class="literal">overrides</code> folder in our application structure. This is where we will put our class override files.</p><p>Inside this folder, we create a new <code class="literal">config</code> directory to mirror our main app folder structure and define a new class named <code class="literal">Overrides.config.Config</code> in a file called <code class="literal">Config.js</code>.</p><div class="mediaobject"><img src="graphics/6626_02_06.jpg" alt="Overriding classes"/></div><p>The <code class="literal">override</code> follows the same structure as a normal class definition, as shown here:</p><div class="informalexample"><pre class="programlisting">Ext.define('Overrides.config.Config', {
    override: 'BizDash.config.Config',
});</pre></div><p>We can now add in our override for the <code class="literal">getBuildNumber</code> method, which uses the <code class="literal">callParent</code> method to execute the original method and combine its output with our label:</p><div class="informalexample"><pre class="programlisting">Ext.define('Overrides.config.Config', {
  override: 'BizDash.config.Config',
  getBuildNumber: function() {
    return 'Build Number: ' + this.callParent(arguments);
  }
});</pre></div><div class="section" title="Requiring our override class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Requiring our override class</h2></div></div></div><p>There is one<a id="id68" class="indexterm"/> extra step required to include this override in our app and for the changes to take effect. We must tell the application where our override classes reside so <code class="literal">Ext.Loader</code> knows where to find them. We do this by adding the <code class="literal">overrides</code> path to our <code class="literal">sencha.cfg</code> file so that Sencha Cmd can update the app's dependencies. We do this by adding the following line to the bottom of the <code class="literal">BizDash/.sencha/app/sencha.cfg</code> file:</p><div class="informalexample"><pre class="programlisting">app.overrides=${app.dir}/overrides</pre></div><p>We can then run the <code class="literal">sencha app refresh</code> command from within the <code class="literal">BizDash</code> folder to regenerate the app's bootstrap files.</p><p>If we now reload our application and call the <code class="literal">getBuildNumber</code> method, we should see the output as <span class="strong"><strong>Build Number: 0</strong></span>.</p><div class="mediaobject"><img src="graphics/6626_02_07.jpg" alt="Requiring our override class"/></div><p>Although this override is overriding one of our own custom methods, an identical process can be followed to override any of the framework's own classes whose behavior you would like to change.</p></div><div class="section" title="Targeting overrides to framework versions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Targeting overrides to framework versions</h2></div></div></div><p>It is now <a id="id69" class="indexterm"/>possible to target overrides to specific framework or package versions by using the compatibility configuration. This can accept a single string containing a version number, an array of version strings that will be matched with an OR operator, or an object using the <code class="literal">and</code> or <code class="literal">or</code> keys to create more complex matches. The following examples show how these can be used:</p><div class="informalexample"><pre class="programlisting">/* matches Ext JS 5.0.0 compatibility: '5.0.0'
matches Ext JS 5.0.0 OR Ext JS 4.2.1 compatibility: ['5.0.0', '4.2.1']
matches the 'Ext JS' package with 5.0.0 and 'Sencha Core' with 5.0.0 */
compatibility: {
  and: [
    'extjs@5.0.0',
    'sencha-core@5.0.0'
  ]
}</pre></div><p>If the compatibility option is a match, then the override is included; otherwise it is not.</p><p>For full<a id="id70" class="indexterm"/> details of what version expressions can be used, see the documentation on the <code class="literal">Ext.checkVersion</code> method. <a class="ulink" href="http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion">http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion</a>.</p></div></div>
<div class="section" title="Configuring classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Configuring classes</h1></div></div></div><p>Ext JS offers <a id="id71" class="indexterm"/>us a useful way of creating configurable properties, which gives us an autogenerated process to get and set their values, and also to perform any updates required in other areas; for example, reflecting the updated value in the UI.</p><p>When a class is defined, any properties found in the <code class="literal">config</code> object become completely encapsulated from other class members and are given their own getter and setter methods.</p><p>For example, if we move our <code class="literal">Config</code> class' <code class="literal">version</code> property into a <code class="literal">config</code> object, as shown in the following code snippet, the class will be given two new methods named <code class="literal">getVersion</code> and <code class="literal">setVersion</code>. Notice that we must create a <code class="literal">constructor</code> function and call the <code class="literal">initConfig</code> method to have the class system initialize these new methods. We also must update our <code class="literal">getBuildNumber</code> method, which references the version number using <code class="literal">this.version</code>, to use the new getter method <code class="literal">getVersion</code>.</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
  extend: 'Ext.util.Observable',
  singleton: true,
  requires: ['BizDash.config.Constants'],
  config: { version: '0.0.1-0' },
  constructor: function(config){
    this.initConfig(config);
    this.callParent([config]);
  },
  getBuildNumber: function() {
    var versionSplit = this.getVersion().split('-');
    return versionSplit[1];
  }
}, function() {
  ...
});</pre></div><p>In Ext JS 5, the call to <code class="literal">initConfig</code> is now not required when extending the <code class="literal">Ext.Component</code> class or one of its subclasses, as it is called internally.</p><div class="section" title="Setting a configuration value"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Setting a configuration value</h2></div></div></div><p>When <a id="id72" class="indexterm"/>giving the <code class="literal">config</code> option a new value, the generated setter method goes through a more complex process than just assigning the given value to a property in the class. It introduces the concept of <code class="literal">applier</code> and <code class="literal">updater</code> methods, which are optional and, if present, called in turn within the setter method.</p><p>The applier function should be named with the same convention as the getter and setter, with the name being prefixed with <code class="literal">apply</code> and the property name's first letter in uppercase; for example, <code class="literal">applyVersion</code>. This method is used to transform the given value as required before it is stored in the class. Potential usage may be to perform a lookup of the value to get its real instance (for example, a store instance from its ID). This method must return a value; otherwise the property won't be updated.</p><p>The updater <a id="id73" class="indexterm"/>function follows the same naming pattern (for example, <code class="literal">updateVersion</code>) and is called after the value has been transformed with the applier and set in the class. This function is primarily used to update the UI to reflect the latest value within a component.</p><p>The following diagram shows how this process works when calling the generated setter method:</p><div class="mediaobject"><img src="graphics/6626_02_08.jpg" alt="Setting a configuration value"/></div><p>The following example shows how we use and apply the method to ensure the format of the version number; and an update method to raise a custom event, allowing other areas of the app to be notified of the change:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
  extend: 'Ext.util.Observable',
  singleton: true,
  requires: ['BizDash.config.Constants'],
  config: {
    version: '0.0.1-0',
    ...
  },
  ...
  applyVersion: function(newVersion, oldVersion){
  return newVersion;
  },
  updateVersion: function(newVersion, oldVersion){
    this.fireEvent('versionchanged', newVersion, oldVersion);
  }
}, function() { ... });</pre></div></div><div class="section" title="Overriding defaults"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Overriding defaults</h2></div></div></div><p>The default <a id="id74" class="indexterm"/>values given to configuration properties can be easily overridden when a new class instance is created, by simply adding the property and the desired value to the configuration object passed to the <code class="literal">Ext.create</code> method. The following snippet shows the version option being set (assuming the <code class="literal">Config</code> class wasn't set to be a singleton):</p><div class="informalexample"><pre class="programlisting">var config = Ext.create('BizDash.config.Config', {
  version: '0.2.0-0'
});
// logs "0.2.0-0"
console.log(config.getVersion());</pre></div></div><div class="section" title="Platform-specific configs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Platform-specific configs</h2></div></div></div><p>Ext JS 5 introduces the ability to configure a class differently based on the platform the application<a id="id75" class="indexterm"/> is being run on, so we can tailor the experience based on the platform's capabilities.</p><p>This is done by using the <code class="literal">platformConfig config</code> option, giving it an array of configuration objects. These configuration options must contain a platform property, which will be used to find the appropriate config to use on the current platform.</p><p>This option should contain an array of strings describing the platform the config should target. This can be one or more of the following options: phone, tablet, desktop, iOS, Android, Blackberry, Safari, Chrome, or IE10.</p><p>If any of these platforms match the current one, then the other properties will be merged into the class configuration. It is possible that multiple rules will evaluate to true, in which case the properties of all matched rules will be applied.</p><p>The following code shows how we can configure our <code class="literal">Config</code> class differently based on the platform:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.config.Config', {
  extend: 'Ext.util.Observable',
  singleton: true,
  requires: ['BizDash.config.Constants'],
  config: {
    version: '0.0.1-0',
    isPhone : false,
    isTablet : false,
    isDesktop: false
  },
  platformConfig: [ {
    platform: ['phone'],
    isPhone : true
  },
  {
    platform: ['tablet'],
    isTablet: true
  },
  {
    platform : ['desktop'],
    isDesktop: true
  }]
  ...
});</pre></div><p>We can<a id="id76" class="indexterm"/> then access these properties using their getter methods. The following code, run on a laptop, will output <code class="literal">true</code> for the <code class="literal">isDesktop</code> property and <code class="literal">false</code> for the other two:</p><div class="informalexample"><pre class="programlisting">// logs "true", "false", "false" 
console.log(BizDash.config.Config.getIsDesktop()); 
console.log(BizDash.config.Config.getIsPhone()); 
console.log(BizDash.config.Config.getIsTablet());</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, we have covered all aspects of the Ext JS class system, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining and instantiating classes</li><li class="listitem" style="list-style-type: disc">Adding properties, methods, and statics</li><li class="listitem" style="list-style-type: disc">Extending other classes and overriding the framework behavior</li><li class="listitem" style="list-style-type: disc">Configuring classes and making use of applier and updater methods</li></ul></div><p>We have also demonstrated how to ensure our class files are loaded into our application when needed, using the <code class="literal">Ext.Loader</code> class.</p><p>The next chapter will discuss how Ext JS handles events, originating both from user input and from other classes.</p></div></body></html>