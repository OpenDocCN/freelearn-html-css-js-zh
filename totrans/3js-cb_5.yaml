- en: Chapter 5. Lights and Custom Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating shadows with THREE.SpotLight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shadows with THREE.DirectionalLight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Softening lights by adding ambient lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using THREE.HemisphereLight for natural lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a moving all-directional light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving a light source along a path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a light source follow an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom vertex shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom fragment shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js provides a large number of light sources out of the box. In this chapter,
    we'll show you a number of recipes that work on lights and also show you how to
    get the most out of the lighting options provided by Three.js. We'll also show
    you two advanced recipes that explain how you can access the raw features of WebGL
    by creating your own custom vertex and fragment shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shadows with THREE.SpotLight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js offers many different types of lights you can use in your scenes. A
    couple of these lights also allow you to add shadows to the scene. When you use
    `THREE.SpotLight` or a `THREE.DirectionalLight` object, you can let Three.js add
    shadows based on the position of the lights. In this recipe, we'll show you how
    to do this with `THREE.SpotLight`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you don''t need any external dependencies. Three.js includes
    all the available lights directly in the main Three.js JavaScript library. We''ve
    created a simple example that you can use to see how shadows work in combination
    with `THREE.SpotLight` in Three.js. You can view this example by opening `05.01-using-shadows-with-a-spotLight.html`
    in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this scene, you can see that we've added two meshes to the scene, both of
    which cast a shadow on the floor. From this example, you can also directly see
    the distinct light shape provided by `THREE.SpotLight`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a shadow with `THREE.SpotLight`, we need to set a couple of properties,
    which define the area where shadows are created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at `THREE.SpotLight`, the first thing we need to do is tell
    the renderer that we want to enable shadows. To do this, set the following property
    on `THREE.WebGLRenderer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to inform Three.js which objects cast shadows and which objects
    receive shadows. If you look back at the screenshot in the *Getting ready* section,
    you can see that the monkey and the cube both cast a shadow and the floor receives
    the shadow. To do this, you have to set the following properties on the `THREE.Mesh`
    objects that should cast shadows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For objects that receive shadows, you have to set the following on the `THREE.Mesh`
    object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we''re ready to create `THREE.SpotLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the standard properties that define how `THREE.SpotLight` adds light
    to a scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to set up the shadow-related properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first property, `castShadow`, tells Three.js that this light casts shadows.
    As casting shadows is an expensive operation, we need to define the area where
    shadows can appear. This is done with the `shadowCameraNear`, `shadowCameraFar`,
    and `shadowCameraFov` properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Three.js uses something called a shadow map to render the shadows. If your
    shadow looks a bit blocky around its edges, it means the shadow map is too small.
    To increase the shadow map size, set the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alternatively, you can also try to change the `shadowMapType` property of `THREE.WebGLRenderer`.
    You can set this to `THREE.BasicShadowMap`, `THREE.PCFShadowMap`, or `THREE.PCSSoftShadowMap`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to add `THREE.SpotLight` to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Determining the correct properties for the various `THREE.SpotLight` properties
    can be difficult. In the following section, we'll explain a bit more how the various
    properties affect the area where shadows are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to use `THREE.SpotLight` as a light source that can cast shadows,
    Three.js needs to know the area that will be affected by these shadows. You can
    compare this with the arguments you use to configure `THREE.PerspectiveCamera`.
    So, what you do with the `shadowCameraNear`, `shadowCameraFar`, and `shadowCameraFov`
    properties is define where Three.js should render shadows. Determining the correct
    values for these properties can be a bit difficult, but luckily, Three.js can
    visualize this area. If you set the `shadowCameraVisible` property of `THREE.SpotLight`
    to `true`, Three.js will show you the affected area, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1182OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, the size of the area is visualized with orange and red lines.
    By enabling this `shadowCameraVisible` property and experimenting with the other
    values, you can quickly determine the correct values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Three.js, there are two light sources that can cast shadows: `THREE.SpotLight`
    and `THREE.DirectionalLight`. In the *Creating shadows with a THREE.DirectionalLight*
    recipe, we explain how to cast shadows using `THREE.DirectionalLight`. A more
    performant but static way to create shadows is explained in the *Using a shadow
    map for fixed shadows* recipe in [Chapter 4](ch04.html "Chapter 4. Materials and
    Textures"), *Materials and Textures*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shadows with THREE.DirectionalLight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `THREE.DirectionalLight`, you can simulate a light source from far away
    whose rays run parallel to each other. A good example of this is light received
    from the sun. In this recipe, we'll show you how to create `THREE.DirectionalLight`
    and use it to create shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we''ve created an example that shows you what the shadows
    cast by a `THREE.DirectionalLight` object look like. Open up the `05.02-using-shadows-with-a-directionalLight.html`
    example in your browser, and you''ll see something like what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, a single `THREE.DirectionalLight` object provides the shadows
    and lighting.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `THREE.DirectionLight` as a shadow only takes a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do to enable any kind of shadow is set `shadowMapEnabled`
    on `THREE.WebGLRenderer` to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we inform Three.js which of our objects should receive shadows and which
    should cast shadows. So, for the objects that should cast a shadow, set the `castShadow`
    property on `THREE.Mesh` to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the objects that should receive a shadow, the floor in this case, set the
    following property on `THREE.Mesh` to `true`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create `THREE.DirectionalLight` and configure this light source.
    Add the following code to create `THREE.DirectionalLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create and position `THREE.DirectionalLight` and together with the
    `castShadow` property, this light source will be used by Three.js to render shadows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to configure the area where shadows should be rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these properties, we create a box-like area where Three.js will render
    shadows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Three.js uses two additional properties to determine the detail of the rendered
    shadow: `shadowMapWidth` and `shadowMapHeight`. If your shadows look a bit rough
    or blocky, you should increase the values like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After all these properties have been set, you can add the light source to the
    scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from these steps it is a little complicated to correctly configure
    `THREE.DirectionalLight`. Determining the correct values can be difficult. In
    the next section, we'll explain a bit more what these properties do and how you
    can determine their optimal values for your scene.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look back to the *Using an orthographic camera* recipe in [Chapter 3](ch03.html
    "Chapter 3. Working with the Camera"), *Working with the Camera*, you''ll notice
    that the camera uses the same properties as `THREE.DirectionalLight`. Both these
    objects define a bounding box that is rendered in the case of `THREE.OrthographicCamera`
    and is used to determine where to render shadows in the case of `THREE.DirectionalLight`.
    With `shadowCameraNear`, `shadowCameraFar`, `shadowCameraLeft`, `shadowCameraRight`,
    `shadowCameraTop`, and `shadowCameraBottom`, you define this area. You can set
    an additional property on `THREE.DirectionalLight` to visualize the affected area.
    If you set `directionalLight.shadowCameraVisible` to `true`, Three.js will draw
    the box defined by the `shadowCameraXXX` properties. The following screenshot
    shows you the result of enabling the `shadowCameraVisible` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1182OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shadows will only be rendered in the area contained by the orange box.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Three.js, there are two light sources that can cast shadows: `THREE.SpotLight`
    and `THREE.DirectionalLight`. In the *Creating shadows with THREE.SpotLight* recipe,
    we explain how to cast shadows using `THREE.SpotLight`. An alternative way to
    create shadows is explained in the *Using a shadow map for fixed shadows* recipe
    in [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials and
    Textures*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Softening lights by adding ambient lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you add lights to a scene, the result might look a bit harsh. You can see
    a strong contrast between the areas that receive lights and those that don't.
    When you look at real-life lighting, everything is a bit softer and almost every
    surface will receive some light, most often reflected from other surfaces. In
    this recipe, we'll show you how you can soften the light usage in your scene using
    `THREE.AmbientLight`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no steps required to get ready for this recipe. To see the final
    result in action, we provided an example, which you can see by opening the `05.03-soften-lights.html`
    example in your browser. You will find something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the menu in the top-right section, you can enable or disable `THREE.AmbientLight`
    to see the effect `THREE.AmbientLight` object has.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.AmbientLight` is the simplest of lights to use. As it applies light
    to the complete scene, there is no need to position the light source. All you
    have to do is create an instance of `THREE.AmbientLight` and add it to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the instance of `THREE.AmbientLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create the light source. When you create the ambient light, you can
    specify its color as a hex value. Don't specify it too high; if you do, your whole
    scene will be very bright.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The only thing left to do is add this light to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these two very simple steps, you've created `THREE.AmbientLight`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.AmbientLight` works in a very simple way. When you create `THREE.AmbientLight`,
    you pass in a color (in hex) into its constructor. When the scene is rendered,
    Three.js just blends in the specified color to the color of any of your meshes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though `THREE.AmbientLight` can be used to soften the lighting in a scene,
    it's hard to create natural-looking lighting. In the *Using THREE.HemisphereLight
    for natural lighting* recipe, we show you how to use a different light source
    for natural outside lighting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using THREE.HemisphereLight for natural lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look at the lighting outside, you'll see that the lights don't really
    come from a single direction. Part of the sunlight is reflected by Earth, and
    other parts are scattered by the atmosphere. The result is a very soft light coming
    from lots of directions. In Three.js, we can create something similar using `THREE.HemisphereLight`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like the other lights provided by Three.js, there is no need to include
    any additional JavaScript file to work with `THREE.HemisphereLight`. All you need
    is a scene with some objects, and you can add this light. To see the effect `THREE.HemisphereLight`
    object has, we''ve provided a simple example. Open up `05.04-create-a-sun-like-light.html`
    in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the controls in the top-right section, you can enable and disable `THREE.HemisphereLight`
    and `THREE.DirectionalLight`, which are used in this scene.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating `THREE.HemisphereLight` works in pretty much the same way as creating
    the other lights:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You first need to instantiate a `THREE.HemisphereLight` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first parameter sets the color of the sky, and the second color sets the
    color reflected from the floor. In both these cases, we just set a white light.
    With the last property, you can control the intensity of `THREE.HemisphereLight`
    object. In this case, we dampen the light by setting it to `0.6`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to position the light:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you position `THREE.HemisphereLight`, it's best to position it directly
    above the scene for the best effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, with the position set, the last step is to add the light to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You could use `THREE.HemisphereLight` as the main light source of your scene,
    but most often, this light source is used together with a different light source.
    For the best outdoor effect, use it with `THREE.DirectionalLight`, which can cast
    shadows.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.HemisphereLight` pretty much acts as two `THREE.DirectionalLight` objects:
    one positioned at the specified position and another one in exactly the opposite
    position. So, when a scene is rendered, `THREE.HemisphereLight` lights an object
    from the top and from the opposite direction to create a natural-looking effect.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can, of course, also use two `THREE.DirectionalLight` objects instead of
    `THREE.HemisphereLight`. With careful tuning, you can reach the exact same effect
    as you would get with `THREE.HemisphereLight`. The added advantage is that you
    could also make very faint shadows with this approach, as `THREE.DirectionalLight`
    supports casting shadows whereas `THREE.HemisphereLight` does not.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Softening lights by adding ambient lighting* recipe, we showed you a
    more simple approach of supporting the main light sources in your scene. We showed
    you how you can use `THREE.AmbientLight` as an extra light source to soften the
    lights and the shadows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a moving all-directional light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a lot of cases, you don't need a light source that casts shadows but just
    a light source that illuminates your scene. In the *Creating shadows with THREE.SpotLight*
    and *Creating shadows with THREE.DirectionalLight* recipes, we already showed
    you how you can use `THREE.SpotLight` and `THREE.DirectionalLight`. In this recipe,
    we'll show you a third kind of light, which is `THREE.PointLight`; this kind of
    light emits light to all directions and in this recipe, we will show you how to
    create one and move it through the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the Three.js standard comes with the `THREE.PointLight` object, there is
    no need to include any additional JavaScript. The same is the case with all the
    recipes where we''ve included an example where you can see the result of this
    recipe in action. For this recipe, open the `05.05-use-a-point-light.html` example
    in your browser, and you''ll see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, there are four `THREE.PointLight` objects that move from the
    top to the bottom in between three models of a shark. You can use your mouse to
    move around this scene and see how `THREE.PointLight` illuminates the models.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a moving `THREE.PointLight` object is very easy and only takes a couple
    of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is create a `THREE.PointLight` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `color` property, we set the color `THREE.PointLight` object emits,
    and the intensity allows us to set how much light is emitted. Finally, the `distance`
    property is used to calculate how much the intensity decreases the farther away
    the lit object is from the light. In this case, the intensity will be `0` when
    the distance to the light is `60`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`THREE.PointLight` emits lights in all directions, so we need to set the `position`
    property and then we can add the light to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing we need to do for this recipe is move `THREE.PointLight` through
    the scene. Like all animations, we do this in the render loop by adding the following
    to the `render` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this small code snippet, we first get a reference to our `THREE.PointLight`
    object and then update its `position.y` property. For this to work, we also need
    to define a global `count` property at the top of our JavaScript like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these simple steps, you've created `THREE.PointLight`, which moves up and
    down through the scene.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.PointLight` emits light in all directions; you can compare this a bit
    with `THREE.SpotLight` but with a 360 degree field of view in all directions.
    This is also the main reason that `THREE.PointLight` can''t be used to cast shadows.
    As there is so much light being emitted by `THREE.PointLight`, it is very difficult
    and resource-intensive to calculate the resulting shadows.'
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want shadows and also use `THREE.PointLight`, you could use a shadow
    map if you have a static `THREE.PointLight` object or an extra `THREE.SpotLight`
    object and set it to only cast shadows with the `onlyShadow` property.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of recipes that you can look at in relation to this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating shadows with a THREE.SpotLight* recipe, we showed you how you
    can use `THREE.SpotLight` to create shadows. You can use this together with `THREE.PointLight`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Creating shadows with a THREE.DirectionalLight* recipe, we show you
    how to set up and configure `THREE.DirectionalLight`. This light casts shadows
    and can be used together with `THREE.PointLight`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials and
    Textures*, we showed you the *Using a shadow map for fixed shadows* recipe. This
    recipe explained how to use shadow maps to fake shadows. If you use that recipe
    together with this one, you can use it to fake the shadows cast by `THREE.PointLight`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving a light source along a path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Add an moving all-directional light* recipe, we moved a light source
    up and down. While these simple kinds of paths are often enough, there are cases
    where you want more control over how your light source moves through a scene.
    In this recipe, we'll show you how you can move a light source along a predefined
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create this recipe, we''ll use a `THREE.SplineCurve3D` and `THREE.SpotLight`
    object. As both of these objects are included with Three.js, we don''t need to
    take any steps to get ready. A good thing to do, however, is look at the provided
    example for this recipe, which will show you what you''ll get when you execute
    the steps from this recipe when you run the `05.06-move-a-light-through-the-scene.html`
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the screenshot, you can see a light that moves slowly along the purple line.
    In the next section, we'll show you how you can create this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we first need to create the path that we''ll follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this path, we''ll create `THREE.SplineCurve3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will result in a curved path that moves through the points added in the
    constructor of the `THREE.SplineCurve3` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we position our light on the path of this `THREE.SplineCurve3` object,
    let''s create the light:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use this `SplineCurve3` object to determine the position of our
    light. For this, we create a helper function called `positionLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we use `spline.getPointAt(pos)` to determine where on the
    `THREE.SplineCurve3` path we need to position our light. With `pos` at `0`, we're
    at the beginning of spline and with `pos` at `1`, we're at the end. This way,
    we slowly (in steps of `0.001`) move the light along the spline.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All that is left to do is call the `positionLight` function from the render
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the render function is called approximately 60 times per second and we take
    1000 steps for our complete path, the light will move along the complete path
    in about 17 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you instantiate a `THREE.SplineCurve3` object, you pass in an array of
    `THREE.Vector3` objects. Three.js internally interpolates these points to create
    a fluid curve that moves through all these points. Once the curve is created,
    you have two ways to get positions. You can use the `getPointAt` function, as
    we did in this recipe, to get a relative position based on the provided parameter,
    from `0` to `1`, and the length of the curve. Alternatively, you can also use
    the `getPoints` function, where you specify, as the parameter, in how many points
    the line should be divided.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Getting ready* part of this recipe, we showed you an example where
    a light moved through a scene. What you could see was that we also showed the
    path along which the light moved. To do this for yourself, you can use the `getPoints`
    function from the created `THREE.SplineCurve3` object to create a `THREE.Line`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we moved a light along a specific path. However, as a light
    is also just an object with a specific position, we can apply this same principle
    to all the other objects in the scene, such as `THREE.Mesh`, `THREE.PerspectiveCamera`,
    or `THREE.OrthographicCamera`.
  prefs: []
  type: TYPE_NORMAL
- en: Making a light source follow an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've got a moving object in the scene that you want to highlight with a
    spotlight, you need to be able to change the direction a light is pointed at.
    In this recipe, we will show you how to do just that. We will show you how you
    can keep `THREE.SpotLight` pointed at a moving object in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no steps that you need to take to run this recipe. You can see the
    final result of this recipe by opening up the `05.07-make-a-light-follow-object.html`
    example in your browser. You will see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can see a sphere that moves from left to right and back
    again. `THREE.SpotLight` in this scene follows the position of this sphere so
    that it is always pointed directly at the center of that object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following an object in Three.js is very easy and only takes a couple of easy
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fist thing we need to do is create the object that we want to follow. For
    this recipe, this is `THREE.SpotLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create and add `THREE.SpotLight` to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that at this step, we don't point the created light to the sphere. We'll
    do this in the next step in the render loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To keep the light pointed at the sphere, we need to set the `target` property
    to the correct value. We do this in the `render` function of the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One thing to notice in the last step is that we set the target property of `spotLight`
    to the `THREE.Mesh` object and not to the position property of `THREE.Mesh`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To point `THREE.SpotLight` at a certain position, we set its `target` property.
    As you''ve seen in the recipe steps, we target `THREE.Object3D`, from which `THREE.Mesh`
    extends, instead of a position. If we want to point `THREE.SpotLight` to an arbitrary
    position, we need to first create an empty `THREE.Object3D` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can point `THREE.SpotLight` not just to an existing object in
    the scene but to any position you want.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we pointed a light at a specific target, and we can also make
    a camera follow an object around the scene, as we showed in the *Making the camera
    follow an object* recipe from [Chapter 3](ch03.html "Chapter 3. Working with the
    Camera"), *working with the Camera* and point one object to another, as shown
    in the *Pointing an object to another object* recipe in [Chapter 2](ch02.html
    "Chapter 2. Geometries and Meshes"), *Geometries and Meshes*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom vertex shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to create advanced 3D effects with great performance, you can
    choose to write your own shaders. **Shaders** are programs that directly affect
    what your results look like and which colors are used to represent them. A shader
    always comes as a pair. A vertex shader determines what a geometry will look like,
    and a fragment shader will determine the resulting color. In this recipe, we'll
    show you how you can use your own custom vertex shader in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebGL and GLSL, which is the language in which you write shaders, are supported
    by most modern browsers. So, for this recipe, there aren't any additional steps
    you need to take before you can walk through this recipe. A good resource on GLSL
    is always the khronos website ([http://www.khronos.org](http://www.khronos.org));
    they have a great tutorial ([http://www.khronos.org/webgl/wiki/Tutorial](http://www.khronos.org/webgl/wiki/Tutorial))
    on WebGL that can help you better understand what we're doing in this recipe.
    For this specific recipe, we've provided two examples. The first one is the one
    we'll use in this recipe, and you can view this one by opening `05.09-custom-vertex-shader.html`
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example, as you can see in the previous screenshot, shows you `THREE.BoxGeometry`,
    where the position of its individual vertices have been replaced using a vertex
    shader. A more advanced example can be found in `05.09-custom-vertex-shader-2.html`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we once again change the position of individual vertices, but
    this time, we use `THREE.SphereGeometry` as the source and combine it with a perlin
    noise generator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a custom vertex shader, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we just want to write a vertex shader, we''ll use a standard fragment shader,
    which is the one also used by `THREE.MeshBasicMaterial` from Three.js. You can
    get a reference to this shader by selecting the correct one from `THREE.ShaderLib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to define the `Uniforms` object. `Uniforms` are parameters
    that are passed into the shaders as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we first `merge` the standard uniforms that are by the
    fragment shader we reuse, we set a texture, and the last two uniforms are the
    ones we access in our own custom vertex shader, as we'll see later on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can define `THREE.ShaderMaterial` and tell Three.js the shaders that
    we want to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, you can see that we reference the `uniform` value we saw
    in step 2, as `fragmentShader` we use `basicShader` from step 1, and for the `vertexShader`
    parameter, we reference our custom shader, which we'll define in the next step.
    Note that we also provide a `defines` element; this is needed to make sure Three.js
    shows our texture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we can define our own custom vertex shader. We do this directly
    in the HTML as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this shader, we change the location of the vertices by changing the `p.z`
    and the `p.x` part of its position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we can just create a geometry and use the material we created
    in step 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look in the shader code in step 4, you can see that the position is
    influenced by the delta uniform value. We use the `render` function to pass in
    a new value for this uniform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are all the steps you need to take to create and use a custom vertex shader
    combined with a simple fragment shader from Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look a bit closer at what is happening in the vertex shader used in
    this recipe. Before we start, we''ll give you a very short introduction to the
    types of qualifiers that you can use with the variables in your shader code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `uniform` qualifier: This is a global variable that can be passed in from
    JavaScript to the shaders. You can change this value in each rendering loop but
    can''t change the value in the shader itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `attribute` qualifier: This is a value that can be specified for each individual
    vertex. The `attributes` qualifier are passed on into the vertex shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `varying` qualifier: This is used to pass data between the vertex shader
    and the fragment shader. It can be written into the vertex shader but can only
    be read in the fragment shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `const` qualifier: This is a constant value and is defined directly in
    your shader code. This value can''t change during the execution of your shaders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we do is define some parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `vUv` vector is a varying variable and is a value that is passed into the
    fragment shader and is required for the basic shader to work in Three.js. The
    other two parameters are passed in as uniforms from the JavaScript you saw in
    the previous section. Let''s look at the main function, which is the function
    that is exectured for each vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The main thing that happens here is that we change the position of the vertex
    based on the passed-in delta and some `sin` and `cos` functions. The result is
    that each vertex of our model is displaced in some manner. Finally, we need to
    set the `gl_Position` variable with the new position of our vertex.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you look for information on custom shaders, you''ll most often see examples
    of fragment shaders. In many use cases, a vertex shader doesn''t need to change
    the positions of the vertices. When it does, it is often for effects such as smoke
    or fire. There aren''t that many good vertex shaders examples out there. The following
    two sites, however, provide a good starting point if you want to learn more about
    vertex shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: A good resource to learn more about vertex shaders is the shader tutorial from
    lighthouse3d at [http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/](http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an online vertex shader editor available at kickjs.org, which
    you can find at [http://www.kickjs.org/example/shader_editor/shader_editor.html](http://www.kickjs.org/example/shader_editor/shader_editor.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a vertex shader is always accompanied with a fragment shader, it is good
    to also understand how they work. In the *Creating a custom fragment shader* recipe,
    we explain the steps you need to take to set up a custom fragment shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom fragment shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A WebGL shader always consists of two parts: the vertex shader that can be
    used to reposition the individual vertices of the model and a fragment shader
    that can be used to add color to the model. In this recipe, we''ll show you the
    steps you need to take to use a custom fragment shader.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start with the fragment shader, there is one thing you need to know.
    Just like with a vertex shader, you don't write the fragment shader code in JavaScript.
    These shaders are written in the GLSL language. So, if you want to learn more
    about the functions and notations used in this example, look at the WebGL specification,
    which can be found at [https://www.khronos.org/registry/webgl/specs/1.0/](https://www.khronos.org/registry/webgl/specs/1.0/).
    If you want to experiment with the provided shader code, you can just open up
    `05.10-custom-fragment-shader.html` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1182OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shader colors an object based on the normal vector and on the distance
    from the camera. In the following sections, we will explain how you can do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the JavaScript part of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A shader always consists of a vertex shader and a fragment shader. In this
    recipe, we''ll use the standard vertex shader provided by Three.js and provide
    our own custom fragment shader. Three.js keeps all its shaders in `THREE.ShaderLib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In step 3, we'll reference this `basicShader` object to get the standard vertex
    shader.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For our custom shader, we have some configuration options. These options are
    passed into a shader using uniforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that in our shader code, we can access the `delta`, `mNear`, and
    `mFar` values, all of which are floating point values, and we can use them to
    calculate the colors we want to render.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we can create the shader material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the configuration of `THREE.ShaderMaterial`, we reference our `uniform` variable,
    the standard vertex shader, `basicShader.vertexShader` provided by Three.js, and
    our own custom fragment shader. We'll show you the definition of our custom shader
    in step 5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last thing we need to do is create `THREE.BoxGeometry` and add it to the
    scene using the material created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In step 3, we referenced a DOM element with the simple-fragment name. In your
    HTML page, you should define it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to know more about how this fragment shader works, look at the explanation
    in the *How it works...* section of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you''ve looked at the example from the *Getting ready* section, you can
    see that the colors change constantly. This happens because we update the delta
    property, which is passed into our custom shader, in the `render` loop of this
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how this shader works, let''s look through the code step by step.
    Let''s start by looking at the variables used in this shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `vNormal` object is a variable that is passed in from the standard Three.js
    vertex shader and contains the value of the normal vector applicable to this fragment.
    The three uniform values are passed in from the JavaScript, as we''ve seen in
    the previous section. The PI variable is a constant that doesn''t change over
    time. Each fragment shader should set the `gl_fragColor` vector, which determines
    the color and opacity of each fragment. For this shader, we set the vector as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Without going into too many GLSL details, roughly the following steps are taken:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we determine the depth of this fragment. You can see this as the distance
    of this fragment from the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As depth is an absolute value, we convert it to a scale of `0` to `1` using
    the `smoothstep` function. As this function also takes the `mNear` and `mFar`
    uniforms as its parameters, we can control how much the depth affects the color
    of a fragment from JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we define the color of the fragment by setting `gl_FragColor`. The
    `gl_FragColor` variable is of type `vec4`, where the first three values determine
    the RGB value of the color and the last one defines the opacity. This is all on
    a scale of `0` to `1`. For each part of the color, we use a function that includes
    the `vNormal` vector and calculated `depthColor` variable to generate a color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is just the tip of the iceberg of what you can do with custom fragment
    shaders. In the upcoming section, you can find some resources to learn more about
    this.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating custom fragment shaders is rather difficult. It''ll take a lot of
    experimenting, a good grasp of math, and a lot of patience. There are, however,
    a number of resources available that can help you understand fragment shaders
    and learn from the work of others:'
  prefs: []
  type: TYPE_NORMAL
- en: Lots of fragment shaders can be found at [http://glslsandbox.com/](http://glslsandbox.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the Shadertoy site, you can experiment fragment shaders using different
    kinds of input: [https://www.shadertoy.com/](https://www.shadertoy.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple online shader editor can be found at [http://shdr.bkcore.com/](http://shdr.bkcore.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another great help can be the latest version of Firefox Dev Tools. This is a
    special version of Firefox, which provides great debugging support and even includes
    a shader editor that you can use to edit a shader program and directly see the
    results. You can download this version from [https://www.mozilla.org/en-US/firefox/developer/](https://www.mozilla.org/en-US/firefox/developer/).
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, the khronos website ([http://www.khronos.org](http://www.khronos.org)),
    which is a great resource to find out what a specific function actually does.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a fragment shader is always accompanied with a vertex shader, it is good
    to also understand how they work. In the *Creating a custom vertex shader* recipe,
    we explained the steps you need to take to set up a custom vertex shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
