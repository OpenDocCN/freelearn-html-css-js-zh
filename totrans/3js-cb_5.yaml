- en: Chapter 5. Lights and Custom Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 灯光和自定义着色器
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating shadows with THREE.SpotLight
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.SpotLight`创建阴影
- en: Creating shadows with THREE.DirectionalLight
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.DirectionalLight`创建阴影
- en: Softening lights by adding ambient lighting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加环境光照来柔化灯光
- en: Using THREE.HemisphereLight for natural lighting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.HemisphereLight`进行自然照明
- en: Adding a moving all-directional light
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个全方向移动的灯光
- en: Moving a light source along a path
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿路径移动光源
- en: Making a light source follow an object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使光源跟随一个对象
- en: Creating a custom vertex shader
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义顶点着色器
- en: Creating a custom fragment shader
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义片段着色器
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Three.js provides a large number of light sources out of the box. In this chapter,
    we'll show you a number of recipes that work on lights and also show you how to
    get the most out of the lighting options provided by Three.js. We'll also show
    you two advanced recipes that explain how you can access the raw features of WebGL
    by creating your own custom vertex and fragment shaders.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了大量的光源，无需额外依赖。在本章中，我们将展示一些关于灯光的食谱，并展示如何充分利用Three.js提供的照明选项。我们还将展示两个高级食谱，解释如何通过创建自己的自定义顶点和片段着色器来访问WebGL的原始功能。
- en: Creating shadows with THREE.SpotLight
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`THREE.SpotLight`创建阴影
- en: Three.js offers many different types of lights you can use in your scenes. A
    couple of these lights also allow you to add shadows to the scene. When you use
    `THREE.SpotLight` or a `THREE.DirectionalLight` object, you can let Three.js add
    shadows based on the position of the lights. In this recipe, we'll show you how
    to do this with `THREE.SpotLight`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了许多不同类型的灯光，你可以在场景中使用。其中一些灯光还允许你向场景添加阴影。当你使用`THREE.SpotLight`或`THREE.DirectionalLight`对象时，你可以让Three.js根据光源的位置添加阴影。在本食谱中，我们将展示如何使用`THREE.SpotLight`来实现这一点。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you don''t need any external dependencies. Three.js includes
    all the available lights directly in the main Three.js JavaScript library. We''ve
    created a simple example that you can use to see how shadows work in combination
    with `THREE.SpotLight` in Three.js. You can view this example by opening `05.01-using-shadows-with-a-spotLight.html`
    in your browser. You will see something similar to the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你不需要任何外部依赖。Three.js将所有可用的灯光直接包含在主Three.js JavaScript库中。我们创建了一个简单的示例，你可以使用它来查看在Three.js中如何结合`THREE.SpotLight`使用阴影。你可以在浏览器中打开`05.01-using-shadows-with-a-spotLight.html`来查看这个示例。你将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_05_01.jpg)'
- en: In this scene, you can see that we've added two meshes to the scene, both of
    which cast a shadow on the floor. From this example, you can also directly see
    the distinct light shape provided by `THREE.SpotLight`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，你可以看到我们向场景中添加了两个网格，它们都在地板上投下了阴影。从这个例子中，你也可以直接看到`THREE.SpotLight`提供的独特光形状。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a shadow with `THREE.SpotLight`, we need to set a couple of properties,
    which define the area where shadows are created:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`THREE.SpotLight`创建阴影，我们需要设置一些属性，这些属性定义了创建阴影的区域：
- en: 'Before we look at `THREE.SpotLight`, the first thing we need to do is tell
    the renderer that we want to enable shadows. To do this, set the following property
    on `THREE.WebGLRenderer`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们查看`THREE.SpotLight`之前，我们首先需要做的是告诉渲染器我们想要启用阴影。为此，在`THREE.WebGLRenderer`上设置以下属性：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step is to inform Three.js which objects cast shadows and which objects
    receive shadows. If you look back at the screenshot in the *Getting ready* section,
    you can see that the monkey and the cube both cast a shadow and the floor receives
    the shadow. To do this, you have to set the following properties on the `THREE.Mesh`
    objects that should cast shadows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是通知Three.js哪些对象投下阴影，哪些对象接收阴影。如果你回顾一下*准备工作*部分中的截图，你可以看到猴子和立方体都投下了阴影，而地板接收了阴影。为此，你必须在应该投下阴影的`THREE.Mesh`对象上设置以下属性：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For objects that receive shadows, you have to set the following on the `THREE.Mesh`
    object:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于接收阴影的对象，你必须在`THREE.Mesh`对象上设置以下属性：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we''re ready to create `THREE.SpotLight`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好创建`THREE.SpotLight`：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These are the standard properties that define how `THREE.SpotLight` adds light
    to a scene.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是定义`THREE.SpotLight`如何向场景添加光的标准属性。
- en: 'The next step is to set up the shadow-related properties:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置与阴影相关的属性：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first property, `castShadow`, tells Three.js that this light casts shadows.
    As casting shadows is an expensive operation, we need to define the area where
    shadows can appear. This is done with the `shadowCameraNear`, `shadowCameraFar`,
    and `shadowCameraFov` properties.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个属性 `castShadow` 告诉 Three.js 这个光源可以投射阴影。由于投射阴影是一个昂贵的操作，我们需要定义阴影可以出现的位置。这是通过
    `shadowCameraNear`、`shadowCameraFar` 和 `shadowCameraFov` 属性来完成的。
- en: 'Three.js uses something called a shadow map to render the shadows. If your
    shadow looks a bit blocky around its edges, it means the shadow map is too small.
    To increase the shadow map size, set the following properties:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Three.js 使用一种称为阴影图的技术来渲染阴影。如果您的阴影在边缘看起来有点块状，这意味着阴影图太小。要增加阴影图的大小，设置以下属性：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Alternatively, you can also try to change the `shadowMapType` property of `THREE.WebGLRenderer`.
    You can set this to `THREE.BasicShadowMap`, `THREE.PCFShadowMap`, or `THREE.PCSSoftShadowMap`.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您也可以尝试更改 `THREE.WebGLRenderer` 的 `shadowMapType` 属性。您可以将此设置为 `THREE.BasicShadowMap`、`THREE.PCFShadowMap`
    或 `THREE.PCSSoftShadowMap`。
- en: 'The last step is to add `THREE.SpotLight` to the scene:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将 `THREE.SpotLight` 添加到场景中：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Determining the correct properties for the various `THREE.SpotLight` properties
    can be difficult. In the following section, we'll explain a bit more how the various
    properties affect the area where shadows are rendered.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确定各种 `THREE.SpotLight` 属性的正确属性可能很困难。在以下部分，我们将进一步解释这些属性如何影响阴影渲染的区域。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you want to use `THREE.SpotLight` as a light source that can cast shadows,
    Three.js needs to know the area that will be affected by these shadows. You can
    compare this with the arguments you use to configure `THREE.PerspectiveCamera`.
    So, what you do with the `shadowCameraNear`, `shadowCameraFar`, and `shadowCameraFov`
    properties is define where Three.js should render shadows. Determining the correct
    values for these properties can be a bit difficult, but luckily, Three.js can
    visualize this area. If you set the `shadowCameraVisible` property of `THREE.SpotLight`
    to `true`, Three.js will show you the affected area, as shown in the following
    screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想将 `THREE.SpotLight` 作为可以投射阴影的光源使用时，Three.js 需要知道这些阴影将影响哪些区域。您可以将其与您用于配置 `THREE.PerspectiveCamera`
    的参数进行比较。因此，您通过 `shadowCameraNear`、`shadowCameraFar` 和 `shadowCameraFov` 属性所做的操作是定义
    Three.js 应该在哪里渲染阴影。确定这些属性的值可能有点困难，但幸运的是，Three.js 可以可视化这个区域。如果您将 `THREE.SpotLight`
    的 `shadowCameraVisible` 属性设置为 `true`，Three.js 将显示受影响的区域，如下面的截图所示：
- en: '![How it works...](img/1182OS_05_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1182OS_05_02.jpg)'
- en: In this screenshot, the size of the area is visualized with orange and red lines.
    By enabling this `shadowCameraVisible` property and experimenting with the other
    values, you can quickly determine the correct values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，区域的大小用橙色和红色线条表示。通过启用此 `shadowCameraVisible` 属性并尝试其他值，您可以快速确定正确的值。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In Three.js, there are two light sources that can cast shadows: `THREE.SpotLight`
    and `THREE.DirectionalLight`. In the *Creating shadows with a THREE.DirectionalLight*
    recipe, we explain how to cast shadows using `THREE.DirectionalLight`. A more
    performant but static way to create shadows is explained in the *Using a shadow
    map for fixed shadows* recipe in [Chapter 4](ch04.html "Chapter 4. Materials and
    Textures"), *Materials and Textures*.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Three.js 中，有两种可以投射阴影的光源：`THREE.SpotLight` 和 `THREE.DirectionalLight`。在 *使用
    THREE.DirectionalLight 创建阴影* 食谱中，我们解释了如何使用 `THREE.DirectionalLight` 投射阴影。在 [第
    4 章](ch04.html "第 4 章。材料和纹理") *材料和纹理* 的 *使用阴影图创建固定阴影* 食谱中，解释了一种更高效但静态的创建阴影的方法。
- en: Creating shadows with THREE.DirectionalLight
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 THREE.DirectionalLight 创建阴影
- en: With `THREE.DirectionalLight`, you can simulate a light source from far away
    whose rays run parallel to each other. A good example of this is light received
    from the sun. In this recipe, we'll show you how to create `THREE.DirectionalLight`
    and use it to create shadows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.DirectionalLight`，您可以模拟一个远处的光源，其光线相互平行。一个很好的例子是从太阳接收到的光线。在这个食谱中，我们将向您展示如何创建
    `THREE.DirectionalLight` 并使用它来创建阴影。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we''ve created an example that shows you what the shadows
    cast by a `THREE.DirectionalLight` object look like. Open up the `05.02-using-shadows-with-a-directionalLight.html`
    example in your browser, and you''ll see something like what is shown in the following
    screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们创建了一个示例，展示了 `THREE.DirectionalLight` 对象产生的阴影的样子。在您的浏览器中打开 `05.02-using-shadows-with-a-directionalLight.html`
    示例，您将看到以下截图所示的内容：
- en: '![Getting ready](img/1182OS_05_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_05_03.jpg)'
- en: In this screenshot, a single `THREE.DirectionalLight` object provides the shadows
    and lighting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，一个单独的 `THREE.DirectionalLight` 对象提供了阴影和照明。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Using `THREE.DirectionLight` as a shadow only takes a couple of steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.DirectionLight` 作为阴影只需要几个步骤：
- en: 'The first thing we need to do to enable any kind of shadow is set `shadowMapEnabled`
    on `THREE.WebGLRenderer` to `true`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用任何类型的阴影，我们首先需要将 `THREE.WebGLRenderer` 上的 `shadowMapEnabled` 设置为 `true`：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we inform Three.js which of our objects should receive shadows and which
    should cast shadows. So, for the objects that should cast a shadow, set the `castShadow`
    property on `THREE.Mesh` to `true`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通知 Three.js 哪些对象应该接收阴影，哪些对象应该投射阴影。因此，对于应该投射阴影的对象，在 `THREE.Mesh` 上设置 `castShadow`
    属性为 `true`：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the objects that should receive a shadow, the floor in this case, set the
    following property on `THREE.Mesh` to `true`:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于应该接收阴影的对象，在这个例子中是地板，在 `THREE.Mesh` 上设置以下属性为 `true`：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can create `THREE.DirectionalLight` and configure this light source.
    Add the following code to create `THREE.DirectionalLight`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建 `THREE.DirectionalLight` 并配置这个光源。添加以下代码以创建 `THREE.DirectionalLight`：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will create and position `THREE.DirectionalLight` and together with the
    `castShadow` property, this light source will be used by Three.js to render shadows.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建并定位 `THREE.DirectionalLight`，与 `castShadow` 属性一起，这个光源将被 Three.js 用于渲染阴影。
- en: 'The next step is to configure the area where shadows should be rendered:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置应该渲染阴影的区域：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With these properties, we create a box-like area where Three.js will render
    shadows.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这些属性，我们创建了一个类似盒子的区域，Three.js 将在这个区域中渲染阴影。
- en: 'Three.js uses two additional properties to determine the detail of the rendered
    shadow: `shadowMapWidth` and `shadowMapHeight`. If your shadows look a bit rough
    or blocky, you should increase the values like this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Three.js 使用两个额外的属性来确定渲染阴影的细节：`shadowMapWidth` 和 `shadowMapHeight`。如果你的阴影看起来有点粗糙或块状，你应该增加这些值，如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After all these properties have been set, you can add the light source to the
    scene:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置完所有这些属性后，你可以将光源添加到场景中：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from these steps it is a little complicated to correctly configure
    `THREE.DirectionalLight`. Determining the correct values can be difficult. In
    the next section, we'll explain a bit more what these properties do and how you
    can determine their optimal values for your scene.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如从这些步骤中可以看出，正确配置 `THREE.DirectionalLight` 是有点复杂的。确定正确的值可能很困难。在下一节中，我们将更详细地解释这些属性的作用以及如何确定它们在场景中的最佳值。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If you look back to the *Using an orthographic camera* recipe in [Chapter 3](ch03.html
    "Chapter 3. Working with the Camera"), *Working with the Camera*, you''ll notice
    that the camera uses the same properties as `THREE.DirectionalLight`. Both these
    objects define a bounding box that is rendered in the case of `THREE.OrthographicCamera`
    and is used to determine where to render shadows in the case of `THREE.DirectionalLight`.
    With `shadowCameraNear`, `shadowCameraFar`, `shadowCameraLeft`, `shadowCameraRight`,
    `shadowCameraTop`, and `shadowCameraBottom`, you define this area. You can set
    an additional property on `THREE.DirectionalLight` to visualize the affected area.
    If you set `directionalLight.shadowCameraVisible` to `true`, Three.js will draw
    the box defined by the `shadowCameraXXX` properties. The following screenshot
    shows you the result of enabling the `shadowCameraVisible` property:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾到第 3 章 [使用正交相机](ch03.html "第 3 章。使用相机") 中的 *使用正交相机* 菜谱，*使用相机*，你会注意到相机使用与
    `THREE.DirectionalLight` 相同的属性。这两个对象都定义了一个边界框，在 `THREE.OrthographicCamera` 的情况下渲染，在
    `THREE.DirectionalLight` 的情况下用于确定渲染阴影的位置。通过 `shadowCameraNear`、`shadowCameraFar`、`shadowCameraLeft`、`shadowCameraRight`、`shadowCameraTop`
    和 `shadowCameraBottom`，你定义了这个区域。你还可以在 `THREE.DirectionalLight` 上设置一个额外的属性来可视化受影响区域。如果你将
    `directionalLight.shadowCameraVisible` 设置为 `true`，Three.js 将绘制由 `shadowCameraXXX`
    属性定义的框。以下截图显示了启用 `shadowCameraVisible` 属性的结果：
- en: '![How it works...](img/1182OS_05_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/1182OS_05_04.jpg)'
- en: Shadows will only be rendered in the area contained by the orange box.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影只会在橙色框所包含的区域中渲染。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In Three.js, there are two light sources that can cast shadows: `THREE.SpotLight`
    and `THREE.DirectionalLight`. In the *Creating shadows with THREE.SpotLight* recipe,
    we explain how to cast shadows using `THREE.SpotLight`. An alternative way to
    create shadows is explained in the *Using a shadow map for fixed shadows* recipe
    in [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials and
    Textures*.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Three.js中，有两种可以投射阴影的光源：`THREE.SpotLight` 和 `THREE.DirectionalLight`。在 *使用 THREE.SpotLight
    创建阴影* 的配方中，我们解释了如何使用 `THREE.SpotLight` 投射阴影。在 [第4章](ch04.html "第4章。材料和纹理") 的 *使用阴影图创建固定阴影*
    配方中，我们解释了另一种创建阴影的方法。
- en: Softening lights by adding ambient lighting
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过添加环境光照来柔化灯光
- en: When you add lights to a scene, the result might look a bit harsh. You can see
    a strong contrast between the areas that receive lights and those that don't.
    When you look at real-life lighting, everything is a bit softer and almost every
    surface will receive some light, most often reflected from other surfaces. In
    this recipe, we'll show you how you can soften the light usage in your scene using
    `THREE.AmbientLight`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向场景中添加灯光时，结果可能看起来有点刺眼。你可以看到接受光照的区域和不接受光照的区域之间存在强烈的对比。当你观察现实生活中的照明时，一切都会显得柔和一些，几乎每个表面都会接收到一些光，通常是来自其他表面的反射。在这个配方中，我们将向你展示如何使用
    `THREE.AmbientLight` 在你的场景中柔化灯光的使用。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are no steps required to get ready for this recipe. To see the final
    result in action, we provided an example, which you can see by opening the `05.03-soften-lights.html`
    example in your browser. You will find something similar to the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，没有需要准备的步骤。为了看到最终结果，我们提供了一个示例，你可以在浏览器中打开 `05.03-soften-lights.html` 示例来查看。你将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_05_05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_05_05.jpg)'
- en: With the menu in the top-right section, you can enable or disable `THREE.AmbientLight`
    to see the effect `THREE.AmbientLight` object has.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角的菜单中，你可以启用或禁用 `THREE.AmbientLight` 来查看 `THREE.AmbientLight` 对象的效果。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '`THREE.AmbientLight` is the simplest of lights to use. As it applies light
    to the complete scene, there is no need to position the light source. All you
    have to do is create an instance of `THREE.AmbientLight` and add it to the scene:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.AmbientLight` 是最简单的灯光之一。因为它将光照应用到整个场景，所以不需要定位光源。你所要做的就是创建一个 `THREE.AmbientLight`
    实例并将其添加到场景中：'
- en: 'First, create the instance of `THREE.AmbientLight`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建 `THREE.AmbientLight` 的实例：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will create the light source. When you create the ambient light, you can
    specify its color as a hex value. Don't specify it too high; if you do, your whole
    scene will be very bright.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建光源。当你创建环境光时，你可以指定其颜色为一个十六进制值。不要指定得太高；如果你这样做，你的整个场景将会非常明亮。
- en: 'The only thing left to do is add this light to the scene:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是将这个灯光添加到场景中：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With these two very simple steps, you've created `THREE.AmbientLight`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个非常简单的步骤，你就创建了 `THREE.AmbientLight`。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`THREE.AmbientLight` works in a very simple way. When you create `THREE.AmbientLight`,
    you pass in a color (in hex) into its constructor. When the scene is rendered,
    Three.js just blends in the specified color to the color of any of your meshes.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.AmbientLight` 的工作方式非常简单。当你创建 `THREE.AmbientLight` 时，你将一个颜色（十六进制）传递给其构造函数。当场景渲染时，Three.js
    只是将指定的颜色混合到你的网格的颜色中。'
- en: See also
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Even though `THREE.AmbientLight` can be used to soften the lighting in a scene,
    it's hard to create natural-looking lighting. In the *Using THREE.HemisphereLight
    for natural lighting* recipe, we show you how to use a different light source
    for natural outside lighting.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管可以使用 `THREE.AmbientLight` 来柔化场景中的照明，但创建看起来自然的照明是困难的。在 *使用 THREE.HemisphereLight
    进行自然照明* 的配方中，我们展示了如何使用不同的光源来创建自然的外部照明。
- en: Using THREE.HemisphereLight for natural lighting
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 THREE.HemisphereLight 进行自然照明
- en: If you look at the lighting outside, you'll see that the lights don't really
    come from a single direction. Part of the sunlight is reflected by Earth, and
    other parts are scattered by the atmosphere. The result is a very soft light coming
    from lots of directions. In Three.js, we can create something similar using `THREE.HemisphereLight`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察外部的照明，你会看到灯光并不是真正来自单一方向。部分阳光被地球反射，其他部分被大气散射。结果是来自许多方向的一种非常柔和的光。在Three.js中，我们可以使用
    `THREE.HemisphereLight` 创建类似的效果。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Just like the other lights provided by Three.js, there is no need to include
    any additional JavaScript file to work with `THREE.HemisphereLight`. All you need
    is a scene with some objects, and you can add this light. To see the effect `THREE.HemisphereLight`
    object has, we''ve provided a simple example. Open up `05.04-create-a-sun-like-light.html`
    in your browser. You will see something similar to the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Three.js 提供的其他灯光一样，无需包含任何额外的 JavaScript 文件即可使用 `THREE.HemisphereLight`。你只需要一个包含一些对象的场景，然后就可以添加这个灯光。为了看到
    `THREE.HemisphereLight` 对象的效果，我们提供了一个简单的示例。在浏览器中打开 `05.04-create-a-sun-like-light.html`。你将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_05_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_05_06.jpg)'
- en: With the controls in the top-right section, you can enable and disable `THREE.HemisphereLight`
    and `THREE.DirectionalLight`, which are used in this scene.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角的控件中，你可以启用和禁用场景中使用的 `THREE.HemisphereLight` 和 `THREE.DirectionalLight`。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating `THREE.HemisphereLight` works in pretty much the same way as creating
    the other lights:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `THREE.HemisphereLight` 的方法几乎与其他灯光相同：
- en: 'You first need to instantiate a `THREE.HemisphereLight` instance:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要实例化一个 `THREE.HemisphereLight` 实例：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first parameter sets the color of the sky, and the second color sets the
    color reflected from the floor. In both these cases, we just set a white light.
    With the last property, you can control the intensity of `THREE.HemisphereLight`
    object. In this case, we dampen the light by setting it to `0.6`.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个参数设置天空的颜色，第二个颜色设置从地板反射的颜色。在这两种情况下，我们只是设置了一种白光。通过最后一个属性，你可以控制 `THREE.HemisphereLight`
    对象的强度。在这种情况下，我们将灯光减弱到 `0.6`。
- en: 'Next, we need to position the light:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定位灯光：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you position `THREE.HemisphereLight`, it's best to position it directly
    above the scene for the best effect.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你定位 `THREE.HemisphereLight` 时，最好将其直接放置在场景上方以获得最佳效果。
- en: 'Finally, with the position set, the last step is to add the light to the scene:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在设置好位置后，最后一步是将灯光添加到场景中：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You could use `THREE.HemisphereLight` as the main light source of your scene,
    but most often, this light source is used together with a different light source.
    For the best outdoor effect, use it with `THREE.DirectionalLight`, which can cast
    shadows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `THREE.HemisphereLight` 作为场景的主光源，但通常情况下，这个光源会与另一个光源一起使用。为了获得最佳的户外效果，请与可以投射阴影的
    `THREE.DirectionalLight` 一起使用。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`THREE.HemisphereLight` pretty much acts as two `THREE.DirectionalLight` objects:
    one positioned at the specified position and another one in exactly the opposite
    position. So, when a scene is rendered, `THREE.HemisphereLight` lights an object
    from the top and from the opposite direction to create a natural-looking effect.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.HemisphereLight` 几乎等同于两个 `THREE.DirectionalLight` 对象：一个位于指定的位置，另一个位于完全相反的位置。因此，当场景渲染时，`THREE.HemisphereLight`
    从顶部和相反方向照亮对象，以创建自然的外观效果。'
- en: There's more…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can, of course, also use two `THREE.DirectionalLight` objects instead of
    `THREE.HemisphereLight`. With careful tuning, you can reach the exact same effect
    as you would get with `THREE.HemisphereLight`. The added advantage is that you
    could also make very faint shadows with this approach, as `THREE.DirectionalLight`
    supports casting shadows whereas `THREE.HemisphereLight` does not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以使用两个 `THREE.DirectionalLight` 对象来代替 `THREE.HemisphereLight`。经过仔细调整，你可以达到与使用
    `THREE.HemisphereLight` 相同的效果。额外的优势是，你还可以使用这种方法创建非常微弱的阴影，因为 `THREE.DirectionalLight`
    支持投射阴影，而 `THREE.HemisphereLight` 则不支持。
- en: See also
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In the *Softening lights by adding ambient lighting* recipe, we showed you a
    more simple approach of supporting the main light sources in your scene. We showed
    you how you can use `THREE.AmbientLight` as an extra light source to soften the
    lights and the shadows.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *通过添加环境光照软化灯光* 的配方中，我们向您展示了一种更简单的方法来支持场景中的主光源。我们向您展示了如何使用 `THREE.AmbientLight`
    作为额外的光源来软化灯光和阴影。
- en: Adding a moving all-directional light
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加全方向移动的灯光
- en: In a lot of cases, you don't need a light source that casts shadows but just
    a light source that illuminates your scene. In the *Creating shadows with THREE.SpotLight*
    and *Creating shadows with THREE.DirectionalLight* recipes, we already showed
    you how you can use `THREE.SpotLight` and `THREE.DirectionalLight`. In this recipe,
    we'll show you a third kind of light, which is `THREE.PointLight`; this kind of
    light emits light to all directions and in this recipe, we will show you how to
    create one and move it through the scene.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，你不需要投射阴影的光源，只需要照亮场景的光源。在 *使用 THREE.SpotLight 创建阴影* 和 *使用 THREE.DirectionalLight
    创建阴影* 的食谱中，我们已经向你展示了如何使用 `THREE.SpotLight` 和 `THREE.DirectionalLight`。在这个食谱中，我们将展示第三种灯光，即
    `THREE.PointLight`；这种灯光向所有方向发射光线，在这个食谱中，我们将向你展示如何创建一个并使其在场景中移动。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'As the Three.js standard comes with the `THREE.PointLight` object, there is
    no need to include any additional JavaScript. The same is the case with all the
    recipes where we''ve included an example where you can see the result of this
    recipe in action. For this recipe, open the `05.05-use-a-point-light.html` example
    in your browser, and you''ll see the following result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Three.js 标准自带 `THREE.PointLight` 对象，因此不需要包含任何额外的 JavaScript。所有包含示例的食谱也是如此，你可以看到这个食谱的实际效果。对于这个食谱，请在浏览器中打开
    `05.05-use-a-point-light.html` 示例，你会看到以下结果：
- en: '![Getting ready](img/1182OS_05_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_05_07.jpg)'
- en: In this example, there are four `THREE.PointLight` objects that move from the
    top to the bottom in between three models of a shark. You can use your mouse to
    move around this scene and see how `THREE.PointLight` illuminates the models.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有四个 `THREE.PointLight` 对象在三条鲨鱼模型之间从上到下移动。你可以使用鼠标在这个场景中移动，看看 `THREE.PointLight`
    如何照亮模型。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating a moving `THREE.PointLight` object is very easy and only takes a couple
    of steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个移动的 `THREE.PointLight` 对象非常简单，只需几个步骤：
- en: 'The first thing to do is create a `THREE.PointLight` instance:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的事情是创建一个 `THREE.PointLight` 实例：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the `color` property, we set the color `THREE.PointLight` object emits,
    and the intensity allows us to set how much light is emitted. Finally, the `distance`
    property is used to calculate how much the intensity decreases the farther away
    the lit object is from the light. In this case, the intensity will be `0` when
    the distance to the light is `60`.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `color` 属性，我们设置 `THREE.PointLight` 对象发射的颜色，强度允许我们设置发射多少光线。最后，`distance` 属性用于计算被照亮的物体离灯光越远，强度降低的程度。在这种情况下，当距离灯光为
    `60` 时，强度将为 `0`。
- en: '`THREE.PointLight` emits lights in all directions, so we need to set the `position`
    property and then we can add the light to the scene:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`THREE.PointLight` 在所有方向上发射光线，因此我们需要设置 `position` 属性，然后我们可以将灯光添加到场景中：'
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last thing we need to do for this recipe is move `THREE.PointLight` through
    the scene. Like all animations, we do this in the render loop by adding the following
    to the `render` function:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们最后需要做的是将 `THREE.PointLight` 在场景中移动。像所有动画一样，我们在渲染循环中这样做，通过在 `render`
    函数中添加以下内容：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this small code snippet, we first get a reference to our `THREE.PointLight`
    object and then update its `position.y` property. For this to work, we also need
    to define a global `count` property at the top of our JavaScript like this:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个简短的代码片段中，我们首先获取 `THREE.PointLight` 对象的引用，然后更新其 `position.y` 属性。为了使这可行，我们还需要在
    JavaScript 的顶部定义一个全局的 `count` 属性，如下所示：
- en: '[PRE22]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With these simple steps, you've created `THREE.PointLight`, which moves up and
    down through the scene.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的步骤，你已经创建了 `THREE.PointLight`，它会在场景中上下移动。
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`THREE.PointLight` emits light in all directions; you can compare this a bit
    with `THREE.SpotLight` but with a 360 degree field of view in all directions.
    This is also the main reason that `THREE.PointLight` can''t be used to cast shadows.
    As there is so much light being emitted by `THREE.PointLight`, it is very difficult
    and resource-intensive to calculate the resulting shadows.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.PointLight` 在所有方向上发射光线；你可以将其与 `THREE.SpotLight` 进行比较，但拥有360度的视野。这也是为什么
    `THREE.PointLight` 不能用来投射阴影的主要原因。由于 `THREE.PointLight` 发射了大量的光线，因此计算产生的阴影非常困难且资源密集。'
- en: So, if you want shadows and also use `THREE.PointLight`, you could use a shadow
    map if you have a static `THREE.PointLight` object or an extra `THREE.SpotLight`
    object and set it to only cast shadows with the `onlyShadow` property.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想要阴影并且使用`THREE.PointLight`，你可以使用阴影贴图，如果你有一个静态的`THREE.PointLight`对象或额外的`THREE.SpotLight`对象，并且将其设置为仅通过`onlyShadow`属性投射阴影。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'There are a couple of recipes that you can look at in relation to this recipe:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个菜谱你可以参考这个菜谱：
- en: In the *Creating shadows with a THREE.SpotLight* recipe, we showed you how you
    can use `THREE.SpotLight` to create shadows. You can use this together with `THREE.PointLight`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用THREE.SpotLight创建阴影*菜谱中，我们展示了如何使用`THREE.SpotLight`来创建阴影。你可以与`THREE.PointLight`一起使用。
- en: In the *Creating shadows with a THREE.DirectionalLight* recipe, we show you
    how to set up and configure `THREE.DirectionalLight`. This light casts shadows
    and can be used together with `THREE.PointLight`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用THREE.DirectionalLight创建阴影*菜谱中，我们向你展示了如何设置和配置`THREE.DirectionalLight`。这种灯光可以投射阴影，可以与`THREE.PointLight`一起使用。
- en: In [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials and
    Textures*, we showed you the *Using a shadow map for fixed shadows* recipe. This
    recipe explained how to use shadow maps to fake shadows. If you use that recipe
    together with this one, you can use it to fake the shadows cast by `THREE.PointLight`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章. 材质和纹理")，*材质和纹理*中，我们展示了*使用阴影贴图创建固定阴影*菜谱。这个菜谱解释了如何使用阴影贴图来模拟阴影。如果你将这个菜谱与这个菜谱一起使用，你可以用它来模拟`THREE.PointLight`投射的阴影。
- en: Moving a light source along a path
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿路径移动灯光源
- en: In the *Add an moving all-directional light* recipe, we moved a light source
    up and down. While these simple kinds of paths are often enough, there are cases
    where you want more control over how your light source moves through a scene.
    In this recipe, we'll show you how you can move a light source along a predefined
    path.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在*添加一个全方向移动的灯光*菜谱中，我们将灯光源上下移动。虽然这些简单的路径通常已经足够，但在某些情况下，你可能希望对灯光源在场景中的移动有更多的控制。在这个菜谱中，我们将向你展示如何使灯光源沿着预定义的路径移动。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To create this recipe, we''ll use a `THREE.SplineCurve3D` and `THREE.SpotLight`
    object. As both of these objects are included with Three.js, we don''t need to
    take any steps to get ready. A good thing to do, however, is look at the provided
    example for this recipe, which will show you what you''ll get when you execute
    the steps from this recipe when you run the `05.06-move-a-light-through-the-scene.html`
    example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个菜谱，我们将使用`THREE.SplineCurve3D`和`THREE.SpotLight`对象。由于这两个对象都包含在Three.js中，我们不需要采取任何准备步骤。然而，查看这个菜谱提供的示例是一个好主意，它将展示当你运行`05.06-move-a-light-through-the-scene.html`示例时，执行这个菜谱的步骤会得到什么结果：
- en: '![Getting ready](img/1182OS_05_08.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_05_08.jpg)'
- en: In the screenshot, you can see a light that moves slowly along the purple line.
    In the next section, we'll show you how you can create this yourself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图上，你可以看到一个沿着紫色线条缓慢移动的光。在下一节中，我们将向你展示如何自己创建这样的效果。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this recipe, we first need to create the path that we''ll follow:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们首先需要创建我们将要遵循的路径：
- en: 'For this path, we''ll create `THREE.SplineCurve3`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个路径，我们将创建`THREE.SplineCurve3`：
- en: '[PRE23]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will result in a curved path that moves through the points added in the
    constructor of the `THREE.SplineCurve3` object.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生一个通过`THREE.SplineCurve3`对象构造函数中添加的点移动的曲线路径。
- en: 'Before we position our light on the path of this `THREE.SplineCurve3` object,
    let''s create the light:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将灯光放置在`THREE.SplineCurve3`对象的路径上之前，让我们创建灯光：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can use this `SplineCurve3` object to determine the position of our
    light. For this, we create a helper function called `positionLight`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个`SplineCurve3`对象来确定我们灯光的位置。为此，我们创建了一个名为`positionLight`的辅助函数：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this function, we use `spline.getPointAt(pos)` to determine where on the
    `THREE.SplineCurve3` path we need to position our light. With `pos` at `0`, we're
    at the beginning of spline and with `pos` at `1`, we're at the end. This way,
    we slowly (in steps of `0.001`) move the light along the spline.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用`spline.getPointAt(pos)`来确定在`THREE.SplineCurve3`路径上的哪个位置放置我们的灯光。当`pos`为`0`时，我们在样条的起点，当`pos`为`1`时，我们在样条的终点。这样，我们以`0.001`的步长缓慢地移动灯光沿样条。
- en: 'All that is left to do is call the `positionLight` function from the render
    function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是从渲染函数中调用`positionLight`函数：
- en: '[PRE26]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As the render function is called approximately 60 times per second and we take
    1000 steps for our complete path, the light will move along the complete path
    in about 17 seconds.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于渲染函数大约每秒调用 60 次，而我们为完整路径取了 1000 步，因此光线将在大约 17 秒内沿着完整路径移动。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you instantiate a `THREE.SplineCurve3` object, you pass in an array of
    `THREE.Vector3` objects. Three.js internally interpolates these points to create
    a fluid curve that moves through all these points. Once the curve is created,
    you have two ways to get positions. You can use the `getPointAt` function, as
    we did in this recipe, to get a relative position based on the provided parameter,
    from `0` to `1`, and the length of the curve. Alternatively, you can also use
    the `getPoints` function, where you specify, as the parameter, in how many points
    the line should be divided.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化一个 `THREE.SplineCurve3` 对象时，你传递一个 `THREE.Vector3` 对象的数组。Three.js 内部对这些点进行插值以创建一个穿过所有这些点的流畅曲线。一旦曲线创建完成，你有两种方式来获取位置。你可以使用
    `getPointAt` 函数，就像我们在本配方中所做的那样，根据提供的参数获取相对位置，从 `0` 到 `1`，以及曲线的长度。或者，你也可以使用 `getPoints`
    函数，其中你指定作为参数，线应该被分成多少点。
- en: There's more…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In the *Getting ready* part of this recipe, we showed you an example where
    a light moved through a scene. What you could see was that we also showed the
    path along which the light moved. To do this for yourself, you can use the `getPoints`
    function from the created `THREE.SplineCurve3` object to create a `THREE.Line`
    object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方的 *准备工作* 部分，我们向你展示了光线在场景中移动的示例。你所看到的是，我们还展示了光线移动的路径。为了自己做到这一点，你可以使用创建的 `THREE.SplineCurve3`
    对象的 `getPoints` 函数来创建一个 `THREE.Line` 对象：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this recipe, we moved a light along a specific path. However, as a light
    is also just an object with a specific position, we can apply this same principle
    to all the other objects in the scene, such as `THREE.Mesh`, `THREE.PerspectiveCamera`,
    or `THREE.OrthographicCamera`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使光线沿着特定的路径移动。然而，由于光线也是一个具有特定位置的对象，我们可以将这个相同的原理应用到场景中的所有其他对象上，例如 `THREE.Mesh`、`THREE.PerspectiveCamera`
    或 `THREE.OrthographicCamera`。
- en: Making a light source follow an object
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使光源跟随对象
- en: If you've got a moving object in the scene that you want to highlight with a
    spotlight, you need to be able to change the direction a light is pointed at.
    In this recipe, we will show you how to do just that. We will show you how you
    can keep `THREE.SpotLight` pointed at a moving object in the scene.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你场景中有一个你想要用聚光灯突出的移动对象，你需要能够改变光线指向的方向。在这个配方中，我们将向你展示如何做到这一点。我们将向你展示如何使场景中的
    `THREE.SpotLight` 指向移动对象。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are no steps that you need to take to run this recipe. You can see the
    final result of this recipe by opening up the `05.07-make-a-light-follow-object.html`
    example in your browser. You will see something similar to the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个配方不需要采取任何步骤。你可以在浏览器中打开 `05.07-make-a-light-follow-object.html` 示例来查看这个配方的最终结果。你将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_05_09.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_05_09.jpg)'
- en: In this example, you can see a sphere that moves from left to right and back
    again. `THREE.SpotLight` in this scene follows the position of this sphere so
    that it is always pointed directly at the center of that object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到一个从左到右移动然后再返回的球体。场景中的 `THREE.SpotLight` 跟随这个球体的位置，使其始终直接指向该对象中心。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Following an object in Three.js is very easy and only takes a couple of easy
    steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中跟踪一个对象非常简单，只需要几个简单的步骤：
- en: 'The fist thing we need to do is create the object that we want to follow. For
    this recipe, this is `THREE.SpotLight`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建我们想要跟踪的对象。对于这个配方，这是 `THREE.SpotLight`：
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we create and add `THREE.SpotLight` to the scene:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建并添加 `THREE.SpotLight` 到场景中：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that at this step, we don't point the created light to the sphere. We'll
    do this in the next step in the render loop.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这个步骤中，我们没有将创建的光指向球体。我们将在渲染循环的下一步中这样做。
- en: 'To keep the light pointed at the sphere, we need to set the `target` property
    to the correct value. We do this in the `render` function of the scene:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使光线指向球体，我们需要将 `target` 属性设置为正确的值。我们在场景的 `render` 函数中这样做：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One thing to notice in the last step is that we set the target property of `spotLight`
    to the `THREE.Mesh` object and not to the position property of `THREE.Mesh`.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一步中需要注意的一点是，我们将 `spotLight` 的目标属性设置为 `THREE.Mesh` 对象，而不是 `THREE.Mesh` 的位置属性。
- en: There's more…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'To point `THREE.SpotLight` at a certain position, we set its `target` property.
    As you''ve seen in the recipe steps, we target `THREE.Object3D`, from which `THREE.Mesh`
    extends, instead of a position. If we want to point `THREE.SpotLight` to an arbitrary
    position, we need to first create an empty `THREE.Object3D` object:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `THREE.SpotLight` 指向一个特定的位置，我们设置其 `target` 属性。正如你在食谱步骤中看到的，我们针对 `THREE.Object3D`，它是
    `THREE.Mesh` 扩展的，而不是一个位置。如果我们想将 `THREE.SpotLight` 指向任意位置，我们需要首先创建一个空的 `THREE.Object3D`
    对象：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This way, you can point `THREE.SpotLight` not just to an existing object in
    the scene but to any position you want.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以将 `THREE.SpotLight` 指向场景中的任意位置，而不仅仅是现有的对象。
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: In this recipe, we pointed a light at a specific target, and we can also make
    a camera follow an object around the scene, as we showed in the *Making the camera
    follow an object* recipe from [Chapter 3](ch03.html "Chapter 3. Working with the
    Camera"), *working with the Camera* and point one object to another, as shown
    in the *Pointing an object to another object* recipe in [Chapter 2](ch02.html
    "Chapter 2. Geometries and Meshes"), *Geometries and Meshes*.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将灯光指向了特定的目标，我们也可以让相机围绕场景中的对象移动，就像我们在第 3 章的 *让相机跟随对象* 食谱中展示的那样，*与相机一起工作*，以及将一个对象指向另一个对象，就像在第
    2 章的 *指向另一个对象* 食谱中展示的那样，*几何体和网格*。
- en: Creating a custom vertex shader
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义顶点着色器
- en: When you want to create advanced 3D effects with great performance, you can
    choose to write your own shaders. **Shaders** are programs that directly affect
    what your results look like and which colors are used to represent them. A shader
    always comes as a pair. A vertex shader determines what a geometry will look like,
    and a fragment shader will determine the resulting color. In this recipe, we'll
    show you how you can use your own custom vertex shader in Three.js.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想创建具有出色性能的高级 3D 效果时，你可以选择编写自己的着色器。**着色器**是直接影响你的结果看起来像什么以及用于表示它们的颜色的程序。着色器总是成对出现。顶点着色器确定几何体的外观，而片段着色器将确定最终的颜色。在这个食谱中，我们将向你展示如何在
    Three.js 中使用你自己的自定义顶点着色器。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: WebGL and GLSL, which is the language in which you write shaders, are supported
    by most modern browsers. So, for this recipe, there aren't any additional steps
    you need to take before you can walk through this recipe. A good resource on GLSL
    is always the khronos website ([http://www.khronos.org](http://www.khronos.org));
    they have a great tutorial ([http://www.khronos.org/webgl/wiki/Tutorial](http://www.khronos.org/webgl/wiki/Tutorial))
    on WebGL that can help you better understand what we're doing in this recipe.
    For this specific recipe, we've provided two examples. The first one is the one
    we'll use in this recipe, and you can view this one by opening `05.09-custom-vertex-shader.html`
    in your browser.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 和 GLSL，即你编写着色器的语言，被大多数现代浏览器支持。因此，对于这个食谱，在你开始这个食谱之前，不需要采取任何额外的步骤。关于 GLSL
    的好资源总是 Khronos 网站 ([http://www.khronos.org](http://www.khronos.org))；他们有一个关于 WebGL
    的优秀教程 ([http://www.khronos.org/webgl/wiki/Tutorial](http://www.khronos.org/webgl/wiki/Tutorial))，可以帮助你更好地理解在这个食谱中我们正在做什么。对于这个特定的食谱，我们提供了两个示例。第一个是我们将在本食谱中使用的示例，你可以通过在浏览器中打开
    `05.09-custom-vertex-shader.html` 来查看这个示例。
- en: '![Getting ready](img/1182OS_05_10.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_05_10.jpg)'
- en: This example, as you can see in the previous screenshot, shows you `THREE.BoxGeometry`,
    where the position of its individual vertices have been replaced using a vertex
    shader. A more advanced example can be found in `05.09-custom-vertex-shader-2.html`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，这个示例展示了 `THREE.BoxGeometry`，其中其单个顶点的位置已被顶点着色器替换。一个更高级的示例可以在 `05.09-custom-vertex-shader-2.html`
    中找到。
- en: '![Getting ready](img/1182OS_05_11.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_05_11.jpg)'
- en: In this example, we once again change the position of individual vertices, but
    this time, we use `THREE.SphereGeometry` as the source and combine it with a perlin
    noise generator.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次改变了单个顶点的位置，但这次，我们使用 `THREE.SphereGeometry` 作为源，并结合一个 Perlin 噪声生成器。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a custom vertex shader, you need to follow these steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义顶点着色器，你需要遵循以下步骤：
- en: 'As we just want to write a vertex shader, we''ll use a standard fragment shader,
    which is the one also used by `THREE.MeshBasicMaterial` from Three.js. You can
    get a reference to this shader by selecting the correct one from `THREE.ShaderLib`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们只想编写顶点着色器，我们将使用标准的片段着色器，这是 Three.js 中 `THREE.MeshBasicMaterial` 也使用的着色器。你可以通过从
    `THREE.ShaderLib` 中选择正确的着色器来获取对这个着色器的引用：
- en: '[PRE32]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next step is to define the `Uniforms` object. `Uniforms` are parameters
    that are passed into the shaders as arguments:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义`Uniforms`对象。`Uniforms`是作为参数传递到着色器中的参数：
- en: '[PRE33]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this code snippet, we first `merge` the standard uniforms that are by the
    fragment shader we reuse, we set a texture, and the last two uniforms are the
    ones we access in our own custom vertex shader, as we'll see later on.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先`合并`了由片段着色器重用的标准统一变量，我们设置了一个纹理，最后两个统一变量是我们将在后面看到的自定义顶点着色器中访问的变量。
- en: 'Now, we can define `THREE.ShaderMaterial` and tell Three.js the shaders that
    we want to use:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`THREE.ShaderMaterial`并告诉Three.js我们想要使用的着色器：
- en: '[PRE34]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this code snippet, you can see that we reference the `uniform` value we saw
    in step 2, as `fragmentShader` we use `basicShader` from step 1, and for the `vertexShader`
    parameter, we reference our custom shader, which we'll define in the next step.
    Note that we also provide a `defines` element; this is needed to make sure Three.js
    shows our texture.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你可以看到我们引用了在第2步中看到的`uniform`值，我们使用的`fragmentShader`是第1步中的`basicShader`，对于`vertexShader`参数，我们引用了我们将在下一步定义的自定义着色器。注意，我们还提供了一个`defines`元素；这是确保Three.js显示我们的纹理所必需的。
- en: 'At this point, we can define our own custom vertex shader. We do this directly
    in the HTML as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以定义我们自己的自定义顶点着色器。我们直接在HTML中这样做：
- en: '[PRE35]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this shader, we change the location of the vertices by changing the `p.z`
    and the `p.x` part of its position.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个着色器，我们通过改变其位置中的`p.z`和`p.x`部分来改变顶点的位置。
- en: 'At this point, we can just create a geometry and use the material we created
    in step 3:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需创建一个几何体，并使用我们在第3步中创建的材料：
- en: '[PRE36]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you look in the shader code in step 4, you can see that the position is
    influenced by the delta uniform value. We use the `render` function to pass in
    a new value for this uniform:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你查看第4步中的着色器代码，你可以看到位置受到delta统一值的影响。我们使用`render`函数传递一个新的值给这个统一变量：
- en: '[PRE37]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These are all the steps you need to take to create and use a custom vertex shader
    combined with a simple fragment shader from Three.js.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是你需要采取的步骤来创建和使用与简单的片段着色器结合的自定义顶点着色器。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s look a bit closer at what is happening in the vertex shader used in
    this recipe. Before we start, we''ll give you a very short introduction to the
    types of qualifiers that you can use with the variables in your shader code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看在这个食谱中使用的顶点着色器中发生了什么。在我们开始之前，我们将给你一个非常简短的介绍，说明你可以与着色器代码中的变量一起使用的限定符类型：
- en: 'The `uniform` qualifier: This is a global variable that can be passed in from
    JavaScript to the shaders. You can change this value in each rendering loop but
    can''t change the value in the shader itself.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniform`限定符：这是一个全局变量，可以从JavaScript传递到着色器中。你可以在每个渲染循环中更改这个值，但不能在着色器本身中更改这个值。'
- en: 'The `attribute` qualifier: This is a value that can be specified for each individual
    vertex. The `attributes` qualifier are passed on into the vertex shader.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute`限定符：这是一个可以指定给每个单独顶点的值。`attributes`限定符被传递到顶点着色器中。'
- en: 'The `varying` qualifier: This is used to pass data between the vertex shader
    and the fragment shader. It can be written into the vertex shader but can only
    be read in the fragment shader.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`varying`限定符：用于在顶点着色器和片段着色器之间传递数据。它可以在顶点着色器中写入，但只能在片段着色器中读取。'
- en: 'The `const` qualifier: This is a constant value and is defined directly in
    your shader code. This value can''t change during the execution of your shaders.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`限定符：这是一个常量值，它直接定义在你的着色器代码中。这个值在着色器执行过程中不能改变。'
- en: 'The first thing we do is define some parameters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一些参数：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `vUv` vector is a varying variable and is a value that is passed into the
    fragment shader and is required for the basic shader to work in Three.js. The
    other two parameters are passed in as uniforms from the JavaScript you saw in
    the previous section. Let''s look at the main function, which is the function
    that is exectured for each vertex:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`vUv`向量是一个变化变量，是一个传递到片段着色器中的值，对于Three.js中的基本着色器工作来说是必需的。其他两个参数作为统一变量从上一节中看到的JavaScript中传递进来。让我们看看主函数，这是为每个顶点执行的功能：'
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The main thing that happens here is that we change the position of the vertex
    based on the passed-in delta and some `sin` and `cos` functions. The result is
    that each vertex of our model is displaced in some manner. Finally, we need to
    set the `gl_Position` variable with the new position of our vertex.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的主要事情是我们根据传入的delta值和一些`sin`和`cos`函数来改变顶点的位置。结果是我们的模型中的每个顶点都以某种方式偏移。最后，我们需要用我们顶点的新位置设置`gl_Position`变量。
- en: There's more…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When you look for information on custom shaders, you''ll most often see examples
    of fragment shaders. In many use cases, a vertex shader doesn''t need to change
    the positions of the vertices. When it does, it is often for effects such as smoke
    or fire. There aren''t that many good vertex shaders examples out there. The following
    two sites, however, provide a good starting point if you want to learn more about
    vertex shaders:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你寻找关于自定义着色器的信息时，你通常会看到片段着色器的示例。在许多用例中，顶点着色器不需要改变顶点的位置。当它确实需要改变时，通常是为了产生烟雾或火焰等效果。好的顶点着色器示例并不多。然而，以下两个网站提供了学习顶点着色器的良好起点：
- en: A good resource to learn more about vertex shaders is the shader tutorial from
    lighthouse3d at [http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/](http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于顶点着色器的资源，可以参考来自lighthouse3d的着色器教程，链接为[http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/](http://www.lighthouse3d.com/tutorials/glsl-tutorial/shader-examples/)
- en: There is also an online vertex shader editor available at kickjs.org, which
    you can find at [http://www.kickjs.org/example/shader_editor/shader_editor.html](http://www.kickjs.org/example/shader_editor/shader_editor.html)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在kickjs.org上也有一个在线顶点着色器编辑器可用，你可以在这里找到它：[http://www.kickjs.org/example/shader_editor/shader_editor.html](http://www.kickjs.org/example/shader_editor/shader_editor.html)
- en: See also
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料也请查看
- en: As a vertex shader is always accompanied with a fragment shader, it is good
    to also understand how they work. In the *Creating a custom fragment shader* recipe,
    we explain the steps you need to take to set up a custom fragment shader.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于顶点着色器总是与片段着色器一起使用，因此了解它们的工作原理也是好的。在*创建自定义片段着色器*菜谱中，我们解释了你需要采取的步骤来设置自定义片段着色器。
- en: Creating a custom fragment shader
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义片段着色器
- en: 'A WebGL shader always consists of two parts: the vertex shader that can be
    used to reposition the individual vertices of the model and a fragment shader
    that can be used to add color to the model. In this recipe, we''ll show you the
    steps you need to take to use a custom fragment shader.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个WebGL着色器始终由两部分组成：顶点着色器，它可以用来重新定位模型的各个顶点；以及片段着色器，它可以用来给模型添加颜色。在这个菜谱中，我们将向你展示使用自定义片段着色器所需的步骤。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Before we start with the fragment shader, there is one thing you need to know.
    Just like with a vertex shader, you don't write the fragment shader code in JavaScript.
    These shaders are written in the GLSL language. So, if you want to learn more
    about the functions and notations used in this example, look at the WebGL specification,
    which can be found at [https://www.khronos.org/registry/webgl/specs/1.0/](https://www.khronos.org/registry/webgl/specs/1.0/).
    If you want to experiment with the provided shader code, you can just open up
    `05.10-custom-fragment-shader.html` in your browser.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论片段着色器之前，有一件事你需要知道。就像顶点着色器一样，你不会用JavaScript编写片段着色器代码。这些着色器是用GLSL语言编写的。因此，如果你想了解更多关于这个例子中使用的函数和符号，请查看WebGL规范，可以在[https://www.khronos.org/registry/webgl/specs/1.0/](https://www.khronos.org/registry/webgl/specs/1.0/)找到。如果你想实验提供的着色器代码，你只需在浏览器中打开`05.10-custom-fragment-shader.html`即可。
- en: '![Getting ready](img/1182OS_05_12.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_05_12.jpg)'
- en: This shader colors an object based on the normal vector and on the distance
    from the camera. In the following sections, we will explain how you can do this.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器根据法向量以及从相机到物体的距离来给物体上色。在接下来的章节中，我们将解释如何做到这一点。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start with the JavaScript part of this recipe:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个菜谱的JavaScript部分开始：
- en: 'A shader always consists of a vertex shader and a fragment shader. In this
    recipe, we''ll use the standard vertex shader provided by Three.js and provide
    our own custom fragment shader. Three.js keeps all its shaders in `THREE.ShaderLib`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器始终由顶点着色器和片段着色器组成。在这个菜谱中，我们将使用Three.js提供的标准顶点着色器，并为我们提供自己的自定义片段着色器。Three.js将其所有着色器保存在`THREE.ShaderLib`中：
- en: '[PRE40]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In step 3, we'll reference this `basicShader` object to get the standard vertex
    shader.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在步骤3中，我们将引用这个`basicShader`对象来获取标准的顶点着色器。
- en: 'For our custom shader, we have some configuration options. These options are
    passed into a shader using uniforms:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This means that in our shader code, we can access the `delta`, `mNear`, and
    `mFar` values, all of which are floating point values, and we can use them to
    calculate the colors we want to render.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we can create the shader material:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the configuration of `THREE.ShaderMaterial`, we reference our `uniform` variable,
    the standard vertex shader, `basicShader.vertexShader` provided by Three.js, and
    our own custom fragment shader. We'll show you the definition of our custom shader
    in step 5.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last thing we need to do is create `THREE.BoxGeometry` and add it to the
    scene using the material created in the previous step:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In step 3, we referenced a DOM element with the simple-fragment name. In your
    HTML page, you should define it like this:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you want to know more about how this fragment shader works, look at the explanation
    in the *How it works...* section of this recipe.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you''ve looked at the example from the *Getting ready* section, you can
    see that the colors change constantly. This happens because we update the delta
    property, which is passed into our custom shader, in the `render` loop of this
    page:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how this shader works, let''s look through the code step by step.
    Let''s start by looking at the variables used in this shader:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `vNormal` object is a variable that is passed in from the standard Three.js
    vertex shader and contains the value of the normal vector applicable to this fragment.
    The three uniform values are passed in from the JavaScript, as we''ve seen in
    the previous section. The PI variable is a constant that doesn''t change over
    time. Each fragment shader should set the `gl_fragColor` vector, which determines
    the color and opacity of each fragment. For this shader, we set the vector as
    follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Without going into too many GLSL details, roughly the following steps are taken:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: First, we determine the depth of this fragment. You can see this as the distance
    of this fragment from the camera.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As depth is an absolute value, we convert it to a scale of `0` to `1` using
    the `smoothstep` function. As this function also takes the `mNear` and `mFar`
    uniforms as its parameters, we can control how much the depth affects the color
    of a fragment from JavaScript.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we define the color of the fragment by setting `gl_FragColor`. The
    `gl_FragColor` variable is of type `vec4`, where the first three values determine
    the RGB value of the color and the last one defines the opacity. This is all on
    a scale of `0` to `1`. For each part of the color, we use a function that includes
    the `vNormal` vector and calculated `depthColor` variable to generate a color.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is just the tip of the iceberg of what you can do with custom fragment
    shaders. In the upcoming section, you can find some resources to learn more about
    this.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating custom fragment shaders is rather difficult. It''ll take a lot of
    experimenting, a good grasp of math, and a lot of patience. There are, however,
    a number of resources available that can help you understand fragment shaders
    and learn from the work of others:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义片段着色器相当困难。这需要大量的实验、良好的数学掌握和大量的耐心。然而，有一些资源可以帮助您理解片段着色器并从他人的作品中学习：
- en: Lots of fragment shaders can be found at [http://glslsandbox.com/](http://glslsandbox.com/)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 [http://glslsandbox.com/](http://glslsandbox.com/) 找到大量的片段着色器。
- en: 'On the Shadertoy site, you can experiment fragment shaders using different
    kinds of input: [https://www.shadertoy.com/](https://www.shadertoy.com/)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Shadertoy 网站上，您可以使用不同类型的输入进行片段着色器实验：[https://www.shadertoy.com/](https://www.shadertoy.com/)
- en: A simple online shader editor can be found at [http://shdr.bkcore.com/](http://shdr.bkcore.com/)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 [http://shdr.bkcore.com/](http://shdr.bkcore.com/) 找到一个简单的在线着色器编辑器。
- en: Another great help can be the latest version of Firefox Dev Tools. This is a
    special version of Firefox, which provides great debugging support and even includes
    a shader editor that you can use to edit a shader program and directly see the
    results. You can download this version from [https://www.mozilla.org/en-US/firefox/developer/](https://www.mozilla.org/en-US/firefox/developer/).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项极大的帮助可能是最新版本的 Firefox 开发者工具。这是一个特殊的 Firefox 版本，它提供了出色的调试支持，甚至包括一个着色器编辑器，您可以使用它来编辑着色器程序并直接查看结果。您可以从[https://www.mozilla.org/en-US/firefox/developer/](https://www.mozilla.org/en-US/firefox/developer/)下载这个版本。
- en: There is, of course, the khronos website ([http://www.khronos.org](http://www.khronos.org)),
    which is a great resource to find out what a specific function actually does.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有 khronos 网站 ([http://www.khronos.org](http://www.khronos.org))，这是一个查找特定函数实际做什么的极好资源。
- en: See also
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: As a fragment shader is always accompanied with a vertex shader, it is good
    to also understand how they work. In the *Creating a custom vertex shader* recipe,
    we explained the steps you need to take to set up a custom vertex shader.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于片段着色器总是与顶点着色器一起使用，因此了解它们的工作方式也是很好的。在 *创建自定义顶点着色器* 菜单中，我们解释了您需要采取的步骤来设置自定义顶点着色器。
