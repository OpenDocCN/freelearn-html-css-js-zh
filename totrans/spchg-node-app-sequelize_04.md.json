["```js\nActor.hasOne(Job);\nconst actor = await Actor.create({ … });\n```", "```js\nawait actor.createJob({ name: '…' });\n```", "```js\nconst job = await Job.create({ name: '…' });\nawait actor.setJob(job);\n```", "```js\nawait actor.setJob(null);\n```", "```js\nActor.belongsTo(Job);\n```", "```js\nActor.hasMany(Job);\nlet jobs = await Job.findAll();\nawait Actor.setJobs(jobs);\nawait Actor.getJobs();\n```", "```js\nawait Actor.createJob({ name: '…' });\n```", "```js\nconst job = await Job.findOne();\n// true or false boolean value\nconst hasJob = await Actor.hasJob(job);\n// using jobs from our previous example\nconst hasAllJobs = await Actor.hasJobs(jobs);\n```", "```js\nawait Actor.addJob(job);\nawait Actor.addJobs(jobs);\n```", "```js\n// will return 2 following the examples in this section\nawait Actor.countJobs();\n```", "```js\nawait Actor.removeJob(job);\nawait Actor.removeJobs(jobs);\n```", "```js\nActor.belongsToMany(Job, { through: '...' });\n```", "```js\nActor.hasOne(Job, {\n  as: 'gig'\n});\nconst actor = await Actor.create({ … });\nconst gig = await Job.create({ … });\nactor.createGig({ … });\nactor.setGig(gig);\nactor.hasGig(gig);\n```", "```js\nconst A = sequelize.define('A', { … });\nconst B = sequelize.define('B', { … });\nA.hasOne(B);\nB.belongsTo(A);\n```", "```js\nCREATE TABLE IF NOT EXISTS \"b\" (\n  /* ... */\n);\nCREATE TABLE IF NOT EXISTS \"b\" (\n  /* ... */\n  \"aId\" INTEGER REFERENCES \"a\" (\"id\") ON DELETE SET NULL ON UPDATE CASCADE\n  /* ... */\n);\n```", "```js\nA.hasOne(B, {\n    onUpdate: 'SET NULL',\n    onDelete: 'CASCADE',\n    foreignKey: 'otherId'\n});\nB.belongsTo(A);\nA.hasOne(B, {\n    onUpdate: 'CASCADE',\n    onDelete: 'SET NULL',\n    foreignKey: { name: 'otherId' }\n});\nB.belongsTo(A);\n```", "```js\nA.hasOne(B);\nB.belongsTo(A, {\n    onUpdate: 'SET NULL',\n    onDelete: 'CASCADE',\n    foreignKey: 'otherId'\n});\nA.hasOne(B);\nB.belongsTo(A, {\n    onUpdate: 'CASCADE',\n    onDelete: 'SET NULL',\n    foreignKey: { name: 'otherId' }\n});\n```", "```js\nA.hasOne(B, {\n  foreignKey: { allowNull: false }\n});\n```", "```js\nOrganization.hasMany(Employee);\nEmployee.belongsTo(Organization);\n```", "```js\nCREATE TABLE IF NOT EXISTS \"Organizations\" (\n  /* ... */\n);\nCREATE TABLE IF NOT EXISTS \"Employees\" (\n  /* ... */\n  \"OrganizationId\" INTEGER REFERENCES \"Organizations\" (\"id\") ON DELETE SET NULL ON UPDATE CASCADE,\n  /* ... */\n);\n```", "```js\nEmployee.belongsToMany(Task, { through: 'EmployeeTasks' });\nTask.belongsToMany(Employee, { through: 'EmployeeTasks' });\n```", "```js\nCREATE TABLE IF NOT EXISTS \"EmployeeTasks\" (\n    \"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n    \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\n    \"EmployeeId\" INTEGER REFERENCES \"Employees\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    \"TaskId\" INTEGER REFERENCES \"Tasks\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\n    PRIMARY KEY (\"EmployeeId\",\"TaskId\")\n);\n```", "```js\n// Employee and Task are pre-defined for brevity\nconst EmployeeTasks = sequelize.define('EmployeeTasks', {\n    EmployeeId: {\n      type: DataTypes.INTEGER,\n      references: {\n        model: Employee,\n        key: 'id'\n      }\n    },\n    TaskId: {\n      type: DataTypes.INTEGER,\n      references: {\n        model: 'Tasks', // string literal values work here \n                           too\n        key: 'id'\n      }\n    },\n    SomeOtherColumn: {\n        type: DataTypes.STRING\n    }\n});\nEmployee.belongsToMany(Task, {\n    through: EmployeeTasks\n});\nTask.belongsToMany(Employee, {\n    through: EmployeeTasks\n});\n```", "```js\nconst Actor = sequelize.define('Actors', {\n    name: {\n        type: DataTypes.TEXT,\n        unique: true\n    }\n});\nconst Role = sequelize.define('Roles', {\n    title: {\n        type: DataTypes.TEXT,\n        unique: true\n    }\n});\nconst Costume = sequelize.define('Costumes', {\n    wardrobe: {\n        type: DataTypes.TEXT,\n        unique: true\n    }\n});\n```", "```js\nActor.hasOne(Role, {\n    sourceKey: 'name',\n    foreignKey: 'actorName'\n});\n```", "```js\nRoles.hasMany(Costumes, {\n    sourceKey: 'title',\n    foreignKey: 'roleTitle'\n});\n```", "```js\nRoles.belongsTo(Actors, {\n    targetKey: 'name',\n    foreignKey: 'actorName'\n});\n```", "```js\nCostumes.belongsToMany(Actors, {\n    through: 'actor_costumes',\n    sourceKey: 'name',\n    targetKey: 'wardrobe'\n});\n```", "```js\nconst actor = await Actor.findOne();\n// SELECT * FROM jobs WHERE actorId=?\nconst job = await Actor.getJob();\nlet reviews = [];\nif (job.isDone) {\n  // SELECT * FROM reviews WHERE jobId=?\n  reviews = await job.getReviews({\n    where: { published: true }\n  });\n}\n```", "```js\nconst jobs = await Actor.getJobs();\nlet reviews = [];\njobs.map(async job => {\n  if (job.isDone) {\n    let jobReviews = await job.getReviews({\n      where: { published: true }\n    });\n    reviews = reviews.concat(jobReviews);\n  }\n});\n```", "```js\nconst completedJobs = {\n    model: Job,\n    as: 'CompletedJobs',\n    where: {\n        completed: true\n    },\n    include: {\n        model: Review,\n        where: {\n            published: true\n        }\n    }\n}\n```", "```js\nconst incompleteJobs = {\n    model: Job,\n    as: 'IncompleteJobs',\n    where: {\n        completed: false\n    }\n}\n```", "```js\nconst actor = await Actor.findOne({\n    include: [ completedJobs, incompleteJobs ]\n});\n```", "```js\nSELECT\n    `Actor`.*,\n    `CompletedJobs`.`title` AS `CompletedJobs.title`,\n    `CompletedJobs`.`completed` AS `CompletedJobs.completed`,\n    `CompletedJobs->Reviews`.`id` AS `CompletedJobs.Reviews.     id`,\n    `CompletedJobs->Reviews`.`published` AS `CompletedJobs.\n     Reviews.published`,\n\n    `IncompleteJobs`.`title` AS `IncompleteJobs.title`,\n    `IncompleteJobs`.`completed` AS `IncompleteJobs.completed`\n\nFROM (\n    SELECT `Actor`.`id`, `Actor`.`name`, `Actor`.`createdAt`, \n    `Actor`.`updatedAt`\n    FROM `Actors` AS `Actor`\n    LIMIT 1\n) AS `Actor`\nLEFT OUTER JOIN `Jobs` AS `CompletedJobs` ON\n    `Actor`.`id` = `CompletedJobs`.`ActorId` AND\n    `CompletedJobs`.`completed` = true\nLEFT OUTER JOIN `Reviews` AS `CompletedJobs->Reviews` ON\n    `CompletedJobs`.`id` = `CompletedJobs->Reviews`.`JobId` AND\n    `CompletedJobs->Reviews`.`published` = true\nLEFT OUTER JOIN `Jobs` AS `IncompleteJobs` ON\n    `Actor`.`id` = `IncompleteJobs`.`ActorId` AND\n    `IncompleteJobs`.`completed` = false;\n```", "```js\nconst jobs = [].concat(\n  actor.CompletedJobs,\n  actor.IncompleteJobs\n);\n```", "```js\njobs.forEach(job => {\n  const reviews = job.Reviews || [];\n  // display reviews here\n});\n```", "```js\nconst Worker = sequelize.define('worker', { name: DataTypes.STRING });\nconst Task = sequelize.define('task', {\n  title: DataTypes.STRING,\n  completed: DataTypes.BOOLEAN\n});\nWorker.hasMany(Task, {\n    scope: {\n        completed: true\n    },\n    as: 'completedTasks'\n});\nconst worker = await Worker.create({ name: \"Bob\" });\nawait worker.getCompletedTasks();\n```", "```js\nSELECT `id`, `completed`, `workerId`\nFROM `tasks` AS `task`\nWHERE `task`.`completed` = true AND `task`.`workerId` = 1;\n```", "```js\nTask.addScope('completed', {\n    where: { completed: true }\n});\nWorker.hasMany(Task.scope('completed'), {\n  as: 'completedTasks'\n});\n```", "```js\nconst worker = Worker.findOne();\nawait worker.createCompletedTask({ title: 'Repair Cluster' });\n```", "```js\nINSERT INTO \"tasks\" (\n    \"id\", \"title\", \"completed\"\n) VALUES (\n    DEFAULT, 'Repair Cluster', true, 1\n) RETURNING *;\n```", "```js\nconst WorkerTask = sequelize.define('WorkerTask', {\n  published: DataTypes.BOOLEAN\n});\nWorker.belongsToMany(Task.scope('completed'), {\n  through: {\n    model: WorkerTasks,\n    scope: { published: true }\n  },\n  as: 'CompletedAndPublishedTask'\n});\n```", "```js\nconst Employee = sequelize.define('employee', {\n  name: DataTypes.STRING,\n});\nconst Customer = sequelize.define('customer', {\n  name: DataTypes.STRING\n});\nconst Transaction = sequelize.define('transaction', {\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true,\n    allowNull: false\n  },\n  couponCode: DataTypes.STRING\n});\n```", "```js\nEmployee.belongsToMany(Customer, { through: Transaction });\nCustomer.belongsToMany(Employee, { through: Transaction });\n```", "```js\nEmployee.hasMany(Transaction);\nTransaction.belongsTo(Employee);\nCustomer.hasMany(Transaction);\nTransaction.belongsTo(Customer);\n```", "```js\nEmployee.findAll({ include: Customer });\nCustomer.findAll({ include: Employee });\n```", "```js\nEmployee.findAll({ include: Transaction });\nCustomer.findAll({ include: Transaction });\n```", "```js\nTransaction.findAll({ include: Employee });\nTransaction.findAll({ include: Customer });\n```", "```js\nEmployee.belongsToMany(Customer, { through: Transaction });\nCustomer.belongsToMany(Employee, { through: Transaction });\nEmployee.hasMany(Transaction);\nTransaction.belongsTo(Employee);\nCustomer.hasMany(Transaction);\nTransaction.belongsTo(Customer);\n```", "```js\nconst Widget = sequelize.define('Widget', {\n  sku: DataTypes.STRING,\n  url: DataTypes.STRING\n});\nconst Gizmo = sequelize.define('Gizmo', {\n  name: DataTypes.STRING\n});\n```", "```js\nconst Review = sequelize.define('Review', {\n  message: DataTypes.STRING,\n  entityId: DataTypes.INTEGER,\n  entityType: DataTypes.STRING\n}, {\n    instanceMethods: {\n        getEntity(options) {\nif (!this.entityType) return Promise.resolve(null);\nconst mixinMethodName = `get${this.entityType}`;\n            return this[mixinMethodName](options);\n        }\n    }\n});\n```", "```js\nWidget.hasMany(Review, {\n  foreignKey: 'entityId',\n  constraints: false,\n  scope: {\n    entityType: 'Widget'\n  }\n});\nReview.belongsTo(Widget, { foreignKey: 'entityId', \n                           constraints: false });\nGizmo.hasMany(Review, {\n  foreignKey: 'entityId',\n  constraints: false,\n  scope: {\n    entityType: 'Gizmo'\n  }\n});\nReview.belongsTo(Gizmo, { foreignKey: 'entityId', \n                          constraints: false });\n```", "```js\nReview.addHook(\"afterFind\", findResult => {\nif (!Array.isArray(findResult)) findResult = [findResult];\n  for (const instance of findResult) {\n    if (instance.entityType === \"Widget\" && instance.Widget \n        !== undefined) {\n      instance.entity = instance.Widget;\n    } else if (instance.entityType === \"Gizmo\" && in\n               stance.Gizmo !== undefined) {\n      instance.entity = instance.Gizmo;\n    }\n  }\n});\n```", "```js\nconst widget = await Widget.create({ sku: \"WID-1\" });\nconst review = await widget.createReview({ message: \"it works!\" });\n// the following should be true\nconsole.log(review.entityId === widget.id);\n```", "```js\nconst entity = await review.getEntity();\n// widget and entity should be the same object and return \n   \"true\" for deep comparison checking\nconst isDeepEqual = require('deep-equal');\nconsole.log(isDeepEqual(widget, entity));\n```", "```js\nconst reviews = await Review.findAll({\n    include: [Widget, Gizmo]\n});\nfor (const review of reviews) {\n    console.log('Found a review with the following entity: \n                 ', review.entity.toJSON());\n}\n```", "```js\nconst Category = sequelize.define('Category', {\n    name: DataTypes.STRING\n}, {\n    instanceMethods: {\n        getEntities(options) {\n            const widgets = await this.getWidgets(options);\n            const gizmos = await this.getGizmos(options);\n            return [].concat(widgets, gizmos);\n        }\n    }\n});\n```", "```js\nconst CategoryEntity = sequelize.define('CategoryEntity', {\n    categoryId: {\n        type: DataTypes.INTEGER,\n        unique: 'ce_unique_constraint'\n    },\n    entityId: {\n        type: DataTypes.INTEGER,\n        unique: 'ce_unique_constraint',\n        references: null\n    },\n    entityType: {\n        type: DataTypes.STRING,\n        unique: 'ce_unique_constraint'\n    }\n});\n```", "```js\nconst throughJunction = {\n    through: {\n      model: CategoryEntity,\n      unique: false\n    },\n    foreignKey: 'entityId',\n    constraints: false\n};\nfunction scopeJunction(scope) {\n    let opts = throughJunction;\n    opts.through.scope = {\n        entityType: scope\n    };\n    return opts;\n}\n```", "```js\nWidget.belongsToMany(Category, scopeJunction('Widget'));\nCategory.belongsToMany(Widget, throughJunction);\n\nGizmo.belongsToMany(Category, scopeJunction('Gizmo'));\nCategory.belongsToMany(Gizmo, throughJunction);\n```", "```js\nSELECT\n    `Category`.`id`,\n    `Category`.`name`,\n    `CategoryEntity`.`categoryId` AS `CategoryEntity.\n     categoryId`,\n    `CategoryEntity`.`entityId` AS `CategoryEntity.entityId`,\n    `CategoryEntity`.`entityType` AS `CategoryEntity.\n     entityType`,\nFROM `Categories` AS `Category`\nINNER JOIN `CategoryEntities` AS `CategoryEntity` ON\n    `Category`.`id` = `CategoryEntity`.`categoryId` AND\n    `CategoryEntity`.`entityId` = 1 AND\n    `CategoryEntity`.`entityType` = 'Widget';\n```", "```js\nclass Airplane extends Model {\n  static associate(models) {\nthis.FlightSchedules =\nthis.hasMany(models.FlightSchedule);\n  }\n};\n```", "```js\nclass BoardingTicket extends Model {\n  static associate(models) {\n    this.Customer = this.belongsTo(models['Customer']);\n    this.FlightSchedule = this.belongsTo(models['FlightSchedule']);\n  }\n};\n```", "```js\nclass Customer extends Model {\n  static associate(models) {\nthis.BoardingTickets = \nthis.hasMany(models.BoardingTicket);\n  }\n};\n```", "```js\nclass FlightSchedule extends Model {\n  static associate(models) {\n    this.Airplane = this.belongsTo(models['Airplane']);\n    this.BoardingTickets = this.hasMany(models['BoardingTicket']);\n  }\n};\n```", "```js\nsequelize migration:generate --name add-references\n```", "```js\nNew migration was created at /Users/book/migrations/20211031155604-add-references.js .\n```", "```js\nconst { DataTypes } = require(\"@sequelize/core\");\nmodule.exports = {\n  up: async (queryInterface, Sequelize) => { \n```", "```js\n    await queryInterface.addColumn('FlightSchedules', 'AirplaneId', {\n      type: DataTypes.INTEGER,\n    });\n    await queryInterface.addConstraint('FlightSchedules', {\n      type: 'foreign key',\n      fields: ['AirplaneId'],\n      references: {\n        table: 'Airplanes',\n        field: 'id'\n      },\n      name: 'fkey_flight_schedules_airplane',\n      onDelete: 'set null',\n      onUpdate: 'cascade'\n    });\n```", "```js\n    await queryInterface.addColumn('BoardingTickets', 'CustomerId', {\n      type: DataTypes.INTEGER,\n    }\n);    await queryInterface.addConstraint('BoardingTickets', {\n      type: 'foreign key',\n      fields: ['CustomerId'],\n      references: {\n        table: 'Customers',\n        field: 'id'\n      }\n,      name: 'fkey_boarding_tickets_customer',\n      onDelete: 'set null',\n      onUpdate: 'cascade'\n    });\n    await queryInterface.addColumn('BoardingTickets',  \n                                   'FlightScheduleId', {\n      type: DataTypes.INTEGER,\n    });\n    await queryInterface.addConstraint('BoardingTickets', {\n      type: 'foreign key',\n      fields: ['FlightScheduleId'],\n      references: {\n        table: 'FlightSchedules',\n        field: 'id'\n      },\n      name: 'fkey_boarding_tickets_flight_schedule',\n      onDelete: 'set null',\n      onUpdate: 'cascade'\n    });\n```", "```js\n  },\n  down: async (queryInterface, Sequelize) => {\n```", "```js\n    await queryInterface.removeConstraint(\n      'FlightSchedules', 'fkey_flight_schedules_airplane'\n    );\n    await queryInterface.removeConstraint(\n      'BoardingTickets', 'fkey_boarding_tickets_customer'\n    );\n    await queryInterface.removeConstraint(\n      'BoardingTickets', \n      'fkey_boarding_tickets_flight_schedule'\n    );\n    await queryInterface.removeColumn('FlightSchedules', \n       'AirplaneId');\n    await queryInterface.removeColumn('BoardingTickets', \n       'CustomerId');\n    await queryInterface.removeColumn('BoardingTickets', \n    'FlightScheduleId');\n  }\n};\n```", "```js\nsequelize db:migrate\n```"]