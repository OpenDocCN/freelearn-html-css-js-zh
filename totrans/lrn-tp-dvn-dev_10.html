<html><head></head><body>
        

                            
                    <h1 class="header-title">Bringing It All Together</h1>
                
            
            
                
<p>In the previous chapters, we explored the different tools and techniques available for doing type-driven development in ReasonML.</p>
<p>In this chapter, using a final example, we are going to develop a sense for when to use each type-driven technique to solve problems. Let's see how we could, at least partly, create code that handles input (within a small JavaScript app) for social, productivity, and business applications. To be precise, what we mean here are the kinds of successful applications, such as Gmail, Facebook, Twitter, Skype, Airbnb, or Uber, launched by Internet or platform companies.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Starting with a variant type (version 1)</li>
<li>Using more pattern matching (version 2)</li>
<li>Switching to polymorphic variant types (version 3)</li>
<li>Using records (version 4)</li>
<li>Using modules for code structure (version 5)</li>
<li>An alternative code structure (version 6)</li>
<li>An improvement: Using lists as output (version 7)</li>
<li>Another improvement: Using mutable records (version 8)</li>
<li>Unit testing our code (final version)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Starting with a variant type (version 1)</h1>
                
            
            
                
<p>First, we need a <kbd>type</kbd> to represent the companies, which are internet-powered apps. Based on that <kbd>type</kbd>, we can think of writing functions that will help us build our logic in a type-safe manner. Let's see how it goes.</p>
<p>As a first attempt, we start small, defining a variant type for the internet companies we are interested in. As we have seen in previous chapters, we will use pattern matching to show the list of apps each of these companies delivers to their users.</p>
<p>We define the internet company type as follows:</p>
<pre>type <strong>internetCompany</strong> =<br/>   | Facebook<br/>   | Google<br/>   | Twitter;</pre>
<p>Now, we define the function that shows the applications, based on the company, as follows:</p>
<pre>let <em>apps</em> = (company: <strong>internetCompany</strong>) : string =&gt; {<br/>   switch (company) {<br/>     | Facebook =&gt; "facebook, messenger, ads"<br/>     | Google =&gt; "gmail, google+, maps, ads"<br/>     | Twitter =&gt; "twitter"<br/>   }<br/> };</pre>
<p>The following code will show some apps from Google:</p>
<pre>let <em>googleApps</em> = apps(Google);<br/>Js.log(googleApps);</pre>
<p>Here is the output of the whole code (generated from <kbd>src/Ch10/Ch10_PlatformCompany_V1.re</kbd>):</p>
<pre>gmail, google+, maps, ads</pre>
<p>That's a good start.</p>
<p>Since there are different categories of applications involved (social, business, communication, entertainment, and so on), we could enrich our type-driven logic by using more pattern matching code to differentiate the list of applications. Let's do that now.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using more pattern matching (version 2)</h1>
                
            
            
                
<p>If we change the variants' constructors to pass a string to them to represent each possible category (for example <kbd>Facebook(string)</kbd>, which could give <kbd>Facebook("social")</kbd> or <kbd>Facebook("business")</kbd>), we can do the trick. The additional pattern matching could then be something like this:</p>
<pre>Facebook(str) =&gt; switch str {            <br/>        | "social" =&gt; "facebook, messenger, instagram"<br/>        | "business" =&gt; "facebook ads"</pre>
<p>So, let's start the second version of our code by defining the internet company variant type, as follows:</p>
<pre>type <strong>internetCompany </strong>=<br/>   | Facebook(string)<br/>   | Google(string)<br/>   | Twitter(string);</pre>
<p>And, as we planned, our function's pattern matching code could evolve, as follows:</p>
<pre>let <strong>apps</strong> = (company: <strong>internetCompany</strong>) : string =&gt; {<br/>   switch (company) {<br/>     | Facebook(str) =&gt; switch str {            <br/>         | "social" =&gt; "facebook, messenger, instagram"<br/>         | "business" =&gt; "facebook ads"<br/>     }<br/>     | Google(str) =&gt; switch str {            <br/>         | "social" =&gt; "google+, gmail"<br/>         | "business" =&gt; "google ads, google adsense, gmail for business"<br/>     }<br/>     | Twitter(str) =&gt; switch str {            <br/>         | "social" =&gt; "twitter"<br/>         | "business" =&gt; "twitter ads"<br/>     }   <br/>   }<br/> };</pre>
<p class="mce-root"/>
<p>Now, the following code will show some result data, so we can see whether things work as expected:</p>
<pre>Js.log(Js.String.toUpperCase("facebook"))<br/>Js.log("Business: " ++ apps(Facebook("business")));<br/>Js.log("Social: " ++ apps(Facebook("social")));<br/> <br/>Js.log(Js.String.toUpperCase("google"))<br/>Js.log("Business: " ++ apps(Google("business")));<br/>Js.log("Social: " ++ apps(Google("social")));</pre>
<p>Here is the output we get when executing this version (<kbd>src/Ch10/Ch10_PlatformCompany_V2.bs.js</kbd>, generated from <kbd>src/Ch10/Ch10_PlatformCompany_V2.re</kbd>):</p>
<pre>FACEBOOK<br/>Business: facebook ads<br/>Social: facebook, messenger, instagram<br/>GOOGLE<br/>Business: google ads, google adsense, gmail for business<br/>Social: google+, gmail</pre>
<p>Note that our type only accounts for internet companies, but our logic should also apply to other modern companies that use technology (web mobile, databases, AI) to build and deliver services in a scalable way. We can call them <strong>platform companies</strong>. So, we could add a type for platform companies too.</p>
<p>We can even consider that some internet companies (the big ones at least) are also platform companies or have launched platform businesses. So, we could change from <em>normal variant types</em> to <em>polymorphic variant types</em> to use their capability for type reuse.</p>
<p>Let's start the third version based on these new ideas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Switching to polymorphic variant types (version 3)</h1>
                
            
            
                
<p>In this new version, we define the two types we build our logic around, reusing the first one inside the second one, as follows:</p>
<pre>type <strong>internetCompany</strong> = [ `Facebook(string) | `Google(string) | `Twitter(string) ];<br/>type <strong>platformCompany</strong> = [ internetCompany | `Amazon(string) | `Uber(string) ]</pre>
<p>Based on that, we make our function evolve as follows (using <kbd>platformCompany</kbd> to allow all the variants to be accepted for the <kbd>company</kbd> parameter):</p>
<pre>let <em>apps</em> = (company: <strong>platformCompany</strong>) : string =&gt; {<br/>  switch (company) {<br/>    | `Facebook(str) =&gt; switch str {            <br/>      | "social" =&gt; "facebook, messenger, instagram"<br/>      | "business" =&gt; "facebook ads"<br/>    }<br/>    | `Google(str) =&gt; switch str {            <br/>      | "social" =&gt; "google+, gmail"<br/>      | "business" =&gt; "google ads, google adsense, gmail for business"<br/>    }<br/>    | `Twitter(str) =&gt; switch str {            <br/>      | "social" =&gt; "twitter"<br/>      | "business" =&gt; "twitter ads"<br/>    }   <br/>    | `Amazon(str) =&gt; switch str {            <br/>      | "social" =&gt; ""<br/>      | "business" =&gt; "amazon, AWS"<br/>    } <br/>    | `Uber(str) =&gt; switch str {            <br/>      | "social" =&gt; ""<br/>      | "business" =&gt; "uber"<br/>    } <br/>  }<br/>};</pre>
<p>And now, let's add the usual quick data display code, as follows:</p>
<pre>Js.log(Js.String.toUpperCase("facebook"))<br/>Js.log("Business: " ++ apps(`Facebook("business")));<br/>Js.log("Social: " ++ apps(`Facebook("social")));<br/>Js.log("")<br/><br/>Js.log(Js.String.toUpperCase("google"))<br/>Js.log("Business: " ++ apps(`Google("business")));<br/>Js.log("Social: " ++ apps(`Google("social")));<br/>Js.log("")<br/><br/>Js.log(Js.String.toUpperCase("uber"))<br/>Js.log("Business: " ++ apps(`Uber("business")));</pre>
<p class="mce-root"/>
<p>That seems like a good improvement, but let's see whether it works. Testing the generated JavaScript code (based on <kbd>src/Ch10/Ch10_PlatformCompany_V3.re</kbd>) gives the following output:</p>
<pre>FACEBOOK<br/>Business: facebook ads<br/>Social: facebook, messenger, instagram<br/><br/>GOOGLE<br/>Business: google ads, google adsense, gmail for business<br/>Social: google+, gmail<br/><br/>UBER<br/>Business: uber</pre>
<p>Nice! What could we add to that?</p>
<p>Although this implementation is nice, you can quickly see it lacks the ability to handle a richer data structure. Basically, we would like to represent an <em>app</em> with all the needed information, such as <em>the name</em>, and <em>the URL</em> (at least for web apps). For that, Reason has a convenient tool we can use: <em>records</em>.</p>
<p>Let's see how it goes with the next version, using records to handle apps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using records (version 4)</h1>
                
            
            
                
<p>Nothing changes from our first variant types, but we will add the <kbd>webapp</kbd> record type definition to them, as follows:</p>
<pre>type <strong>internetCompany</strong> = [ `Facebook(string) | `Google(string) | `Twitter(string) ];<br/>type <strong>platformCompany</strong> = [ internetCompany | `Amazon(string) | `Uber(string) ];<br/>type <strong>webapp</strong> = {<br/>  <em>name</em>: <strong>string</strong>,<br/>  <em>url</em>: <strong>string</strong>,<br/>};</pre>
<p>Then, we can input some data for the rest of the program, using that record type, as follows:</p>
<pre>/* some data */<br/>let <em>facebook</em>: webapp = {<br/>  <em>name</em>: "facebook",<br/>  <em>url</em>: "https://facebook.com",<br/>}<br/>let <em>facebookads</em>: webapp = {<br/>  <em>name</em>: "facebook ads",<br/>  <em>url</em>: "https://www.facebook.com/business",<br/>}<br/>let <em>messenger</em>: webapp = {<br/>  <em>name</em>: "messenger",<br/>  <em>url</em>: "https://www.facebook.com/messenger",<br/>}<br/>let <em>instagram</em>: webapp = {<br/>  <em>name</em>: "instagram",<br/>  <em>url</em>: "https://www.instagram.com",<br/>}</pre>
<p>Note that we just defined a few of those values for a minimal test. The real production-ready code should include all the record values needed.</p>
<p>The minimal <kbd>apps</kbd> function would then look like the following:</p>
<pre>let <em>apps</em> = (company: <strong>platformCompany</strong>) : string =&gt; {<br/>  switch (company) {<br/>    | `Facebook(str) =&gt; switch str {            <br/>        | "social" =&gt; facebook.name ++ ", " ++ messenger.name ++ ", " ++ instagram.name<br/>        | "business" =&gt; facebookads.name<br/>    }<br/>  }<br/>};</pre>
<p>Let's add some output display code, as follows:</p>
<pre>Js.log(Js.String.toUpperCase("facebook"));<br/>Js.log("Business: " ++ apps(`Facebook("business")));<br/>Js.log("Social: " ++ apps(`Facebook("social")));</pre>
<p>We get the following output for that minimal testing case (code from the <kbd>src/Ch10/Ch10_PlatformCompany_V4.re</kbd> file):</p>
<pre>FACEBOOK<br/>Business: facebook ads<br/>Social: facebook, messenger, instagram</pre>
<p>In the next version, we will also use the URL of each app and show it in the output.</p>
<p>We can also improve the global code structure by packaging some types and functions in modules.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using modules for code structure (version 5)</h1>
                
            
            
                
<p>The first improvement we can make is to create a module to contain the record for the web apps and a function that would return their string representation. Let's call that module <kbd>WebApp</kbd>. Its definition is as follows:</p>
<pre><strong>module</strong> <em>WebApp</em> = {<br/>  type <strong>t</strong> = {<br/>    <em>name</em>: string,<br/>    <em>url</em>: string,<br/>  };<br/><br/>  let <em>toString</em> = (app: t) =&gt; app.name ++ " (" ++ app.url ++ ")" ;<br/>}</pre>
<p>Then, as in the previous version, we have our example web app values. The only thing that changes is that the type annotation is done using <kbd>WebApp.t</kbd>. That part of the code is as follows:</p>
<pre>let <em>facebook</em>: WebApp.t = {<br/>  <em>name</em>: "facebook",<br/>  <em>url</em>: "https://facebook.com",<br/>}<br/>let <em>facebookads</em>: WebApp.t = {<br/>  <em>name</em>: "facebook ads",<br/>  <em>url</em>: "https://www.facebook.com/business",<br/>}<br/>let <em>messenger</em>: WebApp.t = {<br/>  <em>name</em>: "messenger",<br/>  <em>url</em>: "https://www.facebook.com/messenger",<br/>}<br/>let <em>instagram</em>: WebApp.t = {<br/>  <em>name</em>: "instagram",<br/>  <em>url</em>: "https://www.instagram.com",<br/>}</pre>
<p>We then create a module, called <kbd>Platform</kbd>, for the rest of the logic. It could contain the definition of the types for companies and the <kbd>apps</kbd> function. To make things simple, let's choose to have a unique polymorphic variant type that contains all the companies. Within the module, we can call it <kbd>t</kbd>.</p>
<p class="mce-root"/>
<p>We create the module as follows:</p>
<pre><strong>module</strong> <em>Platform</em> = {  <br/>  type <strong>t</strong> = [ `Facebook(string) <br/>             | `Google(string) <br/>             | `Twitter(string) <br/>             | `Amazon(string) <br/>             | `Uber(string) <br/>           ];<br/><br/>  let <em>apps</em> = (company: t) : string =&gt; {<br/>    switch (company) {<br/>      | `Facebook(str) =&gt; switch str {            <br/>          | "social" =&gt; WebApp.toString(facebook) ++ ", " ++ WebApp.toString(messenger) ++ ", " ++ WebApp.toString(instagram)<br/>          | "business" =&gt; WebApp.toString(facebookads)<br/>      }<br/>    }<br/>  };<br/>}</pre>
<p>We can add a similar code that shows some possible output, and the code execution (JS code generated from the <kbd>src/Ch10/Ch10_PlatformCompany_V5.re</kbd> file) gives us an output similar to this:</p>
<pre>FACEBOOK<br/>Business: facebook ads (https://www.facebook.com/business)<br/>Social: facebook (https://facebook.com), messenger (https://www.facebook.com/messenger), instagram (https://www.instagram.com)</pre>
<p>Our result is encouraging. There may be different possibilities, so let's continue experimenting by trying an alternative code structure and later adding improvements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An alternative code structure (version 6)</h1>
                
            
            
                
<p class="mce-root">At this point, it's actually possible to write comprehensive code while using fewer modules in our code file. Let's keep the platform module, but move out what we had in the <kbd>WebApp</kbd> module in <em>Using modules for code structure (version 5)</em>, thus eliminating that module. At the same time, we will adjust some names and definitions.</p>
<p class="mce-root"/>
<p>While we have fewer modules, we can improve our type-based code by introducing an interface file (<kbd>src/Ch10/Ch10_PlatformCompany_V6.rei</kbd>) to hold type information for the <kbd>.re</kbd> file (<kbd>src/Ch10/Ch10_PlatformCompany_V6.re</kbd>), as follows:</p>
<pre>type <strong>webapp</strong>;<br/>type <strong>pfcompany</strong>;<br/><br/>let <em>appToString</em>: webapp =&gt; string;</pre>
<p>Next, we define the <kbd>webapp</kbd> and <kbd>pfcompany</kbd> types and adjust the <kbd>appToString</kbd> function accordingly (in <kbd>src/Ch10/Ch10_PlatformCompany_V6.re</kbd>), as follows:</p>
<pre>/* Basic types and functions we need (see .rei file) */<br/><br/>type <strong>webapp</strong> = {<br/>    <em>name</em>: string,<br/>    <em>url</em>: string,<br/>};<br/><br/>type <strong>pfcompany</strong> = [ `Facebook(string) <br/>                    | `Google(string) <br/>                    | `Twitter(string) <br/>                    | `Amazon(string) <br/>                    | `Uber(string) <br/>                    ];<br/><br/>let <em>appToString</em> = (app: webapp) =&gt; app.name ++ " (" ++ app.url ++ ")" ;</pre>
<p>Then, there is no algorithmic change in the part where we do the <em>let bindings</em> to have input data for the web apps, so because of readability, we will not repeat that part of the code here. You can see the complete set of record values in the <kbd>src/Ch10/Ch10_PlatformCompany_V6.re</kbd> file, and you will notice that we added input for some Google apps, as shown here:</p>
<pre>/* Data */<br/><br/>/* ... <br/>   Extract from src/Ch10/Ch10_PlatformCompany_V6.re */<br/><br/>let <em>google</em>: webapp = {<br/>  <em>name</em>: "google",<br/>  <em>url</em>: "https://google.com",<br/>}<br/>let <em>gmail</em>: webapp = {<br/>  <em>name</em>: "gmail",<br/>  <em>url</em>: "https://google.com/gmail",<br/>}<br/>let <em>googleads</em>: webapp = {<br/>  <em>name</em>: "google ads",<br/>  <em>url</em>: "https://ads.google.com",<br/>}<br/>let googleplus: webapp = {<br/>  <em>name</em>: "google+",<br/>  <em>url</em>: "https://plus.google.com",<br/>}</pre>
<p>Next, we improve the <kbd>Platform</kbd> module code:</p>
<ul>
<li>We have the <kbd>Platform</kbd> module, which is preceded by its signature, <kbd>PlatformType</kbd>.</li>
<li>We're using <kbd>pfcompany</kbd> now as the type for the <kbd>company</kbd> values.</li>
<li>We added the case of Google (and their apps) in the code for pattern matching in the <kbd>apps</kbd> function.</li>
</ul>
<p>The improvised part of the platform module code is as follows:</p>
<pre>/* Platform module, signature followed by implementation */<br/><br/><strong>module</strong> type <strong>PlatformType</strong> = {<br/>  let apps: <strong>pfcompany</strong> =&gt; string;<br/>};<br/><br/><strong>module</strong> <em>Platform</em>: <strong>PlatformType</strong> = {  <br/>  let <em>apps</em> = (company: <strong>pfcompany</strong>) : string =&gt; {<br/>    switch (company) {<br/>      | `Facebook(str) =&gt; switch str {            <br/>          | "social" =&gt; appToString(facebook) ++ ", " ++ appToString(messenger) ++ ", " ++ appToString(instagram)<br/>          | "business" =&gt; appToString(facebookads)<br/>      }<br/><br/>      | `Google(str) =&gt; switch str {            <br/>          | "social" =&gt; appToString(googleplus)<br/>          | "business" =&gt; appToString(googleads)<br/>      }<br/>    }<br/>  };<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To make this version of the implementation easily testable, we add the usual input and output printing code, as follows:</p>
<pre>Js.log("Facebook")<br/>Js.log("Business: " ++ Platform.apps(`Facebook("business")));<br/>Js.log("Social: " ++ Platform.apps(`Facebook("social")));<br/>print_newline();<br/>Js.log("Google")<br/>Js.log("Business: " ++ Platform.apps(`Google("business")));<br/>Js.log("Social: " ++ Platform.apps(`Google("social")));</pre>
<p>To recap, we improved the type declarations using a <kbd>.rei</kbd> file (which helps with code documentation), we added a module signature (<kbd>PlatformType</kbd>) for platform, and we improved the coverage of the input by adding the Google case.</p>
<p>The reader is encouraged to add input data (for the other companies in the variant type, such as Twitter, Amazon, and Uber).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An improvement – using lists as output (version 7)</h1>
                
            
            
                
<p>You noticed that in our output, we are just using strings (via concatenation). From the beginning, we could have returned a real list of the apps from each company. No problem, let's change the code to do that now.</p>
<p>The change is limited to the <kbd>Platform</kbd> module. In the signature, for the <kbd>apps</kbd> function, we change the output type from <kbd>string</kbd> to <kbd>list(string)</kbd>. And, in the pattern matching part of the function, we change the implementation accordingly, for example, by returning the <kbd>[appToString(facebook), appToString(messenger), appToString(instagram)]</kbd> list for Facebook apps.</p>
<p>The main part of the new version is as follows:</p>
<pre>/* Platform module, signature followed by implementation */<br/> <br/><strong> module</strong> type <strong>PlatformType</strong> = {<br/>   let <em>apps</em>: <strong>pfcompany</strong> =&gt; list(string);<br/> };<br/> <br/> <strong>module</strong> <em>Platform</em>: <strong>PlatformType</strong> = {  <br/>   let <em>apps</em> = (company: <strong>pfcompany</strong>) : list(string) =&gt; {<br/>     switch (company) {<br/>       | `Facebook(str) =&gt; switch str {            <br/>           | "social" =&gt; [appToString(facebook), appToString(messenger), appToString(instagram)]<br/>           | "business" =&gt; [appToString(facebookads),]<br/>       }<br/> <br/>       | `Google(str) =&gt; switch str {            <br/>           | "social" =&gt; [appToString(googleplus),]<br/>           | "business" =&gt; [appToString(googleads),]<br/>       }<br/>     }<br/>   };<br/> }</pre>
<p class="mce-root">Since we now output lists, it is a good idea to use <kbd>Array.of_list</kbd> to print them, since it is a  nice and quick  solution. We change the last part of the code with the following:</p>
<pre class="mce-root"> Js.log("Facebook")<br/> print_string("Business: ")<br/> Js.log(Array.of_list(Platform.apps(`Facebook("business"))));<br/> print_string("Social: ")<br/> Js.log(Array.of_list(Platform.apps(`Facebook("social"))));<br/> print_newline();<br/> <br/> Js.log("Google")<br/> print_string("Business: ")<br/> Js.log(Array.of_list(Platform.apps(`Google("business"))));<br/> print_string("Social: ")<br/> Js.log(Array.of_list(Platform.apps(`Google("social"))));</pre>
<p>Executing the resulting code with my input data gives the following output:</p>
<pre>Facebook<br/>Business: [ 'facebook ads (https://www.facebook.com/business)' ]<br/>Social: [ 'facebook (https://facebook.com)',<br/>  'messenger (https://www.facebook.com/messenger)',<br/>  'instagram (https://www.instagram.com)' ]<br/><br/>Google<br/>Business: [ 'google ads (https://ads.google.com)' ]<br/>Social: [ 'google+ (https://plus.google.com)' ]</pre>
<p>Nice! This was an interesting improvement. Let's continue adding to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Another improvement – using mutable records (version 8)</h1>
                
            
            
                
<p>Now, we could use a mutable record for the <kbd>webapp</kbd> type, so that we use it for interesting app data that keeps updating. One such data point is the number of accounts created. Another one could be the number of downloads of the corresponding mobile app.</p>
<p>In this example, let's see how we can improve our implementation by adding the <em>number of accounts</em> parameter to the record. This is done by using <kbd>mutable numberOfAccounts: int</kbd> as the entry for that parameter in the record definition.</p>
<p>So that's the only change for now, but let's recap the definitions for the <kbd>webapp</kbd> type, the <kbd>pfcompany</kbd> type, and the <kbd>appToString</kbd> function for better readability, as follows: </p>
<pre>type <strong>webapp</strong> = {<br/>    <em>name</em>: <strong>string</strong>,<br/>    <em>url</em>: <strong>string</strong>,<br/>    mutable <em>numberOfAccounts</em>: <strong>int</strong>,<br/>};<br/><br/>type <strong>pfcompany</strong> = [ `Facebook(string) <br/>                    | `Google(string) <br/>                    | `Twitter(string) <br/>                    | `Amazon(string) <br/>                    | `Uber(string) <br/>                    ];<br/><br/>let <em>appToString</em> = (app: webapp) =&gt; app.name ++ " (" ++ app.url ++ ")" ;</pre>
<p>After that, let's add a function that increments the value of <kbd>numberofAccounts</kbd> in the record corresponding to a web app each time there is a new sign-up. This function could look as follows:</p>
<pre>let <em>newSignUp</em> = (app: webapp) : unit =&gt; {<br/>  app.<em>numberOfAccounts</em> = app.<em>numberOfAccounts</em> + 1;<br/>  ()<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Then, as before, we have the input data part. But now we have the new parameter <kbd>newSignUp</kbd> which we have to keep updating. To make things simple, let's pretend that all these apps currently have the same number of accounts, and we choose 10,000 as an arbitrary number. So, now the record definitions are as follows:</p>
<pre>/* Data */<br/><br/>let <em>facebook</em>: webapp = {<br/> <em> name</em>: "facebook",<br/> <em> url</em>: "https://facebook.com",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}<br/>let <em>facebookads</em>: webapp = {<br/>  <em>name</em>: "facebook ads",<br/>  <em>url</em>: "https://www.facebook.com/business",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}<br/>let <em>messenger</em>: webapp = {<br/>  <em>name</em>: "messenger",<br/>  <em>url</em>: "https://www.facebook.com/messenger",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}<br/>let <em>instagram</em>: webapp = {<br/>  <em>name</em>: "instagram",<br/>  <em>url</em>: "https://www.instagram.com",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}<br/>let <em>google</em>: webapp = {<br/>  <em>name</em>: "google",<br/>  <em>url</em>: "https://google.com",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}<br/>let <em>gmail</em>: webapp = {<br/>  <em>name</em>: "gmail",<br/>  <em>url</em>: "https://google.com/gmail",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}<br/>let <em>googleads</em>: webapp = {<br/>  <em>name</em>: "google ads",<br/>  <em>url</em>: "https://ads.google.com",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}<br/>let <em>googleplus</em>: webapp = {<br/>  <em>name</em>: "google+",<br/>  <em>url</em>: "https://plus.google.com",<br/>  <em>numberOfAccounts</em>: 10000,<br/>}</pre>
<p class="mce-root"/>
<p>There is no change in the <kbd>Platform</kbd> module part, so let's move to the next and last part, the code that tests things:</p>
<pre>Js.log("Facebook")<br/>print_string("Business: ")<br/>Js.log(Array.of_list(Platform.apps(`Facebook("business"))));<br/>print_string("Social: ")<br/>Js.log(Array.of_list(Platform.apps(`Facebook("social"))));<br/>print_newline();<br/><br/>Js.log("New sign-up on Instagram")<br/><em>newSignUp</em>(instagram);<br/>Js.log("New sign-up on Instagram")<br/><em>newSignUp</em>(instagram);<br/>Js.log(instagram.numberOfAccounts)</pre>
<p>Executing the code compiled from the <kbd>src/Ch10/Ch10_PlatformCompany_V5.re</kbd> file gives the following output:</p>
<pre>Facebook<br/>Business: [ 'facebook ads (https://www.facebook.com/business)' ]<br/>Social: [ 'facebook (https://facebook.com)',<br/>  'messenger (https://www.facebook.com/messenger)',<br/>  'instagram (https://www.instagram.com)' ]<br/><br/>New sign-up on Instagram<br/>New sign-up on Instagram<br/>10002</pre>
<p>So, we just took an interesting use case where mutable records can be used, and saw how easy it is to add that functionality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit testing our code (final version)</h1>
                
            
            
                
<p>Now is the time to add tests to our code! For a complete demonstration, let's create a new package in which we will do the necessary setup for writing unit tests with the <kbd>Jest</kbd> framework.</p>
<p>Another web technology used at Facebook, <kbd>Jest</kbd> is a framework for writing tests for JavaScript code, which also works with compile-to-JavaScript languages, such as TypeScript or ReasonML. For Reason, we also need to install the <kbd>bs-jest</kbd> package, which provides bindings for Jest in BuckleScript.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our final package and setting up for tests</h1>
                
            
            
                
<p>To quickly get things working, we create a folder, called <kbd>Ch10-final</kbd>, which contains the following file structure:</p>
<pre>bsconfig.json<br/>package.json<br/>src<br/>__tests__</pre>
<p>We got the <kbd>package.json</kbd> file by copying the one we were using, generated by the ReasonML or BuckleScript code starter, and adapting it. The first version is as follows:</p>
<pre>{<br/>  "name": "Ch10-final",<br/>  "version": "0.1.0",<br/>  "scripts": {<br/>    "build": "bsb -make-world",<br/>    "start": "bsb -make-world -w",<br/>    "clean": "bsb -clean-world"<br/>  },<br/>  "keywords": [<br/>    "BuckleScript"<br/>  ],<br/>  "author": "",<br/>  "license": "MIT",<br/>  "devDependencies": {<br/>    "bs-platform": "^4.0.7",<br/>  },<br/>  "dependencies": {}<br/>}</pre>
<p>Then, we can add <kbd>Jest</kbd> and <kbd>bs-jest</kbd> (the one referenced by <kbd>glennsl/bs-jest</kbd>, to be precise) as development dependencies to our package using <kbd>npm</kbd>.</p>
<p>To install <kbd>bs-jest</kbd>, run the <kbd>npm install @glennsl/bs-jest --save-dev</kbd> command.</p>
<p>To install <kbd>Jest</kbd>, run the <kbd>npm install jest --save-dev</kbd> command.</p>
<p class="mce-root"/>
<p>With these installations, the required files are installed in the usual <kbd>node_modules</kbd> subdirectory and our <kbd>package.json</kbd> file changes to reference both dependencies with the versions that were installed. The updated <kbd>devDependencies</kbd> in the <kbd>package.json</kbd> file shows the two additions, as seen in the following extract:</p>
<pre>"devDependencies": {<br/>    "@glennsl/bs-jest": "^0.4.5",<br/>    "bs-platform": "^4.0.7",<br/>    "jest": "^23.6.0"<br/>  },</pre>
<p>The <kbd>bsconfig.json</kbd> file is also copied (and adapted) from the one we were using for the previous code setup (which allows the <kbd>bsb -w</kbd> command to work, and our <kbd>.re</kbd> files to be compiled on the fly). We adjust the <kbd>sources</kbd> list to reference both the <kbd>src</kbd> directory for the usual code and the <kbd>__tests__</kbd> directory for the <em>test code</em> (notice the <kbd>"type": "dev"</kbd> part), as follows:</p>
<pre>"sources": [        <br/>    {<br/>      "dir" : "src",<br/>    },  <br/>    {<br/>      "dir": "__tests__",<br/>      "type": "dev",<br/>    },<br/>  ],</pre>
<p>The last thing we need to add is the <kbd>@glennsl/bs-jest</kbd> reference to the <kbd>bs-dev-dependencies</kbd> parameter. We will see why in a minute.</p>
<p>The <kbd>bsconfig.json</kbd> file for our <kbd>ch10final</kbd> package is as follows:</p>
<pre>{<br/>  "name": "ch10final",<br/>  "version": "0.1.0",<br/>  "sources": [        <br/>    {<br/>      "dir" : "src",<br/>    },  <br/>    {<br/>      "dir": "__tests__",<br/>      "type": "dev",<br/>    },<br/>  ],<br/>  "package-specs": {<br/>    "module": "commonjs",<br/>    "in-source": true<br/>  },<br/>  "suffix": ".bs.js",<br/>  "bs-dependencies": [<br/>  ],<br/>  "bs-dev-dependencies": ["@glennsl/bs-jest"],<br/>  "warnings": {<br/>    "error" : "+101"<br/>  },<br/>  "namespace": true,<br/>  "refmt": 3<br/>}</pre>
<p>In the <kbd>src</kbd> subdirectory, we can add our final Reason code file (<kbd>src/Ch10-final/src/Ch10_PlatformCompany.re</kbd>). Our ReasonML code is exactly the same as in the previous version (the <kbd>src/Ch10/Ch10_PlatformCompany_V8.re</kbd> file), except that we simplify it by removing the last bit (the snippet that prints some output).</p>
<p>Now, let's write the tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing our first tests</h1>
                
            
            
                
<p>To test code using <kbd>Jest</kbd>, we must start by opening the module:</p>
<pre>open Jest;</pre>
<p>Then, we define a <kbd>describe</kbd> function to encapsulate the tests suite. We need to open the <kbd>Expect</kbd> module, part of <kbd>Jest</kbd>, which provides the <kbd>expect</kbd> function with other things where we need to check that some values meet certain conditions. We also open the module file, which contains our implementation code. So far, our test function contains the following:</p>
<pre>describe("Platform", () =&gt; {<br/>  open Expect;<br/>  open Ch10_PlatformCompany;<br/><br/>});</pre>
<p>Now, we can add a first test to verify the data returned by the <kbd>apps</kbd> function in the <kbd>Platform</kbd> module. The test suite code is as follows:</p>
<pre>describe("Platform", () =&gt; {<br/>  open Expect;<br/>  open Ch10_PlatformCompany;<br/><br/>  test("list facebook business app", () =&gt; {<br/>    let <em>facebook_biz</em> = Platform.apps(`Facebook("business"));<br/>    expect(facebook_biz) |&gt; toEqual([ "facebook ads (https://www.facebook.com/business)" ]);<br/>  });<br/>});</pre>
<p>Let's not stop here and add a second test that verifies that the number of accounts is the previous number incremented by <kbd>1</kbd> after the <kbd>newSignUp</kbd> function has been called.</p>
<p>The complete tests suite code is as follows (in the <kbd>src\Ch10-final\__tests__\Platform_test.re</kbd> file):</p>
<pre>open Jest;<br/><br/>describe("Platform", () =&gt; {<br/>  open Expect;<br/>  open Ch10_PlatformCompany;<br/><br/>  test("list facebook business app", () =&gt; {<br/>    let <em>facebook_biz</em> = Platform.apps(`Facebook("business"));<br/>    expect(facebook_biz) |&gt; toEqual([ "facebook ads (https://www.facebook.com/business)" ]);<br/>  });<br/>    <br/>  test("instagram number of accounts", () =&gt; {<br/>    let <em>nb</em> = instagram.numberOfAccounts;<br/>    <em>newSignUp</em>(instagram);<br/>    expect(instagram.numberOfAccounts) |&gt; toEqual(nb + 1);<br/>  });<br/>});</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the tests</h1>
                
            
            
                
<p>Before we can execute the tests, we need to build the code using the <kbd>bsb -make-world</kbd> command. This finds the test code and compiles it. If everything goes well, that process copies the resulting files in the <kbd>lib</kbd> part (generated) of the package structure (under <kbd>src\Ch10-final\lib\bs\__tests__</kbd>). We are now ready to run the tests.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To run the tests, we use the <kbd>Jest</kbd> command. In my case, running this on Windows, the executable is actually located at <kbd>node_modules\.bin\jest</kbd>, but in your case, you could just type <kbd>jest</kbd>.</p>
<p>When we execute the <kbd>Jest</kbd> test runner command, we get the following output:</p>
<pre> PASS  __tests__/Platform_test.bs.js<br/>  Platform<br/>    √ list facebook business app (16ms)<br/>    √ instagram number of accounts (2ms)<br/><br/>Test Suites: 1 passed, 1 total<br/>Tests:       2 passed, 2 total<br/>Snapshots:   0 total<br/>Time:        8.433s<br/>Ran all test suites.</pre>
<p>At this point, we have a good structure, including a test suite, and we can build on it. We can extend the input part of the code to take all the <em>platform companies</em> into account and add more functionalities. And we can add more tests as we go. This is left as an exercise for the reader.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we built some type-safe code that is also relatively easy to maintain and extend, using Reason's core features. We could go further to have more generic code using advanced techniques, such as functors, but that is not necessary for this small example.</p>
<p>This was the final chapter. We iterated through a type-driven process of solving coding problems. While doing so, we improved our understanding of ReasonML's features and techniques, in particular variant types, functions, modules, and records. We also looked at how to test ReasonML code directly using the <kbd>Jest</kbd> framework.</p>
<p>I hope the book was useful as an introduction to the world of ML languages, and that it will help you go further with the ReasonML techniques and tools, and maybe even with React if you are a web developer with additional skills.</p>


            

            
        
    </body></html>