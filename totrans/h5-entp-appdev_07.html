<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. The App: Showing Ratings via Canvas</h1></div></div></div><p>Until now, we have seen ways to lay out and draw elements in our enterprise application using CSS and images. If we need to create complex visualizations and/or animations based on dynamic data, the use of <code class="literal">DOM</code> objects becomes intricate and its manipulation slow. For that reason, the <code class="literal">canvas</code> tag was introduced in the HTML5 specification. The <code class="literal">canvas</code> tag defines a rectangular area where we can draw anything using its JavaScript API. This chapter introduces the <a id="id415" class="indexterm"/>
<code class="literal">canvas</code> tag for data visualizations and simple animations.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Charting</li><li class="listitem" style="list-style-type: disc">Preparing our code</li><li class="listitem" style="list-style-type: disc">Everything depends on the context (2D and 3D contexts)</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Charting</h1></div></div></div><a id="id416" class="indexterm"/><p>Our current implementation of MovieNow uses a subset of the data provided by the <code class="literal">movielistings.php</code> web service. Some of the data not used includes ratings from MetaCritic, EditorBoost, and general user ratings (<code class="literal">avgMetaCriticRating</code>, <code class="literal">editorBoost</code>, and <code class="literal">avgUserRating</code> respectively). MovieNow users would love to see that information in the form of bar charts. For that, we will use <code class="literal">canvas</code>.<a id="id417" class="indexterm"/>
</p><div><div><h3 class="title"><a id="tip40"/>Tip</h3><p>Although it is possible to render this information using <code class="literal">DOM</code> objects it can be slower and more restrictive.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Preparing our code</h1></div></div></div><a id="id418" class="indexterm"/><p>We need to add a new interaction to show the ratings chart with a click. Let us remove our current on-click interaction:</p><div><pre class="programlisting">$("#movies-near-me li").click(function(){
  $(this).toggleClass("open")
});</pre></div><p>The new interaction will include two buttons: one to show the movie description and the other to show the ratings chart. Inside the <code class="literal">img</code> folder, you will find an <code class="literal">options.png</code> image sprite. It has icons for both information and charts.</p><div><img src="img/5689_07_01.jpg" alt="Preparing our code"/></div><p>Using the <code class="literal">details-button</code> and <code class="literal">charting-button</code> classes, let us add some styles to <code class="literal">styles.css</code>. Each button will be 45 px x 45 px, using absolute positioning to place it in the bottom-right corner:</p><div><pre class="programlisting">.details-button,.charting-button{
  width:45px;
  height:45px;
  cursor:pointer;
  position:absolute;
  bottom:10px;
  right:0;
  background:none;
  border:none;
  background-image:url(../img/options.png)
}</pre></div><p>Place the details button to the left-hand side of the charting button:</p><div><pre class="programlisting">.details-button{
  right:45px;
}</pre></div><p>Set the correct image for the charting button:</p><div><pre class="programlisting">.charting-button{
  background-position:-45px 0;
}</pre></div><p>In the <code class="literal">displayShowtimes</code> function of <code class="literal">movienow.geolocation.js</code>, we will need to change the HTML structure to add our new buttons:</p><div><pre class="programlisting">&lt;input type="button" class="charting-button" /&gt;
&lt;input type="button" class="details-button" /&gt;</pre></div><a id="id419" class="indexterm"/><p>We will also place our chart container with its canvas. At this point, we are going to use the HTML5 custom data attribute – <code class="literal">data-feed</code>, to store information about ratings in each canvas:</p><div><pre class="programlisting">&lt;section class="charting"&gt;
  &lt;h3 itemprop="name"&gt;movie.title&lt;/h3&gt;
  &lt;p&gt;&lt;canvas data-feed= "MetaCritic:movie.avgMetaCriticRating,EditorBoost:movie.editorBoost,User Rating:movie.avgUserRating"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;/section&gt;</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>HTML5 custom data attributes allow the embedding of metadata on HTML elements. Your attribute name must have a prefix, <code class="literal">data-</code>, followed at least by one character string; in our case we use the word <code class="literal">feed</code> so our attribute name is <code class="literal">data-feed</code>. It does not allow uppercase and the value is a string.</p></div></div><p>Putting it together, we get:</p><div><pre class="programlisting">for (var item in movies.items) {
  movie = movies.items[item];
  var movieDesc=(movie.synopsis &amp;&amp;movie.synopsis.length&gt;200)?movie.synopsis.substr(0,200)+"...": movie.synopsis;
  var movieHTML='&lt;li itemscope itemtype="http://schema.org/Movie"&gt;';
  movieHTML+='&lt;img src="img/'+movie.poster+'" alt="'+movie.title+'" width="120" /&gt;';
  movieHTML+='&lt;section class="main-info"&gt;';
  movieHTML+='<strong>&lt;input type="button" class="charting-button" /&gt;</strong>';
  movieHTML+='<strong>&lt;input type="button" class="details-button" /&gt;</strong>';
  movieHTML+='&lt;h3 itemprop="name"&gt;'+movie.title+'&lt;/h3&gt;';
  movieHTML+='&lt;p class="details genre" itemprop="genre"&gt;'+Array(movie.genre).join(', ')+'&lt;/p&gt;';
  movieHTML+='&lt;p class="details"&gt;'+movie.mpaaRating+'&lt;/p&gt;';
  movieHTML+='&lt;p class="theater"&gt;'+movie.theater.title+" "+movie.theater.address+'&lt;/p&gt;';
  movieHTML+='&lt;p class="actors"&gt;'+Array(movie.selectedStar).join(', ')+'&lt;/p&gt;';
  movieHTML+='&lt;/section&gt;';
  movieHTML+='&lt;section class="description"&gt;';
  movieHTML+='&lt;h3 itemprop="name"&gt;'+movie.title+'&lt;/h3&gt;';
  movieHTML+='&lt;p&gt;'+movieDesc+'&lt;/p&gt;';
  movieHTML+='&lt;/section&gt;';
  movieHTML+='<strong>&lt;section class="charting"&gt;</strong>';
  movieHTML+='<strong>&lt;h3 itemprop="name"&gt;'+movie.title+'&lt;/h3&gt;</strong>';
  movieHTML+='<strong>&lt;p&gt;&lt;canvas data-feed= "MetaCritic:'+movie.avgMetaCriticRating+",EditorBoost:"+movie.editorBoost+",User Rating:"+movie.avgUserRating+'"&gt;&lt;/canvas&gt;&lt;/p&gt;</strong>';
  movieHTML+='<strong>&lt;/section&gt;</strong>';
  movieHTML+='&lt;/li&gt;';
  html+=movieHTML;
}</pre></div><p>Add some spacing before the charting elements in <code class="literal">styles.css</code>:</p><div><pre class="programlisting">.charting canvas{
  margin-top:10px;
}</pre></div><a id="id420" class="indexterm"/><p>To hide and show the <code class="literal">charting</code> and <code class="literal">description</code> areas, we are going to use the <code class="literal">desc</code> class. If the <code class="literal">desc</code> class is applied to the <code class="literal">li</code> tag, we will hide <code class="literal">charting</code> and show <code class="literal">description</code>. Otherwise, we hide <code class="literal">description</code> and show <code class="literal">charting</code>:</p><div><pre class="programlisting">#movies-near-me li.desc section.description, #movies-near-me li section.charting{
  display:block;
}
#movies-near-me li section.description, #movies-near-me li.desc section.charting{
  display:none;
}</pre></div><p>Back to <code class="literal">movienow.geolocation.js</code>, we define methods to show chart (<code class="literal">showCharts</code>) and show details (<code class="literal">showDetails</code>). For <code class="literal">showCharts</code>, we will use jQuery's chaining capability. <code class="literal">$(event.target)</code> if the button is clicked, so we go two levels up using <code class="literal">parent()</code>; remove the <code class="literal">desc</code> class from the current object (<code class="literal">li</code>), add the <code class="literal">open</code> class, and find the first <code class="literal">canvas</code> element:</p><div><pre class="programlisting">$(event.target)
  .parent()
  .parent()
  .removeClass("desc")
  .addClass("open")
  .find("canvas")[0];</pre></div><div><div><h3 class="title"><a id="tip41"/>Tip</h3><p>jQuery allows for the concatenation of method calls applying each method to the result of the previous one. This improves performance but sometimes goes against readability.</p></div></div><a id="id421" class="indexterm"/><p>We are going to create a function called <code class="literal">charts</code> to draw each canvas, this function will take the <code class="literal">canvas</code> object as a parameter. Our final method should look like the following:</p><div><pre class="programlisting">this.showCharts = function(event) {
  that.charts(
    $(event.target)
      .parent()
      .parent()
      .removeClass("desc")
      .addClass("open")
      .find("canvas")[0]
  );
};</pre></div><p>Apply the same train of thought to show details:</p><div><pre class="programlisting">this.showDetails = function(event) {
  $(event.target)
    .parent()
    .parent()
    .addClass("desc")
    .addClass("open");
};</pre></div><p>Add event handlers for a click to open and close:</p><div><pre class="programlisting">$("#movies-near-me li .details-button").click(that.showDetails);
$("#movies-near-me li .description, #movies-near-me li .charting").click(function(){
  $(this)
    .parent()
    .removeClass("open")
});	
$("#movies-near-me li .charting-button").click(that.showCharts);</pre></div><a id="id422" class="indexterm"/><p>Now we create <code class="literal">movienow.charts.js</code> and add the <code class="literal">charts</code> method:</p><div><pre class="programlisting">var movienow = movienow || {};
movienow.charts = (function(){
  var that = this;
  this.charts = function(canvas){
    that.drawBarChart(canvas);
  };
  this.drawBarChart = function(canvas) {
  }
})();</pre></div><p>Notice that the <code class="literal">charts</code> method calls the <a id="id423" class="indexterm"/>
<code class="literal">drawBarChart</code> method. We use this construct to change the drawing method later.</p><p>Remember to include <code class="literal">movienow.charts.js</code> in <code class="literal">index.html</code>:</p><div><pre class="programlisting">&lt;script src="img/ios-orientationchange-fix.js"&gt;&lt;/script&gt;
&lt;script src="img/jquery-1.8.0.min.js"&gt;&lt;/script&gt;
&lt;script src="img/jquery.xdomainajax.js"&gt;&lt;/script&gt;
<strong>&lt;script src="img/movienow.charts.js"&gt;&lt;/script&gt;</strong>
&lt;script src="img/movienow.geolocation.js"&gt;&lt;/script&gt;
&lt;script src="img/movienow.js"&gt;&lt;/script&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Everything depends on the context</h1></div></div></div><p>Canvas provides APIs to draw in two or three dimensions, where supported. Canvas 2D has wider support than Canvas 3D; the latter is generally not supported on any mobile browser. </p><p>You can define what API to use by getting the canvas context. Let us suppose that <code class="literal">chart</code> is our <code class="literal">canvas</code> object. If you want to draw in two dimensions, you can use:<a id="id424" class="indexterm"/>
</p><div><pre class="programlisting">var context=chart.getContext("2D");</pre></div><p>Then, you can use the 2D API to draw, for example, a red square defining its color:</p><div><pre class="programlisting">context.fillStyle="#FF0000";</pre></div><p>Draw the shape as follows:</p><div><pre class="programlisting">context.fillRect(0,0,20,20);</pre></div><p>For the 3D API, the use is far more complicated. First, it is still not fully supported as some browsers recognize <code class="literal">webgl</code>:</p><div><pre class="programlisting">var context=chart.getContext("webgl");</pre></div><p>While others use <code class="literal">experimental-webgl</code>:</p><div><pre class="programlisting">var context=chart.getContext("experimental-webgl");</pre></div><p>This is because the <code class="literal">webgl</code> specification is still in development. Use of WebGL requires knowledge of computer graphics and concepts like cameras, lights, textures, materials, mapping, and so on.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec69"/>2D context</h2></div></div></div><a id="id425" class="indexterm"/><p>We are going to create a horizontal bar chart to show MetaCritic, EditorBoost, and user ratings. The idea is to use green, yellow, and red to indicate how high or low the rating is.</p><p>In the following image, we can see our chart design:</p><div><img src="img/5689_07_02.jpg" alt="2D context"/></div><a id="id426" class="indexterm"/><p>Based on the <code class="literal">movienow.charts.js</code> structure we have established, let us write the <code class="literal">drawBarChart</code> method. As we do not want to redraw our canvas every time we call this method, we are going to use the <code class="literal">painted</code> class as a flag to determine if the canvas is already drawn.</p><p>We can then save <code class="literal">canvas</code> as a jQuery object:</p><div><pre class="programlisting">var myCanvas=$(canvas);</pre></div><p>Then, we can verify if it has the <code class="literal">painted</code> class:</p><div><pre class="programlisting">if(!myCanvas.hasClass("painted")){
  //DRAW HERE
  myCanvas.addClass("painted");
}</pre></div><p>Inside our conditional, we split <code class="literal">data-feed</code> that contains rating information in order to iterate over it, building a bar for each rating category:<a id="id427" class="indexterm"/>
</p><div><pre class="programlisting">var values=myCanvas.attr("data-feed").split(",");</pre></div><p>We then get the 2D context:</p><div><pre class="programlisting">var context=canvas.getContext("2d");</pre></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec11"/>An overview of the Canvas 2D Drawing API</h3></div></div></div><p>Let us go over the most useful methods of Canvas in a 2D context:<a id="id428" class="indexterm"/>
</p><div><div><div><div><h4 class="title"><a id="ch07lvl4sec15"/>Styles</h4></div></div></div><a id="id429" class="indexterm"/><p>The methods used for setting styles in Canvas 2D API are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">context.strokeStyle(value)</code>: This receives a string containing a CSS color of the stroke; if no parameter is passed, it returns the current style for stroking shapes.<a id="id430" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.fillStyle(value)</code>: It receives a string with the CSS color for filling shapes; if no parameter is passed, it returns the current fill style.<a id="id431" class="indexterm"/><div><div><h3 class="title"><a id="tip42"/>Tip</h3><p>
<code class="literal">strokeStyle</code> and <code class="literal">fillStyle</code> can receive <code class="literal">CanvasGradient</code> or <code class="literal">CanvasPattern</code> as a parameter, allowing you to draw gradients and patterns. For more information about how to create gradients and patterns, you can check out the canvas 2D API specification: <a class="ulink" href="http://dev.w3.org/2006/canvas-api/canvas-2d-api.html">http://dev.w3.org/2006/canvas-api/canvas-2d-api.html</a>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.lineWidth(value)</code>: <a id="id432" class="indexterm"/>It defines the width of the lines using pixels. It only accepts positive values; if no value is passed, it acts like a getter and returns the current line width.</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.lineCap(value)</code>:<a id="id433" class="indexterm"/> It sets the style of the end (or cap) of lines. Possible values are <code class="literal">butt</code>, <code class="literal">round</code>, and <code class="literal">square</code>. If no value is passed, it returns the current line cap.</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.lineJoin(value)</code>: It sets the style of the connection of lines. Possible values are <code class="literal">bevel</code>, <code class="literal">round</code>, and <code class="literal">miter</code>. If no value is passed, it returns the current line joint style.<a id="id434" class="indexterm"/></li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec16"/>Font styles</h4></div></div></div><a id="id435" class="indexterm"/><p>The methods used for setting font styles in canvas 2D API are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">context.font(value)</code>: <a id="id436" class="indexterm"/>It defines the style of the fonts using a string with CSS syntax. If no value is passed, it returns the current font style.</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.fillText</code><a id="id437" class="indexterm"/><code class="literal">(text,x,y[, maxWidth])</code>: It draws text. It receives a <code class="literal">text</code> string with the information to draw <code class="literal">x</code> and <code class="literal">y</code> coordinates in pixels and <code class="literal">maxWidth</code> that defines the maximum size in pixels for the container's width, which is optional.<a id="id438" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><a id="id439" class="indexterm"/><code class="literal">context.strokeText(text,x,y[, maxWidth])</code>: It behaves like <code class="literal">fillText</code> but draws only the stroke of the text.</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec17"/>Drawing simple shapes</h4></div></div></div><a id="id440" class="indexterm"/><p>The methods used for drawing simple shapes in the Canvas 2D API are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">context.clearRect(x, y, w, h)</code>: It defines a rectangle with coordinates<a id="id441" class="indexterm"/> <code class="literal">x</code> and <code class="literal">y</code>, width <code class="literal">w</code>, and height <code class="literal">h</code>, and clears all pixels inside the area defined. Values are in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.fillRect(x, y, w, h)</code>: It draws a rectangle with coordinates <code class="literal">x</code> and <code class="literal">y</code>, width <code class="literal">w</code> and height <code class="literal">h</code> using the predefined <code class="literal">fillStyle</code>.<a id="id442" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.strokeRect</code><a id="id443" class="indexterm"/><code class="literal">(x, y, w, h)</code>: It draws the stroke of a rectangle with coordinates <code class="literal">x</code> and <code class="literal">y</code>, width <code class="literal">w</code>, and height <code class="literal">h</code> using the predefined <code class="literal">strokeStyle</code>.</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec18"/>Drawing complex shapes</h4></div></div></div><a id="id444" class="indexterm"/><p>To create more complex shapes, Canvas 2D API allows you to define paths and subpaths. A path is a collection of subpaths while a subpath is a list of points connected by lines or curves.</p><p>The current project does not require complex shapes, but it is good to know the methods that allow you to draw curves and lines making it possible to draw any figure.</p><p>We need to be aware that our context always contains a current path, and it is not possible to have more than one.<a id="id445" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">co</code><a id="id446" class="indexterm"/><code class="literal">ntext.beginPath()</code>: It resets the current path</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.closePath()</code>:<a id="id447" class="indexterm"/> It closes the current path and creates a new one with a first point that uses the same coordinates as the last subpath point</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.moveTo(x, y)</code>: <a id="id448" class="indexterm"/>It creates a new subpath with coordinates <code class="literal">x</code> and <code class="literal">y</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.lineTo(x, y)</code>: It creates a line between the current point and a new point with coordinates <code class="literal">x</code> and <code class="literal">y</code> adding the latest to the current subpath<a id="id449" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.quadraticCurveTo(cpx, cpy, x, y)</code>: It creates a quadratic curve between the current point and a new point with coordinates <code class="literal">x</code> and <code class="literal">y</code> using a control point, defined with coordinates <code class="literal">cpx</code> on the x axis, and <code class="literal">cpy</code> on the y axis<a id="id450" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code>: It creates a Bezier curve between the current point and a new point with coordinates <code class="literal">x</code> and <code class="literal">y</code> using two control points cp1(<code class="literal">cp1x</code>, <code class="literal">cp1y</code>) and cp2 (<code class="literal">cp2x</code>, <code class="literal">cp2y</code>)<a id="id451" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.arcTo(x1, y2, x2, y2, radius)</code>: It connects the current point with a new point with coordinates <code class="literal">x1</code> and <code class="literal">y1</code>, then creates a new point with coordinates <code class="literal">x2</code> and <code class="literal">y2</code> joined with the previous one by an arc with radius defined by the parameter <code class="literal">radius</code><a id="id452" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.rect(x, y, w, h)</code>: It adds a rectangle with coordinates <code class="literal">x</code> and <code class="literal">y</code>, width <code class="literal">w</code>, and height <code class="literal">h</code> to the list of subpaths<a id="id453" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context.fill()</code>: <a id="id454" class="indexterm"/>It applies the current fill style to fill the subpaths</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.stroke()</code>: <a id="id455" class="indexterm"/>It applies the current stroke style to create stroke lines for the subpaths</li><li class="listitem" style="list-style-type: disc"><code class="literal">context.isPointInPath(x, y)</code>: It returns <code class="literal">true</code> if the point defined by coordinates <code class="literal">x</code> and <code class="literal">y</code> is in the current path and <code class="literal">false</code> otherwise<a id="id456" class="indexterm"/></li></ul></div><p>There are other methods that can be useful for more complicated drawings and animations; you can look at the canvas specification here: <a class="ulink" href="http://dev.w3.org/2006/canvas-api/canvas-2d-api.html">http://dev.w3.org/2006/canvas-api/canvas-2d-api.html</a>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec12"/>Drawing charts</h3></div></div></div><a id="id457" class="indexterm"/><p>First, let us define the text style for that context and a variable to count the current bar index (in case not all movies have the same number of rating categories):</p><div><pre class="programlisting">context.font = "bold 14px sans-serif";
var index=0;</pre></div><p>Iterate over rating categories and get the current value:</p><div><pre class="programlisting">for(var i=0; i&lt;values.length; i++){
      var info=values[i].split(":");
      var val=info[1];
}</pre></div><p>We draw (only if the value is bigger than <code class="literal">0</code>) first a gray bar (<code class="literal">#292929</code>) that defines a width of <code class="literal">290</code> px and a height of <code class="literal">26</code> px. Using the syntax <code class="literal">fillRect(x,y,width,height)</code>, notice that we use <code class="literal">36</code> to give 10 pixels of separation between bars:</p><div><pre class="programlisting">        var pos=index*36;
        context.fillStyle="#292929";
        context.fillRect(0,pos,290,26);</pre></div><div><div><h3 class="title"><a id="note19"/>Note</h3><p>The canvas origin is positioned in the upper-left corner of the canvas DOM object. Positive values go below origin and to the right-hand side.</p></div></div><p>We can then draw our color bar. For that, we define a <code class="literal">getChartColor</code> method that returns different colors depending on the rating value using green for higher ones, yellow for mediums, and red for lowest:</p><div><pre class="programlisting">this.getChartColor = function(val){
  var result="";
  if(val&lt;40){
    result="#FF0066";
  }else{
    if(val&lt;80){
      result="#FFCC33";
    }else{
      result="#66CC33";
    }
  }
  return result;
};</pre></div><p>Using our <a id="id458" class="indexterm"/>
<code class="literal">getChartColor</code> method and current rating value <code class="literal">val</code>, we can set the shape:</p><div><pre class="programlisting">context.fillStyle=that.getChartColor(val);
context.fillRect(0,pos,val*2.9,26);</pre></div><p>To draw the rating category title, we change fill style to a transparent white, and then we use <code class="literal">fillText</code> with syntax <code class="literal">fillText(text, x,y)</code>:</p><div><pre class="programlisting">context.fillStyle = "rgba(255, 255, 255, .9)";
context.fillText(info[0]+" "+val+"%", 10, pos+18);
index++;</pre></div><div><div><h3 class="title"><a id="tip43"/>Tip</h3><p>Notice that we can use hexadecimal, RGB, or RGBA colors to define <code class="literal">fillStyle</code>.</p></div></div><a id="id459" class="indexterm"/><p>Finally, we write a validation such that if there is no data we show a message that says <strong>No Data Available</strong>:</p><div><pre class="programlisting">    if(index==0){
   context.fillStyle = "#FFFFFF";
      context.fillText("No Data Available", 40, 50);
    }</pre></div><p>Wrap it all together:</p><div><pre class="programlisting">this.drawBarChart = function(canvas) {
  var myCanvas=$(canvas);
  if(!myCanvas.hasClass("painted")){
    var values=myCanvas.attr("data-feed").split(",");
    var context=canvas.getContext("2d");
    context.font = "bold 14px sans-serif";
    var index=0;
    for(var i=0; i&lt;values.length; i++){
      var info=values[i].split(":");
      var val=info[1];
      if(val&gt;0){
        var pos=index*36;
        context.fillStyle="#292929";
        context.fillRect(0,pos,290,26);
        context.fillStyle=that.getChartColor(val);
        context.fillRect(0,pos,val*2.9,26);
        context.fillStyle = "rgba(255, 255, 255, .9)";
        context.fillText(info[0]+" "+val+"%", 10, pos+18);
        index++;
      }
    }
    if(index==0){
   context.fillStyle = "#FFFFFF";
      context.fillText("No Data Available", 40, 50);
    }
    myCanvas.addClass("painted");
  }
};</pre></div><a id="id460" class="indexterm"/><p>In this example, we do not need to clear our canvas area because we are not animating or changing information after our first draw. However, if we do require redrawing, we can use:</p><div><pre class="programlisting">context.clearRect(0, 0, canvas.width, canvas.height);</pre></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Canvas 2D context provides a procedural approach to drawing—creating bitmap images. If we need to use vectorial graphics instead of bitmaps it's possible to use Scalable Vector Graphics (SVG), which provides a declarative approach using XML. To know more about SVG you can research here <a class="ulink" href="http://www.w3.org/Graphics/SVG/">http://www.w3.org/Graphics/SVG/</a>.</p></div></div><p>The Canvas 2D API is supported in all modern browsers including Internet Explorer since Version 9.0. As we have shown in <a class="link" href="ch02.html" title="Chapter 2. HTML5 Starter Kit: Useful Tools">Chapter 2</a>, <em>HTML Starter Kit: Useful Tools</em>, it is still possible to support previous versions of Internet Explorer using ExplorerCanvas <a class="ulink" href="http://code.google.com/p/explorercanvas/downloads/list">http://code.google.com/p/explorercanvas/downloads/list</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>3D context – WebGL and experimental WebGL</h2></div></div></div><a id="id461" class="indexterm"/><p>Now that we saw a two-dimensional implementation of our chart solution, let us try to create a three-dimensional version and add some animations to make things more interesting.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>When we think of user experience, a general rule is that less is more. That means that keeping things simple should make our application more usable. In this case, we are going to add animations that are not needed for the sake of learning how to do it. </p></div></div><p>In our case we are going to draw bar charts using WebGL and rating categories titles using DOM objects.</p><p>The final implementation should look like the following:</p><div><img src="img/5689_07_03.jpg" alt="3D context – WebGL and experimental WebGL"/></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec13"/>Entering a tridimensional world</h3></div></div></div><p>The <a id="id462" class="indexterm"/>WebGL specification is based on the OpenGL for Embedded Systems 2.0 (or OpenGL ES) specification. Unless you are familiar with OpenGL and you need to work with low level manipulations, it is suggested that you use a library that abstracts the use of it. Among the advantages are more readable code, less development time, and better extensibility.</p><p>In our case, we selected <code class="literal">Three.js</code>, a JavaScript library that simplifies the use of WebGL using common metaphors used in other tridimensional libraries.<a id="id463" class="indexterm"/>
</p><div><div><h3 class="title"><a id="tip44"/>Tip</h3><p>Consider project objectives when you have to decide which library to use, and think in terms of future improvements and limitations of that library. </p></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec14"/>Three.js</h3></div></div></div><a id="id464" class="indexterm"/><p>
<code class="literal">Three.js</code> is a JavaScript library that abstracts 3D manipulation allowing us to use simple metaphors like scenes, cameras, objects, and so on. You can download <code class="literal">Three.js</code> from <a class="ulink" href="https://github.com/mrdoob/three.js/ a">https://github.com/mrdoob/three.js/ a</a>nd read its documentation at <a class="ulink" href="http://mrdoob.github.com/three.js/docs/50/">http://mrdoob.github.com/three.js/docs/50/</a>.<a id="id465" class="indexterm"/>
</p><p>Let us go over some basic concepts:</p><div><div><div><div><h4 class="title"><a id="ch07lvl4sec19"/>Scene</h4></div></div></div><a id="id466" class="indexterm"/><p>The scene is the virtual environment where we can insert objects. Every object must be in a <code class="literal">scene</code> in order to visualize it.</p><p>You can create scenes using <code class="literal">scene = new THREE.Scene()</code> and add an object to it using <code class="literal">scene.add(object)</code>.</p></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec20"/>Camera</h4></div></div></div><p>A camera<a id="id467" class="indexterm"/> indicates which section of our scene to visualize. Think of it as a movie; if we want to record a specific place, we need to point our camera at it. <code class="literal">Three.js</code> provides an abstract <code class="literal">Camera</code> class for cameras, two basic cameras, and two extra implementations of cameras.</p><p>
<code class="literal">OrthographicCamera</code> defines an orthographic projection defined by a cube formed for the constructor parameters:<a id="id468" class="indexterm"/>
</p><div><pre class="programlisting">OrthographicCamera(left, right, top, bottom, near, far)</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">left</code> – defines left plane using a float that indicates position</li><li class="listitem" style="list-style-type: disc"><code class="literal">right</code> – defines right plane using a float that indicates position</li><li class="listitem" style="list-style-type: disc"><code class="literal">top</code> – defines top plane using a float that indicates position</li><li class="listitem" style="list-style-type: disc"><code class="literal">bottom</code> – defines bottom plane using a float that indicates position</li><li class="listitem" style="list-style-type: disc"><code class="literal">near</code> – defines the plane nearest to the camera or near plane using a float that indicates position</li><li class="listitem" style="list-style-type: disc"><code class="literal">far</code> – defines the plane farthest to the camera or far plane using a float that indicates position</li></ul></div><p>
<code class="literal">PerspectiveCamera</code> defines a perspective projection using field of view, aspect ratio, near and far values:<a id="id469" class="indexterm"/>
</p><div><pre class="programlisting">
<a id="id470" class="indexterm"/>PerspectiveCamera(fov, aspect, near, far)</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fov</code> – defines the angle that indicates the field of view represented by a float</li><li class="listitem" style="list-style-type: disc"><code class="literal">aspect</code> – defines the camera aspect ratio defined by a float</li><li class="listitem" style="list-style-type: disc"><code class="literal">near</code> – as in <code class="literal">OrtographicCamera</code> defines near plane using a float</li><li class="listitem" style="list-style-type: disc"><code class="literal">far</code> – as in <code class="literal">OrtographicCamera</code> defines far plane using a float</li></ul></div><p>A visual representation of a perspective camera is shown in the following figure:</p><div><img src="img/5689EN_07_04.jpg" alt="Camera"/></div></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec21"/>Material</h4></div></div></div><a id="id471" class="indexterm"/><p>Materials define a set of properties that describe the appearance of objects.</p></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec22"/>Texture</h4></div></div></div><a id="id472" class="indexterm"/><p>Textures define appearance of objects using images (or procedural patterns).</p></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec23"/>Mesh</h4></div></div></div><a id="id473" class="indexterm"/><p>Meshes are part of the list of objects than can be added to the scene. You can assign geometries and materials to a mesh.</p></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec24"/>Geometry</h4></div></div></div><a id="id474" class="indexterm"/><p>Geometry is a representation of an object that can be assigned to a mesh. In our case, we are going to use <code class="literal">CubeGeometry</code> to define our bars.</p><p>To start, we will download and include <code class="literal">three.js</code> in our <code class="literal">index.html</code> file:</p><div><pre class="programlisting">&lt;script src="img/ios-orientationchange-fix.js"&gt;&lt;/script&gt;        
&lt;script src="img/jquery-1.8.0.min.js"&gt;&lt;/script&gt;        
&lt;script src="img/jquery.xdomainajax.js"&gt;&lt;/script&gt;        
<strong>&lt;script src="img/three.js"&gt;&lt;/script&gt;</strong>
&lt;script src="img/movienow.charts.js"&gt;&lt;/script&gt;       
&lt;script src="img/movienow.geolocation.js"&gt;&lt;/script&gt;        
&lt;script src="img/movienow.js"&gt;&lt;/script&gt; </pre></div><p>We then add a new parameter to our <code class="literal">charts</code> class to specify which rendering we would like to use:</p><div><pre class="programlisting">this.charts = function(canvas<strong>, type</strong>){
<strong>  switch(type){</strong>
<strong>    case "3DChart":</strong>
<strong>      that.draw3DChart(canvas);</strong>
<strong>      break;</strong>
<strong>    case "barChart":</strong>
<strong>    default:</strong>
      that.drawBarChart(canvas);
      <strong>break;</strong>
<strong>  }</strong>
};</pre></div><p>We define as default <strong>3DChart</strong> in the <code class="literal">showCharts</code> method:<a id="id475" class="indexterm"/>
</p><div><pre class="programlisting">this.showCharts = function(event) {  
that.charts($(event.target).parent().parent().removeClass("desc").addClass("open").find("canvas")[0]<strong>, "3DChart"</strong>);
};</pre></div><a id="id476" class="indexterm"/><p>Now let us write our 3D drawing method <code class="literal">draw3DChart</code>. As our previous two-dimensional drawing method, this one takes our <code class="literal">canvas</code> as a parameter:</p><div><pre class="programlisting">this.draw3DChart = function(canvas) {
}</pre></div><p>As before, we verify if Canvas has the <code class="literal">painted</code> class to avoid initializing it again. We can then verify WebGL support and, if it is not supported, we render our 2D charts:</p><div><pre class="programlisting">this.draw3DChart = function(canvas) {
  var myCanvas=$(canvas);
  var myCanvasParent=myCanvas.parent();
  if(!myCanvas.hasClass("painted")){
    var webGlSupport=false;
    try {
      /*** VERIFICATION OF WEBGL SUPPORT ***/
      webGlSupport = !!window.WebGLRenderingContext &amp;&amp; !!document.createElement('canvas').getContext('experimental-webgl');
    }catch(e){}
    if (webGlSupport){
    //DRAW 3D HERE
    }else{
      /** IF NOT WEBGL SUPPORT RENDERS CHART IN 2D ***/
      that.drawBarChart(canvas);
    }
  }
};</pre></div><p>Inside <code class="literal">webGLSupport</code>, we get our ratings data, <code class="literal">canvas</code> dimensions, and a variable to store time for animation:</p><div><pre class="programlisting">var data=myCanvas.attr("data-feed");
var values=data.split(",");
var w = myCanvas.width();
var h = myCanvas.height();
var lastTime = 0;</pre></div><p>Now we define a <code class="literal">three.js</code> renderer using WebGL, which contains our new canvas, and set its dimensions:</p><div><pre class="programlisting">var renderer = new THREE.WebGLRenderer();
renderer.setSize(w, h);</pre></div><p>We assign the <code class="literal">data</code> attribute and the <code class="literal">painted</code> class to the renderer DOM element (<code class="literal">canvas</code>) and replace our old <code class="literal">canvas</code> with this one.</p><div><pre class="programlisting">var newCanvas=$(renderer.domElement);
newCanvas.attr("data-feed",data);
myCanvas.addClass("painted");
myCanvas.replaceWith(newCanvas);</pre></div><a id="id477" class="indexterm"/><p>We implement our camera using field of vision (FOV) 45 degree, aspect ratio based on canvas dimensions, near of 1 and far of 1000, and we position our camera to 700 on the z axis.</p><div><pre class="programlisting">var camera = new THREE.PerspectiveCamera(45, w/h, 1, 1000);
camera.position.z = 700;</pre></div><p>Then we define our scene, a <code class="literal">bars</code> array to store meshes to be rendered later, an <code class="literal">index</code> as in our 2D example and a <code class="literal">labels</code> string to store the DOM object that will show the titles:</p><div><pre class="programlisting">var scene = new THREE.Scene();
var bars=[];
var index=0;
var labels="&lt;div class='chart-labels'&gt;";</pre></div><p>Iterate over rating categories as our previous example. We get a color for our current value using <code class="literal">getChartColor</code> and replace <code class="literal">#</code> with <code class="literal">0x</code> because of the color notation used: </p><div><pre class="programlisting">var mainColor=that.getChartColor(val).replace("#", "0x");</pre></div><p>As we will have six faces for each bar, we will have six different materials. Each one will have its own color, so we define arrays for <code class="literal">colors</code> and <code class="literal">materials</code>. We fill our title information in the <code class="literal">labels</code> string too:</p><div><pre class="programlisting">var colors = [mainColor, mainColor, mainColor, mainColor, mainColor, mainColor];
var materials = [];
labels+="&lt;div&gt;"+info[0]+"&lt;/div&gt;";
for (var n = 0; n &lt; 6; n++) {
  materials.push([
    new THREE.MeshLambertMaterial({
      color: colors[n],
      opacity:0.6,
      transparent: true,
      shading: THREE.FlatShading,
      vertexColors: THREE.VertexColors
    }),
    new THREE.MeshBasicMaterial({
      color: colors[n],
      shading: THREE.FlatShading,
      wireframe: true,
      transparent: true
    })
  ]);
}</pre></div><a id="id478" class="indexterm"/><p>Notice that we can have more than one material assigned. In this case, we use the following to define a transparent fill for our solids:</p><div><pre class="programlisting">THREE.MeshLambertMaterial({
  color: colors[n],
  opacity:0.6,
  transparent:
  true,
  shading: THREE.FlatShading,
  vertexColors: THREE.VertexColors
})</pre></div><p>The following draws the edges:</p><div><pre class="programlisting">new THREE.MeshBasicMaterial({
  color: colors[n],
  shading: THREE.FlatShading,
  wireframe: true,
  transparent: true
})</pre></div><p>Each <code class="literal">bar</code> is defined as a mesh with geometry. Use the following <code class="literal">CubeGeometry</code> syntax:</p><div><pre class="programlisting">CubeGeometry(width, height, depth, segmentsWidth, segmentsHeight, segmentsDepth)</pre></div><p>This creates a new <code class="literal">CubeGeometry</code> object:</p><div><pre class="programlisting">var bar = new THREE.Mesh(new THREE.CubeGeometry(myWidth, 90, 90, 1, 1, 1, materials), new THREE.MeshFaceMaterial());</pre></div></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec25"/>Animating our geometries</h4></div></div></div><a id="id479" class="indexterm"/><p>We are going to animate the growing of the bars, so we will scale them on the x axis.</p><div><pre class="programlisting">bar.scale.x=.01;</pre></div><p>Meshes have their reference points at their centers, so positioning the mesh and setting the overdraw to manage transparent geometries, we have:</p><div><pre class="programlisting">bar.position.y=200-(index*140);
bar.position.x=-500+(myWidth/2)*bar.scale.x;
bar.overdraw = true;</pre></div><p>We add the bar to our scene and to our array with the final width that we should have at the end of our animation:</p><div><pre class="programlisting">scene.add(bar);
bars.push({object:bar, width:myWidth});
index++;</pre></div><p>So our iteration should look as follows:</p><div><pre class="programlisting">for(var i=0; i&lt;values.length; i++){
  var info=values[i].split(":");
  var val=info[1];
  if(val&gt;0){
    var mainColor=that.getChartColor(val).replace("#", "0x");
    var colors = [mainColor, mainColor, mainColor, mainColor, mainColor, mainColor];
    var materials = [];
    labels+="&lt;div&gt;"+info[0]+"&lt;/div&gt;";
    for (var n = 0; n &lt; 6; n++) {
      materials.push([
        new THREE.MeshLambertMaterial({
          color: colors[n],
          opacity:0.6,
          transparent: true,
          shading: THREE.FlatShading,
          vertexColors: THREE.VertexColors
        }),
        new THREE.MeshBasicMaterial({
          color: colors[n],
          shading: THREE.FlatShading,
          wireframe: true,
          transparent: true
        })
       ]);
     }
     var myWidth=val*8;
     var bar = new THREE.Mesh(new THREE.CubeGeometry(myWidth, 90, 90, 1, 1, 1, materials), new THREE.MeshFaceMaterial());
     bar.scale.x=.01;
     bar.position.y=200-(index*140);
     bar.position.x=-500+(myWidth/2)*bar.scale.x;
     bar.overdraw = true;
     scene.add(bar);
     bars.push({object:bar, width:myWidth});
     index++;
  }
}</pre></div><a id="id480" class="indexterm"/><p>At this point, we have not rendered anything. We can remedy that by setting the <code class="literal">labels</code> string and appending it:</p><div><pre class="programlisting">labels+"&lt;/div&gt;";
myCanvasParent.append(labels);</pre></div><p>We set a <code class="literal">three</code> structure that we will use for our rendering, and then we call our render method – <code class="literal">animate3DChart</code>:</p><div><pre class="programlisting">var three = {
  renderer: renderer,
  camera: camera,
  scene: scene,
  bars: bars
};
that.animate3DChart(lastTime, three);</pre></div><p>Our <code class="literal">draw3DChart</code> method looks as follows:</p><div><pre class="programlisting">this.draw3DChart = function(canvas) {
  var myCanvas=$(canvas);
  var myCanvasParent=myCanvas.parent();
  if(!myCanvas.hasClass("painted")){
    var webGlSupport=false;
    try {
      /*** VERIFICATION OF WEBGL SUPPORT ***/
      webGlSupport = !!window.WebGLRenderingContext &amp;&amp; !!document.createElement('canvas').getContext('experimental-webgl');
    }catch(e){}
    if (webGlSupport){
      var data=myCanvas.attr("data-feed");
      var values=data.split(",");
      var w = myCanvas.width();
      var h = myCanvas.height();
      var lastTime = 0;
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(w, h);
      var newCanvas=$(renderer.domElement);
      newCanvas.attr("data-feed",data);
      myCanvas.addClass("painted");
      /*** REPLACES ORIGINAL CANVAS WITH THREE.JS CANVAS ***/
      myCanvas.replaceWith(newCanvas);
      /*** CAMERA DEFINITION ***/
      var camera = new THREE.PerspectiveCamera(45, w/h, 1, 1000);
      camera.position.z = 700;
      /*** SCENE DEFINITION ***/
      var scene = new THREE.Scene();
      var bars=[];
      var index=0;
      var labels="&lt;div class='chart-labels'&gt;";
      for(var i=0; i&lt;values.length; i++){
        var info=values[i].split(":");
        var val=info[1];
        if(val&gt;0){
          var mainColor=that.getChartColor(val).replace("#", "0x");
          var colors = [mainColor, mainColor, mainColor, mainColor, mainColor, mainColor];
          var materials = [];
          labels+="&lt;div&gt;"+info[0]+"&lt;/div&gt;";
          for (var n = 0; n &lt; 6; n++) {
            materials.push([
              new THREE.MeshLambertMaterial({
                color: colors[n],
                opacity:0.6,
                transparent: true,
                shading: THREE.FlatShading,
                vertexColors: THREE.VertexColors
              }),
              new THREE.MeshBasicMaterial({
                color: colors[n],
                shading: THREE.FlatShading,
                wireframe: true,
                transparent: true
              })
            ]);
          }
          var myWidth=val*8;
          var bar = new THREE.Mesh(new THREE.CubeGeometry(myWidth, 90, 90, 1, 1, 1, materials), new THREE.MeshFaceMaterial());
          bar.scale.x=.01;
          bar.position.y=200-(index*140);
          bar.position.x=-500+(myWidth/2)*bar.scale.x;
          bar.overdraw = true;
          scene.add(bar);
          bars.push({object:bar, width:myWidth});
          index++;
        }
      }
      labels+"&lt;/div&gt;";
      myCanvasParent.append(labels);
      /*** SAVE INFORMATION REQUIRED TO RENDER SCENE ***/
      var three = {
        renderer: renderer,
        camera: camera,
        scene: scene,
        bars: bars
      };
      that.animate3DChart(lastTime, three);
    }else{
      /** IF NOT WEBGL SUPPORT RENDERS CHART IN 2D ***/
      that.drawBarChart(canvas);
    }
  }
};</pre></div></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec26"/>Finishing up</h4></div></div></div><a id="id481" class="indexterm"/><p>We create a <a id="id482" class="indexterm"/>
<code class="literal">window.requestAnimFrame</code> method to abstract the definition of our <code class="literal">timeout</code> for animation. Notice that we use <code class="literal">1000/60</code>. This indicates 60 frames per second (<code class="literal">FPS</code>):</p><div><pre class="programlisting">window.requestAnimFrame = (function(callback){
  return window.requestAnimationFrame ||window.webkitRequestAnimationFrame ||window.mozRequestAnimationFrame ||window.oRequestAnimationFrame ||window.msRequestAnimationFrame ||function(callback){
  /* Using 60FPS */
    window.setTimeout(callback, 1000 / 60);
  };
})();</pre></div><p>For the<a id="id483" class="indexterm"/> <a id="id484" class="indexterm"/>
<code class="literal">animate3DChart</code> method, we simply define a variable to stop our animation (<code class="literal">isReady</code>), and scale and position each <code class="literal">bar</code> stopping when we reach 100 percent scale (in this case <code class="literal">1</code>):</p><div><pre class="programlisting">this.animate3DChart = function(lastTime, three){
  var isReady=false;
  for(var i=0; i&lt;three.bars.length; i++){
    if(three.bars[i].object.scale.x&lt;1){
      three.bars[i].object.scale.x+=.03;
      three.bars[i].object.position.x=-500+(three.bars[i].width/2)*three.bars[i].object.scale.x;
    }
    <strong>isReady=(three.bars[i].object.scale.x&gt;=1);</strong>
  }
  lastTime = time;
  /*** SCENE RENDER USING THREE.JS ***/
  three.renderer.render(three.scene, three.camera);
  if(!isReady){
    requestAnimFrame(function(){
      that.animate3DChart(lastTime, three);
    });
  }
}</pre></div><p>If we want to rotate each bar with no stop, we can define some values to control the animation:</p><div><pre class="programlisting">var angularSpeed = 1.2;
var date = new Date();
var time = date.getTime();
var timeDiff = time - lastTime;
var angleChange = angularSpeed * timeDiff * 2 * Math.PI / 1000;</pre></div><p>We can then substitute <code class="literal">isReady=(three.bars[i].object.scale.x&gt;=1)</code> with <code class="literal">three.bars[i].object.rotation.x += angleChange</code>.</p><p>To modify rotation on the x axis, we can add the following:</p><div><pre class="programlisting">this.animate3DChart = function(lastTime, three){
  <strong>var angularSpeed = 1.2;</strong>
<strong>  var date = new Date();</strong>
<strong>  var time = date.getTime();</strong>
<strong>  var timeDiff = time - lastTime;</strong>
<strong>  var angleChange = angularSpeed * timeDiff * 2 * Math.PI / 1000;</strong>
  var isReady=false;
  for(var i=0; i&lt;three.bars.length; i++){
    if(three.bars[i].object.scale.x&lt;1){
      three.bars[i].object.scale.x+=.03;
      three.bars[i].object.position.x=-500+(three.bars[i].width/2)*three.bars[i].object.scale.x;
    }
    <strong>//isReady=(three.bars[i].object.scale.x&gt;=1);</strong>
    <strong>three.bars[i].object.rotation.x += angleChange;</strong>
  }
  lastTime = time;
  /*** SCENE RENDER USING THREE.JS ***/
  three.renderer.render(three.scene, three.camera);
  if(!isReady){
    requestAnimFrame(function(){
      that.animate3DChart(lastTime, three);
    });
  }
}</pre></div><p>The canvas WebGL API is not fully supported by all browsers. You can use the 3D API for Firefox 4.0+, Chrome, Opera, and Safari since Version 5.1 (on OSX or higher, but not Safari for iOS devices or Safari for Windows).</p><div><div><h3 class="title"><a id="tip45"/>Tip</h3><p>WebGL is disabled by default on Safari. <a id="id485" class="indexterm"/>To enable WebGL on Safari, click on the <strong>Safari</strong> menu and select <strong>Preferences</strong>, then click on the <strong>Advanced</strong> tab. At the bottom, check the <strong>Show Develop menu in menu bar</strong> checkbox. Open the <strong>Develop</strong> menu and then select <strong>Enable WebGL</strong>.</p></div></div><p>For Internet Explorer, you can enable WebGL support by installing the <a id="id486" class="indexterm"/>Chrome Frame plugin <a class="ulink" href="http://www.google.com/chromeframe">http://www.google.com/chromeframe</a>. Google Chrome Frame replaces the rendering mechanism of Internet Explorer with Google Chrome's versions of the WebKit layout engine and V8 JavaScript engine.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Summary</h1></div></div></div><p>Although the canvas specification is still in development, we can apply its APIs for innumerable use cases in our enterprise applications. Charts, scientific visualization, diagrams, and animated wizards are merely the tip of the iceberg. As developers, we should always give ample consideration to fallbacks or alternative solutions in the event something is not supported to ensure proper cross-platform compatibility.</p><p>The next chapter will cover drag-and-drop capabilities and event delegation using HTML5.</p></div></body></html>