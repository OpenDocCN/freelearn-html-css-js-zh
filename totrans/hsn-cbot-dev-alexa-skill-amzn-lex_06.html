<html><head></head><body>
        

                            
                    <h1 class="header-title">Connecting a Lex Bot to DynamoDB</h1>
                
            
            
                
<p class="mce-root">After reading the previous chapter, we know how to create a Lex chatbot. Now we can start building a chatbot that takes the user through a more complex flow. Designing and building larger chatbots is closer to what you are likely to be doing, and we'll look at the best ways to approach the design and setup.</p>
<p>We'll be using our chatbot to get data from S3 as well as getting and writing data to DynamoDB tables. This allows us to persist information about the users' choices and progress through the flow.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Creating flow diagrams for a larger, more complex chatbot</li>
<li>Creating a Lex chatbot to cover all of the intents and flows</li>
<li>Retrieving data from an S3 bucket and performing logic upon it</li>
<li>Creating a Dynamo table and using it to store and retrieve information</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>In this chapter, we will be creating a Lambda function for our skill, and we'll be creating and deploying it using the local development setup that we created in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank"/><a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>.</p>
<p>All of the code and data required for this chapter can be found at <a href="http://bit.ly/chatbot-ch6">http://bit.ly/chatbot-ch6.</a></p>
<p><a href="http://bit.ly/chatbot-ch6"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing the flows</h1>
                
            
            
                
<p>The FAQ chatbot that we built in the previous chapter didn't need to have any flows designed as everything was simply a question and an answer. This chatbot will be a lot more complex, with multiple flows, some of which will lead to other intents and flows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Perfect conversations</h1>
                
            
            
                
<p>As always, we can start to build flow diagrams by starting with perfect conversations. The difference this time is that we will have a few different conversations. We'll have some that go from asking about stock to making a purchase, others will stop before checking out, and some people won't even add anything to their basket. These are all flows that we will need to design and build.</p>
<p>It is good to start with a conversation that goes through the whole process. Here is one such conversation:</p>
<div><img src="img/bd74cd0d-d0c9-4a36-9c0b-36cfb1fec56f.png" style=""/></div>
<p>Full process conversation</p>
<p>We can also create other conversations that deal with part of the flow. A user could add some items to their basket and then save them for later, while another user will want to ask what is in their cart before checking out. You can probably see that some of these conversations will overlap. This will become more apparent as we progress onto our flow diagrams.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flow diagrams</h1>
                
            
            
                
<p>As this is a large and complex conversation, we are going to break the flow into sections. This will make it easier to create and visualize.</p>
<p>The first part of the full conversation, as well as the stock-checking conversation, can be used to create a <kbd>productFind</kbd> flow diagram:</p>
<div><img src="img/6d828097-266f-4006-a24b-c341f4998227.png" style=""/></div>
<p>The productFind flow diagram</p>
<p>As you can see, there is some logic that is similar to the logic that we used in the Car Helper chatbot in <a href="13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml" target="_blank"/><a href="13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml" target="_blank">Chapter 3</a>, <em>Creating Your</em> <em>First Alexa Skill</em>. By the end of this flow, we know what product the user is asking about.</p>
<p class="mce-root">You may have noticed a new symbol in this flow. This symbol is similar to <kbd>intentTrigger</kbd> but this is for starting another flow. Breaking the whole flow into smaller chunks that can call each other is the best way to keep your diagrams organized:</p>
<div><img src="img/b91d2c7a-dee7-4a9c-920c-9fb10ae5b3fd.png" style=""/></div>
<p>Start another flow</p>
<p>Now that we know what product the user is asking about, we can create a flow for checking stock and asking whether they want to add that to their cart. This starts with a request to S3, and if there is stock and they want it, we add it to their basket in Dynamo:</p>
<div><img src="img/b5adffcb-a780-467d-a658-456936dc4922.png" style=""/></div>
<p>Stock and cart</p>
<p>The last stage of this conversation is the checkout. This is about getting a few details about the user so we can place the order. This would normally include taking a card payment, but we won't be doing that with this chatbot:</p>
<div><img src="img/474d1365-9297-4ce0-a090-4ae846948f8f.png" style=""/></div>
<p>Checkout</p>
<p>The reason that we are breaking the conversation into multiple smaller flow diagrams is so that each flow does a single thing. This means that we can link different flows together. What if we have a user who knows the ID for the item? We can have them skip the <kbd>productFind</kbd> flow and start at the <kbd>lookupAndCart</kbd> flow.</p>
<p>When we consider a few other conversations, we end up with a web of flows in a master flow diagram:</p>
<div><img class="alignnone size-full wp-image-306 image-border" src="img/0906373e-0a2a-4bb6-a6c8-a94daad7b648.png" style=""/></div>
<p>Master flow diagram</p>
<p>This master flow diagram shows how each of the sub-flows can be connected together to map any conversation. This web of conversation allows the chatbot to deal with the user in a much more human way than older chatbots that had a single path that the user had to follow.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the chatbot</h1>
                
            
            
                
<p>With all of the sub-flow diagrams and the master flow diagram, we can start to build the chatbot. Another great thing about having these sub-flows is that they are quite similar to intents.</p>
<p>Before we can start creating intents, we need to set up our Lex bot. In the Lex console, click Create and then follow the process for creating a Custom bot as described in <a href="e8792431-53cf-4a17-9837-edbfa381d507.xhtml" target="_blank">Chapter 5</a>, <em>Building Your First Amazon Lex Chatbot</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Product find</h1>
                
            
            
                
<p>We will start with the most common conversationâ€”finding a product. First, we'll create a new intent called <kbd>productFind</kbd>.</p>
<p>This intent will deal with users who want to find a product to add to their cart, as well as users just checking the stock levels, so we need to provide utterances to represent this. We also need to deal with user utterances such as, "I want a new jacket" and "Do you have any medium, blue shirts in stock?"</p>
<p>To capture the slot values from the utterances, we can use curly braces around the slot name:</p>
<div><img src="img/443c54cf-04b3-4ee6-ad35-e9fb8ba3839c.png" style=""/></div>
<p>Utterances for productFind</p>
<p>With some utterances created, we need to create the slots and slot types. For the <kbd>productFind</kbd> intent, we need quite a few slots: <kbd>type</kbd>, <kbd>size</kbd>, <kbd>color</kbd>, <kbd>length</kbd>, and <kbd>itemNumber</kbd>. The first four are self-explanatory but <kbd>itemNumber</kbd> is less obvious.</p>
<p>We want to include an item number slot so that if a customer wants to buy a product that they already have, they don't need to go through the longer question-answer product-finding flow. These small things are what separate good bots from great bots.</p>
<p>Next, we need to choose a slot type for each of our slots. For the first four slots, we're going to need to create custom slots:</p>
<ul>
<li><strong>Type</strong>: We are going to be selling three types of clothing: shirts, jackets, and trousers (pants).</li>
</ul>
<p style="padding-left: 60px">Click the + next to Slot types and choose Create slot type. Name your slot something such as <kbd>clothingType</kbd> and select Restrict to Slot values and Synonyms. It is a good idea to be relatively specific with your slot type naming as you can't have two slot types with the same name.</p>
<p style="padding-left: 60px">We can now add our values of the shirt, jacket, and trousers. We then need to add synonyms that the user might type. Instead of <kbd>shirt</kbd>, they may type <kbd>blouse</kbd>, <kbd>top</kbd>, or <kbd>t-shirt</kbd>. For <kbd>trousers</kbd>, they might type <kbd>a pair of trousers</kbd>, <kbd>pants</kbd>, or <kbd>a pair of pants</kbd>. Expand all of the synonyms for all of the values until you can't think of anything else.</p>
<ul>
<li><strong>Size</strong>: Size is going to be a very similar process to <em>type</em> with values of <em>large</em>, <em>medium</em>, and <em>small</em>. If this was for a genuine retailer, you'd have a lot more size options, and probably size options based on the type of item.</li>
</ul>
<p style="padding-left: 60px">Make sure to include some synonyms for each of the color values. We could use <kbd>AMAZON.Color</kbd> for the color but that would allow hundreds of colors through â€“ to make our lives easier, we're going to have five colors.</p>
<p style="padding-left: 60px">Create a custom slot type with the colors of <em>black</em>, <em>white</em>, <em>red</em>, <em>pink</em>, and <em>blue</em>. You can add synonyms of the colors, but it is more likely they are just saying a color we don't support.</p>
<p style="padding-left: 60px"><kbd>Length</kbd>: Length has values of <kbd>long</kbd>, <kbd>standard</kbd>, and <kbd>short</kbd>. Make sure to add in any synonyms you can think of, such as <kbd>medium</kbd> and <kbd>normal</kbd> as synonyms for standard.</p>
<p class="mce-root"/>
<ul>
<li><strong>Item Number</strong>: We don't need to create a new slot type for order numbers as we can use AMAZON.NUMBER. If we wanted to use item numbers, such as <em>SH429178</em>, where we use numbers and letters, we would have to use a custom slot type:</li>
</ul>
<div><img class="alignnone size-full wp-image-307 image-border" src="img/afdfb667-c905-490e-82c0-f6b262b3a8f4.png" style=""/></div>
<p>Competed slots</p>
<p>We need to change all of the slots to not be required. This is because if a user asks for an item by item number, we don't want to ask them about what size and color they want as the item has a size and color already.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda</h1>
                
            
            
                
<p>The Lambda that handles this intent is going to need to do a few things:</p>
<ul>
<li>It needs to check whether it has an item number or all of the correct slots are filled.</li>
<li>It then needs to get our S3 stock data and check the stock levels of the item requested.</li>
<li>If there is stock, it will ask the user whether they want to add it to their cart. If there's no stock, it will tell the user and ask whether they want to find another product.</li>
</ul>
<p>Start by creating a new folder in <kbd>Lambdas</kbd> called <kbd>productFind</kbd> and create an <kbd>index.js</kbd> file inside there. The <kbd>index.js</kbd> file can start with our default Node 8.10 handler and we will pass the event to a <kbd>handleProductFind</kbd> function:</p>
<pre>exports.handler = async (event) =&gt; {<br/>    return handleProductFind(event);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Inside this <kbd>handleProductFind</kbd> function, we start by checking the slot values. The first one to check is <kbd>itemNumber</kbd>, because if that one is present, we don't need any of the other slots. After that, we check the type, size, and color before finally checking the length if the type is <kbd>trousers</kbd>:</p>
<pre>const handleProductFind = event =&gt; {<br/>    let { slots } = event.currentIntent;<br/>    let { itemNumber, type, size, colour, length } = slots;<br/> <br/>    if (itemNumber) return getItem(slots);<br/>    // No item number so using normal product find<br/>    if (!type) {<br/>        let message = 'Are you looking for a shirt, jacket or trousers?';<br/>        let intentName = 'productFind';<br/>        let slotToElicit = 'type';<br/>        return Lex.elicitSlot({ message, intentName, slotToElicit, slots })<br/>    }<br/>    ...<br/>}</pre>
<p>We can copy the code for the <kbd>type</kbd> check and repeat it for the <kbd>size</kbd>, <kbd>color</kbd>, and <kbd>length</kbd> slots, changing just <kbd>message</kbd> and <kbd>slotToElicit</kbd> for each test. The <kbd>length</kbd> check needs to be modified further so that it also checks that <kbd>type</kbd> is <kbd>trousers</kbd>:</p>
<pre>if ( !length &amp;&amp; type === 'trousers' ){ ... }</pre>
<p>After the last check, we can call a function to get the item that the user has chosen through their selections. We need to pass through the slots so that we can filter down the items by user choice:</p>
<pre>return getItem(slots);</pre>
<p>Inside our <kbd>getItem()</kbd> function we need to do three things: get the data, filter out just the item that matches the user answers, and create a response.</p>
<p>To get all of the stock data from S3, we are going to create a <kbd>getStock()</kbd> function. This is going to be the same as the S3 requests that we have made before. We can then call that as the first part of the <kbd>getItem()</kbd> function:</p>
<pre>const getStock = () =&gt; {<br/>    var params = {<br/>        Bucket: 'shopping-stock',<br/>        Key: `stock.json`<br/>    };<br/> <br/>    return new Promise((resolve, reject) =&gt; {<br/>        s3.getObject(params, function(err, data) {<br/>            if (err) { // an error occurred<br/>                reject(err)<br/>            } else { // successful response<br/>                resolve(JSON.parse(data.Body).stock)<br/>            }<br/>        });<br/>    })<br/>}</pre>
<p>We also need to require in <kbd>aws-sdk</kbd> and create an <kbd>s3</kbd> instance. In your folder, run <kbd>npm install --save aws-sdk</kbd>. Put this code at the top of the file:</p>
<pre>const AWS = require('aws-sdk');<br/>const s3 = new AWS.sS()'</pre>
<p>Now that we have the data, we need to filter out the correct item. Arrays have a very useful function called <kbd>.find</kbd>. This function will go through each of the items in an array and run some code on that item. This will happen until an item returns <kbd>true</kbd> when the function returns the item that satisfied the function. If no item satisfied the function, <kbd>undefined</kbd> is returned.</p>
<p>We can use this to get the item that the user wants. We want to return <kbd>true</kbd> if all of the slots match the values on the item or the <kbd>itemNumber</kbd> matches. We also need to make sure that if the type is <kbd>trousers</kbd>, then the <kbd>length</kbd> matches as well:</p>
<pre>let matching = stock.find(item =&gt;<br/>    itemNumber === item.itemNumber ||<br/>    type == item.type &amp;&amp;<br/>    size == item.size &amp;&amp;<br/>    colour == item.colour &amp;&amp;<br/>    (item.length == length || item.type != 'trousers'));</pre>
<p>After this, we expect that we will have one item. If we don't, either we've created the function incorrectly or the data was wrong. Either way, we need to tell the user that we haven't managed to find the item that they were looking for:</p>
<pre>if (!matching) {<br/>    let message = `Unfortunately we couldn't find the item you were looking for`;<br/>    return Lex.Close({ message })<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>If we found an item but there is no stock, then we can tell the user and ask whether they would like to find another product. This means we will be using the <kbd>confirmIntent</kbd> Lex response. This response takes an <kbd>intentName</kbd>, a <kbd>message</kbd>, and a <kbd>slots</kbd> object containing all of the slots with values or <kbd>null</kbd>:</p>
<pre>if (matching.stock &lt; 1) {<br/>    let message = `Unfortunately we don't have anything matching your request in stock. Would you like to search again?`;<br/>    let intentName = 'productFind';<br/>    slots = { type: null, size: null, colour: null, length: null, itemNumber: null };<br/>    return Lex.confirmIntent({ intentName, slots, message })<br/>}</pre>
<p>If we find the product and there is stock, then we need to tell the user how many we have in stock. One tricky thing we have to deal with is the plurality of the types. If we find more than one <em>shirt</em>, they are called <em>shirts</em>; when a user has chosen <em>trousers</em>, we could either have one <em>pair of trousers</em> or multiple <em>pairs of trousers</em>. To avoid making the message string really complicated, we can make a function that takes the type and stock and returns the correct unit name:</p>
<pre>const units = (type, stock) =&gt; {<br/>    if (type === 'trousers') {<br/>        return `pair${stock !== 1 ? 's': ''} of trousers`<br/>    }<br/>    return `${type}${stock !== 1 ? 's': ''}`;<br/>}</pre>
<p>This means that we can create a much neater message for the user. The message that we will be asking will be whether they want to add this item to their basket. We can use another <kbd>confirmIntent</kbd> response with an <kbd>intentName</kbd> of <kbd>addToBasket</kbd> with slots of <kbd>itemNumber</kbd>, which are set to <kbd>matching.itemNumber</kbd>:</p>
<pre>let message = `There are ${matching.stock} ${matching.colour} ${units(matching.type, matching.stock)} in stock. Would you like to add one to your basket?`;<br/>let intentName = 'addToBasket';<br/>slots = { itemNumber: matching.itemNumber };<br/>return Lex.confirmIntent({ intentName, slots, message });</pre>
<p>Throughout this Lambda, we have been using a lot of <kbd>Lex.something</kbd> responses. These are methods on the <kbd>Lex</kbd> class. To make these work, we need to create a new class called <kbd>Lex</kbd>, which contains all of the Lex responses we talked about in the previous chapter.</p>
<p>Create a new file called <kbd>LexResponses.js</kbd>, and inside we will create our class:</p>
<pre>module.exports = class Lex {<br/>    ElicitSlot({ sessionAttributes = {}, message, intentName, slotToElicit, slots }) { ... }<br/>    Close({ message, sessionAttributes = {}, fulfillmentState = "Fulfilled" }) { ... }<br/>    ElicitIntent({ message, sessionAttributes = {} }) { ... }<br/>    confirmIntent({ sessionAttributes = {}, intentName, slots, message }) { ... }<br/>    delegate({ sessionAttributes = {}, slots }) { ... }<br/>}</pre>
<p>The objects that we return from these methods can be found at the end of the previous chapter, or the complete <kbd>LexResponses.js</kbd> file can be found at <a href="http://bit.ly/chatbot-ch6">bit.ly/chatbot-ch6</a>.</p>
<p>We then need to require this class in this file and create a new instance of the class. At the top of our <kbd>productFind</kbd>/<kbd>index.js</kbd> file, add these two lines of code. The first line requires our <kbd>Lex</kbd> class from our <kbd>LexResponses</kbd> file, before the second line creates a new instance of this class:</p>
<pre>const lex = require('./LexResponses);<br/>const Lex = new lex();</pre>
<p>Earlier in this Lambda, we wrote that if there is no stock, we ask the user whether they want to find another order using <kbd>confirmIntent</kbd>. This <kbd>confirmIntent</kbd> response will hit our same Lambda, but there will be a slightly different format to the call. We need to look for those different requests and handle them accordingly.</p>
<p>If the Lambda was called with <kbd>confirmIntent</kbd>, then <kbd>event.currentIntent.confirmationStatus</kbd> will have a value of <kbd>Confirmed</kbd> or <kbd>Denied</kbd>. If the user denied the question (said "no"), then we can give them a goodbye message and close the message. If they confirmed, we can let the process fall through to the <kbd>handleProductFind()</kbd> function. The following code needs to be added in the <kbd>exports.handler</kbd> function before the <kbd>handleProductFind()</kbd> function:</p>
<pre>if (event.currentIntent &amp;&amp; event.currentIntent.confirmationStatus) {<br/>    let confirmationStatus = event.currentIntent.confirmationStatus;<br/>    if (confirmationStatus == "Denied"){<br/>        console.log('got denied status');<br/>        let message = `Thank you for shopping with us today. Have a nice day`<br/>        return Lex.close({message})<br/>    }<br/>    if (confirmationStatus == 'Confirmed'){<br/>        console.log('got confirmed status');<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the data</h1>
                
            
            
                
<p>Creating the data for this Lambda is not difficult, but there is a lot of data to generate. A record needs to be created for every combination of color, size, and type of item, as well as every pair of trousers needing a short, standard, and long length. Each of these rows needs to be in an array with a key of <strong>stock</strong>.</p>
<p>You can download the completed data file at <a href="http://bit.ly/chatbot-ch6">bit.ly/chatbot-ch6</a>. This file needs to be put into a new bucket called <kbd>shopping-stock</kbd> so our Lambda can access it. As in previous chapters, we don't need to change any of the permissions on the bucket or file from their defaults.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lambda testing</h1>
                
            
            
                
<p>To test this Lambda, we can create some tests. These tests should test all of the scenarios:</p>
<ul>
<li>All of the normal slots filled</li>
<li>Only the <kbd>itemNumber</kbd> slot filled</li>
<li>Missing a slot value</li>
<li>A <kbd>Denied</kbd> confirmation status</li>
<li>A <kbd>Confirmed</kbd> confirmation status</li>
</ul>
<p>We need to use four tests to cover all of these scenarios as we can test <kbd>Confirmed</kbd> with any of the slot filled scenarios.</p>
<p>In the Lex console, navigate into the <kbd>productFind</kbd> Lambda, and at the top of the page click Configure test events. The first test event that we can test is missing a slot value. We can actually provide no slot values and we expect that the Lambda will ask us to choose a shirt, jacket, or trousers. This is the input for the first test. Name this test and click Save. When you click Test, you should get a successful response in the format we expect:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "type": null,<br/>            "size": null,<br/>            "colour": null,<br/>            "length": null,<br/>            "itemNumber": null<br/>        }<br/>    }<br/>}</pre>
<p>Next, we can test for a Confirmed confirmation status and all slots filled in one test. Click the dropdown and select Configure test events again. This test object now also has <kbd>confirmationStatus</kbd> on the <kbd>currentIntent</kbd> object:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "type": "shirt",<br/>            "size": "medium",<br/>            "colour": "blue",<br/>            "length": null,<br/>            "itemNumber": null<br/>        },<br/>        "confirmationStatus": "Confirmed"<br/>    }<br/>}</pre>
<p>Similar tests can be created to test <kbd>Denied</kbd> requests and <kbd>itemNumber</kbd> requests. The exact code for the tests can be found in the <kbd>tests</kbd> file in the <kbd>productFind</kbd> code folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Completing the intent</h1>
                
            
            
                
<p>Now that we have a Lambda to fulfill the intent, we need to go back into Lex and make sure that our intent is triggering that Lambda. As in <a href="e8792431-53cf-4a17-9837-edbfa381d507.xhtml" target="_blank">Chapter 5</a>, <em>Building Your First Amazon Lex Chatbot</em>, scroll to the Fulfillment section of the intent and select Lambda fulfillment. From the drop-down menu, we can choose our new <kbd>productFind</kbd> Lambda.</p>
<p>Save the intent and we're ready to move on to the next step.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Add to cart</h1>
                
            
            
                
<p>This intent is a simple intent. If a user says <kbd>Yes</kbd> to adding the item to the cart, then it adds the item to a cart in Dynamo and asks whether they want to checkout or add another item. If the user says no to adding the item to the cart, then it asks the user whether they want to find another product.</p>
<p>Inside Lex, we need to create a new intent called <kbd>addToCart</kbd> with a single slot of <kbd>itemNumber</kbd>. This <kbd>itemNumber</kbd> slot can be set to have the slot type of AMAZON.NUMBER as we've used simple numbers as our item numbers.</p>
<p>As we did in the last Lambda, we need to set this slot to <em>not be required</em>. If we required the slot and a user started the intent without one, they would be asked for the item number. Most people won't know items by item number so they wouldn't know what to put. If they enter anything that isn't valid, Lex will re-prompt them for the item number until they guess one or they fail three times. We want to be able to check whether there is an item number and to send them to <kbd>productFind</kbd> if there isn't.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda</h1>
                
            
            
                
<p>To start this Lambda, create another folder in the <kbd>Lambda</kbd> directory called <kbd>addToCart</kbd> with an <kbd>index.js</kbd> file inside. In your folder, we need to run <kbd>npm install --save aws-sdk</kbd> to make sure that we have access to AWS. We start, as normal, with our default node 8.10 function, and there are two things we need to do at the start of this function: check whether there is a <kbd>Denied</kbd> confirmation status, and call a <kbd>handleAddToCart</kbd> function.</p>
<p>If the confirmation status is <kbd>denied</kbd>, we can ask the user whether they want to find another product, using <kbd>Lex.confirmIntent</kbd>. We have already programmed our <kbd>productFind</kbd> Lambda to deal with <kbd>confirmIntent</kbd> triggers so that should already be working:</p>
<pre>exports.handler = async (event) =&gt; {<br/>    if (event.currentIntent &amp;&amp; event.currentIntent.confirmationStatus === "Denied"){<br/>        let message = `Would you like to find another product?`;<br/>        let intentName = 'productFind';<br/>        let slots = { type: null, size: null, colour: null, length: null, itemNumber: null };<br/>        return Lex.confirmIntent({ intentName, slots, message })<br/>    }<br/>    return handleAddToCart(event);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As we're using the same <kbd>Lex.confirmIntent</kbd> function as in <kbd>productFind</kbd>, we need to copy the <kbd>LexResponses.js</kbd> file into this folder and add this code to the top of this file:</p>
<pre>const lex = require('./LexResponses');<br/>const Lex = new lex();</pre>
<p>With the confirmation status dealt with, we can focus on adding the item to the cart. We need to create the <kbd>handleAddToCart</kbd> function; the first thing that this needs to do is check that we have an <kbd>itemNumber</kbd>. This check will be very similar to the checks at the start of our <kbd>productFind</kbd> Lambda, except a missing <kbd>itemNumber</kbd> will trigger <kbd>confirmIntent</kbd> on <kbd>productFind</kbd>:</p>
<pre>const handleAddToCart = async event =&gt; {<br/>    let { slots } = event.currentIntent;<br/>    let { itemNumber } = slots;<br/> <br/>    if (!itemNumber) {<br/>        let message = `You need to select a product before adding it to a cart. Would you like to find another product?`;<br/>        let intentName = 'productFind';<br/>        slots = { type: null, size: null, colour: null, length: null, itemNumber: null };<br/>        return Lex.confirmIntent({ intentName, slots, message })<br/>    }<br/>}</pre>
<p>If there is an item number, then we need to add the item to the user's cart. Next, we will be creating a new class, called <kbd>DB</kbd>, so that we can make requests, but for now we can assume that these methods exist.</p>
<p>To add an item to the user's cart, we need to check whether the user already has a cart. If they don't, the request will error and we need to create a new cart for them. We are using the same <em>to</em> error-catching method that we discussed in <a href="7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml" target="_blank">Chapter 4</a>, <em>Connecting Your Alexa Skill to External APIs</em>, for error-handling.</p>
<p>The <kbd>shopping-cart</kbd> table will contain four keys:</p>
<ul>
<li>ID is a string of the conversation ID</li>
<li>Items is a list of <kbd>itemNumbers</kbd></li>
<li><kbd>name</kbd> is a name you can give to your cart to save it</li>
<li>TTL is the <em>time to live</em> for the data</li>
</ul>
<p>The TTL is used so that the record is automatically deleted at a set time. This helps keep your database clean, and is very useful if you have to deal with data protection.</p>
<p class="mce-root"/>
<p>We can try to get a record from the database using <kbd>DB.get</kbd>, which we will create later in this section. If it returns a value, we can use this as the existing cart. If there isn't a <kbd>cartUser</kbd>, we will create a default cart. To ensure that the name is unique, we'll use a UUID (universally unique identifier) by setting <kbd>name</kbd> to <kbd>uuidv4()</kbd>:</p>
<pre>let [err, cartUser] = await to(DB.get('ID', event.userId, 'shopping-cart'));<br/>if (!cartUser) {<br/>    cartUser = { ID: event.userId, Items: [], name: uuidv4(), TTL: 0 }<br/>}</pre>
<p>To get this working, we need to run <kbd>npm install --save uuid</kbd> while in out Lambda folder. We then need to include this line at the top of the <kbd>index.js</kbd> file: </p>
<pre>const uuidv4 = require('uuid/v4');</pre>
<p>Now we have a value for <kbd>cartUser</kbd> for both new and existing carts. To update this cart row, we can use the <kbd>spread</kbd> operator. This takes an object or array and spreads the values into the new object or array. Any values after the spread can overwrite the values in <kbd>spread</kbd>:</p>
<pre>let updatedCart = { ...cartUser, Items: [...cartUser.Items, itemNumber], TTL: Date.now() + 7 * 24 * 60 * 60 * 1000 };</pre>
<p>This line of code takes the previous cart, adds a new item number to the <kbd>Items</kbd> list, and changes the <em>time to live</em> to be <kbd>7</kbd> days from now.</p>
<p>With an updated cart, we need to write it to the table. If there is an error writing to the table, we need to tell the user using <kbd>Lex.close</kbd>:</p>
<pre>let [writeErr, res] = await to(DB.write(event.userId, updatedCart, 'shopping-cart'));<br/>if (writeErr) {<br/>    let message = `Unfortunately we've had an error on our system and we can't add this to your cart.`<br/>    return Lex.close({ message });<br/>}</pre>
<p>If adding the item to the cart worked, we can ask the user whether they want to add another product, checkout, or save the cart. Unlike when we've asked them whether they want to find another product or add this item to a cart, it isn't a <em>yes/no</em> question. They should answer with <kbd>I want to checkout</kbd>, <kbd>I want to save my cart</kbd>, or <kbd>I want to add another item</kbd>, which we will set as example utterances for the <kbd>checkout</kbd>, <kbd>saveCart</kbd>, and <kbd>productFind</kbd> intents.</p>
<p class="mce-root"/>
<p>Because we are trying to find out which intent the user wants to use, we can respond to Lex with an <kbd>elicitIntent</kbd> response:</p>
<pre>let message = `Would you like to checkout, add another item to your cart or save your cart for later?`;<br/>return Lex.elicitIntent({ message });</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">DynamoDB</h1>
                
            
            
                
<p>As we said earlier, we are going to use DynamoDB to store the cart information. We are going to have two Dynamo tables, one for current carts and one for placed orders. To create these, we need to go onto the AWS console and navigate to the <kbd>DynamoDB</kbd> service:</p>
<div><img class="alignnone size-full wp-image-308 image-border" src="img/32efdd8b-b323-413c-ae43-273abcd3f7cd.png" style=""/></div>
<p>DynamoDB console page</p>
<p>Click Create table to start creating a new table. We are asked to name our table and select a primary key. We're going to call our first table <kbd>shopping-cart</kbd> and set the Primary key to <kbd>ID</kbd>. The primary key is the value that we will be able to use to look up records, and it is best practice to use <kbd>ID</kbd> as the name of the Primary key:</p>
<div><img src="img/231a5f1b-9f58-4aab-afdb-c8ecf77799b9.png" style=""/></div>
<p>Table creation</p>
<p>When we click the Create button, we will be taken to the main DynamoDB console page. There is a lot of information available on this page, but we only need to see that we have our <kbd>shopping-cart</kbd> table in the table list. When you have just created the table, it may have a loading indicator next to it as the creation process finishes.</p>
<p>With our table created, we need to write some code that allows us to work with it. Because we will be working with Dynamo in multiple intents and Lambdas, it is good practice to create reusable code. For this, we will create a <kbd>DB</kbd> class that provides methods to get, write, update, and deletes record from the database. Create a new file called <kbd>DB.js</kbd> in our <kbd>addToCart</kbd> folder, and inside we're going to create a new class:</p>
<pre>module.exports = class DB {};</pre>
<p>To allow us to access the Dynamo tables, AWS provides us with a DynamoDB document client. To create <kbd>documentClient</kbd>, we need to pass in a configuration object containing the region. This code can go at the top of our <kbd>DB</kbd> file.</p>
<p>Make sure to change your region to the region that your tables are located in. This should be either <kbd>eu-west-1</kbd> or <kbd>us-east-1</kbd>. If you are not sure, go to your AWS console and check your location setting. Ireland is <kbd>eu-west-1</kbd> and US East (N. Virginia) is <kbd>us-east-1</kbd>:</p>
<pre>const AWS = require('aws-sdk');<br/>let documentClient = new AWS.DynamoDB.DocumentClient({<br/>    'region': 'eu-west-1'<br/>});</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now that we've created our <kbd>documentClient</kbd> variable, we can move back into our class and create our methods. The first method that we are going to make is <kbd>write</kbd>. We need three things to write to a table: the row ID, the data that we want to write, and the table name.</p>
<p>To improve the usability of this class, we're going to return a <kbd>Promise</kbd>. Inside this <kbd>Promise</kbd>, we first need to check the <kbd>ID</kbd>, <kbd>data</kbd>, and <kbd>table</kbd>. If any of them are missing, or if <kbd>ID</kbd> or <kbd>table</kbd> aren't strings, we need to throw an error:</p>
<pre>write(ID, data, table) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        if (!ID) throw 'An ID is needed';<br/>        if (typeof ID !== 'string') throw `the id must be a string and not ${ID}`<br/>        if (!data) throw "data is needed";<br/>        if (!table) throw 'table name is needed';<br/>        if (typeof table !== 'string') throw `the table must be a string and not ${table}`;<br/>    })<br/>}</pre>
<p>If <kbd>ID</kbd>, <kbd>data</kbd>, and <kbd>table</kbd> are all correct, we can write our data to the table. To write to a table, we need to pass the request into a specific format. The <kbd>Item</kbd> needs to be all of the data with an added <kbd>ID</kbd> field with a value of the row ID that we pass in:</p>
<pre>let params = {<br/>    TableName: table,<br/>    Item: { ...data, ID: ID }<br/>};</pre>
<p>This <kbd>params</kbd> object can then be passed into the <kbd>documentClient.put()</kbd> method, which also takes a <kbd>callback</kbd> function. We <kbd>console.log</kbd> out the error or data from the response before resolving the data or rejecting the error:</p>
<pre>documentClient.put(params, function(err, result) {<br/>    if (err) {<br/>        console.log("Err in writeForCall writing messages to dynamo:", err);<br/>        console.log(params);<br/>        return reject(err);<br/>    }<br/>    console.log('wrote data to table ', table)<br/>    return resolve({ ...result.Attributes, ...params.Item });<br/>});</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>As we are creating this class, we are going to create the <kbd>get</kbd>, <kbd>update</kbd>, and <kbd>delete</kbd> methods as well.</p>
<p><kbd>get</kbd> is very similar to <kbd>write</kbd>, taking just a <kbd>key</kbd>, <kbd>value</kbd>, and <kbd>table</kbd>. Instead of passing in the items that we want to write, we pass in the key that we want to match. This <kbd>key-value</kbd> pair needs to be set inside <kbd>params</kbd>:</p>
<pre>get(key, value, table) {<br/>    if (!table) throw 'table needed';<br/>    if (typeof key !== 'string') throw `key was not string and was ${JSON.stringify(key)} on table ${table}`;<br/>    if (typeof value !== 'string') throw `value was not string and was ${JSON.stringify(value)} on table ${table}`;<br/>    return new Promise((resolve, reject) =&gt; {<br/>        let params = {<br/>            TableName: table,<br/>            Key: { [key]: value }<br/>        };<br/>        documentClient.get(params, function(err, data) {<br/>            if (err) {<br/>                console.log(`There was an error fetching the data for ${key} ${value} on table ${table}`, err);<br/>                return reject(err);<br/>            }<br/>            //TODO check only one Item.<br/>            return resolve(data.Item);<br/>        });<br/>    });<br/>}</pre>
<p><kbd>get</kbd> works as you would expect for getting items based on the primary index, but what if we want to get items by a second value? We can't use <kbd>documentClient.get()</kbd>, so we need to create a new function called <kbd>getDifferent</kbd>. This function uses <kbd>documentClient.query()</kbd> instead of <kbd>documentClient.get()</kbd>:</p>
<pre> getDifferent(key, value, table) {<br/>     if (!table) throw 'table needed';<br/>     if (typeof key !== 'string') throw `key was not string and was ${JSON.stringify(key)} on table ${table}`;<br/>     if (typeof value !== 'string') throw `value was not string and was ${JSON.stringify(value)} on table ${table}`;<br/>     if (!table) 'table needs to be users, sessions, or routes.'<br/>     return new Promise((resolve, reject) =&gt; {<br/>         var params = {<br/>             TableName : table,<br/>             IndexName : `${key}-index`,<br/>             KeyConditionExpression : `${key} = :value`, <br/>             ExpressionAttributeValues : {<br/>                 ':value' : value <br/>             }<br/>         };<br/> <br/>         documentClient.query(params, function(err, data) {<br/>             if (err) {<br/>                 console.error("Unable to read item. Error JSON:", JSON.stringify(err));<br/>                 reject(err);<br/>             } else {<br/>                 console.log("GetItem succeeded:", JSON.stringify(data.Items));<br/>                 resolve(data.Items);<br/>             }<br/>         });<br/>     })<br/> }</pre>
<p><kbd>delete</kbd> is almost identical to <kbd>get</kbd>, with the main difference being that we call <kbd>documentClient.delete</kbd>:</p>
<pre>delete(ID, table) {<br/>    if (!table) throw 'table needed';<br/>    if (typeof ID !== 'string') throw `ID was not string and was ${JSON.stringify(ID)} on table ${table}`;<br/>    console.log("dynamo deleting record ID", ID, 'from table ', table);<br/>    let params = {<br/>        TableName: table,<br/>        Key: { 'ID': ID  }<br/>    };<br/> <br/>    return new Promise((resolve, reject) =&gt; {<br/>        documentClient.delete(params, function(err, data) {<br/>            if (err) {<br/>                reject(err);<br/>            } else {<br/>                resolve(data);<br/>            }<br/>        });<br/>    });<br/>}</pre>
<p>The last method that we need to create is <kbd>update</kbd>. This is a very simple method as it just uses the other methods to do most of the work. It gets the data for the <kbd>ID</kbd> and then writes it back with the new key and value added on or changed:</p>
<pre>async update(ID, table, key, value) {<br/>    let data = await this.get(ID, table);<br/>    return this.write(ID, { ...data, [key]: value }, table);<br/>}</pre>
<p>Now that we've completed the <kbd>DB</kbd> class, we need to import it into our Lambda and create a new instance. At the top of our <kbd>index.js</kbd> file in the <kbd>addToCart</kbd> folder, we can add these lines:</p>
<pre>const db = require('./DB');<br/>const DB = new db();</pre>
<p>Our Lambdas have to deal with Dynamo as well as S3; we need to give these Lambdas the permissions they need to do this.</p>
<p>Open up the AWS console and navigate to AIM. Under Roles in the menu on the left, find the role that we created back in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>. We're going to add Dynamo permissions to this role.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Dynamo permissions</h1>
                
            
            
                
<p>Now that our Lambdas are working with Dynamo and S3, we need to update our permissions the role that we use to build our Lambdas. Navigate to the <kbd>IAM</kbd> service and select the lambdaBasic role that we created in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>. Click Attach policy and search for Dynamo.</p>
<p>We need to add AmazonDynamoDBFullAccess. This gives the Lambda permissions to read and write to Dynamo:</p>
<div><img src="img/f461327e-feb6-4c6c-9b13-41f4248ac394.png" style=""/></div>
<p>Adding DynamoDB policies</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>Before we run any testing, we need to build and deploy our Lambda. Using the build script we created in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>, we can run <kbd>./build.sh addToCart</kbd> to build and deploy our new Lambda.</p>
<p>With this complete, we can navigate to our Lambda console and select our new <kbd>addToCart</kbd> Lambda. Next to Test, we can click Configure test events.</p>
<p>There are things that we need to test for this Lambda:</p>
<ul>
<li>A <kbd>Denied</kbd> confirmation status</li>
<li>A <kbd>Confirmed</kbd> confirmation status</li>
<li>A trigger without an <kbd>itemNumber</kbd></li>
<li>Adding an item to a new cart</li>
<li>Adding an item to an existing cart</li>
</ul>
<p> </p>
<p class="mce-root">A <kbd>Denied</kbd> trigger is the easiest to test. You should get a response asking <kbd>Would you like to find another product?</kbd>:</p>
<p> </p>
<pre>{ "currentIntent": { "confirmationStatus": "Denied" } }</pre>
<p>We can test a <kbd>Confirmed</kbd> confirmation status and a trigger without an <kbd>itemNumber</kbd> in one test. We should get through to the <kbd>handleAddToCart</kbd> function, and then get a response telling us we need to select a product and asking whether we want to find one:</p>
<pre>{<br/>    "currentIntent": {<br/>        "confirmationStatus": "Confirmed",<br/>        "slots": {<br/>            "itemNumber": null<br/>        }<br/>    }<br/>}</pre>
<p>The test for adding an item to a new cart and to an existing cart will be the same; you just have to run the test twice. The first time, there won't be any existing order. The second time, there will be. You need to change the <kbd>ID</kbd> value every time you want to test a new cart:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "itemNumber": 1034<br/>        }<br/>    },<br/>    "userId": "123-sdf-654-hjk2"<br/>}</pre>
<p>Both times, you should get a response asking <kbd>Would you like to checkout or add another item to your basket?</kbd>.</p>
<p>The last thing we need to do is to add this tested Lambda as the handler for the intent. Navigate to the Lex chatbot and to the <kbd>addToCart</kbd> intent. In the Fulfillment section of the page, we can change the fulfillment to Lambda fulfillment and select our new <kbd>addToCart</kbd> Lambda to fulfill it.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Checkout</h1>
                
            
            
                
<p>When a user wants to checkout, we are going to do a simplified checkout process. We are just going to ask them for a mailing address and tell them we'll collect payment on delivery. Behind the scenes, we're going to take their cart and move it into a new <kbd>shopping-orders</kbd> table.</p>
<p>To start, we need to create a new intent in Lex called <kbd>checkout</kbd>. We can add utterances such as <kbd>I want to checkout</kbd>, <kbd>can I checkout please</kbd>, and just <kbd>checkout</kbd>. You can add more utterances that you expect a user might reply to, such as <kbd>Would you like to checkout or add another item to your basket?</kbd>.</p>
<p>We can access their cart using the <em>userId</em> on the event so the only other information we need is their <kbd>deliveryAddress</kbd> â€“ so we need to add that as a slot. The slot type for this slot can be set to AMAZON.PostalAddress and we can add a prompt of <kbd>What address do you want your products delivered to?</kbd>. We can set this slot to be required so that whenever this intent is triggered. This means that we should already have the delivery address when the fulfillment Lambda gets triggered:</p>
<div><img src="img/864e93bc-b2b7-46f0-a8af-39e8b96b78a0.png"/></div>
<p>Checkout slot</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda</h1>
                
            
            
                
<p>With the intent set up, we can create the Lambda. Create a new folder called <kbd>checkout</kbd> and add an <kbd>index.js</kbd> file. In your folder, we need to run <kbd>npm install --save aws-sdk</kbd>. We are going to start with the node 8.10 handler with the <kbd>confirmationStatus</kbd> check for a denied status. We may want to trigger this intent with <kbd>confirmIntent</kbd> in the future:</p>
<pre>exports.handler = async (event) =&gt; {<br/>    if (event.currentIntent &amp;&amp; event.currentIntent.confirmationStatus === "Denied") {<br/>        let message = `Would you like to find another product?`;<br/>        let intentName = 'productFind';<br/>        slots = { type: null, size: null, colour: null, length: null, itemNumber: null };<br/>        return Lex.confirmIntent({ intentName, slots, message })<br/>    }<br/>    return handleCheckout(event);<br/>}</pre>
<p>We have already used <kbd>Lex</kbd> again, so we need to copy our <kbd>LexResponse.js</kbd> file into this folder and use our setup code at the top of the file:</p>
<pre>const lex = require('./LexResponses');<br/>const Lex = new lex();</pre>
<p>Now we can get into the bulk of this Lambda with our <kbd>handleCheckout</kbd> function. We are first going to check that we have a value in the <kbd>deliveryAddress</kbd> slot. If we don't, then we'll ask them for it using <kbd>elicitSlot</kbd>:</p>
<pre>const handleCheckout = async event =&gt; {<br/>    let { slots } = event.currentIntent;<br/>    let { deliveryAddress } = slots;<br/> <br/>    if (!deliveryAddress) {<br/>        let message = `What address would you like this order delivered to?`;<br/>        let intentName = 'checkout';<br/>        slots = { deliveryAddress: null };<br/>        let slotToElicit = 'deliveryAddress';<br/>        return Lex.elicitSlot({message, intentName, slots, slotToElicit});<br/>    }<br/>}</pre>
<p>Once we know that we have a delivery address, we can turn their cart into an order. To do this, we'll get their cart and then put that into a <kbd>shopping-orders</kbd> table with their delivery address and date of order.</p>
<p>Before we can create the code, we need to set up a new table in DynamoDB. Navigate to the Dynamo console in AWS and click Create table. Name our new table <kbd>shopping-orders</kbd> and give it a primary key of <kbd>ID</kbd>.</p>
<p>Back in our Lambda code, we can now create the logic to place the order. First we need to get the cart, and then delete that cart. If we get an error, then we need to tell the user and ask whether there is anything else we can help them with:</p>
<pre>let [cartErr, cart] = await to(DB.get("ID", event.userId, 'shopping-cart'));<br/>if (!cart){<br/>    console.log('no cart');<br/>    let message = `We couldn't find your cart. Is there anything else I can help you with`;<br/>    return Lex.elicitIntent({ message });<br/>}</pre>
<p>If we successfully got a cart back, we can delete the cart, create a new <kbd>orders</kbd> object, and write that to our <kbd>shopping-orders</kbd> table. We delete the cart because we don't expect to place an order and still have all of the items in your cart:</p>
<pre>let order = { Items: cart.Items, address: deliveryAddress, date: Date.now() };<br/>let ID = uuidv4();</pre>
<p>We generate a random ID by using <kbd>uuidv4()</kbd> again. This means that we also need to run <kbd>npm install --save uuid </kbd> and include <kbd>const uuidv4 = require('uuid/v4');</kbd> at the top of this file.</p>
<p>We will use a <kbd>try</kbd>/<kbd>catch</kbd> for this as it allows us to make both of the requests and handle any errors in a single handler. If an error is thrown, it is likely that our code is wrong so we don't want to make the user go through that again. Therefore, we'll tell them there was an error and their order can't be placed:</p>
<pre>try {<br/>    await to(DB.write(ID, order, 'shopping-orders'));<br/>    await to(DB.delete(event.userId, 'shopping-cart'));<br/>} catch (err) {<br/>    console.log('error deleting the cart or writing the order', cartErr)<br/>    let message = `I'm sorry, there was a system error so your order hasn't been placed.`;<br/>    return Lex.close({ message });<br/>}</pre>
<p>If there wasn't an error, we can tell the user that their order was placed:</p>
<pre>let message = `Thank you. Your order has been placed and will be delivered in 3-5 working days`;<br/>return Lex.close({ message });</pre>
<p>With all paths of the intent completed, we can use our build script to build and deploy our Lambda before testing. Navigate into your <kbd>Lambdas</kbd> folder and run the following code:</p>
<pre>./build.sh checkout</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>With this Lambda, there are a few scenarios to test:</p>
<ul>
<li>Confirmed intent</li>
<li>Denied intent</li>
<li>No delivery address</li>
<li>The user doesn't have a cart to checkout</li>
<li>The user has a cart</li>
</ul>
<p>A <kbd>Denied</kbd> intent should ask us whether we want to find a new product:</p>
<pre>{ "currentIntent": { "confirmationStatus": "Denied" } }</pre>
<p>The <kbd>Confirmed</kbd> intent and no delivery address can be tested together. We expect the status to have no effect on the process, and the response to ask us for our delivery address:</p>
<pre>{<br/>    "currentIntent": {<br/>        "confirmationStatus": "Confirmed",<br/>        "slots": { "deliveryAddress": null}<br/>    }<br/>}</pre>
<p>To test a user without a cart, we can call the Lambda with a <kbd>userId</kbd> that would never have an order. We can choose a normal word as this will never be used as a <kbd>userID</kbd> in Lex:</p>
<pre>{<br/> "currentIntent": {<br/> "confirmationStatus": "None",<br/> "slots": { "deliveryAddress": "123 imaginary street, fake town, madeupsville"}<br/> },<br/> "userId": "fakeUser"<br/>}</pre>
<p>From this test, we should be told <kbd>We couldn't find your cart.</kbd> and then asked whether we want to find a product.</p>
<p class="mce-root"/>
<p>The last scenario is a successful order placement. This will need a little more work as we need to find a valid cart. To do this, we can go onto AWS and navigate to Dynamo. Select the <kbd>shopping-orders</kbd> table and then we can click the Items tab. This allows us to look directly at the items in our table so we can find a valid cart ID. Copy any of the IDs, and paste it as the value in this next test case:</p>
<pre>{<br/>    "currentIntent": {<br/>        "confirmationStatus": "None",<br/>        "slots": { "deliveryAddress": "123 imaginary street, fake town, madeupsville"}<br/>    },<br/>    "userId": ## paste your ID here<br/>}</pre>
<p>From this, we expect to get a response telling us that we have successfully placed an order. We can also check in our <kbd>shopping-orders</kbd> table that we have a new row. When running this test, we need to use a valid cart ID. Unfortunately, when we create an order, we delete the old cart, meaning that the ID is no longer valid so we need to get a new ID for every test.</p>
<p>As with all of the Lambdas and intents so far, the last thing we need to do is add this tested Lambda as the handler for the intent. Navigate to the Lex chatbot and then to the checkout intent. In the Fulfillment section of the page, we can change the fulfillment to Lambda fulfillment and select our new checkout Lambda to fulfill it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving our cart</h1>
                
            
            
                
<p>So far, we have created the flow for the perfect conversation, one where the user finds one or more products, adds them to their cart, and checks out straight away. This is good, but a lot of people will add things to their cart, leave, and then come back to checkout.</p>
<p>We need to create an intent that lets the user save their cart and come back to it later to checkout. Most shopping websites will have a login system or use web caching to save a cart to a user, but we're going to save a cart by a <em>unique name</em>.</p>
<p>In our Lex console for this chatbot, we can add a new <kbd>saveCart</kbd> intent. At the end of the <kbd>addToCart</kbd> intent, we ask the user whether they want to <kbd>add another product, save your cart</kbd>, or <kbd>checkout</kbd>. We need to handle the utterances that the user might say to save their cart. Add utterances such as <kbd>save my cart</kbd> and <kbd>I want to save my cart for later</kbd>.</p>
<p>The <kbd>cart</kbd> and <kbd>basket</kbd> words are very similar in meaning, so add some utterances with each of them:</p>
<div><img src="img/c26068a8-532e-402f-87b6-bd34274c3af5.png" style=""/></div>
<p>saveCart sample utterances</p>
<p>We only need one slot for this intent. Add a slot of <kbd>cartName</kbd> with a slot type of AMAZON.Musician and a prompt of <kbd>What name would you like to save your cart as?</kbd>. Using a slot type of Musician might seem strange, but this slot type allows any value to be accepted, thereby allowing users to name their basket whatever they want. We can set the <kbd>cartName</kbd> slot to be required, as we'll always need a name to save the cart as.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda</h1>
                
            
            
                
<p>Create a new folder in the <kbd>Lambdas</kbd> folder, called <kbd>saveCart</kbd>, with an <kbd>index.js</kbd> file in it. In that <kbd>index.js</kbd> file, we're going to start, as normal, with the node 8.10 async handler. We know that we are going to be using Lex responses and accessing dynamo, so we add those files and require them into our <kbd>index.js</kbd>:</p>
<pre>const lex = require('./LexResponses');<br/>const Lex = new lex();<br/>const db = require('./DB');<br/>const DB = new db();<br/> <br/>exports.handler = async (event) =&gt; {<br/>    return handleSaveCart(event);<br/>}</pre>
<p>As we're going to be using Dynamo, we need to make sure to install <kbd>aws-sdk</kbd> by running <kbd>npm install --save aws-sdk</kbd>.</p>
<p>With this intent, we are never going to be doing <kbd>confirmIntent</kbd> on it, so we don't need to handle any confirmation status. This means the only function in our handler is a <kbd>handleSaveCart(event)</kbd> function.</p>
<p>Inside the <kbd>handleSaveCart</kbd> function, we need to get <kbd>userID</kbd> and <kbd>slots</kbd> from the event. We can then get <kbd>cartName</kbd> from the slots:</p>
<pre>const handleSaveCart = async event =&gt; {<br/>    let { slots } = event.currentIntent;<br/>    let { cartName } = slots;<br/>}</pre>
<p>We first need to check that there is a <kbd>cartName</kbd> as there always needs to be. This should never be called since the <kbd>cartName</kbd> slot is required, but it is always safer to put it in:</p>
<pre>if (!cartName) {<br/>    let message = `You need to save your cart with a name. What do you want to call it?`;<br/>    let intentName = 'saveCart';<br/>    slots = { cartName: null };<br/>    let slotToElicit = 'cartName';<br/>    return Lex.elicitSlot({ intentName, slotToElicit, slots, message });<br/>}</pre>
<p>Now that we have a valid cart name, we first need to see whether the user has a cart to checkout. If they don't, then we ask them whether they want to add an item to their cart:</p>
<pre>let [err, cart] = await to(DB.get('ID', event.userId, 'shopping-cart'));<br/>if (err || !cart || !cart.Items) {<br/>    let message = `You don't have a cart. Would you like to find a product?`;<br/>    let intentName = 'productFind';<br/>    slots = { type: null, size: null, colour: null, length: null, itemNumber: null };<br/>    return Lex.confirmIntent({ intentName, slots, message });<br/>}</pre>
<p>Next, we can check whether there is already a cart with that name. To do this, we can try getting the cart with that name. If we can't find a cart with that name it means that we won't over-ride another cart when we save. If we do find a cart with that name, then we need to ask the user for a new cart name:</p>
<pre>let [getCartErr, getCarts] = await to(DB.getDifferent('cartName', cartName, 'shopping-cart'));<br/>if (!getCarts || !getCarts[0] ) {<br/>    // No cart with that name so we can save the current cart to this name<br/>    return addNameToCart(cart, cartName);<br/>}<br/>let message = `Unfortunately you can't use that name. Please choose another name.`;<br/>let intentName = 'saveCart';<br/>let slotToElicit = 'cartName';<br/>slots = { cartName: null };<br/>return Lex.elicitSlot({ intentName, slots, slotToElicit, message });</pre>
<p>To save their cart using that cart name, we return a function to add the name to the cart. This function starts by setting the cart name as the passed-in slot value:</p>
<pre>const addNameToCart = async (cart, cartName) =&gt; {<br/>    cart.cartName = cartName;<br/>}</pre>
<p>Now we can carry on this function by writing the cart back to the table. If there is an error, we tell the user we can't save their cart, otherwise we tell them it's been saved and how to access it next time:</p>
<pre>let [err, res] = await to(DB.write(cart.ID, cart, 'shopping-cart'));<br/>if (err) {<br/>    console.log('err writing cart with name', err);<br/>    let message = `Unfortunately we cant save your cart`;<br/>    return Lex.close({ message });<br/>}<br/>let message = `Your cart has been saved. Type "find my cart" next time and enter "${cartName}" to get this cart.`;<br/>return Lex.close({ message });</pre>
<p>As always, make sure to run the build script to deploy your Lambda.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dynamo changes</h1>
                
            
            
                
<p>In this Lambda, we did <kbd>DB.get</kbd> using the <kbd>cartName</kbd> instead of the <kbd>ID</kbd>. To get this working, we need to index our table by <kbd>cartName</kbd>. Creating an index for a key allow us to search by the values. This is also why we set the default name for a cart to <kbd>uuidv4()</kbd>. Because we can search by the name, it needs to be unique.</p>
<p class="mce-root"/>
<p>Navigate to the Dynamo service in AWS and select the <kbd>shopping-cart</kbd> table. Across the top of this section is a row of tabs, and we're going to choose <em>Indexes</em> and click Create index. This will open a popup where we need to enter the key we want to index, in this case, <kbd>cartName</kbd>. Click Create index and the index will start to be created:</p>
<div><img src="img/3429173d-8a40-4af8-ad31-4b6ee66347d2.png" style=""/></div>
<p>Secondary index</p>
<p>When this finishes the creation process, we will be able to do <kbd>getDifferent</kbd> requests on this table by <kbd>cartName</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>Testing our <kbd>saveCart</kbd> intent requires only dealing with four scenarios: <em>no cart name,  no cart to save, cart name already taken,</em> and<em> saving a cart.</em></p>
<p>Testing when there is no cart name is very simple. We expect this to ask us to give a name for our cart:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "cartName": null<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To test saving when we don't have a cart, we can use a nonsense <kbd>userId</kbd> as there is no chance that there will be a cart for them. We need to pass in a valid <kbd>cartName</kbd> now so that we pass the first check:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "cartName": "personalShopping"<br/>        }<br/>    },<br/>    "userId": "asdasdasdasdasd"<br/>}</pre>
<p>We are going to have to test the last two in a different order. We first test a successful saving of a cart. To do this, we need a <kbd>userId</kbd> with a cart. We can find that by going into our Dynamo console and looking at the Items tab on our <kbd>shopping-cart</kbd> table. Choose any of the IDs that are there and copy it into the <kbd>userId</kbd> value in the test object.</p>
<p>We expect that this will be successful and we'll be told how to get our cart next time:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "cartName": "testCartSave"<br/>        }<br/>    },<br/>    "userId": ## valid userId<br/>}</pre>
<p>Now that we have saved a cart, we can try saving a different cart with the same name. We have to find a new <kbd>ID</kbd> for this test but leave the rest of the request the same.</p>
<p>This time, we should be told that we can't use that cart name and to try a different one:</p>
<pre class="mce-root">{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "cartName": "testCartSave"<br/>        }<br/>    },<br/>    "userId": ## another valid userId<br/>}</pre>
<p>With all of the tests responding as we expected, go back into the Lex console for this bot and change the fulfillment of the <em>saveCart</em> intent to the <kbd>saveCart</kbd> Lambda.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrieving a saved cart</h1>
                
            
            
                
<p>Now that the user can save their cart, we need to give them a way to get the cart that they saved. We can then change the cart so that it matches their <kbd>userId</kbd>, and then they can continue to add more items or checkout.</p>
<p>Create a new <kbd>getSavedCart</kbd> intent in Lex, and we're only going to be asking for the <kbd>cartName</kbd> of the cart they saved. As we did in the <kbd>saveCart</kbd> intent, we can set the <kbd>cartName</kbd> slot type to AMAZON.Musician to allow any values through. We can also set this slot to be required and have a prompt of <kbd>"What was the name you saved your cart to?"</kbd>.</p>
<p>Unlike with the other intents so far, we can allow the user to enter the <kbd>cartName</kbd> as part of the utterance. This is done by including the slot name in the utterance with curly brackets around it. This can be used for utterances such as <kbd>"I want to get cart { cartName }"</kbd>.</p>
<p>As well as utterances that include the <kbd>cartName</kbd>, we will still have normal utterances such as <kbd>"I want to get my saved cart"</kbd> or <kbd>"get my cart"</kbd>. This utterance will get Lex to prompt the user for the <kbd>cartName</kbd> using the prompt we provided:</p>
<div><img src="img/407ff7c7-7f6e-4f1d-9f8b-87813caea938.png" style=""/></div>
<p>Utterances for getSavedCart</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda</h1>
                
            
            
                
<p>We start by creating a <kbd>getSavedCart</kbd> folder in our <kbd>Lambdas</kbd> directory, and inside we're going to have an <kbd>index.js</kbd> file and copy our <kbd>DB.js</kbd> and <kbd>LexResponses.js</kbd> files from our previous Lambdas. Our <kbd>index.js</kbd> file will start as normal, with us importing and initiating our <kbd>DB</kbd> and <kbd>Lex</kbd> classes and using the node 8.10 handler.  We need to make sure to run <kbd>npm install --save aws-sdk</kbd> in our folder as well. We'll never do a confirmed intent on this intent, so we only need to handle a <kbd>getSavedCart</kbd> event:</p>
<pre>const lex = require('./LexResponses');<br/>const Lex = new lex();<br/>const db = require('./DB');<br/>const DB = new db();<br/> <br/>exports.handler = async (event) =&gt; {<br/>    return handleGetSavedCart(event);<br/>}</pre>
<p>The first thing we need to do in our Lambda is to get our <kbd>userId</kbd>, <kbd>slots</kbd>, and our <kbd>cartName</kbd> slot. We can then check that we have a <kbd>cartName</kbd> or ask the user for it if we don't:</p>
<pre>const handleGetSavedCart = event =&gt; {<br/>    let { userId, currentIntent: { slots } } = event;<br/>    let { cartName } = slots;<br/> <br/>    if (!cartName) {<br/>        let message = `What name did you save your cart as?`;<br/>        let intentName = 'getSavedCart';<br/>        let slotToElicit = 'cartName';<br/>        let slots = { cartName: null };<br/>        return Lex.elicitSlot({ intentName, slots, slotToElicit, message });<br/>    }<br/>}</pre>
<p>Now that we know we have a <kbd>cartName</kbd>, we can try to get the cart with that name. If we can't get a cart with that name, then we need to ask whether they want to try another name or start a new cart. This will have to be an <kbd>elicitIntent</kbd> as they could go with either of two intents:</p>
<pre>let [err, carts] = await to(DB.getDifferent('cartName', cartName, 'shopping-cart'));<br/>if (err || !carts || !carts[0]) {
        let message = `We couldn't find a cart with that name. Would you like to try another name or start a new cart?`;<br/>        return Lex.elicitIntent({message});<br/>    }</pre>
<p>To get this <kbd>elicitIntent</kbd> to work, we need to also add the utterance of <kbd>try another name</kbd> to <kbd>getSavedCart</kbd>, and <kbd>start a new cart</kbd> to the <kbd>productFind</kbd> intent.</p>
<p><kbd>DB.getDifferent</kbd> gets an array of matching carts, which is why we're looking for <kbd>carts[0]</kbd>. We also need to extract our cart by adding this line after our error-handler:<br/></p>
<pre>let cart = carts[0];</pre>
<p>If we found a cart for that <kbd>cartName</kbd>, then we need to do two things. We need to create a cart with those items on their current <kbd>userId</kbd>, and then we need to delete the old cart. If we don't delete the old cart, there will be two carts with the same name.</p>
<p>We can create the new cart by changing the ID and updating the TTL on the old cart. We also need to store the ID of the old cart so we can delete it too:</p>
<pre>let cart = carts[0];<br/>let oldCartID = cart.ID;<br/>let newCart = { ...cart, ID: userId, TTL: Date.now() + 7 * 24 * 60 * 60 * 1000 };</pre>
<p>When we create the new cart and delete the old one, we can wrap them both in <kbd>try</kbd>/<kbd>catch</kbd> and handle any errors in the same way. If there are any errors, then we need to tell the user that we couldn't recover their cart and ask whether they want to start a new cart. This can be a <kbd>confirmIntent</kbd> on the <kbd>productFind</kbd> intent, which will start them at the beginning of the flow again.</p>
<p>If there's no error, then we can tell them that we have got their cart and ask whether they want to checkout or get another item:</p>
<pre>try {<br/>    await DB.write(userId, newCart, 'shopping-cart');<br/>    await DB.delete(oldCartID, 'shopping-cart');<br/>} catch (createErr) {<br/>    let message = `Unfortunately we couldn't recover your cart. Would you like to create a new cart?`;<br/>    let intentName = 'productFind';<br/>    let slots = { type: null, size: null, colour: null, length: null, itemNumber: null };<br/>    return Lex.confirmIntent({ intentName, slots, message });<br/>}<br/> <br/>let message = `We have got your cart for you. Would you like to checkout or add another product?`;<br/>return Lex.elicitIntent({ message });</pre>
<p>That is the end of this Lambda, so now we can build and deploy using our script and move on to testing it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>To test this, we need to test three things:</p>
<ul>
<li>No <kbd>cartName</kbd></li>
<li>A non-existent <kbd>cartName</kbd></li>
<li>Successfully getting their cart</li>
</ul>
<p>Testing no cart name is very simple. We expect to get a response asking for the cart name:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "cartName": null<br/>        }<br/>    }<br/>}</pre>
<p>To test a non-existent cart name, we need to use a name that someone isn't going to use. We expect the response to say that a cart with that name couldn't be found:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {<br/>            "cartName": "nonsense"<br/>        }<br/>    }<br/>}</pre>
<p>The last test requires us to look in the Dynamo tables again. This time, we are looking for an order with a valid name. If we completed the tests for <kbd>saveCart</kbd>, we should have a cart called <kbd>testCartSave</kbd>. This request should get a response saying that the cart has been found and asking whether they want to checkout or find another product:</p>
<pre>{<br/>    "currentIntent": {<br/>        "slots": {
            "cartName": "testCartSave"<br/>        }<br/>    }<br/>}</pre>
<p>Once all of these tests pass, we can add this Lambda as the fulfillment method for our <kbd>getSavedCart</kbd> intent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What's in my cart?</h1>
                
            
            
                
<p>This is the last intent we are going to make in this chapter. When a user asks what they have in their cart, we are going to give them a summary. This involves getting their cart and matching their item numbers up with the data in S3.</p>
<p>When we create this intent in Lex, we don't need any slotsâ€”the only information we need is their <kbd>userId</kbd>. The utterances will be questions about what is in their cart, such as <kbd>what is in my cart</kbd> and <kbd>how much have I got in my basket</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda</h1>
                
            
            
                
<p>We create a new folder called <kbd>whatsInMyCart</kbd> in our Lambda directory with an <kbd>index.js</kbd> file, as well as copying <kbd>DB.js</kbd> and <kbd>LexResponses.js</kbd> into this folder.</p>
<p>This function is going to need to access Dynamo to access the baskets and S3 to get the product data. We start the <kbd>index.js</kbd> file by requiring in <kbd>DB.js</kbd>, <kbd>LexResponses.js</kbd>, and <kbd>aws-sdk</kbd>, and then creating new <kbd>DB</kbd>, <kbd>Lex</kbd>, and <kbd>S3</kbd> class instances. We don't have any confirmations on this intent, so we can just return a <kbd>handleWhatsInMyCart</kbd> function:</p>
<pre>const lex = require('./LexResponses');<br/>const Lex = new lex();<br/>const db = require('./DB');<br/>const DB = new db();<br/>const AWS = require('aws-sdk');<br/>const s3 = new AWS.S3();<br/> <br/>exports.handler = async (event) =&gt; {<br/>    return handleWhatsInMyCart(event);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>When a user triggers this intent, the first thing we need to do is get their cart. If they don't have a cart, then we need to remind them that they can recover a saved cart or add new items to their existing cart:</p>
<pre>const handleWhatsInMyCart = async event =&gt; {<br/>    let [err, cart] = await to(DB.get('ID', event.userId, 'shopping-cart'));<br/>    if (err || !cart || cart.Items.length == 0) {<br/>        let message = `You don't appear to have a cart. If you have saved a cart then you can recover it by typing "Get my cart", or you can say "I want to buy something"`;<br/>        return Lex.elicitIntent({ message });<br/>    }<br/>}</pre>
<p>If they do have a cart, then we can reformat the items into their cart into a more manageable format. The way that items are added to the cart, multiples of the same item are just separate items in the array. We can use some array logic to convert this into an object with item numbers as keys, which point to objects containing the quantity. This code goes through each item, and if we have already added that item to the <kbd>items</kbd> object, it adds 1 to the quantity. If this is the first unit of this item, then it sets the quantity to 1:</p>
<pre>let items = {};<br/>cart.Items.map(item =&gt; {<br/>    items[item] = (items[item] &amp;&amp; items[item].quantity) ? { quantity: items[item].quantity + 1 } : { quantity: 1 };<br/>});</pre>
<p>With our object of items, we need to map this to item descriptions. For this, we need the data from S3. We can copy the same <kbd>getStock()</kbd> function that we used in <kbd>productFind</kbd> into this Lambda. If there is an error or we don't get back a list of products, we need to tell the user that we have had a problem:</p>
<pre>const [s3Err, products] = await to(getStock());<br/>if (s3Err || !products) {<br/>    let message = `Unfortunately our system has had an error.`;<br/>    Lex.close({ message });<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We have our object of items and all of our products. We can use this to expand the data in our <kbd>items</kbd> object. To do this, we can map over each of the <kbd>products</kbd> and, if the <kbd>itemNumber</kbd> is in our <kbd>items</kbd> object, we add those details to that item's data:</p>
<pre>products.forEach(product =&gt; {<br/>    if (items[product.itemNumber]){<br/>        items[product.itemNumber] = { ...product, ...items[product.itemNumber]};<br/>    }<br/>});</pre>
<p>We have an object that contains all the data we need. We can map over this and create a string describing the item and quantity. We can use the <kbd>Object.values()</kbd> method, which turns an object into an array that contains the values. Here is an example:</p>
<pre>let data = {<br/>    name: { firstName: 'Tom', lastName: 'Jones' },<br/>    age: 25,<br/>    height: '178 cm'<br/>};<br/> <br/>console.log(Object.values(data));<br/>// [ { firstName: 'Tom', lastName: 'Jones' }, 25 , '178cm' ]</pre>
<p>We can use this to get the data for each of the items to create <kbd>itemStrings</kbd>, such as <kbd>2 blue jackets</kbd> or <kbd>1 long, black pair of trousers</kbd>. We can use the <kbd>units()</kbd> function that we created in <kbd>productFind</kbd> to deal with the units and with trousers:</p>
<pre>let itemStrings = Object.values(items).map(item =&gt; {<br/>    let { type, size, colour, length, quantity } = item;<br/>    return `${quantity} ${size}, ${length ? `${length}, ` : ''}${colour} ${units(type, quantity)}`;<br/>});</pre>
<p>We can now join this array of item strings together into a one-cart summary. If there is one item, we can just say that item. Two items mean we need to add <kbd>and</kbd> between them, and we need to separate three or more items with commas:</p>
<pre>let message = `You have ${itemStrings.slice(0,-1).join(', ')}${itemStrings.length &gt; 1 ? ` and `: ""}${itemStrings.pop()} in your cart. Would you like to checkout, save your cart or add another item?`;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>With our message created, all we have left to do is to return our <kbd>Lex</kbd> response, which will be an <kbd>elicitIntent</kbd> response:</p>
<pre>return Lex.elicitIntent({ message });</pre>
<p>With the Lambda completed, we need to build and deploy it, and move on to testing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p>There are only two situations to test for in this Lambda:</p>
<ul>
<li>No cart</li>
<li>Successful cart lookup</li>
</ul>
<p>To test for no cart, we can provide a non-existent <kbd>userId</kbd>. We should get a response telling us that our cart can't be found:</p>
<pre>{<br/>    "userId": "nonsense"<br/>}</pre>
<p>To test a successful cart lookup, we need to go into our Dynamo table and find a cart with items in it. We should get a nicely formatted sentence describing the items in the cart and be asked whether we want to checkout, save, or add another item:</p>
<pre>{<br/>    "userId": ## valid userID<br/>}</pre>
<p>With the testing complete, we can go into the Lex bot and change the fulfilment for the <kbd>whatsInMyCart</kbd> intent to our <kbd>whatsInMyCart</kbd> Lambda.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the whole bot</h1>
                
            
            
                
<p>Now that we have created all of the Lambdas and tested that they all work, we can put it all together and build our chatbot. On the Lex console for this chatbot, go through each of the intents and make sure that they are all being fulfilled using the correct Lambda, and then we can click Build at the top of the page.</p>
<p>Once it has finished building, we can start testing it out. We can start with finding a product. Typing <kbd>I want to buy a shirt</kbd> starts the <kbd>productFind</kbd> intent flow, and we can find the stock levels of the found item:</p>
<div><img src="img/4eb00e4a-aec2-4378-8528-73d245cd0128.png" style=""/></div>
<p>Testing productFind</p>
<p>When we get shown a product, we should also be asked whether we want to add this to our cart. No matter our answer, we should then be asked whether we want to checkout, add another item, or save our cart. We need to try each of these methods, starting with adding another item:</p>
<div><img src="img/5c22027a-59e2-489c-b4d2-35d82975464b.png" style=""/></div>
<p>Adding another item to the cart</p>
<p>As expected, we are sent to the start of the <kbd>productFind</kbd> flow. Having gone through that flow but not added a new item to our cart, we can now test saving our cart. When we get to the end of a product find, we can say that we want to save our cart. When we provide a cart name, we are told that our cart has been saved:</p>
<div><img src="img/669206aa-f872-4b57-9d48-47213b2fff7d.png" style=""/></div>
<p>Testing saveCart</p>
<p>To test recovering a cart, we can clear the chat in Lex and ask to <kbd>get my saved cart</kbd><em>.</em> We should be asked to enter our cart name and, if found, it will be recovered for us:</p>
<div><img src="img/3e9d9c3b-cd8c-4b07-a4f6-23d6bf3c7905.png" style=""/></div>
<p>Testing getSavedCart</p>
<p>Now that we've got our saved cart back, we might want to check what we put in it. All we need to say is <kbd>what is in my cart</kbd> and we should get a summary of our products. As we only added the first product, we should have just one item:</p>
<div><img src="img/da3e9bf7-ec9e-4ceb-9503-6eed7cbeb92d.png" style=""/></div>
<p>Testing whatsInMyCart</p>
<p>The last thing to test is checking out. With at least one item in our basket, we can ask to checkout. We should be asked for an address and then be told that our order has been placed:</p>
<div><img src="img/0d7353d5-9385-4f20-8ad2-11af84245a7a.png" style=""/></div>
<p>Testing checkout</p>
<p>With all of that tested, we have completed our shopping chatbot. If you've had any problems with these tests, go back and make sure that all of your code is correct and that Lex has been set up correctly. If you are having further issues, there is a set of debugging tips at the end of this book. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has covered a lot. We started by designing a complex chatbot flow with multiple sub-flows. We then built these flows into a set of intents, which allow a user to go through the full process, or to do part of the process and return later. This meant we need to trigger intents directly from other intents, pre-populating some of the slots and using <em>confirmation intents</em> to change from one intent to another. We've also learned how to use DynamoDB tables to store and retrieve data about the progress of the users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the main difference between a complex flow and a simple flow?</li>
<li>How can we make complex flow diagrams easier to understand?</li>
<li>What are the five types of Lex fulfillment?</li>
<li>What is the name of the part of the AWS SDK that we can use to access DynamoDB tables?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>If you want to learn more about the different ways to interact with Dynamo, I would recommend looking through the DocumentClient documentation. You can learn how to implement scans, queries, and batch processing. You can read that documentation at <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html">https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html</a>.<a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#update-property"/></p>


            

            
        
    </body></html>