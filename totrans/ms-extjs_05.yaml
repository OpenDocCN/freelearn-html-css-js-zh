- en: Chapter 5. Advanced Dynamic Menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have the login capability that we implemented throughout [Chapter
    3](ch03.html "Chapter 3. The Login Page"), *The Login Page*, and the base of the
    application, that we implemented in [Chapter 4](ch04.html "Chapter 4. The Logout
    and Multilingual Capabilities"), *The Logout and Multilingual Capabilities*. In
    the base of our application there is one missing piece, which is the menu. So
    the next thing we are going to develop is the dynamic menu.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has been authenticated, we are going to display the base screen
    of the application, which consists of a Viewport with a Border layout. On the
    left-hand side of the Viewport, we are going to display a menu. This menu will
    be dynamic, and the items that will be displayed on the menu depend on the permissions
    that the user has, which is why we call it a dynamic menu.
  prefs: []
  type: TYPE_NORMAL
- en: One of the options is to render all the screens of the system and then, depending
    on the user roles, we can hide or show them. However, this is not the approach
    we are going to use in this book. We are going to render and display only the
    screens the user has access to. The approach we are going to use is to dynamically
    render a menu according to the user entitlements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this chapter, we will learn how to display a dynamic menu using different
    Ext JS components and layouts (that we have not covered yet). To summarize, in
    this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic menu with the Accordion layout and TreePanel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Model association to load the data from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the dynamic menu on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a menu item dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the MVC architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the dynamic menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So the first component that we are going to implement in this chapter is the
    dynamic menu. We could use only a TreePanel to display the menu, but we do like
    a challenge and we want to offer the best experience to the user. So, we are going
    to implement a dynamic menu using the Accordion layout and TreePanels, which results
    in a more advanced dynamic menu.
  prefs: []
  type: TYPE_NORMAL
- en: Our system consists of modules, and each module has subitems, which are the
    screens of our system. An accordion panel will represent the menu itself with
    all the modules; this way, the user can expand to see the options of each module
    at a time. And for the options of each module, we will use a TreePanel; each option
    of the menu will be a node from the TreePanel.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at the end of this topic, we will have a dynamic menu like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the dynamic menu](img/0457OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we get started with the dynamic menu, let's take a quick look at how
    the Ext JS TreePanel component works and how the Accordion layout works. Understanding
    these two concepts first will make it easier to understand how the dynamic menu
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS TreePanel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A TreePanel is the perfect component to display hierarchical data in an application.
    This is the reason why we will use it to display the menu. The following image
    exemplifies a TreePanel and its pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ext JS TreePanel](img/0457OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*, the TreePanel extends from the `Ext.panel.Table` class,
    and so does the GridPanel. The `Ext.panel.Table` class extends from the `Panel`
    class. All the `Panel` classes have a *shell*, which is the panel itself, which
    allows us to set a title and add toolbars and also add child items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The piece that is responsible for displaying the data is called the View, which
    is of the type `Ext.view.View`, and it is placed inside the `Panel` container.
    There are two ways that we can set data to a TreePanel: predefined using the `root`
    configuration or using a Store.'
  prefs: []
  type: TYPE_NORMAL
- en: The Store behaves as our **Data Access Object** (**DAO**). In this example,
    we will load data from the server, so we will use a Store. The Store loads a collection
    of objects that we call `Model` (`Ext.data.Model`). In the case of the TreePanel,
    these models are decorated with `NodeInterface` (`Ext.data.NodeInterface`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the decorator pattern, please access [http://en.wikipedia.org/wiki/Decorator_pattern](http://en.wikipedia.org/wiki/Decorator_pattern).
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to show or hide `Root` of the TreePanel. In the preceding image,
    `Root` is visible (the node called `Root`).
  prefs: []
  type: TYPE_NORMAL
- en: Each **Node** of a TreePanel can have **Children** (in as many nested levels
    as needed). When a **Node** does not have any child, we call it a **Leaf**.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive more into the TreePanel when we implement the menu later in this
    chapter. For now, these are the concepts that we need to be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Accordion layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Accordion layout manages multiple panels in an expandable accordion style
    such that by default only one panel can be expanded at any given time (this can
    be changed by setting the `multi` configuration as true). Only Ext panels and
    all subclasses of `Ext.panel.Panel` can be used in an Accordion layout container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could implement the dynamic menu using only a TreePanel, but we do like
    a challenge! Besides, from the UI point of view, having the modules separated
    by an Accordion layout container looks prettier than a simple TreePanel, as we
    can see in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accordion layout](img/0457OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The menu itself is a panel that uses the Accordion layout. A TreePanel represents
    each module of the menu (note that you can expand or collapse each module due
    the capabilities of the Accordion layout). We are going to load the required data
    to display this menu from the server, and we are going to load the data from the
    database according to the user entitlements. That is why we call it a dynamic
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important note on this approach: we are creating a TreePanel for each module
    for navigation. Creating many objects at the same time has some disadvantages,
    such as memory consumption. We can also create a single TreePanel and display
    all the modules as nodes with children. For more information about JavaScript,
    and memory consumption and its problems, please read [https://developer.chrome.com/devtools/docs/javascript-memory-profiling](https://developer.chrome.com/devtools/docs/javascript-memory-profiling).'
  prefs: []
  type: TYPE_NORMAL
- en: So now that we are familiar with all the concepts, we can start with the menu!
  prefs: []
  type: TYPE_NORMAL
- en: The database model – groups, menus, and permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already created the `user` and `groups` tables. To store the information
    of the menu and its options and also the permission that each group has, we need
    to create two more tables: the `menu` and `permissions` tables, as shown by the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The database model – groups, menus, and permissions](img/0457OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the `menu` table, we will store all the `menu` information. As each option
    of the `menu` table will be a node of a TreePanel, we will store the information
    in a way that represents a TreePanel. So, we have an `id` field to identify the
    node, a `text` field as the text that is going to be displayed on the node (in
    our case, we will store the attribute of the translations file since we are using
    a multilingual capability), `iconCls` representing the `css` class that will be
    used to display the icon for each node, `className` representing the `alias` (`xtype`)
    of the class that we are going to instantiate dynamically and open at the central
    tab panel of the application, and finally the `menu_id` field representing the
    `root` node (if it has one—the module nodes will not have a `menu_id` field, but
    the module items will).
  prefs: []
  type: TYPE_NORMAL
- en: Then, as the `menu` table has an **N:N** relationship with the `groups` table,
    we need to create the `permissions` table that will represent this relationship.
    We will learn more about how to assign a user to a group in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not familiar with database relationships, the following link provides
    a good tutorial: [http://goo.gl/hXRsPx](http://goo.gl/hXRsPx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So to create the new table, we will use the following SQL script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And we also need to populate the `menu` and `permissions` tables with some
    data. We can use the following SQL code to create all the modules and menu options
    that we are going to develop throughout this book. We are also going to grant
    the user we created in the preceding chapter access to all menu options, as this
    user is *admin*. Here''s the code that encapsulates what we discussed in this
    paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this book, we are going to create the screens of our application,
    and we will need to run some update queries. For now, whenever we click on any
    menu option, the application is going to open an empty panel so that we can test
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `className` is set to `Panel` for all options. We will update the
    records in the database accordingly throughout the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic menu – an MVC approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the MVC architecture concept in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*, already, but let's do a quick overview one more
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The Model represents the data we want to manipulate. It is a representation
    of the tables we have in the database. A Model instance represents a single data
    row of a table. The Store will be responsible for loading the collection of models
    from the server. A Store is usually bound to a View. A View is the component with
    which the user is seeing the screen (we have created a few so far; for example,
    a GridPanel provides a visual representation of data found in a Store.). And the
    Controller is what keeps everything together. The Controller will capture the
    events from the View and will execute some logic based on it. The Controller can
    also redirect the logic to the Model or the Store, making all the pieces communicate
    with each other, behaving like a mediator.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we used the MVVM architecture. We saw an example using
    the View and ViewController only and an example with View, ViewModel (predefined
    data), and ViewController. We have also learned that the ViewController is bound
    to its View's component life cycle, which means it is created when the View is
    created, and it is destroyed when the View is destroyed. With the MVC approach,
    the Controllers are alive as long as the application is running in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: While in the ViewController, we can easily retrieve the view's reference or
    any of its children's references as well (using the `reference` configuration),
    in the Controller, we need to define what events from what components we want
    to listen to, and there is another approach to retrieve the components references.
  prefs: []
  type: TYPE_NORMAL
- en: MVC is not better than MVVM or vice versa. It depends on the application, the
    type of screen you are developing, the use case, and also your personal preference
    (why not?). That is why we are going to use all the possibilities in this book
    in the examples. This way, you can learn all of them (MVVM, MVC, and hybrid architecture)
    and use the one you like the most!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with the MVC architecture, we usually create the models first.
  prefs: []
  type: TYPE_NORMAL
- en: So first, we will create a class named `Packt.model.menu.Accordion`. To do that,
    we need to create the directory `app/model/menu` and also create a file named
    `Accordion.js`. With this Model, we will be able to represent each of the accordion
    panels we want to create (that will be represented by a TreePanel). So, for each
    module (or TreePanel), we want to set a title and also an icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the implementation of the `Packt.model.menu.Accordion`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The main configuration for a Model is called `fields` (`#1`). In this configuration,
    we can declare all the `fields` for the Model (which would be similar to the columns
    of a table from the database). The class `Ext.data.field.Field` represents each
    field. Each field can have `name` and it can also have `type`. The available types
    are `string`, `int`, `number`, `boolean`, `date`, and `auto` (when no type is
    defined, and in this case, the field does not try to convert the value to any
    of the default types). The fields `text` and `iconCls` have the type `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Model needs a field that works as its unique identifier. In this case,
    we are defining the field `id` (`#2`) as our unique field. If the unique identifier
    of the Model is not called `id`, we need to configure this information in the
    Model as well by using the `idProperty` configuration. For example, if our ID
    was named `accordionId`, we would declare it normally, and inside the Model, we
    would add `idProperty: ''accordionId''` so that the Model would know that the
    field is the identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Model` and `Field` classes also have other features. Please refer to them
    to see all their capabilities in the Ext JS documentation, which is very complete
    and full of examples. Please take a look at [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model)
    and [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a Model to represent the menu option, which consists of the Tree
    nodes of the TreePanel. To do so, we will declare the following Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `TreeNode` Model declared three fields present in the `NodeInterface` class,
    which are `id`, `text`, and `iconCls`. The `className` value is going to be used
    as `xtype` to instantiate the class that represents the screen of the menu option.
    We will talk more about this later. Then, we have the `parent_id` field. In the
    JSON, when we load data from the server, we will have the `menu_id` property instead
    of `parent_id`. We can use the `mapping` configuration to make this link (`#1`).
    This is nice because our Ext JS models do not need to be exactly like what is
    coming from the server (but it makes our life easier if they are the same).
  prefs: []
  type: TYPE_NORMAL
- en: Working with the hasMany association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two different ways of working with associations in Ext JS. The first
    one is using `Ext.data.association.Association` introduced in Ext JS 4\. And the
    second one is using the `reference` configuration introduced in Ext JS 5\. Ext
    JS 5 maintains backwards compatibility with the Model associations from Ext JS
    4, although these Ext JS 4 features are marked as legacy code in the sources.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to use the hasMany association introduced in Ext
    JS 4\. Later in this book, we will see another example using `reference`, and
    we will be able to compare the difference and choose when to use one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the hasMany association, inside the `Accordion` Model, we first need
    to add the `hasMany` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This means that a new field named `items` (`#1`) will be created for the `Accordion`
    Model. For each instance of the `Accordion` Model, a method named `items()` will
    also be available to retrieve the `TreeNode` Model instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot forget to add the `requires` declaration to the beginning of the
    `Accordion` Model as well, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating the store-loading menu from the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the Model defined, we can move on and create the Store. We
    will create a new class named `Packt.store.Menu`, so we need to create a new file
    named `Menu.js` under the `app/store` folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important things we need to declare in the Store: the `model`
    and the `proxy` properties. The `model` tells the Store what type of data the
    Store needs to load from the server (or client storages), and the `proxy` tells
    the Store how and where to get the data.'
  prefs: []
  type: TYPE_NORMAL
- en: This Store is going to use the model `Packt.model.` (`#2`). Instead of using
    the `model` configuration, it is also possible to declare the fields directly
    inside the Store using the `fields` configuration (it would be a copy from `fields`
    from the Model). In this case, the Store would use a so-called "anonymous model".
  prefs: []
  type: TYPE_NORMAL
- en: 'The Store is going to communicate with the server through the proxy using an
    Ajax request to the provided `url`. The `reader` (`#5`) tells the proxy how to
    decode the information from the server and transform it into a collection of the
    specified models. This Store is expecting a JSON format with `rootProperty` (known
    in Ext JS 4 as `root`) named `data`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we declare the associations in the previous topic, the Store knows how
    to decode a nested JSON and create the respective Model instances.
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, exceptions can occur! For this reason, we can add `exception`
    `listener` (`#6`) in `proxy` so that we can display an error message to the user.
    As we are using the `Util` class we created, we also need to add this class in
    the `requires` declaration (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: We can listen to events from views and stores in the Controller; however, the
    Store does not have any exception event. For this reason, `listener` needs to
    be added directly to `proxy`. This is an optional step, but if an error occurs,
    nothing will happen in the UI (Ext JS will output an error message in the browser's
    console, but users do not use the application with the developer tools console
    opened). That is why it is a good practice to have `exception listener` declared
    inside every proxy we use. We will develop a more elegant approach, but for now,
    we will use it like this.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of declaring `proxy` inside the Store, we can declare it inside the
    Model. You can declare `proxy` in the place of your preference. However, if you
    declare `proxy` on the Model and on the Store, when using the Store's `sync()`
    method, it will call the `proxy` instance declared on the Store; else the Model's
    `proxy` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the data format that we need to retrieve from the server, let's
    implement it!
  prefs: []
  type: TYPE_NORMAL
- en: Handling the dynamic menu on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we declared on the `Packt.store.Menu` Store, we need to create a new file
    named `menu/list.php` under the `php` folder. The following is the programming
    logic that we need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the user that is logged in from the session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a connection with the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the menu `id` instances from the `permission` table so that we know what
    permissions the user from the session has.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the modules that the user has permission to access—`menu_id` is `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each module, select the nodes (menu options) that the user has access to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode the result in the JSON format and wrap it in the `data` root (as specified
    by the Store).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So let''s get our hands on the code. The following code was organized in functions,
    so we can organize the code exactly as listed in the preceding set of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As the code was organized in functions, let's create another file called `menuFunction.php`
    inside the `php/menu` folder as well. As we are going to code the functions inside
    this file, we need to require this file inside `menu/list.php` (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will get the user that is logged in to the session (`#2`). So we will
    get the entitlements for the user that is logged in, increasing the security a
    little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will do as listed. For each function to which we open the connection
    with the database, we will retrieve the user's permissions (`#4`), then we will
    retrieve the modules the user has permission to access (`#5`), and then based
    on the module, we retrieve the menu options the user also has access to (`#6`).
  prefs: []
  type: TYPE_NORMAL
- en: At last, we will encode the result array in the JSON format (`#7`), and it is
    going to produce the JSON listed in the preceding topic.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the user permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s dive into each function declared inside the `menuFunctions.php`
    file. The first one is the function used to retrieve the user''s permissions as
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we will open the connection with the database (`#8`), and then we prepare
    the SQL query to get the `id` instances from the `menu` table that the user has
    access to (`#9`). We are using `JOIN` because the only information we have is
    `username`, and we need to pass through the `groups` table to get to the `permissions`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: We execute the SQL query (`#10`), and we create an array with the menu `id`
    that the user has permission to use (`#11`).
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we free the result set (`#12`), close the database connection (`#13`),
    and we return the `permissions` array (`#14`).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the modules the user is entitled to
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the function that will retrieve the modules based
    on users'' permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To be able to retrieve the modules the user has access to, we need to know what
    modules (records from the `menu` table that do not have a `menu_id` parent menu)
    the user has permission to access. In our SQL query (`#16`), there is an `IN`
    clause to fetch all modules. As we have the `permissions` array, we can use the
    `join` PHP function (`#15`) that will return a string with all the array values
    separated by the "`,`" delimiter we informed. Then, we concatenate with "`( )`"
    and we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is executing the SQL query (`#17`), and with the results from
    the database, we create an array with the `modules` that the user has access to,
    and at the end of the function, we return this information (`#18`).
  prefs: []
  type: TYPE_NORMAL
- en: The `modules` variable represents the `Accordion Model` class we created.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the menu options based on modules and permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After we have retrieved the `permissions` and `modules` the user has access
    to, it is time to retrieve the last piece to create the data for the dynamic menu,
    which is retrieving the menu options. The code is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For each `module` that the user has access to (`#2`), we will retrieve the menu
    options (`#3`). To do so, we need the ID of the module and also the `permissions`
    (`#1`). As each module might have several menu options, a user might not have
    permission to access all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we execute the query (`#4`) and retrieve the number of records returned
    by the database (`#5`). If this number is positive (`#6`), we create the `items`
    array ((`#7`), the `hasMany` association) and we fetch each item adding it to
    the `module['items']` array (`#8`).
  prefs: []
  type: TYPE_NORMAL
- en: Each `$item` variable inside `module['items']` represents the `TreeNode` model.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of it, we add `$item` to the `result` variable (`#9`) and return
    it (`#10`). This `result` variable is the one that will be wrapped inside the
    `data` root and encoded as JSON to be returned to Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: The database for the `menu` fits perfectly to what Ext JS needs. We designed
    the `menu` table according to Ext JS expectations, and in a way that would be
    easier for us to retrieve the information. The preceding server-side code also
    fits perfectly to what Ext JS needs. Unless we have the chance to design the database
    ourselves in a project that we are starting from scratch, we will probably have
    a different design; therefore, the server-side code to retrieve the information
    will be a little different too. There is no problem at all. It does not matter
    how the database looks or the server-side code you need to write to retrieve the
    information. However, Ext JS is expecting a specific format to be sent back to
    the frontend code, and unfortunately, we need to send the information in this
    specific format (the JSON listed before). If the information we retrieved from
    the database is not in the format that Ext JS expects (the same format as our
    preceding code), all we need to do is parse and transform it, which means there
    will be an extra step in our server-side code before we send it back to Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the menu with the Accordion layout and TreePanel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can go back to the Ext JS code and start implementing the dynamic menu View
    component now. First, we need to create a new folder under `app/view/menu` and
    create a new file named `Accordion.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This class is going to be a panel and it is going to wrap the TreePanels that
    will be the menus. It is going to use the Accordion layout (`#3`); this way, the
    user can expand or collapse the desired module. As the default behavior, all modules
    will be expanded (`#4`). If only the first module should be expanded at a time,
    we can comment line `#4`.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to use this class in the `west` region of the `Main` class,
    we are going to declare `xtype` (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Be very careful when declaring `xtype`. Always remember to create a unique
    `xtype` and not any that is already being used by Ext JS components. For example,
    let''s say there is an `xtype` property you might want to use, but if we go to
    the documentation and use the quick search, we will see this `xtype` property
    is already in use by Ext JS, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the menu with the Accordion layout and TreePanel](img/0457OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As this panel will be rendered in the `west` region, we need to set a `width`
    (`#2`)—remember that whenever we are using the Border layout, we need to specify
    a `width` for the `west` and `east` regions. We will also allow the user to resize
    the `west` region (`#4`) and collapse (`#3`) so that there is more space for the
    screen in the center.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, to prettify, we are declaring a Font Awesome icon (`#5`) and a `title`
    property (`#6`). We cannot forget to add the following entry in the `locale/en.js`
    file and its translations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get the Spanish and Portuguese translations by downloading the source
    code bundle from this book or downloading from the GitHub repository [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a TreePanel to represent each module. We will create
    a new class named `Packt.view.menu.Tree`; therefore, we need to create a new file
    named `Tree.js` under `app/view/menu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This class is a TreePanel. We do not want a `border` property for our module,
    and the `root` property will not be visible. As we can see, we are not setting
    many attributes. We will set the missing information dynamically on the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is going back to the `Main` class and adding `Accordion` to the
    `west` region. To do so, first we cannot forget to add the class `''Packt.view.menu.Accordion''`
    to `requires` and change the `west` region code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We removed all the configurations (`width`, `split`) and replaced `xtype` with
    `menu.Accordion`. When we execute the application, we will be able to see the
    `west` region with a panel now. The creation of the dynamic menu is pending though,
    and we will take care of it next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the menu Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have all the views, models, and stores and also have the server-side
    covered. Now the only thing left is to implement the Controller, which is where
    all the magic will happen. So, let''s go ahead and create a new file named `Menu.js`
    under the `app/controller` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the MVC approach, all controllers are created inside the `app/controller`
    folder, while in the MVVM approach, ViewController is created in the same folder
    as the View.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` function is called when the application boots, and it is called before
    the application's `launch` function is. We can use this function to execute any
    logic before the first View (`Login` or Viewport) is created. Inside this function
    is also the place where we want to set up the events we want this Controller to
    listen to using the `control` function (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: In this Controller, we want to listen to two events. The first one is we want
    to render the dynamic menu (`#4`) when the Viewport (`Main` class) has been rendered.
    The second one is whenever the user clicks on a menu option (a node from the TreePanel—`#2`),
    we want to open the screen inside the center panel (#3).
  prefs: []
  type: TYPE_NORMAL
- en: 'To listen to an event inside the `control` method, we need to define three
    things: the selector, the event we want the Controller to listen to, and the method
    to be executed. It has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finding the selector is the most challenging part. The scope in this case is
    not the View as in the ViewController, but the application. For selectors, we
    usually use the `xtype` component. It helps when it is an `xtype` component we
    created for the application and not an Ext JS `xtype` such as `'tree'`; for example,
    `'menutree'` is much better because we narrow down the possibilities (there might
    be several TreePanels within the application, but we know that only the TreePanels
    from the dynamic menu have `menutree` as `xtype`). We have to remember that if
    we use the selector `'tree'` (`xtype` for TreePanel), the Controller will listen
    to the event from all TreePanels of the application, so it is good to be as specific
    as we can be.
  prefs: []
  type: TYPE_NORMAL
- en: We can listen to as many events from a selector as we want to. We simply need
    to separate the events by a "`,`".
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s implement the `renderDynamicMenu` method first. We use
    `mainmenu` as the selector. This is the `xtype` component for the `view.menu.Accordion`
    class, which is being rendered in the `west` region of the `Main` class (Viewport).
    So, when this component is rendered, the Controller is going to execute the `renderDynamicMenu`
    method. Let''s declare this method inside the `Menu` Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can always start the implementation of an event listener in the Controller
    by adding a `console.log` or `alert` message to make sure the method is being
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to always go to the documentation to verify the parameters that are
    being passed to the event so that we can declare them. For the `render` event,
    it is usually the component itself and `options`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare `onTreePanelItemClick` as well so that we can test this Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The method signature is enough so that we do not get any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add this Controller in `Application.js` as well. So, go back to
    `Application.js` and add the highlighted code shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the application, we will get the output as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the menu Controller](img/0457OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that it is working as we expect. Do not worry about the other warning
    messages; we will take care of them later in this book (the important thing is
    not getting error messages).
  prefs: []
  type: TYPE_NORMAL
- en: So let's go ahead and add the required business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the menu from nested JSON (the hasMany association)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to add the logic that will be responsible for creating the dynamic
    menu with the information that will be received from the server. We will add the
    following code inside the `renderDynamicMenu` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we are going to do is create an empty array so that we can add
    all the modules to it (`#1`). As we are going to make a request to the server
    and as initially the menu in the `west` region is going to be empty, it is nice
    to add a loading message (`#2`) just in case there is any delay with the server
    response (*Ajax is asynchronous*). The `view` was passed as a parameter to the
    event and is a reference to the `Packt.view.menu.Accordion` class instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to load the `Menu` Store (`#3`), which is responsible for loading
    the nested JSON from the server (`#1`). Note that we are using `this.getMenuStore()`
    to retrieve the Store, which means this is a method from the Controller. We need
    to declare the `menu` Store inside the `stores` configuration in the Controller
    so that it will generate this method for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there is no need to declare the complete name of the Store—only
    what is after `'Packt.store'`. Because of the MVC architecture, Ext JS knows that
    it needs to look for a file named `Menu.js` inside the `app/store` folder. As
    the name of the Store is `Menu`, the Controller will generate a method named `get`
    + `Menu` + `Store` (`getMenuStore`) once the Store is loaded (that is why we are
    going to handle the creation of the dynamic menu inside the load callback). For
    each `record` returned from the Store (`#4`), we will create a TreePanel (`Packt.view.menu.Tree`—`#5`)
    to represent each module. We will set the `title` property (getting the `title`
    property from the locale file `(#6`). In the database, we will store the key from
    the `en.js` file in the column `text` and set `iconCls` (`#7`) for it to look
    prettier (a Font Awesome icon).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ext.create or Ext.widget**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Getting Started"), *Getting Started*, when
    we instantiated a class for the first time in this book, we discussed the options
    we can use when we need to instantiate a `component` class. Just to remind you,
    we can use `Ext.create` passing the complete name of the class as an argument,
    or we can use `Ext.widget` passing the class alias as an argument (there are other
    ways as well, but these two are more commonly used). It is a matter of preference,
    but you can use any of the ways we mentioned in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: So, with this code, we are able to display each TreePanel representing each
    of the modules (with no menu option). The next step is getting the data to display
    inside the TreePanel. This data is available in the JSON already through the `hasMany`
    association we configured. Because of the `hasMany` association, a method named
    `items` (`name` of the association we configured) will be created for each Model
    instance inside the Store. The `items` method returns a Store with the `hasMany`
    data in it (`#8`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are not sure whether the method was created or not, we can always inspect
    the Model instance in the console. For example, if we output `console.log(this)`
    inside the `load` callback, we will get the Store outputted in the browser''s
    console. Inspect the `data` configuration, and inside the `data` configuration,
    we will find `items`, which contains the Model collection as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering the menu from nested JSON (the hasMany association)](img/0457OT_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For each `Packt.model.menu.TreeNode` Model instance from the Store (`#9` and
    `#10`), we will push a new node (`#11`) into an array. When adding the new node,
    we set the `text` and `leaf` (`#12`) that are properties from the `NodeInterface`
    class. We are adding `id` and `className` that are not part of the `NodeInterface`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: To add all the nodes created, we need access to the `Root` node of the TreePanel.
    As `Root` is also a node (decorated with the `NodeInterface` class), it has a
    method called `appendChild`, which can be used to append nodes to a specific node
    (in this case, `Root`). So, we add all the nodes we created at once (`#14`).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid many changes in the DOM, which is not a good practice, we are going
    to create an array with all the menus we created (`#15`). And then, we will add
    all the menus at once (`#16`) to the `Accordion` panel (this will avoid browser
    reflow).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Minimizing browser reflow is a technique used to increase performance. We could
    do the insertions inside the loops, but this would increase DOM manipulation,
    which is very expensive. With simple changes in the code to add whatever needs
    to be added at once, we can increase the performance a little bit. For more information,
    please visit [https://developers.google.com/speed/articles/reflow](https://developers.google.com/speed/articles/reflow).
  prefs: []
  type: TYPE_NORMAL
- en: At last, we remove the `mask` from the `Accordion` menu (`#17`).
  prefs: []
  type: TYPE_NORMAL
- en: If we execute the code, the menu will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Using glyphs in TreePanel – working with overrides
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There was a piece from the code that we did not cover in the previous topic,
    which is line `#13`, the `glyph` configuration in the node. We know that we can
    use icon fonts, such as Font Awesome, with Ext JS, but the support is still limited.
    It is not possible to use Font Awesome icons in TreePanel nodes. However, there
    is an override we can use that will allow us to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first time we are mentioning the term **glyph** in this book. It
    is basically the same thing as the font icon we have been using until now, but
    it has an alternative configuration for it. For example, we used a key icon in
    the `Login` class, and we set `iconCls` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have used the `glyph` configuration instead as an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code could also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But we need to configure the `glyphFontFamily` configuration inside the `Packt.Application`
    class in `Application.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And then, we can remove `'@FontAwesome'` from the `glyph` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Font Awesome provides a cheat sheet with the CSS names and glyph codes at [http://fortawesome.github.io/Font-Awesome/cheatsheet/](http://fortawesome.github.io/Font-Awesome/cheatsheet/).
  prefs: []
  type: TYPE_NORMAL
- en: The Font Awesome `iconCls` is not going to work for the Tree nodes, but as mentioned
    before, we can apply an override. An override is a way of changing the behavior
    of the Ext JS class. It would be similar to modifying the prototype of a JavaScript
    object—the new behavior is applied to all the instances of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Ext JS is open source, we should avoid changing the source code
    directly (despite the open source code philosophy). Changing the source code can
    be an issue when upgrading the framework version in the future. Using overrides
    is more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The override we are going to use can be found at [http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels](http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create the override inside the file `app/overrides/tree/ColumnOverride.js`.
    We cannot forget to change the name of the override to `Packt.overrides.tree.ColumnOverride`
    (the first line of code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside `Application.js`, we are going to add the following code to make
    sure it is loaded when the application is loaded and the override is applied,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can also add this `require` declaration inside the `Packt.view.menu.Tree`
    class to remind us that we are using an override as well, but it is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `menu` table looks like at this moment. The modules have the
    Font Awesome CSS, and the menu options have the glyph codes (`iconCls` column),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using glyphs in TreePanel – working with overrides](img/0457OT_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use only the glyph codes throughout the application. We are using both
    to show it is possible to use both. From now on, you can use the approach you
    prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Menu locale support
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We also need to add the keys to the `en.js` file (and other locale files as
    well). For the menu, these are the entries needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the keys are the same entries as the `text` column from the `menu` table.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a menu item programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the menu is rendered, the user will be able to select an option from
    it. The logic behind the method is: when the user selects an option from the menu
    we need to verify that the tab has already been created on the tab panel. If yes,
    we do not need to create it again; we only need to select the tab on the tab panel
    and make it active. If not, then we need to instantiate the screen selected by
    the user. To do so, the Controller will execute the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to get the reference of the tab panel (`#1`). We are using `this.getMainPanel()`,
    which was created by the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways of getting object references inside Controller methods.
    The first one is using the parameters passed to the method. The second one is
    using the `ComponentQuery` (that we have not discussed yet), and the third one
    is using `refs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we are going to use `refs`. We need to add the following
    code inside the Controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can configure the selector we want the Controller to search for and the name
    of the reference. In this case, the Controller will create a method called `get`
    + `mainPanel` (in the `ref` name, the first letter becomes a capital letter) resulting
    in `getMainPanel`. This is equivalent to `reference` used by the ViewController.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to verify that the selected menu option was already created (`#2`),
    and we will do it comparing the tab `title` with the `text` configuration of the
    selected node (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: If it is not a new tab, we will add it to the tab panel, passing as an instance
    to the `add` method (`#5`). So we will get the `xtype` configuration of the component
    we are going to add from the node `className` (`#6`), and the tab can be `closed`
    (`#7`); it will have the same `glyph` as its node (`#8`) and will also have the
    same `title` as the node (`#9`—menu option).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will set it as the active tab. If the screen is already rendered, we
    will only change the `active` tab to the screen that the user selected from the
    menu (`#10`).
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic menu functionality is now complete!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement an advanced dynamic menu using
    an Accordion layout and also TreePanels for each module of the application. We
    learned how to handle the dynamic logic on the sever side and also how to handle
    its return on the Ext JS side loading a Store to build the menu dynamically. And
    finally, we have also learned how to open an item from the menu programmatically
    and display it on the center component of the application. We also used the MVC
    architecture for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to implement screens to list, create,
    and update users and also how to assign a group to the user.
  prefs: []
  type: TYPE_NORMAL
