- en: Chapter 5. Advanced Dynamic Menu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have the login capability that we implemented throughout [Chapter
    3](ch03.html "Chapter 3. The Login Page"), *The Login Page*, and the base of the
    application, that we implemented in [Chapter 4](ch04.html "Chapter 4. The Logout
    and Multilingual Capabilities"), *The Logout and Multilingual Capabilities*. In
    the base of our application there is one missing piece, which is the menu. So
    the next thing we are going to develop is the dynamic menu.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has been authenticated, we are going to display the base screen
    of the application, which consists of a Viewport with a Border layout. On the
    left-hand side of the Viewport, we are going to display a menu. This menu will
    be dynamic, and the items that will be displayed on the menu depend on the permissions
    that the user has, which is why we call it a dynamic menu.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: One of the options is to render all the screens of the system and then, depending
    on the user roles, we can hide or show them. However, this is not the approach
    we are going to use in this book. We are going to render and display only the
    screens the user has access to. The approach we are going to use is to dynamically
    render a menu according to the user entitlements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this chapter, we will learn how to display a dynamic menu using different
    Ext JS components and layouts (that we have not covered yet). To summarize, in
    this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic menu with the Accordion layout and TreePanel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Model association to load the data from the server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the dynamic menu on the server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a menu item dynamically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the MVC architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the dynamic menu
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So the first component that we are going to implement in this chapter is the
    dynamic menu. We could use only a TreePanel to display the menu, but we do like
    a challenge and we want to offer the best experience to the user. So, we are going
    to implement a dynamic menu using the Accordion layout and TreePanels, which results
    in a more advanced dynamic menu.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Our system consists of modules, and each module has subitems, which are the
    screens of our system. An accordion panel will represent the menu itself with
    all the modules; this way, the user can expand to see the options of each module
    at a time. And for the options of each module, we will use a TreePanel; each option
    of the menu will be a node from the TreePanel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at the end of this topic, we will have a dynamic menu like the following
    screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the dynamic menu](img/0457OT_05_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Before we get started with the dynamic menu, let's take a quick look at how
    the Ext JS TreePanel component works and how the Accordion layout works. Understanding
    these two concepts first will make it easier to understand how the dynamic menu
    is implemented.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS TreePanel
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A TreePanel is the perfect component to display hierarchical data in an application.
    This is the reason why we will use it to display the menu. The following image
    exemplifies a TreePanel and its pieces:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Ext JS TreePanel](img/0457OT_05_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*, the TreePanel extends from the `Ext.panel.Table` class,
    and so does the GridPanel. The `Ext.panel.Table` class extends from the `Panel`
    class. All the `Panel` classes have a *shell*, which is the panel itself, which
    allows us to set a title and add toolbars and also add child items.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The piece that is responsible for displaying the data is called the View, which
    is of the type `Ext.view.View`, and it is placed inside the `Panel` container.
    There are two ways that we can set data to a TreePanel: predefined using the `root`
    configuration or using a Store.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The Store behaves as our **Data Access Object** (**DAO**). In this example,
    we will load data from the server, so we will use a Store. The Store loads a collection
    of objects that we call `Model` (`Ext.data.Model`). In the case of the TreePanel,
    these models are decorated with `NodeInterface` (`Ext.data.NodeInterface`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the decorator pattern, please access [http://en.wikipedia.org/wiki/Decorator_pattern](http://en.wikipedia.org/wiki/Decorator_pattern).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to show or hide `Root` of the TreePanel. In the preceding image,
    `Root` is visible (the node called `Root`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Each **Node** of a TreePanel can have **Children** (in as many nested levels
    as needed). When a **Node** does not have any child, we call it a **Leaf**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We will dive more into the TreePanel when we implement the menu later in this
    chapter. For now, these are the concepts that we need to be familiar with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Accordion layout
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Accordion layout manages multiple panels in an expandable accordion style
    such that by default only one panel can be expanded at any given time (this can
    be changed by setting the `multi` configuration as true). Only Ext panels and
    all subclasses of `Ext.panel.Panel` can be used in an Accordion layout container.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'We could implement the dynamic menu using only a TreePanel, but we do like
    a challenge! Besides, from the UI point of view, having the modules separated
    by an Accordion layout container looks prettier than a simple TreePanel, as we
    can see in the following image:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Accordion layout](img/0457OT_05_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: The menu itself is a panel that uses the Accordion layout. A TreePanel represents
    each module of the menu (note that you can expand or collapse each module due
    the capabilities of the Accordion layout). We are going to load the required data
    to display this menu from the server, and we are going to load the data from the
    database according to the user entitlements. That is why we call it a dynamic
    menu.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important note on this approach: we are creating a TreePanel for each module
    for navigation. Creating many objects at the same time has some disadvantages,
    such as memory consumption. We can also create a single TreePanel and display
    all the modules as nodes with children. For more information about JavaScript,
    and memory consumption and its problems, please read [https://developer.chrome.com/devtools/docs/javascript-memory-profiling](https://developer.chrome.com/devtools/docs/javascript-memory-profiling).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: So now that we are familiar with all the concepts, we can start with the menu!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The database model – groups, menus, and permissions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already created the `user` and `groups` tables. To store the information
    of the menu and its options and also the permission that each group has, we need
    to create two more tables: the `menu` and `permissions` tables, as shown by the
    following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![The database model – groups, menus, and permissions](img/0457OT_05_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: On the `menu` table, we will store all the `menu` information. As each option
    of the `menu` table will be a node of a TreePanel, we will store the information
    in a way that represents a TreePanel. So, we have an `id` field to identify the
    node, a `text` field as the text that is going to be displayed on the node (in
    our case, we will store the attribute of the translations file since we are using
    a multilingual capability), `iconCls` representing the `css` class that will be
    used to display the icon for each node, `className` representing the `alias` (`xtype`)
    of the class that we are going to instantiate dynamically and open at the central
    tab panel of the application, and finally the `menu_id` field representing the
    `root` node (if it has one—the module nodes will not have a `menu_id` field, but
    the module items will).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Then, as the `menu` table has an **N:N** relationship with the `groups` table,
    we need to create the `permissions` table that will represent this relationship.
    We will learn more about how to assign a user to a group in the next chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not familiar with database relationships, the following link provides
    a good tutorial: [http://goo.gl/hXRsPx](http://goo.gl/hXRsPx).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'So to create the new table, we will use the following SQL script:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And we also need to populate the `menu` and `permissions` tables with some
    data. We can use the following SQL code to create all the modules and menu options
    that we are going to develop throughout this book. We are also going to grant
    the user we created in the preceding chapter access to all menu options, as this
    user is *admin*. Here''s the code that encapsulates what we discussed in this
    paragraph:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Throughout this book, we are going to create the screens of our application,
    and we will need to run some update queries. For now, whenever we click on any
    menu option, the application is going to open an empty panel so that we can test
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `className` is set to `Panel` for all options. We will update the
    records in the database accordingly throughout the next chapters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic menu – an MVC approach
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the MVC architecture concept in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*, already, but let's do a quick overview one more
    time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The Model represents the data we want to manipulate. It is a representation
    of the tables we have in the database. A Model instance represents a single data
    row of a table. The Store will be responsible for loading the collection of models
    from the server. A Store is usually bound to a View. A View is the component with
    which the user is seeing the screen (we have created a few so far; for example,
    a GridPanel provides a visual representation of data found in a Store.). And the
    Controller is what keeps everything together. The Controller will capture the
    events from the View and will execute some logic based on it. The Controller can
    also redirect the logic to the Model or the Store, making all the pieces communicate
    with each other, behaving like a mediator.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we used the MVVM architecture. We saw an example using
    the View and ViewController only and an example with View, ViewModel (predefined
    data), and ViewController. We have also learned that the ViewController is bound
    to its View's component life cycle, which means it is created when the View is
    created, and it is destroyed when the View is destroyed. With the MVC approach,
    the Controllers are alive as long as the application is running in the browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: While in the ViewController, we can easily retrieve the view's reference or
    any of its children's references as well (using the `reference` configuration),
    in the Controller, we need to define what events from what components we want
    to listen to, and there is another approach to retrieve the components references.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: MVC is not better than MVVM or vice versa. It depends on the application, the
    type of screen you are developing, the use case, and also your personal preference
    (why not?). That is why we are going to use all the possibilities in this book
    in the examples. This way, you can learn all of them (MVVM, MVC, and hybrid architecture)
    and use the one you like the most!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with the MVC architecture, we usually create the models first.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: So first, we will create a class named `Packt.model.menu.Accordion`. To do that,
    we need to create the directory `app/model/menu` and also create a file named
    `Accordion.js`. With this Model, we will be able to represent each of the accordion
    panels we want to create (that will be represented by a TreePanel). So, for each
    module (or TreePanel), we want to set a title and also an icon.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the implementation of the `Packt.model.menu.Accordion`
    class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main configuration for a Model is called `fields` (`#1`). In this configuration,
    we can declare all the `fields` for the Model (which would be similar to the columns
    of a table from the database). The class `Ext.data.field.Field` represents each
    field. Each field can have `name` and it can also have `type`. The available types
    are `string`, `int`, `number`, `boolean`, `date`, and `auto` (when no type is
    defined, and in this case, the field does not try to convert the value to any
    of the default types). The fields `text` and `iconCls` have the type `auto`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Model needs a field that works as its unique identifier. In this case,
    we are defining the field `id` (`#2`) as our unique field. If the unique identifier
    of the Model is not called `id`, we need to configure this information in the
    Model as well by using the `idProperty` configuration. For example, if our ID
    was named `accordionId`, we would declare it normally, and inside the Model, we
    would add `idProperty: ''accordionId''` so that the Model would know that the
    field is the identifier.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Model` and `Field` classes also have other features. Please refer to them
    to see all their capabilities in the Ext JS documentation, which is very complete
    and full of examples. Please take a look at [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model)
    and [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a Model to represent the menu option, which consists of the Tree
    nodes of the TreePanel. To do so, we will declare the following Model:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `TreeNode` Model declared three fields present in the `NodeInterface` class,
    which are `id`, `text`, and `iconCls`. The `className` value is going to be used
    as `xtype` to instantiate the class that represents the screen of the menu option.
    We will talk more about this later. Then, we have the `parent_id` field. In the
    JSON, when we load data from the server, we will have the `menu_id` property instead
    of `parent_id`. We can use the `mapping` configuration to make this link (`#1`).
    This is nice because our Ext JS models do not need to be exactly like what is
    coming from the server (but it makes our life easier if they are the same).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Working with the hasMany association
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two different ways of working with associations in Ext JS. The first
    one is using `Ext.data.association.Association` introduced in Ext JS 4\. And the
    second one is using the `reference` configuration introduced in Ext JS 5\. Ext
    JS 5 maintains backwards compatibility with the Model associations from Ext JS
    4, although these Ext JS 4 features are marked as legacy code in the sources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to use the hasMany association introduced in Ext
    JS 4\. Later in this book, we will see another example using `reference`, and
    we will be able to compare the difference and choose when to use one or the other.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the hasMany association, inside the `Accordion` Model, we first need
    to add the `hasMany` configuration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that a new field named `items` (`#1`) will be created for the `Accordion`
    Model. For each instance of the `Accordion` Model, a method named `items()` will
    also be available to retrieve the `TreeNode` Model instances.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot forget to add the `requires` declaration to the beginning of the
    `Accordion` Model as well, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating the store-loading menu from the server
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the Model defined, we can move on and create the Store. We
    will create a new class named `Packt.store.Menu`, so we need to create a new file
    named `Menu.js` under the `app/store` folder with the following content:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are two important things we need to declare in the Store: the `model`
    and the `proxy` properties. The `model` tells the Store what type of data the
    Store needs to load from the server (or client storages), and the `proxy` tells
    the Store how and where to get the data.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: This Store is going to use the model `Packt.model.` (`#2`). Instead of using
    the `model` configuration, it is also possible to declare the fields directly
    inside the Store using the `fields` configuration (it would be a copy from `fields`
    from the Model). In this case, the Store would use a so-called "anonymous model".
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The Store is going to communicate with the server through the proxy using an
    Ajax request to the provided `url`. The `reader` (`#5`) tells the proxy how to
    decode the information from the server and transform it into a collection of the
    specified models. This Store is expecting a JSON format with `rootProperty` (known
    in Ext JS 4 as `root`) named `data`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we declare the associations in the previous topic, the Store knows how
    to decode a nested JSON and create the respective Model instances.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, exceptions can occur! For this reason, we can add `exception`
    `listener` (`#6`) in `proxy` so that we can display an error message to the user.
    As we are using the `Util` class we created, we also need to add this class in
    the `requires` declaration (`#1`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We can listen to events from views and stores in the Controller; however, the
    Store does not have any exception event. For this reason, `listener` needs to
    be added directly to `proxy`. This is an optional step, but if an error occurs,
    nothing will happen in the UI (Ext JS will output an error message in the browser's
    console, but users do not use the application with the developer tools console
    opened). That is why it is a good practice to have `exception listener` declared
    inside every proxy we use. We will develop a more elegant approach, but for now,
    we will use it like this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of declaring `proxy` inside the Store, we can declare it inside the
    Model. You can declare `proxy` in the place of your preference. However, if you
    declare `proxy` on the Model and on the Store, when using the Store's `sync()`
    method, it will call the `proxy` instance declared on the Store; else the Model's
    `proxy` will be used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the data format that we need to retrieve from the server, let's
    implement it!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Handling the dynamic menu on the server
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we declared on the `Packt.store.Menu` Store, we need to create a new file
    named `menu/list.php` under the `php` folder. The following is the programming
    logic that we need to follow:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Get the user that is logged in from the session.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a connection with the database.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the menu `id` instances from the `permission` table so that we know what
    permissions the user from the session has.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the modules that the user has permission to access—`menu_id` is `null`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each module, select the nodes (menu options) that the user has access to.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode the result in the JSON format and wrap it in the `data` root (as specified
    by the Store).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So let''s get our hands on the code. The following code was organized in functions,
    so we can organize the code exactly as listed in the preceding set of instructions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As the code was organized in functions, let's create another file called `menuFunction.php`
    inside the `php/menu` folder as well. As we are going to code the functions inside
    this file, we need to require this file inside `menu/list.php` (`#1`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will get the user that is logged in to the session (`#2`). So we will
    get the entitlements for the user that is logged in, increasing the security a
    little bit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will do as listed. For each function to which we open the connection
    with the database, we will retrieve the user's permissions (`#4`), then we will
    retrieve the modules the user has permission to access (`#5`), and then based
    on the module, we retrieve the menu options the user also has access to (`#6`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: At last, we will encode the result array in the JSON format (`#7`), and it is
    going to produce the JSON listed in the preceding topic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the user permissions
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s dive into each function declared inside the `menuFunctions.php`
    file. The first one is the function used to retrieve the user''s permissions as
    listed here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we will open the connection with the database (`#8`), and then we prepare
    the SQL query to get the `id` instances from the `menu` table that the user has
    access to (`#9`). We are using `JOIN` because the only information we have is
    `username`, and we need to pass through the `groups` table to get to the `permissions`
    table.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We execute the SQL query (`#10`), and we create an array with the menu `id`
    that the user has permission to use (`#11`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we free the result set (`#12`), close the database connection (`#13`),
    and we return the `permissions` array (`#14`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the modules the user is entitled to
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the function that will retrieve the modules based
    on users'' permissions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To be able to retrieve the modules the user has access to, we need to know what
    modules (records from the `menu` table that do not have a `menu_id` parent menu)
    the user has permission to access. In our SQL query (`#16`), there is an `IN`
    clause to fetch all modules. As we have the `permissions` array, we can use the
    `join` PHP function (`#15`) that will return a string with all the array values
    separated by the "`,`" delimiter we informed. Then, we concatenate with "`( )`"
    and we are good to go.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The next step is executing the SQL query (`#17`), and with the results from
    the database, we create an array with the `modules` that the user has access to,
    and at the end of the function, we return this information (`#18`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The `modules` variable represents the `Accordion Model` class we created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the menu options based on modules and permissions
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After we have retrieved the `permissions` and `modules` the user has access
    to, it is time to retrieve the last piece to create the data for the dynamic menu,
    which is retrieving the menu options. The code is presented as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For each `module` that the user has access to (`#2`), we will retrieve the menu
    options (`#3`). To do so, we need the ID of the module and also the `permissions`
    (`#1`). As each module might have several menu options, a user might not have
    permission to access all of them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Next, we execute the query (`#4`) and retrieve the number of records returned
    by the database (`#5`). If this number is positive (`#6`), we create the `items`
    array ((`#7`), the `hasMany` association) and we fetch each item adding it to
    the `module['items']` array (`#8`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Each `$item` variable inside `module['items']` represents the `TreeNode` model.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: At the end of it, we add `$item` to the `result` variable (`#9`) and return
    it (`#10`). This `result` variable is the one that will be wrapped inside the
    `data` root and encoded as JSON to be returned to Ext JS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The database for the `menu` fits perfectly to what Ext JS needs. We designed
    the `menu` table according to Ext JS expectations, and in a way that would be
    easier for us to retrieve the information. The preceding server-side code also
    fits perfectly to what Ext JS needs. Unless we have the chance to design the database
    ourselves in a project that we are starting from scratch, we will probably have
    a different design; therefore, the server-side code to retrieve the information
    will be a little different too. There is no problem at all. It does not matter
    how the database looks or the server-side code you need to write to retrieve the
    information. However, Ext JS is expecting a specific format to be sent back to
    the frontend code, and unfortunately, we need to send the information in this
    specific format (the JSON listed before). If the information we retrieved from
    the database is not in the format that Ext JS expects (the same format as our
    preceding code), all we need to do is parse and transform it, which means there
    will be an extra step in our server-side code before we send it back to Ext JS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`menu`数据库与Ext JS的需求完美匹配。我们根据Ext JS的期望设计了`menu`表，并且以一种对我们来说更容易检索信息的方式。前面的服务器端代码也完美地符合Ext
    JS的需求。除非我们有在从头开始的项目中自己设计数据库的机会，否则我们可能有一个不同的设计；因此，检索信息的服务器端代码也会略有不同。完全没有问题。数据库看起来如何或你需要编写什么服务器端代码来检索信息都无关紧要。然而，Ext
    JS期望以特定的格式将信息发送回前端代码，不幸的是，我们需要以这种特定格式（前面列出的JSON）发送信息。如果我们从数据库检索到的信息不是Ext JS期望的格式（与前面代码相同的格式），我们只需要解析和转换它，这意味着在我们的服务器端代码在将其发送回Ext
    JS之前将有一个额外的步骤。'
- en: Creating the menu with the Accordion layout and TreePanel
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用折叠布局和树面板创建菜单
- en: 'We can go back to the Ext JS code and start implementing the dynamic menu View
    component now. First, we need to create a new folder under `app/view/menu` and
    create a new file named `Accordion.js`, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到Ext JS代码中，现在开始实现动态菜单视图组件。首先，我们需要在`app/view/menu`下创建一个新文件夹，并创建一个名为`Accordion.js`的新文件，如下所示：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class is going to be a panel and it is going to wrap the TreePanels that
    will be the menus. It is going to use the Accordion layout (`#3`); this way, the
    user can expand or collapse the desired module. As the default behavior, all modules
    will be expanded (`#4`). If only the first module should be expanded at a time,
    we can comment line `#4`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将是一个面板，它将包裹作为菜单的TreePanels。它将使用折叠布局（`#3`）；这样，用户可以展开或折叠所需的模块。默认行为是所有模块都将展开（`#4`）。如果一次只应该展开一个模块，我们可以注释掉`#4`行。
- en: As we are going to use this class in the `west` region of the `Main` class,
    we are going to declare `xtype` (`#1`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在`Main`类的`west`区域使用这个类，我们将声明`xtype`（`#1`）。
- en: 'Be very careful when declaring `xtype`. Always remember to create a unique
    `xtype` and not any that is already being used by Ext JS components. For example,
    let''s say there is an `xtype` property you might want to use, but if we go to
    the documentation and use the quick search, we will see this `xtype` property
    is already in use by Ext JS, as shown below:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明`xtype`时非常小心。始终记得创建一个唯一的`xtype`，而不是任何已经被Ext JS组件使用的`xtype`。例如，假设有一个你可能想要使用的`xtype`属性，但如果我们去文档中快速搜索，我们会看到这个`xtype`属性已经被Ext
    JS使用，如下所示：
- en: '![Creating the menu with the Accordion layout and TreePanel](img/0457OT_05_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用折叠布局和树面板创建菜单](img/0457OT_05_05.jpg)'
- en: As this panel will be rendered in the `west` region, we need to set a `width`
    (`#2`)—remember that whenever we are using the Border layout, we need to specify
    a `width` for the `west` and `east` regions. We will also allow the user to resize
    the `west` region (`#4`) and collapse (`#3`) so that there is more space for the
    screen in the center.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此面板将在`west`区域渲染，我们需要设置一个`width`（`#2`）——记住，无论何时我们使用Border布局，都需要为`west`和`east`区域指定一个`width`。我们还将允许用户调整`west`区域的尺寸（`#4`）并折叠（`#3`），以便为中心屏幕腾出更多空间。
- en: 'At last, to prettify, we are declaring a Font Awesome icon (`#5`) and a `title`
    property (`#6`). We cannot forget to add the following entry in the `locale/en.js`
    file and its translations:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了美化，我们声明了一个Font Awesome图标（`#5`）和一个`title`属性（`#6`）。我们绝不能忘记在`locale/en.js`文件中添加以下条目及其翻译：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can get the Spanish and Portuguese translations by downloading the source
    code bundle from this book or downloading from the GitHub repository [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从本书下载源代码包或从 GitHub 仓库 [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs)
    下载来获取西班牙语和葡萄牙语的翻译。
- en: 'Next, we need to create a TreePanel to represent each module. We will create
    a new class named `Packt.view.menu.Tree`; therefore, we need to create a new file
    named `Tree.js` under `app/view/menu`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 TreePanel 来表示每个模块。我们将创建一个名为 `Packt.view.menu.Tree` 的新类；因此，我们需要在
    `app/view/menu` 下创建一个名为 `Tree.js` 的新文件：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class is a TreePanel. We do not want a `border` property for our module,
    and the `root` property will not be visible. As we can see, we are not setting
    many attributes. We will set the missing information dynamically on the Controller.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是一个 TreePanel。我们不想为我们的模块设置 `border` 属性，并且 `root` 属性将不可见。正如我们所看到的，我们没有设置很多属性。我们将在控制器上动态设置缺失的信息。
- en: 'The last step is going back to the `Main` class and adding `Accordion` to the
    `west` region. To do so, first we cannot forget to add the class `''Packt.view.menu.Accordion''`
    to `requires` and change the `west` region code to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是回到 `Main` 类，并将 `Accordion` 添加到 `west` 区域。要做到这一点，首先我们不能忘记将类 `'Packt.view.menu.Accordion'`
    添加到 `requires` 中，并将 `west` 区域代码更改为以下内容：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We removed all the configurations (`width`, `split`) and replaced `xtype` with
    `menu.Accordion`. When we execute the application, we will be able to see the
    `west` region with a panel now. The creation of the dynamic menu is pending though,
    and we will take care of it next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了所有配置（`width`，`split`）并将 `xtype` 替换为 `menu.Accordion`。当我们执行应用程序时，我们将能够看到现在有一个面板的
    `west` 区域。动态菜单的创建仍在等待中，我们将在下一步处理它。
- en: Creating the menu Controller
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建菜单控制器
- en: 'We already have all the views, models, and stores and also have the server-side
    covered. Now the only thing left is to implement the Controller, which is where
    all the magic will happen. So, let''s go ahead and create a new file named `Menu.js`
    under the `app/controller` folder:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有的视图、模型和存储，并且也覆盖了服务器端。现在唯一剩下的事情就是实现控制器，这是所有魔法发生的地方。所以，让我们继续创建一个名为 `Menu.js`
    的新文件，位于 `app/controller` 文件夹下：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the MVC approach, all controllers are created inside the `app/controller`
    folder, while in the MVVM approach, ViewController is created in the same folder
    as the View.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 方法中，所有控制器都创建在 `app/controller` 文件夹内，而在 MVVM 方法中，ViewController 创建在视图相同的文件夹中。
- en: The `init` function is called when the application boots, and it is called before
    the application's `launch` function is. We can use this function to execute any
    logic before the first View (`Login` or Viewport) is created. Inside this function
    is also the place where we want to set up the events we want this Controller to
    listen to using the `control` function (`#1`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，会调用 `init` 函数，并且它会在应用程序的 `launch` 函数之前被调用。我们可以使用这个函数在第一个视图（`Login`
    或视口）创建之前执行任何逻辑。在这个函数内部也是我们想要设置控制器要监听的事件的地方，使用 `control` 函数（`#1`）。
- en: In this Controller, we want to listen to two events. The first one is we want
    to render the dynamic menu (`#4`) when the Viewport (`Main` class) has been rendered.
    The second one is whenever the user clicks on a menu option (a node from the TreePanel—`#2`),
    we want to open the screen inside the center panel (#3).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，我们想要监听两个事件。第一个事件是当视口（`Main` 类）被渲染后，我们想要渲染动态菜单（`#4`）。第二个事件是无论用户点击菜单选项（来自
    TreePanel 的节点——`#2`），我们想要在中心面板（#3）内打开屏幕。
- en: 'To listen to an event inside the `control` method, we need to define three
    things: the selector, the event we want the Controller to listen to, and the method
    to be executed. It has the following format:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `control` 方法中监听一个事件，我们需要定义三件事：选择器、控制器要监听的事件以及要执行的方法。它具有以下格式：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finding the selector is the most challenging part. The scope in this case is
    not the View as in the ViewController, but the application. For selectors, we
    usually use the `xtype` component. It helps when it is an `xtype` component we
    created for the application and not an Ext JS `xtype` such as `'tree'`; for example,
    `'menutree'` is much better because we narrow down the possibilities (there might
    be several TreePanels within the application, but we know that only the TreePanels
    from the dynamic menu have `menutree` as `xtype`). We have to remember that if
    we use the selector `'tree'` (`xtype` for TreePanel), the Controller will listen
    to the event from all TreePanels of the application, so it is good to be as specific
    as we can be.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 找到选择器是最具挑战性的部分。在这个例子中，范围不是视图（ViewController中的View），而是应用程序。对于选择器，我们通常使用`xtype`组件。当它是一个为应用程序创建的`xtype`组件，而不是Ext
    JS的`xtype`（例如`'tree'`）时，它很有帮助；例如，`'menutree'`更好，因为我们缩小了可能性（应用程序中可能有多个TreePanels，但我们知道只有动态菜单中的TreePanels的`xtype`是`menutree`）。我们必须记住，如果我们使用选择器`'tree'`（TreePanel的`xtype`），控制器将监听应用程序中所有TreePanels的事件，所以最好尽可能具体。
- en: We can listen to as many events from a selector as we want to. We simply need
    to separate the events by a "`,`".
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以监听来自选择器的任意多个事件。我们只需要用“`,`”分隔事件即可。
- en: 'For example, let''s implement the `renderDynamicMenu` method first. We use
    `mainmenu` as the selector. This is the `xtype` component for the `view.menu.Accordion`
    class, which is being rendered in the `west` region of the `Main` class (Viewport).
    So, when this component is rendered, the Controller is going to execute the `renderDynamicMenu`
    method. Let''s declare this method inside the `Menu` Controller:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们首先实现`renderDynamicMenu`方法。我们使用`mainmenu`作为选择器。这是`view.menu.Accordion`类的`xtype`组件，它正在`Main`类的`west`区域（Viewport）中被渲染。所以，当这个组件被渲染时，控制器将执行`renderDynamicMenu`方法。让我们在`Menu`控制器中声明这个方法：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can always start the implementation of an event listener in the Controller
    by adding a `console.log` or `alert` message to make sure the method is being
    executed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在控制器中添加`console.log`或`alert`消息来始终从控制器开始实现事件监听器的实现，以确保该方法正在执行。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to always go to the documentation to verify the parameters that are
    being passed to the event so that we can declare them. For the `render` event,
    it is usually the component itself and `options`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，始终去查阅文档以验证传递给事件的参数，这样我们才能声明它们。对于`render`事件，通常是组件本身和`options`。
- en: 'Let''s declare `onTreePanelItemClick` as well so that we can test this Controller:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明`onTreePanelItemClick`，这样我们就可以测试这个控制器：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The method signature is enough so that we do not get any errors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名已经足够，我们不会得到任何错误。
- en: 'We need to add this Controller in `Application.js` as well. So, go back to
    `Application.js` and add the highlighted code shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`Application.js`中添加这个控制器。所以，回到`Application.js`并添加以下突出显示的代码：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we execute the application, we will get the output as shown in the following
    screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们将得到以下截图所示的输出：
- en: '![Creating the menu Controller](img/0457OT_05_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![创建菜单控制器](img/0457OT_05_06.jpg)'
- en: This means that it is working as we expect. Do not worry about the other warning
    messages; we will take care of them later in this book (the important thing is
    not getting error messages).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它正在按预期工作。不要担心其他警告信息；我们将在本书的后面部分处理它们（重要的是不要出现错误信息）。
- en: So let's go ahead and add the required business logic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续添加所需的业务逻辑。
- en: Rendering the menu from nested JSON (the hasMany association)
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从嵌套JSON（hasMany关联）渲染菜单
- en: 'We need to add the logic that will be responsible for creating the dynamic
    menu with the information that will be received from the server. We will add the
    following code inside the `renderDynamicMenu` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加负责创建包含从服务器接收的信息的动态菜单的逻辑。我们将在`renderDynamicMenu`方法中添加以下代码：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we are going to do is create an empty array so that we can add
    all the modules to it (`#1`). As we are going to make a request to the server
    and as initially the menu in the `west` region is going to be empty, it is nice
    to add a loading message (`#2`) just in case there is any delay with the server
    response (*Ajax is asynchronous*). The `view` was passed as a parameter to the
    event and is a reference to the `Packt.view.menu.Accordion` class instance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to load the `Menu` Store (`#3`), which is responsible for loading
    the nested JSON from the server (`#1`). Note that we are using `this.getMenuStore()`
    to retrieve the Store, which means this is a method from the Controller. We need
    to declare the `menu` Store inside the `stores` configuration in the Controller
    so that it will generate this method for us:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, there is no need to declare the complete name of the Store—only
    what is after `'Packt.store'`. Because of the MVC architecture, Ext JS knows that
    it needs to look for a file named `Menu.js` inside the `app/store` folder. As
    the name of the Store is `Menu`, the Controller will generate a method named `get`
    + `Menu` + `Store` (`getMenuStore`) once the Store is loaded (that is why we are
    going to handle the creation of the dynamic menu inside the load callback). For
    each `record` returned from the Store (`#4`), we will create a TreePanel (`Packt.view.menu.Tree`—`#5`)
    to represent each module. We will set the `title` property (getting the `title`
    property from the locale file `(#6`). In the database, we will store the key from
    the `en.js` file in the column `text` and set `iconCls` (`#7`) for it to look
    prettier (a Font Awesome icon).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ext.create or Ext.widget**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Getting Started"), *Getting Started*, when
    we instantiated a class for the first time in this book, we discussed the options
    we can use when we need to instantiate a `component` class. Just to remind you,
    we can use `Ext.create` passing the complete name of the class as an argument,
    or we can use `Ext.widget` passing the class alias as an argument (there are other
    ways as well, but these two are more commonly used). It is a matter of preference,
    but you can use any of the ways we mentioned in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: So, with this code, we are able to display each TreePanel representing each
    of the modules (with no menu option). The next step is getting the data to display
    inside the TreePanel. This data is available in the JSON already through the `hasMany`
    association we configured. Because of the `hasMany` association, a method named
    `items` (`name` of the association we configured) will be created for each Model
    instance inside the Store. The `items` method returns a Store with the `hasMany`
    data in it (`#8`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are not sure whether the method was created or not, we can always inspect
    the Model instance in the console. For example, if we output `console.log(this)`
    inside the `load` callback, we will get the Store outputted in the browser''s
    console. Inspect the `data` configuration, and inside the `data` configuration,
    we will find `items`, which contains the Model collection as shown in the following
    screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering the menu from nested JSON (the hasMany association)](img/0457OT_05_07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: For each `Packt.model.menu.TreeNode` Model instance from the Store (`#9` and
    `#10`), we will push a new node (`#11`) into an array. When adding the new node,
    we set the `text` and `leaf` (`#12`) that are properties from the `NodeInterface`
    class. We are adding `id` and `className` that are not part of the `NodeInterface`
    class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: To add all the nodes created, we need access to the `Root` node of the TreePanel.
    As `Root` is also a node (decorated with the `NodeInterface` class), it has a
    method called `appendChild`, which can be used to append nodes to a specific node
    (in this case, `Root`). So, we add all the nodes we created at once (`#14`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To avoid many changes in the DOM, which is not a good practice, we are going
    to create an array with all the menus we created (`#15`). And then, we will add
    all the menus at once (`#16`) to the `Accordion` panel (this will avoid browser
    reflow).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Minimizing browser reflow is a technique used to increase performance. We could
    do the insertions inside the loops, but this would increase DOM manipulation,
    which is very expensive. With simple changes in the code to add whatever needs
    to be added at once, we can increase the performance a little bit. For more information,
    please visit [https://developers.google.com/speed/articles/reflow](https://developers.google.com/speed/articles/reflow).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: At last, we remove the `mask` from the `Accordion` menu (`#17`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If we execute the code, the menu will be rendered.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Using glyphs in TreePanel – working with overrides
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There was a piece from the code that we did not cover in the previous topic,
    which is line `#13`, the `glyph` configuration in the node. We know that we can
    use icon fonts, such as Font Awesome, with Ext JS, but the support is still limited.
    It is not possible to use Font Awesome icons in TreePanel nodes. However, there
    is an override we can use that will allow us to do that.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first time we are mentioning the term **glyph** in this book. It
    is basically the same thing as the font icon we have been using until now, but
    it has an alternative configuration for it. For example, we used a key icon in
    the `Login` class, and we set `iconCls` as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We could have used the `glyph` configuration instead as an alternative:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code could also be written as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But we need to configure the `glyphFontFamily` configuration inside the `Packt.Application`
    class in `Application.js`, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And then, we can remove `'@FontAwesome'` from the `glyph` configuration.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Font Awesome provides a cheat sheet with the CSS names and glyph codes at [http://fortawesome.github.io/Font-Awesome/cheatsheet/](http://fortawesome.github.io/Font-Awesome/cheatsheet/).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The Font Awesome `iconCls` is not going to work for the Tree nodes, but as mentioned
    before, we can apply an override. An override is a way of changing the behavior
    of the Ext JS class. It would be similar to modifying the prototype of a JavaScript
    object—the new behavior is applied to all the instances of that class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Even though Ext JS is open source, we should avoid changing the source code
    directly (despite the open source code philosophy). Changing the source code can
    be an issue when upgrading the framework version in the future. Using overrides
    is more elegant.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The override we are going to use can be found at [http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels](http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create the override inside the file `app/overrides/tree/ColumnOverride.js`.
    We cannot forget to change the name of the override to `Packt.overrides.tree.ColumnOverride`
    (the first line of code).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside `Application.js`, we are going to add the following code to make
    sure it is loaded when the application is loaded and the override is applied,
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can also add this `require` declaration inside the `Packt.view.menu.Tree`
    class to remind us that we are using an override as well, but it is optional.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `menu` table looks like at this moment. The modules have the
    Font Awesome CSS, and the menu options have the glyph codes (`iconCls` column),
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Using glyphs in TreePanel – working with overrides](img/0457OT_05_08.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: You can use only the glyph codes throughout the application. We are using both
    to show it is possible to use both. From now on, you can use the approach you
    prefer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Menu locale support
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We also need to add the keys to the `en.js` file (and other locale files as
    well). For the menu, these are the entries needed:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the keys are the same entries as the `text` column from the `menu` table.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Opening a menu item programmatically
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the menu is rendered, the user will be able to select an option from
    it. The logic behind the method is: when the user selects an option from the menu
    we need to verify that the tab has already been created on the tab panel. If yes,
    we do not need to create it again; we only need to select the tab on the tab panel
    and make it active. If not, then we need to instantiate the screen selected by
    the user. To do so, the Controller will execute the following method:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we need to get the reference of the tab panel (`#1`). We are using `this.getMainPanel()`,
    which was created by the Controller.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways of getting object references inside Controller methods.
    The first one is using the parameters passed to the method. The second one is
    using the `ComponentQuery` (that we have not discussed yet), and the third one
    is using `refs`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Controller方法中获取对象引用有三种方式。第一种是使用传递给方法的方法参数。第二种是使用`ComponentQuery`（我们尚未讨论），第三种是使用`refs`。
- en: 'For this example, we are going to use `refs`. We need to add the following
    code inside the Controller:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用`refs`。我们需要在Controller中添加以下代码：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can configure the selector we want the Controller to search for and the name
    of the reference. In this case, the Controller will create a method called `get`
    + `mainPanel` (in the `ref` name, the first letter becomes a capital letter) resulting
    in `getMainPanel`. This is equivalent to `reference` used by the ViewController.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置Controller要搜索的选择器和引用的名称。在这种情况下，Controller将创建一个名为`get` + `mainPanel`（在`ref`名称中，第一个字母变为大写）的方法，结果为`getMainPanel`。这相当于ViewController使用的`reference`。
- en: Then, we need to verify that the selected menu option was already created (`#2`),
    and we will do it comparing the tab `title` with the `text` configuration of the
    selected node (`#3`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要验证所选菜单选项是否已经创建（`#2`），我们将通过比较标签`title`与所选节点的`text`配置来完成此操作（`#3`）。
- en: If it is not a new tab, we will add it to the tab panel, passing as an instance
    to the `add` method (`#5`). So we will get the `xtype` configuration of the component
    we are going to add from the node `className` (`#6`), and the tab can be `closed`
    (`#7`); it will have the same `glyph` as its node (`#8`) and will also have the
    same `title` as the node (`#9`—menu option).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是新标签页，我们将将其添加到标签面板中，并将实例传递给`add`方法（`#5`）。因此，我们将从节点的`className`获取我们打算添加的组件的`xtype`配置（`#6`），标签可以`关闭`（`#7`）；它将具有与节点相同的`glyph`（`#8`）并且也将具有与节点相同的`title`（`#9`—菜单选项）。
- en: Then, we will set it as the active tab. If the screen is already rendered, we
    will only change the `active` tab to the screen that the user selected from the
    menu (`#10`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将将其设置为活动标签。如果屏幕已经渲染，我们只会将`active`标签更改为用户从菜单中选择的屏幕（`#10`）。
- en: The dynamic menu functionality is now complete!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 动态菜单功能现在已完成！
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement an advanced dynamic menu using
    an Accordion layout and also TreePanels for each module of the application. We
    learned how to handle the dynamic logic on the sever side and also how to handle
    its return on the Ext JS side loading a Store to build the menu dynamically. And
    finally, we have also learned how to open an item from the menu programmatically
    and display it on the center component of the application. We also used the MVC
    architecture for the first time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用折叠布局和为应用程序的每个模块使用TreePanels实现一个高级动态菜单。我们学习了如何在服务器端处理动态逻辑，以及如何在Ext
    JS端处理其返回值，通过加载Store动态构建菜单。最后，我们还学习了如何通过编程方式打开菜单项并在应用程序的中心组件上显示它。我们还首次使用了MVC架构。
- en: In the next chapter, we will learn how to implement screens to list, create,
    and update users and also how to assign a group to the user.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何实现列出、创建和更新用户以及如何将组分配给用户的屏幕。
