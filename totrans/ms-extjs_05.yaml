- en: Chapter 5. Advanced Dynamic Menu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 高级动态菜单
- en: We already have the login capability that we implemented throughout [Chapter
    3](ch03.html "Chapter 3. The Login Page"), *The Login Page*, and the base of the
    application, that we implemented in [Chapter 4](ch04.html "Chapter 4. The Logout
    and Multilingual Capabilities"), *The Logout and Multilingual Capabilities*. In
    the base of our application there is one missing piece, which is the menu. So
    the next thing we are going to develop is the dynamic menu.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了登录功能，这在第 3 章[“登录页面”](ch03.html "第 3 章. 登录页面")中进行了实现，以及应用程序的基础，这在第 4 章[“注销和多语言功能”](ch04.html
    "第 4 章. 注销和多语言功能")中进行了实现。在我们的应用程序基础中，缺少一个部分，那就是菜单。因此，接下来我们将开发的是动态菜单。
- en: Once the user has been authenticated, we are going to display the base screen
    of the application, which consists of a Viewport with a Border layout. On the
    left-hand side of the Viewport, we are going to display a menu. This menu will
    be dynamic, and the items that will be displayed on the menu depend on the permissions
    that the user has, which is why we call it a dynamic menu.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户经过认证，我们将显示应用程序的基本屏幕，它由一个带有 Border 布局的 Viewport 组成。在 Viewport 的左侧，我们将显示一个菜单。这个菜单将是动态的，菜单上显示的项目取决于用户拥有的权限，这就是为什么我们称之为动态菜单。
- en: One of the options is to render all the screens of the system and then, depending
    on the user roles, we can hide or show them. However, this is not the approach
    we are going to use in this book. We are going to render and display only the
    screens the user has access to. The approach we are going to use is to dynamically
    render a menu according to the user entitlements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个选项是渲染系统的所有屏幕，然后根据用户角色隐藏或显示它们。然而，这不是我们在这本书中将要使用的方法。我们将只渲染和显示用户可以访问的屏幕。我们将采用的方法是动态根据用户权限渲染菜单。
- en: 'So in this chapter, we will learn how to display a dynamic menu using different
    Ext JS components and layouts (that we have not covered yet). To summarize, in
    this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将学习如何使用不同的 Ext JS 组件和布局（我们尚未介绍）来显示动态菜单。总结来说，在本章中，我们将涵盖：
- en: Creating a dynamic menu with the Accordion layout and TreePanel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Accordion 布局和 TreePanel 创建动态菜单
- en: Using the Model association to load the data from the server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型关联从服务器加载数据
- en: Handling the dynamic menu on the server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上处理动态菜单
- en: Opening a menu item dynamically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态打开菜单项
- en: Using the MVC architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MVC 架构
- en: An overview of the dynamic menu
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态菜单概述
- en: So the first component that we are going to implement in this chapter is the
    dynamic menu. We could use only a TreePanel to display the menu, but we do like
    a challenge and we want to offer the best experience to the user. So, we are going
    to implement a dynamic menu using the Accordion layout and TreePanels, which results
    in a more advanced dynamic menu.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将首先实现动态菜单。我们本可以使用仅 TreePanel 来显示菜单，但我们喜欢挑战，并希望为用户提供最佳体验。因此，我们将使用 Accordion
    布局和 TreePanels 来实现动态菜单，从而得到一个更高级的动态菜单。
- en: Our system consists of modules, and each module has subitems, which are the
    screens of our system. An accordion panel will represent the menu itself with
    all the modules; this way, the user can expand to see the options of each module
    at a time. And for the options of each module, we will use a TreePanel; each option
    of the menu will be a node from the TreePanel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统由模块组成，每个模块都有子项，这些子项是系统的屏幕。一个 Accordion 面板将代表包含所有模块的菜单；这样，用户可以展开以一次查看每个模块的选项。而对于每个模块的选项，我们将使用
    TreePanel；菜单的每个选项都将来自 TreePanel 的一个节点。
- en: 'So, at the end of this topic, we will have a dynamic menu like the following
    screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本主题结束时，我们将拥有如下截图所示的动态菜单：
- en: '![An overview of the dynamic menu](img/0457OT_05_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![动态菜单概述](img/0457OT_05_01.jpg)'
- en: Before we get started with the dynamic menu, let's take a quick look at how
    the Ext JS TreePanel component works and how the Accordion layout works. Understanding
    these two concepts first will make it easier to understand how the dynamic menu
    is implemented.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始动态菜单之前，让我们快速了解一下 Ext JS TreePanel 组件的工作原理以及 Accordion 布局的工作原理。首先理解这两个概念将有助于我们理解动态菜单的实现方式。
- en: Ext JS TreePanel
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext JS TreePanel
- en: 'A TreePanel is the perfect component to display hierarchical data in an application.
    This is the reason why we will use it to display the menu. The following image
    exemplifies a TreePanel and its pieces:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 树形面板是显示应用程序中层次数据的完美组件。这就是为什么我们将使用它来显示菜单。以下图像展示了树形面板及其组成部分：
- en: '![Ext JS TreePanel](img/0457OT_05_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Ext JS 树形面板](img/0457OT_05_02.jpg)'
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*, the TreePanel extends from the `Ext.panel.Table` class,
    and so does the GridPanel. The `Ext.panel.Table` class extends from the `Panel`
    class. All the `Panel` classes have a *shell*, which is the panel itself, which
    allows us to set a title and add toolbars and also add child items.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ch01.html "第1章. Sencha Ext JS 概述")中学习的，*Sencha Ext JS 概述*，树形面板扩展自`Ext.panel.Table`类，同样，网格面板也是如此。`Ext.panel.Table`类扩展自`Panel`类。所有`Panel`类都有一个*外壳*，即面板本身，这允许我们设置标题并添加工具栏，还可以添加子项。
- en: 'The piece that is responsible for displaying the data is called the View, which
    is of the type `Ext.view.View`, and it is placed inside the `Panel` container.
    There are two ways that we can set data to a TreePanel: predefined using the `root`
    configuration or using a Store.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 负责显示数据的部分称为视图，它是`Ext.view.View`类型，并放置在`Panel`容器内。我们可以通过两种方式将数据设置到树形面板中：使用`root`配置预定义或使用存储器。
- en: The Store behaves as our **Data Access Object** (**DAO**). In this example,
    we will load data from the server, so we will use a Store. The Store loads a collection
    of objects that we call `Model` (`Ext.data.Model`). In the case of the TreePanel,
    these models are decorated with `NodeInterface` (`Ext.data.NodeInterface`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 存储器充当我们的**数据访问对象**（**DAO**）。在这个例子中，我们将从服务器加载数据，所以我们将使用存储器。存储器加载一个我们称之为`Model`（`Ext.data.Model`）的对象集合。在树形面板的情况下，这些模型被装饰了`NodeInterface`（`Ext.data.NodeInterface`）。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the decorator pattern, please access [http://en.wikipedia.org/wiki/Decorator_pattern](http://en.wikipedia.org/wiki/Decorator_pattern).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于装饰器模式的更多信息，请访问[http://en.wikipedia.org/wiki/Decorator_pattern](http://en.wikipedia.org/wiki/Decorator_pattern)。
- en: We can choose to show or hide `Root` of the TreePanel. In the preceding image,
    `Root` is visible (the node called `Root`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择显示或隐藏树形面板的`Root`。在前面的图像中，`Root`是可见的（称为`Root`的节点）。
- en: Each **Node** of a TreePanel can have **Children** (in as many nested levels
    as needed). When a **Node** does not have any child, we call it a **Leaf**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 树形面板的每个**节点**都可以有**子节点**（在所需的嵌套级别中）。当一个**节点**没有任何子节点时，我们称之为**叶节点**。
- en: We will dive more into the TreePanel when we implement the menu later in this
    chapter. For now, these are the concepts that we need to be familiar with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章后面实现菜单时，我们将更深入地探讨树形面板。现在，这些是我们需要熟悉的概念。
- en: Accordion layout
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手风琴布局
- en: The Accordion layout manages multiple panels in an expandable accordion style
    such that by default only one panel can be expanded at any given time (this can
    be changed by setting the `multi` configuration as true). Only Ext panels and
    all subclasses of `Ext.panel.Panel` can be used in an Accordion layout container.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 手风琴布局管理多个面板，以可展开的手风琴样式，默认情况下，任何给定时间只能展开一个面板（这可以通过将`multi`配置设置为`true`来更改）。只有Ext面板和`Ext.panel.Panel`的所有子类可以在手风琴布局容器中使用。
- en: 'We could implement the dynamic menu using only a TreePanel, but we do like
    a challenge! Besides, from the UI point of view, having the modules separated
    by an Accordion layout container looks prettier than a simple TreePanel, as we
    can see in the following image:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用树形面板单独实现动态菜单，但我们喜欢挑战！此外，从UI的角度来看，使用手风琴布局容器将模块分开比简单的树形面板更美观，正如我们在以下图像中可以看到的：
- en: '![Accordion layout](img/0457OT_05_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![手风琴布局](img/0457OT_05_03.jpg)'
- en: The menu itself is a panel that uses the Accordion layout. A TreePanel represents
    each module of the menu (note that you can expand or collapse each module due
    the capabilities of the Accordion layout). We are going to load the required data
    to display this menu from the server, and we are going to load the data from the
    database according to the user entitlements. That is why we call it a dynamic
    menu.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单本身是一个使用手风琴布局的面板。一个树形面板代表菜单的每个模块（注意，由于手风琴布局的能力，你可以展开或折叠每个模块）。我们将从服务器加载所需的数据来显示这个菜单，并且我们将根据用户的权限从数据库中加载数据。这就是为什么我们称之为动态菜单。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An important note on this approach: we are creating a TreePanel for each module
    for navigation. Creating many objects at the same time has some disadvantages,
    such as memory consumption. We can also create a single TreePanel and display
    all the modules as nodes with children. For more information about JavaScript,
    and memory consumption and its problems, please read [https://developer.chrome.com/devtools/docs/javascript-memory-profiling](https://developer.chrome.com/devtools/docs/javascript-memory-profiling).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种方法的注意事项：我们为每个模块创建一个 TreePanel 用于导航。同时创建许多对象有一些缺点，例如内存消耗。我们也可以创建一个单独的 TreePanel，并将所有模块作为带有子节点的节点显示。有关
    JavaScript、内存消耗及其问题的更多信息，请阅读 [https://developer.chrome.com/devtools/docs/javascript-memory-profiling](https://developer.chrome.com/devtools/docs/javascript-memory-profiling)。
- en: So now that we are familiar with all the concepts, we can start with the menu!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了所有概念，我们就可以开始菜单了！
- en: The database model – groups, menus, and permissions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库模型 – 组、菜单和权限
- en: 'We have already created the `user` and `groups` tables. To store the information
    of the menu and its options and also the permission that each group has, we need
    to create two more tables: the `menu` and `permissions` tables, as shown by the
    following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `user` 和 `groups` 表。为了存储菜单及其选项的信息以及每个组拥有的权限，我们需要创建另外两个表：`menu` 和 `permissions`
    表，如下截图所示：
- en: '![The database model – groups, menus, and permissions](img/0457OT_05_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![数据库模型 – 组、菜单和权限](img/0457OT_05_04.jpg)'
- en: On the `menu` table, we will store all the `menu` information. As each option
    of the `menu` table will be a node of a TreePanel, we will store the information
    in a way that represents a TreePanel. So, we have an `id` field to identify the
    node, a `text` field as the text that is going to be displayed on the node (in
    our case, we will store the attribute of the translations file since we are using
    a multilingual capability), `iconCls` representing the `css` class that will be
    used to display the icon for each node, `className` representing the `alias` (`xtype`)
    of the class that we are going to instantiate dynamically and open at the central
    tab panel of the application, and finally the `menu_id` field representing the
    `root` node (if it has one—the module nodes will not have a `menu_id` field, but
    the module items will).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `menu` 表中，我们将存储所有的 `menu` 信息。由于 `menu` 表的每个选项都将是一个 TreePanel 的节点，我们将以表示 TreePanel
    的方式存储信息。因此，我们有一个 `id` 字段来识别节点，一个 `text` 字段作为将在节点上显示的文本（在我们的情况下，我们将存储翻译文件的属性，因为我们使用多语言功能），`iconCls`
    代表用于显示每个节点图标的 `css` 类，`className` 代表我们将动态实例化和在应用程序中央选项卡面板中打开的类的 `alias` (`xtype`)，最后是
    `menu_id` 字段，代表 `root` 节点（如果有的话——模块节点将没有 `menu_id` 字段，但模块项将有）。
- en: Then, as the `menu` table has an **N:N** relationship with the `groups` table,
    we need to create the `permissions` table that will represent this relationship.
    We will learn more about how to assign a user to a group in the next chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于 `menu` 表与 `groups` 表之间存在 **N:N** 的关系，我们需要创建一个 `permissions` 表来表示这种关系。我们将在下一章中学习如何将用户分配到组中。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are not familiar with database relationships, the following link provides
    a good tutorial: [http://goo.gl/hXRsPx](http://goo.gl/hXRsPx).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对数据库关系不熟悉，以下链接提供了一个很好的教程：[http://goo.gl/hXRsPx](http://goo.gl/hXRsPx)。
- en: 'So to create the new table, we will use the following SQL script:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建新的表，我们将使用以下 SQL 脚本：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And we also need to populate the `menu` and `permissions` tables with some
    data. We can use the following SQL code to create all the modules and menu options
    that we are going to develop throughout this book. We are also going to grant
    the user we created in the preceding chapter access to all menu options, as this
    user is *admin*. Here''s the code that encapsulates what we discussed in this
    paragraph:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要用一些数据填充 `menu` 和 `permissions` 表。我们可以使用以下 SQL 代码创建本书中将开发的全部模块和菜单选项。我们还将授予上一章中创建的用户对所有菜单选项的访问权限，因为这个用户是
    *管理员*。以下是封装本段讨论内容的代码：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Throughout this book, we are going to create the screens of our application,
    and we will need to run some update queries. For now, whenever we click on any
    menu option, the application is going to open an empty panel so that we can test
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将创建应用程序的屏幕，并且我们需要运行一些更新查询。现在，每次我们点击任何菜单选项时，应用程序都将打开一个空面板，以便我们可以对其进行测试。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `className` is set to `Panel` for all options. We will update the
    records in the database accordingly throughout the next chapters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有选项的`className`都设置为`Panel`。在接下来的章节中，我们将相应地更新数据库中的记录。
- en: The dynamic menu – an MVC approach
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态菜单 - MVC方法
- en: We have covered the MVC architecture concept in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*, already, but let's do a quick overview one more
    time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](ch02.html "第2章。入门")中介绍了MVC架构的概念，*入门*，但让我们再次快速概述一下。
- en: The Model represents the data we want to manipulate. It is a representation
    of the tables we have in the database. A Model instance represents a single data
    row of a table. The Store will be responsible for loading the collection of models
    from the server. A Store is usually bound to a View. A View is the component with
    which the user is seeing the screen (we have created a few so far; for example,
    a GridPanel provides a visual representation of data found in a Store.). And the
    Controller is what keeps everything together. The Controller will capture the
    events from the View and will execute some logic based on it. The Controller can
    also redirect the logic to the Model or the Store, making all the pieces communicate
    with each other, behaving like a mediator.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模型代表我们想要操作的数据。它是我们数据库中表的表示。模型实例代表表的单个数据行。Store将负责从服务器加载模型集合。Store通常绑定到View。View是用户看到屏幕的组件（我们已创建了一些；例如，GridPanel提供了Store中找到的数据的视觉表示）。控制器是保持一切在一起的东西。控制器将捕获来自View的事件，并基于它执行一些逻辑。控制器还可以将逻辑重定向到模型或Store，使所有部件相互通信，表现得像一个调解者。
- en: In the previous chapters, we used the MVVM architecture. We saw an example using
    the View and ViewController only and an example with View, ViewModel (predefined
    data), and ViewController. We have also learned that the ViewController is bound
    to its View's component life cycle, which means it is created when the View is
    created, and it is destroyed when the View is destroyed. With the MVC approach,
    the Controllers are alive as long as the application is running in the browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了MVVM架构。我们看到了仅使用View和ViewController的示例，以及使用View、ViewModel（预定义数据）和ViewController的示例。我们还了解到，ViewController绑定到其View的生命周期，这意味着它在View创建时创建，在View销毁时销毁。在MVC方法中，Controllers只要浏览器中的应用程序在运行就保持活跃。
- en: While in the ViewController, we can easily retrieve the view's reference or
    any of its children's references as well (using the `reference` configuration),
    in the Controller, we need to define what events from what components we want
    to listen to, and there is another approach to retrieve the components references.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当在ViewController中时，我们可以轻松检索视图的引用或其任何子视图的引用（使用`reference`配置），而在Controller中，我们需要定义我们想要监听哪些组件的事件，并且还有另一种方法来检索组件引用。
- en: MVC is not better than MVVM or vice versa. It depends on the application, the
    type of screen you are developing, the use case, and also your personal preference
    (why not?). That is why we are going to use all the possibilities in this book
    in the examples. This way, you can learn all of them (MVVM, MVC, and hybrid architecture)
    and use the one you like the most!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MVC并不比MVVM或反之更好。这取决于应用程序、你正在开发的屏幕类型、用例以及你的个人偏好（为什么不呢？）。这就是为什么我们将在本书的示例中使用所有可能性。这样，你可以学习所有这些（MVVM、MVC和混合架构），并使用你最喜欢的一个！
- en: Creating the models
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型
- en: When working with the MVC architecture, we usually create the models first.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MVC架构工作时，我们通常首先创建模型。
- en: So first, we will create a class named `Packt.model.menu.Accordion`. To do that,
    we need to create the directory `app/model/menu` and also create a file named
    `Accordion.js`. With this Model, we will be able to represent each of the accordion
    panels we want to create (that will be represented by a TreePanel). So, for each
    module (or TreePanel), we want to set a title and also an icon.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`Packt.model.menu.Accordion`的类。为此，我们需要创建`app/model/menu`目录，并创建一个名为`Accordion.js`的文件。有了这个模型，我们将能够表示我们想要创建的每个手风琴面板（这些面板将由TreePanel表示）。因此，对于每个模块（或TreePanel），我们想要设置一个标题以及一个图标。
- en: 'The following code snippet shows the implementation of the `Packt.model.menu.Accordion`
    class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`Packt.model.menu.Accordion`类的实现：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main configuration for a Model is called `fields` (`#1`). In this configuration,
    we can declare all the `fields` for the Model (which would be similar to the columns
    of a table from the database). The class `Ext.data.field.Field` represents each
    field. Each field can have `name` and it can also have `type`. The available types
    are `string`, `int`, `number`, `boolean`, `date`, and `auto` (when no type is
    defined, and in this case, the field does not try to convert the value to any
    of the default types). The fields `text` and `iconCls` have the type `auto`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的主配置称为 `fields`（`#1`）。在这个配置中，我们可以声明模型的所有 `fields`（这类似于数据库表中的列）。`Ext.data.field.Field`
    类代表每个字段。每个字段都可以有 `name` 属性，也可以有 `type` 属性。可用的类型有 `string`、`int`、`number`、`boolean`、`date`
    和 `auto`（当未定义类型时，在这种情况下，字段不会尝试将值转换为任何默认类型）。`text` 和 `iconCls` 字段的类型为 `auto`。
- en: 'Every Model needs a field that works as its unique identifier. In this case,
    we are defining the field `id` (`#2`) as our unique field. If the unique identifier
    of the Model is not called `id`, we need to configure this information in the
    Model as well by using the `idProperty` configuration. For example, if our ID
    was named `accordionId`, we would declare it normally, and inside the Model, we
    would add `idProperty: ''accordionId''` so that the Model would know that the
    field is the identifier.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '每个模型都需要一个作为其唯一标识符的字段。在这种情况下，我们将字段 `id`（`#2`）定义为我们的唯一字段。如果模型的唯一标识符不是 `id`，我们需要使用
    `idProperty` 配置在模型中配置此信息。例如，如果我们的 ID 被命名为 `accordionId`，我们通常会声明它，并在模型内部添加 `idProperty:
    ''accordionId''`，这样模型就会知道该字段是标识符。'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Model` and `Field` classes also have other features. Please refer to them
    to see all their capabilities in the Ext JS documentation, which is very complete
    and full of examples. Please take a look at [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model)
    and [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model` 和 `Field` 类还有其他功能。请参考 Ext JS 文档中的它们，以查看所有功能，Ext JS 文档非常完整且充满示例。请查看
    [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model)
    和 [http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field)。'
- en: 'We also need a Model to represent the menu option, which consists of the Tree
    nodes of the TreePanel. To do so, we will declare the following Model:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个模型来表示菜单选项，它由 TreePanel 的树节点组成。为此，我们将声明以下模型：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `TreeNode` Model declared three fields present in the `NodeInterface` class,
    which are `id`, `text`, and `iconCls`. The `className` value is going to be used
    as `xtype` to instantiate the class that represents the screen of the menu option.
    We will talk more about this later. Then, we have the `parent_id` field. In the
    JSON, when we load data from the server, we will have the `menu_id` property instead
    of `parent_id`. We can use the `mapping` configuration to make this link (`#1`).
    This is nice because our Ext JS models do not need to be exactly like what is
    coming from the server (but it makes our life easier if they are the same).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeNode` 模型声明了三个在 `NodeInterface` 类中存在的字段，它们是 `id`、`text` 和 `iconCls`。`className`
    值将被用作 `xtype` 来实例化表示菜单选项屏幕的类。我们稍后会更多地讨论这个问题。然后，我们有 `parent_id` 字段。在 JSON 中，当我们从服务器加载数据时，我们将有
    `menu_id` 属性而不是 `parent_id`。我们可以使用 `mapping` 配置来建立这个链接（`#1`）。这很好，因为我们的 Ext JS
    模型不需要与从服务器来的数据完全相同（但如果它们相同，这会使我们的生活更轻松）。'
- en: Working with the hasMany association
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 hasMany 关联一起工作
- en: There are two different ways of working with associations in Ext JS. The first
    one is using `Ext.data.association.Association` introduced in Ext JS 4\. And the
    second one is using the `reference` configuration introduced in Ext JS 5\. Ext
    JS 5 maintains backwards compatibility with the Model associations from Ext JS
    4, although these Ext JS 4 features are marked as legacy code in the sources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 中处理关联有两种不同的方式。第一种是使用在 Ext JS 4 中引入的 `Ext.data.association.Association`。第二种是使用在
    Ext JS 5 中引入的 `reference` 配置。尽管 Ext JS 4 的这些功能在源代码中被标记为遗留代码，但 Ext JS 5 与 Ext JS
    4 的模型关联保持向后兼容。
- en: In this example, we are going to use the hasMany association introduced in Ext
    JS 4\. Later in this book, we will see another example using `reference`, and
    we will be able to compare the difference and choose when to use one or the other.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Ext JS 4中引入的`hasMany`关联。在本书的后面部分，我们将看到另一个使用`reference`的例子，我们将能够比较两者的区别并选择何时使用其中一个。
- en: 'To use the hasMany association, inside the `Accordion` Model, we first need
    to add the `hasMany` configuration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`hasMany`关联，我们首先需要在`Accordion`模型中添加`hasMany`配置：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that a new field named `items` (`#1`) will be created for the `Accordion`
    Model. For each instance of the `Accordion` Model, a method named `items()` will
    also be available to retrieve the `TreeNode` Model instances.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着将为`Accordion`模型创建一个名为`items` (`#1`)的新字段。对于`Accordion`模型的每个实例，也将有一个名为`items()`的方法可用于检索`TreeNode`模型实例。
- en: 'We cannot forget to add the `requires` declaration to the beginning of the
    `Accordion` Model as well, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记在`Accordion`模型的开头添加`requires`声明，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating the store-loading menu from the server
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器创建存储加载菜单
- en: 'Now that we have the Model defined, we can move on and create the Store. We
    will create a new class named `Packt.store.Menu`, so we need to create a new file
    named `Menu.js` under the `app/store` folder with the following content:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了模型，我们可以继续创建存储。我们将创建一个名为`Packt.store.Menu`的新类，因此我们需要在`app/store`文件夹下创建一个名为`Menu.js`的新文件，其内容如下：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are two important things we need to declare in the Store: the `model`
    and the `proxy` properties. The `model` tells the Store what type of data the
    Store needs to load from the server (or client storages), and the `proxy` tells
    the Store how and where to get the data.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储中，我们需要声明两个重要属性：`model`和`proxy`。`model`告诉存储需要从服务器（或客户端存储）加载什么类型的数据，而`proxy`告诉存储如何以及在哪里获取数据。
- en: This Store is going to use the model `Packt.model.` (`#2`). Instead of using
    the `model` configuration, it is also possible to declare the fields directly
    inside the Store using the `fields` configuration (it would be a copy from `fields`
    from the Model). In this case, the Store would use a so-called "anonymous model".
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储将使用模型`Packt.model.` (`#2`)。除了使用`model`配置外，还可以直接在存储中使用`fields`配置声明字段（它将是从模型复制过来的`fields`）。在这种情况下，存储将使用所谓的“匿名模型”。
- en: 'The Store is going to communicate with the server through the proxy using an
    Ajax request to the provided `url`. The `reader` (`#5`) tells the proxy how to
    decode the information from the server and transform it into a collection of the
    specified models. This Store is expecting a JSON format with `rootProperty` (known
    in Ext JS 4 as `root`) named `data`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 存储将通过代理使用Ajax请求与提供的`url`通信。`reader` (`#5`)告诉代理如何从服务器解码信息并将其转换为指定模型的集合。这个存储期望一个具有`rootProperty`（在Ext
    JS 4中称为`root`）名为`data`的JSON格式，如下所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because we declare the associations in the previous topic, the Store knows how
    to decode a nested JSON and create the respective Model instances.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前面的主题中声明了关联，存储知道如何解码嵌套的JSON并创建相应的模型实例。
- en: And, of course, exceptions can occur! For this reason, we can add `exception`
    `listener` (`#6`) in `proxy` so that we can display an error message to the user.
    As we are using the `Util` class we created, we also need to add this class in
    the `requires` declaration (`#1`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可能发生异常！因此，我们可以在`proxy`中添加`exception` `listener` (`#6`)，以便我们可以向用户显示错误消息。由于我们正在使用我们创建的`Util`类，我们还需要在`requires`声明中添加这个类（`#1`）。
- en: We can listen to events from views and stores in the Controller; however, the
    Store does not have any exception event. For this reason, `listener` needs to
    be added directly to `proxy`. This is an optional step, but if an error occurs,
    nothing will happen in the UI (Ext JS will output an error message in the browser's
    console, but users do not use the application with the developer tools console
    opened). That is why it is a good practice to have `exception listener` declared
    inside every proxy we use. We will develop a more elegant approach, but for now,
    we will use it like this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控制器中监听视图和存储的事件；然而，存储没有任何异常事件。因此，需要直接在`proxy`中添加`listener`。这是一个可选步骤，但如果发生错误，UI中不会发生任何操作（Ext
    JS将在浏览器的控制台中输出错误消息，但用户不会使用带有开发者工具控制台打开的应用程序）。这就是为什么在每一个我们使用的代理中声明`exception listener`是一个好习惯。我们将开发一个更优雅的方法，但现在我们将这样使用它。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of declaring `proxy` inside the Store, we can declare it inside the
    Model. You can declare `proxy` in the place of your preference. However, if you
    declare `proxy` on the Model and on the Store, when using the Store's `sync()`
    method, it will call the `proxy` instance declared on the Store; else the Model's
    `proxy` will be used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Store 中而不是在 Model 中声明 `proxy`。您可以在您偏好的位置声明 `proxy`。然而，如果您在 Model 和 Store
    上声明 `proxy`，当使用 Store 的 `sync()` 方法时，它将调用 Store 上声明的 `proxy` 实例；否则将使用 Model 的
    `proxy`。
- en: Now that we know the data format that we need to retrieve from the server, let's
    implement it!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了需要从服务器检索的数据格式，让我们来实现它！
- en: Handling the dynamic menu on the server
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理服务器上的动态菜单
- en: 'As we declared on the `Packt.store.Menu` Store, we need to create a new file
    named `menu/list.php` under the `php` folder. The following is the programming
    logic that we need to follow:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `Packt.store.Menu` 商店中声明的，我们需要在 `php` 文件夹下创建一个名为 `menu/list.php` 的新文件。以下是我们需要遵循的编程逻辑：
- en: Get the user that is logged in from the session.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从会话中获取已登录的用户。
- en: Open a connection with the database.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开与数据库的连接。
- en: Select the menu `id` instances from the `permission` table so that we know what
    permissions the user from the session has.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `permission` 表中选择菜单 `id` 实例，以便我们知道会话中的用户有什么权限。
- en: Select the modules that the user has permission to access—`menu_id` is `null`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用户有权限访问的模块——`menu_id` 为 `null`。
- en: For each module, select the nodes (menu options) that the user has access to.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个模块，选择用户可以访问的节点（菜单选项）。
- en: Encode the result in the JSON format and wrap it in the `data` root (as specified
    by the Store).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果编码为 JSON 格式，并将其包装在 `data` 根节点中（如商店所指定）。
- en: 'So let''s get our hands on the code. The following code was organized in functions,
    so we can organize the code exactly as listed in the preceding set of instructions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手编写代码。以下代码是按函数组织的，因此我们可以按照前面指令列表中的顺序组织代码：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As the code was organized in functions, let's create another file called `menuFunction.php`
    inside the `php/menu` folder as well. As we are going to code the functions inside
    this file, we need to require this file inside `menu/list.php` (`#1`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码是按函数组织的，让我们在 `php/menu` 文件夹内创建另一个名为 `menuFunction.php` 的文件。由于我们将在该文件中编写函数，我们需要在
    `menu/list.php` 中包含此文件（`#1`）。
- en: Then, we will get the user that is logged in to the session (`#2`). So we will
    get the entitlements for the user that is logged in, increasing the security a
    little bit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将获取会话中已登录的用户（`#2`）。因此，我们将获取已登录用户的权限，稍微提高一点安全性。
- en: Then, we will do as listed. For each function to which we open the connection
    with the database, we will retrieve the user's permissions (`#4`), then we will
    retrieve the modules the user has permission to access (`#5`), and then based
    on the module, we retrieve the menu options the user also has access to (`#6`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将按照以下步骤进行。对于每个我们与数据库建立连接的功能，我们将检索用户的权限（`#4`），然后检索用户有权限访问的模块（`#5`），然后根据模块，检索用户也有权限访问的菜单选项（`#6`）。
- en: At last, we will encode the result array in the JSON format (`#7`), and it is
    going to produce the JSON listed in the preceding topic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将结果数组以 JSON 格式（`#7`）进行编码，并将生成前述主题中列出的 JSON。
- en: Fetching the user permissions
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取用户权限
- en: 'Now, let''s dive into each function declared inside the `menuFunctions.php`
    file. The first one is the function used to retrieve the user''s permissions as
    listed here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解 `menuFunctions.php` 文件内部声明的每个函数。第一个是用于检索用户权限的函数，如下所示：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we will open the connection with the database (`#8`), and then we prepare
    the SQL query to get the `id` instances from the `menu` table that the user has
    access to (`#9`). We are using `JOIN` because the only information we have is
    `username`, and we need to pass through the `groups` table to get to the `permissions`
    table.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将打开数据库连接（`#8`），然后准备 SQL 查询以获取用户有权限访问的 `menu` 表中的 `id` 实例（`#9`）。我们使用 `JOIN`
    是因为我们拥有的唯一信息是 `username`，我们需要通过 `groups` 表到达 `permissions` 表。
- en: We execute the SQL query (`#10`), and we create an array with the menu `id`
    that the user has permission to use (`#11`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行 SQL 查询（`#10`），并创建一个包含用户有权限使用的菜单 `id` 的数组（`#11`）。
- en: In the end, we free the result set (`#12`), close the database connection (`#13`),
    and we return the `permissions` array (`#14`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们释放结果集（`#12`），关闭数据库连接（`#13`），并返回 `permissions` 数组（`#14`）。
- en: Fetching the modules the user is entitled to
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取用户有权访问的模块
- en: 'Now let''s take a look at the function that will retrieve the modules based
    on users'' permissions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看根据用户权限检索模块的功能：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To be able to retrieve the modules the user has access to, we need to know what
    modules (records from the `menu` table that do not have a `menu_id` parent menu)
    the user has permission to access. In our SQL query (`#16`), there is an `IN`
    clause to fetch all modules. As we have the `permissions` array, we can use the
    `join` PHP function (`#15`) that will return a string with all the array values
    separated by the "`,`" delimiter we informed. Then, we concatenate with "`( )`"
    and we are good to go.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够检索用户可以访问的模块，我们需要知道用户有权访问哪些模块（来自 `menu` 表且没有 `menu_id` 父菜单的记录）。在我们的 SQL 查询中（`#16`），有一个
    `IN` 子句用于检索所有模块。因为我们有 `permissions` 数组，我们可以使用 `join` PHP 函数（`#15`），它将返回一个由我们告知的
    "`,`" 分隔符分隔的所有数组值的字符串。然后，我们将它与 "`( )`" 连接起来，我们就准备好了。
- en: The next step is executing the SQL query (`#17`), and with the results from
    the database, we create an array with the `modules` that the user has access to,
    and at the end of the function, we return this information (`#18`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是执行 SQL 查询（`#17`），然后使用数据库的结果创建一个包含用户可以访问的 `modules` 的数组，并在函数末尾返回这个信息（`#18`）。
- en: The `modules` variable represents the `Accordion Model` class we created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules` 变量代表我们创建的 `Accordion Model` 类。'
- en: Fetching the menu options based on modules and permissions
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据模块和权限检索菜单选项
- en: 'After we have retrieved the `permissions` and `modules` the user has access
    to, it is time to retrieve the last piece to create the data for the dynamic menu,
    which is retrieving the menu options. The code is presented as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到用户可以访问的 `permissions` 和 `modules` 之后，是时候检索创建动态菜单数据的最后一部分，即检索菜单选项。代码如下所示：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For each `module` that the user has access to (`#2`), we will retrieve the menu
    options (`#3`). To do so, we need the ID of the module and also the `permissions`
    (`#1`). As each module might have several menu options, a user might not have
    permission to access all of them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户可以访问的每个 `module`（`#2`），我们将检索菜单选项（`#3`）。为此，我们需要模块的 ID 和 `permissions`（`#1`）。由于每个模块可能有多个菜单选项，用户可能没有权限访问所有这些选项。
- en: Next, we execute the query (`#4`) and retrieve the number of records returned
    by the database (`#5`). If this number is positive (`#6`), we create the `items`
    array ((`#7`), the `hasMany` association) and we fetch each item adding it to
    the `module['items']` array (`#8`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行查询（`#4`）并检索数据库返回的记录数（`#5`）。如果这个数字是正数（`#6`），我们创建 `items` 数组（`#7`），即 `hasMany`
    关联，并获取每个项目，将其添加到 `module['items']` 数组中（`#8`）。
- en: Each `$item` variable inside `module['items']` represents the `TreeNode` model.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`module[''items'']` 内的每个 `$item` 变量代表 `TreeNode` 模型。'
- en: At the end of it, we add `$item` to the `result` variable (`#9`) and return
    it (`#10`). This `result` variable is the one that will be wrapped inside the
    `data` root and encoded as JSON to be returned to Ext JS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `$item` 添加到 `result` 变量中（`#9`）并返回它（`#10`）。这个 `result` 变量是会被包裹在 `data`
    根节点内，并编码为 JSON 格式以返回给 Ext JS 的。
- en: The database for the `menu` fits perfectly to what Ext JS needs. We designed
    the `menu` table according to Ext JS expectations, and in a way that would be
    easier for us to retrieve the information. The preceding server-side code also
    fits perfectly to what Ext JS needs. Unless we have the chance to design the database
    ourselves in a project that we are starting from scratch, we will probably have
    a different design; therefore, the server-side code to retrieve the information
    will be a little different too. There is no problem at all. It does not matter
    how the database looks or the server-side code you need to write to retrieve the
    information. However, Ext JS is expecting a specific format to be sent back to
    the frontend code, and unfortunately, we need to send the information in this
    specific format (the JSON listed before). If the information we retrieved from
    the database is not in the format that Ext JS expects (the same format as our
    preceding code), all we need to do is parse and transform it, which means there
    will be an extra step in our server-side code before we send it back to Ext JS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`menu`数据库与Ext JS的需求完美匹配。我们根据Ext JS的期望设计了`menu`表，并且以一种对我们来说更容易检索信息的方式。前面的服务器端代码也完美地符合Ext
    JS的需求。除非我们有在从头开始的项目中自己设计数据库的机会，否则我们可能有一个不同的设计；因此，检索信息的服务器端代码也会略有不同。完全没有问题。数据库看起来如何或你需要编写什么服务器端代码来检索信息都无关紧要。然而，Ext
    JS期望以特定的格式将信息发送回前端代码，不幸的是，我们需要以这种特定格式（前面列出的JSON）发送信息。如果我们从数据库检索到的信息不是Ext JS期望的格式（与前面代码相同的格式），我们只需要解析和转换它，这意味着在我们的服务器端代码在将其发送回Ext
    JS之前将有一个额外的步骤。'
- en: Creating the menu with the Accordion layout and TreePanel
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用折叠布局和树面板创建菜单
- en: 'We can go back to the Ext JS code and start implementing the dynamic menu View
    component now. First, we need to create a new folder under `app/view/menu` and
    create a new file named `Accordion.js`, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到Ext JS代码中，现在开始实现动态菜单视图组件。首先，我们需要在`app/view/menu`下创建一个新文件夹，并创建一个名为`Accordion.js`的新文件，如下所示：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class is going to be a panel and it is going to wrap the TreePanels that
    will be the menus. It is going to use the Accordion layout (`#3`); this way, the
    user can expand or collapse the desired module. As the default behavior, all modules
    will be expanded (`#4`). If only the first module should be expanded at a time,
    we can comment line `#4`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将是一个面板，它将包裹作为菜单的TreePanels。它将使用折叠布局（`#3`）；这样，用户可以展开或折叠所需的模块。默认行为是所有模块都将展开（`#4`）。如果一次只应该展开一个模块，我们可以注释掉`#4`行。
- en: As we are going to use this class in the `west` region of the `Main` class,
    we are going to declare `xtype` (`#1`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在`Main`类的`west`区域使用这个类，我们将声明`xtype`（`#1`）。
- en: 'Be very careful when declaring `xtype`. Always remember to create a unique
    `xtype` and not any that is already being used by Ext JS components. For example,
    let''s say there is an `xtype` property you might want to use, but if we go to
    the documentation and use the quick search, we will see this `xtype` property
    is already in use by Ext JS, as shown below:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明`xtype`时非常小心。始终记得创建一个唯一的`xtype`，而不是任何已经被Ext JS组件使用的`xtype`。例如，假设有一个你可能想要使用的`xtype`属性，但如果我们去文档中快速搜索，我们会看到这个`xtype`属性已经被Ext
    JS使用，如下所示：
- en: '![Creating the menu with the Accordion layout and TreePanel](img/0457OT_05_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用折叠布局和树面板创建菜单](img/0457OT_05_05.jpg)'
- en: As this panel will be rendered in the `west` region, we need to set a `width`
    (`#2`)—remember that whenever we are using the Border layout, we need to specify
    a `width` for the `west` and `east` regions. We will also allow the user to resize
    the `west` region (`#4`) and collapse (`#3`) so that there is more space for the
    screen in the center.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此面板将在`west`区域渲染，我们需要设置一个`width`（`#2`）——记住，无论何时我们使用Border布局，都需要为`west`和`east`区域指定一个`width`。我们还将允许用户调整`west`区域的尺寸（`#4`）并折叠（`#3`），以便为中心屏幕腾出更多空间。
- en: 'At last, to prettify, we are declaring a Font Awesome icon (`#5`) and a `title`
    property (`#6`). We cannot forget to add the following entry in the `locale/en.js`
    file and its translations:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了美化，我们声明了一个Font Awesome图标（`#5`）和一个`title`属性（`#6`）。我们绝不能忘记在`locale/en.js`文件中添加以下条目及其翻译：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can get the Spanish and Portuguese translations by downloading the source
    code bundle from this book or downloading from the GitHub repository [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从本书下载源代码包或从 GitHub 仓库 [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs)
    下载来获取西班牙语和葡萄牙语的翻译。
- en: 'Next, we need to create a TreePanel to represent each module. We will create
    a new class named `Packt.view.menu.Tree`; therefore, we need to create a new file
    named `Tree.js` under `app/view/menu`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 TreePanel 来表示每个模块。我们将创建一个名为 `Packt.view.menu.Tree` 的新类；因此，我们需要在
    `app/view/menu` 下创建一个名为 `Tree.js` 的新文件：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class is a TreePanel. We do not want a `border` property for our module,
    and the `root` property will not be visible. As we can see, we are not setting
    many attributes. We will set the missing information dynamically on the Controller.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是一个 TreePanel。我们不想为我们的模块设置 `border` 属性，并且 `root` 属性将不可见。正如我们所看到的，我们没有设置很多属性。我们将在控制器上动态设置缺失的信息。
- en: 'The last step is going back to the `Main` class and adding `Accordion` to the
    `west` region. To do so, first we cannot forget to add the class `''Packt.view.menu.Accordion''`
    to `requires` and change the `west` region code to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是回到 `Main` 类，并将 `Accordion` 添加到 `west` 区域。要做到这一点，首先我们不能忘记将类 `'Packt.view.menu.Accordion'`
    添加到 `requires` 中，并将 `west` 区域代码更改为以下内容：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We removed all the configurations (`width`, `split`) and replaced `xtype` with
    `menu.Accordion`. When we execute the application, we will be able to see the
    `west` region with a panel now. The creation of the dynamic menu is pending though,
    and we will take care of it next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了所有配置（`width`，`split`）并将 `xtype` 替换为 `menu.Accordion`。当我们执行应用程序时，我们将能够看到现在有一个面板的
    `west` 区域。动态菜单的创建仍在等待中，我们将在下一步处理它。
- en: Creating the menu Controller
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建菜单控制器
- en: 'We already have all the views, models, and stores and also have the server-side
    covered. Now the only thing left is to implement the Controller, which is where
    all the magic will happen. So, let''s go ahead and create a new file named `Menu.js`
    under the `app/controller` folder:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有的视图、模型和存储，并且也覆盖了服务器端。现在唯一剩下的事情就是实现控制器，这是所有魔法发生的地方。所以，让我们继续创建一个名为 `Menu.js`
    的新文件，位于 `app/controller` 文件夹下：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the MVC approach, all controllers are created inside the `app/controller`
    folder, while in the MVVM approach, ViewController is created in the same folder
    as the View.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 方法中，所有控制器都创建在 `app/controller` 文件夹内，而在 MVVM 方法中，ViewController 创建在视图相同的文件夹中。
- en: The `init` function is called when the application boots, and it is called before
    the application's `launch` function is. We can use this function to execute any
    logic before the first View (`Login` or Viewport) is created. Inside this function
    is also the place where we want to set up the events we want this Controller to
    listen to using the `control` function (`#1`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，会调用 `init` 函数，并且它会在应用程序的 `launch` 函数之前被调用。我们可以使用这个函数在第一个视图（`Login`
    或视口）创建之前执行任何逻辑。在这个函数内部也是我们想要设置控制器要监听的事件的地方，使用 `control` 函数（`#1`）。
- en: In this Controller, we want to listen to two events. The first one is we want
    to render the dynamic menu (`#4`) when the Viewport (`Main` class) has been rendered.
    The second one is whenever the user clicks on a menu option (a node from the TreePanel—`#2`),
    we want to open the screen inside the center panel (#3).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，我们想要监听两个事件。第一个事件是当视口（`Main` 类）被渲染后，我们想要渲染动态菜单（`#4`）。第二个事件是无论用户点击菜单选项（来自
    TreePanel 的节点——`#2`），我们想要在中心面板（#3）内打开屏幕。
- en: 'To listen to an event inside the `control` method, we need to define three
    things: the selector, the event we want the Controller to listen to, and the method
    to be executed. It has the following format:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `control` 方法中监听一个事件，我们需要定义三件事：选择器、控制器要监听的事件以及要执行的方法。它具有以下格式：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finding the selector is the most challenging part. The scope in this case is
    not the View as in the ViewController, but the application. For selectors, we
    usually use the `xtype` component. It helps when it is an `xtype` component we
    created for the application and not an Ext JS `xtype` such as `'tree'`; for example,
    `'menutree'` is much better because we narrow down the possibilities (there might
    be several TreePanels within the application, but we know that only the TreePanels
    from the dynamic menu have `menutree` as `xtype`). We have to remember that if
    we use the selector `'tree'` (`xtype` for TreePanel), the Controller will listen
    to the event from all TreePanels of the application, so it is good to be as specific
    as we can be.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 找到选择器是最具挑战性的部分。在这个例子中，范围不是视图（ViewController中的View），而是应用程序。对于选择器，我们通常使用`xtype`组件。当它是一个为应用程序创建的`xtype`组件，而不是Ext
    JS的`xtype`（例如`'tree'`）时，它很有帮助；例如，`'menutree'`更好，因为我们缩小了可能性（应用程序中可能有多个TreePanels，但我们知道只有动态菜单中的TreePanels的`xtype`是`menutree`）。我们必须记住，如果我们使用选择器`'tree'`（TreePanel的`xtype`），控制器将监听应用程序中所有TreePanels的事件，所以最好尽可能具体。
- en: We can listen to as many events from a selector as we want to. We simply need
    to separate the events by a "`,`".
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以监听来自选择器的任意多个事件。我们只需要用“`,`”分隔事件即可。
- en: 'For example, let''s implement the `renderDynamicMenu` method first. We use
    `mainmenu` as the selector. This is the `xtype` component for the `view.menu.Accordion`
    class, which is being rendered in the `west` region of the `Main` class (Viewport).
    So, when this component is rendered, the Controller is going to execute the `renderDynamicMenu`
    method. Let''s declare this method inside the `Menu` Controller:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们首先实现`renderDynamicMenu`方法。我们使用`mainmenu`作为选择器。这是`view.menu.Accordion`类的`xtype`组件，它正在`Main`类的`west`区域（Viewport）中被渲染。所以，当这个组件被渲染时，控制器将执行`renderDynamicMenu`方法。让我们在`Menu`控制器中声明这个方法：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can always start the implementation of an event listener in the Controller
    by adding a `console.log` or `alert` message to make sure the method is being
    executed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在控制器中添加`console.log`或`alert`消息来始终从控制器开始实现事件监听器的实现，以确保该方法正在执行。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to always go to the documentation to verify the parameters that are
    being passed to the event so that we can declare them. For the `render` event,
    it is usually the component itself and `options`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，始终去查阅文档以验证传递给事件的参数，这样我们才能声明它们。对于`render`事件，通常是组件本身和`options`。
- en: 'Let''s declare `onTreePanelItemClick` as well so that we can test this Controller:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明`onTreePanelItemClick`，这样我们就可以测试这个控制器：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The method signature is enough so that we do not get any errors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名已经足够，我们不会得到任何错误。
- en: 'We need to add this Controller in `Application.js` as well. So, go back to
    `Application.js` and add the highlighted code shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`Application.js`中添加这个控制器。所以，回到`Application.js`并添加以下突出显示的代码：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we execute the application, we will get the output as shown in the following
    screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们将得到以下截图所示的输出：
- en: '![Creating the menu Controller](img/0457OT_05_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![创建菜单控制器](img/0457OT_05_06.jpg)'
- en: This means that it is working as we expect. Do not worry about the other warning
    messages; we will take care of them later in this book (the important thing is
    not getting error messages).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它正在按预期工作。不要担心其他警告信息；我们将在本书的后面部分处理它们（重要的是不要出现错误信息）。
- en: So let's go ahead and add the required business logic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续添加所需的业务逻辑。
- en: Rendering the menu from nested JSON (the hasMany association)
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从嵌套JSON（hasMany关联）渲染菜单
- en: 'We need to add the logic that will be responsible for creating the dynamic
    menu with the information that will be received from the server. We will add the
    following code inside the `renderDynamicMenu` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加负责创建包含从服务器接收的信息的动态菜单的逻辑。我们将在`renderDynamicMenu`方法中添加以下代码：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we are going to do is create an empty array so that we can add
    all the modules to it (`#1`). As we are going to make a request to the server
    and as initially the menu in the `west` region is going to be empty, it is nice
    to add a loading message (`#2`) just in case there is any delay with the server
    response (*Ajax is asynchronous*). The `view` was passed as a parameter to the
    event and is a reference to the `Packt.view.menu.Accordion` class instance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是创建一个空数组，以便我们可以将所有模块添加到其中（#1）。由于我们将向服务器发出请求，并且最初 `west` 区域中的菜单将是空的，因此添加一个加载消息（#2）以备不时之需是个不错的选择，以防服务器响应有任何延迟（*Ajax
    是异步的*）。`view` 作为参数传递给事件，是对 `Packt.view.menu.Accordion` 类实例的引用。
- en: 'Then, we need to load the `Menu` Store (`#3`), which is responsible for loading
    the nested JSON from the server (`#1`). Note that we are using `this.getMenuStore()`
    to retrieve the Store, which means this is a method from the Controller. We need
    to declare the `menu` Store inside the `stores` configuration in the Controller
    so that it will generate this method for us:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要加载 `Menu` Store（#3），它负责从服务器加载嵌套的 JSON（#1）。注意，我们使用 `this.getMenuStore()`
    来检索 Store，这意味着这是一个来自 Controller 的方法。我们需要在 Controller 的 `stores` 配置中声明 `menu` Store，这样它就会为我们生成这个方法：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, there is no need to declare the complete name of the Store—only
    what is after `'Packt.store'`. Because of the MVC architecture, Ext JS knows that
    it needs to look for a file named `Menu.js` inside the `app/store` folder. As
    the name of the Store is `Menu`, the Controller will generate a method named `get`
    + `Menu` + `Store` (`getMenuStore`) once the Store is loaded (that is why we are
    going to handle the creation of the dynamic menu inside the load callback). For
    each `record` returned from the Store (`#4`), we will create a TreePanel (`Packt.view.menu.Tree`—`#5`)
    to represent each module. We will set the `title` property (getting the `title`
    property from the locale file `(#6`). In the database, we will store the key from
    the `en.js` file in the column `text` and set `iconCls` (`#7`) for it to look
    prettier (a Font Awesome icon).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，没有必要声明 Store 的完整名称——只需 `''Packt.store''` 后面的部分即可。由于采用了 MVC 架构，Ext JS
    会知道它需要在 `app/store` 文件夹内查找名为 `Menu.js` 的文件。由于 Store 的名称是 `Menu`，一旦 Store 被加载，Controller
    将会生成一个名为 `get` + `Menu` + `Store`（即 `getMenuStore`）的方法（这就是为什么我们要在加载回调中处理动态菜单的创建）。对于
    Store 返回的每个 `record`（即 #4），我们将创建一个 TreePanel（`Packt.view.menu.Tree`——#5）来表示每个模块。我们将设置
    `title` 属性（从本地化文件中获取 `title` 属性——#6）。在数据库中，我们将 `en.js` 文件中的键存储在 `text` 列中，并设置
    `iconCls`（#7）以使其看起来更美观（一个 Font Awesome 图标）。'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Ext.create or Ext.widget**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ext.create 或 Ext.widget**'
- en: In [Chapter 2](ch02.html "Chapter 2. Getting Started"), *Getting Started*, when
    we instantiated a class for the first time in this book, we discussed the options
    we can use when we need to instantiate a `component` class. Just to remind you,
    we can use `Ext.create` passing the complete name of the class as an argument,
    or we can use `Ext.widget` passing the class alias as an argument (there are other
    ways as well, but these two are more commonly used). It is a matter of preference,
    but you can use any of the ways we mentioned in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "Chapter 2. Getting Started"，"入门") 中，*入门*，当我们在这本书中第一次实例化一个类时，我们讨论了在需要实例化一个
    `component` 类时我们可以使用的选项。只是为了提醒你，我们可以使用 `Ext.create` 并传递类的完整名称作为参数，或者我们可以使用 `Ext.widget`
    并传递类别名作为参数（还有其他方法，但这两个更常用）。这是一个个人喜好问题，但你可以使用我们在 [第 2 章](ch02.html "Chapter 2. Getting
    Started"，"入门") 中提到的任何方法，*入门*。
- en: So, with this code, we are able to display each TreePanel representing each
    of the modules (with no menu option). The next step is getting the data to display
    inside the TreePanel. This data is available in the JSON already through the `hasMany`
    association we configured. Because of the `hasMany` association, a method named
    `items` (`name` of the association we configured) will be created for each Model
    instance inside the Store. The `items` method returns a Store with the `hasMany`
    data in it (`#8`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这段代码，我们能够显示代表每个模块的每个 TreePanel（没有菜单选项）。下一步是获取要在 TreePanel 中显示的数据。这些数据已经通过我们配置的
    `hasMany` 关联在 JSON 中可用。由于 `hasMany` 关联，Store 中的每个 Model 实例内部将创建一个名为 `items`（即我们配置的关联的
    `name`）的方法。`items` 方法返回一个包含 `hasMany` 数据的 Store（#8）。
- en: 'When we are not sure whether the method was created or not, we can always inspect
    the Model instance in the console. For example, if we output `console.log(this)`
    inside the `load` callback, we will get the Store outputted in the browser''s
    console. Inspect the `data` configuration, and inside the `data` configuration,
    we will find `items`, which contains the Model collection as shown in the following
    screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不确定方法是否被创建时，我们总是可以在控制台中检查Model实例。例如，如果我们想在`load`回调中输出`console.log(this)`，我们将在浏览器控制台中看到Store的输出。检查`data`配置，在`data`配置中，我们将找到`items`，它包含如以下截图所示的Model集合：
- en: '![Rendering the menu from nested JSON (the hasMany association)](img/0457OT_05_07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![从嵌套JSON渲染菜单（hasMany关联）](img/0457OT_05_07.jpg)'
- en: For each `Packt.model.menu.TreeNode` Model instance from the Store (`#9` and
    `#10`), we will push a new node (`#11`) into an array. When adding the new node,
    we set the `text` and `leaf` (`#12`) that are properties from the `NodeInterface`
    class. We are adding `id` and `className` that are not part of the `NodeInterface`
    class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从Store（`#9`和`#10`）中获取的每个`Packt.model.menu.TreeNode` Model实例，我们将一个新节点（`#11`）推入一个数组。在添加新节点时，我们设置来自`NodeInterface`类的`text`和`leaf`（`#12`）属性。我们添加了不是`NodeInterface`类一部分的`id`和`className`。
- en: To add all the nodes created, we need access to the `Root` node of the TreePanel.
    As `Root` is also a node (decorated with the `NodeInterface` class), it has a
    method called `appendChild`, which can be used to append nodes to a specific node
    (in this case, `Root`). So, we add all the nodes we created at once (`#14`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加所有创建的节点，我们需要访问TreePanel的`Root`节点。由于`Root`也是一个节点（装饰了`NodeInterface`类），它有一个名为`appendChild`的方法，可以用来将节点追加到特定的节点（在这种情况下，`Root`）。因此，我们一次性添加我们创建的所有节点（`#14`）。
- en: To avoid many changes in the DOM, which is not a good practice, we are going
    to create an array with all the menus we created (`#15`). And then, we will add
    all the menus at once (`#16`) to the `Accordion` panel (this will avoid browser
    reflow).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在DOM中进行许多更改，这不是一个好的做法，我们将创建一个包含我们创建的所有菜单的数组（`#15`）。然后，我们将一次性将所有菜单添加到`Accordion`面板中（这将避免浏览器重排）。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Minimizing browser reflow is a technique used to increase performance. We could
    do the insertions inside the loops, but this would increase DOM manipulation,
    which is very expensive. With simple changes in the code to add whatever needs
    to be added at once, we can increase the performance a little bit. For more information,
    please visit [https://developers.google.com/speed/articles/reflow](https://developers.google.com/speed/articles/reflow).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化浏览器重排是一种提高性能的技术。我们可以在循环内部进行插入操作，但这会增加DOM操作，而这是非常昂贵的。通过在代码中进行简单的更改，一次性添加所有需要添加的内容，我们可以略微提高性能。更多信息，请访问[https://developers.google.com/speed/articles/reflow](https://developers.google.com/speed/articles/reflow)。
- en: At last, we remove the `mask` from the `Accordion` menu (`#17`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从`Accordion`菜单中移除`mask`（`#17`）。
- en: If we execute the code, the menu will be rendered.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行代码，菜单将被渲染。
- en: Using glyphs in TreePanel – working with overrides
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在TreePanel中使用glyphs – 使用覆盖
- en: There was a piece from the code that we did not cover in the previous topic,
    which is line `#13`, the `glyph` configuration in the node. We know that we can
    use icon fonts, such as Font Awesome, with Ext JS, but the support is still limited.
    It is not possible to use Font Awesome icons in TreePanel nodes. However, there
    is an override we can use that will allow us to do that.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中没有涵盖代码的一部分，即行`#13`中的节点`glyph`配置。我们知道我们可以使用像Font Awesome这样的图标字体与Ext JS一起使用，但支持仍然有限。在TreePanel节点中无法使用Font
    Awesome图标。然而，有一个覆盖可以让我们做到这一点。
- en: 'This is the first time we are mentioning the term **glyph** in this book. It
    is basically the same thing as the font icon we have been using until now, but
    it has an alternative configuration for it. For example, we used a key icon in
    the `Login` class, and we set `iconCls` as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中第一次提到**glyph**这个术语。它基本上与我们至今使用的字体图标相同，但它有一个替代配置。例如，我们在`Login`类中使用了键图标，并将`iconCls`设置为如下：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We could have used the `glyph` configuration instead as an alternative:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`glyph`配置作为替代方案：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code could also be written as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码也可以写成如下形式：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But we need to configure the `glyphFontFamily` configuration inside the `Packt.Application`
    class in `Application.js`, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们需要在`Application.js`中的`Packt.Application`类内部配置`glyphFontFamily`配置，如下所示：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And then, we can remove `'@FontAwesome'` from the `glyph` configuration.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从 `glyph` 配置中移除 `'@FontAwesome'`。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Font Awesome provides a cheat sheet with the CSS names and glyph codes at [http://fortawesome.github.io/Font-Awesome/cheatsheet/](http://fortawesome.github.io/Font-Awesome/cheatsheet/).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome 提供了一个包含 CSS 名称和符号代码的速查表，可以在[http://fortawesome.github.io/Font-Awesome/cheatsheet/](http://fortawesome.github.io/Font-Awesome/cheatsheet/)找到。
- en: The Font Awesome `iconCls` is not going to work for the Tree nodes, but as mentioned
    before, we can apply an override. An override is a way of changing the behavior
    of the Ext JS class. It would be similar to modifying the prototype of a JavaScript
    object—the new behavior is applied to all the instances of that class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome 的 `iconCls` 不会在树节点上工作，但如前所述，我们可以应用覆盖。覆盖是一种改变 Ext JS 类行为的方式。这类似于修改
    JavaScript 对象的原型——新的行为将应用于该类的所有实例。
- en: Even though Ext JS is open source, we should avoid changing the source code
    directly (despite the open source code philosophy). Changing the source code can
    be an issue when upgrading the framework version in the future. Using overrides
    is more elegant.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Ext JS是开源的，但我们应避免直接更改源代码（尽管开源代码哲学）。更改源代码可能在将来升级框架版本时成为一个问题。使用覆盖更为优雅。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The override we are going to use can be found at [http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels](http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的覆盖可以在[http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels](http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels)找到。
- en: We are going to create the override inside the file `app/overrides/tree/ColumnOverride.js`.
    We cannot forget to change the name of the override to `Packt.overrides.tree.ColumnOverride`
    (the first line of code).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在文件 `app/overrides/tree/ColumnOverride.js` 内创建覆盖。我们不要忘记将覆盖的名称更改为 `Packt.overrides.tree.ColumnOverride`（代码的第一行）。
- en: 'Then, inside `Application.js`, we are going to add the following code to make
    sure it is loaded when the application is loaded and the override is applied,
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Application.js`内部，我们将添加以下代码以确保在应用程序加载和覆盖应用时加载，如下所示：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can also add this `require` declaration inside the `Packt.view.menu.Tree`
    class to remind us that we are using an override as well, but it is optional.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `Packt.view.menu.Tree` 类内部添加此 `require` 声明，以提醒我们我们也在使用覆盖，但这不是必需的。
- en: 'This is what the `menu` table looks like at this moment. The modules have the
    Font Awesome CSS, and the menu options have the glyph codes (`iconCls` column),
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前 `menu` 表的样子。模块有 Font Awesome CSS，菜单选项有符号代码（`iconCls` 列），如下所示：
- en: '![Using glyphs in TreePanel – working with overrides](img/0457OT_05_08.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![在 TreePanel 中使用符号 – 使用覆盖](img/0457OT_05_08.jpg)'
- en: You can use only the glyph codes throughout the application. We are using both
    to show it is possible to use both. From now on, you can use the approach you
    prefer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个应用程序中，您只能使用符号代码。我们同时使用它们来展示这是可能的。从现在开始，您可以使用您喜欢的任何方法。
- en: Menu locale support
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 菜单区域支持
- en: 'We also need to add the keys to the `en.js` file (and other locale files as
    well). For the menu, these are the entries needed:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将键添加到 `en.js` 文件（以及其他区域文件）中。对于菜单，这些是需要条目：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the keys are the same entries as the `text` column from the `menu` table.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意键与 `menu` 表中的 `text` 列的条目相同。
- en: Opening a menu item programmatically
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以编程方式打开菜单项
- en: 'After the menu is rendered, the user will be able to select an option from
    it. The logic behind the method is: when the user selects an option from the menu
    we need to verify that the tab has already been created on the tab panel. If yes,
    we do not need to create it again; we only need to select the tab on the tab panel
    and make it active. If not, then we need to instantiate the screen selected by
    the user. To do so, the Controller will execute the following method:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单渲染后，用户将能够从中选择一个选项。该方法背后的逻辑是：当用户从菜单中选择一个选项时，我们需要验证标签页是否已经在标签面板上创建。如果是，我们不需要再次创建它；我们只需要在标签面板上选择标签并使其活动。如果不是，那么我们需要实例化用户选择的屏幕。为此，控制器将执行以下方法：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we need to get the reference of the tab panel (`#1`). We are using `this.getMainPanel()`,
    which was created by the Controller.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取标签面板的引用（`#1`）。我们使用 `this.getMainPanel()`，这是由控制器创建的。
- en: There are three ways of getting object references inside Controller methods.
    The first one is using the parameters passed to the method. The second one is
    using the `ComponentQuery` (that we have not discussed yet), and the third one
    is using `refs`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Controller方法中获取对象引用有三种方式。第一种是使用传递给方法的方法参数。第二种是使用`ComponentQuery`（我们尚未讨论），第三种是使用`refs`。
- en: 'For this example, we are going to use `refs`. We need to add the following
    code inside the Controller:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用`refs`。我们需要在Controller中添加以下代码：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can configure the selector we want the Controller to search for and the name
    of the reference. In this case, the Controller will create a method called `get`
    + `mainPanel` (in the `ref` name, the first letter becomes a capital letter) resulting
    in `getMainPanel`. This is equivalent to `reference` used by the ViewController.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置Controller要搜索的选择器和引用的名称。在这种情况下，Controller将创建一个名为`get` + `mainPanel`（在`ref`名称中，第一个字母变为大写）的方法，结果为`getMainPanel`。这相当于ViewController使用的`reference`。
- en: Then, we need to verify that the selected menu option was already created (`#2`),
    and we will do it comparing the tab `title` with the `text` configuration of the
    selected node (`#3`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要验证所选菜单选项是否已经创建（`#2`），我们将通过比较标签`title`与所选节点的`text`配置来完成此操作（`#3`）。
- en: If it is not a new tab, we will add it to the tab panel, passing as an instance
    to the `add` method (`#5`). So we will get the `xtype` configuration of the component
    we are going to add from the node `className` (`#6`), and the tab can be `closed`
    (`#7`); it will have the same `glyph` as its node (`#8`) and will also have the
    same `title` as the node (`#9`—menu option).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是新标签页，我们将将其添加到标签面板中，并将实例传递给`add`方法（`#5`）。因此，我们将从节点的`className`获取我们打算添加的组件的`xtype`配置（`#6`），标签可以`关闭`（`#7`）；它将具有与节点相同的`glyph`（`#8`）并且也将具有与节点相同的`title`（`#9`—菜单选项）。
- en: Then, we will set it as the active tab. If the screen is already rendered, we
    will only change the `active` tab to the screen that the user selected from the
    menu (`#10`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将将其设置为活动标签。如果屏幕已经渲染，我们只会将`active`标签更改为用户从菜单中选择的屏幕（`#10`）。
- en: The dynamic menu functionality is now complete!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 动态菜单功能现在已完成！
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement an advanced dynamic menu using
    an Accordion layout and also TreePanels for each module of the application. We
    learned how to handle the dynamic logic on the sever side and also how to handle
    its return on the Ext JS side loading a Store to build the menu dynamically. And
    finally, we have also learned how to open an item from the menu programmatically
    and display it on the center component of the application. We also used the MVC
    architecture for the first time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用折叠布局和为应用程序的每个模块使用TreePanels实现一个高级动态菜单。我们学习了如何在服务器端处理动态逻辑，以及如何在Ext
    JS端处理其返回值，通过加载Store动态构建菜单。最后，我们还学习了如何通过编程方式打开菜单项并在应用程序的中心组件上显示它。我们还首次使用了MVC架构。
- en: In the next chapter, we will learn how to implement screens to list, create,
    and update users and also how to assign a group to the user.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何实现列出、创建和更新用户以及如何将组分配给用户的屏幕。
