- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Compatibility with Existing Standards
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兼容现有标准
- en: Some frameworks attempt to simplify your work as a developer by providing you
    with tools and functionality to wrap around common tasks, such as making network
    requests or managing data submitted by forms. While the intentions are noble,
    this strategy can have unintended consequences. For instance, when learning a
    new framework, developers have to master all of its intricacies to be effective.
    Reading about *yet another way to make network requests* can slow developers down,
    as time spent reading documentation is time spent *not building*. It can also
    prevent code portability. When the code written for application *A* is specific
    to framework *X*, then the code will need to be modified before being reused in
    application *B*, which was built with framework *Y*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架试图通过为你提供工具和功能来简化你的开发工作，例如处理网络请求或管理表单提交的数据。虽然这种策略的意图是高尚的，但它可能产生意想不到的后果。例如，当学习一个新的框架时，开发者必须掌握其所有复杂性才能有效。阅读关于*另一种制作网络请求的方式*可能会减慢开发者的速度，因为阅读文档的时间就是没有在构建的时间。它也可能防止代码的可移植性。当为应用*A*编写的代码特定于框架*X*时，那么在将其用于使用框架*Y*构建的应用*B*之前，代码需要修改。
- en: SvelteKit has a solution to this, and that solution is to do nothing. Well,
    not *nothing*, but rather than providing you with wrappers and functions that
    will require you to look up the documentation each time you go to use one, SvelteKit
    encourages the use of existing Web **Application Programming Interfaces** (**APIs**)
    and standards. By not reinventing the wheel, more developers can get started with
    SvelteKit quickly, since they won’t have to learn abstractions for standards that
    they’re already familiar with. Not only does it keep time spent reading documentation
    to a minimum, but it also requires less code to power a framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SvelteKit针对这个问题有一个解决方案，那就是什么都不做。嗯，不是真的什么都不做，而是不提供需要你每次使用时查阅文档的包装器和函数，SvelteKit鼓励使用现有的Web
    **应用程序编程接口**（**APIs**）和标准。通过不重新发明轮子，更多的开发者可以快速开始使用SvelteKit，因为他们不需要学习他们已经熟悉的标准的抽象。这不仅将阅读文档的时间降到最低，而且还需要更少的代码来驱动框架。
- en: 'This chapter will cover some basic use cases of **Web APIs** and how they interact
    with SvelteKit. Specifically, we’ll look at these examples of current web standards:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些基本的**Web APIs**用法以及它们如何与SvelteKit交互。具体来说，我们将查看以下当前网络标准的示例：
- en: Fetch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取
- en: FormData
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FormData
- en: URL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL
- en: An in-depth dive into each of these standards is beyond the scope of this chapter,
    but if you’re looking for more information about them, resources will be provided
    at the end. After these examples, you should feel comfortable using your existing
    knowledge of various web standards with SvelteKit.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些标准的深入探讨超出了本章的范围，但如果你想了解更多信息，相关信息将在本章末尾提供。在这些示例之后，你应该能够舒适地使用你对各种网络标准的现有知识来使用SvelteKit。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter03](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter03).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter03](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter03)。
- en: Fetch
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fetch
- en: To begin, let’s take a look at one of the most commonly used Web APIs, `fetch`.
    Assuming your development environment is on the latest LTS version of Node.js
    (v18+), you’ll have access to `fetch` on the server without having to install
    an extra package such as `node-fetch`. That package was the most widely used package
    to deliver functionality, allowing developers to make network requests before
    `fetch` was incorporated into Node.js's core features. Since `fetch` is now also
    supported in every major browser, we can safely use it in both client- and server-side
    environments to make external and internal requests. Because SvelteKit can run
    in both a browser and server environment, it is safe to say that we have, in fact,
    “made fetch happen.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看最常用的Web APIs之一，`fetch`。假设你的开发环境运行在Node.js（v18+）的最新LTS版本上，你将无需安装额外的包如`node-fetch`就能在服务器上使用`fetch`。那个包是最广泛使用的包，它提供了功能，允许开发者在`fetch`被纳入Node.js的核心功能之前进行网络请求。由于`fetch`现在也支持每个主要浏览器，我们可以在客户端和服务器端环境中安全地使用它来发起外部和内部请求。因为SvelteKit可以在浏览器和服务器环境中运行，所以我们可以说，我们实际上“让fetch发生了。”
- en: To illustrate how fetch can work in both the browser and server, let’s take
    a look at an example. We’ll create a new route by adding the `src/routes/fetch/+page.svelte`
    file to serve as our demo page. We’ll also create `src/routes/fetch/+page.js`
    to get data from an actual `fetch` request. In this example, we’ll utilize NASA’s
    free *Astronomy Picture of the Day* API found at [https://api.nasa.gov/](https://api.nasa.gov/).
    It’s recommended to obtain an API key for regular use; however, the demonstration
    API key provided in the following examples will suffice for our purposes. This
    example makes a network request to the NASA API and shows the data received on
    our page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`fetch`在浏览器和服务器上如何工作，让我们看看一个例子。我们将通过添加`src/routes/fetch/+page.svelte`文件来创建一个新的路由，作为我们的演示页面。我们还将创建`src/routes/fetch/+page.js`来从实际的`fetch`请求中获取数据。在这个例子中，我们将利用位于[https://api.nasa.gov/](https://api.nasa.gov/)的NASA免费“每日天文图片”API。建议获取一个API密钥以供常规使用；然而，以下示例中提供的演示API密钥足以满足我们的需求。这个例子向NASA
    API发出网络请求，并在我们的页面上显示接收到的数据。
- en: 'Please note that the styles are by no means required and are only provided
    to make our example more digestible when viewed in the browser. We could add lots
    of styles and make this look fantastic, but that would take up more of our limited
    space on these pages. Plus, you’re here to learn about SvelteKit, not CSS:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，样式绝对不是必需的，只是提供以使我们的示例在浏览器中查看时更容易理解。我们可以添加很多样式，使这个例子看起来很棒，但这会占用我们在这页面上有限的更多空间。此外，你在这里是为了学习SvelteKit，而不是CSS：
- en: src/routes/fetch/+page.svelte
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/routes/fetch/+page.svelte`'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this file, we’re simply setting up the markup for our data to populate.
    To get access to the data provided by the sibling `+page.js` file, we *must* include
    `export let data;`. If you''re familiar with React or Vue, think of this as SvelteKit''s
    method for passing props between components. If you''re familiar with React of
    Vue, think of this as SvelteKit''s method for passing props between components.
    After doing that, we can use the data provided in the object to populate the image
    title, a link to the high-resolution file, a link to the externally hosted image,
    and show an image description. And, of course, we’ve added some minimal styles.
    The real magic, and our `fetch` request, happens in the next snippet for `+page.js`,
    where we make the call to the external API:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们只是设置了数据的标记，以便填充。要访问由兄弟文件`+page.js`提供的数据，我们必须包含`export let data;`。如果你熟悉React或Vue，可以将这视为SvelteKit在组件之间传递属性的方法。如果你熟悉React或Vue，可以将这视为SvelteKit在组件之间传递属性的方法。完成这些后，我们可以使用对象中提供的数据来填充图像标题、链接到高分辨率文件、链接到外部托管图像，并显示图像描述。当然，我们还添加了一些最小化样式。真正的魔法，以及我们的`fetch`请求，发生在下一个`+page.js`片段中，我们在那里调用外部API：
- en: src/routes/fetch/+page.js
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/routes/fetch/+page.js`'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In `+page.js`, we’ve created a constant where you can place your own API key.
    Then, we exported the `load` function, which is necessary to tell SvelteKit to
    run before rendering the sibling `+page.svelte` file. It can be `async` or not;
    SvelteKit doesn’t care and will handle each case accordingly. We then create the
    constant `pic`, to which we can assign the promise returned from the `fetch` call.
    In the `fetch` call, we provided the URL with an API key appended to it, as the
    first and only argument. If your API needed to have options specified in the header,
    a method set, or perhaps an authentication cookie, you could do so by providing
    that as an object in the second argument. Remember that SvelteKit aims to be compatible
    with the existing web standards, so the implementations will have at least the
    standardized functionality. See the resources at the end of this chapter for more
    information on how to utilize `fetch` in these ways.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`+page.js`中，我们创建了一个常量，你可以在这里放置你自己的API密钥。然后，我们导出了`load`函数，这是告诉SvelteKit在渲染兄弟文件`+page.svelte`之前必须运行的函数。它可以`async`也可以不是；SvelteKit并不关心，会相应地处理每种情况。然后我们创建了一个常量`pic`，我们可以将`fetch`调用返回的promise分配给它。在`fetch`调用中，我们提供了带有附加API密钥的URL，作为第一个也是唯一的参数。如果你的API需要在头部指定选项、设置方法或可能需要一个认证cookie，你可以通过在第二个参数中提供一个对象来实现。记住，SvelteKit旨在与现有的网络标准兼容，所以实现将至少包含标准化的功能。有关如何以这种方式利用`fetch`的更多信息，请参阅本章末尾的资源。
- en: Continuing with the promise received by the `fetch` call, we run `console.log()`
    to demonstrate that code is being run in both the browser and server environments.
    If your development environment isn’t yet running, you can start it with the `npm
    run dev` command. Remember that it will then be available in your browser at the
    provided URL. You can confirm this by checking your browser console output in
    your developer tools, as well as the output from your Vite development server
    in your terminal. In both cases, you should see the “*got response*” output displayed.
    Because our request didn’t require any authentication, it was safe for us to run
    on the client side.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`fetch`调用接收到的承诺，我们运行`console.log()`来演示代码在浏览器和服务器环境中都会运行。如果你的开发环境还没有运行，你可以使用`npm
    run dev`命令启动它。记住，它将在提供的URL中在浏览器中可用。你可以通过检查你的浏览器控制台输出（在开发者工具中）以及你的终端中的Vite开发服务器输出来确认这一点。在这两种情况下，你应该看到显示的“*收到响应*”输出。因为我们的请求不需要任何认证，所以在客户端运行是安全的。
- en: Finally, we convert the `load` functions, they run on both the server and browser.
    In the case of universal load functions, they *must* return an object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将转换`load`函数，这些函数在服务器和浏览器上都会运行。对于通用`load`函数，它们**必须**返回一个对象。
- en: Loading Data
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据
- en: We’ve established that code run from `+page.js` is actually run in both the
    browser and server. If we wanted the code to only be run on the client, we would
    place that in `+page.svelte`. Similarly, if we wanted this code to be run only
    on the server, then we could change the filename to `+page.server.js`. This second
    use case would be more suitable for making an authenticated database call or accessing
    environment variables, such as API keys (as we did in this previous example).
    SvelteKit will recognize that this file is intended to run only in the server
    environment and will take the appropriate steps to separate that logic. Server
    `load` functions also work slightly differently from universal `load` functions,
    but we’ll go into that in more depth in a later chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定从`+page.js`运行的代码实际上在浏览器和服务器上都会运行。如果我们想让代码只在客户端运行，我们就可以将其放在`+page.svelte`中。同样，如果我们想让这段代码只在服务器上运行，我们可以将文件名更改为`+page.server.js`。第二种用法更适合进行认证数据库调用或访问环境变量，例如API密钥（就像我们在之前的例子中所做的那样）。SvelteKit将识别这个文件是打算只在服务器环境中运行的，并将采取适当的步骤来分离该逻辑。服务器`load`函数与通用`load`函数的工作方式略有不同，但我们将更深入地探讨这一点，在后面的章节中。
- en: After doing all of this, we can now navigate to `/fetch` in our browser and
    see the image, its title, and a description, and even click on the image to view
    the full high-resolution file. It’s very helpful to make calls to various internal
    or external APIs, but our application will likely need to receive data from users
    at some point. In the next section, we’ll cover how we can access and manipulate
    `FormData` objects provided in `Requests`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些操作之后，我们现在可以在浏览器中导航到 `/fetch`，查看图片、标题和描述，甚至可以点击图片查看全分辨率文件。调用各种内部或外部API非常有帮助，但我们的应用程序可能需要在某个时候从用户那里接收数据。在下一节中，我们将介绍如何访问和操作`Requests`中提供的`FormData`对象。
- en: FormData
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FormData
- en: 'When building web applications, it’s common to accept data from users through
    the use of forms. Accessing this data can be done via the `+page.svelte` and `+page.server.js`,
    under the new *comment* route. As before, the `+page.svelte` file contains HTML
    to scaffold our form and minimal styles. In order to get access to the data sent
    from our server, we must include the line reading `export let form;` in our client-side
    `<script>` code. This lets us view the status of the object returned from `+page.server.js`
    and report the status back to the user by using the templating system provided
    by Svelte:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Web应用程序时，通常通过使用表单来接受用户数据。可以通过`+page.svelte`和`+page.server.js`访问这些数据，这些都在新的*评论*路由下。和之前一样，`+page.svelte`文件包含用于构建表单的HTML和最小样式。为了获取从服务器发送的数据，我们必须在我们的客户端`<script>`代码中包含读取`export
    let form;`的行。这让我们可以查看从`+page.server.js`返回的对象的状态，并通过Svelte提供的模板系统将状态反馈给用户：
- en: src/routes/comment/+page.svelte
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/comment/+page.svelte
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: src/routes/comment/+page.server.js
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/comment/+page.server.js
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As noted earlier, `+page.server.js` works in the same way as a `+page.js` file,
    except that it will only run on the server. Just as we can export `load()`, like
    in our `fetch` example, server-side files can also export `actions`. These exported
    `actions` can only be accessed via `POST` requests. We’ll look at how we can further
    utilize `actions` in a later chapter, but for now, note that we’re creating a
    single action, `default`. This means that when a form is submitted, the `POST`
    request is handled by the `/``comment` endpoint.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`+page.server.js`与`+page.js`文件的工作方式相同，但它在服务器上才会运行。就像我们可以在`fetch`示例中导出`load()`一样，服务器端文件也可以导出`actions`。这些导出的`actions`只能通过`POST`请求访问。我们将在后面的章节中探讨如何进一步利用`actions`，但到目前为止，请注意我们正在创建一个单独的动作，`default`。这意味着当表单提交时，`POST`请求将由`/comment`端点处理。
- en: From the `default` action, this example accesses the `Request` object located
    in `event`, and then accesses `FormData` within that `Request`. Once the `FormData`
    object has been assigned to the `form` variable, we use `get()` to retrieve the
    value from the form input by its name. Normally, we would then move on to something
    akin to a database call that would save the comment alongside a unique user identifier.
    For the sake of brevity, we will just return an object with the `status` and `msg`
    properties.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从`default`动作中，这个例子访问了位于`event`中的`Request`对象，然后访问该`Request`中的`FormData`。一旦`FormData`对象被分配给`form`变量，我们使用`get()`通过名称从表单输入中检索值。通常，我们接下来会进行类似数据库调用的操作，以保存评论和唯一的用户标识符。为了简洁起见，我们只需返回一个包含`status`和`msg`属性的简单对象。
- en: When the page reloads, those properties are then checked by the Svelte template
    syntax and show the user a message that their comment has been successfully submitted.
    Even though this example only accessed `FormData` with `get()`, all methods documented
    in official standards are also available to us. If we wanted to cycle through
    all values and keys submitted, we could do so using a `for...of` loop and access
    the values via `form.values()` and `form.keys()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面重新加载时，这些属性将通过Svelte模板语法进行检查，并向用户显示他们的评论已成功提交的消息。尽管这个例子只使用了`FormData`的`get()`方法，但官方标准中记录的所有方法对我们也都是可用的。如果我们想遍历所有提交的值和键，我们可以使用`for...of`循环，并通过`form.values()`和`form.keys()`访问值。
- en: Now that we know how to obtain data from submitted forms, we should also look
    at another way of receiving data from users that may be overlooked – the URL.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从提交的表单中获取数据，我们也应该看看另一种可能被忽视的从用户那里接收数据的方式——URL。
- en: URL
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL
- en: The `event` object, just as the `request` object was. Let’s continue with our
    previous example using comments. If we wanted to build a commenting service for
    use across a network of other websites, we may want to report to a user which
    site they just commented on. Let’s expand on that previous example and do just
    that. We don’t need to make any changes to `src/routes/comment/+page.svelte`.
    Instead, we’ll adjust our server action accordingly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`对象，就像`request`对象一样。让我们继续使用之前的评论示例。如果我们想在其他网站的网络中构建一个评论服务，我们可能想向用户报告他们刚刚在哪个网站上发表了评论。让我们扩展之前的例子并做到这一点。我们不需要对`src/routes/comment/+page.svelte`做任何修改。相反，我们将相应地调整我们的服务器动作。'
- en: 'This example is identical to the last except for a couple of changes. The URL
    API is accessed via `event.url` and assigned to the `url` constant. It is then
    output to the server with `console.log(url)` to show you the various read-only
    properties that you can access. For this demonstration, we get the hostname via
    `url.hostname` and use it in a template literal, which is assigned to the `msg`
    property of the returned object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子相同，只是做了一些改动。通过`event.url`访问URL API，并将其分配给`url`常量。然后使用`console.log(url)`将其输出到服务器，以显示你可以访问的各种只读属性。为了演示，我们通过`url.hostname`获取主机名，并在模板字面量中使用它，这被分配给返回对象的`msg`属性：
- en: src/routes/comment/+page.server.js
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/comment/+page.server.js
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you switch to your browser window and post a comment, you’ll now see that
    it reports the `hostname` property. In a production environment, this would ideally
    be your domain name, but in our development environment, we see the message `http://localhost`,
    you’ll see `URL` object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换到浏览器窗口并发表评论，你现在会看到它报告了`hostname`属性。在生产环境中，这应该是你的域名，但在我们的开发环境中，你会看到消息`http://localhost`，你将看到`URL`对象：
- en: Sample event.url object
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例事件.url对象
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `URL` object showcases how simple it is to grab information about it. All
    of the read-only properties shown are easily accessed using dot notation. Gone
    are the days of parsing an entire `URL` with regex in an attempt to extract the
    portion needed. Now, if you wanted to get the values set in query strings, you
    could easily iterate over `event.url.searchParams` with a `for...of` loop. Go
    ahead and add some options to the URL in your browser. An example might look like
    `http://127.0.0.1:5173/comment?id=5&name=YOUR_NAME_HERE`. Now, the `console.log(url)`
    function call will output the names and values set after the first `?` and each
    subsequent `&`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`URL`对象展示了获取其信息是多么简单。所有显示的只读属性都可以通过点符号轻松访问。不再需要使用正则表达式解析整个`URL`以提取所需的部分。现在，如果您想获取查询字符串中设置的值，可以轻松地使用`for...of`循环遍历`event.url.searchParams`。在您的浏览器中添加一些URL选项。一个例子可能看起来像`http://127.0.0.1:5173/comment?id=5&name=YOUR_NAME_HERE`。现在，`console.log(url)`函数调用将输出第一个`?`之后和每个随后的`&`设置的名字和值。
- en: Summary
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered an example use case of `fetch` and a two-part demonstration
    showing how `URL` and `FormData` can be used. While the examples presented here
    do not represent the full scope of the various Web APIs that you’ll have access
    to, they should illustrate how simple it is to use them with SvelteKit. If you’re
    hoping to build applications with SvelteKit, it’s important you become familiar
    with these modern Web APIs, as they’re used extensively throughout development
    with SvelteKit. SvelteKit encourages you to lean on that existing knowledge. By
    doing so, SvelteKit can ship less code to you so that you can ship less code to
    your users.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一个`fetch`的示例用例，以及一个两部分的演示，展示了如何使用`URL`和`FormData`。虽然这里提供的示例并不代表您将能够访问的所有各种Web
    API的全貌，但它们应该说明了使用SvelteKit使用它们是多么简单。如果您希望使用SvelteKit构建应用程序，那么熟悉这些现代Web API非常重要，因为它们在SvelteKit的开发过程中被广泛使用。SvelteKit鼓励您依赖现有的知识。通过这样做，SvelteKit可以向您提供更少的代码，从而使您可以向用户提供更少的代码。
- en: In the next chapter, we’ll move away from the background information that is
    necessary for using SvelteKit and start building something that resembles an application.
    We’ll cover various routing techniques and how you can build out a consistent
    user interface across the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从使用SvelteKit所必需的背景信息中脱离出来，开始构建一个类似应用程序的东西。我们将介绍各种路由技术以及如何在应用程序中构建一致的用户界面。
- en: Resources
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: MDN Web Docs – For references to `fetch()`, `formData()`, `URL`, and more, visit
    [https://developer.mozilla.org](https://developer.mozilla.org).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDN Web 文档 – 要了解`fetch()`、`formData()`、`URL`等更多信息，请访问[https://developer.mozilla.org](https://developer.mozilla.org)。
- en: Part 2 – Core Concepts
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 核心概念
- en: Navigation on the web is such a quintessential experience that the developers
    of SvelteKit have made routing central to the framework. In this part, we’ll examine
    previously introduced routing techniques in more detail. After that, we’ll see
    how SvelteKit moves data to components and accepts data from them through HTML
    form elements. Finally, we’ll see some more advanced routing techniques that promise
    to cover even the most obscure edge cases encountered in routing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 网络导航是一种非常典型的体验，SvelteKit的开发者已经将路由作为框架的核心。在本部分中，我们将更详细地检查之前介绍的路线技术。之后，我们将看到SvelteKit如何将数据移动到组件中，并通过HTML表单元素从它们那里接受数据。最后，我们将看到一些更高级的路由技术，这些技术承诺可以覆盖在路由中遇到的几乎所有边缘情况。
- en: 'This part has the following chapters:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060), *Effective Routing
    Techniques*'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B19024_04_Final_AM.xhtml#_idTextAnchor060), *有效路由技术*'
- en: '[*Chapter 5*](B19024_05_Final_AM.xhtml#_idTextAnchor072), *Deep Dive into Data
    Loading*'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19024_05_Final_AM.xhtml#_idTextAnchor072), *深入数据加载*'
- en: '[*Chapter 6*](B19024_06_Final_AM.xhtml#_idTextAnchor080), *Forms and Data Submission*'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19024_06_Final_AM.xhtml#_idTextAnchor080), *表单和数据提交*'
- en: '[*Chapter 7*](B19024_07_Final_AM.xhtml#_idTextAnchor093), *Advanced Routing
    Techniques*'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19024_07_Final_AM.xhtml#_idTextAnchor093), *高级路由技术*'
