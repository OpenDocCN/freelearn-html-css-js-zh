- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behaving Properly – Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*,
    we considered functions as the critical elements in **functional programming**
    (**FP**), went into detail about arrow functions, and introduced some concepts,
    such as injection, callbacks, polyfilling, and stubbing. In this chapter, we’ll
    have the opportunity to revisit or apply some of those ideas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the notion of **purity** and why we should care about **pure functions**—and
    **impure functions** as well!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the concept of **referential transparency**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the problems implied by side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show some advantages of pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the main reasons behind impure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover ways to minimize the number of impure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on ways of testing both pure and impure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pure functions behave the same way as mathematical functions and provide various
    benefits. A function is pure if it satisfies two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given the same arguments, the function always calculates and returns the
    same result**: This should be true no matter how many times it’s invoked or under
    which conditions you call it. This result cannot depend on any outside information
    or state, which could change during the program execution and cause it to return
    a different value. Nor can the function result depend on I/O results, random numbers,
    some other external variable, or a value that is not directly controllable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When calculating its result, the function doesn’t cause any observable side
    effects**: This includes output to I/O devices, the mutation of objects, changes
    to a program’s state outside of the function, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can simply say that pure functions don’t depend on (and don’t modify) anything
    outside their scope and always return the same result for the same input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Another word used in this context is **idempotency**, but it’s not exactly the
    same. An idempotent function can be called as many times as desired and will always
    produce the same result. However, this doesn’t imply that the function is free
    from side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotency is usually mentioned in the context of RESTful services. Let’s see
    a simple example showing the difference between purity and idempotency. A `PUT`
    call would cause a database record to be updated (a side effect), but if you repeat
    the call, the element will not be further modified, so the global state of the
    database won’t change any further.
  prefs: []
  type: TYPE_NORMAL
- en: We might also invoke a software design principle and remind ourselves that a
    function should *do one thing, only one thing, and nothing but that thing*. If
    a function does something else and has some hidden functionality, then that dependency
    on the state will mean that we won’t be able to predict the function’s output
    and will make things harder for us as developers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look into these conditions in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematics, referential transparency is the property that lets you replace
    an expression with its value without changing the results of whatever you are
    doing. The counterpart of referential transparency is, appropriately enough, **referential
    opacity**. A referentially opaque function cannot guarantee that it will always
    produce the same result, even when called with the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a simple example, let’s consider what happens with an optimizing compiler
    that performs **constant folding**. Suppose you have a sentence like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler might optimize the code to the following by noting that `2*3`
    is a constant value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, a new round of optimization could avoid the sum altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To save execution time, the compiler is taking advantage of the fact that all
    mathematical expressions and functions are (by definition) referentially transparent.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the compiler cannot predict the output of a given expression,
    it won’t be able to optimize the code in any fashion, and the calculation will
    have to be done at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: (TypeScript does a similar type analysis, and given the original `const x =
    1 + 2 * 3` line, it would correctly decide that `x` is of type `number`.)
  prefs: []
  type: TYPE_NORMAL
- en: Of lambdas and betas
  prefs: []
  type: TYPE_NORMAL
- en: In lambda calculus, if you replace the value of an expression involving a function
    with the calculated value for the function, then that operation is called a **β
    (beta) reduction**. Note that you can only do this safely with referentially transparent
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All arithmetical expressions (involving both mathematical operators and functions)
    are referentially transparent: `22*9` can always be replaced by `198`. Expressions
    involving I/O are not transparent, given that their results cannot be known until
    executed. For the same reason, expressions involving date- and time-related functions
    or random numbers are also not transparent.'
  prefs: []
  type: TYPE_NORMAL
- en: Concerning JavaScript functions you can produce, it’s pretty easy to write some
    that won’t fulfill the referential transparency condition. In fact, a function
    is not even required to return a value, though the JavaScript interpreter will
    return `undefined` in that situation.
  prefs: []
  type: TYPE_NORMAL
- en: A matter of distinction
  prefs: []
  type: TYPE_NORMAL
- en: Some languages distinguish between functions, which are expected to return a
    value, and procedures, which do not return anything, but that’s not the case with
    JavaScript. Some languages even provide the means to ensure that functions are
    referentially transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to, you could classify functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pure functions**: These return a value that depends only on its arguments
    and have no side effects whatsoever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`, but that’s not relevant here) but do produce some side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions with side effects**: This means that they return a value that may
    not only depend on the function arguments but also involve side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In FP, much emphasis is put on the first group: referentially transparent pure
    functions. A compiler can reason about the program behavior (and thus be able
    to optimize the generated code), and the programmer can more easily reason about
    the program and the relationship between its components. This, in turn, can help
    prove the correctness of an algorithm or optimize the code by replacing a function
    with an equivalent one.'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are side effects? We can define these as a change in state or an interaction
    with outside elements (the user, a web service, another computer—whatever) that
    occurs during the execution of some calculations or a process.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a possible misunderstanding as to the scope of this meaning. In everyday
    speech, when you speak of side effects, it’s a bit like talking about collateral
    damage—some unintended consequences for a given action; however, in computing,
    we include every possible effect or change outside the function. If you write
    a function meant to perform a `console.log()` call to display a result, that would
    be considered a side effect, even if it’s exactly what you intended the function
    to do in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Common side effects in JavaScript programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problems that global and inner states cause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility of functions mutating their arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some functions that are always troublesome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usual side effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In programming, there are (too many!) things that are considered side effects.
    In JavaScript programming, including both front- and backend coding, the more
    common ones you may find include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing global variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating objects received as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing any I/O, such as showing an alert message or logging some text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with, or changing, the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying or updating a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a web service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying or modifying the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering any external process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just calling another function that produces a side effect of its own. You could
    say that impurity is contagious: a function that calls an impure function automatically
    becomes impure on its own!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this definition, let’s start looking at what can cause functional impurity
    (or referential opaqueness).
  prefs: []
  type: TYPE_NORMAL
- en: Global state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of all the preceding points, the most common reason for side effects is the
    usage of nonlocal variables that share a global state with other parts of the
    program. Since pure functions, by definition, always return the same output value
    given the same input arguments, if a function refers to anything outside its internal
    state, it automatically becomes impure. Furthermore—and this is a hindrance to
    debugging—to understand what a function has done, you must understand how the
    state got its current values, which means understanding all of the past history
    from your program: not easy!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a function to detect whether a person is a legal adult by checking
    whether they were born at least 18 years ago. (OK—that’s not precise enough because
    we are not considering the day and month of birth, but bear with me; the problem
    is elsewhere.) A version of an `isOldEnough()` function could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `isOldEnough()` function correctly detects whether a person is at least
    18 years old, but it depends on an external variable—a variable good for 2022
    only! Even though the function works, the implementation isn’t the best that it
    could possibly be. You cannot tell what the function does unless you know about
    the external variable and how it got its value. Testing is also hard; you must
    remember to create the global `limitYear` variable, or all your tests will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an exception to this rule. Check out the following case: is the following
    `circleArea()` function, which calculates the area of a circle given its radius,
    pure or not?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Even though the function is accessing an external state, the fact that `PI`
    is a constant (and thus cannot be modified) would allow us to substitute it inside
    `circleArea` with no functional change, and so we should accept that the function
    is pure. The function will always return the same value for the same argument
    and thus fulfills our purity requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to use `Math.PI` instead of a constant as we defined in the code
    (a better idea, by the way) the constant cannot be changed, so the function would
    remain pure.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have dealt with problems caused by the global state; let’s move on
    to the inner state.
  prefs: []
  type: TYPE_NORMAL
- en: Inner state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The notion is also extended to internal variables, in which a local state is
    stored and used for future calls. The external state is unchanged, but internal
    side effects imply future differences regarding what the function will return.
    Let’s imagine a `roundFix()` rounding function that considers whether it has been
    rounding up or down too much so that the next time, it will round the other way,
    bringing the accumulated difference closer to zero. Our function will have to
    accumulate the effects of previous roundings to decide how to proceed next. The
    implementation could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Some comments regarding this function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `console.log()` call is just for the sake of this example; it wouldn’t
    be included in the real-world function. It lists the accumulated difference up
    to the point and the result it will return: the given number rounded up or down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the IIFE pattern from the `myCounter()` example in the *Immediate
    invocation* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting
    Out with Functions,* to get a hidden internal variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `nRounded` calculation could also be written as `Math[accum > 0 ? "ceil":
    "floor"](n)`—we test `accum` to see which method to invoke (`"ceil"` or `"floor"`)
    and then use the `Object["method"]` notation to indirectly invoke `Object.method()`.
    The way we used it, I think, is more clear, but I just wanted to give you a heads-up
    in case you happen to find this other coding style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running this function with just two values (recognize them?) shows that results
    are not always the same for a given input. The `result` part of the console log
    shows how the value got rounded, up or down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first time around, `accum` is zero, so 3.14159 gets rounded down, and `accum`
    becomes 0.14159 in our favor. The second time, since `accum` is positive (meaning
    that we have been rounding in our favor), 2.71828 gets rounded up to 3, and now
    `accum` becomes negative. The third time, the same 2.71828 value gets rounded
    down to 2 because the accumulated difference was negative—we got different values
    for the same input! The rest of the example is similar; you can get the same value
    rounded up or down, depending on the accumulated differences, because the function’s
    result depends on its inner state.
  prefs: []
  type: TYPE_NORMAL
- en: Why not OOP?
  prefs: []
  type: TYPE_NORMAL
- en: This usage of the internal state is why many FP programmers think that using
    objects is potentially flawed. In OOP, we developers are used to storing information
    (attributes) and using them for future calculations; however, this usage is considered
    impure insofar as repeated method calls may return different values, although
    the same arguments are being passed.
  prefs: []
  type: TYPE_NORMAL
- en: We have now dealt with the problems caused by both global and inner states,
    but there are still more possible side effects. For example, what happens if a
    function changes the values of its arguments? Let’s consider this next.
  prefs: []
  type: TYPE_NORMAL
- en: Argument mutation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You also need to be aware of the possibility that an impure function will modify
    its arguments. In JavaScript, arguments are passed by value, except for arrays
    and objects, which are passed by reference. This implies that any modification
    to the function’s parameters will affect an actual modification of the original
    object or array. This can be further obscured by the fact that several `Math.max()`
    with no further ado). A short implementation could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The function does provide the correct result (and if you worry about foreign
    languages, we already saw a way around that in the *Injection – sorting it out*
    section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out with
    Functions*), but it has a defect. Let’s see what happened with the original array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Oops—the original array was modified; this is a side effect by definition! (TypeScript
    would have helped detect this error if we had only written a complete type definition
    for `maxStrings()`; see *Question 4.2* for details.) If you were to call `maxStrings(countries)`
    again, then instead of returning the same result as before, it would produce another
    value; clearly, this is not a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, a quick solution is to work on a copy of the array, and we can
    use the spread operator to help. Still, we’ll be dealing with more ways of avoiding
    these sorts of problems in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring
    Purity*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, we have found yet another cause for side effects: functions that modify
    their arguments. A final case to consider is functions that just have to be impure!'
  prefs: []
  type: TYPE_NORMAL
- en: Troublesome functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, some functions also cause problems. For instance, `Math.random()`
    is impure: it doesn’t always return the same value, and it would defeat its purpose
    if it did! Furthermore, each call to the function modifies a global seed value,
    from which the next random value will be calculated.'
  prefs: []
  type: TYPE_NORMAL
- en: Not really random
  prefs: []
  type: TYPE_NORMAL
- en: The fact that random numbers are actually calculated by an internal function
    makes them not random at all; *pseudorandom* would be a better name for them.
    If you knew the used formula and the seed’s initial value, you’d be able to predict
    the following numbers, in a totally non-random way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following function that generates random letters
    from `"A"` to `"Z"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The fact that it receives no arguments, but is expected to produce different
    results upon each call, clearly points out that this function is impure.
  prefs: []
  type: TYPE_NORMAL
- en: Random explanations
  prefs: []
  type: TYPE_NORMAL
- en: Go to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
    for an explanation of our `getRandomLetter()` function, and to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)
    for the `.``charCodeAt()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Impurity can be inherited by calling functions. If a function uses an impure
    function, it immediately becomes impure itself. We might want to use `getRandomLetter()`
    to generate random filenames with an optional given extension; our `getRandomFileName()`
    function could then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of its usage of `getRandomLetter()`, `getRandomFileName()` is also
    impure, though it performs as expected, correctly producing totally random filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Keep this function in mind; we’ll see some ways around the unit testing problem
    later in this chapter, and we’ll rewrite it a bit to help with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concern about impurity also extends to functions that access the current
    time or date because their results will depend on an external condition (namely,
    the time of day) that is part of the application’s *global* state. We could rewrite
    our `isOldEnough()` function to remove the dependency upon a global variable,
    but it wouldn’t help much. One attempt is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A problem has been removed—the new `isOldEnough2()` function is now safer.
    Also, as long as you don’t use it near midnight just before New Year’s Day, it
    will consistently return the same results, so you could say—paraphrasing the *Ivory
    Soap* slogan from the 19th century—that it’s about *99.44% pure*; however, an
    inconvenience remains: how would you test it? If you were to write some tests
    that worked fine today, they’d start to fail next year. We’ll have to work a bit
    to solve this, and we’ll see how later.'
  prefs: []
  type: TYPE_NORMAL
- en: Several other functions that are also impure are those that cause I/O. If a
    function gets input from a source (a web service, the user themself, a file, or
    some other source), then the result may obviously vary. You should also consider
    the possibility of an I/O error, so the very same function, calling the same service
    or reading the same file, might at some point fail for reasons outside its control
    (you should assume that your filesystem, database, socket, and so on could be
    unavailable, and thus a given function call might produce an error instead of
    the expected constant, unvarying, answer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even having a pure output and a generally safe statement (such as a `console.log()`)
    that doesn’t change anything internally (at least in a visible way) causes some
    side effects because the user does see a change: namely, the produced output.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this imply that we won’t ever be able to write a program that requires
    random numbers, handles dates, performs I/O, and also uses pure functions? Not
    at all—but it does mean that some functions won’t be pure, and they will have
    some disadvantages that we will have to consider; we’ll return to this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main advantage of using pure functions is that they don’t have any side
    effects. When you call a pure function, you don’t need to worry about anything
    other than which arguments you are passing to it. Also, more to the point, you
    can be sure that you will not cause any problems or break anything else because
    the function will only work with whatever you give it and not with outside sources.
    But this is not their only advantage. Let’s learn more in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Order of execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way of looking at what we have been saying in this chapter is to see
    pure functions as robust. You know that their execution—in whichever order—won’t
    ever impact the system. This idea can be extended further: you could evaluate
    pure functions in parallel, with the assurance that results wouldn’t vary from
    what you would get in a single-threaded execution. (JavaScript doesn’t provide
    Java-like threads, but we can make do, more or less, with workers. We’ll cover
    this topic in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*.)'
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration to keep in mind when you work with pure functions is that
    there’s no explicit need to specify the order in which they should be called.
    If you work with mathematics, an expression such as `f(2)+f(5)` is always the
    same as `f(5)+f(2)`; this is called the *commutative property*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when you deal with impure functions, that can be false, as shown in
    the following purposefully written tricky function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With impure functions such as the previous one, you cannot assume that calculating
    `f(3)+f(3)` would produce the same result as `2*f(3)` or that `f(4)-f(4)` would
    actually be zero; check it out for yourself... Common mathematical properties,
    down the drain!
  prefs: []
  type: TYPE_NORMAL
- en: Why should you care? When writing code, willingly or not, you always keep in
    mind those properties you learned about, such as the commutative property. So,
    while you might think that both expressions should produce the same result and
    code accordingly, you may be in for a surprise when using impure functions, with
    hard-to-find bugs that are difficult to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the output of a pure function for a given input is always the same, you
    can cache the function results and avoid a possibly costly recalculation. This
    process, which implies evaluating an expression only the first time and caching
    the result for later calls, is called **memoization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will return to this idea in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, but let’s look at an example done by hand. The Fibonacci
    sequence is always used for this example because of its simplicity and hidden
    calculation costs. This sequence is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For *n*=0, fib(*n*)=0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *n*=1, fib(*n*)=1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *n*>1, fib(*n*)=fib(*n*-2)+fib(*n*-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fibonacci who?
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci’s name actually comes from *filius Bonacci* or *son of Bonacci*. He
    is best known for having introduced the usage of digits 0-9 as we know them today,
    instead of the cumbersome Roman numbers. He derived the sequence named after him
    as the answer to a puzzle involving rabbits! You can read more about it, and Fibonacci’s
    life in general, at en.wikipedia.org/wiki/Fibonacci_number#History or [plus.maths.org/content/life-and-numbers-fibonacci](http://plus.maths.org/content/life-and-numbers-fibonacci).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the numbers, the sequence starts with 0, then 1, and from that point
    onward, each term is the sum of the two previous ones: 1 again, then 2, 3, 5,
    8, 13, 21, 34, 55, and so on. Programming this series using recursion is simple;
    we’ll revisit this example in [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172),
    *Designing Functions*. The following code, a direct translation of the definition,
    will do—and see *Question 4.4* for an alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you try out this function for growing values of `n`, you’ll soon realize
    that there is a problem, and computation starts taking too much time. For example,
    I took timings (measured in milliseconds) at my machine and plotted them on a
    graph. Since the function is quite speedy, I had to run calculations 100 times
    for values of `n` between 0 and 40\. Even then, the times for small values of
    `n` were really tiny; it was only from 25 onward that I got interesting numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chart (see *Figure 4**.1*) shows exponential growth, which bodes ill:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially](img/Figure_4.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially
  prefs: []
  type: TYPE_NORMAL
- en: 'If we draw a diagram of all the calls required to calculate `fib(6)`, you’ll
    notice the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication](img/Figure_4.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication
  prefs: []
  type: TYPE_NORMAL
- en: Each node represents a call to compute `fib(n)`. We note the value of `n` in
    the node. Every call, except those for `n`=0 or `n`=1, requires further calls,
    as you can see in *Figure 4**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the increasing delays becomes obvious: for example, the calculation
    for `fib(2)` was repeated on four different occasions, and `fib(3)` was itself
    calculated three times. Given that our function is pure, we could have stored
    the calculated values to avoid running the numbers over and over again. A possible
    version, using a cache array for previously calculated values, would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, the `cache` array is empty. Whenever we need to calculate the value
    of `fib2(n)`, we check whether it was already calculated beforehand. If that’s
    not true, we do the calculation, but with a twist: instead of immediately returning
    the value, we first store it in the cache and then return it. This means that
    no calculation will be done twice: after we have calculated `fib2(n)` for a particular
    `n` value, future calls will not repeat the procedure and will return the earlier
    evaluated result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few short notes:'
  prefs: []
  type: TYPE_NORMAL
- en: We memoized the function by hand, but we can do it with a higher-order function.
    We’ll see this later in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing
    Functions*. It is perfectly possible to memoize a function without having to change
    or rewrite it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a global `cache` variable isn’t a very good practice; we could have used
    an IIFE and a closure to hide `cache` from sight—do you see how? (Also, see *Question
    4.3* at the end of this chapter.) The `myCounter()` example in the *Immediate
    invocation* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting
    Out with Functions,* shows how.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you will be constrained by the available cache space, and it’s possible
    you could eventually crash your application by eating up all available RAM. Resorting
    to external memory (a database, a file, or a cloud solution) would probably eat
    up all the performance advantages of caching. There are some standard solutions
    (involving eventually deleting items from the cache), but they are beyond the
    scope of this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you don’t need to do this for every pure function in your program.
    You’d do this sort of optimization only for frequently called functions that take
    a significant amount of time; otherwise, the added cache management time would
    cost more than what you expected to save!
  prefs: []
  type: TYPE_NORMAL
- en: Self-documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pure functions have another advantage. Since everything the function needs to
    work with is given to it through its parameters, with no hidden dependency whatsoever,
    when you read its source code, you have all you need to understand its objective.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extra advantage: knowing that a function doesn’t access anything beyond
    its parameters makes you more confident in using it since you won’t be accidentally
    producing a side effect; the only thing the function will accomplish is what you
    already learned through its documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests (which we’ll cover in the next section) also work as documentation
    because they provide examples of what the function returns when given certain
    arguments. Most programmers will agree that the best kind of documentation is
    full of examples, and each unit test can be considered such a sample case.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yet another advantage of pure functions—and one of the most important ones—has
    to do with unit testing. Pure functions have a single responsibility: producing
    their output in terms of their input. So, when you write tests for pure functions,
    your work is greatly simplified because there is no context to consider and no
    state to simulate.'
  prefs: []
  type: TYPE_NORMAL
- en: You can focus on providing inputs and checking outputs because all function
    calls can be reproduced in isolation, independently from the rest of the world.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen several aspects of pure functions. Let’s move on, learn about impure
    functions a bit, and finish by testing both pure and impure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Impure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you decided to entirely forgo all kinds of side effects, then your programs
    would only be able to work with hardcoded inputs and wouldn’t be able to show
    you the calculated results! Similarly, most web pages would be useless: you wouldn’t
    be able to make web service calls or update the DOM; you’d only have static pages.
    And your Node code would be really useless for server-side work, as it wouldn’t
    be able to perform any I/O.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing side effects is a good goal in FP, but we shouldn’t go overboard! So,
    let’s think of how to avoid using impure functions, if possible, and how to deal
    with them if not, looking for the best way to contain or limit their scope.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding impure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we saw the more common reasons for using impure functions.
    Let’s now consider how we can reduce the number of impure functions, even if doing
    away with all of them isn’t really feasible. Basically, we’ll have two methods
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the usage of state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a programming pattern, **injection**, to control impurities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the usage of state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With regard to the usage of the global state—both getting and setting it—the
    solution is well known. The key points to this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide whatever is needed of the global state to the function as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function needs to update the state, it shouldn’t do it directly, but
    instead produce a new version of the state and return it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be the caller’s responsibility to take the returned state, if any,
    and update the global state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the technique that Redux uses for its reducers. (We saw this in the
    *What FP is not* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,
    Becoming Functional*, and the *Functions as objects* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*,
    Starting Out with Functions*.) The signature for a reducer is `(previousState,
    action) => newState`, meaning that it takes a state and an action as parameters
    and returns a new state as the result. Most specifically, the reducer is not supposed
    to change the `previousState` argument, which must remain untouched (we’ll learn
    more about this in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring
    Purity*).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first version of the `isOldEnough()` function, which used a global
    `limitYear` variable, the change is simple enough: we have to provide `limitYear`
    as a parameter for the function. With this change, it will become pure since it
    will produce its result by only using its parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, we should provide the current year and let the function do the
    math instead of forcing the caller to do so. Our newer version of the adult age
    test could then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we’ll have to change all the calls to provide the required `currentYear`
    argument (we could also use partial application, as we will see in [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*). The responsibility for the value of `currentYear` remains
    outside of the function, as before, but we have managed to avoid a defect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply this solution to our peculiar `roundFix()` function. As you
    will recall, the function worked by accumulating the differences caused by rounding
    and deciding whether to round up or down depending on the sign of that accumulator.
    We cannot avoid using that state, but we can split off the rounding part from
    the accumulating part. Our original code (with fewer comments, no logging, and
    using arrow functions throughout) would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The newer version (see *Question 4.6* for more about this) would have two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'How would you use this function? Initializing the accumulator, passing it to
    the function, and updating it afterward are now the responsibility of the caller
    code. You would have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `accum` value is now part of the global state of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `roundFix2()` needs it, its value is provided in each call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller is responsible for updating the global state, not `roundFix2()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spreading, once more
  prefs: []
  type: TYPE_NORMAL
- en: Note the usage of the destructuring assignment to allow a function to return
    more than a value and easily store each one in a different variable. For more
    on this, go to [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
    For an alternative see *Question 4.7*.
  prefs: []
  type: TYPE_NORMAL
- en: This new `roundFix2()` function is totally pure and can be easily tested. If
    you want to hide the accumulator from the rest of the application, you could still
    use a closure, as we have seen in other examples, but that would again introduce
    impurity in your code—your call!
  prefs: []
  type: TYPE_NORMAL
- en: Injecting impure functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a function becomes impure because it needs to call another function that
    is itself impure, a way around this problem is to inject the required function
    in the call. This technique provides more flexibility in your code and allows
    for easier future changes and less complex unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the random filename generator function that we saw earlier.
    The problematic part of this function is its usage of `getRandomLetter()` to produce
    the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A way to solve this is to replace the impure function with an injected external
    one; we must now provide a `randomLetterFunc()` argument for our random filename
    function to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have removed the inherent impurity from this function. If we want to
    provide a predefined pseudorandom function that returns fixed, known values, we
    can easily unit-test this function; we’ll see how in the following examples. The
    usage of the function will change, and we would have to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If this bothers you, you may want to provide a default value for the `randomLetterFunc`
    parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can also solve this using **partial application**, as we’ll see in [*Chapter
    7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: This hasn’t actually avoided the usage of impure functions. Normally, you’ll
    call `getRandomFileName()` by providing it with the random letter generator we
    wrote, so it will behave as an impure function. However, if for testing purposes
    you provide a function that returns predefined (that is, not random) letters,
    you’ll be able to test it as if it were pure much more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about the original problem function, `getRandomLetter()`? We can apply
    the same trick and write a new version, such as the following, which will have
    an argument that will produce random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We should change `getRandomFileName3()` to call `getRandomLetter2()`. If it
    calls it without providing any parameters, `getRandomLetter2()` will behave in
    its expected random ways. But if we want to test whether `getRandomFileName3()`
    does what we wanted, we can run it with an injected function that will return
    whatever we decide, letting us test it thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Bind them all
  prefs: []
  type: TYPE_NORMAL
- en: For the default of `getRandomNum`, we wrote `Math.random.bind(Math)`, as explained
    in the *Working with methods* section of the previous chapter. The alternative
    (arguably clearer for some people) is `() => Math.random()`; we’ll use it in the
    *Is your function pure?* section later in this chapter, just for variety.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s finish this section with a more complex case: what happens with a function
    with multiple impurities? For instance, we could be working on a backend `calculateDebt()`
    service that calculates a person’s debt, given their `id`. To do that, we could
    access a database, get the list of the person’s invoices, and then call some service
    to get the amount owed in each invoice; the sum of those amounts would be the
    calculated debt. A skeleton of such a function could be as follows—and I’m using
    plain JavaScript to omit unnecessary details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: (If `calculatedDebt = wedAmounts.reduce(…)` is foreign to you, see the *Summing
    an array* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*,* *Programming
    Declaratively*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot easily test such a function because it depends on the availability
    of a database and another service. To *purify* it, we need to inject two functions:
    one to get data from a database and another to query a service. The purified function
    would become this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `getInvoicesFromDb()` and `getOwedAmountFromAPI()` would be the
    functions that do the DB access and API call. Our `calculateDebt2()` function
    now doesn’t know (or need to know) the details of how to access and work with
    the DB or the other service; that’s a better software design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the function has two parameters: `id` (as before) and an optional object
    with the two functions to be injected. In regular use, we wouldn’t supply the
    second parameter, and the function accesses the DB and calls the API as needed.
    But here’s the point: for testing purposes, we inject an object with two mock
    functions and are then able to write simple tests. (If you are wondering why we
    injected an object, see *Question 4.8*.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'An extra detail: thorough real-world testing of functions is usually hard to
    achieve. For instance, how do you simulate a dropped connection or a failed service
    call? With injection, that’s no problem; we can easily provide a mock that will
    return wrong values, throw an exception, and do anything else you need for your
    complete testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Using injection to avoid impurities is very important and has a broad spectrum
    of applications for other problems. For example, instead of having a function
    directly access the DOM, we can provide it with injected functions that would
    do this. For testing purposes, it would be simple to verify that the tested function
    does what it needs to do without really interacting with the DOM (of course, we’d
    have to find another way to test those DOM-related functions). This can also apply
    to functions that need to update the DOM, generate new elements, and do all sorts
    of manipulations—you use some intermediary functions. We’ll even apply injection
    in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204)*, Implementing Design Patterns,*
    to derive a better system architecture, so it’s a powerful, key concept.
  prefs: []
  type: TYPE_NORMAL
- en: Is your function pure?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s end this section by considering an important question: can you ensure
    that a function is truly pure? To show the difficulties of this task, we’ll go
    back to the simple `sum3()` function that we saw in the *Spread* section of [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional* , just rewritten
    to use arrow functions for brevity. Would you say that this function is pure?
    It certainly looks like it!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see: the function doesn’t access anything but its parameters, doesn’t
    even try to modify them (not that it could (or could it?)), doesn’t perform any
    I/O, or work with any of the impure functions or methods that we mentioned earlier.
    What could go wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer has to do with checking your assumptions. For example, who says
    the arguments for this function should be numbers? In plain JavaScript, we could
    call it with, say, strings, but we’re now using TypeScript, and it’s supposed
    to check that, right? And even if passing strings to the function, you might ask
    yourself: *OK, they could be strings, but the function would still be pure, wouldn’t
    it?* For an (assuredly evil!) answer to that, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Evil coding!
  prefs: []
  type: TYPE_NORMAL
- en: We assigned a new function to the `x.valueOf()` method to make an object look
    like a number. We also lied when saying `x = {} as number`; otherwise, TypeScript
    would have objected that you were passing an object where a number was expected.
  prefs: []
  type: TYPE_NORMAL
- en: Well, `sum3()` ought to be pure, but that actually depends on whichever parameters
    you pass to it; you can make a pure function behave impurely! You might console
    yourself by thinking that surely no one would pass such arguments, but edge cases
    are usually where bugs reside. But you need not resign yourself to abandoning
    the idea of pure functions. As we see, you can even con TypeScript into accepting
    wrong data types, so you can never be totally sure that your code is always pure!
  prefs: []
  type: TYPE_NORMAL
- en: Throughout these sections, we have gone through the characteristics of pure
    and impure functions. Let’s finish the chapter by looking at how we can test these
    sorts of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing – pure versus impure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how pure functions are conceptually better than impure ones, but
    we cannot set out on a crusade to vanquish all impurities from our code. First,
    no one can deny that side effects can be useful, or at least unavoidable: you
    will need to interact with the DOM or call a web service, and there are no ways
    to do this in a pure way. So, rather than bemoaning the fact that you have to
    allow for impurity, try to structure your code to isolate the impure functions
    and let the rest of your code be the best it can possibly be.'
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, you’ll have to be able to write unit tests for all kinds
    of functions, pure or impure. Writing unit tests is different, in terms of difficulty
    and complexity, for pure and impure functions. While coding tests for the former
    is usually quite simple and follows a basic pattern, the latter usually requires
    scaffolding and complex setups. So, let’s finish this chapter by seeing how to
    go about testing both types of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the characteristics of pure functions that we have already described,
    most of your unit tests could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the function with a given set of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that the results match what you expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with a couple of simple examples. Testing the `isOldEnough()` function
    would have been more complex than we needed for the version that required access
    to a global variable. On the other hand, the last version, `isOldEnough3()`, which
    didn’t require anything because it received two parameters, is simple to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing another of the pure functions we wrote is equally simple, but we must
    be careful because of precision considerations. If we test the `circleArea` function,
    we must use the Jest `toBeCloseTo()` matcher, which allows for approximate equality
    when dealing with floating-point numbers. (See *Question 4.9* for more on math
    in JavaScript.) Other than this, the tests are just about the same—call the function
    with known arguments and check the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'No difficulty whatsoever! (I wrote the three tests in different styles on purpose,
    just for variety.) The test run reports success for both suites (see *Figure 4**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – A successful test run for a pair of pure functions](img/Figure_4.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – A successful test run for a pair of pure functions
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have to worry about pure functions; let’s move on to the impure ones
    we dealt with by transforming them into pure equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Testing purified functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we considered the following `roundFix()` special function that required
    us to use the state to accumulate the differences due to rounding, we produced
    a new version by providing the current state as an added parameter and by having
    the function return two values—the rounded one and the updated state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is now pure, but testing it requires validating not only the
    returned values but also the updated states. We can base our tests on the experiments
    we did previously. Once again, we have to use `toBeCloseTo()` for dealing with
    floating-point numbers (and see *Question 4.10* for more on this), but we can
    use `toBe()` with integers, which produces no rounding errors. We could write
    our tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We included several cases, with positive, zero, or negative accumulated differences,
    and checked whether they rounded up or down on each occasion. We could certainly
    go further by rounding negative numbers, but the idea is clear: if your function
    takes the current state as a parameter and updates it, the only difference with
    the pure functions’ tests is that you will also have to test whether the returned
    state matches your expectations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now consider an alternative way of testing for our *purified* `getRandomLetter2()`
    function. This is simple: you have to provide a function that produces random
    numbers. (This kind of function, in testing parlance, is called a stub.) There’s
    no limit to the complexity of a stub, but you’ll want to keep it simple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our knowledge of the workings of the function, we can then do some
    tests to verify that low values produce an `"A"` output and values close to 1
    produce a `"Z"` output so that we can have a little confidence that no extra values
    are produced. We should also test that a middle value (around 0.5) should generate
    a letter around the middle of the alphabet. However, this kind of test is not
    very good—if we implemented `getRandomLetter2()` in another way, it might work
    perfectly well but not pass this test! Our tests could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing our filename generator can be done similarly, by using stubs. We can
    provide a simple stub, `f()`, that will return the letters of `"SORTOFRANDOM"`
    in sequence (this function is quite impure; can you see why?). So, we can verify
    that the returned filename matches the expected name and a couple more properties
    of the returned filename, such as its length and extension. Our test could then
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Testing *purified* impure functions is the same as testing originally pure functions.
    Now, we need to consider some cases of truly impure functions because, as we said,
    it’s quite certain that at some time or another, you’ll have to use such functions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing impure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For starters, we’ll return to our original `getRandomLetter()` function. With
    insider knowledge about its implementation (this is called `Math.random()` method
    and set a mock function that will return whichever values we desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can revisit some of the test cases we went through in the previous section.
    In the first case, we set `Math.random()` to return 0.0001 (and test that it was
    actually called) and we also check that the final return is `"A"`. In the second
    case, just for variety, we set things up so that `Math.random()` will be called
    twice, returning two different values. We also verify that both results are `"Z"`.
    Our revisited tests could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: (Of course, you wouldn’t go around inventing whatever tests came into your head.
    In all likelihood, you’ll work from the description of the desired `getRandomLetter()`
    function, which was written before you started to code or test it. In our case,
    I’m making do as if that specification did exist, and it pointedly said—for example—that
    values close to 0 should produce an `"A"` output, values close to 1 should return
    `"Z"`, and the function should return ascending letters for ascending random values.)
  prefs: []
  type: TYPE_NORMAL
- en: Now, how would you test the original `getRandomFileName()` function, the one
    that called the impure `getRandomLetter()` function? That’s a much more complicated
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'What kind of expectations do you have? You cannot know the results it will
    give, so you won’t be able to write any `.toBe()` type of tests. What you can
    do is test for some properties of the expected results, and also, if your function
    implies randomness of some kind, you can repeat the tests as many times as you
    want so that you have a bigger chance of catching a bug. We could do some tests
    along the lines of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not passing any random letter generator function to `getFileName()`,
    so it will use the original, impure one. We ran some of the tests a hundred times,
    as extra insurance. Our tests check for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Filenames are 12 letters long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names only include letters “`A`” to “`Z`”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filenames include the provided extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no extension is provided, none is included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need for evidence
  prefs: []
  type: TYPE_NORMAL
- en: When testing code, always remember that *absence of evidence isn’t evidence
    of absence*. Even if our repeated tests succeed, there is no guarantee that they
    won’t produce an unexpected, hitherto undetected, error with some other random
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do another property test. Suppose we want to test a shuffling algorithm;
    we might decide to implement the Fisher–Yates version along the lines of the following
    code. (For more on this algorithm—including some pitfalls for the unwary programmer—see
    [en.wikipedia.org/wiki/Fisher-Yates_shuffle](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle).)
    As implemented, the algorithm is doubly impure: it doesn’t always produce the
    same result (obviously!) and it modifies its input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'How could you test this algorithm? Given that the result won’t be predictable,
    we can check for the properties of its output. We can call it with a known array
    and then test some properties—but see *Question 4.13* for an important detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We had to write the second part of the unit tests in that way because, as we
    saw, `shuffle()` modifies the input parameter. For tests for a different (and
    bad!) shuffling function, see *Question 4.14*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of pure functions and studied why
    they matter. We also saw the problems caused by side effects—one of the causes
    of impure functions—looked at some ways of purifying such impure functions, and
    finally, we saw several ways of performing unit tests for both pure and impure
    functions. With these techniques, you’ll be able to favor using pure functions
    in your programming, and when impure functions are needed, you’ll have some ways
    of using them in a controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    we’ll show other advantages of FP: how you can program in a declarative fashion
    at a higher level for more straightforward and robust code.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4.1 **Must return?**A simple, almost philosophical question: must pure functions
    always return something? Could you have a pure function that doesn’t return anything?'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 `maxStrings()`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 4.3 `cache` array for the optimized `fib2()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '4.4 **Minimalistic function**: Functional programmers sometimes write code
    in a minimalistic way. Can you examine the following version of the Fibonacci
    function and explain whether it works, and if so, how?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '4.5 `fib4(6)` by hand and compare it with the example given earlier in the
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 4.6 `roundFix2()` function? Even when TypeScript can work it out by itself (as
    in this case), I prefer spelling it out for extra checks.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 `roundFix2()` so that it will return a tuple instead of a record. The input
    to this rewritten function could be two separate arguments or a single tuple argument.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 **One injection or two?** Why is it better to inject an object with two
    functions rather than two separate functions? In other words, why not write something
    like the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 4.9 `toBeCloseTo()` because of precision problems. A related question, often
    asked in job interviews, is *what will the following code output,* *and why?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '4.10 `toBeCloseTo()` is practical but can cause problems. Some basic mathematics
    properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A number should equal itself: for all numbers *a*, *a* should equal *a*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, then *b* should equal *a*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *b* equals *c*, then *a* should equal *c*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *c* equals *d*, then *a*+*c* should equal *b*+*d*, *a*-*c*
    should equal *b*-*d*, *a***c* should equal *b***d*, and *a*/*c* should equal *b*/*d*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does `toBeCloseTo()` satisfy all these properties?
  prefs: []
  type: TYPE_NORMAL
- en: 4.11 `<T>` in the definition of `shuffle()`?
  prefs: []
  type: TYPE_NORMAL
- en: 4.12 `shuffle()` modifies the input array in place (a side effect!) we don’t
    really need the final `return arr` line and could remove it. What would be the
    type definition of `shuffle()` then?
  prefs: []
  type: TYPE_NORMAL
- en: 4.13\. `shuffle()` to test whether it works correctly with arrays with repeated
    values? The tests we wrote are only valid for arrays with distinct values; can
    you see why?
  prefs: []
  type: TYPE_NORMAL
- en: 4.14 **Popular, but wrong!** Many online articles suggest the following code
    as a way of shuffling. The idea is to sort the array, but, instead of using a
    correct comparison function to randomly return positive or negative values, these
    random comparisons should get the array in disorder. However, the idea is wrong
    and the algorithm is bad because it doesn’t produce all possible outputs with
    equal probability. How can you check that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '4.15 **Shuffling by sorting**: Sorting and shuffling can be seen as opposite
    functions; one brings order, and the other produces disorder. However, there’s
    a way to shuffle an array by sorting; can you figure out how? (And no, the answer
    is *not* the lousy algorithm shown in the previous question!) We are looking for
    an algorithm that can produce every possible output with the same probability,
    not favoring some outputs over others.'
  prefs: []
  type: TYPE_NORMAL
