- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Behaving Properly – Pure Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确行为——纯净函数
- en: In [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*,
    we considered functions as the critical elements in **functional programming**
    (**FP**), went into detail about arrow functions, and introduced some concepts,
    such as injection, callbacks, polyfilling, and stubbing. In this chapter, we’ll
    have the opportunity to revisit or apply some of those ideas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19301_03.xhtml#_idTextAnchor054)，“函数入门”，我们考虑函数作为**函数式编程**（**FP**）中的关键元素，详细介绍了箭头函数，并介绍了一些概念，例如注入、回调、polyfilling和stubbing。在本章中，我们将有机会回顾或应用这些想法。
- en: 'In this chapter, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Consider the notion of **purity** and why we should care about **pure functions**—and
    **impure functions** as well!
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑**纯净性**的概念以及为什么我们应该关注**纯净函数**——以及**不纯净函数**！
- en: Examine the concept of **referential transparency**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查**指称透明性**的概念
- en: Recognize the problems implied by side effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到副作用所暗示的问题
- en: Show some advantages of pure functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示纯净函数的一些优点
- en: Describe the main reasons behind impure functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不纯净函数背后的主要原因
- en: Discover ways to minimize the number of impure functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现最小化不纯净函数数量的方法
- en: Focus on ways of testing both pure and impure functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于测试纯净函数和不纯净函数的方法
- en: Pure functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯净函数
- en: 'Pure functions behave the same way as mathematical functions and provide various
    benefits. A function is pure if it satisfies two conditions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 纯净函数的行为与数学函数相同，并提供各种好处。一个函数是纯净的，如果它满足以下两个条件：
- en: '**Given the same arguments, the function always calculates and returns the
    same result**: This should be true no matter how many times it’s invoked or under
    which conditions you call it. This result cannot depend on any outside information
    or state, which could change during the program execution and cause it to return
    a different value. Nor can the function result depend on I/O results, random numbers,
    some other external variable, or a value that is not directly controllable.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定相同的参数，函数总是计算并返回相同的结果**：这应该在任何调用次数或调用条件下都成立。此结果不能依赖于任何外部信息或状态，这些信息或状态在程序执行过程中可能会改变，从而导致返回不同的值。同样，函数的结果也不能依赖于I/O结果、随机数、其他外部变量或无法直接控制的价值。'
- en: '**When calculating its result, the function doesn’t cause any observable side
    effects**: This includes output to I/O devices, the mutation of objects, changes
    to a program’s state outside of the function, and so on.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在计算其结果时，函数不会引起任何可观察的副作用**：这包括输出到I/O设备、对象的修改、函数外部程序状态的改变等。'
- en: You can simply say that pure functions don’t depend on (and don’t modify) anything
    outside their scope and always return the same result for the same input arguments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地这样说，纯净函数不依赖于（也不修改）它们作用域之外的东西，并且对于相同的输入参数总是返回相同的结果。
- en: Another word used in this context is **idempotency**, but it’s not exactly the
    same. An idempotent function can be called as many times as desired and will always
    produce the same result. However, this doesn’t imply that the function is free
    from side effects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中使用的另一个词是**幂等性**，但它并不完全相同。一个幂等的函数可以被调用任意多次，并且总是产生相同的结果。然而，这并不意味着函数没有副作用。
- en: Idempotency is usually mentioned in the context of RESTful services. Let’s see
    a simple example showing the difference between purity and idempotency. A `PUT`
    call would cause a database record to be updated (a side effect), but if you repeat
    the call, the element will not be further modified, so the global state of the
    database won’t change any further.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性通常在RESTful服务上下文中提到。让我们看看一个简单的例子，说明纯净性和幂等性的区别。一个`PUT`调用会导致数据库记录被更新（副作用），但如果你重复调用，元素将不会被进一步修改，因此数据库的全局状态不会进一步改变。
- en: We might also invoke a software design principle and remind ourselves that a
    function should *do one thing, only one thing, and nothing but that thing*. If
    a function does something else and has some hidden functionality, then that dependency
    on the state will mean that we won’t be able to predict the function’s output
    and will make things harder for us as developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能引用一个软件设计原则，并提醒自己，一个函数应该*只做一件事，只做那件事，而且只做那件事*。如果一个函数做了其他事情并且有一些隐藏的功能，那么这种对状态的依赖意味着我们无法预测函数的输出，这将使我们的开发工作变得更加困难。
- en: Let’s look into these conditions in more detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地研究这些条件。
- en: Referential transparency
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指称透明性
- en: In mathematics, referential transparency is the property that lets you replace
    an expression with its value without changing the results of whatever you are
    doing. The counterpart of referential transparency is, appropriately enough, **referential
    opacity**. A referentially opaque function cannot guarantee that it will always
    produce the same result, even when called with the same arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，引用透明性是指你可以用一个表达式的值来替换它，而不会改变你正在做的任何操作的结果。引用透明性的对立面，恰如其分地，是**引用不透明性**。一个引用不透明的函数不能保证它在用相同的参数调用时总是产生相同的结果。
- en: 'To give a simple example, let’s consider what happens with an optimizing compiler
    that performs **constant folding**. Suppose you have a sentence like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的例子来说明，让我们考虑一个执行**常量折叠**的优化编译器会发生什么。假设你有一个这样的句子：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The compiler might optimize the code to the following by noting that `2*3`
    is a constant value:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能会通过注意到 `2*3` 是一个常量值来优化代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Even better, a new round of optimization could avoid the sum altogether:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，新一轮的优化可以完全避免求和：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To save execution time, the compiler is taking advantage of the fact that all
    mathematical expressions and functions are (by definition) referentially transparent.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省执行时间，编译器正在利用这样一个事实：所有数学表达式和函数（根据定义）都是引用透明的。
- en: On the other hand, if the compiler cannot predict the output of a given expression,
    it won’t be able to optimize the code in any fashion, and the calculation will
    have to be done at runtime.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果编译器无法预测给定表达式的输出，它将无法以任何方式优化代码，计算将不得不在运行时完成。
- en: (TypeScript does a similar type analysis, and given the original `const x =
    1 + 2 * 3` line, it would correctly decide that `x` is of type `number`.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: （TypeScript 进行了类似的类型分析，并且根据原始的 `const x = 1 + 2 * 3` 行，它会正确地判断 `x` 的类型为 `number`。）
- en: Of lambdas and betas
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 lambda 和 beta
- en: In lambda calculus, if you replace the value of an expression involving a function
    with the calculated value for the function, then that operation is called a **β
    (beta) reduction**. Note that you can only do this safely with referentially transparent
    functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lambda 演算中，如果你用一个函数涉及的表达式的值替换为该函数的计算值，那么这个操作就称为**β (beta) 折减**。请注意，你只能安全地使用引用透明的函数来做这件事。
- en: 'All arithmetical expressions (involving both mathematical operators and functions)
    are referentially transparent: `22*9` can always be replaced by `198`. Expressions
    involving I/O are not transparent, given that their results cannot be known until
    executed. For the same reason, expressions involving date- and time-related functions
    or random numbers are also not transparent.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有算术表达式（涉及数学运算符和函数）都是引用透明的：`22*9` 总是可以替换为 `198`。涉及 I/O 的表达式不透明，因为它们的执行结果在执行之前是无法知道的。同样地，涉及日期和时间相关函数或随机数的表达式也不透明。
- en: Concerning JavaScript functions you can produce, it’s pretty easy to write some
    that won’t fulfill the referential transparency condition. In fact, a function
    is not even required to return a value, though the JavaScript interpreter will
    return `undefined` in that situation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于你可以生成的 JavaScript 函数，编写一些不满足引用透明性条件的函数相当容易。实际上，函数甚至不需要返回一个值，尽管在这种情况下 JavaScript
    解释器会返回 `undefined`。
- en: A matter of distinction
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 区分的问题
- en: Some languages distinguish between functions, which are expected to return a
    value, and procedures, which do not return anything, but that’s not the case with
    JavaScript. Some languages even provide the means to ensure that functions are
    referentially transparent.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言区分函数和过程，函数预期返回一个值，而过程不返回任何值，但 JavaScript 的情况并非如此。一些语言甚至提供了确保函数是引用透明的手段。
- en: 'If you wanted to, you could classify functions as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以这样对函数进行分类：
- en: '**Pure functions**: These return a value that depends only on its arguments
    and have no side effects whatsoever.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：这些函数返回的值仅取决于其参数，并且没有任何副作用。'
- en: '`undefined`, but that’s not relevant here) but do produce some side effects.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`，但在这里这不相关）但确实会产生一些副作用。'
- en: '**Functions with side effects**: This means that they return a value that may
    not only depend on the function arguments but also involve side effects.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有副作用的函数**：这意味着它们返回的值可能不仅取决于函数参数，还涉及副作用。'
- en: 'In FP, much emphasis is put on the first group: referentially transparent pure
    functions. A compiler can reason about the program behavior (and thus be able
    to optimize the generated code), and the programmer can more easily reason about
    the program and the relationship between its components. This, in turn, can help
    prove the correctness of an algorithm or optimize the code by replacing a function
    with an equivalent one.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，对第一组（引用透明的纯函数）给予了更多重视。编译器可以推理程序行为（从而能够优化生成的代码），程序员也可以更容易地推理程序及其组件之间的关系。这反过来可以帮助证明算法的正确性或通过用等效函数替换函数来优化代码。
- en: Side effects
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用
- en: What are side effects? We can define these as a change in state or an interaction
    with outside elements (the user, a web service, another computer—whatever) that
    occurs during the execution of some calculations or a process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是副作用？我们可以将这些定义为在执行某些计算或过程中的状态变化或与外部元素（用户、网络服务、另一台计算机——无论什么）的交互，这些交互发生在执行某些计算或过程中的某个时刻。
- en: There’s a possible misunderstanding as to the scope of this meaning. In everyday
    speech, when you speak of side effects, it’s a bit like talking about collateral
    damage—some unintended consequences for a given action; however, in computing,
    we include every possible effect or change outside the function. If you write
    a function meant to perform a `console.log()` call to display a result, that would
    be considered a side effect, even if it’s exactly what you intended the function
    to do in the first place!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个含义的范围，可能存在一些误解。在日常用语中，当你说到副作用时，就像谈论附带损害——对于某个动作的一些意外后果；然而，在计算机科学中，我们包括函数之外的所有可能的效果或变化。如果你编写一个函数，目的是执行一个`console.log()`调用以显示结果，那么这将被视为副作用，即使这最初正是你打算让函数执行的事情！
- en: 'In this section, we will look at the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下内容：
- en: Common side effects in JavaScript programming
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript编程中的常见副作用
- en: The problems that global and inner states cause
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局和内部状态引起的问题
- en: The possibility of functions mutating their arguments
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数修改其参数的可能性
- en: Some functions that are always troublesome
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些总是麻烦的函数
- en: Usual side effects
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的副作用
- en: 'In programming, there are (too many!) things that are considered side effects.
    In JavaScript programming, including both front- and backend coding, the more
    common ones you may find include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有（太多！）被认为是副作用的事情。在JavaScript编程中，包括前端和后端编码，你可能会遇到以下更常见的情况：
- en: Changing global variables.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改全局变量。
- en: Mutating objects received as arguments.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改作为参数接收的对象。
- en: Performing any I/O, such as showing an alert message or logging some text.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行任何I/O操作，例如显示一个警告消息或记录一些文本。
- en: Working with, or changing, the filesystem.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件系统一起工作或更改文件系统。
- en: Querying or updating a database.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询或更新数据库。
- en: Calling a web service.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个网络服务。
- en: Querying or modifying the DOM.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询或修改DOM。
- en: Triggering any external process.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发任何外部过程。
- en: 'Just calling another function that produces a side effect of its own. You could
    say that impurity is contagious: a function that calls an impure function automatically
    becomes impure on its own!'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只调用另一个产生自身副作用的函数。可以说，不纯性是具有传染性的：调用一个不纯函数的函数自动变得不纯！
- en: With this definition, let’s start looking at what can cause functional impurity
    (or referential opaqueness).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，让我们开始探讨什么可以导致函数的不纯性（或引用不透明性）。
- en: Global state
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局状态
- en: 'Of all the preceding points, the most common reason for side effects is the
    usage of nonlocal variables that share a global state with other parts of the
    program. Since pure functions, by definition, always return the same output value
    given the same input arguments, if a function refers to anything outside its internal
    state, it automatically becomes impure. Furthermore—and this is a hindrance to
    debugging—to understand what a function has done, you must understand how the
    state got its current values, which means understanding all of the past history
    from your program: not easy!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有上述点中，最常见的副作用原因是使用非局部变量，这些变量与其他程序部分共享全局状态。由于纯函数，根据定义，给定相同的输入参数总是返回相同的输出值，如果一个函数引用了其内部状态之外的内容，它就自动变成了不纯的。此外——这对调试是一个障碍——要了解一个函数做了什么，你必须了解状态是如何获得当前值的，这意味着理解程序的所有历史：这并不容易！
- en: 'Let’s write a function to detect whether a person is a legal adult by checking
    whether they were born at least 18 years ago. (OK—that’s not precise enough because
    we are not considering the day and month of birth, but bear with me; the problem
    is elsewhere.) A version of an `isOldEnough()` function could be as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来检测一个人是否是合法的成年人，通过检查他们是否至少18年前出生。（好吧——这不够精确，因为我们没有考虑出生的日和月，但请耐心等待；问题在其他地方。）一个`isOldEnough()`函数的版本可能如下所示：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `isOldEnough()` function correctly detects whether a person is at least
    18 years old, but it depends on an external variable—a variable good for 2022
    only! Even though the function works, the implementation isn’t the best that it
    could possibly be. You cannot tell what the function does unless you know about
    the external variable and how it got its value. Testing is also hard; you must
    remember to create the global `limitYear` variable, or all your tests will fail.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOldEnough()`函数正确地检测一个人是否至少18岁，但它依赖于一个外部变量——一个只适用于2022年的变量！尽管函数可以工作，但实现并不是最好的。除非你知道关于外部变量及其值的信息，否则你无法知道函数的功能。测试也很困难；你必须记得创建全局的`limitYear`变量，否则所有测试都会失败。'
- en: 'There is an exception to this rule. Check out the following case: is the following
    `circleArea()` function, which calculates the area of a circle given its radius,
    pure or not?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则有一个例外。看看以下情况：以下`circleArea()`函数，它根据圆的半径计算圆的面积，是纯函数还是非纯函数？
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though the function is accessing an external state, the fact that `PI`
    is a constant (and thus cannot be modified) would allow us to substitute it inside
    `circleArea` with no functional change, and so we should accept that the function
    is pure. The function will always return the same value for the same argument
    and thus fulfills our purity requirements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使函数正在访问外部状态，由于`PI`是一个常数（因此不能被修改），我们可以将其在`circleArea`函数内部替换，而不会对函数的功能产生影响，因此我们应该接受这个函数是纯函数。该函数对于相同的参数总是返回相同的值，从而满足我们的纯函数要求。
- en: If you were to use `Math.PI` instead of a constant as we defined in the code
    (a better idea, by the way) the constant cannot be changed, so the function would
    remain pure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`Math.PI`而不是我们在代码中定义的常数（顺便说一句，这是一个更好的主意），由于常数不能被更改，所以函数将保持纯函数状态。
- en: Here, we have dealt with problems caused by the global state; let’s move on
    to the inner state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理了由全局状态引起的问题；让我们继续讨论内部状态。
- en: Inner state
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部状态
- en: 'The notion is also extended to internal variables, in which a local state is
    stored and used for future calls. The external state is unchanged, but internal
    side effects imply future differences regarding what the function will return.
    Let’s imagine a `roundFix()` rounding function that considers whether it has been
    rounding up or down too much so that the next time, it will round the other way,
    bringing the accumulated difference closer to zero. Our function will have to
    accumulate the effects of previous roundings to decide how to proceed next. The
    implementation could be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念也扩展到内部变量，其中存储并使用局部状态以供未来的调用。外部状态保持不变，但内部副作用意味着函数将返回的结果在未来会有所不同。让我们想象一个`roundFix()`舍入函数，它会考虑是否已经向上或向下舍入过多，以便下次它会向另一方向舍入，使累积差异更接近零。我们的函数将不得不累积先前舍入的效果，以决定如何进行下一步。实现可能如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Some comments regarding this function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此函数的一些注释：
- en: 'The `console.log()` call is just for the sake of this example; it wouldn’t
    be included in the real-world function. It lists the accumulated difference up
    to the point and the result it will return: the given number rounded up or down.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console.log()`调用只是为了这个示例；它不会包含在现实世界的函数中。它列出了到该点的累积差异以及它将返回的结果：向上或向下舍入的给定数字。'
- en: We are using the IIFE pattern from the `myCounter()` example in the *Immediate
    invocation* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting
    Out with Functions,* to get a hidden internal variable.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用来自*立即执行函数表达式（IIFE）*模式的`myCounter()`示例，该模式位于[*第3章*](B19301_03.xhtml#_idTextAnchor054)*，从函数开始*部分，以获取隐藏的内部变量。
- en: 'The `nRounded` calculation could also be written as `Math[accum > 0 ? "ceil":
    "floor"](n)`—we test `accum` to see which method to invoke (`"ceil"` or `"floor"`)
    and then use the `Object["method"]` notation to indirectly invoke `Object.method()`.
    The way we used it, I think, is more clear, but I just wanted to give you a heads-up
    in case you happen to find this other coding style.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nRounded`的计算也可以写成`Math[accum > 0 ? "ceil": "floor"](n)`——我们测试`accum`以确定调用哪个方法（`"ceil"`或`"floor"`），然后使用`Object["method"]`的表示法间接调用`Object.method()`。我认为我们使用的方法更清晰，但我只是想提前提醒你，以防你偶然发现这种其他的编码风格。'
- en: 'Running this function with just two values (recognize them?) shows that results
    are not always the same for a given input. The `result` part of the console log
    shows how the value got rounded, up or down:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只用两个值运行这个函数（认出它们了吗？）表明对于给定的输入，结果并不总是相同的。控制台日志的`result`部分显示了值是如何四舍五入的，向上或向下：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first time around, `accum` is zero, so 3.14159 gets rounded down, and `accum`
    becomes 0.14159 in our favor. The second time, since `accum` is positive (meaning
    that we have been rounding in our favor), 2.71828 gets rounded up to 3, and now
    `accum` becomes negative. The third time, the same 2.71828 value gets rounded
    down to 2 because the accumulated difference was negative—we got different values
    for the same input! The rest of the example is similar; you can get the same value
    rounded up or down, depending on the accumulated differences, because the function’s
    result depends on its inner state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，`accum`为零，所以3.14159被向下舍入，`accum`变为0.14159。第二次，由于`accum`是正的（这意味着我们已经是在有利于我们的方向上舍入），2.71828被向上舍入到3，现在`accum`变为负数。第三次，相同的2.71828值被向下舍入到2，因为累积的差异是负的——对于相同的输入我们得到了不同的值！其余的例子类似；你可以根据累积的差异得到向上或向下舍入的相同值，因为函数的结果取决于其内部状态。
- en: Why not OOP?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不是面向对象编程（OOP）？
- en: This usage of the internal state is why many FP programmers think that using
    objects is potentially flawed. In OOP, we developers are used to storing information
    (attributes) and using them for future calculations; however, this usage is considered
    impure insofar as repeated method calls may return different values, although
    the same arguments are being passed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这种内部状态的使用，许多函数式编程（FP）程序员认为使用对象可能是有缺陷的。在面向对象编程（OOP）中，我们开发者习惯于存储信息（属性）并用于未来的计算；然而，这种使用被认为是不纯的，因为重复的方法调用可能会返回不同的值，尽管传递了相同的参数。
- en: We have now dealt with the problems caused by both global and inner states,
    but there are still more possible side effects. For example, what happens if a
    function changes the values of its arguments? Let’s consider this next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经处理了由全局和内部状态引起的问题，但还有更多的可能副作用。例如，如果一个函数改变了其参数的值会发生什么？让我们考虑这一点。
- en: Argument mutation
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数突变
- en: 'You also need to be aware of the possibility that an impure function will modify
    its arguments. In JavaScript, arguments are passed by value, except for arrays
    and objects, which are passed by reference. This implies that any modification
    to the function’s parameters will affect an actual modification of the original
    object or array. This can be further obscured by the fact that several `Math.max()`
    with no further ado). A short implementation could be as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要意识到一个不纯的函数可能会修改其参数的可能性。在JavaScript中，参数是通过值传递的，除了数组和对象，它们是通过引用传递的。这意味着对函数参数的任何修改都将影响原始对象或数组的实际修改。这一点可能被几个`Math.max()`（无需进一步说明）的简短实现所进一步掩盖。一个简短的实现可能如下所示：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The function does provide the correct result (and if you worry about foreign
    languages, we already saw a way around that in the *Injection – sorting it out*
    section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out with
    Functions*), but it has a defect. Let’s see what happened with the original array:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数确实提供了正确的结果（如果你担心外语，我们已经在[*第三章*](B19301_03.xhtml#_idTextAnchor054)*，开始使用函数*）的*注入
    – 解决问题*部分中看到了一种解决方案，但它有一个缺陷。让我们看看原始数组发生了什么：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Oops—the original array was modified; this is a side effect by definition! (TypeScript
    would have helped detect this error if we had only written a complete type definition
    for `maxStrings()`; see *Question 4.2* for details.) If you were to call `maxStrings(countries)`
    again, then instead of returning the same result as before, it would produce another
    value; clearly, this is not a pure function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——原始数组被修改了；这是定义上的副作用！（如果我们只为`maxStrings()`编写一个完整的类型定义，TypeScript本可以帮助检测这个错误；有关详细信息，请参阅*问题4.2*。）如果你再次调用`maxStrings(countries)`，那么它将不会返回之前的结果，而是产生另一个值；显然，这不是一个纯函数。
- en: 'In this case, a quick solution is to work on a copy of the array, and we can
    use the spread operator to help. Still, we’ll be dealing with more ways of avoiding
    these sorts of problems in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring
    Purity*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个快速的解决方案是在数组的副本上工作，我们可以使用扩展运算符来帮助。尽管如此，我们将在[*第10章*](B19301_10.xhtml#_idTextAnchor188)
    *确保纯度*中讨论更多避免这类问题的方法。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So now, we have found yet another cause for side effects: functions that modify
    their arguments. A final case to consider is functions that just have to be impure!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在又找到了另一个副作用的原因：修改其参数的函数。需要考虑的最后一个情况是必须不纯的函数！
- en: Troublesome functions
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 麻烦的函数
- en: 'Finally, some functions also cause problems. For instance, `Math.random()`
    is impure: it doesn’t always return the same value, and it would defeat its purpose
    if it did! Furthermore, each call to the function modifies a global seed value,
    from which the next random value will be calculated.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些函数也会引起问题。例如，`Math.random()`是不纯的：它并不总是返回相同的值，如果它这样做的话，就会违背其目的！此外，每次调用该函数都会修改一个全局种子值，下一个随机值将从该值计算出来。
- en: Not really random
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并非真正的随机
- en: The fact that random numbers are actually calculated by an internal function
    makes them not random at all; *pseudorandom* would be a better name for them.
    If you knew the used formula and the seed’s initial value, you’d be able to predict
    the following numbers, in a totally non-random way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数实际上是由一个内部函数计算出来的，这使得它们根本不是随机的；*伪随机*可能更适合它们的名称。如果你知道了使用的公式和种子初始值，你就能以完全非随机的方式预测接下来的数字。
- en: 'For instance, consider the following function that generates random letters
    from `"A"` to `"Z"`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下从"A"到"Z"生成随机字母的函数：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The fact that it receives no arguments, but is expected to produce different
    results upon each call, clearly points out that this function is impure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它不接受任何参数，但在每次调用时都期望产生不同的结果，这清楚地表明这个函数是不纯的。
- en: Random explanations
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随机解释
- en: Go to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
    for an explanation of our `getRandomLetter()` function, and to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)
    for the `.``charCodeAt()` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)了解我们的`getRandomLetter()`函数的解释，以及[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)了解`.charCodeAt()`方法。
- en: 'Impurity can be inherited by calling functions. If a function uses an impure
    function, it immediately becomes impure itself. We might want to use `getRandomLetter()`
    to generate random filenames with an optional given extension; our `getRandomFileName()`
    function could then be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不纯性可以通过调用函数来继承。如果一个函数使用了不纯的函数，它立即变得不纯。我们可能想使用`getRandomLetter()`来生成带有可选扩展名的随机文件名；那么我们的`getRandomFileName()`函数可以如下所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because of its usage of `getRandomLetter()`, `getRandomFileName()` is also
    impure, though it performs as expected, correctly producing totally random filenames:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了`getRandomLetter()`，`getRandomFileName()`也是不纯的，尽管它按预期执行，正确地生成了完全随机的文件名：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Keep this function in mind; we’ll see some ways around the unit testing problem
    later in this chapter, and we’ll rewrite it a bit to help with that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个函数；我们将在本章后面讨论一些绕过单元测试问题的方法，并且我们会稍作修改以帮助解决这个问题。
- en: 'The concern about impurity also extends to functions that access the current
    time or date because their results will depend on an external condition (namely,
    the time of day) that is part of the application’s *global* state. We could rewrite
    our `isOldEnough()` function to remove the dependency upon a global variable,
    but it wouldn’t help much. One attempt is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对不纯的担忧也扩展到访问当前时间或日期的函数，因为它们的结果将取决于一个外部条件（即一天中的时间），这是应用程序的*全局*状态的一部分。我们可以重写我们的`isOldEnough()`函数以消除对全局变量的依赖，但这不会有多大帮助。一个尝试如下：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A problem has been removed—the new `isOldEnough2()` function is now safer.
    Also, as long as you don’t use it near midnight just before New Year’s Day, it
    will consistently return the same results, so you could say—paraphrasing the *Ivory
    Soap* slogan from the 19th century—that it’s about *99.44% pure*; however, an
    inconvenience remains: how would you test it? If you were to write some tests
    that worked fine today, they’d start to fail next year. We’ll have to work a bit
    to solve this, and we’ll see how later.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题已经被解决——新的`isOldEnough2()`函数现在更安全。此外，只要你不在大年夜午夜前后使用它，它将始终返回相同的结果，所以可以说——借用19世纪象牙肥皂的广告语——它是“大约99.44%纯”；然而，一个不便之处仍然存在：你如何测试它？如果你编写了一些今天可以正常工作的测试，它们明年就会开始失败。我们得花点时间解决这个问题，稍后我们会看到。
- en: Several other functions that are also impure are those that cause I/O. If a
    function gets input from a source (a web service, the user themself, a file, or
    some other source), then the result may obviously vary. You should also consider
    the possibility of an I/O error, so the very same function, calling the same service
    or reading the same file, might at some point fail for reasons outside its control
    (you should assume that your filesystem, database, socket, and so on could be
    unavailable, and thus a given function call might produce an error instead of
    the expected constant, unvarying, answer).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 几个也是不纯的函数包括那些引起输入/输出的函数。如果一个函数从某个来源（一个网络服务、用户本人、一个文件或其它来源）获取输入，那么结果显然可能会变化。你还应该考虑I/O错误的可能性，因此，同一个函数，调用相同的服务或读取相同的文件，可能在某个时刻因为其控制范围之外的原因而失败（你应该假设你的文件系统、数据库、套接字等可能不可用，因此某个特定的函数调用可能会产生错误，而不是预期的恒定、不变的答案）。
- en: 'Even having a pure output and a generally safe statement (such as a `console.log()`)
    that doesn’t change anything internally (at least in a visible way) causes some
    side effects because the user does see a change: namely, the produced output.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有一个纯输出和通常安全的声明（如`console.log()`），它内部没有改变任何东西（至少在可见的方式上），也会引起一些副作用，因为用户确实会看到变化：即产生的输出。
- en: Does this imply that we won’t ever be able to write a program that requires
    random numbers, handles dates, performs I/O, and also uses pure functions? Not
    at all—but it does mean that some functions won’t be pure, and they will have
    some disadvantages that we will have to consider; we’ll return to this in a bit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们永远无法编写一个需要随机数、处理日期、执行I/O以及使用纯函数的程序？绝对不是——但这确实意味着某些函数不会是纯函数，它们将有一些我们必须考虑的缺点；我们稍后会回到这个问题。
- en: Advantages of pure functions
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数的优势
- en: The main advantage of using pure functions is that they don’t have any side
    effects. When you call a pure function, you don’t need to worry about anything
    other than which arguments you are passing to it. Also, more to the point, you
    can be sure that you will not cause any problems or break anything else because
    the function will only work with whatever you give it and not with outside sources.
    But this is not their only advantage. Let’s learn more in the following sections.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数的主要优势是它们没有任何副作用。当你调用一个纯函数时，你不需要担心任何其他事情，除了你传递给它的参数。更重要的是，你可以确信你不会引起任何问题或破坏其他东西，因为函数只会处理你给它的一切，而不会与外部来源交互。但这并不是它们的唯一优势。让我们在接下来的章节中了解更多。
- en: Order of execution
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行顺序
- en: 'Another way of looking at what we have been saying in this chapter is to see
    pure functions as robust. You know that their execution—in whichever order—won’t
    ever impact the system. This idea can be extended further: you could evaluate
    pure functions in parallel, with the assurance that results wouldn’t vary from
    what you would get in a single-threaded execution. (JavaScript doesn’t provide
    Java-like threads, but we can make do, more or less, with workers. We’ll cover
    this topic in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*.)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待我们在这章中所说内容的方法是将纯函数视为健壮的。你知道它们的执行——无论顺序如何——永远不会影响系统。这个想法可以进一步扩展：你可以并行评估纯函数，确保结果不会与单线程执行的结果不同。（JavaScript不提供Java-like线程，但我们可以用workers来做到这一点。我们将在[*第5章*](B19301_05.xhtml#_idTextAnchor084)，*声明式编程*）中讨论这个话题。）
- en: Another consideration to keep in mind when you work with pure functions is that
    there’s no explicit need to specify the order in which they should be called.
    If you work with mathematics, an expression such as `f(2)+f(5)` is always the
    same as `f(5)+f(2)`; this is called the *commutative property*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与纯函数一起工作时，需要记住的另一个考虑因素是，没有必要明确指定它们应该调用的顺序。如果你从事数学工作，表达式如 `f(2)+f(5)` 总是与 `f(5)+f(2)`
    相同；这被称为*交换律*。
- en: 'However, when you deal with impure functions, that can be false, as shown in
    the following purposefully written tricky function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你处理不纯函数时，这可能是不正确的，如下面故意写出的棘手函数所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With impure functions such as the previous one, you cannot assume that calculating
    `f(3)+f(3)` would produce the same result as `2*f(3)` or that `f(4)-f(4)` would
    actually be zero; check it out for yourself... Common mathematical properties,
    down the drain!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像前面那样的不纯函数，你不能假设计算 `f(3)+f(3)` 会产生与 `2*f(3)` 相同的结果，或者 `f(4)-f(4)` 实际上是零；你自己检查一下...
    常见的数学属性，都流失了！
- en: Why should you care? When writing code, willingly or not, you always keep in
    mind those properties you learned about, such as the commutative property. So,
    while you might think that both expressions should produce the same result and
    code accordingly, you may be in for a surprise when using impure functions, with
    hard-to-find bugs that are difficult to fix.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要关心这个？在编写代码时，无论是有意还是无意，你总是牢记你学到的那些属性，比如交换律。所以，虽然你可能认为这两个表达式应该产生相同的结果，并相应地编写代码，但当你使用不纯函数时，可能会遇到难以找到的难以修复的错误。
- en: Memoization
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: Since the output of a pure function for a given input is always the same, you
    can cache the function results and avoid a possibly costly recalculation. This
    process, which implies evaluating an expression only the first time and caching
    the result for later calls, is called **memoization**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纯函数对于给定输入的输出始终相同，你可以缓存函数结果并避免可能昂贵的重新计算。这个过程，意味着只评估表达式一次并将结果缓存以供后续调用，被称为**缓存**。
- en: 'We will return to this idea in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, but let’s look at an example done by hand. The Fibonacci
    sequence is always used for this example because of its simplicity and hidden
    calculation costs. This sequence is defined as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B19301_06.xhtml#_idTextAnchor107)，*生成函数*中回到这个想法，但让我们先看看一个手工完成的例子。斐波那契序列总是用于这个例子，因为它简单且隐藏的计算成本。这个序列被定义为如下：
- en: For *n*=0, fib(*n*)=0
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *n*=0，fib(*n*)=0
- en: For *n*=1, fib(*n*)=1
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *n*=1，fib(*n*)=1
- en: For *n*>1, fib(*n*)=fib(*n*-2)+fib(*n*-1)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *n*>1，fib(*n*)=fib(*n*-2)+fib(*n*-1)
- en: Fibonacci who?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契是谁？
- en: Fibonacci’s name actually comes from *filius Bonacci* or *son of Bonacci*. He
    is best known for having introduced the usage of digits 0-9 as we know them today,
    instead of the cumbersome Roman numbers. He derived the sequence named after him
    as the answer to a puzzle involving rabbits! You can read more about it, and Fibonacci’s
    life in general, at en.wikipedia.org/wiki/Fibonacci_number#History or [plus.maths.org/content/life-and-numbers-fibonacci](http://plus.maths.org/content/life-and-numbers-fibonacci).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契的名字实际上来自 *filius Bonacci* 或 *son of Bonacci*。他最著名的是引入了我们今天所知道的0-9位数的使用，而不是繁琐的罗马数字。他推导出以他的名字命名的序列作为解决涉及兔子的谜题的答案！你可以在en.wikipedia.org/wiki/Fibonacci_number#History或[plus.maths.org/content/life-and-numbers-fibonacci](http://plus.maths.org/content/life-and-numbers-fibonacci)上了解更多关于它和斐波那契生平的信息。
- en: 'If you run the numbers, the sequence starts with 0, then 1, and from that point
    onward, each term is the sum of the two previous ones: 1 again, then 2, 3, 5,
    8, 13, 21, 34, 55, and so on. Programming this series using recursion is simple;
    we’ll revisit this example in [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172),
    *Designing Functions*. The following code, a direct translation of the definition,
    will do—and see *Question 4.4* for an alternative:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这些数字，序列从0开始，然后是1，从那时起，每个项都是前两个项的和：1再次，然后是2，3，5，8，13，21，34，55，等等。使用递归编程这个序列很简单；我们将在[*第
    9 章*](B19301_09.xhtml#_idTextAnchor172)，*设计函数*中重新审视这个例子。以下代码是定义的直接翻译，将执行——参见*问题
    4.4*以获取另一种方法：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you try out this function for growing values of `n`, you’ll soon realize
    that there is a problem, and computation starts taking too much time. For example,
    I took timings (measured in milliseconds) at my machine and plotted them on a
    graph. Since the function is quite speedy, I had to run calculations 100 times
    for values of `n` between 0 and 40\. Even then, the times for small values of
    `n` were really tiny; it was only from 25 onward that I got interesting numbers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用递增的`n`值测试这个函数，你很快就会意识到存在问题，计算开始花费太多时间。例如，我在我的机器上进行了计时（以毫秒为单位），并在图表上绘制了它们。由于函数速度相当快，我不得不为0到40之间的`n`值运行100次计算。即便如此，小`n`值的计时仍然非常小；只有从25开始，我才得到了有趣的数据。
- en: 'The chart (see *Figure 4**.1*) shows exponential growth, which bodes ill:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图表（见*图 4.1*）显示了指数增长，这预示着不祥：
- en: '![Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially](img/Figure_4.1_B19301.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – fib()递归函数的计算时间呈指数增长](img/Figure_4.1_B19301.jpg)'
- en: Figure 4.1 – Calculation times for the ﬁb() recursive function go up exponentially
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – fib()递归函数的计算时间呈指数增长
- en: 'If we draw a diagram of all the calls required to calculate `fib(6)`, you’ll
    notice the problem:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绘制出计算`fib(6)`所需的所有调用的图表，你会注意到问题：
- en: '![Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication](img/Figure_4.2_B19301.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 计算 fib(6) 所需的计算显示了大量的重复](img/Figure_4.2_B19301.jpg)'
- en: Figure 4.2 – The calculations needed for ﬁb(6) show lots of duplication
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 计算 fib(6) 所需的计算显示了大量的重复
- en: Each node represents a call to compute `fib(n)`. We note the value of `n` in
    the node. Every call, except those for `n`=0 or `n`=1, requires further calls,
    as you can see in *Figure 4**.2*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点代表对计算`fib(n)`的调用。我们在节点中记录`n`的值。除了`n`=0或`n`=1的调用外，每个调用都需要进一步的调用，如图*图 4.2*所示。
- en: 'The reason for the increasing delays becomes obvious: for example, the calculation
    for `fib(2)` was repeated on four different occasions, and `fib(3)` was itself
    calculated three times. Given that our function is pure, we could have stored
    the calculated values to avoid running the numbers over and over again. A possible
    version, using a cache array for previously calculated values, would be as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 增加延迟的原因变得明显：例如，`fib(2)`的计算在四次不同的情况下被重复，而`fib(3)`本身被计算了三次。鉴于我们的函数是纯函数，我们本可以将计算值存储起来以避免反复运行数字。一个可能的版本，使用用于先前计算值的缓存数组，如下所示：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Initially, the `cache` array is empty. Whenever we need to calculate the value
    of `fib2(n)`, we check whether it was already calculated beforehand. If that’s
    not true, we do the calculation, but with a twist: instead of immediately returning
    the value, we first store it in the cache and then return it. This means that
    no calculation will be done twice: after we have calculated `fib2(n)` for a particular
    `n` value, future calls will not repeat the procedure and will return the earlier
    evaluated result.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，`cache`数组为空。每次我们需要计算`fib2(n)`的值时，我们会检查它是否之前已经计算过。如果不是，我们就进行计算，但有一个转折：不是立即返回值，而是首先将其存储在缓存中，然后返回。这意味着不会进行两次计算：一旦我们为特定的`n`值计算了`fib2(n)`，未来的调用将不会重复该过程，而是返回之前评估的结果。
- en: 'A few short notes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 几点简要说明：
- en: We memoized the function by hand, but we can do it with a higher-order function.
    We’ll see this later in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing
    Functions*. It is perfectly possible to memoize a function without having to change
    or rewrite it.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们手动备忘录化了函数，但我们可以使用高阶函数来完成。我们将在[*第 6 章*](B19301_06.xhtml#_idTextAnchor107)，*生产函数*中看到这一点。完全有可能备忘录化一个函数，而无需更改或重写它。
- en: Using a global `cache` variable isn’t a very good practice; we could have used
    an IIFE and a closure to hide `cache` from sight—do you see how? (Also, see *Question
    4.3* at the end of this chapter.) The `myCounter()` example in the *Immediate
    invocation* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting
    Out with Functions,* shows how.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局`cache`变量并不是一个好的做法；我们本可以使用IIFE和闭包来隐藏`cache`，你看懂了吗？（也请参阅本章末尾的*问题4.3*。）[*第3章*](B19301_03.xhtml#_idTextAnchor054)*，从函数开始入门*，中的`myCounter()`示例在*立即执行*部分展示了如何做到这一点。
- en: Of course, you will be constrained by the available cache space, and it’s possible
    you could eventually crash your application by eating up all available RAM. Resorting
    to external memory (a database, a file, or a cloud solution) would probably eat
    up all the performance advantages of caching. There are some standard solutions
    (involving eventually deleting items from the cache), but they are beyond the
    scope of this book.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，你将受到可用缓存空间的限制，并且有可能最终通过消耗所有可用的RAM来崩溃你的应用程序。求助于外部内存（数据库、文件或云解决方案）可能会吞噬缓存的所有性能优势。有一些标准解决方案（涉及最终从缓存中删除项目），但这些超出了本书的范围。
- en: Of course, you don’t need to do this for every pure function in your program.
    You’d do this sort of optimization only for frequently called functions that take
    a significant amount of time; otherwise, the added cache management time would
    cost more than what you expected to save!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要为程序中的每个纯函数都这样做。你只会对那些频繁调用且占用大量时间的函数进行此类优化；否则，增加的缓存管理时间可能会超过你预期的节省！
- en: Self-documentation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自我文档化
- en: Pure functions have another advantage. Since everything the function needs to
    work with is given to it through its parameters, with no hidden dependency whatsoever,
    when you read its source code, you have all you need to understand its objective.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数还有另一个优势。由于函数需要处理的所有内容都是通过其参数提供的，没有任何隐藏的依赖，当你阅读其源代码时，你就有所有你需要了解其目标所需的信息。
- en: 'An extra advantage: knowing that a function doesn’t access anything beyond
    its parameters makes you more confident in using it since you won’t be accidentally
    producing a side effect; the only thing the function will accomplish is what you
    already learned through its documentation.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的优势：知道一个函数不会访问其参数之外的内容，这让你在使用它时更有信心，因为你不会意外地产生副作用；函数唯一能完成的事情就是通过其文档你已经了解的内容。
- en: Unit tests (which we’ll cover in the next section) also work as documentation
    because they provide examples of what the function returns when given certain
    arguments. Most programmers will agree that the best kind of documentation is
    full of examples, and each unit test can be considered such a sample case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试（我们将在下一节中介绍）也充当文档的作用，因为它们提供了函数在给定某些参数时返回的示例。大多数程序员都会同意，最好的文档是充满示例的，每个单元测试都可以被视为这样一个案例。
- en: Testing
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: 'Yet another advantage of pure functions—and one of the most important ones—has
    to do with unit testing. Pure functions have a single responsibility: producing
    their output in terms of their input. So, when you write tests for pure functions,
    your work is greatly simplified because there is no context to consider and no
    state to simulate.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的另一个优势——也是最重要的优势之一——与单元测试有关。纯函数只有一个职责：根据其输入产生输出。因此，当你为纯函数编写测试时，你的工作会大大简化，因为你不需要考虑任何上下文，也不需要模拟任何状态。
- en: You can focus on providing inputs and checking outputs because all function
    calls can be reproduced in isolation, independently from the rest of the world.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以专注于提供输入和检查输出，因为所有函数调用都可以在隔离状态下重现，独立于世界上的其他部分。
- en: We have seen several aspects of pure functions. Let’s move on, learn about impure
    functions a bit, and finish by testing both pure and impure functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了纯函数的几个方面。让我们继续前进，了解一些不纯函数，最后测试纯函数和不纯函数。
- en: Impure functions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不纯函数
- en: 'If you decided to entirely forgo all kinds of side effects, then your programs
    would only be able to work with hardcoded inputs and wouldn’t be able to show
    you the calculated results! Similarly, most web pages would be useless: you wouldn’t
    be able to make web service calls or update the DOM; you’d only have static pages.
    And your Node code would be really useless for server-side work, as it wouldn’t
    be able to perform any I/O.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定完全放弃所有副作用，那么你的程序就只能处理硬编码的输入，并且无法显示计算结果！同样，大多数网页将变得毫无用处：你将无法进行网络服务调用或更新DOM；你将只有静态页面。而且你的Node代码对于服务器端工作将毫无用处，因为它无法执行任何I/O操作。
- en: Reducing side effects is a good goal in FP, but we shouldn’t go overboard! So,
    let’s think of how to avoid using impure functions, if possible, and how to deal
    with them if not, looking for the best way to contain or limit their scope.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，减少副作用是一个良好的目标，但我们不应该过分追求！因此，让我们思考如何尽可能避免使用不纯函数，如果无法避免，则如何处理它们，寻找最佳方法来限制或缩小它们的范围。
- en: Avoiding impure functions
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用不纯函数
- en: 'Earlier in this chapter, we saw the more common reasons for using impure functions.
    Let’s now consider how we can reduce the number of impure functions, even if doing
    away with all of them isn’t really feasible. Basically, we’ll have two methods
    for this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们看到了使用不纯函数的更常见原因。现在，让我们考虑如何减少不纯函数的数量，即使完全消除它们并不现实。基本上，我们将有两种方法：
- en: Avoiding the usage of state
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用状态
- en: Using a programming pattern, **injection**, to control impurities
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编程模式**注入**来控制不纯性
- en: Avoiding the usage of state
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用状态
- en: 'With regard to the usage of the global state—both getting and setting it—the
    solution is well known. The key points to this are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关于全局状态的使用——获取和设置——解决方案是众所周知的。以下是关键点：
- en: Provide whatever is needed of the global state to the function as arguments
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将全局状态所需的部分作为参数提供给函数
- en: If the function needs to update the state, it shouldn’t do it directly, but
    instead produce a new version of the state and return it
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数需要更新状态，它不应该直接进行，而应该生成一个新的状态版本并返回它
- en: It should be the caller’s responsibility to take the returned state, if any,
    and update the global state
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有返回的状态，更新全局状态应该是调用者的责任
- en: This is the technique that Redux uses for its reducers. (We saw this in the
    *What FP is not* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,
    Becoming Functional*, and the *Functions as objects* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*,
    Starting Out with Functions*.) The signature for a reducer is `(previousState,
    action) => newState`, meaning that it takes a state and an action as parameters
    and returns a new state as the result. Most specifically, the reducer is not supposed
    to change the `previousState` argument, which must remain untouched (we’ll learn
    more about this in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring
    Purity*).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Redux用于其reducers的技术。（我们在[*第一章*](B19301_01.xhtml#_idTextAnchor015)的*什么是函数式编程不是*部分和[*第三章*](B19301_03.xhtml#_idTextAnchor054)的*函数作为对象*部分中看到了这一点，分别是*成为函数式程序员*和*从函数开始*。）reducer的签名是`(previousState,
    action) => newState`，这意味着它接受状态和动作作为参数，并返回一个新的状态作为结果。最具体地说，reducer不应该改变`previousState`参数，它必须保持不变（我们将在[*第十章*](B19301_10.xhtml#_idTextAnchor188)的*确保纯净性*中了解更多关于这一点）。
- en: 'For our first version of the `isOldEnough()` function, which used a global
    `limitYear` variable, the change is simple enough: we have to provide `limitYear`
    as a parameter for the function. With this change, it will become pure since it
    will produce its result by only using its parameters.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个`isOldEnough()`函数版本，它使用了一个全局的`limitYear`变量，更改很简单：我们必须将`limitYear`作为参数提供给函数。通过这个更改，它将变得纯净，因为它将只通过使用其参数来生成结果。
- en: 'Even better, we should provide the current year and let the function do the
    math instead of forcing the caller to do so. Our newer version of the adult age
    test could then be as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的做法是提供当前年份，并让函数自己进行计算，而不是强迫调用者这样做。那么我们更新的成人年龄测试版本可以如下所示：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Obviously, we’ll have to change all the calls to provide the required `currentYear`
    argument (we could also use partial application, as we will see in [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*). The responsibility for the value of `currentYear` remains
    outside of the function, as before, but we have managed to avoid a defect:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们必须更改所有调用以提供所需的`currentYear`参数（我们也可以使用偏应用，正如我们将在[*第7章*](B19301_07.xhtml#_idTextAnchor128)，*转换函数*）中看到的）。`currentYear`的值责任仍然在函数外部，就像之前一样，但我们已经设法避免了缺陷：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also apply this solution to our peculiar `roundFix()` function. As you
    will recall, the function worked by accumulating the differences caused by rounding
    and deciding whether to round up or down depending on the sign of that accumulator.
    We cannot avoid using that state, but we can split off the rounding part from
    the accumulating part. Our original code (with fewer comments, no logging, and
    using arrow functions throughout) would be as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将此解决方案应用于我们特有的`roundFix()`函数。如您所回忆的，该函数通过累积舍入引起的差异并决定根据该累积器的符号向上还是向下舍入来工作。我们无法避免使用该状态，但我们可以将舍入部分从累积部分分离出来。我们的原始代码（注释较少，没有日志记录，并使用箭头函数）如下所示：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The newer version (see *Question 4.6* for more about this) would have two parameters:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本（有关更多信息，请参阅*问题4.6*）将有两个参数：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'How would you use this function? Initializing the accumulator, passing it to
    the function, and updating it afterward are now the responsibility of the caller
    code. You would have something like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何使用这个函数？初始化累积器，将其传递给函数，并在之后更新它现在是调用者代码的责任。你会有以下类似的内容：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The `accum` value is now part of the global state of the application
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accum`值现在是应用程序的全局状态的一部分'
- en: Since `roundFix2()` needs it, its value is provided in each call
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`roundFix2()`需要它，其值在每次调用中提供
- en: The caller is responsible for updating the global state, not `roundFix2()`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者负责更新全局状态，而不是`roundFix2()`
- en: Spreading, once more
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次扩展
- en: Note the usage of the destructuring assignment to allow a function to return
    more than a value and easily store each one in a different variable. For more
    on this, go to [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
    For an alternative see *Question 4.7*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用解构赋值来允许一个函数返回多个值，并轻松地将每个值存储在不同的变量中。有关更多信息，请参阅[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。有关替代方案，请参阅*问题4.7*。
- en: This new `roundFix2()` function is totally pure and can be easily tested. If
    you want to hide the accumulator from the rest of the application, you could still
    use a closure, as we have seen in other examples, but that would again introduce
    impurity in your code—your call!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`roundFix2()`函数是完全纯的，可以轻松测试。如果你想将累积器从应用程序的其余部分隐藏起来，你仍然可以使用闭包，就像我们在其他示例中看到的那样，但这又会再次在你的代码中引入不纯性——你的调用！
- en: Injecting impure functions
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入不纯函数
- en: If a function becomes impure because it needs to call another function that
    is itself impure, a way around this problem is to inject the required function
    in the call. This technique provides more flexibility in your code and allows
    for easier future changes and less complex unit testing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数因为需要调用另一个自身不纯的函数而变得不纯，解决这个问题的方法是在调用中注入所需的函数。这种技术为你的代码提供了更多的灵活性，并允许更容易的未来更改和更简单的单元测试。
- en: 'Let’s consider the random filename generator function that we saw earlier.
    The problematic part of this function is its usage of `getRandomLetter()` to produce
    the filename:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们之前看到的随机文件名生成函数。这个函数的问题部分在于它使用`getRandomLetter()`来生成文件名：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A way to solve this is to replace the impure function with an injected external
    one; we must now provide a `randomLetterFunc()` argument for our random filename
    function to use:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将不纯函数替换为一个注入的外部函数；我们现在必须为我们的随机文件名函数提供一个`randomLetterFunc()`参数来使用：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we have removed the inherent impurity from this function. If we want to
    provide a predefined pseudorandom function that returns fixed, known values, we
    can easily unit-test this function; we’ll see how in the following examples. The
    usage of the function will change, and we would have to write the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从这个函数中移除了固有的不纯性。如果我们想提供一个预定义的伪随机函数，该函数返回固定的、已知的值，我们可以轻松地对这个函数进行单元测试；我们将在下面的例子中看到。函数的使用将改变，我们可能需要编写以下内容：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If this bothers you, you may want to provide a default value for the `randomLetterFunc`
    parameter as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这让你烦恼，你可能想为`randomLetterFunc`参数提供一个默认值，如下所示：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can also solve this using **partial application**, as we’ll see in [*Chapter
    7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用**偏应用**来解决这个问题，我们将在[*第7章*](B19301_07.xhtml#_idTextAnchor128)*，*转换函数*中看到。
- en: This hasn’t actually avoided the usage of impure functions. Normally, you’ll
    call `getRandomFileName()` by providing it with the random letter generator we
    wrote, so it will behave as an impure function. However, if for testing purposes
    you provide a function that returns predefined (that is, not random) letters,
    you’ll be able to test it as if it were pure much more easily.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并没有避免使用不纯函数。通常，你会通过提供一个我们编写的随机字母生成器来调用`getRandomFileName()`，因此它表现得像一个不纯函数。然而，如果你出于测试目的提供一个返回预定义（即，非随机）字母的函数，你将能够更容易地像纯函数一样测试它。
- en: 'But what about the original problem function, `getRandomLetter()`? We can apply
    the same trick and write a new version, such as the following, which will have
    an argument that will produce random numbers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但原始问题函数`getRandomLetter()`怎么办？我们可以应用同样的技巧并编写一个新的版本，如下所示，它将有一个产生随机数的参数：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We should change `getRandomFileName3()` to call `getRandomLetter2()`. If it
    calls it without providing any parameters, `getRandomLetter2()` will behave in
    its expected random ways. But if we want to test whether `getRandomFileName3()`
    does what we wanted, we can run it with an injected function that will return
    whatever we decide, letting us test it thoroughly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将`getRandomFileName3()`修改为调用`getRandomLetter2()`。如果它不提供任何参数就调用它，`getRandomLetter2()`将以预期的随机方式运行。但如果我们想测试`getRandomFileName3()`是否按预期工作，我们可以通过注入一个返回我们决定的内容的函数来运行它，这样我们就可以彻底测试它。
- en: Bind them all
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定所有
- en: For the default of `getRandomNum`, we wrote `Math.random.bind(Math)`, as explained
    in the *Working with methods* section of the previous chapter. The alternative
    (arguably clearer for some people) is `() => Math.random()`; we’ll use it in the
    *Is your function pure?* section later in this chapter, just for variety.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`getRandomNum`的默认值，我们编写了`Math.random.bind(Math)`，如前一章的*与方法一起工作*部分所述。另一种（对某些人来说可能更清晰）的替代方法是`()
    => Math.random()`；我们将在本章后面的*你的函数是纯的吗？*部分使用它，只是为了多样化。
- en: 'Let’s finish this section with a more complex case: what happens with a function
    with multiple impurities? For instance, we could be working on a backend `calculateDebt()`
    service that calculates a person’s debt, given their `id`. To do that, we could
    access a database, get the list of the person’s invoices, and then call some service
    to get the amount owed in each invoice; the sum of those amounts would be the
    calculated debt. A skeleton of such a function could be as follows—and I’m using
    plain JavaScript to omit unnecessary details:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个更复杂的案例来结束这一节：一个具有多个不纯性的函数会发生什么？例如，我们可能正在处理一个后端`calculateDebt()`服务，该服务根据人的`id`计算债务。为此，我们可以访问数据库，获取该人的发票列表，然后调用一些服务以获取每张发票的欠款金额；这些金额的总和就是计算出的债务。这样一个函数的骨架可能如下——我使用纯JavaScript来省略不必要的细节：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: (If `calculatedDebt = wedAmounts.reduce(…)` is foreign to you, see the *Summing
    an array* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*,* *Programming
    Declaratively*.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你不熟悉`calculatedDebt = wedAmounts.reduce(…)`，请参阅[*第5章*](B19301_05.xhtml#_idTextAnchor084)*，*声明式编程*中的*求和数组*部分。）
- en: 'We cannot easily test such a function because it depends on the availability
    of a database and another service. To *purify* it, we need to inject two functions:
    one to get data from a database and another to query a service. The purified function
    would become this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能轻易地测试这样的函数，因为它依赖于数据库和另一个服务的可用性。为了*净化*它，我们需要注入两个函数：一个用于从数据库获取数据，另一个用于查询服务。净化后的函数将变成这样：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this code, `getInvoicesFromDb()` and `getOwedAmountFromAPI()` would be the
    functions that do the DB access and API call. Our `calculateDebt2()` function
    now doesn’t know (or need to know) the details of how to access and work with
    the DB or the other service; that’s a better software design.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`getInvoicesFromDb()`和`getOwedAmountFromAPI()`将是执行数据库访问和API调用的函数。我们的`calculateDebt2()`函数现在不知道（或不需要知道）如何访问和操作数据库或其他服务的细节；这是一个更好的软件设计。
- en: 'Now, the function has two parameters: `id` (as before) and an optional object
    with the two functions to be injected. In regular use, we wouldn’t supply the
    second parameter, and the function accesses the DB and calls the API as needed.
    But here’s the point: for testing purposes, we inject an object with two mock
    functions and are then able to write simple tests. (If you are wondering why we
    injected an object, see *Question 4.8*.)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个函数有两个参数：`id`（如前所述）和一个可选的对象，包含要注入的两个函数。在常规使用中，我们不会提供第二个参数，函数会根据需要访问数据库并调用API。但这里是关键点：为了测试目的，我们注入一个包含两个模拟函数的对象，然后能够编写简单的测试。（如果你想知道为什么我们注入了一个对象，请参阅*问题4.8*。）
- en: 'An extra detail: thorough real-world testing of functions is usually hard to
    achieve. For instance, how do you simulate a dropped connection or a failed service
    call? With injection, that’s no problem; we can easily provide a mock that will
    return wrong values, throw an exception, and do anything else you need for your
    complete testing.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的细节：在实际世界中彻底测试函数通常很难实现。例如，如何模拟断开连接或服务调用失败？使用注入，这不成问题；我们可以轻松提供一个返回错误值、抛出异常以及完成你需要的任何其他测试的模拟。
- en: Using injection to avoid impurities is very important and has a broad spectrum
    of applications for other problems. For example, instead of having a function
    directly access the DOM, we can provide it with injected functions that would
    do this. For testing purposes, it would be simple to verify that the tested function
    does what it needs to do without really interacting with the DOM (of course, we’d
    have to find another way to test those DOM-related functions). This can also apply
    to functions that need to update the DOM, generate new elements, and do all sorts
    of manipulations—you use some intermediary functions. We’ll even apply injection
    in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204)*, Implementing Design Patterns,*
    to derive a better system architecture, so it’s a powerful, key concept.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注入来避免杂质非常重要，并且对于其他问题有着广泛的应用。例如，我们不是让一个函数直接访问DOM，而是可以给它提供一些注入的函数来完成这项工作。在测试目的下，简单地验证被测试的函数是否完成了它需要做的事情，而不需要真正与DOM交互（当然，我们得找到另一种方法来测试那些与DOM相关的函数）。这同样适用于需要更新DOM、生成新元素以及进行各种操作的函数——你使用一些中间函数。我们甚至会在[*第11章*](B19301_11.xhtml#_idTextAnchor204)*，实现设计模式*中应用注入，以推导出更好的系统架构，因此它是一个强大且关键的概念。
- en: Is your function pure?
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的函数是纯函数吗？
- en: 'Let’s end this section by considering an important question: can you ensure
    that a function is truly pure? To show the difficulties of this task, we’ll go
    back to the simple `sum3()` function that we saw in the *Spread* section of [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional* , just rewritten
    to use arrow functions for brevity. Would you say that this function is pure?
    It certainly looks like it!'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑一个重要问题来结束本节：你能确保一个函数真正是纯函数吗？为了展示这个任务的困难，我们将回到我们在[*第1章*](B19301_01.xhtml#_idTextAnchor015)，*成为函数式开发者*，*散列*部分看到的简单`sum3()`函数，只是为了简洁而重写为使用箭头函数。你会说这个函数是纯函数吗？它看起来确实像是！
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s see: the function doesn’t access anything but its parameters, doesn’t
    even try to modify them (not that it could (or could it?)), doesn’t perform any
    I/O, or work with any of the impure functions or methods that we mentioned earlier.
    What could go wrong?'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看：这个函数没有访问任何东西，除了它的参数，它甚至没有尝试修改它们（当然，它不能（或它能吗？）），它没有执行任何I/O，也没有与任何我们之前提到的非纯函数或方法一起工作。可能出错的地方在哪里？
- en: 'The answer has to do with checking your assumptions. For example, who says
    the arguments for this function should be numbers? In plain JavaScript, we could
    call it with, say, strings, but we’re now using TypeScript, and it’s supposed
    to check that, right? And even if passing strings to the function, you might ask
    yourself: *OK, they could be strings, but the function would still be pure, wouldn’t
    it?* For an (assuredly evil!) answer to that, see the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 答案与检查你的假设有关。例如，谁说这个函数的参数应该是数字？在纯JavaScript中，我们可以用字符串调用它，但现在我们使用TypeScript，它应该检查这一点，对吧？即使向函数传递字符串，你也可能会问自己：*好吧，它们可以是字符串，但函数仍然会是纯的，不是吗？*
    对于这个（肯定邪恶！）问题的答案，请看以下代码：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Evil coding!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 恶劣的编码！
- en: We assigned a new function to the `x.valueOf()` method to make an object look
    like a number. We also lied when saying `x = {} as number`; otherwise, TypeScript
    would have objected that you were passing an object where a number was expected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个新函数分配给`x.valueOf()`方法，使对象看起来像是一个数字。当我们说`x = {} as number`时，我们也撒了谎；否则，TypeScript会反对你传递了一个期望数字的对象。
- en: Well, `sum3()` ought to be pure, but that actually depends on whichever parameters
    you pass to it; you can make a pure function behave impurely! You might console
    yourself by thinking that surely no one would pass such arguments, but edge cases
    are usually where bugs reside. But you need not resign yourself to abandoning
    the idea of pure functions. As we see, you can even con TypeScript into accepting
    wrong data types, so you can never be totally sure that your code is always pure!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`sum3()`应该是纯函数，但实际上这取决于你传递给它的参数；你可以让一个纯函数表现得像不纯函数！你可能会自我安慰地想，肯定没有人会传递这样的参数，但边缘情况通常是错误所在。但你不必放弃纯函数的想法。正如我们所见，你甚至可以欺骗TypeScript接受错误的数据类型，所以你永远不能完全确定你的代码总是纯的！
- en: Throughout these sections, we have gone through the characteristics of pure
    and impure functions. Let’s finish the chapter by looking at how we can test these
    sorts of functions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些章节中，我们已经探讨了纯函数和不纯函数的特点。让我们通过看看如何测试这类函数来结束这一章。
- en: Testing – pure versus impure
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 – 纯函数与不纯函数
- en: 'We have seen how pure functions are conceptually better than impure ones, but
    we cannot set out on a crusade to vanquish all impurities from our code. First,
    no one can deny that side effects can be useful, or at least unavoidable: you
    will need to interact with the DOM or call a web service, and there are no ways
    to do this in a pure way. So, rather than bemoaning the fact that you have to
    allow for impurity, try to structure your code to isolate the impure functions
    and let the rest of your code be the best it can possibly be.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到纯函数在概念上比不纯函数更好，但我们不能发动一场十字军东征，从我们的代码中消除所有的不纯性。首先，没有人能否认副作用可能是有用的，或者至少是不可避免的：你需要与DOM交互或调用网络服务，而这两种方式都没有纯方法可以做到。因此，与其哀叹不得不允许不纯性，不如尝试结构化你的代码，将不纯函数隔离开来，让其余的代码尽可能做到最好。
- en: With this in mind, you’ll have to be able to write unit tests for all kinds
    of functions, pure or impure. Writing unit tests is different, in terms of difficulty
    and complexity, for pure and impure functions. While coding tests for the former
    is usually quite simple and follows a basic pattern, the latter usually requires
    scaffolding and complex setups. So, let’s finish this chapter by seeing how to
    go about testing both types of functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你必须能够为所有类型的函数编写单元测试，无论是纯函数还是不纯函数。编写单元测试在难度和复杂性方面对纯函数和不纯函数是不同的。对于前者，编写测试代码通常相当简单，遵循一个基本模式，而对于后者，通常需要搭建脚手架和复杂的设置。因此，让我们通过看看如何测试这两种类型的函数来结束这一章。
- en: Testing pure functions
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: 'Given the characteristics of pure functions that we have already described,
    most of your unit tests could be the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们已描述的纯函数的特点，你大部分的单元测试可能是以下这样的：
- en: Calling the function with a given set of arguments
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的参数集调用函数
- en: Verifying that the results match what you expected
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证结果是否符合预期
- en: 'Let’s start with a couple of simple examples. Testing the `isOldEnough()` function
    would have been more complex than we needed for the version that required access
    to a global variable. On the other hand, the last version, `isOldEnough3()`, which
    didn’t require anything because it received two parameters, is simple to test:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从几个简单的例子开始。测试`isOldEnough()`函数比我们需要的版本更复杂，因为那个版本需要访问全局变量。另一方面，最后一个版本`isOldEnough3()`，因为它接收了两个参数，所以不需要任何东西，测试起来很简单：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Testing another of the pure functions we wrote is equally simple, but we must
    be careful because of precision considerations. If we test the `circleArea` function,
    we must use the Jest `toBeCloseTo()` matcher, which allows for approximate equality
    when dealing with floating-point numbers. (See *Question 4.9* for more on math
    in JavaScript.) Other than this, the tests are just about the same—call the function
    with known arguments and check the expected results:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们编写的另一个纯函数同样简单，但我们必须小心，因为考虑到精度。如果我们测试`circleArea`函数，我们必须使用Jest的`toBeCloseTo()`匹配器，它允许在处理浮点数时进行近似相等。有关JavaScript中的数学的更多信息，请参阅*问题4.9*）。除了这一点，测试几乎相同——用已知的参数调用函数并检查预期的结果：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'No difficulty whatsoever! (I wrote the three tests in different styles on purpose,
    just for variety.) The test run reports success for both suites (see *Figure 4**.3*):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完全没有难度！（我故意用不同的风格写了三个测试，只是为了多样化。）测试运行报告显示两个测试套件都成功（见*图4.3*）：
- en: '![Figure 4.3 – A successful test run for a pair of pure functions](img/Figure_4.3_B19301.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 一对纯函数的成功测试运行](img/Figure_4.3_B19301.jpg)'
- en: Figure 4.3 – A successful test run for a pair of pure functions
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 一对纯函数的成功测试运行
- en: We don’t have to worry about pure functions; let’s move on to the impure ones
    we dealt with by transforming them into pure equivalents.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心纯函数；让我们继续处理我们通过转换为纯等价物来处理的非纯函数。
- en: Testing purified functions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试净化函数
- en: 'When we considered the following `roundFix()` special function that required
    us to use the state to accumulate the differences due to rounding, we produced
    a new version by providing the current state as an added parameter and by having
    the function return two values—the rounded one and the updated state:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑以下`roundFix()`特殊函数时，它要求我们使用状态来累积舍入差异，我们通过提供当前状态作为附加参数并让函数返回两个值——舍入后的值和更新的状态来生成一个新的版本：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function is now pure, but testing it requires validating not only the
    returned values but also the updated states. We can base our tests on the experiments
    we did previously. Once again, we have to use `toBeCloseTo()` for dealing with
    floating-point numbers (and see *Question 4.10* for more on this), but we can
    use `toBe()` with integers, which produces no rounding errors. We could write
    our tests as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数现在是纯函数，但测试它不仅需要验证返回的值，还需要验证更新的状态。我们可以基于之前所做的实验来构建我们的测试。再次强调，我们必须使用`toBeCloseTo()`来处理浮点数（有关更多内容，请参阅*问题4.10*），但对于整数，我们可以使用`toBe()`，这不会产生舍入错误。我们可以这样编写我们的测试：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We included several cases, with positive, zero, or negative accumulated differences,
    and checked whether they rounded up or down on each occasion. We could certainly
    go further by rounding negative numbers, but the idea is clear: if your function
    takes the current state as a parameter and updates it, the only difference with
    the pure functions’ tests is that you will also have to test whether the returned
    state matches your expectations.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了几个案例，其中累积差异为正、零或负，并检查了它们在每种情况下是向上还是向下舍入。我们当然可以通过对负数进行舍入来进一步深入，但这个想法很明确：如果你的函数将当前状态作为参数并更新它，与纯函数的测试相比，唯一的区别是你还必须测试返回的状态是否符合你的预期。
- en: 'Let’s now consider an alternative way of testing for our *purified* `getRandomLetter2()`
    function. This is simple: you have to provide a function that produces random
    numbers. (This kind of function, in testing parlance, is called a stub.) There’s
    no limit to the complexity of a stub, but you’ll want to keep it simple.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一种测试我们的*净化*`getRandomLetter2()`函数的替代方法。这很简单：你必须提供一个生成随机数的函数。（在测试术语中，这种函数被称为存根。）存根的复杂性没有限制，但你希望保持它简单。
- en: 'Based on our knowledge of the workings of the function, we can then do some
    tests to verify that low values produce an `"A"` output and values close to 1
    produce a `"Z"` output so that we can have a little confidence that no extra values
    are produced. We should also test that a middle value (around 0.5) should generate
    a letter around the middle of the alphabet. However, this kind of test is not
    very good—if we implemented `getRandomLetter2()` in another way, it might work
    perfectly well but not pass this test! Our tests could be written as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对函数工作原理的了解，我们可以进行一些测试来验证低值产生“A”输出，而接近1的值产生“Z”输出，这样我们就可以对没有产生额外值有一定的信心。我们还应该测试中间值（大约0.5）应该生成字母表中中间位置的字母。然而，这种测试并不很好——如果我们用另一种方式实现了`getRandomLetter2()`，它可能工作得很好，但不会通过这个测试！我们的测试可以写成如下：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Testing our filename generator can be done similarly, by using stubs. We can
    provide a simple stub, `f()`, that will return the letters of `"SORTOFRANDOM"`
    in sequence (this function is quite impure; can you see why?). So, we can verify
    that the returned filename matches the expected name and a couple more properties
    of the returned filename, such as its length and extension. Our test could then
    be written as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用存根来测试我们的文件名生成器可以类似地进行，我们可以提供一个简单的存根`f()`，它将按顺序返回`"SORTOFRANDOM"`中的字母（这个函数相当不纯；你能看出为什么吗？）。因此，我们可以验证返回的文件名与预期的名称匹配，以及返回的文件名的几个其他属性，例如其长度和扩展名。我们的测试可以写成如下所示：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Testing *purified* impure functions is the same as testing originally pure functions.
    Now, we need to consider some cases of truly impure functions because, as we said,
    it’s quite certain that at some time or another, you’ll have to use such functions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 测试*纯化*不纯函数与测试原始纯函数相同。现在，我们需要考虑一些真正不纯函数的情况，因为正如我们所说，在某个时候，你肯定会需要使用这样的函数。
- en: Testing impure functions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试不纯函数
- en: For starters, we’ll return to our original `getRandomLetter()` function. With
    insider knowledge about its implementation (this is called `Math.random()` method
    and set a mock function that will return whichever values we desire.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回到原始的`getRandomLetter()`函数。通过对其实现的内幕知识（这被称为`Math.random()`方法）设置一个模拟函数，该函数将返回我们想要的任何值。
- en: 'We can revisit some of the test cases we went through in the previous section.
    In the first case, we set `Math.random()` to return 0.0001 (and test that it was
    actually called) and we also check that the final return is `"A"`. In the second
    case, just for variety, we set things up so that `Math.random()` will be called
    twice, returning two different values. We also verify that both results are `"Z"`.
    Our revisited tests could look as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回顾一下上一节中我们讨论的一些测试用例。在第一种情况下，我们将`Math.random()`设置为返回0.0001（并测试它是否确实被调用），我们还检查最终返回的是`"A"`。在第二种情况下，为了多样化，我们设置了一个场景，使得`Math.random()`将被调用两次，返回两个不同的值。我们还验证了两个结果都是`"Z"`。我们回顾的测试可能如下所示：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: (Of course, you wouldn’t go around inventing whatever tests came into your head.
    In all likelihood, you’ll work from the description of the desired `getRandomLetter()`
    function, which was written before you started to code or test it. In our case,
    I’m making do as if that specification did exist, and it pointedly said—for example—that
    values close to 0 should produce an `"A"` output, values close to 1 should return
    `"Z"`, and the function should return ascending letters for ascending random values.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，你不会随意发明任何出现在你脑海中的测试。很可能会根据你开始编码或测试之前编写的预期`getRandomLetter()`函数的描述进行工作。在我们的情况下，我假设该规范存在，并且明确指出——例如——接近0的值应该产生`"A"`输出，接近1的值应该返回`"Z"`，并且函数应该对递增的随机值返回递增的字母。）
- en: Now, how would you test the original `getRandomFileName()` function, the one
    that called the impure `getRandomLetter()` function? That’s a much more complicated
    problem.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将如何测试原始的`getRandomFileName()`函数，即调用不纯的`getRandomLetter()`函数的那个函数？这是一个更复杂的问题。
- en: 'What kind of expectations do you have? You cannot know the results it will
    give, so you won’t be able to write any `.toBe()` type of tests. What you can
    do is test for some properties of the expected results, and also, if your function
    implies randomness of some kind, you can repeat the tests as many times as you
    want so that you have a bigger chance of catching a bug. We could do some tests
    along the lines of the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你有什么样的期望？你无法知道它将给出的结果，因此你将无法编写任何`.toBe()`类型的测试。你可以做的是测试预期结果的某些属性，如果你的函数暗示了某种随机性，你可以重复测试任意多次，这样你就有更大的机会捕捉到错误。我们可以进行一些类似于以下代码的测试：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are not passing any random letter generator function to `getFileName()`,
    so it will use the original, impure one. We ran some of the tests a hundred times,
    as extra insurance. Our tests check for the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将任何随机字母生成函数传递给`getFileName()`，因此它将使用原始的不纯函数。我们运行了一些测试一百次，作为额外的保险。我们的测试检查以下内容：
- en: Filenames are 12 letters long
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名长度为12个字母
- en: Names only include letters “`A`” to “`Z`”
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称只包含字母“`A`”到“`Z`”
- en: Filenames include the provided extension
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名包含提供的扩展名
- en: If no extension is provided, none is included
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有提供扩展名，则不包含任何扩展名
- en: Need for evidence
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 需要证据
- en: When testing code, always remember that *absence of evidence isn’t evidence
    of absence*. Even if our repeated tests succeed, there is no guarantee that they
    won’t produce an unexpected, hitherto undetected, error with some other random
    input.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码时，始终记住*没有证据并不意味着没有证据*。即使我们的重复测试成功，也不能保证它们不会在某个其他随机输入上产生意外、以前未检测到的错误。
- en: 'Let’s do another property test. Suppose we want to test a shuffling algorithm;
    we might decide to implement the Fisher–Yates version along the lines of the following
    code. (For more on this algorithm—including some pitfalls for the unwary programmer—see
    [en.wikipedia.org/wiki/Fisher-Yates_shuffle](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle).)
    As implemented, the algorithm is doubly impure: it doesn’t always produce the
    same result (obviously!) and it modifies its input parameter:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再进行另一个属性测试。假设我们想要测试一个洗牌算法；我们可能会决定按照以下代码实现Fisher–Yates版本。（关于此算法的更多信息——包括对粗心大意的程序员的陷阱——请参阅[en.wikipedia.org/wiki/Fisher-Yates_shuffle](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle)。）按照实现，该算法是双重的非纯：它并不总是产生相同的结果（显然！）并且它修改了它的输入参数：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'How could you test this algorithm? Given that the result won’t be predictable,
    we can check for the properties of its output. We can call it with a known array
    and then test some properties—but see *Question 4.13* for an important detail:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何测试这个算法？鉴于结果是不可预测的，我们可以检查其输出的属性。我们可以用一个已知的数组调用它，然后测试一些属性——但请参阅*问题 4.13*以了解一个重要细节：
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We had to write the second part of the unit tests in that way because, as we
    saw, `shuffle()` modifies the input parameter. For tests for a different (and
    bad!) shuffling function, see *Question 4.14*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不以这种方式编写单元测试的第二部分，因为正如我们所看到的，`shuffle()`会修改输入参数。对于不同（且不好！）的洗牌函数的测试，请参阅*问题
    4.14*。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the concept of pure functions and studied why
    they matter. We also saw the problems caused by side effects—one of the causes
    of impure functions—looked at some ways of purifying such impure functions, and
    finally, we saw several ways of performing unit tests for both pure and impure
    functions. With these techniques, you’ll be able to favor using pure functions
    in your programming, and when impure functions are needed, you’ll have some ways
    of using them in a controlled manner.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了纯函数的概念，并研究了它们为什么重要。我们还看到了由副作用（不纯函数的一个原因）引起的问题——查看一些净化这种不纯函数的方法，最后，我们看到了对纯函数和不纯函数进行单元测试的几种方法。有了这些技术，你将能够在编程中优先使用纯函数，当需要不纯函数时，你将有一些方法可以以受控的方式使用它们。
- en: 'In [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    we’ll show other advantages of FP: how you can program in a declarative fashion
    at a higher level for more straightforward and robust code.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B19301_05.xhtml#_idTextAnchor084) *声明式编程*中，我们将展示函数式编程的其他优点：如何在更高层次上以声明式方式编程，以获得更直接和健壮的代码。
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '4.1 **Must return?**A simple, almost philosophical question: must pure functions
    always return something? Could you have a pure function that doesn’t return anything?'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 4.1 **必须返回吗？**一个简单、几乎哲学性的问题：纯函数是否总是必须返回一些东西？你能有一个不返回任何内容的纯函数吗？
- en: 4.2 `maxStrings()`?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2 `maxStrings()`？
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 4.3 `cache` array for the optimized `fib2()` function.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 4.3 为优化后的`fib2()`函数创建`cache`数组。
- en: '4.4 **Minimalistic function**: Functional programmers sometimes write code
    in a minimalistic way. Can you examine the following version of the Fibonacci
    function and explain whether it works, and if so, how?'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 4.4 **最小化函数**：函数式程序员有时会以最小化方式编写代码。你能检查以下版本的斐波那契函数，并解释它是否工作，如果是的话，是如何工作的吗？
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '4.5 `fib4(6)` by hand and compare it with the example given earlier in the
    book:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 4.5 手动计算`fib4(6)`并与书中早些时候给出的示例进行比较：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 4.6 `roundFix2()` function? Even when TypeScript can work it out by itself (as
    in this case), I prefer spelling it out for extra checks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 4.6 `roundFix2()`函数？即使TypeScript可以自己解决这个问题（如本例所示），我也更喜欢明确地写出它以进行额外的检查。
- en: 4.7 `roundFix2()` so that it will return a tuple instead of a record. The input
    to this rewritten function could be two separate arguments or a single tuple argument.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 4.7 将`roundFix2()`函数修改为返回一个元组而不是一个记录。这个重写的函数的输入可以是两个单独的参数或一个单一的元组参数。
- en: 4.8 **One injection or two?** Why is it better to inject an object with two
    functions rather than two separate functions? In other words, why not write something
    like the following?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 4.8 **一个还是两个注入？**为什么用两个函数而不是两个单独的函数注入一个对象更好？换句话说，为什么不写如下内容？
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 4.9 `toBeCloseTo()` because of precision problems. A related question, often
    asked in job interviews, is *what will the following code output,* *and why?*
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 4.9 `toBeCloseTo()`由于精度问题。一个相关的问题，经常在面试中问到，是*以下代码将输出什么，为什么？*
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '4.10 `toBeCloseTo()` is practical but can cause problems. Some basic mathematics
    properties are as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 4.10 `toBeCloseTo()`函数实用但可能引起问题。一些基本的数学属性如下：
- en: 'A number should equal itself: for all numbers *a*, *a* should equal *a*'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字应该等于它自己：对于所有数字*a*，*a*应该等于*a*
- en: If *a* equals *b*, then *b* should equal *a*
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*等于*b*，那么*b*应该等于*a*
- en: If *a* equals *b*, and *b* equals *c*, then *a* should equal *c*
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*等于*b*，且*b*等于*c*，那么*a*应该等于*c*
- en: If *a* equals *b*, and *c* equals *d*, then *a*+*c* should equal *b*+*d*, *a*-*c*
    should equal *b*-*d*, *a***c* should equal *b***d*, and *a*/*c* should equal *b*/*d*
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*等于*b*，且*c*等于*d*，那么*a*+*c*应该等于*b*+*d*，*a*-*c*应该等于*b*-*d*，*a***c*应该等于*b***d*，和*a*/*c*应该等于*b*/*d*
- en: Does `toBeCloseTo()` satisfy all these properties?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBeCloseTo()`是否满足所有这些属性？'
- en: 4.11 `<T>` in the definition of `shuffle()`?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 4.11 `<T>`在`shuffle()`的定义中？
- en: 4.12 `shuffle()` modifies the input array in place (a side effect!) we don’t
    really need the final `return arr` line and could remove it. What would be the
    type definition of `shuffle()` then?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 4.12 `shuffle()`在原地修改输入数组（副作用！）我们实际上不需要最后的`return arr`行，可以将其删除。那么`shuffle()`的类型定义会是什么？
- en: 4.13\. `shuffle()` to test whether it works correctly with arrays with repeated
    values? The tests we wrote are only valid for arrays with distinct values; can
    you see why?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 4.13\. `shuffle()`测试它是否正确地与具有重复值的数组一起工作？我们编写的测试只对具有不同值的数组有效；你能看出为什么吗？
- en: 4.14 **Popular, but wrong!** Many online articles suggest the following code
    as a way of shuffling. The idea is to sort the array, but, instead of using a
    correct comparison function to randomly return positive or negative values, these
    random comparisons should get the array in disorder. However, the idea is wrong
    and the algorithm is bad because it doesn’t produce all possible outputs with
    equal probability. How can you check that?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 4.14 **流行但错误！**许多在线文章建议以下代码作为洗牌的方法。想法是对数组进行排序，但，而不是使用正确的比较函数随机返回正或负值，这些随机比较应该使数组处于混乱状态。然而，这个想法是错误的，算法也是糟糕的，因为它没有以相等的概率产生所有可能的输出。你如何检查这一点？
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '4.15 **Shuffling by sorting**: Sorting and shuffling can be seen as opposite
    functions; one brings order, and the other produces disorder. However, there’s
    a way to shuffle an array by sorting; can you figure out how? (And no, the answer
    is *not* the lousy algorithm shown in the previous question!) We are looking for
    an algorithm that can produce every possible output with the same probability,
    not favoring some outputs over others.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 4.15 **通过排序进行洗牌**：排序和洗牌可以看作是相反的操作；一个带来秩序，另一个产生混乱。然而，有一种方法可以通过排序来洗牌；你能想出来吗？（不，答案不是前一个问题中展示的糟糕算法！）我们正在寻找一个算法，它可以以相同的概率产生所有可能的输出，而不是偏向某些输出。
