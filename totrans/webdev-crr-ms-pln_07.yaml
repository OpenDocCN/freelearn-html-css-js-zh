- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: From Front to Back – More on Backend Tools and Technologies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从前端到后端 - 更多关于后端工具和技术
- en: In the last chapter, we focused primarily on the frontend. In this chapter,
    we’ll jump back to the backend side of the fence and look at some other server-side
    technologies and concepts. A full-fledged website or web app will rarely be only
    a client – it will nearly always require some sort of server to interact with
    – so, being full stack and understanding how both sides fit together is beneficial
    to being a web developer even if you ultimately decide to focus on one side or
    the other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们主要关注前端。在本章中，我们将回到后端，并探讨一些其他的服务器端技术和概念。一个完整的网站或网络应用程序很少只有客户端 - 它几乎总是需要某种服务器来与之交互
    - 因此，即使你最终决定专注于某一侧，了解这两者如何结合在一起对成为一名网络开发者也是有利的。
- en: 'In this chapter, we’ll look at what is perhaps the most important server-side
    concept: data. You’ll learn how data is stored and accessed, and you’ll understand
    the basic operations that can be performed on data. You’ll see multiple ways of
    storing data, and then you’ll learn how to build a facility that clients can use
    to access that data.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可能是最重要的服务器端概念：数据。你将了解数据是如何存储和访问的，以及你将理解可以在数据上执行的基本操作。你将看到多种存储数据的方式，然后你将学习如何构建一个客户端可以使用来访问这些数据的设施。
- en: Of course, understanding how to work with data should obviously be important
    since without data, a website is likely to not be of all that much use, but knowing
    how to expose that data to clients in a consistent way (where *clients* in this
    context most often will mean a browser-based application) is also important to
    understand since it allows not only your own app or website to use the data but
    potentially others in their own way, which is a nice bit of flexibility to be
    able to offer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，了解如何处理数据显然很重要，因为没有数据，一个网站可能不会有多大用处，但了解如何以一致的方式向客户端暴露数据（在这个上下文中，“客户端”通常意味着基于浏览器的应用程序）也很重要，因为它不仅允许你的应用程序或网站使用数据，还可能允许其他人以他们自己的方式使用数据，这是一项很棒的灵活性。
- en: You’ll also get a look at a couple of different technologies for building server-side
    code, in addition to Node, which you’ve seen already. This will include Java,
    PHP, .NET, and even some Python options. It’s important to know what the various
    options are so that you can make an informed decision about which is most appropriate
    when building your server-side code (and you may find that the decision in large
    part comes down to personal preference and pre-existing knowledge, which oftentimes
    is fine).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将了解一些构建服务器端代码的不同技术，除了你已看到的Node之外。这包括Java、PHP、.NET，甚至一些Python选项。了解各种选项很重要，这样你就可以在构建服务器端代码时做出明智的决定（你可能会发现这个决定在很大程度上取决于个人偏好和先验知识，这通常是可以接受的）。
- en: 'So, in this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Getting to the heart of the matter – data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抓住问题的核心 - 数据
- en: Building web APIs with REST, Node, and Express
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REST、Node和Express构建网络API
- en: Going back to the future – SSR
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到未来 - SSR
- en: Using PHP on the server side
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端使用PHP
- en: Building with Java and Spring Boot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java和Spring Boot进行构建
- en: Introducing .NET
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍.NET
- en: Using Python web app frameworks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python网络应用程序框架
- en: Reviewing the roadmap
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查路线图
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As usual, you will want the code download bundle for this book, along with the
    code found in the `ch-07` directory specifically.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，你将想要这本书的代码下载包，以及`ch-07`目录中找到的代码。
- en: But specifically for this chapter, you’ll need to install a tool called Postman,
    which we’ll use for exercising our backend code later. Though at the time of writing
    you can download the tool without signing up, you’ll most likely want an account
    either way since it provides expanded functionality. So, go to [https://www.postman.com](https://www.postman.com),
    sign up, and download the Postman desktop app. The app is a typical desktop app
    for whichever operating system you’re using, so you shouldn’t have much trouble
    getting it installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但具体到这一章，你需要安装一个名为Postman的工具，稍后我们将用它来测试我们的后端代码。尽管在撰写本文时你可以不注册就下载这个工具，但你可能无论如何都会想要一个账户，因为它提供了扩展的功能。因此，请访问[https://www.postman.com](https://www.postman.com)，注册并下载Postman桌面应用程序。该应用程序适用于你使用的任何操作系统，所以你不太可能遇到安装上的麻烦。
- en: You’ll also need to have the .NET SDK installed, which you can get at [https://dotnet.microsoft.com](https://dotnet.microsoft.com).
    This is a platform Microsoft provides for developing all sorts of apps, both Windows
    native and web apps. This again is a standard installer, so you shouldn’t have
    too much trouble – just grab the latest version available. Once you install it,
    go to Command Prompt and execute the `dotnet --version` command to confirm it’s
    ready to go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装.NET SDK，你可以从这里获取：[https://dotnet.microsoft.com](https://dotnet.microsoft.com)。这是微软提供的一个平台，用于开发各种应用程序，包括Windows原生应用程序和Web应用程序。这同样是一个标准安装程序，所以你
    shouldn't have too much trouble – just grab the latest version available. Once
    you install it, go to Command Prompt and execute the `dotnet --version` command
    to confirm it’s ready to go.
- en: 'Finally, you’ll next need to install the latest Java JDK, which you can get
    here: [https://www.oracle.com/java/technologies/downloads](https://www.oracle.com/java/technologies/downloads).
    Java is one of the most popular programming languages and platforms in use today,
    and we’ll take a look at it later. The version shouldn’t matter for our purposes
    here, so just grab the latest (21 as of this writing). Once installed, head to
    Command Prompt and ensure that `java -–version` returns you the correct version.
    Note that if you run into any issues with either the JDK or the .NET SDK not working,
    you can find installation help on their respective websites.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还需要安装最新的Java JDK，你可以从这里获取：[https://www.oracle.com/java/technologies/downloads](https://www.oracle.com/java/technologies/downloads)。Java是目前使用最广泛的编程语言和平台之一，我们稍后会对其进行探讨。版本在这里并不重要，所以只需获取最新的版本（截至本文写作时为21）。安装完成后，转到命令提示符并确保`java
    -–version`返回正确的版本。请注意，如果你遇到JDK或.NET SDK无法正常工作的问题，你可以在它们各自的网站上找到安装帮助。
- en: Getting to the heart of the matter – data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抓住问题的关键——数据
- en: Most websites or web apps require data of some sort to do what they’re designed
    to do. That’s not exactly a revelatory statement, of course. eBay wouldn’t work
    if it didn’t have data available to display auctions. Google wouldn’t be able
    to do searches without (an insane amount of) data. And CNN wouldn’t be able to
    show the latest news headlines without data to back it up.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站或Web应用程序都需要某种类型的数据才能执行它们设计的目的。这当然不是一个令人震惊的声明。如果没有可供显示拍卖的数据，eBay将无法工作。没有（大量）数据，Google将无法进行搜索。没有支持数据，CNN将无法展示最新的新闻标题。
- en: But how does that data get stored, and how does it get used?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些数据是如何存储的，又是如何被使用的呢？
- en: So far, everything you’ve seen has been more or less static, meaning it doesn’t
    change. A page is what it is when you create it, and it will always be that. Oh,
    there may be some minor dynamic interactions – things such as buttons that highlight
    when you hover your mouse over them – but that’s not dynamic content such as those
    websites I named produce. That can only be done with data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所看到的一切基本上都是静态的，这意味着它不会改变。页面在你创建它时是什么样子，它就会一直是那个样子。哦，可能会有一些微小的动态交互——比如当你将鼠标悬停在其上时按钮会突出显示——但这并不是我提到的那些网站产生的动态内容。那只能通过数据来实现。
- en: There are lots of ways to store data that websites can work with. Perhaps the
    simplest form is to store it as plain text files on the server. Those files can
    be read – perhaps in Node-based code, for example – and their contents can be
    used to create a dynamic response at the time it’s requested.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网站可以使用的存储数据的方式有很多。可能最简单的方式是将数据存储为服务器上的纯文本文件。这些文件可以被读取——例如，可能使用基于Node的代码——并且它们的内
    容可以在请求时用来创建动态响应。
- en: 'In a nutshell, that’s what we’re talking about here: creating responses dynamically
    on the server when requested by a client (usually a web browser) and returning
    them for display to the user.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这正是我们在这里讨论的：当客户端（通常是Web浏览器）请求时，在服务器上动态创建响应，并将它们返回给用户进行显示。
- en: 'While plain text files can work, the more common method is some form of **database**.
    A database is, usually, a piece of software running on the server, separate from
    your web server software and separate from your own application code, where data
    is stored and which can respond to requests for that data (or for writing data
    to it). While it’s possible in some cases for a web browser to access such database
    software directly, it’s far more common to have some server-side code that does
    so and then uses the data to produce a response. This is more common for no other
    reason than security: presumably, your own code is protected against misuse of
    the database, whereas just giving users direct access to it will most likely lack
    such protection.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然纯文本文件可以工作，但更常见的方法是某种形式的**数据库**。数据库通常是一段运行在服务器上的软件，与你的Web服务器软件以及你的应用程序代码分开，用于存储数据并能够响应对数据的请求（或写入数据）。虽然在某些情况下，网络浏览器可以直接访问这样的数据库软件，但更常见的是有一些服务器端代码来这样做，然后使用这些数据来生成响应。这更常见的原因仅仅是安全性：你的代码可能受到对数据库滥用的保护，而直接给用户访问数据库的权限则很可能缺乏这种保护。
- en: There are several different types of databases, but the two most relevant to
    you as a budding web developer are **relational databases** and **NoSQL databases**.
    Let’s talk about relational databases first.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同类型的数据库，但对你这个初出茅庐的Web开发者来说，最相关的两种是**关系型数据库**和**NoSQL数据库**。我们先来谈谈关系型数据库。
- en: Relational databases
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: 'Relational databases conceptually look a lot like spreadsheets – say, Microsoft
    Excel. In a spreadsheet, you have rows and columns. Where they intersect, you
    have a cell, and in a cell, you usually have some data. In an Excel spreadsheet,
    you can also have multiple sheets, often to store different types of data. *Figure
    7**.1* illustrates these ideas:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库在概念上看起来与电子表格非常相似——比如说，Microsoft Excel。在电子表格中，你有行和列。它们相交的地方是单元格，在单元格中，你通常会有一些数据。在Excel电子表格中，你也可以有多个工作表，通常用于存储不同类型的数据。*图7.1*展示了这些概念：
- en: '![Figure 7.1: An Excel spreadsheet, with multiple sheets shown to mimic a database
    and tables](img/B18315_07_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：一个Excel电子表格，展示了多个工作表以模拟数据库和表](img/B18315_07_1.jpg)'
- en: 'Figure 7.1: An Excel spreadsheet, with multiple sheets shown to mimic a database
    and tables'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：一个Excel电子表格，展示了多个工作表以模拟数据库和表
- en: If you already understand the basic structure of a spreadsheet, then to understand
    a relational database, you really just have to change some words!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经理解了电子表格的基本结构，那么要理解关系型数据库，你实际上只需要改变一些词汇！
- en: 'The entire spreadsheet in Excel is conceptually what we call a *database*,
    and each sheet in a spreadsheet is called a *table* in that database. Within the
    database software, you can normally have multiple databases if you need to. This
    can be confusing, so to disambiguate, we tend to say database *server* versus
    plain *database*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Excel中的整个电子表格在概念上就是我们所说的*数据库*，而电子表格中的每一张表在那个数据库中被称为*表*。在数据库软件中，如果你需要的话，通常可以拥有多个数据库。这可能会让人困惑，因此为了消除歧义，我们倾向于说*数据库服务器*与普通的*数据库*：
- en: A database *server* refers to the software that runs on the server (names such
    as Oracle MySQL, PostgreSQL, and MS SQL Server) and which contains databases and
    provides the basic functionality to work with the data
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务器指的是运行在服务器上（如Oracle MySQL、PostgreSQL和MS SQL Server等）的软件，它包含数据库并提供与数据交互的基本功能
- en: The term *database* – different from the aforementioned database *server* –
    refers to the actual collection of tables for a given purpose, perhaps one database
    per website hosted on the server, but all living in the database server software
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语*数据库*——与上述的数据库服务器不同——指的是为特定目的而实际收集的表集合，可能每个服务器上托管一个网站，但所有这些都生活在数据库服务器软件中
- en: In a database table, you define what columns there are – what type of data you
    want to store about each row of data in the table – and then you have the rows
    of data itself. If you think of each row of data – which we often call a **record**
    – as being some sort of entity, say a person or a banking account, then the columns
    effectively describe the pieces of information you want to store about each.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库表中，你定义有哪些列——你想要存储关于表中每一行数据的哪种类型的数据——然后你就有数据本身的那一行。如果你把每一行数据——我们通常称之为**记录**——看作是一种实体，比如说一个人或一个银行账户，那么列实际上描述了你想要存储的关于每个实体的信息。
- en: 'For example, let’s say you want to create a database table to store some information
    about people. We’ll be exceptionally uncreative here and say that we’ll name the
    table `People`. Maybe for each row of data – which will be a person entity – you
    want to store their first name, last name, and age. As a result, you might wind
    up with a database table that looks like *Figure 7**.2*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要创建一个数据库表来存储一些关于人的信息。我们将非常缺乏创意，所以我们将称这个表为`People`。也许对于每一行数据——它将是一个人实体——你想要存储他们的名字、姓氏和年龄。结果，你可能会得到一个看起来像*图7.2*的数据库表：
- en: '![Figure 7.2: The People table’s structure](img/B18315_07_2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：`People`表的结构](img/B18315_07_2.jpg)'
- en: 'Figure 7.2: The People table’s structure'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：`People`表的结构
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As an aside, you probably would never store a person’s age because that obviously
    won’t be correct a year later. Instead, you would most likely store their birthdate
    and calculate their age from that when needed. But here, I’m trying to keep this
    example as simple as possible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为补充，你可能永远不会存储一个人的年龄，因为显然一年后那个年龄就不会正确了。相反，你可能会存储他们的出生日期，并在需要时从那个日期计算他们的年龄。但在这里，我尽量让这个例子尽可能简单。
- en: 'For each column, you have to tell the database what kind of data will be stored
    in it. Every database specifies the type of data in each column differently, but
    they all relate to what you know already. Here, you can see that `first_name`
    and `last_name` are strings (which are of the data type `TEXT` in this particular
    database), and `age` is a number (of the data type `INTEGER`). Another bit of
    terminology to change here is that we usually call a single data element a field
    in a database rather than a cell as in a spreadsheet. But it’s again the same
    basic thing: it’s the value in a row that corresponds to a given column.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一列，你必须告诉数据库将存储什么类型的数据。每个数据库都会以不同的方式指定每列的数据类型，但它们都与你所知道的内容相关。在这里，你可以看到`first_name`和`last_name`是字符串（在这个特定的数据库中，它们的数据类型是`TEXT`），而`age`是一个数字（数据类型为`INTEGER`）。在这里需要更改的另一项术语是，我们通常将数据库中的一个单一数据元素称为字段，而不是像电子表格中的单元格那样。但它们仍然是相同的基本东西：它是行中对应给定列的值。
- en: 'With that basic table structure defined, we can store some rows of data in
    it; maybe this data (and yes, those were their actual ages when the series began
    – I did the research!):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了基本的表结构之后，我们可以在其中存储一些数据行；也许这些数据（是的，这些确实是系列开始时的实际年龄——我做了研究！）：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But how do we actually store that data? That’s where the concept of Structured
    Query Language comes in, which is what we’re discussing next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们实际上如何存储这些数据呢？这就是结构化查询语言的概念发挥作用的地方，这是我们接下来要讨论的。
- en: Introducing SQL
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍SQL
- en: '**Structured Query Language** (**SQL**) is a special language used to interact
    with relational databases. It allows us to request data using a form that is generally
    easy to understand, attempting to look less like a programming language than something
    like JS.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言**（**SQL**）是一种用于与关系数据库交互的特殊语言。它允许我们使用一种通常容易理解的形式来请求数据，试图让它看起来更像JS而不是编程语言。'
- en: 'To jump right in with an example, let’s say you wanted to get all three records
    from our `People` table. The SQL statement for that would be this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，让我们直接用一个例子开始，假设你想要从我们的`People`表中获取所有三条记录。对应的SQL语句会是这样的：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That’s it! What you’ll get is a list of records, each containing the first
    name, last name, and age of each person. This shows the most basic type of SQL
    statement: a `SELECT` statement. We tell it what data we want from each record
    (in this case, the asterisk means all), and then we have to state what table to
    get the records from.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！你将得到一个记录列表，每个记录都包含每个人的名字、姓氏和年龄。这显示了最基本的SQL语句类型：`SELECT`语句。我们告诉它我们想要从每条记录中获取什么数据（在这种情况下，星号表示所有），然后我们必须说明从哪个表获取记录。
- en: 'If we wanted just the last names, we would execute the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取姓氏，我们会执行以下操作：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And if we wanted just the last name and age, we could execute the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取姓氏和年龄，我们可以执行以下操作：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What if we want just the people who are over 40 years old? That’s where the
    `WHERE` clause comes into play:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取超过40岁的人呢？这就是`WHERE`子句发挥作用的地方：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we’ll get just a single record – Montgomery Scott – since that’s the only
    record with a value for `age` greater than `40`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将只获取一条记录——蒙哥马利·斯科特，因为这是唯一一条`age`值大于`40`的记录。
- en: Here, `SELECT` statements such as this allow for other capabilities, including
    sorting the returned data, filtering it in various ways, and lots of functions
    that can be used to manipulate the returned data (for example, to uppercase the
    names, maybe). But the basic ability to retrieve data is ultimately what it’s
    all about.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SELECT` 语句如此类许允许其他功能，包括对返回的数据进行排序、以各种方式过滤，以及许多可以用来操作返回数据的函数（例如，将名称转换为大写，也许）。但最终，获取数据的基本能力才是关键所在。
- en: 'And, of course, retrieving data is great, but what if we want to add a person?
    This can be done through SQL as well, using an `INSERT` statement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，检索数据很棒，但如果我们要添加一个人呢？这也可以通过 SQL 完成，使用一个 `INSERT` 语句：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have to provide the name of the table to insert the data into, then a list
    of fields to insert, and then the value of each field. After executing that statement,
    we’ll have four rows of data in the table.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提供要插入数据的表名，然后列出要插入的字段，然后是每个字段的值。执行该语句后，表中将有四行数据。
- en: 'What about changing existing data? That’s doable too with SQL, using its `UPDATE`
    statement:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于更改现有数据呢？这也可以使用 SQL 的 `UPDATE` 语句来完成：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, we have to specify which table we’re changing data in, and then which
    field to change.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们必须指定我们更改数据的表，然后指定要更改的字段。
- en: 'And of course, we can update multiple fields if we wish:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们想更新多个字段，也是可以的：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `WHERE` clause is actually optional here, but the result of not providing
    it is that **all** the records in the table will be updated since there’s nothing
    to limit which records it affects. So, it’s important when working with SQL that
    your statements that change data always do so to only the records you intend to
    change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句在这里实际上是可选的，但如果不提供它，结果将是**所有**表中的记录都将被更新，因为没有限制它影响的记录。因此，在处理 SQL 时，确保你的数据更改语句只更改你打算更改的记录是很重要的。'
- en: 'The final form of SQL statement you need to be aware of is for deleting data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的 SQL 语句的最终形式是用于删除数据：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once more, you must specify the table to operate on, and then some `WHERE` clause
    to determine which records to remove. As with the `UPDATE` statement, the `WHERE`
    clause is optional, so unless you actually intend to delete all the records in
    the table, be careful to include the correct criteria to match records by!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你必须指定要操作的表，然后指定一些 `WHERE` 子句来确定要删除的记录。与 `UPDATE` 语句一样，`WHERE` 子句是可选的，所以除非你真的打算删除表中的所有记录，否则请务必包括正确的标准来匹配记录！
- en: These are, of course, just the most basic SQL statements possible – SQL can
    get quite a bit more complex as you get into more advanced use cases – but if
    you understand the basic idea behind these four types of statements, then you’ll
    have a good start on understanding more advanced use cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些当然是可能的最基本的 SQL 语句——随着你进入更高级的使用案例，SQL 可以变得相当复杂——但如果你理解这四种类型语句背后的基本思想，那么你将很好地开始理解更高级的使用案例。
- en: Now, one of those more advanced use cases is when tables have some direct relationship
    to each other, which is where the word *relational* comes from in relational databases,
    so let’s talk about that next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，其中一个更高级的使用案例是当表之间有直接关系时，这就是关系型数据库中“关系”一词的由来，所以让我们接下来谈谈这个。
- en: Putting the relational in relational databases
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在关系型数据库中引入关系
- en: 'As you know, you can have multiple tables in a database. For example, let’s
    say that in addition to the `People` table, we add a `Starships` table now, as
    shown in *Figure 7**.3*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，数据库中可以有多个表。例如，除了 `People` 表之外，我们现在添加一个 `Starships` 表，如图 *7.3* 所示：
- en: '![Figure 7.3: The Starships table’s structure](img/B18315_07_3.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：Starships 表的结构](img/B18315_07_3.jpg)'
- en: 'Figure 7.3: The Starships table’s structure'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：Starships 表的结构
- en: 'As it stands, there isn’t any real relationship between these two tables, and
    there’s nothing that ties them together. Sometimes that’s fine, but what if we
    want to know the starship each person serves on? One way we could do this would
    be to alter the `People` table, as shown in *Figure 7**.4*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这两个表之间没有真正的关联，也没有任何东西将它们联系在一起。有时这没问题，但如果我们想知道每个人服务的飞船是哪一艘？我们可以通过修改 `People`
    表来实现，如图 *7.4* 所示：
- en: '![Figure 7.4: The People table’s structure, now with a starship_id column](img/B18315_07_4.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：People 表的结构，现在包含 starship_id 列](img/B18315_07_4.jpg)'
- en: 'Figure 7.4: The People table’s structure, now with a starship_id column'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：People 表的结构，现在包含 starship_id 列
- en: Now, the `starship_id` column has been added, and assuming that the value in
    that field for each row of data matches one of the `id` values of a record in
    the `Starships` table, we’ve effectively connected the two tables and can now,
    at least indirectly, tell which starship each person serves on. We’ve created
    a *relationship*, in other words, between these tables, making this now a truly
    *relational* database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已经添加了`starship_id`列，并且假设每行数据中该字段中的值与`Starships`表中记录的`id`值之一相匹配，我们实际上已经连接了这两个表，现在至少可以间接地告诉每个人在哪个星球飞船上服役。换句话说，我们在这些表之间创建了一个*关系*，这使得现在成为一个真正的*关系型*数据库。
- en: 'But what does that do to our SQL queries? Well, they work the same as before,
    but now we have some new capabilities at our fingertips because we can query for
    data from both tables at once based on the relationship:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但这对我们的SQL查询有什么影响呢？嗯，它们的工作方式与之前相同，但现在我们有一些新的能力在我们的指尖，因为我们可以根据关系同时查询两个表中的数据：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we’ll get four pieces of data for each record returned: the first name,
    last name, and age of each person, plus the starship they serve on. But we need
    to specify that we’re querying from two tables and combining the data in one result
    set, a concept called `p` for the `Person` table and `s` for the `Starships` table.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为每个返回的记录获取四条数据：每个人的名字、姓氏和年龄，以及他们服役的星球飞船。但我们需要指定我们正在从两个表查询并将数据组合在一个结果集中，这个概念被称为`p`代表`Person`表，`s`代表`Starships`表。
- en: We then use these names as prefixes on the names of columns everywhere in the
    query (again, to ensure that SQL knows exactly which fields we want).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些名称用作查询中所有列名称的前缀（再次，以确保SQL确切知道我们想要哪些字段）。
- en: Finally, we have to provide a `WHERE` clause here. It says that for each record
    in the `People` table (since it’s the first one in the list of tables in the `FROM`
    clause), find a record in the `Starships` table with an `id` value that matches
    the `starship_id` value in the `People` table. And since we’re returning `s.starship_name`
    in the list of fields, we wind up with data about each person from `People`, along
    with the name of the starship they serve on from `Starships`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在这里提供一个`WHERE`子句。它表示对于`People`表中的每个记录（因为它是`FROM`子句中表列表中的第一个），在`Starships`表中找到一个与`People`表中的`starship_id`值匹配的`id`值的记录。并且由于我们在字段列表中返回`s.starship_name`，我们最终得到了来自`People`表每个人的数据，以及他们服役的星球飞船的名称。
- en: 'This is really the main point of relational databases: the ability to return
    data that is a combination of data from two or more tables, based on some relationship
    between them. The relationship here is the `id` fields, so where they match, the
    data from both tables is combined and returned as part of the query results. Joining
    is an expansive topic that can get fairly complex in a hurry (it deals with the
    mathematical concept of set theory), so we won’t go into it in detail here. But
    the basic concept is always the same: your query works to combine data from multiple
    tables based on one or more matching conditions, returning it all as a single
    list of data records.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是关系型数据库的主要点：能够根据它们之间的一些关系返回来自两个或更多表的数据组合。这里的关系是`id`字段，所以当它们匹配时，两个表的数据就组合在一起，并作为查询结果的一部分返回。连接是一个广泛的话题，可能会很快变得相当复杂（它涉及到集合理论的数学概念），所以我们在这里不会详细讨论。但基本概念始终相同：你的查询通过基于一个或多个匹配条件将多个表的数据组合起来，并将它们作为一个单一的数据记录列表返回。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to dive a little deeper into the various join types and how to
    write them, a good reference can be found here: [https://learnsql.com/blog/sql-joins-types-explained](https://learnsql.com/blog/sql-joins-types-explained).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更深入地了解各种连接类型以及如何编写它们，一个好的参考资料可以在这里找到：[https://learnsql.com/blog/sql-joins-types-explained](https://learnsql.com/blog/sql-joins-types-explained)。
- en: Even from this simple example, I’m sure you can begin to see the power of relational
    data. You can have a list of students and a separate list of classes and be able
    to write a query to get a list of classes each attends. Or, you could have a list
    of banking accounts and who owns each in separate tables but be able to tie them
    together when needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从这个简单的例子中，我相信你也能开始看到关系型数据的强大之处。你可以有一个学生列表和一个单独的班级列表，并且能够编写一个查询来获取每个学生参加的班级列表。或者，你可能有银行账户列表和每个账户的所有者列表分别在不同的表中，但在需要时能够将它们联系起来。
- en: Why do this, though? One of the main goals of relational databases is to not
    duplicate data (or, more precisely, duplicate it as little as possible – a process
    called `People` table itself, on each row of data. That would work just as well
    for our purposes. But if the name of the starship changes, then we would need
    to update all records in the `People` table accordingly. If instead we have two
    tables and join them as shown, then you just need to change the name in the `Starships`
    table – in one place, on one record – and it, in effect, is automatically changed
    for every person serving on it (at the time you do a query, that is). It’s a more
    logical way to deal with the data since the name of the starship isn’t logically
    tied to a person – they’re separate entities, really – and it’s also more efficient
    in terms of storage space (and, in some cases, improves performance, though that
    is very much a situation-by-situation thing and can, in fact, have the *opposite*
    effect).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么要这样做呢？关系型数据库的主要目标之一是不要重复数据（或者更精确地说，尽可能少地重复数据——这个过程被称为`People`表本身，在每一行数据上。这对我们的目的来说效果是一样的。但是，如果星际飞船的名字改变了，那么我们就需要相应地更新`People`表中的所有记录。如果我们有两组表并且像这样连接它们，那么你只需要在`Starships`表中更改名字——在一个地方，一个记录——实际上，在查询时，它对每个服务在该飞船上的人（即当时）都会自动更改。这是一种更逻辑地处理数据的方式，因为星际飞船的名字在逻辑上并没有与一个人绑定——它们实际上是独立的实体，而且在存储空间（在某些情况下，性能也有所提高，但这很大程度上取决于具体情况，实际上可能会有相反的效果）方面也更有效率。
- en: At this point, you may be wondering what to do if the data you’re working with
    isn’t inherently relational. And what if the form of the data you want to store
    isn’t as concrete as it needs to be in order to be described in a table as you’ve
    seen so far? Well, there’s another type of database for such cases that might
    be more appropriate – NoSQL databases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能想知道如果你正在处理的数据本身不是关系型的，你会怎么做。还有，如果你想要存储的数据形式不像你迄今为止所看到的表格那样具体，你会怎么做？嗯，对于这种情况，还有一种可能更适合的数据库类型——NoSQL数据库。
- en: NoSQL databases
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: 'In simplest terms, a NoSQL database is literally any other kind of mechanism
    for storing data (which we often call *data stores*) that doesn’t use SQL to operate
    on the data. This includes types of databases such as the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，NoSQL数据库实际上是指任何不使用SQL来操作数据的存储数据机制（我们通常称之为*数据存储*）。这包括以下类型的数据库：
- en: '`"first name"`, and the value for that key is `"Frank"`. This is just about
    the simplest NoSQL type there is, and it’s used for situations where the data
    is very simple. Some common names you’ll hear for this type are Redis and DynamoDB,
    two products that provide a key-value database store.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"first name"`，该键的值是`"Frank"`。这几乎是NoSQL中最简单的类型了，它用于数据非常简单的情况。你可能听到的这种类型的常见名称包括Redis和DynamoDB，这两个产品提供了键值数据库存储。'
- en: '**Graph databases**: These are somewhat newer and are specifically used for
    types of data that have (usually many) well-defined connections between entities.
    An example of this might be a social network: you are an entity, and you probably
    have connections to many friends, who also have connections to many friends, and
    so on. While these types of relationships can be modeled in a relational database,
    a graph database may be more appropriate, especially if you need to *traverse
    the graph*, meaning to start at one entity and follow its connections to some
    remote entity. Some common names you might hear for this type are Neo4j and Amazon
    Neptune.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据库**：这些数据库相对较新，专门用于具有（通常很多）实体之间定义良好的连接的数据类型。一个例子可能是一个社交网络：你是一个实体，你可能有很多朋友，他们也可能有很多朋友，以此类推。虽然这些类型的关系可以在关系型数据库中建模，但图数据库可能更合适，尤其是当你需要*遍历图*时，这意味着从一个实体开始，跟随其连接到某个远程实体。你可能听到的这种类型的常见名称包括Neo4j和Amazon
    Neptune。'
- en: '**Wide-column stores**: These are a type of database used primarily when there
    is a need to analyze especially large datasets. They work by storing columns of
    data together in rows, which allows for optimizing complex queries across many
    fields of data in each entity. Examples of this type include Apache Cassandra
    and Google Bigtable.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽列存储**：这种数据库类型主要用于需要分析特别大的数据集的情况。它们通过将数据列存储在行中来工作，这允许优化每个实体中许多字段上的复杂查询。这种类型的例子包括Apache
    Cassandra和Google Bigtable。'
- en: There is also a fourth type known as a *document database* – I left it off the
    list because while all of the previous types are NoSQL databases, the fact is
    that when someone says NoSQL database, nine times out of ten, they probably mean
    a document database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为**文档数据库**的第四种类型——我把它从列表中省略了，因为虽然所有前面的类型都是NoSQL数据库，但事实是，当有人说NoSQL数据库时，十有八九他们指的是文档数据库。
- en: 'In a document database, the data is stored in objects, very often JSON objects,
    though not necessarily. You’ve seen JSON several times already: the `package.json`
    file that `npm` generates when you initialize a project. But the format of the
    data stored in it is **JSON**, which stands for **JavaScript Object Notation**.
    Curiously, while it was definitely invented within the context of JS, it’s used
    outside of that context frequently nowadays because it’s relatively simple and
    easy to work with. It’s simply a string at the end of the day, which can be easily
    parsed and used in various ways.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档数据库中，数据存储在对象中，通常是JSON对象，尽管不一定是。你已经见过几次JSON了：当你初始化一个项目时，`npm`生成的`package.json`文件。但存储在其中的数据格式是**JSON**，代表**JavaScript对象表示法**。有趣的是，尽管它肯定是在JS的背景下发明的，但现在它经常被用于这个背景之外，因为它相对简单且易于处理。归根结底，它只是一个字符串，可以轻松解析并以各种方式使用。
- en: 'One of those ways is to serve as a document in a document database, such as
    MongoDB, which is easily the biggest name in document databases (CouchDB is another
    popular name). As an example, if we wanted to store the data in the `People` table
    from earlier in MongoDB, we would wind up with four separate documents that might
    look something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方式是作为一个文档存储在文档数据库中，比如MongoDB，它是文档数据库中当之无愧的最大品牌（CouchDB也是一个流行的品牌）。例如，如果我们想在MongoDB中存储之前提到的`People`表中的数据，我们最终会得到四个独立的文档，可能看起来像这样：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Rather than being rows in a table, each of those is a separate object – a document
    – stored in a **collection**, which roughly corresponds to a relational database
    table.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与其作为表中的行不同，每一个都是独立的对象——一个文档——存储在**集合**中，这大致对应于关系型数据库表。
- en: 'Here’s the big difference between a relational database and a document database.
    Let’s say I want to store a nickname, but only for Leonard McCoy. In a relational
    database, I would need to add a `nickname` column to the table, and each row would
    need to have a nickname (it could, of course, be blank for people without a nickname).
    In a document database, though, I could simply write McCoy’s document like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库和文档数据库之间有一个很大的区别。假设我想存储一个昵称，但只针对莱纳德·麦科伊。在关系型数据库中，我需要在表中添加一个`nickname`列，并且每一行都需要有一个昵称（当然，对于没有昵称的人来说，它可以是空的）。然而，在文档数据库中，我可以简单地这样写麦科伊的文档：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It doesn’t matter that the other documents don’t have a `nickname` field; that’s
    perfectly valid. You see, the structure of a database, which includes the fields
    in the tables, is known as the **schema**. Since all rows of data in a table share
    the same column, the table essentially defines the schema for all the rows.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文档没有`nickname`字段并不重要；这是完全有效的。你看，数据库的结构，包括表中的字段，被称为**模式**。由于表中的所有数据行都共享相同的列，因此表本质上定义了所有行的模式。
- en: But in a document database, it’s the documents themselves that define the schema.
    Well, really, *you* as the developer do(!), but the point is that each document
    can in a sense have its own schema.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但在文档数据库中，定义模式的是文档本身。实际上，是**你**作为开发者（！），但重点是每个文档在某种程度上可以有自己的模式。
- en: This has several benefits. One is that development can often be done quicker
    and easier with a document database because, unlike a relational database, you
    don’t have to get everything right at the start. With a relational database, you
    have to think about the data you want to store, and you have to build the tables
    with the appropriate columns and data types at the start (it’s true that you can
    alter the structure of tables after they’ve been created, but this comes with
    caveats that will sometimes make it not possible, and even if it *is* possible,
    it takes time and effort).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个好处。其中一个好处是，使用文档数据库通常可以更快、更轻松地开发，因为与关系型数据库不同，你不必一开始就做对一切。在关系型数据库中，你必须考虑你想存储的数据，并且你必须在开始时构建具有适当列和数据类型的表（虽然你可以在表创建后更改表的结构，但这有时会带来限制，有时甚至不可能，即使可能，也需要时间和精力）。
- en: Another benefit is that as you develop and realize that you need slightly different
    schemas on newer documents, you don’t necessarily have to alter existing data
    at all. As long as your code understands the possible differences, then you can
    deal with two versions of a document efficiently.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，随着你的开发，当你意识到需要在新文档上使用稍微不同的模式时，你不必一定修改现有的数据。只要你的代码理解可能的不同，你就可以有效地处理文档的两个版本。
- en: Now, one common misconception is that NoSQL databases, and document databases
    specifically, don’t have relational data. For sure that *can* be true, but using
    a document database doesn’t automatically mean that your data *can’t* have relationships.
    It’s probably fair to say that *more often than not* it won’t, and if it does
    have relationships, then it’s *probably* more appropriate to use a relational
    database. But one doesn’t negate the other.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个常见的误解是，NoSQL 数据库，特别是文档数据库，没有关系数据。当然，*可能* 是这样，但使用文档数据库并不意味着你的数据 *不能* 有关系。可能公平地说，*大多数情况下*
    它不会有关系，如果它确实有关系，那么可能更合适使用关系数据库。但一个不会否定另一个。
- en: 'And NoSQL databases do supply mechanisms to perform all the basic CRUD operations,
    including querying for related data. I’m not going to go into those in detail
    here, just because they can vary greatly from database to database. However, given
    it’s the most popular NoSQL/document database, here’s an example from MongoDB,
    just so you have some idea what it looks like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库确实提供了执行所有基本 CRUD 操作的机制，包括查询相关数据。这里我不会详细介绍这些，因为它们可以从数据库到数据库有很大的不同。然而，鉴于它是最受欢迎的
    NoSQL/文档数据库，这里有一个来自 MongoDB 的例子，以便你有一个大致的了解：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That would be equivalent in SQL to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 SQL 中相当于以下操作：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with SQL, such statements can get rather complex the more complex the documents
    are, and if there are relationships between them, and so on. But that, in a nutshell,
    is how you work with them, and that code can be written in a multitude of languages
    depending on your needs and server-side infrastructure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 SQL 一样，随着文档的复杂度增加，这样的语句可能会变得相当复杂，如果它们之间存在关系，等等。但简而言之，这就是你如何处理它们，而且根据你的需求和服务器端基础设施，这些代码可以用多种语言编写。
- en: All of this database discussion leads to one last general topic, but I have
    to warn you, it may take you a moment to stop giggling before you read the next
    section, because here comes some CRUD!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据库讨论最终导致最后一个一般性话题，但我要警告你，在阅读下一节之前，你可能需要花一点时间停止咯咯笑，因为接下来会有一些 CRUD！
- en: Basic CRUD operations
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本CRUD操作
- en: 'I know, I know – it sounds dirty, but I swear it’s a real term! The acronym
    **CRUD** stands for **Create, Read, Update, and Delete**, and it defines the four
    basic operations you can do on data, whether in a relational database or not.
    You can, of course, do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，我知道——这听起来很脏，但我发誓这是一个真正的术语！首字母缩略词 **CRUD** 代表 **创建（Create**）、**读取（Read**）、**更新（Update**）和**删除（Delete**），它定义了你可以对数据进行的基本操作，无论是在关系数据库中还是不是。你当然可以执行以下操作：
- en: Create data, as with an `insert` SQL statement
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据，就像使用一个 `insert` SQL 语句一样
- en: Read data, as with a `select` SQL statement
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取数据，就像使用一个 `select` SQL 语句一样
- en: Update data, as with an `update` SQL statement
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据，就像使用一个 `update` SQL 语句一样
- en: Delete data, as with a `delete` SQL statement
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除数据，就像使用一个 `delete` SQL 语句一样
- en: If for no other reason than just being able to have an intelligible conversation
    with other developers, it’s valuable to have this terminology in your head, even
    if you might snicker to yourself every time you say it! And it doesn’t really
    matter how these operations are implemented in code; it only matters that conceptually,
    they are the only things you ever do with data in any form.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只是为了能够与其他开发者进行有意义的对话，了解这些术语也是很有价值的，即使你每次说这些术语时可能会自己笑出声！而且这些操作在代码中的实现方式并不重要；重要的是，从概念上讲，它们是你以任何形式处理数据的唯一方式。
- en: 'But, of course, how these operations are implemented *does* matter in other
    ways. These CRUD (hehe) operations are often the basis for something called a
    web API, a collection of functions that can be called from remote systems. When
    it comes to building web APIs, the most common way to build them today is with
    yet another acronym (this field is flush with acronyms, if nothing else!): REST.
    And that’s the next thing we’re going to investigate.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，这些操作如何实现 *在其他方面* 也是很重要的。这些 CRUD（哈哈）操作通常是构建所谓的 Web API 的基础，这些 API 是可以从远程系统调用的函数集合。当涉及到构建
    Web API 时，今天最常见的方法是使用另一个首字母缩略词（这个领域充满了首字母缩略词，如果不是别的的话）：REST。这就是我们接下来要调查的下一个东西。
- en: Building web APIs with REST, Node, and Express
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST、Node和Express构建Web API
- en: Before we get to REST, though, let’s talk about APIs generally.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们谈到REST之前，先让我们一般地谈谈API。
- en: 'An **API** is an **application programming interface**. This can simply be
    a collection of functions that a program or library provides for other code to
    use. An API can be code located on the same machine as the code that calls on
    it, or an API can be exposed over a network, such as the internet and the World
    Wide Web. In this latter case, we call it a web API, a remote API, or sometimes
    a cloud API. All those terms mean the same thing, though: functions that can be
    called over the network, and they also tend to be language- and even technology-agnostic
    when built this way, meaning a JS client can call on a web API built in C, or
    code written in Python can call on a web API built with PHP, and so on.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**是**应用程序编程接口**。这可以简单地是一组函数，程序或库为其他代码使用提供的。API可以是位于调用它的代码所在同一台机器上的代码，或者API可以通过网络公开，例如互联网和万维网。在后一种情况下，我们称之为Web
    API、远程API，有时也称为云API。所有这些术语的含义相同，即：可以通过网络调用的函数，而且它们在以这种方式构建时往往具有语言和甚至技术无关性，这意味着一个JS客户端可以调用用C构建的Web
    API，或者用Python编写的代码可以调用用PHP构建的Web API，等等。'
- en: There are a great many ways to structure and build such web APIs, lots of different
    technologies and patterns that can be used to build them, and a lot of different
    forms they can take. However, one has risen to the top of the heap after a lot
    of different options have been tried, and that approach is REST.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化和构建这样的Web API有非常多方法，有很多不同的技术和模式可以用来构建它们，也有很多不同的形式。然而，在尝试了多种不同的选择之后，有一种方法脱颖而出，那就是REST。
- en: Introducing REST
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍REST
- en: At its core, **REST**, which stands for **REpresentational State Transfer**,
    is just a way to structure HTTP requests in a (relatively) consistent way.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，**REST**，即**表示状态转移**，只是以（相对）一致的方式结构化HTTP请求的一种方法。
- en: The web inherently uses REST principles. For example, when you enter a URL in
    your browser, you’re requesting a resource based on a unique URL, be that resource
    an HTML page, an image, or maybe some data in the form of JSON (which is most
    common when talking about REST services). That’s basically all the World Wide
    Web is, and that’s really all REST is! However, the modern notion of REST refines
    that basic idea, making it a bit more well-defined.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Web本身使用REST原则。例如，当你在浏览器中输入一个URL时，你是在请求一个基于唯一URL的资源，无论这个资源是一个HTML页面、一张图片，还是以JSON形式（在谈论REST服务时最常见）的一些数据。这就是万维网基本上是，这就是REST实际上也是！然而，现代的REST概念对这一基本想法进行了细化，使其更加明确。
- en: RESTful services, as we call web APIs built using REST, define the meaning of
    the standard HTTP methods – methods such as `GET`, `POST`, `PUT`, and `DELETE`
    – in explicit ways so that they have specific meanings. For example, a request
    made with `GET` means to retrieve a resource. `PUT` (usually) means to update
    some existing resource, while `POST` (usually) means to create a new resource.
    `DELETE`, of course, literally means to delete an existing resource. And of course,
    we’re talking about data on a server somewhere.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的RESTful服务，即使用REST构建的Web API，以明确的方式定义了标准HTTP方法的意义——例如`GET`、`POST`、`PUT`和`DELETE`——这样它们就有特定的含义。例如，使用`GET`发出的请求意味着检索资源。`PUT`（通常）意味着更新某些现有资源，而`POST`（通常）意味着创建一个新资源。`DELETE`当然字面上意味着删除一个现有资源。当然，我们是在谈论某个服务器上的数据。
- en: 'Breaking down the words that make up the acronym *REST* is helpful to understand
    it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将构成缩写词*REST*的单词分解开来有助于理解它：
- en: The word *representational* refers to the fact that when you request data from
    the API, what you get is a *representation* of some resource in a form you can
    digest in code, but not really the resource itself. For example, while a checking
    account resource might be stored in a database on the server in some binary form
    that would look like gibberish to a client, you can *represent* that account using
    something such as JSON, which is essentially just plain text with a specific format,
    which any client can make use of.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词语*representational*指的是当你从API请求数据时，你得到的是一些资源的*表示*，这种表示是以你可以消化在代码中的形式，但并不是资源本身。例如，虽然一个支票账户资源可能以某种二进制形式存储在服务器上的数据库中，这种形式对客户端来说像是乱码，但你可以用诸如JSON这样的东西来表示该账户，JSON本质上只是具有特定格式的纯文本，任何客户端都可以使用。
- en: The word *state* refers to the current condition of the resource. In other words,
    when you request a representation of a checking account, you get a representation
    of it as it exists at the time of the request.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “状态”这个词指的是资源的当前状态。换句话说，当你请求一个支票账户的表示形式时，你得到的是它在请求时的表示形式。
- en: The word *transfer* literally means to transfer that representation across the
    network.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “转移”这个词字面意思是将那种表示形式通过网络传输。
- en: 'So, putting that all together: a REST API is one that transfers representations
    of resources stored on a server in their current state or allows for updating
    the current state in some way or deleting the resource.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，把这些放在一起：REST API是一种将服务器上存储的资源表示形式在当前状态下传输，或者以某种方式允许更新当前状态或删除资源的API。
- en: That’s the theory; now, let’s look at REST in a bit more practical sense.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那是理论；现在，让我们从更实际的角度来看一下REST。
- en: REST in practice
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中的REST
- en: 'When you work with a REST API, you might have a URL that points to a resource
    on the server – say, a checking account:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与REST API一起工作时，你可能会有一个指向服务器上资源的URL——比如说，一个支票账户：
- en: '[https://my-awesome-web-api.com/checking-accounts/1234](https://my-awesome-web-api.com/checking-accounts/1234)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://my-awesome-web-api.com/checking-accounts/1234](https://my-awesome-web-api.com/checking-accounts/1234)'
- en: 'If you make a `GET` request to that URL (it’s not a real URL, but let’s pretend
    it is), it will return to you a representation of the checking account with account
    number 1234\. The representation could be in many forms, but by far the most common
    when using a RESTful API is JSON. So, you might get back a response something
    like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向那个URL（它不是一个真实的URL，但让我们假装它是）发起`GET`请求，它将返回给你账户编号为1234的支票账户的表示形式。这种表示形式可能有多种形式，但使用RESTful
    API时最常见的是JSON。所以，你可能会得到如下所示的响应：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you wanted to get a list of all accounts, then you would simply drop the
    `/1234` part from the URL (most likely), and you would (likely) get back an array
    of object representations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要获取所有账户的列表，那么你只需从URL中删除`/1234`部分（很可能是这样），你很可能会得到一个对象表示形式的数组。
- en: 'Now, if you want to update the balance of that account (we’re ignoring security
    for this discussion, obviously!), you would usually make a request using the same
    URL, but using the HTTP `POST` method this time, and in the body of the request,
    you might provide some JSON like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想更新那个账户的余额（显然，在这个讨论中我们忽略了安全问题！），你通常会使用相同的URL发起请求，但这次使用HTTP `POST`方法，并在请求体中提供一些JSON数据，如下所示：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The exact semantics of the API – the format of the data you get back and the
    data you pass in for updates – will vary from service to service, but the basic
    idea here is the meaning of the HTTP methods and the fact that JSON is being used
    to represent the checking account in both cases. Some APIs might require you to
    send back the exact representation you received from a `GET` request with the
    fields to be updated having the new values; others may just require the fields
    to be updated, as I’ve shown here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: API的确切语义——你得到的数据格式和你为更新传递的数据——会因服务而异，但这里的基本思想是HTTP方法的意义以及JSON在两种情况下都被用来表示支票账户的事实。一些API可能要求你发送回从`GET`请求中接收的确切表示形式，其中要更新的字段具有新值；而其他API可能只需要更新字段，就像我这里展示的那样。
- en: Note the key point, which is that the URL itself is what identifies the resource
    – the checking account, in this case – that we’re operating on. That’s why it
    doesn’t need to be included in the JSON sent in (probably – again, the semantics
    can vary from service to service).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一个关键点，即URL本身就是识别我们正在操作的资源——在这个例子中是支票账户——的标识符。这就是为什么它不需要包含在发送的JSON中（很可能——再次强调，语义可能因服务而异）。
- en: Similarly, to remove that account, you would again use the same URL, but now
    with the HTTP `DELETE` method. That change is all it takes for the server-side
    code to identify what you want to do since the HTTP method is essentially a verb
    in this conversation, describing the action you want to take on the resource pointed
    to by the URL.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，要删除那个账户，你还是会使用相同的URL，但现在使用HTTP `DELETE`方法。这种变化就足以让服务器端代码识别你想要做什么，因为在这个对话中，HTTP方法本质上是一个动词，描述了你对URL指向的资源想要执行的操作。
- en: To create a new account, that’s where it gets a little tricky. While we know
    that we need to use the `PUT` method, there obviously isn’t an existing checking
    account number to put on the URL, so what does the URL look like in this case?
    The answer is that it again depends on the semantics of the API. Some will have
    you put something such as `/add` or `/addNew` in place of the account number.
    Some will not need anything and just take the `PUT` method as meaning you want
    to add an account.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新账户，这会变得有点棘手。虽然我们知道我们需要使用`PUT`方法，但显然URL上没有现有的检查账户号码可以放置，那么在这种情况下URL看起来像什么？答案是这又取决于API的语义。有些人会让你在账户号码的位置放置诸如`/add`或`/addNew`之类的路径。有些人可能不需要任何东西，只需将`PUT`方法视为你想要添加账户的信号。
- en: 'This leads to an important point, which I’ve been hinting at with my use of
    equivocation terms throughout this discussion so far: there is REST, or RESTful,
    and there is REST-like. What that means is some developers will get pretty hardcore
    about following REST principles very rigidly (being RESTful). The problem with
    doing that is that sometimes you will have to make compromises in the design of
    the API that aren’t optimal. For example, some people say that the `/add` pattern
    described previously isn’t “proper” REST, but then they often don’t have a great
    answer for what the “right” answer is.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个重要的观点，我在整个讨论中通过使用模糊术语暗示过：有REST，或者RESTful，还有REST-like。这意味着一些开发者会非常严格地遵循REST原则（成为RESTful）。这样做的问题在于，有时你将不得不在API的设计中做出妥协，而这些妥协并不是最优的。例如，有些人说之前描述的`/add`模式不是“正确”的REST，但他们通常没有很好的答案来解释“正确”的答案是什么。
- en: By contrast, you can be a little more flexible and design your API to be REST-like,
    which means you follow *most* of the architectural guidelines that define REST
    but allow for some degree of fungibility in it. There will almost always be some
    cases where things don’t quite fit the REST model as cleanly as you might like.
    Even just the meaning of HTTP methods can be debatable. While `GET` and `DELETE`
    are virtually never argued about, some developers say that `POST` should be used
    for updates instead of `PUT`, among other debates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，你可以更加灵活一些，设计你的API使其成为REST-like，这意味着你遵循定义REST的*大多数*架构指南，但允许其中有一定的可互换性。几乎总会有一些情况，事情并不像你希望的那样完美地符合REST模型。即使是HTTP方法的含义也可能存在争议。虽然`GET`和`DELETE`几乎从未被争论过，但一些开发者说，`POST`应该用于更新而不是`PUT`，等等。
- en: There is no canonical “these are the rules of REST that you must follow, or
    woe be unto you!” that anyone can point to. REST isn’t a set of guidelines; it’s
    an architectural principle, and those generally don’t have well-defined rules
    to follow.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个标准的“你必须遵循这些REST规则，否则会有麻烦！”的规则，任何人都可以指向。REST不是一套指南；它是一个架构原则，这些通常没有明确的规则可以遵循。
- en: So, my advice is to lean on the side of being REST-like. As long as you’re using
    HTTP methods with consistent meanings, and as long as you’re using URLs to identify
    resources to work with, then you’re about 90% of the way toward doing “proper”
    REST. If you also use JSON for your representation of those resources, then that
    probably gets you to somewhere like 98%.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的建议是偏向于REST-like。只要你在使用具有一致意义的HTTP方法，并且只要你在使用URL来标识要处理资源，那么你大约已经完成了90%的“正确”REST。如果你还使用JSON来表示这些资源，那么这可能会让你达到大约98%。
- en: 'So, that in a nutshell is what REST is, but how do you build a REST web API?
    Let’s take a look at one way with something you have some familiarity with: Node
    and Express.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是REST的本质，但你是如何构建一个RESTful Web API的呢？让我们看看一种你多少熟悉的方法：Node和Express。
- en: Building your first REST API
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建你的第一个REST API
- en: We’ll begin, as always, by init’ing a new project with NPM. Then, we’ll add
    Express as a dependency using the now-familiar `npm install –save express` command.
    That sets us up for coding a RESTful API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像往常一样，使用NPM初始化一个新的项目。然后，我们将使用现在熟悉的`npm install –save express`命令添加Express作为依赖项。这为我们编写RESTful
    API奠定了基础。
- en: 'Let’s take our previous database example using our Starfleet personnel and
    create an API that will let us add people, delete people, update people, and,
    of course, query people. To keep things simple, our “database” (which here simply
    means a collection of data, not a proper database as previously discussed) will
    just be JS variables since we’re focusing on the API part right now and not the
    database part. I’ll break down the code into easily digestible bite-sized pieces,
    but the complete file is `restAPI.js` in the `ch-07/rest` directory of the download
    bundle, and it begins like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们之前的星舰人员数据库为例，创建一个 API，它将允许我们添加人员、删除人员、更新人员，当然，查询人员。为了简化问题，我们的“数据库”（在这里简单地说是指数据集合，而不是之前讨论的正规数据库）将只是
    JS 变量，因为我们现在专注于 API 部分，而不是数据库部分。我会将代码分解成易于消化的小块，但完整的文件是下载包中 `ch-07/rest` 目录下的
    `restAPI.js`，它开始如下：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We, of course, need to import Express itself and create an Express app, and
    then add some middleware to handle JSON being sent in a request. This is stuff
    you saw in [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要导入 Express 本身并创建一个 Express 应用程序，然后添加一些中间件来处理请求中发送的 JSON。这些内容你在[*第 3 章*](B18315_03.xhtml#_idTextAnchor082)中已经看到了。
- en: 'After that, we create our “database” in JS variables:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在 JS 变量中创建我们的“数据库”：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, an empty object is created and assigned to the `people` variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个空对象并将其分配给 `people` 变量。
- en: Next, we add the three crew members you saw earlier in the database discussion,
    each as a JS object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在数据库中添加之前在数据库讨论中看到的三个船员，每个都是一个 JS 对象。
- en: The thing to note here is that JS objects are what are known as **associative
    arrays**. This is a data structure where values are mapped to keys. In a JS object,
    the field names are the keys. What this allows us to do is use the array bracket
    notation to access those fields (the key names are associative with values, and
    we can use array notation to access them, hence *associative arrays*).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，JS 对象是所谓的**关联数组**。这是一种将值映射到键的数据结构。在 JS 对象中，字段名是键。这允许我们使用数组括号符号来访问这些字段（键名与值相关联，我们可以使用数组符号来访问它们，因此称为*关联数组*）。
- en: And, what’s interesting is that in JS, field names in objects can be numbers,
    so that’s what I’ve used for the keys here. That allows me to simply increment
    by one the `nextKey` variable that you see defined in the last line to create
    a unique key for each newly added person.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 而有趣的是，在 JS 中，对象的字段名可以是数字，所以我在这里使用了数字作为键。这允许我简单地通过递增 `nextKey` 变量（你在最后一行定义的）来为每个新添加的人员创建一个唯一的键。
- en: 'So, when that code executes, it results in a JS object with this structure:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当该代码执行时，它会产生一个具有以下结构的 JS 对象：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can then access any of the people in the object using the key values (`1`,
    `2`, or `3`) to access the object for a particular person. The keys act as identifiers
    for the people in essence, which allows us to request a person by that identifier.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用键值（`1`、`2` 或 `3`）来访问对象中的人，以访问特定人员的对象。本质上，键作为人员的标识符，这允许我们通过该标识符请求人员。
- en: 'With the database defined, we can set up the first function in our API, and
    that will be a `POST` request used to create a new person:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库定义好后，我们可以在我们的 API 中设置第一个函数，这将是一个用于创建新人员的 `POST` 请求：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you saw in [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082), we set up routes
    with Express, where a route corresponds to a URL, and we call the appropriate
    method on the app object that corresponds to the HTTP method the route should
    respond to in order to do that. Here, we wind up with a URL such as [http://localhost:8080/people](http://localhost:8080/people)
    that we can post to, which will trigger this code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[*第 3 章*](B18315_03.xhtml#_idTextAnchor082)中看到的，我们使用 Express 设置了路由，其中路由对应于
    URL，我们调用应用程序对象上对应于路由应响应的 HTTP 方法的适当方法来完成此操作。这里，我们最终得到一个可以发送的 URL，如 [http://localhost:8080/people](http://localhost:8080/people)，这将触发此代码。
- en: 'Inside the function, our middleware will have already parsed the incoming JSON,
    which would be in the following form:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们的中间件已经解析了传入的 JSON，其形式如下：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The individual values will be pulled out and added to the `inRequest.body` object.
    We can use JS destructuring notation (as explained in [*Chapter 6*](B18315_06.xhtml#_idTextAnchor159))
    to get the values into individual variables. From there, we take the value of
    `nextKey` as the key of the new object and make sure we increment it so that the
    next creation gets a new key. Then, we just add a new object with the data received
    in the request, under the key we just created.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 单个值将被提取并添加到`inRequest.body`对象中。我们可以使用JS解构符号（如[*第6章*](B18315_06.xhtml#_idTextAnchor159)中解释的那样）将值放入单独的变量中。从那里，我们取`nextKey`的值作为新对象的键，并确保我们增加它，以便下一次创建时得到一个新的键。然后，我们只需添加一个包含请求中接收到的数据的新对象，在刚刚创建的键下。
- en: 'The final step to creating our web API is to return a response since it wouldn’t
    be much good without that! But here is another facet of “proper” REST API design:
    the return codes should also have some meaning, just like the HTTP methods do.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的Web API的最终一步是返回一个响应，因为没有它的话，这并不会有什么用处！但是，这里还有“正确”的REST API设计的一个方面：返回码也应该有一些意义，就像HTTP方法一样。
- en: You could return an HTTP 200 status (or response) code here, because 200 means
    OK, or “the operation was successful.” However, code 201 means Created, which
    seems more right for an object creation function such as this. There can be debate
    about which is more appropriate, but the key thing is that your functions are
    consistent with response code meanings.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里返回一个HTTP 200状态码（或响应码），因为200表示“OK”，或者“操作成功。”然而，代码201表示“已创建”，这似乎更适合像这样的对象创建函数。关于哪个更合适可能会有争议，但关键是要确保你的函数与响应码的意义保持一致。
- en: 'And whatever choices you make, they should always be logical! While 200 or
    201 makes sense, 500, for example, wouldn’t because that code means Internal Server
    Error (you can see a list of the codes and their meanings here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做出什么选择，它们都应该始终是合理的！虽然200或201是有意义的，但例如500就不合适，因为这个代码表示内部服务器错误（你可以在这里看到代码列表及其含义：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status))。
- en: In addition to the response code, what you return is also an important consideration.
    And, at the risk of sounding like a broken record, you can find some debate about
    what is proper for various operations. But when creating a resource such as this,
    a good approach is to return the new resource itself, since the caller may want
    a copy of it, especially if the identifier is included, as it is here. That allows
    the caller to have all the information they need – the key – to delete or update
    the resource later without having to query the API again to get it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了响应码之外，你返回的内容也是一个重要的考虑因素。而且，风险是听起来像一张破唱片，你可能会发现关于各种操作应该是什么样子的争论。但是，当创建像这样的资源时，一个好的做法是返回新的资源本身，因为调用者可能想要一个它的副本，尤其是如果包含了标识符，就像这里一样。这允许调用者拥有他们需要的所有信息——关键——以便稍后无需再次查询API即可删除或更新资源。
- en: 'Next up, let’s look at a function to get a list of all people:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个获取所有人列表的函数：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Yep, it’s just a simple one line of code! We just need to return a response
    200 (which makes sense for a `GET` operation as none seem better to me) that is
    a JSON representation of the values – the objects for each person – in the `people`
    object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这只是一行简单的代码！我们只需要返回一个状态码200（对于一个`GET`操作来说这是合理的，在我看来没有比这更好的了），这是一个JSON表示的值——`people`对象中每个人的对象。
- en: 'The next function we’ll write is to get a single person:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的下一个函数是用来获取一个单独的人：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you define the URL for an HTTP request, here by calling `app.get()` again,
    you can have multiple handlers for a given HTTP method, but the URL must be different
    for each, or else Express won’t know which you want to use. Here, the URL is made
    different by the addition of the `:key` element. This is a token that Express
    will fill in and make available on the `inRequest.params` object. If a client
    makes a `GET` request to `/people`, then the previously-defined `app.get()` route
    handler will execute, but if they instead make a request to `/people/1`, then
    this function will execute instead, and the `1` value from the URL will become
    the value of `inRequest.params.key`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义HTTP请求的URL时，在这里通过再次调用`app.get()`，你可以为给定的HTTP方法有多个处理程序，但每个处理程序的URL必须不同，否则Express将不知道你想使用哪一个。在这里，通过添加`:key`元素，我们使URL不同。这是一个Express将填充并使它可在`inRequest.params`对象上可用的令牌。如果客户端向`/people`发出`GET`请求，那么之前定义的`app.get()`路由处理程序将执行，但如果他们改为向`/people/1`发出请求，那么这个函数将执行，URL中的`1`值将成为`inRequest.params.key`的值。
- en: That allows us to get the value into the `key` variable, which we can then use
    to access the right person object in `people` and send it back as JSON to the
    caller, fulfilling the request.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将值放入`key`变量中，然后我们可以使用它来访问`people`中的正确人员对象，并将其作为JSON发送给调用者，以满足请求。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I should take this opportunity to point out that I’ve written this code very
    simplistically, and one thing I left out in service of that goal is error checking.
    For example, what happens if the caller passes in a `key` variable that doesn’t
    exist in `people`? As written, they’ll get no response (or, really, an empty response
    – but not what a caller expects; that’s the point). You would most likely want
    to check for that condition and return a different status code, maybe 404 Not
    Found, and perhaps a string in the response saying it wasn’t found as well (the
    latter is another of those debatable REST decisions – some people feel the HTTP
    response code is sufficient; others always want *some* response from a function
    no matter what).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该利用这个机会指出，我非常简单化地编写了这段代码，为了实现这个目标，我忽略了一件事，那就是错误检查。例如，如果调用者传递了一个在`people`中不存在的`key`变量，会发生什么？按照现在的编写方式，他们将不会收到任何响应（或者，实际上，一个空响应——但这不是调用者期望的；这是重点）。你很可能想检查这种条件，并返回不同的状态码，比如404
    Not Found，也许在响应中还有一个字符串说它没有被找到（这也是那些可辩论的REST决策之一——有些人认为HTTP响应代码就足够了；其他人总是希望无论发生什么，函数都能返回`some`响应）。
- en: 'Okay, great – we can create people and we can get a list of all people and
    even get one specific person, so what about updating an existing person? That’s
    next:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太好了——我们可以创建人员，我们可以获取所有人的列表，甚至可以获取一个特定的人员，那么更新现有人员怎么办？下一个是：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The URL is the same as for getting a person, which makes sense since in both
    cases the caller needs to specify the resource that we’re dealing with. But, of
    course, we need a different HTTP method, so `app.put()` is used this time to register
    the handler for this route. Inside the handler function, we’ll keep things simple
    and always update all fields in the target resource (by way of creating a new
    object) rather than cherry-picking them. This means the caller must always send
    all the data back, even fields that aren’t changing. Then, it’s just a matter
    of creating a new object with the data sent in, assigning it to the proper key
    in the `people` object, and returning a suitable response.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: URL与获取人员的URL相同，这在逻辑上是合理的，因为在这两种情况下，调用者都需要指定我们正在处理哪种资源。但是，当然，我们需要不同的HTTP方法，所以这次使用`app.put()`来注册此路由的处理程序。在处理程序函数内部，我们将保持简单，并始终更新目标资源中的所有字段（通过创建一个新对象来实现）而不是挑选它们。这意味着调用者必须始终发送所有数据，即使是不变字段。然后，只需创建一个新的对象，用发送的数据填充它，将其分配给`people`对象中的适当键，并返回一个合适的响应。
- en: Since there isn’t an HTTP response code that more clearly means updated successfully,
    I went with a plain 200 (OK), and I sent back the `key` variable only this time
    since the caller already effectively has a copy of the data in its now-current
    state (arguably, it isn’t necessary to even send back the `key` variable, but
    in this case, I did prefer to have *something* returned).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有HTTP响应代码能更清楚地表示更新成功，所以我选择了普通的200（OK），这次只返回了`key`变量，因为调用者已经有效地在其当前状态中拥有数据的副本（可以说，甚至不需要发送回`key`变量，但在这个案例中，我更喜欢有`something`返回）。
- en: 'The final route we have to write is for deleting a person:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写的最后一个路由是用于删除人员：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Yep, it’s that simple! This time, we use `app.delete()` since that’s the HTTP
    method needed to use this function. We get the `key` variable from the URL and
    use the JS `delete` keyword, which removes a field from an object, to remove the
    specified person. Finally, an HTTP 200 response code is sent back, along with
    the `key` variable that was removed (again, because I felt it more appropriate
    to not just return an empty response, but that’s a call you’ll have to make in
    your own work).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就这么简单！这次，我们使用`app.delete()`，因为这是使用此功能所需的HTTP方法。我们从URL中获取`key`变量，并使用JS的`delete`关键字，它从对象中删除一个字段，以删除指定的人。最后，发送一个HTTP
    200响应代码，以及被删除的`key`变量（再次，因为我认为不只是一个空响应更合适，但这将是你自己工作中需要做出的决定）。
- en: 'And with that, we have all the functions in our web API that we need. Now,
    we simply need to start the Express server and thereby make our API active:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了我们需要的所有Web API功能。现在，我们只需要启动Express服务器，从而使我们的API变得活跃：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We run it on port `8080`, and everything is good to go.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在端口`8080`上运行它，一切正常。
- en: 'Now, you can, of course, go off and write some code, perhaps some JS to run
    in a browser, which calls this API. But before you do that, wanting to be a good
    web developer, you should probably test it a bit, right? How can you do that?
    You have lots of options here, but I’m going to talk about one very popular one
    in particular next: Postman.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你当然可以离开并编写一些代码，比如一些在浏览器中运行的JS代码，以调用这个API。但在你这样做之前，作为一个想要成为优秀的Web开发者，你可能需要测试一下，对吧？你有很多选择，但我接下来要特别谈谈一个非常受欢迎的选项：Postman。
- en: Testing the API with Postman
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Postman测试API
- en: Once you have an API running, testing it can be done in many ways, but one way
    that many developers use is a tool called Postman. This is a GUI desktop application
    that allows you to make all sorts of HTTP requests to anything you need to, including
    the API that you should have running on your machine at this point. With Postman,
    you define requests, including what HTTP method they use, what URL they use, and
    any data to be sent with them, and you can trigger those requests at the click
    of a button. Postman can show you the response and can even take the raw response
    and reformat it to make it easier to read.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个API正在运行，测试它可以通过多种方式完成，但许多开发者使用的一种方式是名为Postman的工具。这是一个GUI桌面应用程序，允许你向任何你需要的东西发送各种HTTP请求，包括你现在应该在机器上运行的API。使用Postman，你可以定义请求，包括它们使用的HTTP方法、使用的URL以及与它们一起发送的任何数据，并且你可以通过点击按钮来触发这些请求。Postman可以显示响应，甚至可以将原始响应重新格式化，使其更容易阅读。
- en: 'As an example, testing the `GET` operation to retrieve all the people from
    our faux database is easy:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试从我们的模拟数据库检索所有人的`GET`操作很容易：
- en: Launch Postman and login if necessary.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Postman并在必要时登录。
- en: Create a workspace if you don’t have one already (it may create one by default
    for you).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有工作区，创建一个（它可能会默认为你创建一个）。
- en: On the left, you should see a **Collections** tab. Collections are just groups
    of logically related requests. Create a new collection with the **+** button you
    should see next to the **Collections** tab, and name it whatever you’d like (I
    uncreatively called mine **Book**).
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，你应该看到一个**集合**标签。集合只是逻辑上相关的请求的组。使用你将在**集合**标签旁边看到的**+**按钮创建一个新的集合，并给它起一个你喜欢的名字（我创造性地把它叫做**书**）。
- en: Click the collection so that it’s highlighted, at which point you should see
    a three-dot menu to the right of the name. Click the menu, and then select the
    **Add Request** option. You should see a new request added, and over on the right,
    a new tab should appear that has all the details about the request; Postman should
    automatically focus on the name of the request, ready for you to enter anything
    you wish there.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击集合，使其高亮显示，此时你应该在名称右侧看到一个带有三个点的菜单。点击菜单，然后选择**添加请求**选项。你应该看到一个新请求被添加，在右侧，应该出现一个新的标签，其中包含请求的所有详细信息；Postman应该自动将焦点放在请求的名称上，以便你可以在那里输入任何你想要的。
- en: Ensure that the **GET** method is selected in the dropdown below the request
    name.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在下拉菜单中选择请求名称下方的**GET**方法。
- en: 'In the box to the right of the method, which should say **Enter URL** initially,
    enter the following URL: [localhost:8080/people](https://localhost:8080/people).'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法右侧的框中，最初应该显示为**输入URL**，输入以下URL：[localhost:8080/people](https://localhost:8080/people)。
- en: You should then be able to click the **Send** button to send the request, and
    the results should appear in the **Response** section at the bottom.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你应该能够点击**发送**按钮来发送请求，并且结果应该出现在底部的**响应**部分。
- en: '*Figure 7**.5* shows what all of this should look like when done properly:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.5* 展示了所有这些操作完成正确时的样子：'
- en: '![Figure 7.5: Postman, with a Book collection, a Get All request added, and
    a successful Get All response](img/B18315_07_5.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5：Postman，包含一个书集合，添加了一个 Get All 请求，并成功返回了 Get All 响应](img/B18315_07_5.jpg)'
- en: 'Figure 7.5: Postman, with a Book collection, a Get All request added, and a
    successful Get All response'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：Postman，包含一个书集合，添加了一个 Get All 请求，并成功返回了 Get All 响应
- en: 'You can then add a request to test creating a new person. It’s the same procedure
    starting with creating a new request in the collection; however, this time, the
    method will be `POST` body content to send. It’ll just be some JSON, perhaps like
    the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以添加一个请求来测试创建新人员。这和开始时在集合中创建新请求的流程相同；然而，这次，方法将是 `POST` 主体内容以发送。它将只是某些 JSON，可能如下所示：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To the right of the **Body** tab, you’ll also need to select the type of data
    as **JSON**. Once that’s done, you should be able to trigger the request and get
    back a valid response, as shown in *Figure 7**.6*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Body** 选项卡的右侧，你还需要选择数据类型为 **JSON**。完成这些后，你应该能够触发请求并获得有效的响应，如图 *图 7.6* 所示：
- en: '![Figure 7.6: Postman, showing a successful Create response](img/B18315_07_6.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6：Postman，显示一个成功的 Create 响应](img/B18315_07_6.jpg)'
- en: 'Figure 7.6: Postman, showing a successful Create response'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：Postman，显示一个成功的 Create 响应
- en: As an exercise, go ahead and add requests for updating and deleting people.
    Remember that in those cases, the URL will need to include the key on the end
    (so, something like [localhost:8080/people/4](https://localhost:8080/people/4),
    for example, if 4 is the key returned from a create call). Play around with it
    a bit, creating a person, then doing a **Get All** to see that it has been added,
    then maybe updating a person and doing a **Get** for that specific person to see
    the update, and finally deleting that person and then doing a final **Get All**
    to see they’ve been removed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，请继续添加更新和删除人员的请求。记住，在这些情况下，URL 需要包含末尾的键（例如，如果 4 是从创建调用返回的键，那么可能是类似 [localhost:8080/people/4](https://localhost:8080/people/4)
    的内容）。稍作尝试，创建一个人，然后进行 **Get All** 操作以查看它已被添加，然后可能更新一个人并为此特定人员进行 **Get** 操作以查看更新，最后删除那个人，然后进行最终的
    **Get All** 操作以查看他们已被移除。
- en: 'This is just the very basics of using Postman; it has a lot more capabilities
    than this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用 Postman 的基本操作；它具有比这更多的功能：
- en: You can write scripts to execute multiple requests to more fully test your target
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以编写脚本来执行多个请求，以更全面地测试你的目标
- en: You can include cookies and headers and all the other goodies HTTP requests
    allow for
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以包括 cookie、头部以及 HTTP 请求允许的所有其他好东西
- en: You can supply security credentials for APIs that require it
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为需要安全凭证的 API 提供安全凭证
- en: You can simulate a browser sending a form rather than sending JSON
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以模拟浏览器发送表单而不是发送 JSON
- en: You can test GraphQL servers, which is a way you can expose a database to clients
    directly in a safe way and in a way that they can query for data based on their
    own specific needs.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以测试 GraphQL 服务器，这是一种你可以以安全的方式直接将数据库暴露给客户端，并且根据他们自己的特定需求查询数据的方法。
- en: You can set up certificates to be able to test HTTPS endpoints
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以设置证书以能够测试 HTTPS 端点
- en: 'In short: if it’s done via HTTP/HTTPS, then you can almost certainly do it
    with Postman. It’s a great tool that allows you to test your server-side code
    without having to write all the client-side code first.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：如果是通过 HTTP/HTTPS 完成的，那么你几乎肯定可以用 Postman 完成。这是一个伟大的工具，它允许你在编写所有客户端代码之前测试你的服务器端代码。
- en: But aside from during development, another situation where a tool such as Postman
    can come in handy is if your code isn’t working right for a given request from
    client to server. The problem could be in your client code or your server code.
    How do you know which it is? One good way to start figuring that out is to remove
    one or the other from the equation entirely. If you test your web API with Postman
    and find a problem occurs, then you just discovered the problem must be on the
    server side since the client side isn’t involved. Well, to be fair, as you gain
    experience, you’ll find that statement isn’t always as concrete as it seems! But
    it’s a generally solid approach to getting on the right path, at least.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了开发期间，另一个可以使用像Postman这样的工具的情况是，如果你的代码对于客户端到服务器的特定请求不起作用。问题可能出在客户端代码或服务器代码中。你怎么知道是哪一个呢？一个很好的开始方法是完全从方程中移除一个或另一个。如果你使用Postman测试你的Web
    API并发现出现问题，那么你就发现了问题一定在服务器端，因为客户端没有参与。好吧，公平地说，随着你经验的积累，你会发现这个说法并不总是像看起来那样具体！但至少这是一个通向正确道路的一般稳健方法。
- en: Now that you’ve learned a bit about databases and web APIs, let’s talk about
    something that was actually touched upon earlier but that there’s a little bit
    more to say about, that being the “classic” web versus the “modern” (SPA-based,
    primarily) web, and how what’s old is what’s new again, in a sense, in the form
    of SSR.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对数据库和Web API有了一些了解，让我们谈谈之前已经触及但还有更多话要说的话题，那就是“经典”Web与“现代”（基于SPA的，主要是）Web的比较，以及旧的就是新的，在某种程度上，以SSR的形式。
- en: Going back to the future – SSR
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到未来——SSR
- en: 'In [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082), we talked about SPAs and
    how they lead to a different model of web development. We talked about how this
    new model was in contrast to the classic model, where every interaction on the
    page leads to a request to the server, which generates an entirely new HTML page
    to be displayed. The new model instead depends on JS: on the client making a request
    to the server for just data, which the client code then does something with, most
    often displaying it in some fashion.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第三章*](B18315_03.xhtml#_idTextAnchor082)中，我们讨论了SPA以及它们如何导致不同的Web开发模型。我们讨论了这种新模型与经典模型的不同，在经典模型中，页面上的每一次交互都会导致对服务器的请求，服务器生成一个全新的HTML页面来显示。而新模型则依赖于JS：客户端向服务器请求数据，客户端代码随后对其进行处理，最常见的是以某种形式显示它。
- en: When we looked at React, Vue, and Angular, we saw how the initial HTML document
    was essentially empty, and everything that wound up being shown in the browser
    was created on the fly by JS on the client machine.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看React、Vue和Angular时，我们看到了初始HTML文档基本上是空的，最终在浏览器中显示的所有内容都是由客户端机器上的JS即时创建的。
- en: What’s interesting, though, is that as with many things in this field, the pendulum
    is swinging back the other way a little bit, this time in the form of **SSR**,
    which stands for **server-side rendering**. With SSR, web pages are rendered on
    the server and returned to the browser.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的是，正如这个领域中的许多事物一样，摆锤正在稍微向相反方向摆动，这一次是以**SSR**的形式，它代表**服务器端渲染**。使用SSR，网页在服务器上渲染并返回给浏览器。
- en: But wait – isn’t that what came *before* SPAs?!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等——这难道不是在SPAs之前就存在的事情吗？!
- en: Yes. Yes, indeed it is. The wheel turns, does it not?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。是的，确实如此。车轮转动，不是吗？
- en: As you can probably guess, though, there is a difference between SSR and just
    having static HTML pages on a web server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你可能猜到的，SSR和仅在Web服务器上拥有静态HTML页面之间还是存在区别的。
- en: With SSR, it’s often the case that only the first request generates a new HTML
    page. The server takes what is essentially a template in the form of an HTML page,
    merges in some data, and then returns the final HTML to the client. However, what’s
    interesting is that some of that work can actually be done via JS executing on
    the server instead of the browser. In effect, the server is acting like a web
    browser, albeit one that doesn’t display the HTML. You can even use libraries
    such as React, Vue, and JS to render the content, but on the server. The server
    produces the final HTML document, as a browser would by executing the JS, and
    returns it, fully formed, to the browser. This will very often (almost always,
    in fact) include all the necessary CSS and JS, embedded in the HTML document.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSR时，通常只有第一次请求会生成新的HTML页面。服务器将一个本质上为HTML页面的模板合并一些数据，然后返回最终的HTML给客户端。然而，有趣的是，其中一些工作实际上可以通过在服务器上执行JS而不是在浏览器中执行来完成。实际上，服务器就像一个网络浏览器，尽管它不显示HTML。你甚至可以使用React、Vue和JS等库在服务器上渲染内容。服务器生成最终的HTML文档，就像浏览器通过执行JS一样，并将其完整地返回给浏览器。这通常（实际上几乎总是）包括所有必要的CSS和JS，它们都嵌入在HTML文档中。
- en: Subsequent actions that occur on the client may result in a call to the server
    that generates a whole new HTML document, making SSR in that situation just like
    the classic model. But more often, after the initial page is loaded, things begin
    to function like an SPA in that the server is called to get only data, which is
    then rendered or used on the client in some way. We wind up with something of
    a hybrid approach.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发生的后续操作可能会导致调用服务器以生成整个新的HTML文档，在这种情况下，SSR就像经典模型一样。但更常见的是，在初始页面加载后，事情开始像SPA一样运作，即服务器被调用以获取数据，然后以某种方式在客户端渲染或使用这些数据。我们最终得到一种混合的方法。
- en: 'Why would anyone want to do this, you might ask? There are a couple of good
    reasons:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么有人想这样做？有几个很好的理由：
- en: '**Performance**: Especially when we’re talking about how fast a website loads
    initially, performance is a key metric. By using the server to do that work –
    servers that are in most cases more powerful than client machines and that are
    closer to the data they need – returning a complete document can be noticeably
    faster than returning an HTML document, which then creates new requests to get
    resources such as JS, CSS, and image files, and then render the content with JS.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：特别是当我们谈论网站最初加载速度时，性能是一个关键指标。通过使用服务器来完成这项工作——这些服务器在大多数情况下比客户端机器更强大，并且更接近它们所需的数据——返回完整的文档可以比返回HTML文档（然后创建新的请求以获取资源，如JS、CSS和图像文件，然后使用JS渲染内容）明显更快。'
- en: '**Search engine optimization (SEO)**: It’s the art of including content on
    a website that search engines use to rank your site. Properly tuning this content
    allows you to show up sooner in search results, which is a key consideration for
    public websites. With a website that functions purely as an SPA, that content
    only exists on the client machine when requested, so search engines have a harder
    time indexing your site, and you have a harder time performing SEO. With SSR,
    though, because the server is returning a full HTML document and not a nearly
    empty one, you’d get to start a React, Vue, or Angular app, and search engines
    “see” more content to index, which, when SEO is done properly, leads to higher
    ranking in search results.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索引擎优化（SEO）**：这是在网站上包含搜索引擎用于对您的网站进行排名的内容的艺术。正确调整此内容可以使您在搜索结果中更快地显示出来，这对于公共网站来说是一个关键考虑因素。对于仅作为SPA运行的网站，该内容仅在请求时存在于客户端机器上，因此搜索引擎更难索引您的网站，您也更难进行SEO。但是，使用SSR时，由于服务器返回的是完整的HTML文档而不是几乎空的文档，因此您可以启动React、Vue或Angular应用程序，搜索引擎“看到”更多内容可以索引，当SEO做得正确时，这会导致搜索结果中的排名更高。'
- en: '**Better device support**: Because most of the heaviest lifting in terms of
    rendering the full HTML is done on the server, it allows less powerful client
    devices to have a more acceptable experience. Older cell phones, for example,
    still used around the world, will usually have an easier time rendering a complete
    HTML page – which from its perspective is static – than it will running a lot
    of complex JS on the phone itself to generate the HTML on the fly.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的设备支持**：因为大多数渲染完整HTML的繁重工作都在服务器上完成，这允许较弱的客户端设备有更好的体验。例如，全球仍在使用的旧手机，通常在渲染完整的HTML页面（从其角度来看是静态的）方面会比在手机上运行大量复杂的JS来动态生成HTML要容易得多。'
- en: 'Most of the modern frameworks have support for SSR nowadays. In fact, it can
    be as easy as flipping a switch in a config file in some cases, and all of a sudden,
    you’ll find your initial HTML document being rendered on the server. Although
    in a lot of ways like the classic model, which at this point is 30+ years old,
    SSR is a fairly new thing. Well, sort of: it was actually introduced in some modern
    frameworks as early as 2010, and 10 years in web development really isn’t a long
    time! But it’s new in the sense that it has started picking up steam in terms
    of developer mindshare more recently, as it’s become a more standard part of modern
    frameworks.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代框架现在都支持SSR。实际上，在某些情况下，这可以像在配置文件中切换一个开关一样简单，突然间，你会发现你的初始HTML文档已经在服务器上被渲染了。尽管在许多方面，比如经典的模型，这个模型到现在已经有30多年历史了，SSR相对较新。好吧，有点新：它实际上在2010年左右就被引入到一些现代框架中，而在网络开发中，10年真的不算长！但它在开发者心智份额方面开始崭露头角，因为它已经成为现代框架的一个更标准的部分。
- en: But it’s still an optional thing. Is it possible to do SEO without SSR? Yes,
    it is, though it can be more challenging. For example, you’ll sometimes find that
    you may have to have some content in your static HTML page that is invisible and
    that gets removed when it gets to the browser – but then, you’ll find that search
    engines are kind of on to such tricks, so it may not work as well as you’d hope,
    or indeed at all in some cases. And your use case may not make SSR worth it anyway
    because it certainly does complicate things, and any time you add complexity to
    web development, you have to do a cost-benefit analysis to decide if it’s worth
    it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但它仍然是一个可选的东西。没有SSR也能做SEO吗？是的，可以，尽管这可能更具挑战性。例如，你有时会发现你可能需要在你的静态HTML页面中包含一些不可见的内容，当它到达浏览器时会被移除——但然后，你会发现搜索引擎似乎已经发现了这样的伎俩，所以它可能不会像你希望的那样有效，或者在某些情况下根本不起作用。而且，你的用例可能根本不值得使用SSR，因为它确实使事情复杂化，每次你在网络开发中增加复杂性时，你都必须进行成本效益分析，以决定它是否值得。
- en: Another possibility is to use server-side technologies to render your initial
    HTML document (as well as handle subsequent data requests), which is actually
    another form of SSR in a sense, but one in which you have more granular control.
    That can be done with Node, of course, but there are other options, and that’s
    what we’re going to talk about next.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用服务器端技术来渲染你的初始HTML文档（以及处理后续的数据请求），这在某种程度上实际上是一种SSR（服务器端渲染）的形式，但你在其中拥有更细粒度的控制。当然，这可以用Node来实现，但还有其他选择，这正是我们接下来要讨论的内容。
- en: Using PHP on the server side
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器端使用PHP
- en: There are many server-side technologies you can use; you’re not limited to Node
    and JS. One such technology – one of the oldest, in fact – is PHP. First hitting
    the scene in 1995 (though taking a couple of years to start gaining traction),
    PHP is what’s known as a *preprocessor*. Essentially, it’s an extension to a web
    server that performs some sort of manipulation on a requested resource.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用许多服务器端技术；你不仅限于Node和JS。其中一种技术——实际上是最古老的之一——是PHP。PHP首次出现在1995年（尽管花了几年时间才开始流行），PHP被称为*预处理器*。本质上，它是对Web服务器的一种扩展，对请求的资源进行某种操作。
- en: In the case of PHP, that manipulation is executing code written in the PHP language
    that is embedded in an HTML file. The file is given a `.php` extension, and when
    requested, that extension identifies to the web server that it needs to hand that
    file off to the PHP preprocessor, allow it to transform it, and then return to
    the caller whatever the output of that transformation is.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP的情况下，这种操作是执行嵌入在HTML文件中的PHP语言编写的代码。该文件被赋予`.php`扩展名，当请求时，该扩展名会告诉Web服务器需要将该文件交给PHP预处理器，允许它对其进行转换，然后返回转换的输出给调用者。
- en: 'That may sound a little complicated, but I think a simple example will make
    it clear (you’ll find this in the `hello_world.php` file in the `ch-07/php` directory).
    As always in programming, let’s use a “Hello, world!” example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点复杂，但我认为一个简单的例子会使其变得清晰（你可以在`ch-07/php`目录下的`hello_world.php`文件中找到这个例子）。像往常一样，在编程中，让我们使用一个“Hello,
    world！”的例子：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, it’s a simple HTML document, until you hit that funky-looking
    `<?php` thing. This begins a block of PHP code, and `?>` closes the block. Anything
    in between those must be written in PHP. When this file is requested from a web
    server that has PHP installed, the web server sees the `.php` extension and hands
    the file off to the PHP processor. The processor looks for any PHP code blocks
    like this (of which you can have as many as you like) and executes the code in
    it. Whatever the output of the code is, if any, replaces the block in the final
    output.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它是一个简单的HTML文档，直到你看到那个看起来很奇怪的`<?php`。这标志着PHP代码块的开始，而`?>`则关闭该块。在这两者之间的任何内容都必须用PHP编写。当这个文件从一个安装了PHP的Web服务器请求时，Web服务器看到`.php`扩展名，并将文件交给PHP处理器。处理器会寻找任何这样的PHP代码块（你可以有任意多个），并执行其中的代码。无论代码的输出是什么，如果有输出的话，它将替换最终输出中的块。
- en: 'As a result, what gets returned to the browser in this case will be the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下返回给浏览器的将是以下内容：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, there no longer is any PHP code. Instead, the text that the
    code outputs via the `echo` statement replaces it. This is a common approach with
    many server-side technologies, *“execute some code in a special block and replace
    it with the result of that code,”* and it means that the client doesn’t need to
    know anything about PHP; it’s all handled on the server. The client just knows
    that it’s getting an HTML document back; it doesn’t know anything about what the
    server did to produce it, but PHP and technologies like it provide us developers
    a very simple way to build dynamic content into otherwise static resources and
    without any complex infrastructure or code such as in a Node/Express application,
    for comparison.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这里已经不再有任何PHP代码。取而代之的是，通过`echo`语句输出的文本替换了它。这是一种许多服务器端技术中常见的做法，“在特殊块中执行一些代码，并用其结果替换它”，这意味着客户端不需要了解任何关于PHP的知识；所有这些都由服务器处理。客户端只知道它会收到一个HTML文档；它不知道服务器是如何生成它的，但PHP和类似的技术为我们开发者提供了一个非常简单的方法，将动态内容嵌入到其他静态资源中，而无需任何复杂的基础设施或代码，例如与Node/Express应用程序相比。
- en: PHP is a robust and powerful language, much like JS, and has a lot of libraries
    supporting it that allow it to, for example, interface with databases easily,
    make calls to remote systems, manipulate images, and really do all the things
    that any useful server-side language would do. It has over time evolved into a
    modern language with all the sorts of features developers have come to expect
    from a modern language.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种强大且功能丰富的语言，就像JS一样，并且有许多库支持它，这使得它可以轻松地与数据库交互，调用远程系统，操作图像，以及真正地做任何有用的服务器端语言会做的事情。随着时间的推移，它已经发展成为一个具有现代语言开发者所期望的所有特性的现代语言。
- en: 'To give you just a little more of a taste of PHP, let’s implement a pretty
    common thing done with it, or really any server-side technology: handling the
    submission of a form.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你对PHP有更深的了解，让我们实现一个用PHP做得很常见的事情，或者说是任何服务器端技术：处理表单的提交。
- en: 'First, we’ll create a simple form (`form.html`):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的表单（`form.html`）：
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, it’s just a simple HTML form, something you’ve seen before.
    We allow the user to enter their name and submit the form; that’s it. The target
    of the form submission is `form.php`, which we’ll create next:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它只是一个简单的HTML表单，你之前已经见过。我们允许用户输入他们的名字并提交表单；仅此而已。表单提交的目标是`form.php`，我们将在下一部分创建它：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we construct a plain text response by getting the `username` variable
    from the request and constructing a string with it. Variables in PHP begin with
    a `$` symbol, and the `$_POST` variable is one PHP supplies which will hold the
    values of any data submitted via a POST request. The only one we have to worry
    about is `username`, so we wind up with a `$username` variable with the value
    of whatever the user submitted in the form. Then, `echo` is used to create the
    output, and in PHP, periods are used to represent string concatenation, so we’re
    building a string such as `"Hello, Frank!"` and returning that to the client (note
    that we don’t need to construct a full HTML document because the browser is quite
    capable of displaying a plain text response such as this).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过从请求中获取 `username` 变量并使用它构造一个字符串来构建一个纯文本响应。PHP 中的变量以 `$` 符号开头，`$_POST`
    变量是 PHP 提供的一个变量，它将保存通过 POST 请求提交的任何数据的值。我们唯一需要担心的是 `username`，所以我们最终得到一个包含用户在表单中提交的任何值的
    `$username` 变量。然后，使用 `echo` 创建输出，在 PHP 中，点号用于表示字符串连接，因此我们构建一个如 `"Hello, Frank!"`
    的字符串并将其返回给客户端（注意，我们不需要构建一个完整的 HTML 文档，因为浏览器完全能够显示这样的纯文本响应）。
- en: PHP is fairly straightforward but opens up a lot of possibilities. It is, however,
    far from the only such option available. Another one, which in some contexts is
    much more popular, is Java, and specifically the Spring Boot library for it. Let’s
    take a quick look at that now.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 相对简单直接，但开辟了众多可能性。然而，它绝不是唯一可用的此类选项。另一个在有些情况下更为流行的选项是 Java，特别是为其提供的 Spring
    Boot 库。现在让我们快速看一下这个。
- en: Building with Java and Spring Boot
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java 和 Spring Boot 进行构建
- en: Java and Spring Boot kind of go hand in hand these days in the sense that Spring
    Boot is the most popular way people write apps using Java nowadays, but Spring
    Boot couldn’t exist without Java. So, let’s start with Java, then talk about some
    things that go along with it that allow you to build web apps, and finally arrive
    at Spring Boot. I think once you’ve read through this entire section, you’ll understand
    how the pieces fit together pretty well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Java 和 Spring Boot 在某种程度上是相辅相成的，因为 Spring Boot 是人们现在使用 Java 编写应用程序最流行的方式，但
    Spring Boot 没有Java就无法存在。所以，让我们从 Java 开始，然后讨论一些与之相关的可以帮助你构建 Web 应用程序的事情，最后到达 Spring
    Boot。我认为一旦你阅读完这一节，你将很好地理解这些部分是如何相互配合的。
- en: Introducing Java
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Java
- en: '**Java**, which I’ll let you know up-front has nothing to do with JS other
    than a similar-looking language syntax and is a product of the now-defunct Sun
    Microsystems, is now owned by Oracle, and it is easily one of the most widely
    used languages and platforms of them all. It is especially popular in enterprise
    environments where things such as stability and flexibility – and having a company
    sue if something goes wrong, to be blunt – are of primary importance.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**，我会在一开始就告诉你它与 JS 没有任何关系，除了有相似的语言语法，并且是现在已解散的 Sun Microsystems 的产品，现在由
    Oracle 拥有，并且它可能是所有语言和平台中最广泛使用之一。它在企业环境中特别受欢迎，在这些环境中，稳定性、灵活性——以及如果出现问题，公司会起诉，坦白说——是首要考虑的因素。'
- en: Java became popular based on its “write once run anywhere” principle. It was
    one of the first languages that allowed for a piece of code, without being changed
    in any way, to run on multiple different hardware platforms and operating systems.
    There were a few ways to do that before Java, but none were as easy as Java.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的流行基于其“一次编写，到处运行”的原则。它是最早允许一段代码（无需任何修改）在不同的硬件平台和操作系统上运行的编程语言之一。在 Java 之前有几种方法可以实现这一点，但没有一种像
    Java 那样简单。
- en: Java accomplishes this by the introduction of the **JVM**, or **Java Virtual
    Machine**. It’s similar conceptually to the VMs you’ve already met, but it’s not
    a full simulation of a machine. Instead, it’s a simulation of an artificial machine,
    one that doesn’t exist in the real world. It winds up being a target for compiled
    code. In other words, rather than compiling Java code to a form that can run on
    the native machine, it instead compiles to an intermediate form that can run on
    the artificial machine the JVM represents. The JVM also isn’t an encapsulation
    of that machine and an operating system like a VM is; it instead is just the machine,
    with the compiled Java code running on it, and being the only thing running on
    it (more or less).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过引入**JVM**，即**Java虚拟机**来实现这一点。从概念上讲，它与您已经遇到的虚拟机类似，但它并不是一个完整的机器模拟。相反，它是对一个人工机器的模拟，这个机器在现实世界中并不存在。它最终成为编译代码的目标。换句话说，Java不是将代码编译成可以在本地机器上运行的格式，而是编译成可以在JVM代表的虚拟机器上运行的中间格式。JVM也不是像虚拟机那样的机器和操作系统的封装；它只是机器，上面运行着编译后的Java代码，并且是唯一运行在它上面的东西（或多或少）。
- en: Java also comes with a very extensive standard library and thousands upon thousands
    of functions for you to use, battle-tested and extremely solid. This means you
    have a great foundation to build upon even before you think about adding any third-party
    libraries, which Java, of course, supports.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Java还附带了一个非常广泛的标准的库和成千上万的函数供您使用，经过实战检验且非常稳固。这意味着您有一个很好的基础可以在此基础上构建，甚至在您考虑添加任何第三方库之前，Java当然支持第三方库。
- en: When you work with Java, you normally will interact with its **JDK** or **Java
    Development Kit**. The JDK is a specific form of an **SDK**, which stands for
    **software development kit**. An SDK is a collection of tools for working with
    a specific development platform or language, and a JDK then is an SDK specific
    to Java. You install a JDK, or indeed you can usually just expand an archive and
    not actually install it per se, and then use its command-line tools to compile
    code, debug code, and do all the other things you might want to do with Java code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Java时，您通常会与它的**JDK**或**Java开发工具包**交互。JDK是**SDK**（软件开发工具包）的一种特定形式。SDK是一组用于与特定开发平台或语言一起工作的工具，而JDK是针对Java的SDK。您安装一个JDK，或者实际上通常只需展开存档而不真正安装它，然后使用其命令行工具编译代码、调试代码以及执行您可能想要用Java代码做的所有其他事情。
- en: Writing a Java app
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Java应用程序
- en: 'And what does Java code look like? Here is perhaps the simplest Java app you
    can write (this is the `HelloWorld.java` file in the `ch-07/java` directory):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 那么Java代码看起来是什么样子呢？这里可能是你可以编写的最简单的Java应用程序（这是位于`ch-07/java`目录中的`HelloWorld.java`文件）：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is called a Java *app* specifically, and it shows that everything in Java
    begins with a class, which is the fundamental concept in `public` keyword before
    the `class` keyword and name is called an access modifier, and it tells Java where
    this class can be used from. The `public` access modifier means that any other
    Java code can use it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为Java *应用程序*，它表明Java中的所有内容都是以一个类开始的，这是在`class`关键字之前带有`public`关键字和名称的基本概念，被称为访问修饰符，它告诉Java这个类可以从哪里使用。`public`访问修饰符意味着任何其他Java代码都可以使用它。
- en: 'Classes can have a lot of stuff in them, but this one contains just one thing:
    a function (or method, since it’s a function in a class) named `main()`. The method
    has the `public` access modifier too, so any other Java code can call this method
    (by contrast, a method can be private, which would mean that only other code in
    the class can use it).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 类中可以包含很多东西，但这个类只包含一件事情：一个名为`main()`的函数（或方法，因为它是类中的函数）。该方法也有`public`访问修饰符，所以任何其他Java代码都可以调用这个方法（相比之下，一个方法可以是私有的，这意味着只有类中的其他代码可以使用它）。
- en: The `static` keyword means that the `main()` method can be called on the `HelloWorld`
    class without creating a new instance of it first (which is typically what we
    do with classes – create object instances from them, but in this case, we just
    want to be able to execute the method, so we can skip that requirement with `static`).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`关键字表示可以在不首先创建`HelloWorld`类的新实例的情况下调用`main()`方法（这通常是我们在类上所做的——从它们创建对象实例，但在这个例子中，我们只想能够执行方法，所以我们可以使用`static`来跳过这个要求）。'
- en: The `void` keyword means that this method won’t return anything.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`void` 关键字表示该方法不会返回任何内容。'
- en: This method accepts an argument that is an array of strings and that will come
    from any options we pass to it on the command line when run, if any (we don’t
    need that here, but I figured I’d mention it since it’s required by Java to make
    a Java app work).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个字符串数组作为参数，并且当运行时，如果提供了任何选项，它将来自我们传递给它的命令行（我们这里不需要，但我提到这一点，因为Java需要它来使Java应用程序工作）。
- en: The `System.out.println()` statement in `main()` – the only code in it – is
    a method that outputs text to the console.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数中的`System.out.println()`语句——它是里面唯一的代码——是一个将文本输出到控制台的方法。'
- en: 'You must first compile this app, and that’s done using the Java compiler:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须首先编译这个应用程序，这是使用Java编译器完成的：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That will produce a `HelloWorld.class` file. A `.class` file is what actually
    runs on the JVM, which you can now do easily:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个`HelloWorld.class`文件。`.class`文件是实际上在JVM上运行的文件，你现在可以轻松地这样做：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that `javac` is the Java compiler, while plain old `java` is essentially
    the JVM. The JVM will look for a file named `HelloWorld.class` in the current
    directory, will find it assuming you’ve compiled `HelloWorld.java`, and will then
    look for a `public static void main()` method in it (it *has* to be that *exact*
    method signature), which is the default method a Java app must include to be runnable.
    Finding one, it will execute the method, and the text should be output to the
    console.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`javac`是Java编译器，而普通的`java`实际上是JVM。JVM将在当前目录中查找名为`HelloWorld.class`的文件，假设你已经编译了`HelloWorld.java`，然后会在其中查找`public
    static void main()`方法（它必须是这个**确切**的方法签名），这是Java应用程序必须包含以使其可运行的标准方法。找到后，它将执行该方法，文本应该输出到控制台。
- en: Java apps are neat, and you can do virtually anything with them, but when we’re
    talking about web development with Java, we rarely do that with plain Java apps.
    The next step above apps when it comes to web development are JSPs and servlets.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序很棒，你可以用它们做几乎任何事情，但当我们谈论使用Java进行Web开发时，我们很少用纯Java应用程序来做。在Web开发中，比应用程序更高的步骤是JSP和servlets。
- en: Introducing JSPs and servlets
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍JSP和servlets
- en: 'As with PHP (and with `.cshtml` files, as you’ll see with .NET later), Java
    offers a template language called **JSP**, or **Java Server Pages**. This allows
    you to embed Java code in HTML files. A simple example would be the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHP（以及你稍后将在.NET中看到的`.cshtml`文件）一样，Java提供了一种名为**JSP**或**Java Server Pages**的模板语言。这允许你在HTML文件中嵌入Java代码。一个简单的例子如下：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Any code inside the `<% %>` block is Java code and will be executed as such,
    just as with PHP.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在`<% %>`块内的代码都是Java代码，并且将像PHP一样被执行。
- en: When a JSP is requested, it will be processed by the JVM, and what will happen
    is something called a **servlet** will be generated. A servlet is a special Java
    class that knows how to respond to HTTP requests. But servlets can’t work alone.
    Instead, they have to be run as part of a **Java web app**, which runs in an **application
    server**. The application server manages the web app, handles its lifecycle events,
    and acts as the web server. When it sees a request come in for this JSP for the
    first time, it will generate a servlet class and then execute it (subsequent requests
    can just execute it immediately).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求JSP时，它将由JVM处理，会发生的事情是生成一个名为**servlet**的东西。servlet是一个特殊的Java类，知道如何响应HTTP请求。但servlet不能单独工作。相反，它们必须作为**Java
    Web应用程序**的一部分运行，该应用程序在**应用服务器**上运行。应用服务器管理Web应用程序，处理其生命周期事件，并充当Web服务器。当它第一次看到对这个JSP的请求时，它将生成一个servlet类，然后执行它（后续请求可以立即执行）。
- en: 'The servlet code for our JSP that would be generated might look something like
    this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的JSP生成的servlet代码可能看起来像这样：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There would likely be additional methods present to handle various events in
    the lifetime of a servlet, but that’s the basic idea, and you can see how the
    `_jspSevice()` method, which is the main one in a servlet, outputs the HTML from
    our JSP. Of course, more complex Java code in the JSP would result in more complex
    code in the servlet too.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能还有其他方法来处理servlet生命周期中的各种事件，但这是基本概念，你可以看到`_jspSevice()`方法，它是servlet中的主要方法，从我们的JSP中输出HTML。当然，JSP中的更复杂Java代码会导致servlet中的代码更复杂。
- en: You can write a servlet directly yourself too; you don’t have to start with
    JSPs. In fact, while JSPs can’t be used without servlets, servlets can definitely
    be used without JSPs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接编写servlet；你不必从JSP开始。事实上，虽然没有servlet，JSP无法使用，但servlet确实可以在没有JSP的情况下使用。
- en: Note that I have not included a complete example of all of this in the code
    bundle for two reasons.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有在代码包中包含所有这些的完整示例，原因有两个。
- en: First, there’s quite a lot more involved in setting up a working Java web app
    than this, starting with needing to install and run an app server (which is what
    manages the JSPs and servlets and the web app they’re a part of, and something
    called **Java Enterprise Edition** (or **JEE** for short). While Java itself comes
    with a robust standard library, JEE builds on top of that significantly, providing
    a lot of the higher-level functions modern web apps need. While Java comes with
    basic data structure and algorithms, JEE added JSPs, servlets, database access,
    and a whole host of other “advanced” facilities.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置一个可工作的Java Web应用远不止这些，从需要安装和运行应用服务器（它管理JSPs、servlets以及它们所属的Web应用，以及称为**Java企业版**（或简称**JEE**）的东西）开始。虽然Java本身带有强大的标准库，但JEE在此基础上进行了显著扩展，提供了现代Web应用所需的大量高级功能。虽然Java提供了基本的数据结构和算法，但JEE增加了JSPs、servlets、数据库访问以及一大堆其他“高级”功能。
- en: Second, I wanted to save space for the next section, which I did include a working
    example for since the topics of Spring and Spring Boot are arguably more important
    nowadays than being able to build a Java web app from scratch using JSPs and/or
    servlets and even JEE, and that’s what we’re looking at next.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我想为下一部分节省空间，我已经为Spring和Spring Boot的主题提供了一个工作示例，因为现在Spring和Spring Boot的话题可能比从头开始使用JSPs和/或servlets以及JEE构建Java
    Web应用更重要，这就是我们接下来要探讨的内容。
- en: Introducing Spring and Spring Boot
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Spring和Spring Boot
- en: '**Spring** is without question the single most popular third-party library
    available for Java. It supplies an absolutely monstrous list of features on top
    of Java: things such as security, streamlined database functionality, a high-level
    web app architecture, REST service construction and consumption, task scheduling,
    and so much more.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring** 无疑是Java中最受欢迎的第三方库。它为Java提供了极其庞大的功能列表：包括安全、简化的数据库功能、高级Web应用架构、REST服务构建和消费、任务调度等等。'
- en: What it’s perhaps best known for, though, is its **Dependency Injection**, or
    **DI**, framework. DI is the idea that rather than your code constructing objects
    of various types, it is better to have some higher-level entity *inject* them
    into your code. There are many reasons for doing this, but maybe the biggest is
    testing. If you have some code that builds a connection to a database and you
    then want to test the code, you might need to connect to a separate test database.
    Rather than having to build that into the code, you could instead have a test
    framework build the connection, knowing how to build it for the test database
    rather than the real database, and inject the connection into your code. That
    way, the code you test is identical regardless of which database you connect to.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它最著名的可能是其**依赖注入**（或简称**DI**）框架。DI的理念是，而不是您的代码构建各种类型的对象，更好的做法是让某个高级实体将它们注入到您的代码中。这样做有很多原因，但最大的可能是测试。如果您有一些代码用于建立数据库连接，然后您想测试这段代码，您可能需要连接到一个单独的测试数据库。而不是将这构建到代码中，您可以选择让测试框架建立连接，知道如何为测试数据库而不是真实数据库建立连接，并将连接注入到您的代码中。这样，您测试的代码无论连接到哪个数据库都是相同的。
- en: Spring became famous for this DI framework, but it grew massively after that,
    encompassing nearly anything you could do with Java. In fact, it’s so comprehensive
    now that a lot of people consider Spring to be the core of what Java is, JEE specifically.
    While Spring still needs JEE under the covers, when using Spring, you can all
    but ignore JEE if you wish, deferring to Spring’s functionality instead.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Spring因其DI框架而闻名，但在此之后它迅速发展，几乎包含了您可以用Java做的任何事情。事实上，现在它如此全面，以至于很多人认为Spring是Java的核心，尤其是JEE。虽然Spring在底层仍然需要JEE，但在使用Spring时，如果您愿意，几乎可以忽略JEE，转而使用Spring的功能。
- en: 'Building on top of Spring comes something called Spring Boot. In short, **Spring
    Boot** is a framework that helps you bootstrap (set up) and develop Spring-based
    Java apps, most commonly web apps. Spring Boot does this in the following ways:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring的基础上，出现了名为Spring Boot的东西。简而言之，**Spring Boot**是一个框架，它帮助您启动（设置）并开发基于Spring的Java应用，通常是Web应用。Spring
    Boot通过以下方式实现：
- en: '`.class` files). This simplifies the process of setting up and configuring
    Spring applications.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这简化了设置和配置Spring应用的过程。
- en: '**Standalone**: Spring Boot applications are standalone and can be run directly
    using Java, which makes it easier to build and test Spring applications.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立运行**：Spring Boot应用是独立的，可以直接使用Java运行，这使得构建和测试Spring应用变得更加容易。'
- en: '**Opinionated defaults**: Spring Boot comes with a set of opinionated defaults
    for quick project setup, while also offering options to override these settings
    for customization. This means you have to do less up-front configuration to make
    a Spring Boot app work, but you can override the defaults later as needs dictate.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认配置**：Spring Boot提供了一套默认配置，以便快速设置项目，同时也提供了覆盖这些设置进行自定义的选项。这意味着你不需要进行太多的前期配置就可以使Spring
    Boot应用程序工作，但你可以根据需要覆盖默认设置。'
- en: '**Embedded servers**: Spring Boot apps include the Tomcat, Jetty, or Undertow
    app server directly, so you don’t need to deploy your application to an app server.
    You get a runnable unit with Spring Boot that requires nothing aside from Java
    itself to work.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内嵌服务器**：Spring Boot应用程序直接包含Tomcat、Jetty或Undertow应用程序服务器，因此你不需要将应用程序部署到应用程序服务器。Spring
    Boot为你提供了一个可运行的单元，除了Java本身之外不需要任何其他东西来工作。'
- en: '**Wide range of features**: Out-of-the-box Spring Boot supports a wide range
    of data access, security, and cloud services, making it a versatile tool for a
    variety of applications.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能丰富**：开箱即用的Spring Boot支持广泛的数据访问、安全和云服务，使其成为各种应用的通用工具。'
- en: Let’s now build a simple Hello World web app with Spring Boot and see what’s
    involved.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用Spring Boot构建一个简单的Hello World Web应用程序，看看需要哪些步骤。
- en: A simple Spring Boot web app
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的Spring Boot Web应用程序
- en: The simplest way to start a Spring Boot app is to head on over to [https://start.spring.io](https://start.spring.io)
    and let someone else do the work for you! This is a site provided by the creators
    of Spring and Spring Boot that will generate a basic Spring Boot app for you.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 开始Spring Boot应用程序最简单的方法是访问[https://start.spring.io](https://start.spring.io)，让其他人为你做这项工作！这是一个由Spring和Spring
    Boot的创建者提供的网站，可以为你生成一个基本的Spring Boot应用程序。
- en: You can see this site in *Figure 7**.7*. If you want to try it yourself, select
    the options you see here (including adding the **Spring Web** dependency on the
    right, or this project won’t work!).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*图7.7*中看到这个网站。如果你想亲自尝试，选择你在这里看到的选项（包括在右侧添加**Spring Web**依赖项，否则该项目将无法工作！）。
- en: '![Figure 7.7: The Spring Initializr website with options for creating the example
    project](img/B18315_07_7.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：带有创建示例项目选项的Spring Initializr网站](img/B18315_07_7.jpg)'
- en: 'Figure 7.7: The Spring Initializr website with options for creating the example
    project'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：带有创建示例项目选项的Spring Initializr网站
- en: 'Once you click the `.zip` file that contains your starter project. Extract
    that archive, go to Command Prompt in the directory (which would be named `demo`
    if you entered exactly what is shown in the screenshot), and execute this command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击包含你的启动项目的`.zip`文件。解压该存档，进入目录中的命令提示符（如果你输入了截图中所显示的确切内容，该目录将被命名为`demo`），然后执行以下命令：
- en: '[PRE36]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You’ll see a ton of stuff fly by and, as long as it doesn’t end with an error
    of some sort, it doesn’t really matter. But, to give you some idea… Maven, which
    is what the `mvnw` command represents, is a Java build tool. It knows how to build
    your project into a runnable unit. You see, real Java apps are rarely just a single
    `.java` file to be compiled. Usually, there are all sorts of third-party libraries
    needed, lots of source files to compile, and other files that must be included
    in various ways. Rather than figure out how to do all of that yourself, as long
    as you follow a standard structure and provide some configuration files, then
    Maven will know how to build your project, get all the dependencies for you, and
    handle all those icky details.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到很多东西快速闪过，只要它不以某种错误结束，实际上并不重要。但是，为了给你一些概念……`mvnw`命令代表的是Maven，这是一个Java构建工具。它知道如何将你的项目构建成一个可运行的单元。你知道，真正的Java应用程序很少只有一个需要编译的`.java`文件。通常，需要各种第三方库，大量的源文件需要编译，以及其他必须以各种方式包含的文件。与其自己弄清楚如何做所有这些，只要遵循标准结构并提供一些配置文件，那么Maven就会知道如何构建你的项目，为你获取所有依赖项，并处理所有那些令人讨厌的细节。
- en: Usually, the command to use for Maven is just plain `mvn`. But, for that to
    work, Maven must already be installed and in your path. To save from having to
    do that yourself, `mvnw` is a Maven *wrapper*. These files know how to use Maven
    without you first having to install it. When you first run that command, the wrapper
    will download the necessary Maven files, everything Maven needs to run, and then
    it will begin building the project, downloading all of its dependencies along
    the way.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用于Maven的命令只是简单的`mvn`。但是，为了使其工作，Maven必须已经安装并且在你的路径中。为了避免自己动手做这件事，`mvnw`是一个Maven
    *包装器*。这些文件知道如何使用Maven，而无需你首先安装它。当你第一次运行该命令时，包装器将下载必要的Maven文件，所有Maven运行所需的一切，然后它将开始构建项目，在过程中下载所有依赖项。
- en: At the end, it will run the project, which starts the server that Spring Boot
    provides. And you can then access it in your browser at [http://localhost:8080](http://localhost:8080).
    However, if you do that right away, you’ll get a “Whitelabel Error Page” screen.
    That’s because we haven’t supplied any code to handle the default route, and Spring
    Boot isn’t going to do that for us!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将运行项目，启动Spring Boot提供的服务器。然后你可以在浏览器中访问它，地址为[http://localhost:8080](http://localhost:8080)。然而，如果你立即这样做，你会看到一个“Whitelabel
    Error Page”屏幕。这是因为我们没有提供任何代码来处理默认路由，Spring Boot不会为我们做这件事！
- en: 'To fix it, we need to add a file named `HelloController.java` in the `src/main/java/com/example/demo`
    directory under the parent project directory and put the following content into
    it:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复它，我们需要在父项目目录下的`src/main/java/com/example/demo`目录中添加一个名为`HelloController.java`的文件，并将以下内容放入其中：
- en: '[PRE37]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a controller class that handles requests to specified URLs. In this
    case, the `@GetMapping("/")` line tells Spring Boot to execute this method when
    a URL with nothing after the domain name comes in (where `localhost` is our domain
    name).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个处理指定URL请求的控制器类。在这种情况下，`@GetMapping("/")`行告诉Spring Boot在接收到域名之后没有其他内容的URL时执行此方法（其中`localhost`是我们的域名）。
- en: This statement, plus the `@RestController` line, are what are called `@RestController`
    annotation tells Spring Boot that this class handles HTTP requests (it’s generally
    meant to be used to build REST APIs, but given that a simple `GET` request to
    a URL is still a RESTful operation, it counts for this use case), and Spring Boot
    will maintain a mapping between URLs and controllers and hand requests off to
    the appropriate controllers when they come in.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明，加上`@RestController`行，就是所谓的`@RestController`注解告诉Spring Boot这个类处理HTTP请求（它通常用于构建REST
    API，但鉴于对URL的简单`GET`请求仍然是一种RESTful操作，它适用于这个用例），Spring Boot将维护URL和控制器之间的映射，并在请求到来时将请求传递给适当的控制器。
- en: The method annotated with the `@GetMapping` annotation then executes and returns
    our greeting string – nothing fancy there at all. In fact, this is about as simple
    as a Spring Boot app gets, but it demonstrates the basic ideas well enough.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 被`@GetMapping`注解的方法随后执行并返回我们的问候字符串——这里没有任何花哨的地方。实际上，这几乎就是Spring Boot应用能变得这么简单的原因，但它很好地展示了基本思想。
- en: Spring Boot, as well as Spring and Java itself, is so broad and does so much
    that you can’t hope to learn it all in one go; you have to introduce new concepts
    as they’re needed and learn as you go, which you’ll remember is one of the big
    core requirements to being a web developer!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot，以及Spring和Java本身，功能如此广泛，可以做很多事情，以至于你不可能一次性全部学会；你必须随着需要引入新概念，并在过程中学习，这一点你可能会记得，是成为一名网络开发者的一个重要核心要求！
- en: 'Now that you’ve seen some PHP and Java, let’s have a look at another choice
    for server-side coding, this time from our friends at Microsoft: .NET.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些PHP和Java，让我们来看看另一种服务器端编码的选择，这次来自我们的朋友微软：.NET。
- en: Introducing .NET
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍.NET
- en: While Java largely rules the enterprise space, it’s not the only popular choice
    there. Microsoft has a competitor to it named .NET. As with Java, it’s a large,
    sprawling platform that covers pretty much all the bases in terms of what developers
    need. It can handle database access and network communications and can be used
    to build RESTful APIs as well as other server-based facilities. It can be used
    in **artificial intelligence** (**AI**) applications, and it comes with support
    for several different languages via the **Common Language Runtime** or **CLR**,
    which is conceptually like Java’s JVM.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Java 在企业领域占据主导地位，但并非唯一的选择。微软有一个名为 .NET 的竞争对手。与 Java 类似，它是一个庞大而分散的平台，几乎涵盖了开发者所需的所有基础功能。它可以处理数据库访问和网络通信，并且可以用来构建
    RESTful API 以及其他基于服务器的设施。它可以用于 **人工智能** (**AI**) 应用，并且通过 **公共语言运行时** (CLR) 或 **CLR**
    提供对几种不同语言的支持，这在概念上类似于 Java 的 JVM。
- en: And like Java, while .NET is definitely used for desktop development – more
    so than Java, in fact, is – it has largely become the domain of the server and
    is the primary supported language/platform in Microsoft’s Azure cloud. And while
    .NET began primarily as a Windows technology, it is currently also officially
    supported on Linux and other operating systems.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Java 一样，虽然 .NET 确实用于桌面开发——实际上比 Java 更多——但它已经主要成为服务器领域的一部分，并且是微软 Azure 云中的主要支持语言/平台。而且尽管
    .NET 最初主要是 Windows 技术，但目前它也正式支持 Linux 和其他操作系统。
- en: .NET is often used in conjunction with Microsoft’s Visual Studio IDE. In fact,
    in practice, you probably won’t find that many .NET developers who don’t use it!
    But at the end of the day, it’s not required since .NET provides an SDK like Java
    that you can work with exclusively from the command line, and for our purposes,
    here we won’t be using Visual Studio.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 通常与微软的 Visual Studio IDE 一起使用。实际上，在实践中，你可能找不到不使用它的 .NET 开发者！但最终，它不是必需的，因为
    .NET 提供了一个类似于 Java 的 SDK，你可以仅从命令行与之交互，并且就我们的目的而言，这里我们不会使用 Visual Studio。
- en: Generating a Hello World web app
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 Hello World 网页应用
- en: 'Assuming you have the .NET SDK installed and working, it makes it even easier
    than other options to build a Hello World application because it’s built right
    into .NET! All you need to do is create a directory for your project and execute
    this command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装并配置了 .NET SDK，它使得构建 Hello World 应用程序比其他选项更容易，因为它直接内置在 .NET 中！你所需做的只是为你的项目创建一个目录并执行此命令：
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You’ll wind up with a new directory named `HelloWorld`, in which will be a
    fully functional Hello World application! To run it, navigate to that new directory
    and execute this command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个名为 `HelloWorld` 的新目录，其中将包含一个完全功能性的 Hello World 应用程序！要运行它，导航到该新目录并执行以下命令：
- en: '[PRE39]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will, of course, find such a project already built in the `ch-07/dotnet/HelloWorld`
    directory, but it’s a good exercise to create and run it yourself from scratch.
    And once you do, you can access the page at http://localhost:5262.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然会在 `ch-07/dotnet/HelloWorld` 目录中找到一个已经构建好的项目，但自己从头创建和运行它是一个很好的练习。一旦你做到了，你就可以通过
    http://localhost:5262 访问该页面。
- en: 'You’ll note from looking at *Figure 7**.8* that it has a little more content
    than the simple “Hello, World!” page as in the previous examples (which is why
    I’m showing it here while I didn’t show the others). Unfortunately, as a result
    of that, there is a lot more code behind this “simple” example than either the
    PHP or Java versions – too much to go into everything:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从查看 *图 7.8* 可以看出，它比前例中的简单“Hello, World!”页面内容更多（这就是为什么我在这里展示它，而未展示其他页面）。不幸的是，因此，这个“简单”示例背后的代码比
    PHP 或 Java 版本都要多——太多以至于无法一一介绍：
- en: '![Figure 7.8: The .NET version of the Hello World app](img/B18315_07_8.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8：Hello World 应用的 .NET 版本](img/B18315_07_8.jpg)'
- en: 'Figure 7.8: The .NET version of the Hello World app'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：Hello World 应用的 .NET 版本
- en: But, to not leave you completely with nothing, the three main files involved
    are probably `Program.cs`, `HomeController.cs`, and `Index.cshtml` (there are
    many other files created by .NET, but those are kind of the key ones). These files
    are what we’ll be looking at in the next three subsections.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了避免让你一无所获，涉及的主要三个文件可能是 `Program.cs`、`HomeController.cs` 和 `Index.cshtml`（.NET
    还会创建许多其他文件，但那些是关键文件）。这些文件是我们将在接下来的三个小节中要查看的内容。
- en: The `.cs` extension indicates these are C# source files, where C# is one of
    the languages you can use in .NET, and by far the most used one at that (nearly
    to the exclusion of all others, I’d even say). By extension, `.cshtml` indicates
    an HTML file that has C# code embedded in it, much like a `.php` file can have
    PHP code embedded in it.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`.cs` 扩展名表示这些是 C# 源文件，其中 C# 是你可以在 .NET 中使用的语言之一，而且是最常用的一个（几乎排除了所有其他语言，我甚至可以说）。通过扩展，`.cshtml`
    表示一个嵌入 C# 代码的 HTML 文件，就像 `.php` 文件可以嵌入 PHP 代码一样。'
- en: The server starting point
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器启动点
- en: 'Here’s the `Program.cs` file, which is essentially the starting point that
    sets up the server:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Program.cs` 文件，它是设置服务器的起点：
- en: '[PRE40]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you generate this app yourself, your version may look slightly different
    depending on what version of the SDK you have, but it should look substantially
    the same. From it, you can tell that C# looks a lot like all the languages you’ve
    seen, which is to be expected since they all are based on the C language’s syntax
    and structure (there are huge differences between, say, JS and C#, but they look
    similar enough and share enough concepts that you can probably grasp what’s going
    on even if you’ve never seen a given C-based language before).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己生成此应用程序，你的版本可能因 SDK 的版本而略有不同，但应该大体相同。从它可以看出，C# 看起来与所有你见过的语言都很像，这是可以预料的，因为它们都基于
    C 语言的语法和结构（例如，JS 和 C# 之间有很大的差异，但它们看起来足够相似，并且共享足够的概念，即使你以前从未见过基于 C 的特定语言，你也能理解正在发生的事情）。
- en: Similar to making a server with Node and Express, you construct an `app` object,
    in this case using something called a builder, which is code that knows how to
    construct an `app` object for you (I know, obvious, right?). After that, middleware
    is added for doing things such as handling errors (`UserExceptionHandler`), serving
    static files (`UseStaticFiles`), and setting up routes to controllers (`MapControllerRoute`).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 Node 和 Express 构建服务器类似，你构建一个 `app` 对象，在这种情况下使用一个名为构建器的工具，这是一段知道如何为你构建 `app`
    对象的代码（我知道，很明显，对吧？）。之后，添加中间件以执行诸如处理错误（`UserExceptionHandler`）、服务静态文件（`UseStaticFiles`）以及设置路由到控制器（`MapControllerRoute`）等任务。
- en: The controller
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制器
- en: 'A controller is a piece of code that handles a given request, and that’s where
    the `HomeController.cs` file comes in, as it handles our main “home” route:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是一段处理特定请求的代码，而 `HomeController.cs` 文件就在这里发挥作用，因为它处理我们的主要“主页”路由：
- en: '[PRE41]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is part of an **MVC** application, which stands for **Model-View-Controller**.
    This is an application architecture pattern – a way to structure applications,
    in other words – that tries to separate out the view (usually in the form of an
    HTML file or something similar) from the model (which means the data, in essence)
    from the controller (which binds the other two together). The three are usually
    implemented as separate units of code as is the case here, but they work together
    to generate a response for a client on a given URL. The reason for doing this
    is that if you want to change, say, your database, you can do so without touching
    the view or the controller layers; just change the model layer as needed.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是一个 **MVC** 应用程序，代表 **模型-视图-控制器**。这是一种应用程序架构模式——换句话说，一种组织应用程序的方式——它试图将视图（通常是
    HTML 文件或类似的东西）从模型（本质上意味着数据）和控制器（将其他两个绑定在一起）中分离出来。这三个通常作为独立的代码单元实现，就像这里的情况一样，但它们一起工作，为给定
    URL 的客户端生成响应。这样做的原因是，如果你想更改，比如说，你的数据库，你可以这样做而不必触及视图或控制器层；只需按需更改模型层即可。
- en: 'Note that in this example, there actually is no model layer, which is okay:
    you can still have a more-or-less MVC architecture even if the view or model is
    left out (the controller will always be present, and it’s rare to not have a view
    layer, but if you don’t need data then you don’t need a model layer, which really
    makes it an MV architecture, but we tend to call it MVC anyway, I guess just because
    developers can be weird sometimes!).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，实际上并没有模型层，这是可以的：即使省略了视图或模型，你仍然可以有一个更多或更少的 MVC 架构（控制器始终存在，而且通常不会没有视图层，但如果你不需要数据，那么你不需要模型层，这实际上使其成为一个
    MV 架构，但我们仍然倾向于称之为 MVC，我想只是因为开发者有时会很奇怪！）。
- en: The view
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: 'Finally, a view is generated by the `Index.cshtml` file:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由 `Index.cshtml` 文件生成视图：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And it’s the simplest one of the three! Like PHP and JSP, it’s a template in
    essence, where the `${ }` blocks represent C# code to be executed when rendered.
    The rest is just plain HTML.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这是三者中最简单的一个！就像PHP和JSP一样，本质上它是一个模板，其中`${ }`块代表在渲染时执行的C#代码。其余的都是纯HTML。
- en: 'PHP, Java, and .NET aren’t the only choices, though. Another you might consider
    is one you saw in earlier chapters: Python. Let’s see how Python can be used to
    build web apps next.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PHP、Java 和 .NET 不是唯一的选择。你还可以考虑在前面章节中看到的一种：Python。让我们看看Python如何被用来构建Web应用程序。
- en: Using Python web app frameworks
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python Web应用程序框架
- en: In [*Chapter 5*](B18315_05.xhtml#_idTextAnchor129), you met Python, and we talked
    about how it can be used in the context of DevOps. That’s not the only place Python
    can be used, though. Of course, you can write standalone Python apps for all sorts
    of purposes too. But beyond that, Python can be used as the backend platform for
    your websites and web apps as well.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18315_05.xhtml#_idTextAnchor129)中，你遇到了Python，我们讨论了它如何在DevOps环境中被使用。然而，Python的应用场景远不止于此。当然，你也可以为各种目的编写独立的Python应用程序。但除此之外，Python还可以作为你的网站和Web应用程序的后端平台。
- en: As you’ve seen, when working with Node to develop server-side code, developers
    have two main paths. One is to build the server code solely with Node’s built-in
    capabilities, which can be suitable for smaller projects. However, for larger
    projects, most developers prefer using a library or framework such as Express
    to enhance their development process.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当使用Node开发服务器端代码时，开发者有两个主要路径。一个是仅使用Node内置功能构建服务器代码，这可能适合小型项目。然而，对于大型项目，大多数开发者更喜欢使用库或框架，如Express来增强他们的开发过程。
- en: Similarly, Python offers all the essentials for building a server from scratch.
    But as with Node, many developers opt for a more comprehensive solution in the
    form of a framework to avoid writing a lot of repetitive, foundational code, one
    of those being Django.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Python提供了从头开始构建服务器的所有基本要素。但与Node一样，许多开发者选择使用更全面的解决方案，即框架，以避免编写大量的重复性基础代码，其中之一就是Django。
- en: Django
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django
- en: '**Django** is a framework designed to streamline development; Django aims to
    ease the development load by providing pre-built defaults for various functions,
    significantly cutting down on the amount of basic code developers need to write.
    Django is known for being like Angular in the sense that it tries to include most,
    if not all, of what a typical developer will need to get the job done.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django**是一个旨在简化开发的框架；Django通过提供各种预构建的默认值来减轻开发负担，显著减少了开发者需要编写的基代码量。Django以其类似于Angular的方式而闻名，即它试图包含大多数，如果不是所有，典型开发者完成工作所需的功能。'
- en: 'To give you a brief view of what a Django app might look like, you would need
    to start by creating a directory to host your project (which you’ll find in the
    download bundle under `ch-07/python`) and installing Django itself:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你对Django应用程序可能的样子有一个简要的了解，你需要首先创建一个目录来托管你的项目（你可以在下载包中的`ch-07/python`找到它），然后安装Django本身：
- en: '[PRE43]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the Python world, `pip` plays the same basic role as `npm` does in the Node
    world, installing and dealing with packages, and this specific command installs
    the Django package globally, meaning it can be used from anywhere. After that,
    we can use commands that Django provides to create a new Django project:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的世界里，`pip`在Node世界中所扮演的基本角色与`npm`类似，负责安装和处理包，这个特定的命令全局安装Django包，意味着它可以从任何地方使用。之后，我们可以使用Django提供的命令来创建一个新的Django项目：
- en: '[PRE44]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You’ll wind up with a `helloworld_project` directory in whichever directory
    you’re in when you execute it, which you will then navigate to for the next steps.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在执行时，你会在当前目录下得到一个`helloworld_project`目录，然后你需要导航到该目录进行下一步操作。
- en: 'With Django, a single project can host multiple apps, but we just need one
    right now, and there’s a command to create that too:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django，一个项目可以托管多个应用程序，但我们现在只需要一个，而且也有一个命令可以创建它：
- en: '[PRE45]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `manage.py` file is a script provided by Django for performing all sorts
    of setup and management tasks on a project and the apps under it. After executing
    that command, you’ll find a `hello` directory created inside the `helloworld_project`
    directory.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`manage.py`文件是Django提供的一个脚本，用于在项目及其应用程序上执行各种设置和管理任务。执行该命令后，你会在`helloworld_project`目录内找到一个名为`hello`的目录。'
- en: 'The next step is to create a view, which is conceptually like a route in an
    Express app: something that will respond to requests to a specific URL. To do
    this, go into the `hello` directory, open the `views.py` file that you’ll find
    has been created there, and add this content below the comment line:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个视图，这在概念上类似于 Express 应用中的路由：它将响应到特定 URL 的请求。为此，进入 `hello` 目录，打开那里创建的
    `views.py` 文件，并在注释行下面添加以下内容：
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This provides a function that will ultimately execute when we make a request
    to a configured URL and will return a simple text response.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个函数，当我们在配置的 URL 上发出请求时，它将执行并返回一个简单的文本响应。
- en: Next, you need to tell Django to use this view. This requires two steps.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要告诉 Django 使用这个视图。这需要两个步骤。
- en: 'First, in the `helloworld_project` directory, you find that a directory was
    created automatically that is also named `helloworld_project`. I know – the names
    are confusing, but it’s the way Django does it: you get a directory with the same
    name as the project directory it’s in. Inside that inner `helloworld_project`
    directory, open the `urls.py` file. In it, you’ll find some instructional comments
    and a few lines of code. Two things need to be done here. First, add a new import
    under the existing one:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `helloworld_project` 目录中，你会发现一个自动创建的目录，其名称也是 `helloworld_project`。我知道——名字很混乱，但这就是
    Django 的做法：你得到一个与项目目录相同的名称的目录。在这个内部 `helloworld_project` 目录中，打开 `urls.py` 文件。在里面，你会找到一些说明性注释和一些代码行。这里需要做两件事。首先，在现有的导入下面添加一个新的导入：
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That adds a package named `include` that we need in order to do the rest of
    what’s to come.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了一个名为 `include` 的包，这是我们完成后续操作所必需的。
- en: 'Then, on the line that defines the `urlpatterns` array, add a new entry after
    the `/admin` one that’s already there:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在定义 `urlpatterns` 数组的行中，在已经存在的 `/admin` 之后添加一个新条目：
- en: '[PRE48]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This essentially sets up a route to the `hello` app itself and tells Django
    to look for routes in it as defined in its own `hello.urls` file.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上设置了一个到 `hello` 应用的路由，并告诉 Django 在其 `hello.urls` 文件中查找路由。
- en: 'And that file is the final step to make everything work. You’ll need to create
    a `urls.py` file in the `hello` directory with the following content:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 那个文件是使一切工作的最后一步。你需要在 `hello` 目录下创建一个 `urls.py` 文件，内容如下：
- en: '[PRE49]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That sets up a route in the `hello` app itself to the view we created.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `hello` 应用本身中设置了一个路由到我们创建的视图。
- en: 'At this point, your first Django app should be ready! Conveniently, Django
    includes a built-in web server to test with, and you can start it up now to try
    your app out:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的第一个 Django 应用应该已经准备好了！方便的是，Django 包含一个内置的 Web 服务器用于测试，你现在可以启动它来尝试你的应用：
- en: '[PRE50]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You should find that your app responds to requests to [http://localhost:8000/hello](http://localhost:8000/hello).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会发现你的应用可以响应到 [http://localhost:8000/hello](http://localhost:8000/hello) 的请求。
- en: For such a simple example, it may seem like there’s a lot involved with Django,
    but as an app gets more complex, it starts to pull its weight much more by virtue
    of the advanced functionality it provides, which while it can require this type
    of setup too, it tends to have a much better **return on investment** (**ROI**),
    meaning the benefit is worth the cost.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的示例，可能看起来 Django 涉及的内容很多，但随着应用变得更加复杂，它通过提供的高级功能开始发挥更大的作用，尽管它也可能需要这种类型的设置，但它往往有更好的**投资回报率**（**ROI**），这意味着好处值得成本。
- en: But if you find Django not to your liking, another popular framework named Flask
    might be more so.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你觉得 Django 不适合你，另一个流行的框架 Flask 可能更适合。
- en: Flask
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask
- en: 'With **Flask**, another popular Python web framework like Django, the Hello
    World example is a lot simpler, and it begins with installing Flask:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Django 一样，**Flask** 是另一个流行的 Python Web 框架，其 Hello World 示例要简单得多，它从安装 Flask
    开始：
- en: '[PRE51]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, create a directory for your project (which you can name anything you
    like), and in it, create an `app.py` file like so:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为你的项目创建一个目录（你可以取任何你喜欢的名字），并在其中创建一个 `app.py` 文件，如下所示：
- en: '[PRE52]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And guess what? You’re actually done at this point! You can now run the development
    server that, like Django, Flask provides:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？实际上，你现在就已经完成了！你现在可以运行 Flask 提供的开发服务器，就像 Django 一样：
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: And then, you can access the app at [http://localhost:5000](http://localhost:5000).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过 [http://localhost:5000](http://localhost:5000) 访问该应用。
- en: With Flask clearly being much simpler, why would anyone in their right mind
    choose Django?!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Flask 要简单得多，为什么任何理智的人会选择 Django 呢？！
- en: 'The answer is that they serve different purposes:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是它们服务于不同的目的：
- en: Django is attempting to be as close to all-encompassing as possible. It has
    facilities for working with databases, security, a built-in administration app,
    functions for dealing with sessions and authentication, a templating engine, advanced
    URL routing, and a lot more.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 正在努力成为尽可能全面的存在。它提供了与数据库、安全、内置管理应用、处理会话和认证的功能、模板引擎、高级 URL 路由以及更多。
- en: Flask, on the other hand, is what’s known as a **micro-framework**. Flask is
    designed to be more lightweight and simply not do as much as Django, which requires
    you to add other libraries to the mix as you see fit.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，Flask 是所谓的 **微框架**。Flask 被设计得更加轻量级，并且简单地不做 Django 那么多事情，这意味着你需要根据需要添加其他库。
- en: 'Both have their pros and cons, and it’s roughly the same situation as comparing
    React or Vue to Angular: the first two simply do a lot less out of the box, by
    design, but there is arguably more flexibility in a smaller framework since you
    get to choose how specific features are provided.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 它们各有优缺点，这大概就像比较 React 或 Vue 与 Angular 的情况：前两者设计上功能较少，但小框架的灵活性更高，因为你可以选择如何提供特定功能。
- en: Reviewing the roadmap
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查路线图
- en: 'Well, that’s a few more knocked off, isn’t it? In *Figure 7**.9*, you can see
    the updated web developer roadmap:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这又少了一些，不是吗？在 *图 7**.9* 中，你可以看到更新的 Web 开发者路线图：
- en: '![Figure 7.9: The roadmap with a few more boxes filled in](img/B18315_07_9.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9：填入更多框的路线图](img/B18315_07_9.jpg)'
- en: 'Figure 7.9: The roadmap with a few more boxes filled in'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：填入更多框的路线图
- en: With this chapter, you uncovered the **Databases**, **Java and Spring Boot**,
    **PHP**, and **.NET** blocks. And would you look at that – the entire backend
    section is now fully revealed!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你揭开了 **数据库**、**Java 和 Spring Boot**、**PHP** 和 **.NET** 的模块。看看吧——整个后端部分现在已经完全揭露了！
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about a variety of server-side technologies, starting
    with databases. You learned the difference between relational databases and NoSQL
    databases, and in the process, you got an introduction to the SQL language. You
    then learned about exposing that data through a REST interface, probably the most
    common way web APIs are provided these days (oh, and you learned what a web API
    is too, didn’t you?).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了许多服务器端技术，从数据库开始。你学习了关系型数据库和非关系型数据库之间的区别，在这个过程中，你对 SQL 语言也有了一定的了解。然后，你学习了如何通过
    REST 接口公开这些数据，这可能是目前提供 Web API 最常见的方式（哦，顺便说一下，你也学习了什么是 Web API，不是吗？）。
- en: After that, you got a look at some server-side technologies for building server-side
    code, including Java and Spring Boot, PHP, .NET, and some Python web frameworks
    such as Django and Flash. You sampled code for all of them to give you an idea
    of what might be involved if you choose them, and we talked a bit about the decision
    points that go into choosing one versus another – and you learned that in large
    part, it comes down to personal preference and what you have the most experience
    working with!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你看到了一些用于构建服务器端代码的服务器端技术，包括 Java 和 Spring Boot、PHP、.NET 以及一些 Python Web 框架，如
    Django 和 Flask。我们为它们都提供了代码示例，以便你了解如果你选择它们可能会涉及什么，我们还谈到了在选择一个而不是另一个时需要考虑的决策点——你了解到在很大程度上，这取决于个人偏好以及你最有经验的领域！
- en: In the next chapter, we’re going to in a sense close out the technical portion
    of this book and look at some alternate approaches to coding, in some cases some
    cutting-edge technologies that attempt to make web development much less about
    development. This includes things such as AI, **content management systems** (**CMS**),
    and other so-called “no-code” alternatives.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从某种意义上结束这本书的技术部分，并探讨一些替代的编码方法，在某些情况下，是一些试图使 Web 开发减少开发的工作的尖端技术。这包括人工智能、**内容管理系统**（**CMS**）和其他所谓的“无代码”替代方案。
