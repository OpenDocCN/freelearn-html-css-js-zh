- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From Front to Back – More on Backend Tools and Technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we focused primarily on the frontend. In this chapter,
    we’ll jump back to the backend side of the fence and look at some other server-side
    technologies and concepts. A full-fledged website or web app will rarely be only
    a client – it will nearly always require some sort of server to interact with
    – so, being full stack and understanding how both sides fit together is beneficial
    to being a web developer even if you ultimately decide to focus on one side or
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at what is perhaps the most important server-side
    concept: data. You’ll learn how data is stored and accessed, and you’ll understand
    the basic operations that can be performed on data. You’ll see multiple ways of
    storing data, and then you’ll learn how to build a facility that clients can use
    to access that data.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, understanding how to work with data should obviously be important
    since without data, a website is likely to not be of all that much use, but knowing
    how to expose that data to clients in a consistent way (where *clients* in this
    context most often will mean a browser-based application) is also important to
    understand since it allows not only your own app or website to use the data but
    potentially others in their own way, which is a nice bit of flexibility to be
    able to offer.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also get a look at a couple of different technologies for building server-side
    code, in addition to Node, which you’ve seen already. This will include Java,
    PHP, .NET, and even some Python options. It’s important to know what the various
    options are so that you can make an informed decision about which is most appropriate
    when building your server-side code (and you may find that the decision in large
    part comes down to personal preference and pre-existing knowledge, which oftentimes
    is fine).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to the heart of the matter – data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building web APIs with REST, Node, and Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going back to the future – SSR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PHP on the server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building with Java and Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python web app frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, you will want the code download bundle for this book, along with the
    code found in the `ch-07` directory specifically.
  prefs: []
  type: TYPE_NORMAL
- en: But specifically for this chapter, you’ll need to install a tool called Postman,
    which we’ll use for exercising our backend code later. Though at the time of writing
    you can download the tool without signing up, you’ll most likely want an account
    either way since it provides expanded functionality. So, go to [https://www.postman.com](https://www.postman.com),
    sign up, and download the Postman desktop app. The app is a typical desktop app
    for whichever operating system you’re using, so you shouldn’t have much trouble
    getting it installed.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to have the .NET SDK installed, which you can get at [https://dotnet.microsoft.com](https://dotnet.microsoft.com).
    This is a platform Microsoft provides for developing all sorts of apps, both Windows
    native and web apps. This again is a standard installer, so you shouldn’t have
    too much trouble – just grab the latest version available. Once you install it,
    go to Command Prompt and execute the `dotnet --version` command to confirm it’s
    ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you’ll next need to install the latest Java JDK, which you can get
    here: [https://www.oracle.com/java/technologies/downloads](https://www.oracle.com/java/technologies/downloads).
    Java is one of the most popular programming languages and platforms in use today,
    and we’ll take a look at it later. The version shouldn’t matter for our purposes
    here, so just grab the latest (21 as of this writing). Once installed, head to
    Command Prompt and ensure that `java -–version` returns you the correct version.
    Note that if you run into any issues with either the JDK or the .NET SDK not working,
    you can find installation help on their respective websites.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to the heart of the matter – data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most websites or web apps require data of some sort to do what they’re designed
    to do. That’s not exactly a revelatory statement, of course. eBay wouldn’t work
    if it didn’t have data available to display auctions. Google wouldn’t be able
    to do searches without (an insane amount of) data. And CNN wouldn’t be able to
    show the latest news headlines without data to back it up.
  prefs: []
  type: TYPE_NORMAL
- en: But how does that data get stored, and how does it get used?
  prefs: []
  type: TYPE_NORMAL
- en: So far, everything you’ve seen has been more or less static, meaning it doesn’t
    change. A page is what it is when you create it, and it will always be that. Oh,
    there may be some minor dynamic interactions – things such as buttons that highlight
    when you hover your mouse over them – but that’s not dynamic content such as those
    websites I named produce. That can only be done with data.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of ways to store data that websites can work with. Perhaps the
    simplest form is to store it as plain text files on the server. Those files can
    be read – perhaps in Node-based code, for example – and their contents can be
    used to create a dynamic response at the time it’s requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, that’s what we’re talking about here: creating responses dynamically
    on the server when requested by a client (usually a web browser) and returning
    them for display to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While plain text files can work, the more common method is some form of **database**.
    A database is, usually, a piece of software running on the server, separate from
    your web server software and separate from your own application code, where data
    is stored and which can respond to requests for that data (or for writing data
    to it). While it’s possible in some cases for a web browser to access such database
    software directly, it’s far more common to have some server-side code that does
    so and then uses the data to produce a response. This is more common for no other
    reason than security: presumably, your own code is protected against misuse of
    the database, whereas just giving users direct access to it will most likely lack
    such protection.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several different types of databases, but the two most relevant to
    you as a budding web developer are **relational databases** and **NoSQL databases**.
    Let’s talk about relational databases first.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Relational databases conceptually look a lot like spreadsheets – say, Microsoft
    Excel. In a spreadsheet, you have rows and columns. Where they intersect, you
    have a cell, and in a cell, you usually have some data. In an Excel spreadsheet,
    you can also have multiple sheets, often to store different types of data. *Figure
    7**.1* illustrates these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: An Excel spreadsheet, with multiple sheets shown to mimic a database
    and tables](img/B18315_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: An Excel spreadsheet, with multiple sheets shown to mimic a database
    and tables'
  prefs: []
  type: TYPE_NORMAL
- en: If you already understand the basic structure of a spreadsheet, then to understand
    a relational database, you really just have to change some words!
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire spreadsheet in Excel is conceptually what we call a *database*,
    and each sheet in a spreadsheet is called a *table* in that database. Within the
    database software, you can normally have multiple databases if you need to. This
    can be confusing, so to disambiguate, we tend to say database *server* versus
    plain *database*:'
  prefs: []
  type: TYPE_NORMAL
- en: A database *server* refers to the software that runs on the server (names such
    as Oracle MySQL, PostgreSQL, and MS SQL Server) and which contains databases and
    provides the basic functionality to work with the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term *database* – different from the aforementioned database *server* –
    refers to the actual collection of tables for a given purpose, perhaps one database
    per website hosted on the server, but all living in the database server software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a database table, you define what columns there are – what type of data you
    want to store about each row of data in the table – and then you have the rows
    of data itself. If you think of each row of data – which we often call a **record**
    – as being some sort of entity, say a person or a banking account, then the columns
    effectively describe the pieces of information you want to store about each.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say you want to create a database table to store some information
    about people. We’ll be exceptionally uncreative here and say that we’ll name the
    table `People`. Maybe for each row of data – which will be a person entity – you
    want to store their first name, last name, and age. As a result, you might wind
    up with a database table that looks like *Figure 7**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: The People table’s structure](img/B18315_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The People table’s structure'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, you probably would never store a person’s age because that obviously
    won’t be correct a year later. Instead, you would most likely store their birthdate
    and calculate their age from that when needed. But here, I’m trying to keep this
    example as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each column, you have to tell the database what kind of data will be stored
    in it. Every database specifies the type of data in each column differently, but
    they all relate to what you know already. Here, you can see that `first_name`
    and `last_name` are strings (which are of the data type `TEXT` in this particular
    database), and `age` is a number (of the data type `INTEGER`). Another bit of
    terminology to change here is that we usually call a single data element a field
    in a database rather than a cell as in a spreadsheet. But it’s again the same
    basic thing: it’s the value in a row that corresponds to a given column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that basic table structure defined, we can store some rows of data in
    it; maybe this data (and yes, those were their actual ages when the series began
    – I did the research!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But how do we actually store that data? That’s where the concept of Structured
    Query Language comes in, which is what we’re discussing next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Structured Query Language** (**SQL**) is a special language used to interact
    with relational databases. It allows us to request data using a form that is generally
    easy to understand, attempting to look less like a programming language than something
    like JS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To jump right in with an example, let’s say you wanted to get all three records
    from our `People` table. The SQL statement for that would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! What you’ll get is a list of records, each containing the first
    name, last name, and age of each person. This shows the most basic type of SQL
    statement: a `SELECT` statement. We tell it what data we want from each record
    (in this case, the asterisk means all), and then we have to state what table to
    get the records from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted just the last names, we would execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we wanted just the last name and age, we could execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want just the people who are over 40 years old? That’s where the
    `WHERE` clause comes into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll get just a single record – Montgomery Scott – since that’s the only
    record with a value for `age` greater than `40`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `SELECT` statements such as this allow for other capabilities, including
    sorting the returned data, filtering it in various ways, and lots of functions
    that can be used to manipulate the returned data (for example, to uppercase the
    names, maybe). But the basic ability to retrieve data is ultimately what it’s
    all about.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, retrieving data is great, but what if we want to add a person?
    This can be done through SQL as well, using an `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have to provide the name of the table to insert the data into, then a list
    of fields to insert, and then the value of each field. After executing that statement,
    we’ll have four rows of data in the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about changing existing data? That’s doable too with SQL, using its `UPDATE`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have to specify which table we’re changing data in, and then which
    field to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'And of course, we can update multiple fields if we wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `WHERE` clause is actually optional here, but the result of not providing
    it is that **all** the records in the table will be updated since there’s nothing
    to limit which records it affects. So, it’s important when working with SQL that
    your statements that change data always do so to only the records you intend to
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final form of SQL statement you need to be aware of is for deleting data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once more, you must specify the table to operate on, and then some `WHERE` clause
    to determine which records to remove. As with the `UPDATE` statement, the `WHERE`
    clause is optional, so unless you actually intend to delete all the records in
    the table, be careful to include the correct criteria to match records by!
  prefs: []
  type: TYPE_NORMAL
- en: These are, of course, just the most basic SQL statements possible – SQL can
    get quite a bit more complex as you get into more advanced use cases – but if
    you understand the basic idea behind these four types of statements, then you’ll
    have a good start on understanding more advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, one of those more advanced use cases is when tables have some direct relationship
    to each other, which is where the word *relational* comes from in relational databases,
    so let’s talk about that next.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the relational in relational databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you know, you can have multiple tables in a database. For example, let’s
    say that in addition to the `People` table, we add a `Starships` table now, as
    shown in *Figure 7**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: The Starships table’s structure](img/B18315_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The Starships table’s structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it stands, there isn’t any real relationship between these two tables, and
    there’s nothing that ties them together. Sometimes that’s fine, but what if we
    want to know the starship each person serves on? One way we could do this would
    be to alter the `People` table, as shown in *Figure 7**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: The People table’s structure, now with a starship_id column](img/B18315_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The People table’s structure, now with a starship_id column'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `starship_id` column has been added, and assuming that the value in
    that field for each row of data matches one of the `id` values of a record in
    the `Starships` table, we’ve effectively connected the two tables and can now,
    at least indirectly, tell which starship each person serves on. We’ve created
    a *relationship*, in other words, between these tables, making this now a truly
    *relational* database.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what does that do to our SQL queries? Well, they work the same as before,
    but now we have some new capabilities at our fingertips because we can query for
    data from both tables at once based on the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll get four pieces of data for each record returned: the first name,
    last name, and age of each person, plus the starship they serve on. But we need
    to specify that we’re querying from two tables and combining the data in one result
    set, a concept called `p` for the `Person` table and `s` for the `Starships` table.'
  prefs: []
  type: TYPE_NORMAL
- en: We then use these names as prefixes on the names of columns everywhere in the
    query (again, to ensure that SQL knows exactly which fields we want).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to provide a `WHERE` clause here. It says that for each record
    in the `People` table (since it’s the first one in the list of tables in the `FROM`
    clause), find a record in the `Starships` table with an `id` value that matches
    the `starship_id` value in the `People` table. And since we’re returning `s.starship_name`
    in the list of fields, we wind up with data about each person from `People`, along
    with the name of the starship they serve on from `Starships`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is really the main point of relational databases: the ability to return
    data that is a combination of data from two or more tables, based on some relationship
    between them. The relationship here is the `id` fields, so where they match, the
    data from both tables is combined and returned as part of the query results. Joining
    is an expansive topic that can get fairly complex in a hurry (it deals with the
    mathematical concept of set theory), so we won’t go into it in detail here. But
    the basic concept is always the same: your query works to combine data from multiple
    tables based on one or more matching conditions, returning it all as a single
    list of data records.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to dive a little deeper into the various join types and how to
    write them, a good reference can be found here: [https://learnsql.com/blog/sql-joins-types-explained](https://learnsql.com/blog/sql-joins-types-explained).'
  prefs: []
  type: TYPE_NORMAL
- en: Even from this simple example, I’m sure you can begin to see the power of relational
    data. You can have a list of students and a separate list of classes and be able
    to write a query to get a list of classes each attends. Or, you could have a list
    of banking accounts and who owns each in separate tables but be able to tie them
    together when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Why do this, though? One of the main goals of relational databases is to not
    duplicate data (or, more precisely, duplicate it as little as possible – a process
    called `People` table itself, on each row of data. That would work just as well
    for our purposes. But if the name of the starship changes, then we would need
    to update all records in the `People` table accordingly. If instead we have two
    tables and join them as shown, then you just need to change the name in the `Starships`
    table – in one place, on one record – and it, in effect, is automatically changed
    for every person serving on it (at the time you do a query, that is). It’s a more
    logical way to deal with the data since the name of the starship isn’t logically
    tied to a person – they’re separate entities, really – and it’s also more efficient
    in terms of storage space (and, in some cases, improves performance, though that
    is very much a situation-by-situation thing and can, in fact, have the *opposite*
    effect).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may be wondering what to do if the data you’re working with
    isn’t inherently relational. And what if the form of the data you want to store
    isn’t as concrete as it needs to be in order to be described in a table as you’ve
    seen so far? Well, there’s another type of database for such cases that might
    be more appropriate – NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In simplest terms, a NoSQL database is literally any other kind of mechanism
    for storing data (which we often call *data stores*) that doesn’t use SQL to operate
    on the data. This includes types of databases such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"first name"`, and the value for that key is `"Frank"`. This is just about
    the simplest NoSQL type there is, and it’s used for situations where the data
    is very simple. Some common names you’ll hear for this type are Redis and DynamoDB,
    two products that provide a key-value database store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph databases**: These are somewhat newer and are specifically used for
    types of data that have (usually many) well-defined connections between entities.
    An example of this might be a social network: you are an entity, and you probably
    have connections to many friends, who also have connections to many friends, and
    so on. While these types of relationships can be modeled in a relational database,
    a graph database may be more appropriate, especially if you need to *traverse
    the graph*, meaning to start at one entity and follow its connections to some
    remote entity. Some common names you might hear for this type are Neo4j and Amazon
    Neptune.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wide-column stores**: These are a type of database used primarily when there
    is a need to analyze especially large datasets. They work by storing columns of
    data together in rows, which allows for optimizing complex queries across many
    fields of data in each entity. Examples of this type include Apache Cassandra
    and Google Bigtable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a fourth type known as a *document database* – I left it off the
    list because while all of the previous types are NoSQL databases, the fact is
    that when someone says NoSQL database, nine times out of ten, they probably mean
    a document database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a document database, the data is stored in objects, very often JSON objects,
    though not necessarily. You’ve seen JSON several times already: the `package.json`
    file that `npm` generates when you initialize a project. But the format of the
    data stored in it is **JSON**, which stands for **JavaScript Object Notation**.
    Curiously, while it was definitely invented within the context of JS, it’s used
    outside of that context frequently nowadays because it’s relatively simple and
    easy to work with. It’s simply a string at the end of the day, which can be easily
    parsed and used in various ways.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of those ways is to serve as a document in a document database, such as
    MongoDB, which is easily the biggest name in document databases (CouchDB is another
    popular name). As an example, if we wanted to store the data in the `People` table
    from earlier in MongoDB, we would wind up with four separate documents that might
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Rather than being rows in a table, each of those is a separate object – a document
    – stored in a **collection**, which roughly corresponds to a relational database
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the big difference between a relational database and a document database.
    Let’s say I want to store a nickname, but only for Leonard McCoy. In a relational
    database, I would need to add a `nickname` column to the table, and each row would
    need to have a nickname (it could, of course, be blank for people without a nickname).
    In a document database, though, I could simply write McCoy’s document like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It doesn’t matter that the other documents don’t have a `nickname` field; that’s
    perfectly valid. You see, the structure of a database, which includes the fields
    in the tables, is known as the **schema**. Since all rows of data in a table share
    the same column, the table essentially defines the schema for all the rows.
  prefs: []
  type: TYPE_NORMAL
- en: But in a document database, it’s the documents themselves that define the schema.
    Well, really, *you* as the developer do(!), but the point is that each document
    can in a sense have its own schema.
  prefs: []
  type: TYPE_NORMAL
- en: This has several benefits. One is that development can often be done quicker
    and easier with a document database because, unlike a relational database, you
    don’t have to get everything right at the start. With a relational database, you
    have to think about the data you want to store, and you have to build the tables
    with the appropriate columns and data types at the start (it’s true that you can
    alter the structure of tables after they’ve been created, but this comes with
    caveats that will sometimes make it not possible, and even if it *is* possible,
    it takes time and effort).
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit is that as you develop and realize that you need slightly different
    schemas on newer documents, you don’t necessarily have to alter existing data
    at all. As long as your code understands the possible differences, then you can
    deal with two versions of a document efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Now, one common misconception is that NoSQL databases, and document databases
    specifically, don’t have relational data. For sure that *can* be true, but using
    a document database doesn’t automatically mean that your data *can’t* have relationships.
    It’s probably fair to say that *more often than not* it won’t, and if it does
    have relationships, then it’s *probably* more appropriate to use a relational
    database. But one doesn’t negate the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'And NoSQL databases do supply mechanisms to perform all the basic CRUD operations,
    including querying for related data. I’m not going to go into those in detail
    here, just because they can vary greatly from database to database. However, given
    it’s the most popular NoSQL/document database, here’s an example from MongoDB,
    just so you have some idea what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That would be equivalent in SQL to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As with SQL, such statements can get rather complex the more complex the documents
    are, and if there are relationships between them, and so on. But that, in a nutshell,
    is how you work with them, and that code can be written in a multitude of languages
    depending on your needs and server-side infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: All of this database discussion leads to one last general topic, but I have
    to warn you, it may take you a moment to stop giggling before you read the next
    section, because here comes some CRUD!
  prefs: []
  type: TYPE_NORMAL
- en: Basic CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I know, I know – it sounds dirty, but I swear it’s a real term! The acronym
    **CRUD** stands for **Create, Read, Update, and Delete**, and it defines the four
    basic operations you can do on data, whether in a relational database or not.
    You can, of course, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create data, as with an `insert` SQL statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read data, as with a `select` SQL statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update data, as with an `update` SQL statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete data, as with a `delete` SQL statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If for no other reason than just being able to have an intelligible conversation
    with other developers, it’s valuable to have this terminology in your head, even
    if you might snicker to yourself every time you say it! And it doesn’t really
    matter how these operations are implemented in code; it only matters that conceptually,
    they are the only things you ever do with data in any form.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, of course, how these operations are implemented *does* matter in other
    ways. These CRUD (hehe) operations are often the basis for something called a
    web API, a collection of functions that can be called from remote systems. When
    it comes to building web APIs, the most common way to build them today is with
    yet another acronym (this field is flush with acronyms, if nothing else!): REST.
    And that’s the next thing we’re going to investigate.'
  prefs: []
  type: TYPE_NORMAL
- en: Building web APIs with REST, Node, and Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get to REST, though, let’s talk about APIs generally.
  prefs: []
  type: TYPE_NORMAL
- en: 'An **API** is an **application programming interface**. This can simply be
    a collection of functions that a program or library provides for other code to
    use. An API can be code located on the same machine as the code that calls on
    it, or an API can be exposed over a network, such as the internet and the World
    Wide Web. In this latter case, we call it a web API, a remote API, or sometimes
    a cloud API. All those terms mean the same thing, though: functions that can be
    called over the network, and they also tend to be language- and even technology-agnostic
    when built this way, meaning a JS client can call on a web API built in C, or
    code written in Python can call on a web API built with PHP, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a great many ways to structure and build such web APIs, lots of different
    technologies and patterns that can be used to build them, and a lot of different
    forms they can take. However, one has risen to the top of the heap after a lot
    of different options have been tried, and that approach is REST.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its core, **REST**, which stands for **REpresentational State Transfer**,
    is just a way to structure HTTP requests in a (relatively) consistent way.
  prefs: []
  type: TYPE_NORMAL
- en: The web inherently uses REST principles. For example, when you enter a URL in
    your browser, you’re requesting a resource based on a unique URL, be that resource
    an HTML page, an image, or maybe some data in the form of JSON (which is most
    common when talking about REST services). That’s basically all the World Wide
    Web is, and that’s really all REST is! However, the modern notion of REST refines
    that basic idea, making it a bit more well-defined.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful services, as we call web APIs built using REST, define the meaning of
    the standard HTTP methods – methods such as `GET`, `POST`, `PUT`, and `DELETE`
    – in explicit ways so that they have specific meanings. For example, a request
    made with `GET` means to retrieve a resource. `PUT` (usually) means to update
    some existing resource, while `POST` (usually) means to create a new resource.
    `DELETE`, of course, literally means to delete an existing resource. And of course,
    we’re talking about data on a server somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking down the words that make up the acronym *REST* is helpful to understand
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: The word *representational* refers to the fact that when you request data from
    the API, what you get is a *representation* of some resource in a form you can
    digest in code, but not really the resource itself. For example, while a checking
    account resource might be stored in a database on the server in some binary form
    that would look like gibberish to a client, you can *represent* that account using
    something such as JSON, which is essentially just plain text with a specific format,
    which any client can make use of.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word *state* refers to the current condition of the resource. In other words,
    when you request a representation of a checking account, you get a representation
    of it as it exists at the time of the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word *transfer* literally means to transfer that representation across the
    network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, putting that all together: a REST API is one that transfers representations
    of resources stored on a server in their current state or allows for updating
    the current state in some way or deleting the resource.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s the theory; now, let’s look at REST in a bit more practical sense.
  prefs: []
  type: TYPE_NORMAL
- en: REST in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you work with a REST API, you might have a URL that points to a resource
    on the server – say, a checking account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://my-awesome-web-api.com/checking-accounts/1234](https://my-awesome-web-api.com/checking-accounts/1234)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make a `GET` request to that URL (it’s not a real URL, but let’s pretend
    it is), it will return to you a representation of the checking account with account
    number 1234\. The representation could be in many forms, but by far the most common
    when using a RESTful API is JSON. So, you might get back a response something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you wanted to get a list of all accounts, then you would simply drop the
    `/1234` part from the URL (most likely), and you would (likely) get back an array
    of object representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you want to update the balance of that account (we’re ignoring security
    for this discussion, obviously!), you would usually make a request using the same
    URL, but using the HTTP `POST` method this time, and in the body of the request,
    you might provide some JSON like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The exact semantics of the API – the format of the data you get back and the
    data you pass in for updates – will vary from service to service, but the basic
    idea here is the meaning of the HTTP methods and the fact that JSON is being used
    to represent the checking account in both cases. Some APIs might require you to
    send back the exact representation you received from a `GET` request with the
    fields to be updated having the new values; others may just require the fields
    to be updated, as I’ve shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Note the key point, which is that the URL itself is what identifies the resource
    – the checking account, in this case – that we’re operating on. That’s why it
    doesn’t need to be included in the JSON sent in (probably – again, the semantics
    can vary from service to service).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, to remove that account, you would again use the same URL, but now
    with the HTTP `DELETE` method. That change is all it takes for the server-side
    code to identify what you want to do since the HTTP method is essentially a verb
    in this conversation, describing the action you want to take on the resource pointed
    to by the URL.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new account, that’s where it gets a little tricky. While we know
    that we need to use the `PUT` method, there obviously isn’t an existing checking
    account number to put on the URL, so what does the URL look like in this case?
    The answer is that it again depends on the semantics of the API. Some will have
    you put something such as `/add` or `/addNew` in place of the account number.
    Some will not need anything and just take the `PUT` method as meaning you want
    to add an account.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to an important point, which I’ve been hinting at with my use of
    equivocation terms throughout this discussion so far: there is REST, or RESTful,
    and there is REST-like. What that means is some developers will get pretty hardcore
    about following REST principles very rigidly (being RESTful). The problem with
    doing that is that sometimes you will have to make compromises in the design of
    the API that aren’t optimal. For example, some people say that the `/add` pattern
    described previously isn’t “proper” REST, but then they often don’t have a great
    answer for what the “right” answer is.'
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, you can be a little more flexible and design your API to be REST-like,
    which means you follow *most* of the architectural guidelines that define REST
    but allow for some degree of fungibility in it. There will almost always be some
    cases where things don’t quite fit the REST model as cleanly as you might like.
    Even just the meaning of HTTP methods can be debatable. While `GET` and `DELETE`
    are virtually never argued about, some developers say that `POST` should be used
    for updates instead of `PUT`, among other debates.
  prefs: []
  type: TYPE_NORMAL
- en: There is no canonical “these are the rules of REST that you must follow, or
    woe be unto you!” that anyone can point to. REST isn’t a set of guidelines; it’s
    an architectural principle, and those generally don’t have well-defined rules
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: So, my advice is to lean on the side of being REST-like. As long as you’re using
    HTTP methods with consistent meanings, and as long as you’re using URLs to identify
    resources to work with, then you’re about 90% of the way toward doing “proper”
    REST. If you also use JSON for your representation of those resources, then that
    probably gets you to somewhere like 98%.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, that in a nutshell is what REST is, but how do you build a REST web API?
    Let’s take a look at one way with something you have some familiarity with: Node
    and Express.'
  prefs: []
  type: TYPE_NORMAL
- en: Building your first REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin, as always, by init’ing a new project with NPM. Then, we’ll add
    Express as a dependency using the now-familiar `npm install –save express` command.
    That sets us up for coding a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take our previous database example using our Starfleet personnel and
    create an API that will let us add people, delete people, update people, and,
    of course, query people. To keep things simple, our “database” (which here simply
    means a collection of data, not a proper database as previously discussed) will
    just be JS variables since we’re focusing on the API part right now and not the
    database part. I’ll break down the code into easily digestible bite-sized pieces,
    but the complete file is `restAPI.js` in the `ch-07/rest` directory of the download
    bundle, and it begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We, of course, need to import Express itself and create an Express app, and
    then add some middleware to handle JSON being sent in a request. This is stuff
    you saw in [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082).
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we create our “database” in JS variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, an empty object is created and assigned to the `people` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the three crew members you saw earlier in the database discussion,
    each as a JS object.
  prefs: []
  type: TYPE_NORMAL
- en: The thing to note here is that JS objects are what are known as **associative
    arrays**. This is a data structure where values are mapped to keys. In a JS object,
    the field names are the keys. What this allows us to do is use the array bracket
    notation to access those fields (the key names are associative with values, and
    we can use array notation to access them, hence *associative arrays*).
  prefs: []
  type: TYPE_NORMAL
- en: And, what’s interesting is that in JS, field names in objects can be numbers,
    so that’s what I’ve used for the keys here. That allows me to simply increment
    by one the `nextKey` variable that you see defined in the last line to create
    a unique key for each newly added person.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when that code executes, it results in a JS object with this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can then access any of the people in the object using the key values (`1`,
    `2`, or `3`) to access the object for a particular person. The keys act as identifiers
    for the people in essence, which allows us to request a person by that identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the database defined, we can set up the first function in our API, and
    that will be a `POST` request used to create a new person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you saw in [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082), we set up routes
    with Express, where a route corresponds to a URL, and we call the appropriate
    method on the app object that corresponds to the HTTP method the route should
    respond to in order to do that. Here, we wind up with a URL such as [http://localhost:8080/people](http://localhost:8080/people)
    that we can post to, which will trigger this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the function, our middleware will have already parsed the incoming JSON,
    which would be in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The individual values will be pulled out and added to the `inRequest.body` object.
    We can use JS destructuring notation (as explained in [*Chapter 6*](B18315_06.xhtml#_idTextAnchor159))
    to get the values into individual variables. From there, we take the value of
    `nextKey` as the key of the new object and make sure we increment it so that the
    next creation gets a new key. Then, we just add a new object with the data received
    in the request, under the key we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step to creating our web API is to return a response since it wouldn’t
    be much good without that! But here is another facet of “proper” REST API design:
    the return codes should also have some meaning, just like the HTTP methods do.'
  prefs: []
  type: TYPE_NORMAL
- en: You could return an HTTP 200 status (or response) code here, because 200 means
    OK, or “the operation was successful.” However, code 201 means Created, which
    seems more right for an object creation function such as this. There can be debate
    about which is more appropriate, but the key thing is that your functions are
    consistent with response code meanings.
  prefs: []
  type: TYPE_NORMAL
- en: 'And whatever choices you make, they should always be logical! While 200 or
    201 makes sense, 500, for example, wouldn’t because that code means Internal Server
    Error (you can see a list of the codes and their meanings here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the response code, what you return is also an important consideration.
    And, at the risk of sounding like a broken record, you can find some debate about
    what is proper for various operations. But when creating a resource such as this,
    a good approach is to return the new resource itself, since the caller may want
    a copy of it, especially if the identifier is included, as it is here. That allows
    the caller to have all the information they need – the key – to delete or update
    the resource later without having to query the API again to get it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let’s look at a function to get a list of all people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Yep, it’s just a simple one line of code! We just need to return a response
    200 (which makes sense for a `GET` operation as none seem better to me) that is
    a JSON representation of the values – the objects for each person – in the `people`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we’ll write is to get a single person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When you define the URL for an HTTP request, here by calling `app.get()` again,
    you can have multiple handlers for a given HTTP method, but the URL must be different
    for each, or else Express won’t know which you want to use. Here, the URL is made
    different by the addition of the `:key` element. This is a token that Express
    will fill in and make available on the `inRequest.params` object. If a client
    makes a `GET` request to `/people`, then the previously-defined `app.get()` route
    handler will execute, but if they instead make a request to `/people/1`, then
    this function will execute instead, and the `1` value from the URL will become
    the value of `inRequest.params.key`.
  prefs: []
  type: TYPE_NORMAL
- en: That allows us to get the value into the `key` variable, which we can then use
    to access the right person object in `people` and send it back as JSON to the
    caller, fulfilling the request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I should take this opportunity to point out that I’ve written this code very
    simplistically, and one thing I left out in service of that goal is error checking.
    For example, what happens if the caller passes in a `key` variable that doesn’t
    exist in `people`? As written, they’ll get no response (or, really, an empty response
    – but not what a caller expects; that’s the point). You would most likely want
    to check for that condition and return a different status code, maybe 404 Not
    Found, and perhaps a string in the response saying it wasn’t found as well (the
    latter is another of those debatable REST decisions – some people feel the HTTP
    response code is sufficient; others always want *some* response from a function
    no matter what).
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, great – we can create people and we can get a list of all people and
    even get one specific person, so what about updating an existing person? That’s
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The URL is the same as for getting a person, which makes sense since in both
    cases the caller needs to specify the resource that we’re dealing with. But, of
    course, we need a different HTTP method, so `app.put()` is used this time to register
    the handler for this route. Inside the handler function, we’ll keep things simple
    and always update all fields in the target resource (by way of creating a new
    object) rather than cherry-picking them. This means the caller must always send
    all the data back, even fields that aren’t changing. Then, it’s just a matter
    of creating a new object with the data sent in, assigning it to the proper key
    in the `people` object, and returning a suitable response.
  prefs: []
  type: TYPE_NORMAL
- en: Since there isn’t an HTTP response code that more clearly means updated successfully,
    I went with a plain 200 (OK), and I sent back the `key` variable only this time
    since the caller already effectively has a copy of the data in its now-current
    state (arguably, it isn’t necessary to even send back the `key` variable, but
    in this case, I did prefer to have *something* returned).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final route we have to write is for deleting a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Yep, it’s that simple! This time, we use `app.delete()` since that’s the HTTP
    method needed to use this function. We get the `key` variable from the URL and
    use the JS `delete` keyword, which removes a field from an object, to remove the
    specified person. Finally, an HTTP 200 response code is sent back, along with
    the `key` variable that was removed (again, because I felt it more appropriate
    to not just return an empty response, but that’s a call you’ll have to make in
    your own work).
  prefs: []
  type: TYPE_NORMAL
- en: 'And with that, we have all the functions in our web API that we need. Now,
    we simply need to start the Express server and thereby make our API active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We run it on port `8080`, and everything is good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can, of course, go off and write some code, perhaps some JS to run
    in a browser, which calls this API. But before you do that, wanting to be a good
    web developer, you should probably test it a bit, right? How can you do that?
    You have lots of options here, but I’m going to talk about one very popular one
    in particular next: Postman.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API with Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have an API running, testing it can be done in many ways, but one way
    that many developers use is a tool called Postman. This is a GUI desktop application
    that allows you to make all sorts of HTTP requests to anything you need to, including
    the API that you should have running on your machine at this point. With Postman,
    you define requests, including what HTTP method they use, what URL they use, and
    any data to be sent with them, and you can trigger those requests at the click
    of a button. Postman can show you the response and can even take the raw response
    and reformat it to make it easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, testing the `GET` operation to retrieve all the people from
    our faux database is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Postman and login if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a workspace if you don’t have one already (it may create one by default
    for you).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left, you should see a **Collections** tab. Collections are just groups
    of logically related requests. Create a new collection with the **+** button you
    should see next to the **Collections** tab, and name it whatever you’d like (I
    uncreatively called mine **Book**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the collection so that it’s highlighted, at which point you should see
    a three-dot menu to the right of the name. Click the menu, and then select the
    **Add Request** option. You should see a new request added, and over on the right,
    a new tab should appear that has all the details about the request; Postman should
    automatically focus on the name of the request, ready for you to enter anything
    you wish there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **GET** method is selected in the dropdown below the request
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the box to the right of the method, which should say **Enter URL** initially,
    enter the following URL: [localhost:8080/people](https://localhost:8080/people).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should then be able to click the **Send** button to send the request, and
    the results should appear in the **Response** section at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 7**.5* shows what all of this should look like when done properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Postman, with a Book collection, a Get All request added, and
    a successful Get All response](img/B18315_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Postman, with a Book collection, a Get All request added, and a
    successful Get All response'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then add a request to test creating a new person. It’s the same procedure
    starting with creating a new request in the collection; however, this time, the
    method will be `POST` body content to send. It’ll just be some JSON, perhaps like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To the right of the **Body** tab, you’ll also need to select the type of data
    as **JSON**. Once that’s done, you should be able to trigger the request and get
    back a valid response, as shown in *Figure 7**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Postman, showing a successful Create response](img/B18315_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Postman, showing a successful Create response'
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, go ahead and add requests for updating and deleting people.
    Remember that in those cases, the URL will need to include the key on the end
    (so, something like [localhost:8080/people/4](https://localhost:8080/people/4),
    for example, if 4 is the key returned from a create call). Play around with it
    a bit, creating a person, then doing a **Get All** to see that it has been added,
    then maybe updating a person and doing a **Get** for that specific person to see
    the update, and finally deleting that person and then doing a final **Get All**
    to see they’ve been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just the very basics of using Postman; it has a lot more capabilities
    than this:'
  prefs: []
  type: TYPE_NORMAL
- en: You can write scripts to execute multiple requests to more fully test your target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can include cookies and headers and all the other goodies HTTP requests
    allow for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can supply security credentials for APIs that require it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can simulate a browser sending a form rather than sending JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can test GraphQL servers, which is a way you can expose a database to clients
    directly in a safe way and in a way that they can query for data based on their
    own specific needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set up certificates to be able to test HTTPS endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In short: if it’s done via HTTP/HTTPS, then you can almost certainly do it
    with Postman. It’s a great tool that allows you to test your server-side code
    without having to write all the client-side code first.'
  prefs: []
  type: TYPE_NORMAL
- en: But aside from during development, another situation where a tool such as Postman
    can come in handy is if your code isn’t working right for a given request from
    client to server. The problem could be in your client code or your server code.
    How do you know which it is? One good way to start figuring that out is to remove
    one or the other from the equation entirely. If you test your web API with Postman
    and find a problem occurs, then you just discovered the problem must be on the
    server side since the client side isn’t involved. Well, to be fair, as you gain
    experience, you’ll find that statement isn’t always as concrete as it seems! But
    it’s a generally solid approach to getting on the right path, at least.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned a bit about databases and web APIs, let’s talk about
    something that was actually touched upon earlier but that there’s a little bit
    more to say about, that being the “classic” web versus the “modern” (SPA-based,
    primarily) web, and how what’s old is what’s new again, in a sense, in the form
    of SSR.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the future – SSR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B18315_03.xhtml#_idTextAnchor082), we talked about SPAs and
    how they lead to a different model of web development. We talked about how this
    new model was in contrast to the classic model, where every interaction on the
    page leads to a request to the server, which generates an entirely new HTML page
    to be displayed. The new model instead depends on JS: on the client making a request
    to the server for just data, which the client code then does something with, most
    often displaying it in some fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at React, Vue, and Angular, we saw how the initial HTML document
    was essentially empty, and everything that wound up being shown in the browser
    was created on the fly by JS on the client machine.
  prefs: []
  type: TYPE_NORMAL
- en: What’s interesting, though, is that as with many things in this field, the pendulum
    is swinging back the other way a little bit, this time in the form of **SSR**,
    which stands for **server-side rendering**. With SSR, web pages are rendered on
    the server and returned to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: But wait – isn’t that what came *before* SPAs?!
  prefs: []
  type: TYPE_NORMAL
- en: Yes. Yes, indeed it is. The wheel turns, does it not?
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably guess, though, there is a difference between SSR and just
    having static HTML pages on a web server.
  prefs: []
  type: TYPE_NORMAL
- en: With SSR, it’s often the case that only the first request generates a new HTML
    page. The server takes what is essentially a template in the form of an HTML page,
    merges in some data, and then returns the final HTML to the client. However, what’s
    interesting is that some of that work can actually be done via JS executing on
    the server instead of the browser. In effect, the server is acting like a web
    browser, albeit one that doesn’t display the HTML. You can even use libraries
    such as React, Vue, and JS to render the content, but on the server. The server
    produces the final HTML document, as a browser would by executing the JS, and
    returns it, fully formed, to the browser. This will very often (almost always,
    in fact) include all the necessary CSS and JS, embedded in the HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent actions that occur on the client may result in a call to the server
    that generates a whole new HTML document, making SSR in that situation just like
    the classic model. But more often, after the initial page is loaded, things begin
    to function like an SPA in that the server is called to get only data, which is
    then rendered or used on the client in some way. We wind up with something of
    a hybrid approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would anyone want to do this, you might ask? There are a couple of good
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Especially when we’re talking about how fast a website loads
    initially, performance is a key metric. By using the server to do that work –
    servers that are in most cases more powerful than client machines and that are
    closer to the data they need – returning a complete document can be noticeably
    faster than returning an HTML document, which then creates new requests to get
    resources such as JS, CSS, and image files, and then render the content with JS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search engine optimization (SEO)**: It’s the art of including content on
    a website that search engines use to rank your site. Properly tuning this content
    allows you to show up sooner in search results, which is a key consideration for
    public websites. With a website that functions purely as an SPA, that content
    only exists on the client machine when requested, so search engines have a harder
    time indexing your site, and you have a harder time performing SEO. With SSR,
    though, because the server is returning a full HTML document and not a nearly
    empty one, you’d get to start a React, Vue, or Angular app, and search engines
    “see” more content to index, which, when SEO is done properly, leads to higher
    ranking in search results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better device support**: Because most of the heaviest lifting in terms of
    rendering the full HTML is done on the server, it allows less powerful client
    devices to have a more acceptable experience. Older cell phones, for example,
    still used around the world, will usually have an easier time rendering a complete
    HTML page – which from its perspective is static – than it will running a lot
    of complex JS on the phone itself to generate the HTML on the fly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the modern frameworks have support for SSR nowadays. In fact, it can
    be as easy as flipping a switch in a config file in some cases, and all of a sudden,
    you’ll find your initial HTML document being rendered on the server. Although
    in a lot of ways like the classic model, which at this point is 30+ years old,
    SSR is a fairly new thing. Well, sort of: it was actually introduced in some modern
    frameworks as early as 2010, and 10 years in web development really isn’t a long
    time! But it’s new in the sense that it has started picking up steam in terms
    of developer mindshare more recently, as it’s become a more standard part of modern
    frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: But it’s still an optional thing. Is it possible to do SEO without SSR? Yes,
    it is, though it can be more challenging. For example, you’ll sometimes find that
    you may have to have some content in your static HTML page that is invisible and
    that gets removed when it gets to the browser – but then, you’ll find that search
    engines are kind of on to such tricks, so it may not work as well as you’d hope,
    or indeed at all in some cases. And your use case may not make SSR worth it anyway
    because it certainly does complicate things, and any time you add complexity to
    web development, you have to do a cost-benefit analysis to decide if it’s worth
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility is to use server-side technologies to render your initial
    HTML document (as well as handle subsequent data requests), which is actually
    another form of SSR in a sense, but one in which you have more granular control.
    That can be done with Node, of course, but there are other options, and that’s
    what we’re going to talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: Using PHP on the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many server-side technologies you can use; you’re not limited to Node
    and JS. One such technology – one of the oldest, in fact – is PHP. First hitting
    the scene in 1995 (though taking a couple of years to start gaining traction),
    PHP is what’s known as a *preprocessor*. Essentially, it’s an extension to a web
    server that performs some sort of manipulation on a requested resource.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of PHP, that manipulation is executing code written in the PHP language
    that is embedded in an HTML file. The file is given a `.php` extension, and when
    requested, that extension identifies to the web server that it needs to hand that
    file off to the PHP preprocessor, allow it to transform it, and then return to
    the caller whatever the output of that transformation is.
  prefs: []
  type: TYPE_NORMAL
- en: 'That may sound a little complicated, but I think a simple example will make
    it clear (you’ll find this in the `hello_world.php` file in the `ch-07/php` directory).
    As always in programming, let’s use a “Hello, world!” example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it’s a simple HTML document, until you hit that funky-looking
    `<?php` thing. This begins a block of PHP code, and `?>` closes the block. Anything
    in between those must be written in PHP. When this file is requested from a web
    server that has PHP installed, the web server sees the `.php` extension and hands
    the file off to the PHP processor. The processor looks for any PHP code blocks
    like this (of which you can have as many as you like) and executes the code in
    it. Whatever the output of the code is, if any, replaces the block in the final
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, what gets returned to the browser in this case will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there no longer is any PHP code. Instead, the text that the
    code outputs via the `echo` statement replaces it. This is a common approach with
    many server-side technologies, *“execute some code in a special block and replace
    it with the result of that code,”* and it means that the client doesn’t need to
    know anything about PHP; it’s all handled on the server. The client just knows
    that it’s getting an HTML document back; it doesn’t know anything about what the
    server did to produce it, but PHP and technologies like it provide us developers
    a very simple way to build dynamic content into otherwise static resources and
    without any complex infrastructure or code such as in a Node/Express application,
    for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: PHP is a robust and powerful language, much like JS, and has a lot of libraries
    supporting it that allow it to, for example, interface with databases easily,
    make calls to remote systems, manipulate images, and really do all the things
    that any useful server-side language would do. It has over time evolved into a
    modern language with all the sorts of features developers have come to expect
    from a modern language.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you just a little more of a taste of PHP, let’s implement a pretty
    common thing done with it, or really any server-side technology: handling the
    submission of a form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create a simple form (`form.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it’s just a simple HTML form, something you’ve seen before.
    We allow the user to enter their name and submit the form; that’s it. The target
    of the form submission is `form.php`, which we’ll create next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we construct a plain text response by getting the `username` variable
    from the request and constructing a string with it. Variables in PHP begin with
    a `$` symbol, and the `$_POST` variable is one PHP supplies which will hold the
    values of any data submitted via a POST request. The only one we have to worry
    about is `username`, so we wind up with a `$username` variable with the value
    of whatever the user submitted in the form. Then, `echo` is used to create the
    output, and in PHP, periods are used to represent string concatenation, so we’re
    building a string such as `"Hello, Frank!"` and returning that to the client (note
    that we don’t need to construct a full HTML document because the browser is quite
    capable of displaying a plain text response such as this).
  prefs: []
  type: TYPE_NORMAL
- en: PHP is fairly straightforward but opens up a lot of possibilities. It is, however,
    far from the only such option available. Another one, which in some contexts is
    much more popular, is Java, and specifically the Spring Boot library for it. Let’s
    take a quick look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: Building with Java and Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java and Spring Boot kind of go hand in hand these days in the sense that Spring
    Boot is the most popular way people write apps using Java nowadays, but Spring
    Boot couldn’t exist without Java. So, let’s start with Java, then talk about some
    things that go along with it that allow you to build web apps, and finally arrive
    at Spring Boot. I think once you’ve read through this entire section, you’ll understand
    how the pieces fit together pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Java**, which I’ll let you know up-front has nothing to do with JS other
    than a similar-looking language syntax and is a product of the now-defunct Sun
    Microsystems, is now owned by Oracle, and it is easily one of the most widely
    used languages and platforms of them all. It is especially popular in enterprise
    environments where things such as stability and flexibility – and having a company
    sue if something goes wrong, to be blunt – are of primary importance.'
  prefs: []
  type: TYPE_NORMAL
- en: Java became popular based on its “write once run anywhere” principle. It was
    one of the first languages that allowed for a piece of code, without being changed
    in any way, to run on multiple different hardware platforms and operating systems.
    There were a few ways to do that before Java, but none were as easy as Java.
  prefs: []
  type: TYPE_NORMAL
- en: Java accomplishes this by the introduction of the **JVM**, or **Java Virtual
    Machine**. It’s similar conceptually to the VMs you’ve already met, but it’s not
    a full simulation of a machine. Instead, it’s a simulation of an artificial machine,
    one that doesn’t exist in the real world. It winds up being a target for compiled
    code. In other words, rather than compiling Java code to a form that can run on
    the native machine, it instead compiles to an intermediate form that can run on
    the artificial machine the JVM represents. The JVM also isn’t an encapsulation
    of that machine and an operating system like a VM is; it instead is just the machine,
    with the compiled Java code running on it, and being the only thing running on
    it (more or less).
  prefs: []
  type: TYPE_NORMAL
- en: Java also comes with a very extensive standard library and thousands upon thousands
    of functions for you to use, battle-tested and extremely solid. This means you
    have a great foundation to build upon even before you think about adding any third-party
    libraries, which Java, of course, supports.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with Java, you normally will interact with its **JDK** or **Java
    Development Kit**. The JDK is a specific form of an **SDK**, which stands for
    **software development kit**. An SDK is a collection of tools for working with
    a specific development platform or language, and a JDK then is an SDK specific
    to Java. You install a JDK, or indeed you can usually just expand an archive and
    not actually install it per se, and then use its command-line tools to compile
    code, debug code, and do all the other things you might want to do with Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Java app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And what does Java code look like? Here is perhaps the simplest Java app you
    can write (this is the `HelloWorld.java` file in the `ch-07/java` directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is called a Java *app* specifically, and it shows that everything in Java
    begins with a class, which is the fundamental concept in `public` keyword before
    the `class` keyword and name is called an access modifier, and it tells Java where
    this class can be used from. The `public` access modifier means that any other
    Java code can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes can have a lot of stuff in them, but this one contains just one thing:
    a function (or method, since it’s a function in a class) named `main()`. The method
    has the `public` access modifier too, so any other Java code can call this method
    (by contrast, a method can be private, which would mean that only other code in
    the class can use it).'
  prefs: []
  type: TYPE_NORMAL
- en: The `static` keyword means that the `main()` method can be called on the `HelloWorld`
    class without creating a new instance of it first (which is typically what we
    do with classes – create object instances from them, but in this case, we just
    want to be able to execute the method, so we can skip that requirement with `static`).
  prefs: []
  type: TYPE_NORMAL
- en: The `void` keyword means that this method won’t return anything.
  prefs: []
  type: TYPE_NORMAL
- en: This method accepts an argument that is an array of strings and that will come
    from any options we pass to it on the command line when run, if any (we don’t
    need that here, but I figured I’d mention it since it’s required by Java to make
    a Java app work).
  prefs: []
  type: TYPE_NORMAL
- en: The `System.out.println()` statement in `main()` – the only code in it – is
    a method that outputs text to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must first compile this app, and that’s done using the Java compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That will produce a `HelloWorld.class` file. A `.class` file is what actually
    runs on the JVM, which you can now do easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that `javac` is the Java compiler, while plain old `java` is essentially
    the JVM. The JVM will look for a file named `HelloWorld.class` in the current
    directory, will find it assuming you’ve compiled `HelloWorld.java`, and will then
    look for a `public static void main()` method in it (it *has* to be that *exact*
    method signature), which is the default method a Java app must include to be runnable.
    Finding one, it will execute the method, and the text should be output to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Java apps are neat, and you can do virtually anything with them, but when we’re
    talking about web development with Java, we rarely do that with plain Java apps.
    The next step above apps when it comes to web development are JSPs and servlets.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JSPs and servlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with PHP (and with `.cshtml` files, as you’ll see with .NET later), Java
    offers a template language called **JSP**, or **Java Server Pages**. This allows
    you to embed Java code in HTML files. A simple example would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Any code inside the `<% %>` block is Java code and will be executed as such,
    just as with PHP.
  prefs: []
  type: TYPE_NORMAL
- en: When a JSP is requested, it will be processed by the JVM, and what will happen
    is something called a **servlet** will be generated. A servlet is a special Java
    class that knows how to respond to HTTP requests. But servlets can’t work alone.
    Instead, they have to be run as part of a **Java web app**, which runs in an **application
    server**. The application server manages the web app, handles its lifecycle events,
    and acts as the web server. When it sees a request come in for this JSP for the
    first time, it will generate a servlet class and then execute it (subsequent requests
    can just execute it immediately).
  prefs: []
  type: TYPE_NORMAL
- en: 'The servlet code for our JSP that would be generated might look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There would likely be additional methods present to handle various events in
    the lifetime of a servlet, but that’s the basic idea, and you can see how the
    `_jspSevice()` method, which is the main one in a servlet, outputs the HTML from
    our JSP. Of course, more complex Java code in the JSP would result in more complex
    code in the servlet too.
  prefs: []
  type: TYPE_NORMAL
- en: You can write a servlet directly yourself too; you don’t have to start with
    JSPs. In fact, while JSPs can’t be used without servlets, servlets can definitely
    be used without JSPs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I have not included a complete example of all of this in the code
    bundle for two reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, there’s quite a lot more involved in setting up a working Java web app
    than this, starting with needing to install and run an app server (which is what
    manages the JSPs and servlets and the web app they’re a part of, and something
    called **Java Enterprise Edition** (or **JEE** for short). While Java itself comes
    with a robust standard library, JEE builds on top of that significantly, providing
    a lot of the higher-level functions modern web apps need. While Java comes with
    basic data structure and algorithms, JEE added JSPs, servlets, database access,
    and a whole host of other “advanced” facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Second, I wanted to save space for the next section, which I did include a working
    example for since the topics of Spring and Spring Boot are arguably more important
    nowadays than being able to build a Java web app from scratch using JSPs and/or
    servlets and even JEE, and that’s what we’re looking at next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Spring and Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Spring** is without question the single most popular third-party library
    available for Java. It supplies an absolutely monstrous list of features on top
    of Java: things such as security, streamlined database functionality, a high-level
    web app architecture, REST service construction and consumption, task scheduling,
    and so much more.'
  prefs: []
  type: TYPE_NORMAL
- en: What it’s perhaps best known for, though, is its **Dependency Injection**, or
    **DI**, framework. DI is the idea that rather than your code constructing objects
    of various types, it is better to have some higher-level entity *inject* them
    into your code. There are many reasons for doing this, but maybe the biggest is
    testing. If you have some code that builds a connection to a database and you
    then want to test the code, you might need to connect to a separate test database.
    Rather than having to build that into the code, you could instead have a test
    framework build the connection, knowing how to build it for the test database
    rather than the real database, and inject the connection into your code. That
    way, the code you test is identical regardless of which database you connect to.
  prefs: []
  type: TYPE_NORMAL
- en: Spring became famous for this DI framework, but it grew massively after that,
    encompassing nearly anything you could do with Java. In fact, it’s so comprehensive
    now that a lot of people consider Spring to be the core of what Java is, JEE specifically.
    While Spring still needs JEE under the covers, when using Spring, you can all
    but ignore JEE if you wish, deferring to Spring’s functionality instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on top of Spring comes something called Spring Boot. In short, **Spring
    Boot** is a framework that helps you bootstrap (set up) and develop Spring-based
    Java apps, most commonly web apps. Spring Boot does this in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.class` files). This simplifies the process of setting up and configuring
    Spring applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standalone**: Spring Boot applications are standalone and can be run directly
    using Java, which makes it easier to build and test Spring applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opinionated defaults**: Spring Boot comes with a set of opinionated defaults
    for quick project setup, while also offering options to override these settings
    for customization. This means you have to do less up-front configuration to make
    a Spring Boot app work, but you can override the defaults later as needs dictate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded servers**: Spring Boot apps include the Tomcat, Jetty, or Undertow
    app server directly, so you don’t need to deploy your application to an app server.
    You get a runnable unit with Spring Boot that requires nothing aside from Java
    itself to work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wide range of features**: Out-of-the-box Spring Boot supports a wide range
    of data access, security, and cloud services, making it a versatile tool for a
    variety of applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now build a simple Hello World web app with Spring Boot and see what’s
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: A simple Spring Boot web app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to start a Spring Boot app is to head on over to [https://start.spring.io](https://start.spring.io)
    and let someone else do the work for you! This is a site provided by the creators
    of Spring and Spring Boot that will generate a basic Spring Boot app for you.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this site in *Figure 7**.7*. If you want to try it yourself, select
    the options you see here (including adding the **Spring Web** dependency on the
    right, or this project won’t work!).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: The Spring Initializr website with options for creating the example
    project](img/B18315_07_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: The Spring Initializr website with options for creating the example
    project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click the `.zip` file that contains your starter project. Extract
    that archive, go to Command Prompt in the directory (which would be named `demo`
    if you entered exactly what is shown in the screenshot), and execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see a ton of stuff fly by and, as long as it doesn’t end with an error
    of some sort, it doesn’t really matter. But, to give you some idea… Maven, which
    is what the `mvnw` command represents, is a Java build tool. It knows how to build
    your project into a runnable unit. You see, real Java apps are rarely just a single
    `.java` file to be compiled. Usually, there are all sorts of third-party libraries
    needed, lots of source files to compile, and other files that must be included
    in various ways. Rather than figure out how to do all of that yourself, as long
    as you follow a standard structure and provide some configuration files, then
    Maven will know how to build your project, get all the dependencies for you, and
    handle all those icky details.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the command to use for Maven is just plain `mvn`. But, for that to
    work, Maven must already be installed and in your path. To save from having to
    do that yourself, `mvnw` is a Maven *wrapper*. These files know how to use Maven
    without you first having to install it. When you first run that command, the wrapper
    will download the necessary Maven files, everything Maven needs to run, and then
    it will begin building the project, downloading all of its dependencies along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, it will run the project, which starts the server that Spring Boot
    provides. And you can then access it in your browser at [http://localhost:8080](http://localhost:8080).
    However, if you do that right away, you’ll get a “Whitelabel Error Page” screen.
    That’s because we haven’t supplied any code to handle the default route, and Spring
    Boot isn’t going to do that for us!
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix it, we need to add a file named `HelloController.java` in the `src/main/java/com/example/demo`
    directory under the parent project directory and put the following content into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is a controller class that handles requests to specified URLs. In this
    case, the `@GetMapping("/")` line tells Spring Boot to execute this method when
    a URL with nothing after the domain name comes in (where `localhost` is our domain
    name).
  prefs: []
  type: TYPE_NORMAL
- en: This statement, plus the `@RestController` line, are what are called `@RestController`
    annotation tells Spring Boot that this class handles HTTP requests (it’s generally
    meant to be used to build REST APIs, but given that a simple `GET` request to
    a URL is still a RESTful operation, it counts for this use case), and Spring Boot
    will maintain a mapping between URLs and controllers and hand requests off to
    the appropriate controllers when they come in.
  prefs: []
  type: TYPE_NORMAL
- en: The method annotated with the `@GetMapping` annotation then executes and returns
    our greeting string – nothing fancy there at all. In fact, this is about as simple
    as a Spring Boot app gets, but it demonstrates the basic ideas well enough.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot, as well as Spring and Java itself, is so broad and does so much
    that you can’t hope to learn it all in one go; you have to introduce new concepts
    as they’re needed and learn as you go, which you’ll remember is one of the big
    core requirements to being a web developer!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen some PHP and Java, let’s have a look at another choice
    for server-side coding, this time from our friends at Microsoft: .NET.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Java largely rules the enterprise space, it’s not the only popular choice
    there. Microsoft has a competitor to it named .NET. As with Java, it’s a large,
    sprawling platform that covers pretty much all the bases in terms of what developers
    need. It can handle database access and network communications and can be used
    to build RESTful APIs as well as other server-based facilities. It can be used
    in **artificial intelligence** (**AI**) applications, and it comes with support
    for several different languages via the **Common Language Runtime** or **CLR**,
    which is conceptually like Java’s JVM.
  prefs: []
  type: TYPE_NORMAL
- en: And like Java, while .NET is definitely used for desktop development – more
    so than Java, in fact, is – it has largely become the domain of the server and
    is the primary supported language/platform in Microsoft’s Azure cloud. And while
    .NET began primarily as a Windows technology, it is currently also officially
    supported on Linux and other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: .NET is often used in conjunction with Microsoft’s Visual Studio IDE. In fact,
    in practice, you probably won’t find that many .NET developers who don’t use it!
    But at the end of the day, it’s not required since .NET provides an SDK like Java
    that you can work with exclusively from the command line, and for our purposes,
    here we won’t be using Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Hello World web app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming you have the .NET SDK installed and working, it makes it even easier
    than other options to build a Hello World application because it’s built right
    into .NET! All you need to do is create a directory for your project and execute
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll wind up with a new directory named `HelloWorld`, in which will be a
    fully functional Hello World application! To run it, navigate to that new directory
    and execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You will, of course, find such a project already built in the `ch-07/dotnet/HelloWorld`
    directory, but it’s a good exercise to create and run it yourself from scratch.
    And once you do, you can access the page at http://localhost:5262.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll note from looking at *Figure 7**.8* that it has a little more content
    than the simple “Hello, World!” page as in the previous examples (which is why
    I’m showing it here while I didn’t show the others). Unfortunately, as a result
    of that, there is a lot more code behind this “simple” example than either the
    PHP or Java versions – too much to go into everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: The .NET version of the Hello World app](img/B18315_07_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: The .NET version of the Hello World app'
  prefs: []
  type: TYPE_NORMAL
- en: But, to not leave you completely with nothing, the three main files involved
    are probably `Program.cs`, `HomeController.cs`, and `Index.cshtml` (there are
    many other files created by .NET, but those are kind of the key ones). These files
    are what we’ll be looking at in the next three subsections.
  prefs: []
  type: TYPE_NORMAL
- en: The `.cs` extension indicates these are C# source files, where C# is one of
    the languages you can use in .NET, and by far the most used one at that (nearly
    to the exclusion of all others, I’d even say). By extension, `.cshtml` indicates
    an HTML file that has C# code embedded in it, much like a `.php` file can have
    PHP code embedded in it.
  prefs: []
  type: TYPE_NORMAL
- en: The server starting point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the `Program.cs` file, which is essentially the starting point that
    sets up the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you generate this app yourself, your version may look slightly different
    depending on what version of the SDK you have, but it should look substantially
    the same. From it, you can tell that C# looks a lot like all the languages you’ve
    seen, which is to be expected since they all are based on the C language’s syntax
    and structure (there are huge differences between, say, JS and C#, but they look
    similar enough and share enough concepts that you can probably grasp what’s going
    on even if you’ve never seen a given C-based language before).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to making a server with Node and Express, you construct an `app` object,
    in this case using something called a builder, which is code that knows how to
    construct an `app` object for you (I know, obvious, right?). After that, middleware
    is added for doing things such as handling errors (`UserExceptionHandler`), serving
    static files (`UseStaticFiles`), and setting up routes to controllers (`MapControllerRoute`).
  prefs: []
  type: TYPE_NORMAL
- en: The controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A controller is a piece of code that handles a given request, and that’s where
    the `HomeController.cs` file comes in, as it handles our main “home” route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is part of an **MVC** application, which stands for **Model-View-Controller**.
    This is an application architecture pattern – a way to structure applications,
    in other words – that tries to separate out the view (usually in the form of an
    HTML file or something similar) from the model (which means the data, in essence)
    from the controller (which binds the other two together). The three are usually
    implemented as separate units of code as is the case here, but they work together
    to generate a response for a client on a given URL. The reason for doing this
    is that if you want to change, say, your database, you can do so without touching
    the view or the controller layers; just change the model layer as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in this example, there actually is no model layer, which is okay:
    you can still have a more-or-less MVC architecture even if the view or model is
    left out (the controller will always be present, and it’s rare to not have a view
    layer, but if you don’t need data then you don’t need a model layer, which really
    makes it an MV architecture, but we tend to call it MVC anyway, I guess just because
    developers can be weird sometimes!).'
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, a view is generated by the `Index.cshtml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And it’s the simplest one of the three! Like PHP and JSP, it’s a template in
    essence, where the `${ }` blocks represent C# code to be executed when rendered.
    The rest is just plain HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP, Java, and .NET aren’t the only choices, though. Another you might consider
    is one you saw in earlier chapters: Python. Let’s see how Python can be used to
    build web apps next.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Python web app frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18315_05.xhtml#_idTextAnchor129), you met Python, and we talked
    about how it can be used in the context of DevOps. That’s not the only place Python
    can be used, though. Of course, you can write standalone Python apps for all sorts
    of purposes too. But beyond that, Python can be used as the backend platform for
    your websites and web apps as well.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, when working with Node to develop server-side code, developers
    have two main paths. One is to build the server code solely with Node’s built-in
    capabilities, which can be suitable for smaller projects. However, for larger
    projects, most developers prefer using a library or framework such as Express
    to enhance their development process.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, Python offers all the essentials for building a server from scratch.
    But as with Node, many developers opt for a more comprehensive solution in the
    form of a framework to avoid writing a lot of repetitive, foundational code, one
    of those being Django.
  prefs: []
  type: TYPE_NORMAL
- en: Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Django** is a framework designed to streamline development; Django aims to
    ease the development load by providing pre-built defaults for various functions,
    significantly cutting down on the amount of basic code developers need to write.
    Django is known for being like Angular in the sense that it tries to include most,
    if not all, of what a typical developer will need to get the job done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a brief view of what a Django app might look like, you would need
    to start by creating a directory to host your project (which you’ll find in the
    download bundle under `ch-07/python`) and installing Django itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Python world, `pip` plays the same basic role as `npm` does in the Node
    world, installing and dealing with packages, and this specific command installs
    the Django package globally, meaning it can be used from anywhere. After that,
    we can use commands that Django provides to create a new Django project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You’ll wind up with a `helloworld_project` directory in whichever directory
    you’re in when you execute it, which you will then navigate to for the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Django, a single project can host multiple apps, but we just need one
    right now, and there’s a command to create that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `manage.py` file is a script provided by Django for performing all sorts
    of setup and management tasks on a project and the apps under it. After executing
    that command, you’ll find a `hello` directory created inside the `helloworld_project`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a view, which is conceptually like a route in an
    Express app: something that will respond to requests to a specific URL. To do
    this, go into the `hello` directory, open the `views.py` file that you’ll find
    has been created there, and add this content below the comment line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This provides a function that will ultimately execute when we make a request
    to a configured URL and will return a simple text response.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to tell Django to use this view. This requires two steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the `helloworld_project` directory, you find that a directory was
    created automatically that is also named `helloworld_project`. I know – the names
    are confusing, but it’s the way Django does it: you get a directory with the same
    name as the project directory it’s in. Inside that inner `helloworld_project`
    directory, open the `urls.py` file. In it, you’ll find some instructional comments
    and a few lines of code. Two things need to be done here. First, add a new import
    under the existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That adds a package named `include` that we need in order to do the rest of
    what’s to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, on the line that defines the `urlpatterns` array, add a new entry after
    the `/admin` one that’s already there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This essentially sets up a route to the `hello` app itself and tells Django
    to look for routes in it as defined in its own `hello.urls` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that file is the final step to make everything work. You’ll need to create
    a `urls.py` file in the `hello` directory with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: That sets up a route in the `hello` app itself to the view we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your first Django app should be ready! Conveniently, Django
    includes a built-in web server to test with, and you can start it up now to try
    your app out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You should find that your app responds to requests to [http://localhost:8000/hello](http://localhost:8000/hello).
  prefs: []
  type: TYPE_NORMAL
- en: For such a simple example, it may seem like there’s a lot involved with Django,
    but as an app gets more complex, it starts to pull its weight much more by virtue
    of the advanced functionality it provides, which while it can require this type
    of setup too, it tends to have a much better **return on investment** (**ROI**),
    meaning the benefit is worth the cost.
  prefs: []
  type: TYPE_NORMAL
- en: But if you find Django not to your liking, another popular framework named Flask
    might be more so.
  prefs: []
  type: TYPE_NORMAL
- en: Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With **Flask**, another popular Python web framework like Django, the Hello
    World example is a lot simpler, and it begins with installing Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a directory for your project (which you can name anything you
    like), and in it, create an `app.py` file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And guess what? You’re actually done at this point! You can now run the development
    server that, like Django, Flask provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: And then, you can access the app at [http://localhost:5000](http://localhost:5000).
  prefs: []
  type: TYPE_NORMAL
- en: With Flask clearly being much simpler, why would anyone in their right mind
    choose Django?!
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that they serve different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Django is attempting to be as close to all-encompassing as possible. It has
    facilities for working with databases, security, a built-in administration app,
    functions for dealing with sessions and authentication, a templating engine, advanced
    URL routing, and a lot more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask, on the other hand, is what’s known as a **micro-framework**. Flask is
    designed to be more lightweight and simply not do as much as Django, which requires
    you to add other libraries to the mix as you see fit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both have their pros and cons, and it’s roughly the same situation as comparing
    React or Vue to Angular: the first two simply do a lot less out of the box, by
    design, but there is arguably more flexibility in a smaller framework since you
    get to choose how specific features are provided.'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, that’s a few more knocked off, isn’t it? In *Figure 7**.9*, you can see
    the updated web developer roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: The roadmap with a few more boxes filled in](img/B18315_07_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The roadmap with a few more boxes filled in'
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, you uncovered the **Databases**, **Java and Spring Boot**,
    **PHP**, and **.NET** blocks. And would you look at that – the entire backend
    section is now fully revealed!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about a variety of server-side technologies, starting
    with databases. You learned the difference between relational databases and NoSQL
    databases, and in the process, you got an introduction to the SQL language. You
    then learned about exposing that data through a REST interface, probably the most
    common way web APIs are provided these days (oh, and you learned what a web API
    is too, didn’t you?).
  prefs: []
  type: TYPE_NORMAL
- en: After that, you got a look at some server-side technologies for building server-side
    code, including Java and Spring Boot, PHP, .NET, and some Python web frameworks
    such as Django and Flash. You sampled code for all of them to give you an idea
    of what might be involved if you choose them, and we talked a bit about the decision
    points that go into choosing one versus another – and you learned that in large
    part, it comes down to personal preference and what you have the most experience
    working with!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to in a sense close out the technical portion
    of this book and look at some alternate approaches to coding, in some cases some
    cutting-edge technologies that attempt to make web development much less about
    development. This includes things such as AI, **content management systems** (**CMS**),
    and other so-called “no-code” alternatives.
  prefs: []
  type: TYPE_NORMAL
