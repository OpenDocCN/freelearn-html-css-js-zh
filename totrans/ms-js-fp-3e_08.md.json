["```js\n$ ls -1 | grep \"odt$\" | wc -l\n4\n```", "```js\n$ function cfe() {\nls -1 | grep \"$1\\$\"| wc -l\n}\n```", "```js\n$ cfe odt\n4\n$ cfe pdf\n6\n```", "```js\nconst markers = [\n  { name: \"AR\", lat: -34.6, lon: -58.4 },\n  { name: \"BO\", lat: -16.5, lon: -68.1 },\n  { name: \"BR\", lat: -15.8, lon: -47.9 },\n  { name: \"CL\", lat: -33.4, lon: -70.7 },\n  { name: \"CO\", lat:   4.6, lon: -74.0 },\n  { name: \"EC\", lat:  -0.3, lon: -78.6 },\n  { name: \"PE\", lat: -12.0, lon: -77.0 },\n  { name: \"PY\", lat: -25.2, lon: -57.5 },\n  { name: \"UY\", lat: -34.9, lon: -56.2 },\n  { name: \"VE\", lat:  10.5, lon: -66.9 },\n];\n```", "```js\nconst sum = (x: number, y: number): number => x + y;\nconst average = (arr: number[]) =>\n  arr.reduce(sum, 0) / arr.length;\nconst myMap = curry(\n  flip2(demethodize(Array.prototype.map))\n);\nconst getAllLats = myMap(getField(\"lat\")) as (\n  arg: any\n) => number[];\nconst averageLat = pipeline(getAllLats, average)(markers);\n// and similar code to average longitudes\n```", "```js\nconst averageLat2 = pipeline(\n  curry(flip2(demethodize(Array.prototype.map)))(\n    getField(\"lat\")\n  ) as (arg: any) => number[],\n  average\n)(markers);\n```", "```js\n// pipeline.ts\nfunction getDir(path) {\n  const fs = require(\"fs\");\n  const files = fs.readdirSync(path);\n  return files;\n}\n```", "```js\n// continued...\nconst filterByText = (\n  text: string,\n  arr: string[]\n): string[] => arr.filter((v) => v.endsWith(text));\n```", "```js\n// continued...\nconst filterOdt = (arr: string[]): string[] =>\n  filterByText(\".odt\", arr);\n```", "```js\n// continued...\nconst filterOdt = curry(filterByText)(\".odt\");\n```", "```js\n// continued...\nconst count = <T>(arr: T[]): number => arr.length;\n```", "```js\n// continued...\nconst countOdtFiles = (path: string): number => {\n  const files = getDir(path);\n  const filteredFiles = filterOdt(files);\n  const countOfFiles = count(filteredFiles);\n  return countOfFiles;\n};\ncountOdtFiles(\"/home/fkereki/Documents\");\n// 4, as with the command line solution\n```", "```js\nconst countOdtFiles2 = (path: string): number =>\n  count(filterOdt(getDir(path)));\nconst c2 = countOdtFiles2(\"/home/fkereki/Documents\");\n// 4, again\n```", "```js\n// continued...\nconst pipeTwo =\n  <AF extends any[], RF, RG>(\n    f: (...args: AF[]) => RF,\n    g: (arg: RF) => RG\n  ) =>\n  (...args: any[]) => g(f(...args));\n```", "```js\n// continued...\nconst countOdtFiles3 = (path: string): number =>\n  pipeTwo(pipeTwo(getDir, filterOdt), count)(path);\nconst countOdtFiles4 = (path: string): number =>\n  pipeTwo(getDir, pipeTwo(filterOdt, count))(path);\n```", "```js\ncountOdtFiles3(path) ===\n  pipeTwo(pipeTwo(getDir, filterOdt), count)\n  pipeTwo(filterOdt(getDir(path)), count)(path)\n  pipeTwo(count(filterOdt(getDir(path))))\n```", "```js\ncountOdtFiles4(path) ===\n  pipeTwo(getDir, pipeTwo(filterOdt, count))(path)\n  pipeTwo(getDir(path), pipeTwo(filterOdt, count))\n  pipeTwo(filterOdt, count)(getDir(path))\n  pipeTwo(count(filterOdt(getDir(path))))\n```", "```js\nfunction pipeline(...fns) {\n  return (...args) => {\n    let result = fns[0](...args);\n    for (let i = 1; i < fns.length; i++) {\n      result = fns[i](result);\n    }\n    return result;\n  };\n}\npipeline(\n  getDir,\n  filterOdt,\n  count\n)(\"/home/fkereki/Documents\"); // still 4\n```", "```js\n// continued...\nfunction pipeline2(...fns) {\n  return fns.reduce(\n    (result, f) =>\n      (...args) =>\n        f(result(...args))\n  );\n}\n```", "```js\n// continued...\nfunction pipeline3(...fns) {\n  return fns.reduce(pipeTwo);\n}\n```", "```js\n// continued…\ntype FN = (...args: any[]) => any;\ntype FnsMatchPipe<FNS extends FN[]> =\n  1 extends FNS[\"length\"]\n    ? boolean\n    : FNS extends [\n        infer FN1st extends FN,\n        infer FN2nd extends FN,\n        ...infer FNRest extends FN[]\n      ]\n    ? Parameters<FN2nd> extends [ReturnType<FN1st>]\n      ? FnsMatchPipe<[FN2nd, ...FNRest]>\n      : never\n    : never;\n```", "```js\n// continued...\ntype Pipeline<FNS extends FN[]> =\n  boolean extends FnsMatchPipe<FNS>\n    ? 1 extends FNS[\"length\"]\n      ? FNS[0]\n      : FNS extends [\n          infer FNFIRST extends FN,\n          ...FN[],\n          infer FNLAST extends FN\n        ]\n      ? (...args: Parameters<FNFIRST>) => ReturnType<FNLAST>\n      : never\n    : never;\n```", "```js\n// continued...\nfunction pipeline<FNS extends FN[]>(\n  ...fns: FNS\n): Pipeline<FNS>;\nfunction pipeline<FNS extends FN[]>(...fns: FNS): FN {\n  return (...args: Parameters<FNS[0]>) => {\n    let result = fns[0](...args);\n    for (let i = 1; i < fns.length; i++) {\n      result = fns[i](result);\n    }\n    return result;\n  };\n}\nfunction pipeline2<FNS extends FN[]>(\n  ...fns: FNS\n): Pipeline<FNS>;\nfunction pipeline2<FNS extends FN[]>(...fns: FNS): FN {\n  return fns.reduce(\n    (result, f) =>\n      (...args) =>\n        f(result(...args))\n  );\n}\nfunction pipeline3<FNS extends FN[]>(\n  ...fns: FNS\n): Pipeline<FNS>;\nfunction pipeline3<FNS extends FN[]>(\n  ...fns: FNS\n): (...fns: FNS) => FN {\n  return fns.reduce(pipeTwo);\n}\n```", "```js\n$ ls -1 | grep \"odt$\" | tee /dev/tty | wc -l\n...the list of files with names ending in odt...\n4\n```", "```js\n// pipeline_debug.ts\nconst tee = <A>(arg: A) => {\n  console.log(arg);\n  return arg;\n};\n```", "```js\n// continued...\nconsole.log(\n  pipeline3(\n    getDir,\n    tee,\n    filterOdt,\n    tee,\n    count\n  )(\"/home/fkereki/Documents\")\n);\n...the list of all the files in the directory...\n...the list of files with names ending in odt...\n4\n```", "```js\n// continued...\nconst tee2 = <A>(arg: A, logger = console.log) => {\n  logger(arg);\n  return arg;\n};\n```", "```js\n// continued...\nconst tap = curry(<A>(fn: FN, x: A) => (fn(x), x));\n```", "```js\n// continued...\nconst tee3 = tap(console.log);\n```", "```js\n// continued...\nconst tap2 = (fn: FN) => <A>(x: A) => (fn(x), x);\n```", "```js\npipeline2(\n  addLogging(getDir),\n  addLogging(filterOdt),\n  addLogging(count)\n)(\"/home/fkereki/Documents\");\nentering getDir(/home/fkereki/Documents)\nexiting  getDir=> ...list of files...\nentering filterOdt(...list of files, again...)\nexiting  => ...list of .odt files...\nentering count(...list of .odt files ...)\nexiting  count=>4\n```", "```js\nconst countOdtFiles3 = (path: string): number =>\n  pipeTwo(pipeTwo(getDir, filterOdt), count)(path);\nconst countOdtFiles4 = (path: string): number =>\n  pipeTwo(getDir, pipeTwo(filterOdt, count))(path);\n```", "```js\n// pointfree.ts\nconst countOdtFiles3b = pipeTwo(\n  pipeTwo(getDir, filterOdt),\n  count\n);\nconst countOdtFiles4b = pipeTwo(\n  getDir,\n  pipeTwo(filterOdt, count)\n);\n```", "```js\nconst getLat = curry(getField)(\"lat\");\n```", "```js\nconst getLat = (obj) => curry(getField)(\"lat\")(obj);\n```", "```js\nconst getLat = (obj) => obj.lat;\n```", "```js\nconst isNegativeBalance = v => v.balance < 0;\n```", "```js\nconst isNegativeBalance2 = pipeline(getBalance,\n  isNegative);\n```", "```js\nconst getBalance = curry(getField)(\"balance\");\n```", "```js\nconst isNegative = (x: number): boolean => x < 0;\n```", "```js\nconst isNegative = curry(binaryOp(\">\"))(0);\n```", "```js\nconst isNegative = binaryOpRight(\"<\", 0);\n```", "```js\nconst isNegativeBalance2 = pipeline(\n  curry(getField)(\"balance\"),\n  curry(binaryOp(\">\"))(0)\n);\n```", "```js\nconst isNegativeBalance3 = pipeline(\n  curry(getField)(\"balance\"),\n  binaryOpRight(\"<\", 0)\n);\n```", "```js\nconst range = (start: number, stop: number): number[] =>\n  new Array(stop - start).fill(0).map((v, i) => start + i);\n```", "```js\nvar node = svg\n  .selectAll(\".node\")\n  .data(pack(root).leaves())\n  .enter()\n  .append(\"g\")\n  .attr(\"class\", \"node\")\n  .attr(\"transform\", function (d) {\n    return \"translate(\" + d.x + \",\" + d.y + \")\";\n  });\nnode\n  .append(\"circle\")\n  .attr(\"id\", function (d) {\n    return d.id;\n  })\n  .attr(\"r\", function (d) {\n    return d.r;\n  })\n  .style(\"fill\", function (d) {\n    return color(d.package);\n  });\n```", "```js\n// chaining.ts\nclass City {\n  name: string;\n  lat: number;\n  long: number;\n  constructor(name: string, lat: number, long: number) {\n    this.name = name;\n    this.lat = lat;\n    this.long = long;\n  }\n  getName() {\n    return this.name;\n  }\n  setName(newName: string) {\n    this.name = newName;\n  }\n  setLat(newLat: number) {\n    this.lat = newLat;\n  }\n  setLong(newLong: number) {\n    this.long = newLong;\n  }\n  getCoords() {\n    return [this.lat, this.long];\n  }\n}\n```", "```js\nconst myCity = new City(\n  \"Montevideo, Uruguay\",\n  -34.9011,\n  -56.1645\n);\nconsole.log(myCity.getCoords(), myCity.getName());\n// [ -34.9011, -56.1645 ] 'Montevideo, Uruguay'\n```", "```js\n// chainify.ts\nconst chainify = <OBJ extends { [key: string]: any }>(\n  obj: OBJ\n): Chainify<OBJ> =>\n  new Proxy(obj, {\n    get(target, property, receiver) {\n      if (typeof property === \"string\") {\n        if (typeof target[property] === \"function\") {\n          // requesting a method? return a wrapped version\n          return (...args: any[]) => {\n            const result = target[property](...args);\n            return result === undefined ? receiver :\n              result;\n          };\n        } else {\n          // an attribute was requested - just return it\n          return target[property];\n        }\n      } else {\n        return Reflect.get(target, property, receiver);\n      }\n    },\n  });\n```", "```js\n// continued...\ntype Chainify<A extends { [key: string]: any }> = {\n  [key in keyof A]: A[key] extends (...args: any[]) => any\n    ? void extends ReturnType<A[key]>\n      ? (...args: Parameters<A[key]>) => Chainify<A>\n      : (...args: Parameters<A[key]>) => ReturnType<A[key]>\n    : A[key];\n};\n```", "```js\nconst myCity2 = chainify(myCity);\nconsole.log(\n  myCity2\n    .setName(\"Pune, India\")\n    .setLat(18.5626)\n    .setLong(73.8087)\n    .getCoords(),\n  myCity.getName()\n);\n// [ 18.5626, 73.8087 ] 'Pune, India'\n```", "```js\nconst not = (fn) => (...args) => !fn(...args);\nconst positiveBalance = not(isNegativeBalance);\n```", "```js\nconst logicalNot = unaryOp(\"!\");\n```", "```js\nconst positiveBalance = compose(\n  logicalNot,\n  isNegativeBalance\n);\n```", "```js\nconst changeSign = unaryOp(\"-\");\npalabras.sort(compose(changeSign, spanishComparison));\n```", "```js\nconst countOdtFiles2 = (path: string): number =>\n  count(filterOdt(getDir(path)));\n```", "```js\nconst countOdtFiles2b = (path: string): number =>\n  compose(count, filterOdt, getDir)(path);\ncountOdtFiles2b(\"/home/fkereki/Documents\");\n// 4, no change here\n```", "```js\ncompose(count, filterOdt, getDir)(\"/home/fkereki/Documents\");\n```", "```js\nconst removeNonAlpha = (str: string): string =>\n  str.replace(/[^a-z]/gi, \" \");\nconst toUpperCase = demethodize(\n  String.prototype.toUpperCase\n);\nconst splitInWords = (str: string): string[] =>\n  str.trim().split(/\\s+/);\nconst arrayToSet = (arr: string[]): Set<string> =>\n  new Set(arr);\nconst setToList = (set: Set<string>): string[] =>\n  Array.from(set).sort();\n```", "```js\nconst getUniqueWords = compose(\n  setToList,\n  arrayToSet,\n  splitInWords,\n  toUpperCase,\n  removeNonAlpha\n);\n```", "```js\nconst GETTYSBURG_1_2 = `Four score and seven years ago\nour fathers brought forth on this continent, a new nation, conceived in liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long\nendure.`;\nconsole.log(getUniqueWords(GETTYSBURG_1_2));\n// Output: 43 words, namely\n  'A',           'AGO',       'ALL',\n  'AND',         'ANY',       'ARE',\n  'BROUGHT',     'CAN',       'CIVIL',\n  'CONCEIVED',   'CONTINENT', 'CREATED',\n  'DEDICATED',   'ENDURE',    'ENGAGED',\n  'EQUAL',       'FATHERS',   'FORTH',\n  'FOUR',        'GREAT',     'IN',\n  'LIBERTY',     'LONG',      'MEN',\n  'NATION',      'NEW',       'NOW',\n  'ON',          'OR',        'OUR',\n  'PROPOSITION', 'SCORE',     'SEVEN',\n  'SO',          'TESTING',   'THAT',\n  'THE',         'THIS',      'TO',\n  'WAR',         'WE',        'WHETHER',\n  'YEARS'\n```", "```js\nconst getUniqueWords1 = (str: string): string[] => {\n  const str1 = removeNonAlpha(str);\n  const str2 = toUpperCase(str1);\n  const arr1 = splitInWords(str2);\n  const set1 = arrayToSet(arr1);\n  const arr2 = setToList(set1);\n  return arr2;\n};\nconsole.log(getUniqueWords1(GETTYSBURG_1_2));\n// Output: the same 43 words\n```", "```js\nconst getUniqueWords2 = (str: string): string[] =>\n  setToList(\n    arrayToSet(\n      splitInWords(toUpperCase(removeNonAlpha(str)))\n    )\n  );\nconsole.log(getUniqueWords2(GETTYSBURG_1_2));\n// Output: the same 43 words\n```", "```js\n// compose.ts\nconst pipeTwo =\n  <F extends FN, G extends FN>(f: F, g: G) =>\n  (...args: Parameters<F>): ReturnType<G> =>\n    g(f(...args));\nconst composeTwo =\n  <F extends FN, G extends FN>(f: F, g: G) =>\n  (...args: Parameters<G>): ReturnType<F> =>\n    f(g(...args));\n```", "```js\n// continued...\nconst composeTwoByFlipping = flipTwo(pipeTwo);\n```", "```js\nconst getUniqueWords3 = composeTwo(\n  setToList,\n  composeTwo(\n    arrayToSet,\n    composeTwo(\n      splitInWords,\n      composeTwo(toUpperCase, removeNonAlpha)\n    )\n  )\n);\n```", "```js\n// continued...\nfunction compose(...fns) {\n  return (...args) => {\n    let result = fns[fns.length - 1](...args);\n    for (let i = fns.length - 2; i >= 0; i--) {\n      result = fns[i](result);\n    }\n    return result;\n  };\n}\nconsole.log(\n  compose(\n    setToList,\n    arrayToSet,\n    splitInWords,\n    toUpperCase,\n    removeNonAlpha\n  )(GETTYSBURG_1_2)\n);\n// same output as earlier\n```", "```js\n// continued...\nfunction compose1(...fns) {\n  return pipeline(...fns.reverse());\n}\n```", "```js\n// continued...\nfunction compose2(...fns) {\n  return fns.reduceRight(\n    (f, g) => (...args) => g(f(...args))\n  );\n}\nconsole.log(\n  compose2(\n    setToList,\n    arrayToSet,\n    splitInWords,\n    toUpperCase,\n    removeNonAlpha\n  )(GETTYSBURG_1_2)\n);\n// still same output\n```", "```js\n// continued...\nfunction compose3(...fns) {\n  return fns.reduceRight(pipeTwo);\n}\n```", "```js\n// compose.ts\ntype FnsMatchComp<FNS extends FN[]> =\n  1 extends FNS[\"length\"]\n    ? boolean\n    : FNS extends [\n        ...infer FNInit extends FN[],\n        infer FNPrev extends FN,\n        infer FNLast extends FN\n      ]\n    ? Parameters<FNPrev> extends [ReturnType<FNLast>]\n      ? FnsMatchComp<[...FNInit, FNPrev]>\n      : never\n    : never;\n```", "```js\n// continued...\ntype Compose<FNS extends FN[]> =\n  boolean extends FnsMatchComp<FNS>\n    ? 1 extends FNS[\"length\"]\n      ? FNS[0]\n      : FNS extends [\n          infer FNFIRST extends FN,\n          ...FN[],\n          infer FNLAST extends FN\n        ]\n      ? (...args: Parameters<FNLAST>) =>\n        ReturnType<FNFIRST>\n      : never\n    : never;\n```", "```js\nfunction compose<FNS extends FN[]>(\n  ...fns: FNS\n): Compose<FNS>;\nfunction compose<FNS extends FN[]>(...fns: FNS): FN {\n  return (...args: Parameters<FNS[0]>) => {\n    let result = fns[fns.length - 1](...args);\n    for (let i = fns.length - 2; i >= 0; i--) {\n      result = fns[i](result);\n    }\n    return result;\n  };\n}\n```", "```js\n// transducing.ts\nconst testOdd = (x: number): boolean => x % 2 === 1;\nconst testUnderFifty = (x: number): boolean => x < 50;\nconst duplicate = (x: number): number => x + x;\nconst addThree = (x: number): number => x + 3;\n```", "```js\n// continued...\nconst myArray = [22, 9, 60, 24, 11, 63];\nconst a0 = myArray\n  .filter(testOdd)\n  .map(duplicate)\n  .filter(testUnderFifty)\n  .map(addThree);\nconsole.log(a0);\n// Output: [ 21, 25 ]\n```", "```js\nfor each transformation to be applied:\n    for each element in the input list:\n        apply the transformation to the element\n```", "```js\nfor each element in the input list:\n    for each transformation to be applied:\n        apply the transformation to the element\n```", "```js\n// continued...\nconst mapTR =\n  <V, W>(fn: (x: V) => W) =>\n  <A>(reducer: (am: A, wm: W) => A) =>\n  (accum: A, value: V): A =>\n    reducer(accum, fn(value));\nconst filterTR =\n  <V>(fn: (x: V) => boolean) =>\n  <A>(reducer: (af: A, wf: V) => A) =>\n  (accum: A, value: V): A =>\n    fn(value) ? reducer(accum, value) : accum;\n```", "```js\n// continued...\nconst testOddR = filterTR(testOdd);\nconst testUnderFiftyR = filterTR(testUnderFifty);\nconst duplicateR = mapTR(duplicate);\nconst addThreeR = mapTR(addThree);\n```", "```js\n// continued...\nconst addToArray = (a: any[], v: any): any[] => {\n  a.push(v);\n  return a;\n};\nconst a1 = myArray.reduce(\n  testOddR(\n    duplicateR(testUnderFiftyR(addThreeR(addToArray)))\n  ),\n  []\n);\nconsole.log(a1);\n// Output: [ 21, 25 ], again\n```", "```js\n// continued...\nconst transduce = <A>(arr: A[], fns: FN[]) =>\n  arr.reduce(compose(...fns)(addToArray), []);\nconsole.log(\n  transduce(myArray, [\n    testOddR,\n    duplicateR,\n    testUnderFiftyR,\n    addThreeR,\n  ])\n);\n// Output: [ 21, 25 ], yet again\n```", "```js\n// continued...\nconst transduce2 = <A>(\n  arr: A[],\n  fns: FN[],\n  reducer: FN = addToArray,\n  initial: any = []\n) => arr.reduce(compose(...fns)(reducer), initial);\nconsole.log(\n  transduce2(myArray, [\n    testOddR,\n    duplicateR,\n    testUnderFiftyR,\n    addThreeR,\n  ])\n);\n// Output: [ 21, 25 ], always\n```", "```js\n// continued...\nconsole.log(\n  transduce2(\n    myArray,\n    [testOddR, duplicateR, testUnderFiftyR, addThreeR],\n    (acc, value) => acc + value,\n    0\n  )\n);\n// 46\n```", "```js\n// pipetwo.test.ts\ndescribe(\"pipeTwo\", function () {\n  it(\"works with single arguments\", () => {\n    const fn1 = jest.fn().mockReturnValue(1);\n    const fn2 = jest.fn().mockReturnValue(2);\n    const pipe = pipeTwo(fn1, fn2);\n    const result = pipe(22);\n    expect(fn1).toHaveBeenCalledTimes(1);\n    expect(fn2).toHaveBeenCalledTimes(1);\n    expect(fn1).toHaveBeenCalledWith(22);\n    expect(fn2).toHaveBeenCalledWith(1);\n    expect(result).toBe(2);\n  });\n  it(\"works with multiple arguments\", () => {\n    const fn1 = jest.fn().mockReturnValue(11);\n    const fn2 = jest.fn().mockReturnValue(22);\n    const pipe = pipeTwo(fn1, fn2);\n    const result = pipe(12, 4, 56);\n    expect(fn1).toHaveBeenCalledTimes(1);\n    expect(fn2).toHaveBeenCalledTimes(1);\n    expect(fn1).toHaveBeenCalledWith(12, 4, 56);\n    expect(fn2).toHaveBeenCalledWith(11);\n    expect(result).toBe(22);\n  });\n});\n```", "```js\n// pipeline.test.ts\ndescribe(\"pipeline\", function () {\n  it(\"works with a single function\", () => {\n    const fn1 = jest.fn().mockReturnValue(11);\n    const pipe = pipeline(fn1);\n    const result = pipe(60);\n    expect(fn1).toHaveBeenCalledTimes(1);\n    expect(fn1).toHaveBeenCalledWith(60);\n    expect(result).toBe(11);\n  });\n  it(\"works with single arguments\", () => {\n    const fn1 = jest.fn().mockReturnValue(1);\n    const fn2 = jest.fn().mockReturnValue(2);\n    const pipe = pipeline(fn1, fn2);\n    const result = pipe(22);\n    expect(fn1).toHaveBeenCalledTimes(1);\n    expect(fn2).toHaveBeenCalledTimes(1);\n    expect(fn1).toHaveBeenCalledWith(22);\n    expect(fn2).toHaveBeenCalledWith(1);\n    expect(result).toBe(2);\n  });\n  it(\"works with multiple arguments\", () => {\n    const fn1 = jest.fn().mockReturnValue(11);\n    const fn2 = jest.fn().mockReturnValue(22);\n    const pipe = pipeline(fn1, fn2);\n    const result = pipe(12, 4, 56);\n    expect(fn1).toHaveBeenCalledTimes(1);\n    expect(fn2).toHaveBeenCalledTimes(1);\n    expect(fn1).toHaveBeenCalledWith(12, 4, 56);\n    expect(fn2).toHaveBeenCalledWith(11);\n    expect(result).toBe(22);\n  });\n  it(\"works with 4 functions, multiple arguments\", () => {\n    const fn1 = jest.fn().mockReturnValue(111);\n    const fn2 = jest.fn().mockReturnValue(222);\n    const fn3 = jest.fn().mockReturnValue(333);\n    const fn4 = jest.fn().mockReturnValue(444);\n    const pipe = pipeline(fn1, fn2, fn3, fn4);\n    const result = pipe(24, 11, 63);\n    expect(fn1).toHaveBeenCalledTimes(1);\n    expect(fn2).toHaveBeenCalledTimes(1);\n    expect(fn3).toHaveBeenCalledTimes(1);\n    expect(fn4).toHaveBeenCalledTimes(1);\n    expect(fn1).toHaveBeenCalledWith(24, 11, 63);\n    expect(fn2).toHaveBeenCalledWith(111);\n    expect(fn3).toHaveBeenCalledWith(222);\n    expect(fn4).toHaveBeenCalledWith(333);\n    expect(result).toBe(444);\n  });\n});\n```", "```js\n// compose.test.ts\ndescribe(\"compose\", function () {\n  // other tests, omitted here\n  it(\"works with 4 functions, multiple arguments\", () => {\n    const fn1 = jest.fn().mockReturnValue(111);\n    const fn2 = jest.fn().mockReturnValue(222);\n    const fn3 = jest.fn().mockReturnValue(333);\n    const fn4 = jest.fn().mockReturnValue(444);\n    const comp = compose(fn4, fn3, fn2, fn1);\n    const result = comp(24, 11, 63);\n    expect(fn1).toHaveBeenCalledTimes(1);\n    expect(fn2).toHaveBeenCalledTimes(1);\n    expect(fn3).toHaveBeenCalledTimes(1);\n    expect(fn4).toHaveBeenCalledTimes(1);\n    expect(fn1).toHaveBeenCalledWith(24, 11, 63);\n    expect(fn2).toHaveBeenCalledWith(111);\n    expect(fn3).toHaveBeenCalledWith(222);\n    expect(fn4).toHaveBeenCalledWith(333);\n    expect(result).toBe(444);\n  });\n});\n```", "```js\n// chaining.test.ts\nclass City {\n// as above\n}\nlet myCity: City;\nlet myCity2: Chainify<City>;\ndescribe(\"chainify\", function () {\n  beforeEach(() => {\n    myCity = new City(\n      \"Montevideo, Uruguay\",\n      -34.9011,\n      -56.1645\n    );\n    myCity2 = chainify(myCity);\n  });\n  it(\"doesn't affect get functions\", () => {\n    expect(myCity2.getName()).toBe(\"Montevideo, Uruguay\");\n    expect(myCity2.getCoords()[0]).toBe(-34.9011);\n    expect(myCity2.getCoords()[1]).toBe(-56.1645);\n  });\n  it(\"doesn't affect getting attributes\", () => {\n    expect(myCity2.name).toBe(\"Montevideo, Uruguay\");\n    expect(myCity2.lat).toBe(-34.9011);\n    expect(myCity2.long).toBe(-56.1645);\n  });\n  it(\"returns itself from setting functions\", () => {\n    //    expect(myCity2.setName(\"Other\n      name\")).toBe(myCity2);\n    expect(myCity2.setLat(11)).toBe(myCity2);\n    expect(myCity2.setLong(22)).toBe(myCity2);\n  });\n  it(\"allows chaining\", () => {\n    const newCoords = myCity2\n      .setName(\"Pune, India\")\n      .setLat(18.5626)\n      .setLong(73.8087)\n      .getCoords();\n    expect(myCity2.name).toBe(\"Pune, India\");\n    expect(newCoords[0]).toBe(18.5626);\n    expect(newCoords[1]).toBe(73.8087);\n  });\n});\n```", "```js\n// transducing.test.ts\ndescribe(\"transducing\", () => {\n  it(\"works with several functions\", () => {\n    expect(\n      transduce(myArray, [\n        testOddR,\n        duplicateR,\n        testUnderFiftyR,\n        addThreeR,\n      ])\n    ).toEqual([21, 25]);\n  });\n  it(\"works with just one function at all\", () => {\n    expect(transduce(myArray, [testOddR])).toEqual([\n      9, 11, 63,\n    ]);\n    expect(transduce(myArray, [addThreeR])).toEqual([\n      25, 12, 63, 27, 14, 66,\n    ]);\n  });\n  it(\"works with just mapping\", () => {\n    expect(\n      transduce(myArray, [addThreeR, duplicateR])\n    ).toEqual([50, 24, 126, 54, 28, 132]);\n  });\n  it(\"works with just filtering\", () => {\n    expect(\n      transduce(myArray, [testOddR, testUnderFiftyR])\n    ).toEqual([9, 11]);\n  });\n  it(\"works with special reducer\", () => {\n    expect(\n      transduce2(\n        myArray,\n        [testOddR, duplicateR, testUnderFiftyR, addThreeR],\n        (acc, value) => acc + value,\n        0\n      )\n    ).toBe(46);\n  });\n});\n```", "```js\nconsole.log(headline(\"Alice's ADVENTURES in WoNdErLaNd\"));\n// Alice's Adventures In Wonderland\n```", "```js\nconst allTasks = {\n  date: \"2017-09-22\",\n  byPerson: [\n    {\n      responsible: \"EG\",\n      tasks: [\n        { id: 111, desc: \"task 111\", done: false },\n        { id: 222, desc: \"task 222\", done: false },\n      ],\n    },\n    {\n      responsible: \"FK\",\n      tasks: [\n        { id: 555, desc: \"task 555\", done: false },\n        { id: 777, desc: \"task 777\", done: true },\n        { id: 999, desc: \"task 999\", done: false },\n      ],\n    },\n    {\n      responsible: \"ST\",\n      tasks: [{ id: 444, desc: \"task 444\", done: true }],\n    },\n  ],\n};\n```", "```js\nfunction getSomeResults(things) {\n  return sort(group(filter(select(things))));\n}\n```", "```js\nconst addToArray = (a, v) => [...a, v];\n```"]