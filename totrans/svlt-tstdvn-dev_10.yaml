- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-Driving API Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SvelteKit makes creating API endpoints a breeze. This chapter looks at how you
    can use tests to drive and prove your API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding chapter, you saw how we could push business logic out of SvelteKit
    and into plain JavaScript. We can make use of the extracted `birthdayRepository`
    object in the new API endpoints. We will now add endpoints for creating, updating,
    and getting birthdays using the `addNew`, `replace`, and `getAll` functions from
    the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.1* shows how our system design is shaping up. The endpoints we’ll
    create in this chapter are very lightweight, thanks to the fully specified `birthdayRepository`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – SvelteKit components flowing into the inner system](img/Figure_10.1_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – SvelteKit components flowing into the inner system
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service test with Playwright
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an API endpoint for retrieving data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an API endpoint for saving data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an API endpoint for updating data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have learned how to implement API endpoints
    using test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service test with Playwright
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve already seen how Playwright can be used to create end-to-end tests that
    drive the application through the web browser interface. It can also be used to
    drive the API endpoints directly, and that’s what you’ll learn to do in this section.
    The benefit of writing up-front Playwright API tests is that we can very carefully
    plan out how our API will look.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write just a single test named `creating and reading a birthday`. It
    will do two things: first, create a request to `POST` `/api/birthdays` that will
    create a birthday. Then we’ll call `GET` `/api/birthdays` and check that the previously
    created birthday is returned in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `tests/api/birthdays.test.js` with the following content,
    which is the first half of that test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code snippet uses the test’s request parameter. It has a `request.post`
    method that we invoke to make the API request. The `data` prop is the JSON object
    we want to send across. Playwright takes care of converting that into an HTTP
    request and response. The request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The returned object, which we call `newBirthday`, has an `ok` method that we
    call to figure out whether the endpoint returned a `200` response.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing assertions into test actions
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, all our tests have been structured in the *Arrange-Act-Assert*
    format. When it comes to Playwright tests, it’s okay to occasionally have repeated
    cycles of *Act*-*Assert*, ending up with something like *Arrange-Act-Assert-Act-Assert…*.
  prefs: []
  type: TYPE_NORMAL
- en: I wouldn’t do that in my unit tests, but in end-to-end and service tests, it
    can sometimes make sense because they help the tests play out **user scenarios**.
    The tests follow the steps that a typical user would take. The assertions sprinkled
    throughout the test serve as checkpoints to check whether the test is on the right
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, complete the test with a call to the GET `/api/birthdays` endpoint. Of
    interest here is the use of `expect.anything()` to say *I expect an ID back, but
    I don’t care what* *it is*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the test; go ahead and run the test and check that it currently
    fails (since the endpoint doesn’t exist yet).
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding data clashes in Playwright tests
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example used the name `Nyx` in the test example. This name hasn’t
    been used before, but if you had used one of the previous names, such as `Hercules`
    or `Athena`, you would have seen other tests fail.
  prefs: []
  type: TYPE_NORMAL
- en: The current Playwright test suite does not clear the test database between individual
    test runs. Here, we solved the issue by ensuring that each of our tests uses independent
    pieces of data.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach would be to always clean down the database before each
    test or test suite, similar to how the Vitest unit tests are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an advantage to the first approach, however: you can point Playwright
    to deployed environments that are already primed with data that you don’t control
    and still expect the tests to pass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a second test for updating a birthday using the `PUT` HTTP verb. The request
    will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start with the first half of the test, given as follows. Notice how this pulls
    out the returned `id` field so that we can use it in the second half of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the second half of the test, which performs the `PUT` request using
    `id` and checks the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This last expectation doesn’t make use of `expect.anything`. Instead, it checks
    that `id` remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the two Playwright tests, covering the three new endpoints. In
    the next section, we’ll use the `GET` request to retrieve all the birthdays from
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an API endpoint for retrieving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we get on to the fun bit: introducing new functionality for the API. In
    a SvelteKit application, a `GET` request is very directly specified by creating
    a function named `GET` inside of a route.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we won’t use it for our endpoint, this function has a `params` argument
    that contains the `route` parameter. You’ll see this later in the chapter when
    we implement the `PUT` request in the *Adding an API endpoint for updating* *data*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Valid responses from the endpoint must be proper response objects. We can use
    SvelteKit’s JSON helper to define a valid JSON response. Error responses are handled
    by throwing an exception that is built by calling SvelteKit’s error helper. We’ll
    use both of these now.
  prefs: []
  type: TYPE_NORMAL
- en: The json helper in Node versions below 18
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the `json` function may fail with a `Response is not defined` error.
    If you see this error when implementing the following tests, you can install the
    **node-fetch** package ([https://github.com/node-fetch/node-fetch](https://github.com/node-fetch/node-fetch))
    and ensure it loads as part of your Vitest setup files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining a new test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new test file, `src/routes/api/birthdays/server.test.js`, that begins
    with the following `import` statements. The `birthdayRepository` module is imported
    so that the repository can be populated before calling the `GET` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next define the following helper method, `bodyOfResponse`, which we’ll use
    in the first test to pull out data from the HTTP response. This can go just below
    the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new `describe` block with the following test. It creates two
    birthdays and checks that they are returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing array responses
  prefs: []
  type: TYPE_NORMAL
- en: I find that when I’m testing array objects, it’s always best to use two (and
    sometimes three) items in the list rather than just one. That way, it’s clear
    that the test is operating on lists of items, not just single items.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that test pass, create a new file named `src/routes/api/birthdays/+server.js`
    with the following content. The implementation works like this: it passes the
    request right through to the store using the `getAll` function and then wraps
    the response with a call to SvelteKit’s `json` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the `GET` request. Next, we’ll work on the `POST` and `PUT` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an API endpoint for saving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll start by adding the `POST` request handler function for
    saving data and then continue with the `PUT` function, in its own route file,
    for updating data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with a test helper:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `src/factories/request.js`, with the following content.
    This will be used by both the `POST` and `PUT` functions to read the data of the
    request. SvelteKit will pass a `Request` argument. The only bit of this we need
    to provide is the `json` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Providing minimal versions of collaborating objects
  prefs: []
  type: TYPE_NORMAL
- en: SvelteKit passes the `Request` objects into our request handler functions. But
    for our unit tests we don’t need fully formed `Request` objects, we just need
    an object that implements the parts of the interface that we use. Our application
    code doesn’t use anything but the `json` method for reading the request body in
    JSON format, so that’s the only method we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now move to `src/api/birthdays/server.test.js` and add an `import` statement
    for the `createRequest` method. Also, update the `+server.js` import to include
    the `POST` request handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a new `describe` block for the `POST` function, just below the `describe`
    block for the `GET` function, and include this one test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, first update the import in `src/api/birthdays/+server.js`
    to include the `addNew` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue by adding a definition for `POST`, as shown in the following code
    block. After this change, your test should pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have data saved into the repository, it’s time to check the HTTP
    response. We want any API caller to receive the same data back. The following
    test makes use of the `toContain` matcher rather than `toEqual`. That’s because
    we already know that the response will contain an `id` field that isn’t relevant
    to this test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing the presence of an id field
  prefs: []
  type: TYPE_NORMAL
- en: Why is the `id` field not included in the expectation of this test? Because
    it has a different lifecycle from the other data. This test verifies that the
    user-provided information is stored. But the `id` field is auto-generated, so
    it belongs to a separate test. I’ve omitted it here because it’s already tested
    in both the repository and the Playwright API test, but you may feel more comfortable
    including the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, add a `return` value to the function that uses the `json`
    function import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final test for the `POST` request handler is to check that the function
    throws an exception if the data is invalid. Throwing errors can complicate tests:
    here, the test uses a call to `expect.hasAssertions` to ensure that Vitest will
    fail the test if the call does *not* raise an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try running this test now: you’ll see the `expected any number of assertions,
    but got none` failure. That is courtesy of the `hasAssertions` statement at the
    top of the test.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the hasAssertions helper
  prefs: []
  type: TYPE_NORMAL
- en: 'Try deleting the `expect.hasAssertions` line from the test. You will notice
    that the test already passes. That’s because the expectations were never met.
    This is the point of the `hasAssertions` call: it is useful in tests that rely
    on having expectations within `catch` blocks that won’t be called until you implement
    the exception-throwing behavior in your application code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that pass, first update the `import` statement in `src/api/birthdays/+server.js`
    to include the `error` helper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then update the `POST` function to re-package any errors from the repository
    into an `error` object that’s then thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the `POST` request handler for inserting new birthdays; the next
    section completes the chapter with the addition of the `PUT` request handler for
    updating existing birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an API endpoint for updating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of the puzzle is to add a `PUT` request handler function for
    dealing with updates. Similar to the `POST` function, we must provide the request
    body using the `createRequest` helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form of our `PUT` request means that `id` is passed as a parameter in the
    URL, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a reminder of how the URL must be passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To make SvelteKit register the `abc123` value as a parameter, we need to create
    a new route directory at `src/routes/api/birthday/[id]`. SvelteKit will then know
    that `abc123` matches the `[id]` bit of the directory path. The directory itself
    will then contain the `+server.js` file and its tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `src/routes/api/birthday/[id]/server.test.js` and add
    the following imports. This has everything we’ve used previously for the `GET`
    and `POST` functions, together with an import for the `PUT` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create this new `describe` block. It contains a `beforeEach` block that
    not only clears the repository but inserts a new item, ready for editing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we get to the first test, add the following helper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the first test, as shown here. It mimics SvelteKit’s call semantics
    by passing a new `params` object into the handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, create a new file named `src/routes/api/birthday/[id]/+server.js`
    with the following content. This should immediately make the test pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, we’ll begin by repeating a helper from the `GET` tests.
    Add the `bodyOfResponse` function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the next test, which uses this function to check the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, start by adding the import for `json` in the application
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the `PUT` function to return the result of the repository action,
    just as we did with the `POST` request handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final test repeats the mechanics of the final `POST` test, checking what
    happens if the data is invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, start by updating the `import` statement in the application
    code to include the `error` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, include the guard clause in the `PUT` function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it. If you run both the Vitest and Playwright tests now, you should find
    they all pass.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown how to make quick work of API endpoints. Playwright tests
    can be used to specify how an API should behave, and the unit tests can be used
    to drive the design and ensure that we end up with minimal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter completes the API story arc: we will update the form actions
    to use the new API endpoints rather than going directly to the repository.'
  prefs: []
  type: TYPE_NORMAL
