<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Knowing Your Library</h1></div></div></div><p>
<strong>ES6</strong> has added lots of new properties and methods to built-in<a id="id52" class="indexterm"/> JavaScript objects, so that the programmer can do cumbersome tasks easily. These new functionalities aim to help the developers get rid of using <a id="id53" class="indexterm"/>hacks and error-prone techniques to do various operations related to numbers, strings, and arrays. In this chapter, we will look at all the new functionalities added by ES6 to the native objects.</p><p>In this chapter, we'll cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The new properties and methods of the <code class="literal">Number</code> object</li><li class="listitem" style="list-style-type: disc">Representing the numeric constants as binary or octal</li><li class="listitem" style="list-style-type: disc">The new properties and methods of the <code class="literal">Math</code> object</li><li class="listitem" style="list-style-type: disc">Creating the multiline strings and the new methods of the <code class="literal">String</code> object</li><li class="listitem" style="list-style-type: disc">The new properties and methods of <code class="literal">Array</code> object</li><li class="listitem" style="list-style-type: disc">What are Maps and Sets?</li><li class="listitem" style="list-style-type: disc">Using array buffers and typed arrays</li><li class="listitem" style="list-style-type: disc">The new properties and methods of <code class="literal">Object</code> object</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Working with numbers</h1></div></div></div><p>ES6 adds new ways of creating numbers and new properties to the <code class="literal">Number</code> object to make working with numbers easier. The <code class="literal">Number</code> object was enhanced in ES6 to make it easier to create <a id="id54" class="indexterm"/>mathematically rich applications, and prevent the common misconceptions that caused the errors. ES6 also provides new ways to do things that were already possible in<a id="id55" class="indexterm"/> ES5, such as representing the numeric constants as octal.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>JavaScript represents the numbers as base 10 decimals. The numeric constants are, by default, interpreted as base 10 decimals.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>The binary notation</h2></div></div></div><p>In ES5, there was no native way to<a id="id56" class="indexterm"/> represent the numeric constants as binary. But in ES6, you can prefix the<a id="id57" class="indexterm"/> numeric constants using the <code class="literal">0b</code> token to make JavaScript interpret them as binary.</p><p>Here is an example:</p><div><pre class="programlisting">let a = 0b00001111;
let b = 15;

console.log(a === b);
console.log(a);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">true
15</pre></div><p>Here, <code class="literal">0b00001111</code> is a binary representation of 15, base 10 decimal.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>The octal notation</h2></div></div></div><p>In ES5, to represent a numeric <a id="id58" class="indexterm"/>constant as octal, we needed to prefix the<a id="id59" class="indexterm"/> numeric constant using <code class="literal">0</code>. For example, take a look at the following:</p><div><pre class="programlisting">var a = 017;
var b = 15;

console.log(a === b);
console.log(a);</pre></div><p>The output is as the following:</p><div><pre class="programlisting">true
15</pre></div><p>But often, programmers new to JavaScript, get confused with the octal representations as the decimal number with <code class="literal">0</code> at the front. For example, they think <code class="literal">017</code> is same as <code class="literal">17</code>. Therefore, to remove this confusion, ES6 lets us prefix the numeric constants using <code class="literal">0o</code> to make JavaScript interpret them as octal.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">let a = 0o17;
let b = 15;

console.log(a === b);
console.log(a);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">true
15</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>The Number.isInteger(number) method</h2></div></div></div><p>JavaScript numbers are stored as the 64-bit, floating-point numbers. So the integers in JavaScript are the<a id="id60" class="indexterm"/> floating-point numbers without a decimal fraction, or a decimal fraction with all 0's.</p><p>In ES5, there was no built-in <a id="id61" class="indexterm"/>way to check whether a number is an integer or not. ES6 adds a new method to the <code class="literal">Number</code> object called as <code class="literal">isInteger()</code>, which takes a number and returns <code class="literal">true</code> or <code class="literal">false,</code> depending on weather the number is an integer or not.</p><p>Here is an example code:</p><div><pre class="programlisting">let a = 17.0;
let b = 1.2;

console.log(Number.isInteger(a));
console.log(Number.isInteger(b));</pre></div><p>The output is as follows:</p><div><pre class="programlisting">true
false</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>The Number.isNaN(value) method</h2></div></div></div><p>In ES5, there was no way to<a id="id62" class="indexterm"/> check whether a variable<a id="id63" class="indexterm"/> holds the <code class="literal">NaN</code> value or not.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>The global <code class="literal">isNaN()</code> function is<a id="id64" class="indexterm"/> used to check whether a value is a number or not. If the value is not a number, then it returns <code class="literal">true</code>, otherwise it returns <code class="literal">false</code>.</p></div></div><p>So ES6 introduced a new method for the <code class="literal">Number</code> object called as <code class="literal">isNaN()</code> to check whether a value is <code class="literal">NaN</code> or not. Here is an example, which demonstrates <code class="literal">Number.isNaN()</code> and also explains how it is different from the global <code class="literal">isNaN()</code> function:</p><div><pre class="programlisting">let a = "NaN";
let b = NaN;
let c = "hello";
let d = 12;

console.log(Number.isNaN(a));
console.log(Number.isNaN(b));
console.log(Number.isNaN(c));
console.log(Number.isNaN(d));

console.log(isNaN(a));
console.log(isNaN(b));
console.log(isNaN(c));
console.log(isNaN(d));</pre></div><p>The output is as follows:</p><div><pre class="programlisting">false
true
false
false
true
true
true
false</pre></div><p>Here you can<a id="id65" class="indexterm"/> see that <code class="literal">Number.isNaN()</code> method returns <code class="literal">true</code> only if the passed value is exactly <code class="literal">NaN</code>.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>You might ask, why<a id="id66" class="indexterm"/> not use <code class="literal">==</code> or the <code class="literal">===</code> operator instead of the <code class="literal">Number.isNaN(value)</code> method? The <code class="literal">NaN</code> value is the only value that is not equal to itself, that is, the expression <code class="literal">NaN==NaN</code> or <code class="literal">NaN===NaN</code> will return <code class="literal">false</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>The Number.isFinite(number) method</h2></div></div></div><p>In ES5 there was no<a id="id67" class="indexterm"/> built-in way to check whether a value is a<a id="id68" class="indexterm"/> finite number.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>The global <code class="literal">isFinite()</code> function takes<a id="id69" class="indexterm"/> a value and checks whether it's a finite number or not. But unfortunately, it also returns <code class="literal">true</code> for values that convert to a <code class="literal">Number</code> type.</p></div></div><p>So ES6 introduced the <code class="literal">Number.isFinite()</code> method, which resolves the issue of the <code class="literal">window.isFinite()</code> function. Here is an example to demonstrate this:</p><div><pre class="programlisting">console.log(isFinite(10));
console.log(isFinite(NaN));
console.log(isFinite(null));
console.log(isFinite([]));

console.log(Number.isFinite(10));
console.log(Number.isFinite(NaN));
console.log(Number.isFinite(null));
console.log(Number.isFinite([]));</pre></div><p>The<a id="id70" class="indexterm"/> output<a id="id71" class="indexterm"/> is as follows:</p><div><pre class="programlisting">true
false
true
true
true
false
false
false</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>The Number.isSafeInteger(number) method</h2></div></div></div><p>The JavaScript numbers are stored as 64-bit floating-point numbers, following the international IEEE 754 standard. This format stores numbers in 64 bits, where the number (the fraction) is<a id="id72" class="indexterm"/> stored in 0 to 51 bits, the <a id="id73" class="indexterm"/>exponent in 52 to 62 bits, and the sign in the last bit.</p><p>So in JavaScript, safe integers are those numbers that are not needed to be rounded to some other integer to fit in the IEEE 754 representation. Mathematically, the numbers from -(2<sup>53</sup>-1) to (2<sup>53</sup>-1) are considered as safe integers.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">console.log(Number.isSafeInteger(156));
console.log(Number.isSafeInteger('1212'));
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER));
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1));
console.log(Number.isSafeInteger(Number.MIN_SAFE_INTEGER));
console.log(Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1));</pre></div><p>The output is as follows:</p><div><pre class="programlisting">true
false
true
false
true
false</pre></div><p>Here, <code class="literal">Number.MAX_SAFE_INTEGER</code> and <code class="literal">Number.MIN_SAFE_INTEGER</code> are constant values, introduced in <a id="id74" class="indexterm"/>ES6, representing (2<sup>53</sup>-1) and -(2<sup>53</sup>-1) respectively.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>The Number.EPSILON property</h2></div></div></div><p>JavaScript uses such binary floating-point representation that the computers fail to accurately represent, numbers like 0.1, 0.2, 0.3, and so on. When your code is executed, numbers like 0.1 are rounded to the nearest number in<a id="id75" class="indexterm"/> that format, which results in small rounding error.</p><p>Consider this example:</p><div><pre class="programlisting">console.log(0.1 + 0.2 == 0.3);
console.log(0.9 - 0.8 == 0.1);
console.log(0.1 + 0.2);
console.log(0.9 - 0.8);</pre></div><p>The output is as follows:</p><div><pre class="programlisting">false
false
0.30000000000000004
0.09999999999999998</pre></div><p>The <code class="literal">Number.EPSILON</code> property was introduced in ES6, which has a value of approximately 2<sup>-52</sup>. This value represents a reasonable margin of error when comparing the floating-point numbers. Using this number, we can create a custom function to compare the floating-point numbers by ignoring the minimal rounding errors.</p><p>Here is an example code:</p><div><pre class="programlisting">functionepsilonEqual(a, b)
{
  return Math.abs(a - b) &lt;Number.EPSILON;
}

console.log(epsilonEqual(0.1 + 0.2, 0.3));
console.log(epsilonEqual(0.9 - 0.8, 0.1));</pre></div><p>The output is as follows:</p><div><pre class="programlisting">true
true</pre></div><p>Here, <code class="literal">epsilonEqual()</code> is the custom function that we build to compare whether the two values are equal or not. Now, the output is as expected.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>To learn more<a id="id76" class="indexterm"/> about this behavior of JavaScript and the floating-point arithmetic, visit <a class="ulink" href="http://floating-point-gui.de/">http://floating-point-gui.de/</a>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Doing Math</h1></div></div></div><p>ES6 adds a lot of new methods to the <code class="literal">Math</code> object, related to trigonometry, arithmetic, and miscellaneous. This lets the developers use native methods instead of external math libraries. Native<a id="id77" class="indexterm"/> methods are optimized for performance, and have better decimal precision.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Trigonometry related operations</h2></div></div></div><p>Here is an example <a id="id78" class="indexterm"/>code, which shows the entire trigonometry-related methods that are added to the <code class="literal">Math</code> object:</p><div><pre class="programlisting">
<code class="literal">console.log(Math.sinh(0));    //hyberbolic</code> <code class="literal">sine</code> <code class="literal">of</code> <code class="literal">a</code> <code class="literal">value</code>
<code class="literal">console.log(Math.cosh(0));    //hyberbolic</code> <code class="literal">cosine</code> <code class="literal">of</code> <code class="literal">a</code> <code class="literal">value</code>
<code class="literal">console.log(Math.tanh(0));    //hyberbolic</code> <code class="literal">tangent</code> <code class="literal">of</code> <code class="literal">a</code> <code class="literal">value</code>
<code class="literal">console.log(Math.asinh(0));  //inverse</code> <code class="literal">hyperbolic</code> <code class="literal">sine</code> <code class="literal">of</code> <code class="literal">a</code> <code class="literal">value</code>
<code class="literal">console.log(Math.acosh(1));  //inverse</code> <code class="literal">hyperbolic</code> <code class="literal">cosine</code> <code class="literal">of</code> <code class="literal">a</code> <code class="literal">value</code>
<code class="literal">console.log(Math.atanh(0));  //inverse</code> <code class="literal">hyperbolic</code> <code class="literal">tangent</code> <code class="literal">of</code> <code class="literal">a</code> <code class="literal">value</code>
<code class="literal">console.log(Math.hypot(2,</code> <code class="literal">2,</code> <code class="literal">1));//Pythagoras</code> <code class="literal">theorem</code>
</pre></div><p>The output is as follows:</p><div><pre class="programlisting">0
1
0
0
0
0
3</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Arithmetic related operations</h2></div></div></div><p>Here is an example <a id="id79" class="indexterm"/>code, which shows the entire arithmetic related methods added to the <code class="literal">Math</code> object:</p><div><pre class="programlisting">console.log(Math.log2(16));    //log base 2
console.log(Math.log10(1000)); //log base 10
console.log(Math.log1p(0));    //same as log(1 + value)
console.log(Math.expm1(0));    //inverse of Math.log1p()
console.log(Math.cbrt(8));     //cube root of a value</pre></div><p>The output is <a id="id80" class="indexterm"/>as follows:</p><div><pre class="programlisting">4
3
0
0
2</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Miscellaneous methods</h2></div></div></div><p>ES6 adds some miscellaneous methods to the <code class="literal">Math</code> object. These methods are used for conversion and <a id="id81" class="indexterm"/>extracting information from the numbers.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>The Math.imul(number1, number2) function</h3></div></div></div><p>The <code class="literal">Math.imul()</code> takes two numbers as <a id="id82" class="indexterm"/>32-bit integers and multiplies them. It returns the lower 32 bits of the result. This is the <a id="id83" class="indexterm"/>only native way to do 32-bit integer multiplication in JavaScript.</p><p>Here is an <a id="id84" class="indexterm"/>example to demonstrate this:</p><div><pre class="programlisting">console.log(Math.imul(590, 5000000)); //32-bit integer multiplication
console.log(590 * 5000000); //64-bit floating-point multiplication</pre></div><p>Output is:</p><div><pre class="programlisting">-1344967296
2950000000</pre></div><p>Here when multiplication was done it produced a number so large it couldn't be stored in 32 bits, therefore the lower bits were lost.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>The Math.clz32(number) function</h3></div></div></div><p>The <code class="literal">Math.clz32()</code> function<a id="id85" class="indexterm"/> returns the<a id="id86" class="indexterm"/> number of leading zero bits in the 32-bit representation of a number.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">console.log(Math.clz32(7));
console.log(Math.clz32(1000));
console.log(Math.clz32(295000000));</pre></div><p>Output is:</p><div><pre class="programlisting">29
22
3</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>The Math.sign(number) function</h3></div></div></div><p>The <code class="literal">Math.sign()</code> function returns the sign of a number, indicating weather the number is negative, positive or zero.</p><p>Here is an example to<a id="id87" class="indexterm"/> demonstrate<a id="id88" class="indexterm"/> this:</p><div><pre class="programlisting">console.log(Math.sign(11));
console.log(Math.sign(-11));
console.log(Math.sign(0));</pre></div><p>Output is:</p><div><pre class="programlisting">1
-1
0</pre></div><p>From the preceding code, we can see that the <code class="literal">Math.sign()</code> function returns <code class="literal">1</code> if the number is positive, <code class="literal">-1</code> if the number is negative, and <code class="literal">0</code> if the number is zero.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec15"/>The Math.trunc(number) function</h3></div></div></div><p>The <code class="literal">Math.trunc()</code> function returns the integer part of a number by removing any fractional digit. Here<a id="id89" class="indexterm"/> is an example to demonstrate this:</p><div><pre class="programlisting">console.log(Math.trunc(11.17));
console.log(Math.trunc(-1.112));</pre></div><p>Output is:</p><div><pre class="programlisting">11
-1</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec16"/>The Math.fround(number) function</h3></div></div></div><p>The <code class="literal">Math.fround()</code> function<a id="id90" class="indexterm"/> rounds a <a id="id91" class="indexterm"/>number to a 32-bit floating point value. Here is an example to demonstrate this:</p><div><pre class="programlisting">console.log(Math.fround(0));
console.log(Math.fround(1));
console.log(Math.fround(1.137));
console.log(Math.fround(1.5));</pre></div><p>Output is:</p><div><pre class="programlisting">0
1
1.1369999647140503
1.5</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Working with strings</h1></div></div></div><p>ES6 provides new ways of creating strings and adds new properties to global String object and to its instances to make working with strings easier. Strings in JavaScript lacked features and capabilities when compared with programming <a id="id92" class="indexterm"/>languages such as Python and <strong>Ruby</strong><a id="id93" class="indexterm"/> therefore ES6 enhanced strings to change that.</p><p>Before we get into <a id="id94" class="indexterm"/>new string features lets revise JavaScript's internal character encoding and escape sequences. In the Unicode character set every character is represented by a base 10 decimal number called a <strong>code point</strong>. A <strong>code unit</strong> is a fixed number <a id="id95" class="indexterm"/>of bits in memory to store a code point. An encoding schema determines the length of code unit. A code unit is 8 bits if the <strong>UTF-8</strong> encoding <a id="id96" class="indexterm"/>schema is used or 16 bits if the<a id="id97" class="indexterm"/> <strong>UTF-16</strong> encoding schema is used. If a code point doesn't fit in a code unit it is spilt into multiple code units, that is, multiple characters in sequence representing a single character.</p><p>JavaScript interpreters by default interpret JavaScript source code as sequence of UTF-16 code units. If source code is written in the UTF-8 encoding schema then there are various ways to tell the JavaScript interpreter to interpret it as sequence of UTF-8 code units. JavaScript strings are always a sequence of UTF-16 code points.</p><p>Any Unicode character with a code point less than 65536 can be escaped in a JavaScript string or source code using the hexadecimal value of its code point, prefixed with <code class="literal">\u</code>. Escapes are six characters long. They require exactly four characters following <code class="literal">\u</code>. If the hexadecimal character code is only one, two or three characters long, you'll need to pad it with leading zeroes. Here is an example to demonstrate this:</p><div><pre class="programlisting">var \u0061 = "\u0061\u0062\u0063";
console.log(a); //Output is "abc"</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Escaping larger code points</h2></div></div></div><p>In ES5, for escaping<a id="id98" class="indexterm"/> a character that requires more than 16 bits for storing, we needed two Unicode escapes. For example, to add <code class="literal">\u1F691</code> to a string we had to escape it this way:</p><div><pre class="programlisting">console.log("\uD83D\uDE91");</pre></div><p>Here <code class="literal">\uD83D</code> and <code class="literal">\uDE91</code> are called <strong>surrogate pairs</strong>. A surrogate pair is two Unicode characters when written in sequence represent another character.</p><p>In ES6 we can write it without surrogate pairs:</p><div><pre class="programlisting">console.log("\u{1F691}");</pre></div><p>A string<a id="id99" class="indexterm"/> stores <code class="literal">\u1F691</code> as <code class="literal">\uD83D\uDE91</code>, so length of the above string is still <code class="literal">2</code>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>The codePointAt(index) method</h2></div></div></div><p>The <code class="literal">codePointAt()</code> method of a string returns a non-negative integer that is the code point of the character at<a id="id100" class="indexterm"/> the given index.</p><p>Here is an example to <a id="id101" class="indexterm"/>demonstrate this:</p><div><pre class="programlisting">console.log("\uD83D\uDE91".codePointAt(1));
console.log("\u{1F691}".codePointAt(1));
console.log("hello".codePointAt(2));</pre></div><p>Output is:</p><div><pre class="programlisting">56977
56977
1080</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>The String.fromCodePoint(number1, …, number 2) method</h2></div></div></div><p>The <code class="literal">fromCodePoint()</code> method of <code class="literal">String</code> object takes a sequence of code points and returns a string. Here<a id="id102" class="indexterm"/> is an<a id="id103" class="indexterm"/> example to demonstrate this:</p><div><pre class="programlisting">console.log(String.fromCodePoint(0x61, 0x62, 0x63));
console.log("\u0061\u0062 " == String.fromCodePoint(0x61, 0x62));</pre></div><p>Output is:</p><div><pre class="programlisting">abc
true</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>The repeat(count) method</h2></div></div></div><p>The <code class="literal">repeat()</code> method of a <a id="id104" class="indexterm"/>string, constructs and returns a new string which contains the specified number of copies <a id="id105" class="indexterm"/>on which it was called, concatenated together. Here is an example to demonstrate this:</p><div><pre class="programlisting">console.log("a".repeat(6));      //Output "aaaaaa"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>The includes(string, index) method</h2></div></div></div><p>The <code class="literal">includes()</code> method is <a id="id106" class="indexterm"/>used to find whether one string may<a id="id107" class="indexterm"/> be found in another string, returning <code class="literal">true</code> or <code class="literal">false</code> as appropriate. Here is an example to demonstrate this:</p><div><pre class="programlisting">var str = "Hi, I am a JS Developer";
console.log(str.includes("JS")); //Output "true"</pre></div><p>It takes an optional second parameter representing the position in the string at which to begin searching. Here is<a id="id108" class="indexterm"/> an example to demonstrate<a id="id109" class="indexterm"/> this:</p><div><pre class="programlisting">var str = "Hi, I am a JS Developer";
console.log(str.includes("JS", 13)); // Output "false"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec38"/>The startsWith(string, index) method</h2></div></div></div><p>The <code class="literal">startsWith()</code> method is used to find whether a string begins with the characters of another string, returning<a id="id110" class="indexterm"/> <code class="literal">true</code> or <code class="literal">false</code> as appropriate. Here is an example to demonstrate this:</p><div><pre class="programlisting">var str = "Hi, I am a JS Developer";
console.log(str.startsWith('Hi, I am')); //Output "true"</pre></div><p>It takes an optional<a id="id111" class="indexterm"/> second parameter representing the position in the string at which to begin searching. Here is an example to demonstrate this:</p><div><pre class="programlisting">var str = "Hi, I am a JS Developer";
console.log(str.startsWith('JS Developer', 11)); //Output "true"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec39"/>The endsWith(string, index) function</h2></div></div></div><p>The <code class="literal">endsWith()</code> method is <a id="id112" class="indexterm"/>used to find whether a string ends with the characters of another string, returning true or false as appropriate. It also takes an optional second parameter representing the position in the string that is assumed as the<a id="id113" class="indexterm"/> end of the string. Here is an example to demonstrate this:</p><div><pre class="programlisting">var str = "Hi, I am a JS Developer";
console.log(str.endsWith("JS Developer"));  //Output "true"
console.log(str.endsWith("JS", 13));        //Output "true"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Normalization</h2></div></div></div><p>
<strong>Normalization</strong> is simply the process of searching and standardizing code points without changing the <a id="id114" class="indexterm"/>meaning of the string.</p><p>There are also<a id="id115" class="indexterm"/> different forms of normalization: NFC, NFD, NFKC and NFKD.</p><p>Let's understand Unicode string normalization by an example use case:</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec17"/>A case study</h3></div></div></div><p>There are many Unicode characters that can be stored in 16 bits and can also be represented using a<a id="id116" class="indexterm"/> surrogate pair. For example, '<code class="literal">é</code>' character can be escaped two ways:</p><div><pre class="programlisting">console.log("\u00E9");  //output 'é'
console.log("e\u0301"); //output 'é'</pre></div><p>The problem is when applying the <code class="literal">==</code> operator, iterating or finding length you will get an unexpected result. Here is an example to demonstrate this:</p><div><pre class="programlisting">var a = "\u00E9";
var b = "e\u0301";

console.log(a == b);
console.log(a.length);
console.log(b.length);

for(let i = 0; i&lt;a.length; i++)
{
  console.log(a[i]);
}

for(let i = 0; i&lt;b.length; i++)
{
  console.log(b[i]);
}</pre></div><p>Output is:</p><div><pre class="programlisting">false
1
2
é
é</pre></div><p>Here both the strings display the same way but when we do various string operations on them we get different results.</p><p>The length property ignores surrogate pairs and assumes every 16-bit to be single character. The <code class="literal">==</code> operator matches the binary bits therefore it also ignores surrogate pairs. The <code class="literal">[]</code> operator also assumes every 16-bit to be an index therefore ignoring surrogate pairs.</p><p>In this case to solve the problems we need to convert the surrogate pairs to 16-bit character representation. This process is called as <strong>normalization</strong>. To do this ES6 provides a <code class="literal">normalize()</code> function. Here is an example to demonstrate this:</p><div><pre class="programlisting">var a = "\u00E9".normalize();
var b = "e\u0301".normalize();

console.log(a == b);
console.log(a.length);
console.log(b.length);

for(let i = 0; i&lt;a.length; i++)
{
  console.log(a[i]);
}

for(let i = 0; i&lt;b.length; i++)
{
  console.log(b[i]);
}</pre></div><p>Output is:</p><div><pre class="programlisting">true
1
1
é
é</pre></div><p>Here the<a id="id117" class="indexterm"/> output is as expected. <code class="literal">normalize()</code> returns the normalized version of the string. <code class="literal">normalize()</code> uses NFC form by default.</p><p>Normalization is not just done in the case of surrogate pairs; there are many other cases.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>The Normalized version of a string is not made for displaying to the user; it's used for comparing and searching in strings.</p></div></div><p>To learn more about Unicode<a id="id118" class="indexterm"/> string normalization and normalization forms visit <a class="ulink" href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Template strings</h2></div></div></div><p>Template strings is just a<a id="id119" class="indexterm"/> new literal for creating strings that makes various things easier. They provide features such as embedded expressions, multi-line strings, string interpolation, string formatting, string tagging, and so on. They are always processed and<a id="id120" class="indexterm"/> converted to a normal JavaScript string on runtime therefore they can be used wherever we use normal strings.</p><p>Template strings are written using back ticks instead of single or double quotes. Here is an example of a simple template string:</p><div><pre class="programlisting">let str1 = `hello!!!`; //template string
let str2 = "hello!!!";

console.log(str1 === str2); //output "true"</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Expressions</h3></div></div></div><p>In ES5, to embed<a id="id121" class="indexterm"/> expressions within normal strings you would do something like this:</p><div><pre class="programlisting">Var a = 20;
Var b = 10;
Var c = "JavaScript";
Var str = "My age is " + (a + b) + " and I love " + c;

console.log(str);</pre></div><p>Output is:</p><div><pre class="programlisting">My age is 30 and I love JavaScript</pre></div><p>In ES6, template<a id="id122" class="indexterm"/> strings make it much easier to embed expressions in strings. Template strings can contain expressions in them. The expressions are placed in placeholders indicated by dollar sign and curly brackets, that is, <code class="literal">${expressions}</code>. The resolved value of expressions in the placeholders and the text between them are passed to a function for resolving the template string to a normal string. The default function just concatenates the parts into a single string. If we use a custom function to process the string parts then the template string is called <a id="id123" class="indexterm"/>as a <strong>tagged template string</strong> and the custom<a id="id124" class="indexterm"/> function is called as <strong>tag function</strong>.</p><p>Here is an example which shows how to embed expressions in a template strings:</p><div><pre class="programlisting">let a = 20;
let b = 10;
let c = "JavaScript";
letstr = `My age is ${a+b} and I love ${c}`;

console.log(str);</pre></div><p>Output is:</p><div><pre class="programlisting">My age is 30 and I love JavaScript</pre></div><p>Let's create a tagged template string, that is, process the string using a tag function. Let's implement the tag function to do the same thing as the default function. Here is an example to demonstrate this:</p><div><pre class="programlisting">let tag = function(strings, ...values)
{
  let result = "";

  for(let i = 0; i&lt;strings.length; i++)
  {
    result += strings[i];

    if(i&lt;values.length)
    {
      result += values[i];
    }
  }

  return result;
};

return result;
};

let a = 20;
let b = 10;
let c = "JavaScript";
let str = tag `My age is ${a+b} and I love ${c}`;

console.log(str);</pre></div><p>Output is:</p><div><pre class="programlisting">My age is 30 and I love JavaScript</pre></div><p>Here our tag function's name is <code class="literal">tag</code> but you can name it anything else. The custom function takes two parameters, that is, the first parameter is an array of string literals of the template<a id="id125" class="indexterm"/> string and the second parameter is an array of resolved values of the expressions. The second parameter is passed as multiple arguments therefore we use the rest argument.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Multiline strings</h3></div></div></div><p>Template strings provide a new <a id="id126" class="indexterm"/>way to create strings that contain multiple lines of text.</p><p>In ES5, we need to use <code class="literal">\n</code> new line character to add new line breaks. Here is an example to demonstrate this:</p><div><pre class="programlisting">console.log("1\n2\n3");</pre></div><p>Output is:</p><div><pre class="programlisting">1
2
3</pre></div><p>In ES6, using <strong>multiline</strong> string we can simply write:</p><div><pre class="programlisting">console.log(`1
2
3`);</pre></div><p>Output is:</p><div><pre class="programlisting">1
2
3</pre></div><p>In the above code we <a id="id127" class="indexterm"/>simply included new lines where we needed to place <code class="literal">\n</code>. While converting the template string to normal string the new lines are converted to <code class="literal">\n</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Raw strings</h3></div></div></div><p>A raw string is a normal string in which escaped characters aren't interpreted.</p><p>We can create a raw<a id="id128" class="indexterm"/> string using a template string. We can get raw version of a template string use <code class="literal">String.raw</code> tag function. Here is an example to demonstrate this:</p><div><pre class="programlisting">let s = String.raw `xy\n${ 1 + 1 }z`;
console.log(s);</pre></div><p>Output is:</p><div><pre class="programlisting">xy\n2z</pre></div><p>Here <code class="literal">\n</code> is not interpreted as new line character instead of its two characters, that is, <code class="literal">\</code> and <code class="literal">n</code>. Length of variable <code class="literal">s</code> would be <code class="literal">6</code>.</p><p>If you create a tagged function and you want to return the raw string then use <code class="literal">raw</code> property of the first argument. <code class="literal">raw</code> property is an array, which holds raw versions of the strings of the first argument. Here is an example to demonstrate this:</p><div><pre class="programlisting">let tag = function(strings, ...values)
{
    return strings.raw[0]
};

letstr = tag `Hello \n World!!!`;

console.log(str);</pre></div><p>Output is:</p><div><pre class="programlisting">Hello \n World!!!</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Arrays</h1></div></div></div><p>ES6 adds new properties to the global Array object and to its instances to make working with arrays easier. Arrays in JavaScript lacked features and capabilities when compared with programming<a id="id129" class="indexterm"/> languages such as Python and Ruby therefore ES6 enhanced arrays to change that.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>The Array.from(iterable, mapFunc, this) method</h2></div></div></div><p>The <code class="literal">Array.from()</code> method creates a new array instance from an iterable object. The first argument is a reference<a id="id130" class="indexterm"/> to the iterable object. The second argument is optional and is a callback (known as <strong>Map function</strong>) that is called for every element of the iterable object. The third argument is <a id="id131" class="indexterm"/>also optional and is the value of <code class="literal">this</code> inside the Map function.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">letstr = "0123";
letobj = {number: 1};
letarr = Array.from(str, function(value){
    return parseInt(value) + this.number;
}, obj);

console.log(arr);</pre></div><p>Output is:</p><div><pre class="programlisting">1, 2, 3, 4</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>The Array.of(values…) method</h2></div></div></div><p>The <code class="literal">Array.of()</code> method is an alternative to the <code class="literal">Array</code> constructor for creating arrays. When using <code class="literal">Array</code> constructor<a id="id132" class="indexterm"/> if we pass only one argument, that too a number, then <code class="literal">Array</code> constructor <a id="id133" class="indexterm"/>constructs an empty array with array <code class="literal">length</code> property equal to the passed number instead of creating an array of one element with that number in it. Therefore the <code class="literal">Array.of()</code> method was introduced to resolve this issue.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">let arr1 = new Array(2);
let arr2 = new Array.of(2);

console.log(arr1[0], arr1.length);
console.log(arr2[0], arr2.length);</pre></div><p>Output is:</p><div><pre class="programlisting">undefined 2
2 1</pre></div><p>You should use <code class="literal">Array.of()</code> instead of <code class="literal">Array</code> constructor when you are constructing a new array instance <a id="id134" class="indexterm"/>dynamically, that is, when you don't know the type of values and the number of elements.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>The fill(value, startIndex, endIndex) method</h2></div></div></div><p>The <code class="literal">fill()</code> method of an array fills all the elements of the array from the <code class="literal">startIndex</code> to an <code class="literal">endIndex</code> (not including <code class="literal">endIndex</code>) with a given value. Remember that <code class="literal">startIndex</code> and <code class="literal">endIndex</code> arguments are optional; therefore if they are not provided then the whole array is<a id="id135" class="indexterm"/> filled with the given value. If only <code class="literal">startIndex</code> is provided then <code class="literal">endIndex</code> defaults to length of array minus 1.</p><p>If <code class="literal">startIndex</code> is negative<a id="id136" class="indexterm"/> then it's treated as length of array plus <code class="literal">startIndex</code>. If <code class="literal">endIndex</code>  is negative, it is treated as length of array plus <code class="literal">endIndex</code>.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">let arr1 = [1, 2, 3, 4];
let arr2 = [1, 2, 3, 4];
let arr3 = [1, 2, 3, 4];
let arr4 = [1, 2, 3, 4];
let arr5 = [1, 2, 3, 4];

arr1.fill(5);
arr2.fill(5, 1, 2);
arr3.fill(5, 1, 3);
arr4.fill(5, -3, 2);
arr5.fill(5, 0, -2);

console.log(arr1);
console.log(arr2);
console.log(arr3);
console.log(arr4);
console.log(arr5);</pre></div><p>Output is:</p><div><pre class="programlisting">5,5,5,5
1,5,3,4
1,5,5,4
1,5,3,4
5,5,3,4</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>The find(testingFunc, this) method</h2></div></div></div><p>The <code class="literal">find()</code> method of an array returns an array element, if it satisfies the provided testing function. Otherwise it returns <code class="literal">undefined</code>.</p><p>The <code class="literal">find()</code> method takes two arguments, that is, the first argument is the testing function and the second argument<a id="id137" class="indexterm"/> is the value of <code class="literal">this</code> in the testing function. The second argument is optional.</p><p>The testing function has<a id="id138" class="indexterm"/> three parameters: the first parameter is the array element being processed, second parameter is the index of the current element being processed and third parameter is the array on which <code class="literal">find()</code> is called upon.</p><p>The testing function needs to return <code class="literal">true</code> to satisfy a value. The <code class="literal">find()</code> method returns the first element which satisfies the provided testing function.</p><p>Here is an example to demonstrate the <code class="literal">find()</code> method:</p><div><pre class="programlisting">var x = 12;
var arr = [11, 12, 13];
var result = arr.find(function(value, index, array){
    if(value == this)
    {
        return true;
    }
}, x);

console.log(result); //Output "12"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>The findIndex(testingFunc, this) method</h2></div></div></div><p>The <code class="literal">findIndex()</code> method is similar to the <code class="literal">find()</code> method. The <code class="literal">findIndex()</code> method returns the index <a id="id139" class="indexterm"/>of the satisfied array element instead of the <a id="id140" class="indexterm"/>element itself.</p><div><pre class="programlisting">let x = 12;
let arr = [11, 12, 13];
let result = arr.findIndex(function(value, index, array){
    if(value == this)
    {
        return true;
    }
}, x);

console.log(result); Output "1"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>The copyWithin(targetIndex, startIndex, endIndex) function</h2></div></div></div><p>The <code class="literal">copyWithin()</code> method of an array is used to copy the sequence of values of the array to a different position in the array.</p><p>The <code class="literal">copyWithin()</code> method takes<a id="id141" class="indexterm"/> three arguments: first argument represents the target index where to copy elements to, second argument represents the<a id="id142" class="indexterm"/> index position where to start copying from and the third argument represents the index , that is, where to actually end copying elements.</p><p>The third argument is optional and if not provided then it defaults to <code class="literal">length-1</code> where <code class="literal">length</code> is the length of the array. If <code class="literal">startIndex</code> is negative then it's calculated as <code class="literal">length+startIndex</code>. Similarly if <code class="literal">endIndex</code> is negative then it's calculated as <code class="literal">length+endIndex</code>.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">let arr1 = [1, 2, 3, 4, 5];
let arr2 = [1, 2, 3, 4, 5];
let arr3 = [1, 2, 3, 4, 5];
let arr4 = [1, 2, 3, 4, 5];

arr1.copyWithin(1, 2, 4);
arr2.copyWithin(0, 1);
arr3.copyWithin(1, -2);
arr4.copyWithin(1, -2, -1);

console.log(arr1);
console.log(arr2);
console.log(arr3);
console.log(arr4);</pre></div><p>Output is:</p><div><pre class="programlisting">1,3,4,4,5
2,3,4,5,5
1,4,5,4,5
1,4,3,4,5</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>The entries(), keys(), and values() method</h2></div></div></div><p>The <code class="literal">entries()</code> method of an array returns an iterable object<a id="id143" class="indexterm"/> that contains key/value pairs for each index of the <a id="id144" class="indexterm"/>array. Similarly the <code class="literal">keys()</code> method of an array<a id="id145" class="indexterm"/> returns an iterable object<a id="id146" class="indexterm"/> that contains keys for each of the<a id="id147" class="indexterm"/> indexes in the array. Similarly, the <code class="literal">values()</code> method of an array<a id="id148" class="indexterm"/> returns an iterable object that contains values of the array.</p><p>The iterable object returned by the <code class="literal">entries()</code> method stores the key/value pairs in the form of<a id="id149" class="indexterm"/> arrays.</p><p>The iterable <a id="id150" class="indexterm"/>object returned by<a id="id151" class="indexterm"/> these functions is not an array.</p><p>Here is an <a id="id152" class="indexterm"/>example to <a id="id153" class="indexterm"/>demonstrate<a id="id154" class="indexterm"/> this:</p><div><pre class="programlisting">let arr = ['a', 'b', 'c'];
let entries = arr.entries();
let keys = arr.keys();
let values = arr.values();

console.log(...entries);
console.log(...keys);
console.log(...values);</pre></div><p>Output<a id="id155" class="indexterm"/> is:</p><div><pre class="programlisting">0,a 1,b 2,c
0 1 2
a b c</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Collections</h1></div></div></div><p>A collection is any object that stores multiple elements as a single unit. ES6 introduced various new collection objects to<a id="id156" class="indexterm"/> provide better ways of storing and organizing data.</p><p>The array is the only collection object available in ES5. ES6 introduces array buffers, typed arrays, Sets, and Maps, which are built in collection objects.</p><p>Let's see the different collection objects provided by ES6.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>Array buffers</h2></div></div></div><p>Elements of arrays can be of any type such as strings, numbers, objects, and so on. Arrays can grow dynamically. The problem with arrays is that they are slow in terms of execution time, and occupy <a id="id157" class="indexterm"/>more memory. This causes issues while developing applications that require too much computation and deal with large amount of numbers. Therefore array buffers were introduced to tackle this issue.</p><p>An array buffer is a <a id="id158" class="indexterm"/>collection of 8-bit blocks in memory. Every block is an array buffer element. The size of an array buffer needs to be decided while creating, it therefore it cannot grow dynamically. Array buffers can only store numbers. All blocks are initialized to number 0 on creation of an array buffer.</p><p>An array buffer object is created using <code class="literal">ArrayBuffer</code> constructor.</p><div><pre class="programlisting">let buffer = new ArrayBuffer(80); //80 bytes size</pre></div><p>Reading from and writing <a id="id159" class="indexterm"/>values into an array buffer object can be done using a DateView object. It's not compulsory that only 8 bits are used to represent a number. We can use 8, 16, 32 and 64 bits to represent a number. Here is an example, which<a id="id160" class="indexterm"/> shows how to create a DateView object and read/write to an <code class="literal">ArrayBuffer</code> object:</p><div><pre class="programlisting">let buffer = new ArrayBuffer(80);
let view = new DataView(buffer);

view.setInt32(8,22,false);

var number = view.getInt32(8,false);

console.log(number); //Output "22"</pre></div><p>Here we created a DataView object using <code class="literal">DataView</code> constructor. A DataView object provides several methods to read and write numbers into an array buffer<code class="literal"> object</code>. Here we used <code class="literal">setInt32()</code> method which uses 32 bits to store a provided number.</p><p>All the methods of a DataView object that are used to write data to an array buffer object take three arguments. First argument represents the offset, that is, the byte we want to write the number to. Second argument is the number to be stored. And third argument is a Boolean type, which represents the endian of the number, such as <code class="literal">false</code> represents a big-endian.</p><p>Similarly all the methods of a DataView object that are used to read data of an array buffer object take two arguments. First argument is the offset and second argument represents the endian used.</p><p>Here are other functions<a id="id161" class="indexterm"/> for storing numbers provided by a DataView object:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>setInt8</strong>: Uses 8 bits to store a number. It takes a signed integer (-ve or +ve).</li><li class="listitem" style="list-style-type: disc"><strong>setUint8</strong>: Uses 8 bits to store a number. It takes an unsigned integer (+ve).</li><li class="listitem" style="list-style-type: disc"><strong>setInt16</strong>: Uses 16 bits to store a number. It takes a signed integer.</li><li class="listitem" style="list-style-type: disc"><strong>setUint16</strong>: Uses 16 bits to store a number. It takes an unsigned integer.</li><li class="listitem" style="list-style-type: disc"><strong>setInt32</strong>: Uses 32 bits to store a number. It takes a signed integer.</li><li class="listitem" style="list-style-type: disc"><strong>setUint32</strong>: Uses 32 bits to store a number. It takes an unsigned integer.</li><li class="listitem" style="list-style-type: disc"><strong>setFloat32</strong>: Uses 32 bits to store a number. It takes a signed decimal number.</li><li class="listitem" style="list-style-type: disc"><strong>setFloat64</strong>: Uses 64 bits to store a number. It takes a signed decimal number.</li></ul></div><p>Here are other functions for retrieving stored numbers by a DataView object:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>getInt8</strong>: Reads 8 bits. Returns signed integer number.</li><li class="listitem" style="list-style-type: disc"><strong>getUint8</strong>: Reads 8 bits. Returns unsigned integer number.</li><li class="listitem" style="list-style-type: disc"><strong>getInt16</strong>: Reads 16 bits. Returns signed integer number.</li><li class="listitem" style="list-style-type: disc"><strong>getUint16</strong>: Reads 16 bits. Returns unsigned integer number.</li><li class="listitem" style="list-style-type: disc"><strong>getInt32</strong>: Reads 32 bits. Returns signed integer number.</li><li class="listitem" style="list-style-type: disc"><strong>getUint32</strong>: Reads 32 bits. Returns unsigned integer number.</li><li class="listitem" style="list-style-type: disc"><strong>getFloat32</strong>: Reads<a id="id162" class="indexterm"/> 32 bits. Returns signed decimal number.</li><li class="listitem" style="list-style-type: disc"><strong>getFloat64</strong>: Reads 64<a id="id163" class="indexterm"/> bits. Returns signed decimal number.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>Typed arrays</h2></div></div></div><p>We saw how to read and write numbers in array buffers. But the method was very cumbersome because we had to call a function every time. <strong>Typed arrays</strong> let us read and write to an array <a id="id164" class="indexterm"/>buffer object just like we do for normal arrays.</p><p>A typed array acts like a <a id="id165" class="indexterm"/>wrapper for an array buffer object and treats data of an array buffer object as a sequence of <em>n</em>-bit numbers. The <code class="literal">n</code> value depends on how we created the typed array.</p><p>Here is the code example that demonstrates how to create an array buffer object and read/write to it using a typed array:</p><div><pre class="programlisting">var buffer = new ArrayBuffer(80);
vartyped_array = new Float64Array(buffer);
typed_array[4] = 11;

console.log(typed_array.length);
console.log(typed_array[4]);</pre></div><p>Output is:</p><div><pre class="programlisting">10
11</pre></div><p>Here we created typed array using the <code class="literal">Float64Array</code> constructor, it therefore treats data in the array buffer as a sequence of 64-bit signed decimal numbers. Here the array buffer object size was 640 bits therefore only 10 64-bit numbers can be stored.</p><p>Similarly, there are other typed array constructors to represent data in an array buffer as a sequence of different bit <a id="id166" class="indexterm"/>numbers. Here is the list:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Int8Array</strong>: Treats as 8-bit signed integers</li><li class="listitem" style="list-style-type: disc"><strong>Uint8Array</strong>: Treats as 8-bit unsigned integers</li><li class="listitem" style="list-style-type: disc"><strong>Int16Array</strong>: Treats as 16-bit signed integers</li><li class="listitem" style="list-style-type: disc"><strong>Uint16Array</strong>: Treats as 16-bit unsigned integers</li><li class="listitem" style="list-style-type: disc"><strong>Int32Array</strong>: Treats as 32-bit signed integers</li><li class="listitem" style="list-style-type: disc"><strong>Uint32Array</strong>: Treats as 32-bit unsigned integers</li><li class="listitem" style="list-style-type: disc"><strong>Float32Array</strong>: Treats as 32-bit signed decimal number</li><li class="listitem" style="list-style-type: disc"><strong>Float64Array</strong>: Treats<a id="id167" class="indexterm"/> as 64-bit signed decimal number</li></ul></div><p>Typed arrays<a id="id168" class="indexterm"/> provide all the methods that are also provided by normal <a id="id169" class="indexterm"/>JavaScript arrays. They also implement the iterable protocol therefore they can be used as an iterable object.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Set</h2></div></div></div><p>A <strong>Set</strong> is a collection <a id="id170" class="indexterm"/>of <em>unique</em> values <a id="id171" class="indexterm"/>of any data type. The values in a Set are arranged in<a id="id172" class="indexterm"/> insertion order. A Set is created using <code class="literal">Set</code> constructor. Here is an example:</p><div><pre class="programlisting">let set1 = new Set();
let set2 = new Set("Hello!!!");</pre></div><p>Here <code class="literal">set1</code> is an empty Set. Whereas <code class="literal">set2</code> was created using values of an iterable object, that is, characters of a string and the string was not empty therefore <code class="literal">set2</code> is non-empty.</p><p>Here is example code, which demonstrates various operations that can be done on a Set:</p><div><pre class="programlisting">let set = new Set("Hello!!!");

set.add(12); //add 12

console.log(set.has("!")); //check if value exists
console.log(set.size);

set.delete(12); //delete 12

console.log(...set);

set.clear(); //delete all values</pre></div><p>Output is:</p><div><pre class="programlisting">true
6
H e l o !</pre></div><p>Here we added nine items to the <code class="literal">set</code> object but the <code class="literal">size</code> was only six because Set automatically deletes duplicate values. The characters <code class="literal">l</code>and <code class="literal">!</code>were repeated multiple times.</p><p>The Set object also implements the iterable protocol so they can be used as an iterable object.</p><p>Sets are used when you want to<a id="id173" class="indexterm"/> maintain a collection of values and check if a value exists instead of <a id="id174" class="indexterm"/>retrieving a value. For example: Sets can be used as an alternative to an array if you only use the <code class="literal">indexOf()</code> method of the array in your code to check if an value exists.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec52"/>WeakSet</h2></div></div></div><p>Here are the differences<a id="id175" class="indexterm"/> between Set and WeakSet objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Set can store <a id="id176" class="indexterm"/>primitive types and object references whereas a WeakSet object can only store object references</li><li class="listitem" style="list-style-type: disc">One of the important features of the WeakSet object is that if there is no other reference to an object stored in a WeakSet object then they are garbage collected</li><li class="listitem" style="list-style-type: disc">Lastly a WeakSet object is not enumerable, that is, you cannot find its size; it also doesn't implement iterable protocol</li></ul></div><p>Apart from these three <a id="id177" class="indexterm"/>differences it behaves exactly the same way as a Set<code class="literal">. </code>Everything else apart from these three differences is same between a Set and WeakSet object.</p><p>A WeakSet object is created using <code class="literal">WeakSet</code> constructor. You cannot pass an iterable object as an argument to WeakSet object.</p><p>Here is an example to demonstrate WeakSet:</p><div><pre class="programlisting">letweakset = new WeakSet();

(function(){
  let a = {};
  weakset.add(a);
})()

//here 'a' is garbage collected from weakset
console.log(weakset.size); //output "undefined"
console.log(...weakset); //Exception is thrown

weakset.clear(); //Exception, no such function</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec53"/>Map</h2></div></div></div><p>A Map is a collection of key/value pairs. Keys and values of a Map can be of any data type. The key/value pairs are arranged in the insertion order. A Map object is created using the <code class="literal">Map</code><a id="id178" class="indexterm"/> constructor.</p><p>Here is an example, which <a id="id179" class="indexterm"/>demonstrates how to create a Map object and do various operations on it:</p><div><pre class="programlisting">let map = new Map();
let o = {n: 1};

map.set(o, "A"); //add
map.set("2", 9);

console.log(map.has("2")); //check if key exists
console.log(map.get(o)); //retrieve value associated with key
console.log(...map);

map.delete("2"); //delete key and associated value
map.clear(); //delete everything

//create a map from iterable object
let map_1 = new Map([[1, 2], [4, 5]]);

console.log(map_1.size); //number of keys</pre></div><p>Output is:</p><div><pre class="programlisting">true
A
[object Object],A 2,9
2</pre></div><p>While creating a Map object from an iterable object we need to make sure that the values returned by the iterable object are arrays, each of length <code class="literal">2</code> i.e., index 0 is the key and index 1 is the value.</p><p>If we try to add a key that already exists then it's overwritten. The Map objects also implement the iterable protocol and can therefore also be used as an iterable object. While iterating Maps using the iterable protocol, they return arrays with key/value pairs as you can see in the preceding example.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec54"/>WeakMap</h2></div></div></div><p>Here are the<a id="id180" class="indexterm"/> differences between<a id="id181" class="indexterm"/> the Map and the WeakMap objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keys of a Map object can be of primitive types or object references but keys in WeakMap object can only be object references</li><li class="listitem" style="list-style-type: disc">One of the important features of the WeakMap object is that if there is no other reference to an object that is referenced by a key then the key is garbage collected.</li><li class="listitem" style="list-style-type: disc">Lastly the WeakMap object is not enumerable, that is, you cannot find its size and it doesn't implement iterable protocol.</li></ul></div><p>Everything else, apart from<a id="id182" class="indexterm"/> these three differences is similar between the Map and the WeakMap object.</p><p>A WeakMap is <a id="id183" class="indexterm"/>created using <code class="literal">WeakMap</code> constructor. Here is an example that demonstrates its usage:</p><div><pre class="programlisting">let weakmap = new WeakMap();

(function(){
  let o = {n: 1};
  weakmap.set(o, "A");
})()

//here 'o' key is garbage collected
let s = {m: 1};

weakmap.set(s, "B");

console.log(weakmap.get(s));
console.log(...weakmap); //exception thrown

weakmap.delete(s);
weakmap.clear(); //Exception, no such function

let weakmap_1 = new WeakMap([[{}, 2], [{}, 5]]);   //this works

console.log(weakmap_1.size); //undefined</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Object</h1></div></div></div><p>ES6 standardizes the <code class="literal">__proto__</code> property of an <a id="id184" class="indexterm"/>object and adds new properties to the global <code class="literal">Object</code> object.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec55"/>The __proto__ property</h2></div></div></div><p>JavaScript objects have an internal <code class="literal">[[prototype]]</code> property that references the object's prototype, that is, the object it inherits. To<a id="id185" class="indexterm"/> read the property we had to use <code class="literal">Object.getPrototypeof()</code> and to create a new object with a given prototype we had to use the <code class="literal">Object.create()</code> method. A <code class="literal">[[prototype]]</code> property cannot be directly read or be modified.</p><p>Inheriting was cumbersome <a id="id186" class="indexterm"/>due to the nature of the <code class="literal">[[prototype]]</code> property, therefore some browsers added a special <code class="literal">__proto__</code> property in objects, which is an accessor property that exposes the internal <code class="literal">[[prototype]]</code> property and makes working with prototypes easier. The <code class="literal">__proto__</code> property was not standardized in ES5 but due to its popularity it was standardized in ES6.</p><p>Here is an example to demonstrate this:</p><div><pre class="programlisting">//In ES5
var x = {x: 12};
var y = Object.create(x, {y: {value: 13}});

console.log(y.x); //Output "12"
console.log(y.y); //Output "13"

//In ES6
let a = {a: 12, __proto__: {b: 13}};
console.log(a.a); //Output "12"
console.log(a.b); //Output "13"</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec21"/>The Object.is(value1, value2) method</h3></div></div></div><p>The <code class="literal">Object.is()</code> method determines whether two values are equal or not. It is similar to the <code class="literal">===</code> operator but there are<a id="id187" class="indexterm"/> some special cases for the <code class="literal">Object.is()</code> method. Here<a id="id188" class="indexterm"/> is an example that demonstrates the special cases:</p><div><pre class="programlisting">console.log(Object.is(0, -0));
console.log(0 === -0);
console.log(Object.is(NaN, 0/0));
console.log(NaN === 0/0);
console.log(Object.is(NaN, NaN));
console.log(NaN ===NaN);</pre></div><p>Output is:</p><div><pre class="programlisting">false
true
true
false
true
false</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec22"/>The Object.setPrototypeOf(object, prototype) method</h3></div></div></div><p>The <code class="literal">Object.setPrototypeOf()</code> method is just an another way to assign the <code class="literal">[[prototype]]</code> property<a id="id189" class="indexterm"/> of an object. Here is an example to demonstrate this:</p><div><pre class="programlisting">let x = {x: 12};
let y = {y: 13};

Object.setPrototypeOf(y, x)

console.log(y.x); //Output "12"
console.log(y.y); //Output "13"</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec23"/>The Object.assign(targetObj, sourceObjs…) method</h3></div></div></div><p>The <code class="literal">Object.assign()</code> method is used is used to copy the values of all enumerable own properties from one or more source<a id="id190" class="indexterm"/> objects to a target object. This method <a id="id191" class="indexterm"/>will return the <code class="literal">targetObj.</code>
</p><p>Here is an example which demonstrates this:</p><div><pre class="programlisting">let x = {x: 12};
let y = {y: 13, __proto__: x};
let z = {z: 14, get b() {return 2;}, q: {}};

Object.defineProperty(z, "z", {enumerable: false});

let m = {};

Object.assign(m, y, z);

console.log(m.y);
console.log(m.z);
console.log(m.b);
console.log(m.x);
console.log(m.q == z.q);</pre></div><p>Output is:</p><div><pre class="programlisting">13
undefined
2
undefined
true</pre></div><p>Here is a list of important things to keep in mind while using the <code class="literal">Object.assign()</code> method:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It invokes getters on the sources and setters on the target.</li><li class="listitem" style="list-style-type: disc">It just assigns values of the properties of source to the new or existing properties of<a id="id192" class="indexterm"/> target.</li><li class="listitem" style="list-style-type: disc">It doesn't copy the <code class="literal">[[prototype]]</code> property of sources.</li><li class="listitem" style="list-style-type: disc">JavaScript property <a id="id193" class="indexterm"/>names can be strings or symbols. <code class="literal">Object.assign()</code> copies both.</li><li class="listitem" style="list-style-type: disc">Property definitions are not copied from sources therefore you need to use <code class="literal">Object.getOwnPropertyDescriptor()Object.defineProperty()</code> instead.</li><li class="listitem" style="list-style-type: disc">It ignores copying keys with <code class="literal">null</code> and <code class="literal">undefined</code> values.</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter we learned new features added by ES6 for working with numbers, strings, arrays and objects. We saw how arrays impact performance in math-rich applications and how the array buffers can be used instead. We also walked through the new collection objects provided by ES6.</p><p>In next chapter, we will learn about Symbols and Iteration protocol, and we will discover <code class="literal">yield</code> keyword and generators also.</p></div></body></html>