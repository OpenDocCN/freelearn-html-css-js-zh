- en: Chapter 4. Adding Detail
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。添加细节
- en: This chapter explains how to manage external assets such as 3D models, as well
    as add details to your worlds with particle systems, sound, and graphic effects.
    It will also elaborate on the arena first-person shooter game we built in [Chapter
    3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring and Interacting*,
    to turn it into a Capture-the-Flag game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何管理外部资产，如3D模型，以及如何使用粒子系统、声音和图形效果为你的世界添加细节。它还将详细说明我们在[第3章](ch03.html "第3章。探索和交互")中构建的竞技场第一人称射击游戏，将其转变为夺旗游戏。
- en: Setting up CTF
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置CTF
- en: 'In order to have a proper Capture-the-Flag game, we first need to have teams.
    There are several things that need to be associated with a given team:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个合适的夺旗游戏，我们首先需要拥有队伍。有一些事情需要与特定的队伍相关联：
- en: Flags (and the flag color)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旗帜（以及旗帜颜色）
- en: Players (and the player skins)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家（以及玩家的皮肤）
- en: Spawn points
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成点
- en: Bullets (if you want to avoid same-team damage)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子弹（如果你想要避免同队伤害）
- en: Potentially map decorations/materials
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的地图装饰/材质
- en: The simplest way to associate each of these elements with a team is to just
    add a property with a simple value such as `R` or `B` to represent Red or Blue
    (or some other team name). A more advanced approach could be to create a `Team`
    class that holds references to everything that belongs to that team, since that
    could offer optimizations such as limiting the number of collision checks that
    need to be performed. If you do that, however, make sure you remove all the appropriate
    references from the `Team` container when removing something (such as a bullet)
    from the world in order to avoid memory leaks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些元素中的每一个与一个队伍关联的最简单方法是为它们添加一个具有简单值（如`R`或`B`）的属性来表示红队或蓝队（或任何其他队伍名称）。一个更高级的方法可能是创建一个`Team`类，该类包含属于该队伍的所有内容的引用，因为这可以提供优化，例如限制需要执行的碰撞检查的数量。但是，如果你这样做，确保在从世界中移除某些东西（如子弹）时从`Team`容器中删除所有适当的引用，以避免内存泄漏。
- en: 'Next, we need to modify our map to add flags for the Red and Blue teams, which
    we''ll represent as `R` and `B`, respectively:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的地图以添加红队和蓝队的旗帜，我们将分别用`R`和`B`表示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we need to actually add those flags to the world. Flags are not simple geometric
    primitive shapes though, so we'll want to import a more complex mesh.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些旗帜实际添加到世界中。然而，旗帜不是简单的几何原形形状，因此我们希望导入一个更复杂的网格。
- en: Asset management
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产管理
- en: Primitive geometric shapes are great for tests, but any serious game these days
    will likely make heavy use of 3D models created in a specialized program such
    as Blender, Maya, or 3ds Max. These models need to be imported into Three.js scenes
    and converted to `THREE.Mesh` objects with geometry and materials. Luckily, Three.js
    provides importers called **loaders** for a variety of file formats.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 原始几何形状非常适合测试，但任何严肃的游戏今天都可能大量使用在Blender、Maya或3ds Max等专业程序中创建的3D模型。这些模型需要导入到Three.js场景中，并转换为具有几何和材质的`THREE.Mesh`对象。幸运的是，Three.js为各种文件格式提供了名为**loaders**的导入器。
- en: Loaders
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入器
- en: 'For our flags, we''ll use a simple mesh in Collada format. (Collada is an XML-based
    format for storing 3D mesh and animation data, with files ending in `.dae`.) You
    can download our flag mesh from the Packt Publishing website. The `ColladaLoader`
    is not included in the main Three.js library, but can be copied from `examples/js/loaders/ColladaLoader.js`
    and then included in your HTML as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的旗帜，我们将使用一个简单的Collada格式的网格。（Collada是一种基于XML的格式，用于存储3D网格和动画数据，文件以`.dae`结尾。）你可以从Packt
    Publishing网站下载我们的旗帜网格。`ColladaLoader`不包括在主Three.js库中，但可以从`examples/js/loaders/ColladaLoader.js`复制，然后将其包含在你的HTML中，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then the model can be loaded like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，模型可以像这样加载：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Often imported models need to be resized and repositioned, so you will probably
    want to set `result.scene.scale` and `result.scene.position` before adding the
    mesh to the world. You can see the loaded model in the next screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要调整和重新定位导入的模型，因此你可能会想在将网格添加到世界之前设置`result.scene.scale`和`result.scene.position`。你可以在下一张截图看到加载的模型：
- en: '![Loaders](img/8539_04_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![导入器](img/8539_04_01.jpg)'
- en: The Blue team's flag
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝队的旗帜
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, importing meshes will not work on local `file:///` URLs. This is
    because when JavaScript requests the file, browsers' default security settings
    refuse to return local system files. To get around this restriction, you can either
    run a local HTTP server or change your browser's security settings as described
    at [https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally](https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在本地`file:///` URL上导入网格将不会工作。这是因为当JavaScript请求文件时，浏览器的默认安全设置拒绝返回本地系统文件。为了绕过这个限制，你可以运行一个本地HTTP服务器或更改浏览器安全设置，具体方法请参阅[https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally](https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally)。
- en: There are many other loaders for models in other file formats, including CTM,
    OBJ, MTL, PLY, STL, UTF8, VRML, and VTK. These are located in the `examples/js/loaders`
    folder. Almost all of the loaders have a `load` method, like the `ColladaLoader`
    method mentioned previously, which takes a function to call when loading is finished.
    However, loaders do not have a standardized format, and some of them work in slightly
    different ways. In particular, the parameters passed to the callback depend on
    the file type. You should check the `examples` folder for demos of the loader
    you want to use to make sure you handle the returned result correctly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他用于其他文件格式的模型加载器，包括CTM、OBJ、MTL、PLY、STL、UTF8、VRML和VTK。这些位于`examples/js/loaders`文件夹中。几乎所有的加载器都有一个`load`方法，就像之前提到的`ColladaLoader`方法一样，该方法在加载完成后调用一个函数。然而，加载器没有标准化的格式，其中一些工作方式略有不同。特别是，传递给回调函数的参数取决于文件类型。你应该检查你想要使用的加载器的`examples`文件夹中的演示，以确保你正确处理返回的结果。
- en: 'In our case, we get a group of sub-meshes (in the `result.scene`) back from
    the `ColladaLoader` because Collada files can contain multiple meshes. We need
    to modify the flag''s materials to make sure each flag reflects its team''s color:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们从`ColladaLoader`获取一组子网格（在`result.scene`中），因为Collada文件可以包含多个网格。我们需要修改标志的材质，以确保每个标志反映其队伍的颜色：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Recall that when we set up our camera to follow the player around in the last
    chapter, we added the camera to the `player` object. Whenever objects are grouped
    together this way, they can be accessed through the parent's `children` array.
    In this case, we're using that array to alter the material for the cloth part
    of the flag to make it blue or red depending on which team it belongs to.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在上一章中我们设置相机跟随玩家时，我们将相机添加到了`player`对象中。每当以这种方式将对象分组时，它们可以通过父对象的`children`数组访问。在这种情况下，我们使用该数组来改变旗帜布料部分的材质，使其变为蓝色或红色，具体取决于它属于哪个队伍。
- en: In addition to loaders for standard 3D model file formats, there are a number
    of Three.js-specific loaders included directly in the library. In particular,
    `THREE.JSONLoader` is designed to load single meshes, while `THREE.SceneLoader`
    can load entire scenes (including lighting, cameras, and other Three.js entities).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准3D模型文件格式的加载器之外，库中还包含了一些Three.js特定的加载器。特别是，`THREE.JSONLoader`被设计用来加载单个网格，而`THREE.SceneLoader`可以加载整个场景（包括灯光、相机和其他Three.js实体）。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are also built-in loaders for assets other than 3D models. For example,
    we've already seen `THREE.TextureLoader` at work behind the scenes of `THREE.ImageUtils.loadTexture`.
    You can also directly load pieces of meshes, including geometry, images, and materials.
    Other objects such as lights, cameras, and even arbitrary resources can be loaded
    as well. However, these loaders are normally invoked under the hood of the library
    rather than directly by developers because it usually makes more sense to load
    entire models or scenes rather than the individual pieces. As a result, we will
    not cover these loaders here, but you can find them in the `src/loaders` folder
    if you would like to learn more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了3D模型之外，还有一些内置的加载器用于其他资产。例如，我们已经看到了`THREE.TextureLoader`在`THREE.ImageUtils.loadTexture`背后的工作。你也可以直接加载网格的各个部分，包括几何形状、图像和材质。其他对象，如灯光、相机，甚至任意资源也可以加载。然而，这些加载器通常在库的底层调用，而不是直接由开发者调用，因为通常加载整个模型或场景比加载单个部分更有意义。因此，我们在这里不会介绍这些加载器，但如果你想要了解更多，可以在`src/loaders`文件夹中找到它们。
- en: 'Like `ColladaLoader`, the `JSONLoader` uses a `load` method with a callback.
    However, the callback receives a `THREE.Geometry` object as its first parameter.
    Not all 3D models have associated materials, but if the object does have materials,
    they will be passed to the callback in an array as the second parameter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ColladaLoader` 类似，`JSONLoader` 使用一个带有回调的 `load` 方法。然而，回调接收一个 `THREE.Geometry`
    对象作为其第一个参数。并非所有3D模型都有关联的材料，但如果对象有材料，它们将以数组的形式作为第二个参数传递给回调：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As explained in [Chapter 2](ch02.html "Chapter 2. Building a World"), *Building
    a World*, `MeshFaceMaterial` is a container that maps multiple materials to different
    faces of the mesh.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](ch02.html "第2章。构建世界")《构建世界》中所述，`MeshFaceMaterial` 是一个容器，它将多个材料映射到网格的不同面上。
- en: 'The `SceneLoader` is a little different from other loaders because it can use
    other loaders to handle specific parts of the scene:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneLoader` 与其他加载器略有不同，因为它可以使用其他加载器来处理场景的特定部分：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If a scene includes an external model, the `SceneLoader` will try to import
    it using the appropriate handler. Use the `addGeometryHandler` method to add loaders
    for file formats that only support single meshes, and use `addHierarchyHandler`
    to add loaders for file formats that support multimesh scenes (DAE, OBJ, and UTF8).
    In this example, CTM and DAE files will be loaded correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景包含外部模型，`SceneLoader` 将尝试使用适当的处理程序导入它。使用 `addGeometryHandler` 方法添加仅支持单个网格的文件格式的加载器，并使用
    `addHierarchyHandler` 添加支持多网格场景的文件格式的加载器（DAE、OBJ和UTF8）。在这个例子中，CTM和DAE文件将被正确加载。
- en: Exporting to Three.js
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出到Three.js
- en: The Three.js project includes extensions for the 3ds Max, Maya, and Blender
    3D modeling programs to make exporting models to the Three.js JSON format easier.
    These extensions have some limitations; for example, some modifiers such as smoothing
    groups are not supported. There are two common alternatives to avoid these issues.
    The first is to export models to a format such as DAE and use the corresponding
    Three.js importer. Another approach is to export models to OBJ format and then
    run the Python converter script in the `utils/converters` folder to transform
    the model to Three.js JSON format. Choosing a file format is mostly a trade-off
    in file size (how long the file will take to retrieve) and initialization (how
    long the file will take to parse). You may need to test different formats for
    performance-sensitive projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js项目包括用于3ds Max、Maya和Blender 3D建模程序的扩展，以便更容易地将模型导出为Three.js JSON格式。这些扩展有一些限制；例如，一些修改器如平滑组不支持。有两种常见的替代方案可以避免这些问题。第一种是将模型导出为DAE等格式，并使用相应的Three.js导入器。另一种方法是导出模型为OBJ格式，然后在`utils/converters`文件夹中运行Python转换器脚本，将模型转换为Three.js
    JSON格式。选择文件格式主要是权衡文件大小（文件检索所需时间）和初始化（文件解析所需时间）。你可能需要为性能敏感的项目测试不同的格式。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Python converters were written for Python 2.x and may not work in 3.x.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python转换器是为Python 2.x编写的，可能不适用于3.x。
- en: 'The most common problems that arise when importing models are due to not exporting
    all the required properties. In your modeling program''s export dialog, if given
    a choice, make sure to check the boxes for these properties:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模型时出现最常见的问题是由于没有导出所有必需的属性。在你的建模程序的导出对话框中，如果可以选择，请确保勾选这些属性的复选框：
- en: Vertices
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点
- en: Faces
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面部
- en: Normals
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法线
- en: Skinning / Materials / Texture Maps / Texture Coordinates / UVs / Colors
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 皮肤/材质/纹理贴图/纹理坐标/UV/颜色
- en: Flip YZ
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻转YZ
- en: Morph animation (if applicable)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形态动画（如果适用）
- en: All meshes (if applicable)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有网格（如果适用）
- en: Your modeling software may not have all these options, and you may need to check
    other boxes as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你的建模软件可能没有所有这些选项，你可能还需要检查其他复选框。
- en: To be on the safe side, you may also want to make sure the model you're exporting
    is a top-level object rather than grouped with other things, that the model is
    not translated or rotated, that the scaling is set to `1`, and that you've deleted
    the model's history.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，你可能还想确保你导出的模型是一个顶级对象，而不是与其他事物组合在一起，模型没有被平移或旋转，缩放设置为`1`，并且你已经删除了模型的历史记录。
- en: Exporting from Three.js
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Three.js导出
- en: 'Three.js provides several exporters in the `examples/js/exporters` folder that
    allow saving scenes or objects in various formats, including OBJ, STL, and JSON.
    Like with loaders, more or less any Three.js entity can be exported, but the most
    common approach is to export a complete mesh or scene. The `SceneExporter` tool
    is the most common tool here, and using it is fairly straightforward:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js在`examples/js/exporters`文件夹中提供了几个导出器，允许以各种格式保存场景或对象，包括OBJ、STL和JSON。与加载器一样，几乎任何Three.js实体都可以导出，但最常见的方法是导出一个完整的网格或场景。`SceneExporter`工具在这里是最常见的工具，使用它相当直接：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then `output` value can be saved into a JSON file that `SceneLoader` can read
    later. The one major issue to watch out for is that custom properties won't get
    exported. That includes nonstandard properties added to object instances, properties
    provided by subclasses of Three.js classes, custom classes that don't inherit
    from Three.js classes, and anything that isn't part of the `scene`. If you need
    any of these things to be exported, you may be better off writing a custom exporter
    and importer, possibly starting with one of the ones Three.js provides.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`output`值可以被保存到一个`SceneLoader`可以稍后读取的JSON文件中。需要注意的一个主要问题是自定义属性不会被导出。这包括添加到对象实例中的非标准属性、Three.js类子类提供的属性、不继承自Three.js类的自定义类，以及不属于`scene`的任何内容。如果你需要任何这些内容被导出，你可能最好编写一个自定义导出器和导入器，可能从Three.js提供的其中一个开始。
- en: Managing loaders
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理加载器
- en: Right now, when our CTF map is initialized, we ask a loader to fetch the flag
    model. This works fine because the model is pretty small and we only have the
    one model to load. However, if we had many models or if they were bigger, we may
    notice them popping into the map when they finished loading, even after we've
    started playing. To fix this, larger projects should preload assets before the
    player can start playing the game. All that's required to do so is to disallow
    entering the map until the last model's callback has been executed. Unfortunately,
    if we have a lot of models and we have to load them one by one, it can be hard
    to keep track of how many models are remaining. Users may also lose interest if
    nothing is happening while models are loading.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的CTF地图初始化时，我们要求一个加载器获取旗帜模型。这没问题，因为模型相当小，我们只需要加载一个模型。然而，如果我们有很多模型或者它们很大，我们可能会注意到它们在加载完成后突然出现在地图上，即使我们已经开始玩游戏。为了解决这个问题，较大的项目应该在玩家开始玩游戏之前预加载资源。为此，只需要禁止进入地图，直到最后一个模型的回调函数执行完毕。不幸的是，如果我们有很多模型并且必须逐个加载它们，可能会很难跟踪剩余的模型数量。当模型加载时，如果没有任何事情发生，用户也可能失去兴趣。
- en: 'Usually, this is resolved by loading all the models at once with the `SceneLoader`.
    The `SceneLoader` objects have a `callbackProgress` property that holds a function
    which is invoked after each object in the scene has completed loading. The callback
    takes two parameters, `progress` and `result`. The `progress` object has four
    numeric properties that can be used to display a progress bar: `totalModels`,
    `totalTextures`, `loadedModels`, and `loadedTextures`. The result object contains
    all of the entities that have been loaded so far, and it''s also the value passed
    to the `onLoad` parameter of the loader''s `load` callback when all loading has
    been completed.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是通过使用`SceneLoader`一次性加载所有模型来解决的。`SceneLoader`对象有一个`callbackProgress`属性，它包含一个在场景中的每个对象完成加载后调用的函数。该回调函数接受两个参数，`progress`和`result`。`progress`对象有四个数值属性，可以用来显示进度条：`totalModels`、`totalTextures`、`loadedModels`和`loadedTextures`。`result`对象包含到目前为止已加载的所有实体，它也是当所有加载完成后传递给加载器`load`回调函数的`onLoad`参数的值。
- en: 'Consider HTML like this for a loading bar, where the outer div has a defined
    width:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进度条，可以考虑如下HTML代码，其中外层div有一个定义的宽度：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, you might include code like this in a `callbackProgress` handler:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以在`callbackProgress`处理程序中包含如下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you can't use a `SceneLoader` or don't want to use it for other reasons,
    you will have to chain together your loaders manually. However, Three.js will
    start using **loading managers** in the future. Loading managers are just objects
    that work together with loaders to track when multiple resources have finished
    loading. The loading manager API is not yet stable as of Three.js version r61
    and it is not implemented in many of the loaders.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能使用`SceneLoader`或者出于其他原因不想使用它，你必须手动将你的加载器连接起来。然而，Three.js未来将开始使用**加载管理器**。加载管理器是与加载器一起工作的对象，用于跟踪多个资源何时完成加载。截至Three.js版本r61，加载管理器API尚不稳定，并且许多加载器中尚未实现。
- en: Mesh animation
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格动画
- en: Using animated models is not very different from using normal models. There
    are essentially two types of animation to consider (in addition to manually changing
    the position of a mesh's geometry in Three.js).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动画模型与使用普通模型没有太大区别。除了在Three.js中手动更改网格几何形状的位置外，还有两种类型的动画需要考虑。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If all you need is to smoothly transition properties between different values—for
    example, changing the rotation of a door in order to animate it opening—you can
    use the Tween.js library at [https://github.com/sole/tween.js](https://github.com/sole/tween.js)
    to do so instead of animating the mesh itself. *Jerome Etienne* has a nice tutorial
    on doing this at [http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/](http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要在不同值之间平滑地过渡属性——例如，为了使门旋转以动画打开，你可以使用[Tween.js库](https://github.com/sole/tween.js)来这样做，而不是直接动画化网格。*Jerome
    Etienne*有一个关于如何进行这种动画的很好的教程，可以在[http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/](http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/)找到。
- en: Morph animation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形变动画
- en: Morph animation stores animation data as a sequence of positions. For example,
    if you had a cube with a *shrink* animation, your model could hold the positions
    of the vertices of the cube at full size and at the shrunk size. Then animation
    would consist of interpolating between those states during each rendering or **keyframe**.
    The data representing each state can hold either vertex targets or face normals.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 形变动画将动画数据存储为一系列位置。例如，如果你有一个具有*缩小*动画的立方体，你的模型可以保留立方体顶点的完整大小和缩小大小的位置。然后动画将包括在每个渲染或**关键帧**期间在这两种状态之间进行插值。表示每种状态的数据可以包含顶点目标或面法线。
- en: 'To use morph animation, the easiest approach is to use a `THREE.MorphAnimMesh`
    class, which is a subclass of the normal mesh. In the following example, the highlighted
    lines should only be included if the model uses normals:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用形变动画，最简单的方法是使用`THREE.MorphAnimMesh`类，它是普通网格的子类。在下面的示例中，如果模型使用法线，则应仅包含突出显示的行：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first thing we do is set our material to be aware that the mesh will be
    animated with the `morphTargets` properties and optionally with `morphNormal`
    properties. Next, we check whether colors will change during the animation, and
    set the mesh faces to their initial color if so (if you know your model doesn''t
    have `morphColors`, you can leave out that block). Then the normals are computed
    (if we have them) and our `MorphAnimMesh` animation is created. We set the `duration`
    value of the full animation, and finally store the mesh in the global `morphs`
    array so that we can update it during our physics loop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将材质设置为知道网格将使用`morphTargets`属性进行动画，并且可选地使用`morphNormal`属性。接下来，我们检查颜色是否会在动画期间改变，如果是这样，则将网格面设置为它们的初始颜色（如果你知道你的模型没有`morphColors`，你可以省略该块）。然后计算法线（如果我们有它们）并创建我们的`MorphAnimMesh`动画。我们设置整个动画的`duration`值，最后将网格存储在全局`morphs`数组中，这样我们就可以在物理循环中更新它：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Under the hood, the `updateAnimation` method just changes which set of positions
    in the animation the mesh should be interpolating between. By default, the animation
    will start immediately and loop indefinitely. To stop animating, just stop calling
    `updateAnimation`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`updateAnimation`方法只是更改网格应在其动画中插值的位置集。默认情况下，动画将立即开始并无限循环。要停止动画，只需停止调用`updateAnimation`。
- en: Skeletal animation
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 骨骼动画
- en: Skeletal animation moves a group of vertices in a mesh together by making them
    follow the movement of `bone`. This is generally easier to design because artists
    only have to move a few bones instead of potentially thousands of vertices. It's
    also typically less memory-intensive for the same reason.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼动画通过使顶点群跟随“骨骼”的运动来一起移动网格中的顶点。这通常更容易设计，因为艺术家只需要移动几个骨骼，而不是可能成千上万的顶点。这也通常更节省内存，原因相同。
- en: 'To use morph animation, use a `THREE.SkinnedMesh` class, which is a subclass
    of the normal mesh:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用形变动画，使用`THREE.SkinnedMesh`类，它是普通网格的子类：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The model we're using in this example already has materials, so unlike in the
    morph animation examples, we have to change the existing materials instead of
    creating a new one. For skeletal animation we have to enable **skinning**, which
    refers to how the materials are wrapped around the mesh as it moves. We use the
    `THREE.AnimationHandler` utility to track where we are in the current animation
    and a `THREE.SkinnedMesh` utility to properly handle our model's bones. Then we
    use the mesh to create a new `THREE.Animation` and play it. The animation's `interpolationType`
    determines how the mesh transitions between states. If you want cubic spline easing
    (slow then fast then slow), use `THREE.AnimationHandler.CATMULLROM` instead of
    the `LINEAR` easing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用的模型已经具有材质，因此与形态动画示例不同，我们必须更改现有的材质而不是创建一个新的材质。对于骨骼动画，我们必须启用**皮肤**，这指的是材质如何随着网格的移动而包裹网格。我们使用`THREE.AnimationHandler`实用程序来跟踪我们在当前动画中的位置，并使用`THREE.SkinnedMesh`实用程序来正确处理我们的模型骨骼。然后我们使用网格创建一个新的`THREE.Animation`并播放它。动画的`interpolationType`决定了网格在状态之间如何过渡。如果您想使用立方样条插值（慢-快-慢），请使用`THREE.AnimationHandler.CATMULLROM`而不是`LINEAR`插值。
- en: 'We also need to update the animation in our physics loop:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在物理循环中更新动画：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is possible to use both skeletal and morph animations at the same time. In
    this case, the best approach is to treat the animation as skeletal and manually
    update the mesh's `morphTargetInfluences` array as demonstrated in `examples/webgl_animation_skinning_morph.html`
    in the Three.js project.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用骨骼和形态动画是可能的。在这种情况下，最好的方法是将动画视为骨骼动画，并手动更新网格的`morphTargetInfluences`数组，如Three.js项目中的`examples/webgl_animation_skinning_morph.html`中所示。
- en: Particle systems
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统
- en: Now that our flags are in place and we've learned how to manage the resources
    we'll need to decorate our world, let's add some additional visual effects. The
    first type of effect we'll look at is particle systems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了旗帜，并且我们已经学会了如何管理我们需要的资源来装饰我们的世界，让我们添加一些额外的视觉效果。我们将首先查看的第一种效果是粒子系统。
- en: 'Particles are planes that always face the camera, usually grouped together
    into a *system* to create some effect like fire or steam. They are essential for
    creating great visuals like this colorful heart:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子是始终面向摄像机的平面，通常成组在一起形成一个*系统*，以产生一些效果，如火焰或蒸汽。它们对于创建像这样五彩斑斓的心形等出色视觉效果至关重要：
- en: '![Particle systems](img/8539_04_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/8539_04_02.jpg)'
- en: Particles from examples/webgl_particles_shapes.html with shapes by zz85
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 来自examples/webgl_particles_shapes.html的示例中的粒子，形状由zz85设计
- en: Capturing the flag
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获旗帜
- en: 'We''d like to set off a celebratory fireworks-style display when the player
    captures a flag, so if you haven''t already done so, go ahead and add the mechanics
    of capturing flags. The core logic should be in a function we''ll call for each
    player in our physics loop:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家捕获旗帜时，我们希望启动一个庆祝性的烟花式展示，所以如果您还没有这样做，请继续添加捕获旗帜的机制。核心逻辑应该在一个函数中，我们将在物理循环中的每个玩家上调用此函数：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the player has the opponent's flag, we're checking if they're standing on
    their own flag so that they can score; if the player doesn't have the flag, we're
    checking if they're standing on the other flag so that they can steal it. When
    a flag is stolen it is marked as invisible, and it is marked as visible again
    when it is returned. (The code for this is not included in the preceding example,
    but flags also need to be returned when a flag carrier dies.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家拥有对手的旗帜，我们会检查他们是否站在自己的旗帜上，以便他们可以得分；如果玩家没有旗帜，我们会检查他们是否站在另一面旗帜上，以便他们可以偷取它。当旗帜被偷走时，它会被标记为不可见，当它被归还时，它会被标记为可见。（此代码不包括在先前的示例中，但当旗帜携带者死亡时，旗帜也需要被归还。）
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Objects'' `visible` property is a Boolean controlling whether or not they are
    rendered. In the WebGL renderer, setting this property does not affect child objects,
    though it does affect child objects in other renderers. This is important to know
    for multipart meshes, which are often imported in a hierarchy. To set the visibility
    for an object and all its children, you can use the `traverse` method, which invokes
    a callback for each object in the hierarchy:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的`visible`属性是一个布尔值，用于控制它们是否被渲染。在WebGL渲染器中，设置此属性不会影响子对象，尽管它会影响其他渲染器中的子对象。对于多部分网格，这一点很重要，因为它们通常以层次结构导入。要设置对象及其所有子对象的可见性，您可以使用`traverse`方法，该方法为层次结构中的每个对象调用回调函数：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Particles and Sprites
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子和精灵
- en: '`CanvasRenderer` and `WebGLRenderer` use different objects to represent individual
    particles. When using canvas, use `THREE.Particle`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanvasRenderer` 和 `WebGLRenderer` 使用不同的对象来表示单个粒子。当使用画布时，使用 `THREE.Particle`：'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, particles are basically just made up of a color or an image.
    Similarly, when using WebGL, use `THREE.Sprite`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，粒子基本上是由颜色或图像组成的。同样，在使用 WebGL 时，使用 `THREE.Sprite`：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Sprites are basically the same as particles except that they also support different
    blending modes. Supported blending modes are shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite 与粒子基本上相同，只是它们还支持不同的混合模式。支持的混合模式在以下屏幕截图中显示：
- en: '![Particles and Sprites](img/8539_04_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![粒子和 Sprite](img/8539_04_03.jpg)'
- en: Different blending modes, as displayed in examples/webgl_materials_blending.html
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的混合模式，如 examples/webgl_materials_blending.html 中的示例所示
- en: In both cases, you can use the `position` and `scale` vectors the same way we've
    been using them for meshes, except that `scale.z` has no effect.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您可以使用 `position` 和 `scale` 向量，就像我们之前使用网格一样，只是 `scale.z` 没有作用。
- en: Particle systems
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子系统
- en: Particle systems are a way to create and manage lots of particles at once. They
    use geometry to place a particle on each vertex. This has the benefit that you
    can use built-in tools we've already seen to manipulate the geometry. For example,
    you can use a particle system with imported animated geometry. However, they also
    have several limitations. First, creating dynamic effects can be difficult because
    you have to code them manually, for example by updating the velocity of each individual
    particle in each frame. Second, you can't add and remove particles (although you
    can set their opacity to zero), so you have to pre-allocate as many particles
    as you might need. Third, you can only use a single material per particle system,
    so all the particles in a given system will have the same image, size, and rotation
    (though you can independently change their color).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是一种同时创建和管理大量粒子的方法。它们使用几何形状将粒子放置在每个顶点上。这有一个好处，那就是您可以使用我们之前已经看到的内置工具来操纵几何形状。例如，您可以使用带有导入的动画几何形状的粒子系统。然而，它们也有一些限制。首先，创建动态效果可能很困难，因为您必须手动编码它们，例如通过在每一帧中更新每个单独粒子的速度。其次，您不能添加和删除粒子（尽管您可以将其不透明度设置为零），因此您必须预先分配可能需要的粒子数量。第三，每个粒子系统只能使用一种材质，因此给定系统中的所有粒子都将具有相同的图像、大小和旋转（尽管您可以独立地更改它们的颜色）。
- en: 'For the purposes of our CTF game, we''ll create a celebratory particle system
    when we create our flags:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们 CTF 游戏的目的，当创建旗帜时，我们将创建一个庆祝的粒子系统：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will create small particles in a roughly spherical shape around the flag
    we're initializing. The `sortParticles` property indicates whether particles should
    be sorted by depth so that particles closer to the camera appear in front of those
    that are farther away. Sometimes sorting particles can create a strange popping
    effect when particles are moving and overlapping, so you may want to test and
    see what looks better to you. Additionally, enabling sorting when you have many
    thousands of particles can be computationally expensive, though it should be fine
    with the few hundred particles in our example.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在初始化的旗帜周围创建出大致球形的微小粒子。`sortParticles` 属性指示是否应按深度对粒子进行排序，以便靠近摄像机的粒子出现在远离摄像机的粒子之前。有时，当粒子移动和重叠时，排序粒子可能会产生奇怪的爆裂效果，因此您可能想要测试并看看哪种效果更适合您。此外，当您有数万个粒子时启用排序可能会很昂贵，尽管在我们的示例中只有几百个粒子应该没问题。
- en: 'To complete the effect, we actually want to make the system invisible with
    `system.visible = false`, then temporarily make it visible when a flag is captured
    later. Also, our particles will also be more interesting if they move around.
    We can rotate the whole particle system by changing its rotation vector:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成效果，我们实际上想通过将 `system.visible = false` 使系统不可见，然后在稍后捕获旗帜时临时使其可见。此外，如果粒子四处移动，我们的粒子将更有趣。我们可以通过更改其旋转向量来旋转整个粒子系统：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can see the result in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到结果：
- en: '![Particle systems](img/8539_04_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/8539_04_04.jpg)'
- en: A celebratory particle effect
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 庆祝粒子效果
- en: We can also move the geometry's vertices directly if we want. To do this, we
    first need to set `geometry.dynamic = true` before creating the particle system,
    then set `geometry.verticesNeedUpdate = true` every time we change vertex positions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接移动几何形状的顶点。为此，我们首先需要在创建粒子系统之前将 `geometry.dynamic = true` 设置为 true，然后每次更改顶点位置时都设置
    `geometry.verticesNeedUpdate = true`。
- en: We don't need to do this for our game, but it's also possible to change the
    color of individual particles by changing the `geometry.colors` array. You can
    fill this array with one color for each vertex (at the same index) and that color
    will be blended with the color or image of the particle's material.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们不需要这样做，但也可以通过更改`geometry.colors`数组来改变单个粒子的颜色。你可以为每个顶点（在相同的索引处）填充一个颜色，并且该颜色将与粒子的材质颜色或图像混合。
- en: Some things you may want to do with particles can get quite complicated. For
    example, to simulate spray from a waterfall, you might use particles with some
    physics applied. To simplify similar advanced use cases, two libraries have emerged.
    One of them, called **Sparks**, is actually included with Three.js in the `examples/js`
    folder. It's also available online at [https://github.com/zz85/sparks.js](https://github.com/zz85/sparks.js)
    and is written by *zz85*. A newer library written by *Luke Moody* and *Lee Stemkoski*
    is available at [https://github.com/squarefeet/ShaderParticleEngine](https://github.com/squarefeet/ShaderParticleEngine),
    and while relatively untested, the API is simpler and it's somewhat lighter in
    weight.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要对粒子做一些事情，可能会变得相当复杂。例如，为了模拟瀑布的喷雾，你可能需要使用应用了一些物理学的粒子。为了简化类似的高级用例，已经出现了两个库。其中一个，称为**Sparks**，实际上是包含在Three.js的`examples/js`文件夹中的。它也在线上可用，网址为[https://github.com/zz85/sparks.js](https://github.com/zz85/sparks.js)，由*zz85*编写。由*Luke
    Moody*和*Lee Stemkoski*编写的一个较新的库可在[https://github.com/squarefeet/ShaderParticleEngine](https://github.com/squarefeet/ShaderParticleEngine)找到，尽管相对未经测试，但其API更简单，且在重量上更轻。
- en: Sound
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音
- en: Although Three.js is a graphics library, there is an experimental `THREE.AudioObject`
    class at `examples/js/AudioObject.js` that uses the Web Audio API to support 3D
    sound effects. This object inherits from `Object3D` so it can be attached to other
    objects and placed in the world. It is designed to use spatially accurate 3D sound.
    The main caveat is that the class only works with Chrome as of Three.js version
    r61 due to browser incompatibilities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Three.js是一个图形库，但在`examples/js/AudioObject.js`中有一个实验性的`THREE.AudioObject`类，它使用Web
    Audio API来支持3D音效。该对象继承自`Object3D`，因此可以附加到其他对象并放置在世界中。它旨在使用空间精确的3D音效。主要的限制是，由于浏览器不兼容，该类仅从Three.js版本r61开始与Chrome兼容。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Like with external models, audio is loaded with AJAX, so local file URLs won't
    work by default.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像外部模型一样，音频通过AJAX加载，因此默认情况下本地文件URL无法工作。
- en: 'That said, let''s go ahead and try adding some cheering sounds when a flag
    is captured. First, we''ll create our `AudioObject` instances when we initialize
    our flags:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续尝试在捕获旗帜时添加一些欢呼声。首先，当初始化我们的旗帜时，我们将创建我们的`AudioObject`实例：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code creates an object to play the `cheering.ogg` file with a volume of
    `0`, a playback rate of `1`, and no looping. We set the volume to zero initially
    because `AudioObject` plays the sound immediately, and we only want it to play
    when we capture a flag. To that end, let''s trigger the sound to play when we
    capture a flag:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个对象来播放`cheering.ogg`文件，音量为`0`，播放速率为`1`，且不循环。我们最初将音量设置为零，因为`AudioObject`会立即播放声音，而我们只想在捕获旗帜时播放。为此，让我们在捕获旗帜时触发声音播放：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`AudioObject` does not provide a way to play a sound again, so we have to call
    the constructor to force it to do that. This time, we set the volume to `1`. The
    crowd goes wild!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioObject`不提供再次播放声音的方法，因此我们必须调用构造函数来强制它这样做。这次，我们将音量设置为`1`。人群疯狂了！'
- en: If you set the final parameter to `true` instead of `false`, you can also use
    this to play looping sounds or even music.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将最终参数设置为`true`而不是`false`，你也可以使用这个来播放循环声音或甚至音乐。
- en: Renderer effects and postprocessing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染器效果和后处理
- en: 'Sometimes, effects that change the entire display can give a game or area a
    lot of personality. Three.js supports two major kinds of effects: renderer and
    postprocessing.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，改变整个显示效果可以给游戏或区域增添很多个性。Three.js支持两种主要类型的效果：渲染器和后处理。
- en: 'Renderer effects can be found in `examples/js/effects`. They change what the
    renderer outputs, usually by rendering the scene multiple times with different
    settings. For example, the Anaglyph effect produces the familiar red-and-blue
    shadows that work with 3D glasses to make the scene pop out of the screen, and
    it does this by rendering the scene once for the left eye, once for the right
    eye, and once combined. Setting this up is easy:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器效果可以在`examples/js/effects`中找到。它们改变渲染器输出的内容，通常是通过以不同的设置多次渲染场景来实现的。例如，Anaglyph效果会产生熟悉的红蓝阴影，与3D眼镜配合使用可以使场景从屏幕中突出出来，这是通过为左眼、右眼和一次组合渲染场景来实现的。设置起来很容易：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then just call `effect.render(scene, camera)` instead of `renderer.render(scene,
    camera)`. All of the other renderer effects work the same way except the ASCII
    effect, which requires adding a separate canvas so it can render the scene to
    text characters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需调用`effect.render(scene, camera)`而不是`renderer.render(scene, camera)`。除了ASCII效果外，所有其他渲染器效果的工作方式都相同，ASCII效果需要添加一个单独的画布，以便将其渲染为文本字符。
- en: Postprocessing effects work by applying a GLSL shader over the scene. There
    are many shaders that can be used in the `examples/js`, `examples/js/postprocessing`,
    and `examples/js/shaders` folders. Most of these are just fun, but a few are useful
    in games. The **DOF** (**depth-of-field**) effect, for example, blurs distant
    objects and brings closer ones into focus.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 后处理效果通过在场景上应用GLSL着色器来实现。`examples/js`、`examples/js/postprocessing`和`examples/js/shaders`文件夹中有许多可以使用的着色器。其中大多数只是有趣，但有一些在游戏中很有用。例如，**DOF**（**景深**）效果会模糊远处的物体，并将近处的物体聚焦。
- en: 'The `EffectComposer` in `examples/js/postprocessing` makes applying post-processing
    easier and allows using multiple effects. For example, to use the `EdgeShader`,
    start by adding the necessary files in your HTML:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples/js/postprocessing`中的`EffectComposer`使应用后处理变得更容易，并允许使用多个效果。例如，要使用`EdgeShader`，首先在您的HTML中添加必要的文件：'
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then set up the effect:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置效果：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code requests two postprocessing rendering passes during which the edge
    and copy shaders will both be applied. The edge effect requires knowledge of the
    canvas size, and the effects will be rendered after the copy shader is applied.
    The final step is to replace our `renderer.render(scene, camera)` call with `composer.render()`,
    and we get a pretty dramatic result, as you can see in the next screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在两个后处理渲染过程中请求应用边缘和复制着色器。边缘效果需要了解画布大小，并且效果将在复制着色器应用后渲染。最后一步是将我们的`renderer.render(scene,
    camera)`调用替换为`composer.render()`，您可以在下一张截图看到，这是一个相当戏剧性的结果：
- en: '![Renderer effects and postprocessing](img/8539_04_05.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![渲染器效果和后处理](img/8539_04_05.jpg)'
- en: Our game with the edge shader postprocessor
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们带有边缘着色器后处理器的游戏
- en: As previously mentioned, shaders are written in GLSL instead of JavaScript,
    and they can get pretty complex. As a result, we won't talk about how to write
    them here. However, you can browse and fork some shaders other people have written
    at [https://glsl.heroku.com/](https://glsl.heroku.com/). Three.js author *Mr.doob*
    has also written a shader editor at [http://www.mrdoob.com/projects/glsl_sandbox/](http://www.mrdoob.com/projects/glsl_sandbox/),
    and *Thibaut Despoulain* has written one as well at [http://shdr.bkcore.com/](http://shdr.bkcore.com/).
    Note that shaders can be used to display pretty much anything, and most shaders
    don't make sense as postprocessors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，着色器是用GLSL而不是JavaScript编写的，并且它们可以变得相当复杂。因此，我们在这里不会讨论如何编写它们。然而，您可以在[https://glsl.heroku.com/](https://glsl.heroku.com/)浏览并fork其他人编写的着色器。Three.js的作者*Mr.doob*也编写了一个着色器编辑器，网址为[http://www.mrdoob.com/projects/glsl_sandbox/](http://www.mrdoob.com/projects/glsl_sandbox/)，*Thibaut
    Despoulain*也编写了一个，网址为[http://shdr.bkcore.com/](http://shdr.bkcore.com/)。请注意，着色器可以用来显示几乎任何东西，但大多数着色器作为后处理来说并没有意义。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to manage 3D models and animation. We also explored
    particle systems, sound, and visual effects. Additionally, we used what we learned
    to transform our first-person shooter game from [Chapter 3](ch03.html "Chapter 3. Exploring
    and Interacting"), *Exploring and Interacting* into a Capture-the-Flag game. In
    the next chapter, we'll discuss game design concepts, workflow processes, performance
    considerations, and networking.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何管理3D模型和动画。我们还探讨了粒子系统、声音和视觉效果。此外，我们利用所学知识将我们的第一人称射击游戏从[第3章](ch03.html
    "第3章. 探索和交互")，*探索和交互*，转变为夺旗游戏。在下一章中，我们将讨论游戏设计概念、工作流程过程、性能考虑和网络。
