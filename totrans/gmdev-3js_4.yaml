- en: Chapter 4. Adding Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to manage external assets such as 3D models, as well
    as add details to your worlds with particle systems, sound, and graphic effects.
    It will also elaborate on the arena first-person shooter game we built in [Chapter
    3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring and Interacting*,
    to turn it into a Capture-the-Flag game.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up CTF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have a proper Capture-the-Flag game, we first need to have teams.
    There are several things that need to be associated with a given team:'
  prefs: []
  type: TYPE_NORMAL
- en: Flags (and the flag color)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Players (and the player skins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bullets (if you want to avoid same-team damage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potentially map decorations/materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest way to associate each of these elements with a team is to just
    add a property with a simple value such as `R` or `B` to represent Red or Blue
    (or some other team name). A more advanced approach could be to create a `Team`
    class that holds references to everything that belongs to that team, since that
    could offer optimizations such as limiting the number of collision checks that
    need to be performed. If you do that, however, make sure you remove all the appropriate
    references from the `Team` container when removing something (such as a bullet)
    from the world in order to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to modify our map to add flags for the Red and Blue teams, which
    we''ll represent as `R` and `B`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to actually add those flags to the world. Flags are not simple geometric
    primitive shapes though, so we'll want to import a more complex mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Asset management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primitive geometric shapes are great for tests, but any serious game these days
    will likely make heavy use of 3D models created in a specialized program such
    as Blender, Maya, or 3ds Max. These models need to be imported into Three.js scenes
    and converted to `THREE.Mesh` objects with geometry and materials. Luckily, Three.js
    provides importers called **loaders** for a variety of file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our flags, we''ll use a simple mesh in Collada format. (Collada is an XML-based
    format for storing 3D mesh and animation data, with files ending in `.dae`.) You
    can download our flag mesh from the Packt Publishing website. The `ColladaLoader`
    is not included in the main Three.js library, but can be copied from `examples/js/loaders/ColladaLoader.js`
    and then included in your HTML as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the model can be loaded like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Often imported models need to be resized and repositioned, so you will probably
    want to set `result.scene.scale` and `result.scene.position` before adding the
    mesh to the world. You can see the loaded model in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loaders](img/8539_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Blue team's flag
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, importing meshes will not work on local `file:///` URLs. This is
    because when JavaScript requests the file, browsers' default security settings
    refuse to return local system files. To get around this restriction, you can either
    run a local HTTP server or change your browser's security settings as described
    at [https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally](https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally).
  prefs: []
  type: TYPE_NORMAL
- en: There are many other loaders for models in other file formats, including CTM,
    OBJ, MTL, PLY, STL, UTF8, VRML, and VTK. These are located in the `examples/js/loaders`
    folder. Almost all of the loaders have a `load` method, like the `ColladaLoader`
    method mentioned previously, which takes a function to call when loading is finished.
    However, loaders do not have a standardized format, and some of them work in slightly
    different ways. In particular, the parameters passed to the callback depend on
    the file type. You should check the `examples` folder for demos of the loader
    you want to use to make sure you handle the returned result correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we get a group of sub-meshes (in the `result.scene`) back from
    the `ColladaLoader` because Collada files can contain multiple meshes. We need
    to modify the flag''s materials to make sure each flag reflects its team''s color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Recall that when we set up our camera to follow the player around in the last
    chapter, we added the camera to the `player` object. Whenever objects are grouped
    together this way, they can be accessed through the parent's `children` array.
    In this case, we're using that array to alter the material for the cloth part
    of the flag to make it blue or red depending on which team it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to loaders for standard 3D model file formats, there are a number
    of Three.js-specific loaders included directly in the library. In particular,
    `THREE.JSONLoader` is designed to load single meshes, while `THREE.SceneLoader`
    can load entire scenes (including lighting, cameras, and other Three.js entities).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are also built-in loaders for assets other than 3D models. For example,
    we've already seen `THREE.TextureLoader` at work behind the scenes of `THREE.ImageUtils.loadTexture`.
    You can also directly load pieces of meshes, including geometry, images, and materials.
    Other objects such as lights, cameras, and even arbitrary resources can be loaded
    as well. However, these loaders are normally invoked under the hood of the library
    rather than directly by developers because it usually makes more sense to load
    entire models or scenes rather than the individual pieces. As a result, we will
    not cover these loaders here, but you can find them in the `src/loaders` folder
    if you would like to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `ColladaLoader`, the `JSONLoader` uses a `load` method with a callback.
    However, the callback receives a `THREE.Geometry` object as its first parameter.
    Not all 3D models have associated materials, but if the object does have materials,
    they will be passed to the callback in an array as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As explained in [Chapter 2](ch02.html "Chapter 2. Building a World"), *Building
    a World*, `MeshFaceMaterial` is a container that maps multiple materials to different
    faces of the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SceneLoader` is a little different from other loaders because it can use
    other loaders to handle specific parts of the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If a scene includes an external model, the `SceneLoader` will try to import
    it using the appropriate handler. Use the `addGeometryHandler` method to add loaders
    for file formats that only support single meshes, and use `addHierarchyHandler`
    to add loaders for file formats that support multimesh scenes (DAE, OBJ, and UTF8).
    In this example, CTM and DAE files will be loaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting to Three.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Three.js project includes extensions for the 3ds Max, Maya, and Blender
    3D modeling programs to make exporting models to the Three.js JSON format easier.
    These extensions have some limitations; for example, some modifiers such as smoothing
    groups are not supported. There are two common alternatives to avoid these issues.
    The first is to export models to a format such as DAE and use the corresponding
    Three.js importer. Another approach is to export models to OBJ format and then
    run the Python converter script in the `utils/converters` folder to transform
    the model to Three.js JSON format. Choosing a file format is mostly a trade-off
    in file size (how long the file will take to retrieve) and initialization (how
    long the file will take to parse). You may need to test different formats for
    performance-sensitive projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python converters were written for Python 2.x and may not work in 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common problems that arise when importing models are due to not exporting
    all the required properties. In your modeling program''s export dialog, if given
    a choice, make sure to check the boxes for these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skinning / Materials / Texture Maps / Texture Coordinates / UVs / Colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flip YZ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morph animation (if applicable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All meshes (if applicable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your modeling software may not have all these options, and you may need to check
    other boxes as well.
  prefs: []
  type: TYPE_NORMAL
- en: To be on the safe side, you may also want to make sure the model you're exporting
    is a top-level object rather than grouped with other things, that the model is
    not translated or rotated, that the scaling is set to `1`, and that you've deleted
    the model's history.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting from Three.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js provides several exporters in the `examples/js/exporters` folder that
    allow saving scenes or objects in various formats, including OBJ, STL, and JSON.
    Like with loaders, more or less any Three.js entity can be exported, but the most
    common approach is to export a complete mesh or scene. The `SceneExporter` tool
    is the most common tool here, and using it is fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then `output` value can be saved into a JSON file that `SceneLoader` can read
    later. The one major issue to watch out for is that custom properties won't get
    exported. That includes nonstandard properties added to object instances, properties
    provided by subclasses of Three.js classes, custom classes that don't inherit
    from Three.js classes, and anything that isn't part of the `scene`. If you need
    any of these things to be exported, you may be better off writing a custom exporter
    and importer, possibly starting with one of the ones Three.js provides.
  prefs: []
  type: TYPE_NORMAL
- en: Managing loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, when our CTF map is initialized, we ask a loader to fetch the flag
    model. This works fine because the model is pretty small and we only have the
    one model to load. However, if we had many models or if they were bigger, we may
    notice them popping into the map when they finished loading, even after we've
    started playing. To fix this, larger projects should preload assets before the
    player can start playing the game. All that's required to do so is to disallow
    entering the map until the last model's callback has been executed. Unfortunately,
    if we have a lot of models and we have to load them one by one, it can be hard
    to keep track of how many models are remaining. Users may also lose interest if
    nothing is happening while models are loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, this is resolved by loading all the models at once with the `SceneLoader`.
    The `SceneLoader` objects have a `callbackProgress` property that holds a function
    which is invoked after each object in the scene has completed loading. The callback
    takes two parameters, `progress` and `result`. The `progress` object has four
    numeric properties that can be used to display a progress bar: `totalModels`,
    `totalTextures`, `loadedModels`, and `loadedTextures`. The result object contains
    all of the entities that have been loaded so far, and it''s also the value passed
    to the `onLoad` parameter of the loader''s `load` callback when all loading has
    been completed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider HTML like this for a loading bar, where the outer div has a defined
    width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you might include code like this in a `callbackProgress` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you can't use a `SceneLoader` or don't want to use it for other reasons,
    you will have to chain together your loaders manually. However, Three.js will
    start using **loading managers** in the future. Loading managers are just objects
    that work together with loaders to track when multiple resources have finished
    loading. The loading manager API is not yet stable as of Three.js version r61
    and it is not implemented in many of the loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using animated models is not very different from using normal models. There
    are essentially two types of animation to consider (in addition to manually changing
    the position of a mesh's geometry in Three.js).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If all you need is to smoothly transition properties between different values—for
    example, changing the rotation of a door in order to animate it opening—you can
    use the Tween.js library at [https://github.com/sole/tween.js](https://github.com/sole/tween.js)
    to do so instead of animating the mesh itself. *Jerome Etienne* has a nice tutorial
    on doing this at [http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/](http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/).
  prefs: []
  type: TYPE_NORMAL
- en: Morph animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Morph animation stores animation data as a sequence of positions. For example,
    if you had a cube with a *shrink* animation, your model could hold the positions
    of the vertices of the cube at full size and at the shrunk size. Then animation
    would consist of interpolating between those states during each rendering or **keyframe**.
    The data representing each state can hold either vertex targets or face normals.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use morph animation, the easiest approach is to use a `THREE.MorphAnimMesh`
    class, which is a subclass of the normal mesh. In the following example, the highlighted
    lines should only be included if the model uses normals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do is set our material to be aware that the mesh will be
    animated with the `morphTargets` properties and optionally with `morphNormal`
    properties. Next, we check whether colors will change during the animation, and
    set the mesh faces to their initial color if so (if you know your model doesn''t
    have `morphColors`, you can leave out that block). Then the normals are computed
    (if we have them) and our `MorphAnimMesh` animation is created. We set the `duration`
    value of the full animation, and finally store the mesh in the global `morphs`
    array so that we can update it during our physics loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the `updateAnimation` method just changes which set of positions
    in the animation the mesh should be interpolating between. By default, the animation
    will start immediately and loop indefinitely. To stop animating, just stop calling
    `updateAnimation`.
  prefs: []
  type: TYPE_NORMAL
- en: Skeletal animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Skeletal animation moves a group of vertices in a mesh together by making them
    follow the movement of `bone`. This is generally easier to design because artists
    only have to move a few bones instead of potentially thousands of vertices. It's
    also typically less memory-intensive for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use morph animation, use a `THREE.SkinnedMesh` class, which is a subclass
    of the normal mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The model we're using in this example already has materials, so unlike in the
    morph animation examples, we have to change the existing materials instead of
    creating a new one. For skeletal animation we have to enable **skinning**, which
    refers to how the materials are wrapped around the mesh as it moves. We use the
    `THREE.AnimationHandler` utility to track where we are in the current animation
    and a `THREE.SkinnedMesh` utility to properly handle our model's bones. Then we
    use the mesh to create a new `THREE.Animation` and play it. The animation's `interpolationType`
    determines how the mesh transitions between states. If you want cubic spline easing
    (slow then fast then slow), use `THREE.AnimationHandler.CATMULLROM` instead of
    the `LINEAR` easing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update the animation in our physics loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to use both skeletal and morph animations at the same time. In
    this case, the best approach is to treat the animation as skeletal and manually
    update the mesh's `morphTargetInfluences` array as demonstrated in `examples/webgl_animation_skinning_morph.html`
    in the Three.js project.
  prefs: []
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our flags are in place and we've learned how to manage the resources
    we'll need to decorate our world, let's add some additional visual effects. The
    first type of effect we'll look at is particle systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Particles are planes that always face the camera, usually grouped together
    into a *system* to create some effect like fire or steam. They are essential for
    creating great visuals like this colorful heart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle systems](img/8539_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Particles from examples/webgl_particles_shapes.html with shapes by zz85
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the flag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''d like to set off a celebratory fireworks-style display when the player
    captures a flag, so if you haven''t already done so, go ahead and add the mechanics
    of capturing flags. The core logic should be in a function we''ll call for each
    player in our physics loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the player has the opponent's flag, we're checking if they're standing on
    their own flag so that they can score; if the player doesn't have the flag, we're
    checking if they're standing on the other flag so that they can steal it. When
    a flag is stolen it is marked as invisible, and it is marked as visible again
    when it is returned. (The code for this is not included in the preceding example,
    but flags also need to be returned when a flag carrier dies.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objects'' `visible` property is a Boolean controlling whether or not they are
    rendered. In the WebGL renderer, setting this property does not affect child objects,
    though it does affect child objects in other renderers. This is important to know
    for multipart meshes, which are often imported in a hierarchy. To set the visibility
    for an object and all its children, you can use the `traverse` method, which invokes
    a callback for each object in the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Particles and Sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CanvasRenderer` and `WebGLRenderer` use different objects to represent individual
    particles. When using canvas, use `THREE.Particle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, particles are basically just made up of a color or an image.
    Similarly, when using WebGL, use `THREE.Sprite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Sprites are basically the same as particles except that they also support different
    blending modes. Supported blending modes are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Particles and Sprites](img/8539_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Different blending modes, as displayed in examples/webgl_materials_blending.html
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, you can use the `position` and `scale` vectors the same way we've
    been using them for meshes, except that `scale.z` has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Particle systems are a way to create and manage lots of particles at once. They
    use geometry to place a particle on each vertex. This has the benefit that you
    can use built-in tools we've already seen to manipulate the geometry. For example,
    you can use a particle system with imported animated geometry. However, they also
    have several limitations. First, creating dynamic effects can be difficult because
    you have to code them manually, for example by updating the velocity of each individual
    particle in each frame. Second, you can't add and remove particles (although you
    can set their opacity to zero), so you have to pre-allocate as many particles
    as you might need. Third, you can only use a single material per particle system,
    so all the particles in a given system will have the same image, size, and rotation
    (though you can independently change their color).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of our CTF game, we''ll create a celebratory particle system
    when we create our flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will create small particles in a roughly spherical shape around the flag
    we're initializing. The `sortParticles` property indicates whether particles should
    be sorted by depth so that particles closer to the camera appear in front of those
    that are farther away. Sometimes sorting particles can create a strange popping
    effect when particles are moving and overlapping, so you may want to test and
    see what looks better to you. Additionally, enabling sorting when you have many
    thousands of particles can be computationally expensive, though it should be fine
    with the few hundred particles in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the effect, we actually want to make the system invisible with
    `system.visible = false`, then temporarily make it visible when a flag is captured
    later. Also, our particles will also be more interesting if they move around.
    We can rotate the whole particle system by changing its rotation vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle systems](img/8539_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A celebratory particle effect
  prefs: []
  type: TYPE_NORMAL
- en: We can also move the geometry's vertices directly if we want. To do this, we
    first need to set `geometry.dynamic = true` before creating the particle system,
    then set `geometry.verticesNeedUpdate = true` every time we change vertex positions.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to do this for our game, but it's also possible to change the
    color of individual particles by changing the `geometry.colors` array. You can
    fill this array with one color for each vertex (at the same index) and that color
    will be blended with the color or image of the particle's material.
  prefs: []
  type: TYPE_NORMAL
- en: Some things you may want to do with particles can get quite complicated. For
    example, to simulate spray from a waterfall, you might use particles with some
    physics applied. To simplify similar advanced use cases, two libraries have emerged.
    One of them, called **Sparks**, is actually included with Three.js in the `examples/js`
    folder. It's also available online at [https://github.com/zz85/sparks.js](https://github.com/zz85/sparks.js)
    and is written by *zz85*. A newer library written by *Luke Moody* and *Lee Stemkoski*
    is available at [https://github.com/squarefeet/ShaderParticleEngine](https://github.com/squarefeet/ShaderParticleEngine),
    and while relatively untested, the API is simpler and it's somewhat lighter in
    weight.
  prefs: []
  type: TYPE_NORMAL
- en: Sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Three.js is a graphics library, there is an experimental `THREE.AudioObject`
    class at `examples/js/AudioObject.js` that uses the Web Audio API to support 3D
    sound effects. This object inherits from `Object3D` so it can be attached to other
    objects and placed in the world. It is designed to use spatially accurate 3D sound.
    The main caveat is that the class only works with Chrome as of Three.js version
    r61 due to browser incompatibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like with external models, audio is loaded with AJAX, so local file URLs won't
    work by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let''s go ahead and try adding some cheering sounds when a flag
    is captured. First, we''ll create our `AudioObject` instances when we initialize
    our flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates an object to play the `cheering.ogg` file with a volume of
    `0`, a playback rate of `1`, and no looping. We set the volume to zero initially
    because `AudioObject` plays the sound immediately, and we only want it to play
    when we capture a flag. To that end, let''s trigger the sound to play when we
    capture a flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`AudioObject` does not provide a way to play a sound again, so we have to call
    the constructor to force it to do that. This time, we set the volume to `1`. The
    crowd goes wild!'
  prefs: []
  type: TYPE_NORMAL
- en: If you set the final parameter to `true` instead of `false`, you can also use
    this to play looping sounds or even music.
  prefs: []
  type: TYPE_NORMAL
- en: Renderer effects and postprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, effects that change the entire display can give a game or area a
    lot of personality. Three.js supports two major kinds of effects: renderer and
    postprocessing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Renderer effects can be found in `examples/js/effects`. They change what the
    renderer outputs, usually by rendering the scene multiple times with different
    settings. For example, the Anaglyph effect produces the familiar red-and-blue
    shadows that work with 3D glasses to make the scene pop out of the screen, and
    it does this by rendering the scene once for the left eye, once for the right
    eye, and once combined. Setting this up is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then just call `effect.render(scene, camera)` instead of `renderer.render(scene,
    camera)`. All of the other renderer effects work the same way except the ASCII
    effect, which requires adding a separate canvas so it can render the scene to
    text characters.
  prefs: []
  type: TYPE_NORMAL
- en: Postprocessing effects work by applying a GLSL shader over the scene. There
    are many shaders that can be used in the `examples/js`, `examples/js/postprocessing`,
    and `examples/js/shaders` folders. Most of these are just fun, but a few are useful
    in games. The **DOF** (**depth-of-field**) effect, for example, blurs distant
    objects and brings closer ones into focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EffectComposer` in `examples/js/postprocessing` makes applying post-processing
    easier and allows using multiple effects. For example, to use the `EdgeShader`,
    start by adding the necessary files in your HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then set up the effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code requests two postprocessing rendering passes during which the edge
    and copy shaders will both be applied. The edge effect requires knowledge of the
    canvas size, and the effects will be rendered after the copy shader is applied.
    The final step is to replace our `renderer.render(scene, camera)` call with `composer.render()`,
    and we get a pretty dramatic result, as you can see in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Renderer effects and postprocessing](img/8539_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our game with the edge shader postprocessor
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, shaders are written in GLSL instead of JavaScript,
    and they can get pretty complex. As a result, we won't talk about how to write
    them here. However, you can browse and fork some shaders other people have written
    at [https://glsl.heroku.com/](https://glsl.heroku.com/). Three.js author *Mr.doob*
    has also written a shader editor at [http://www.mrdoob.com/projects/glsl_sandbox/](http://www.mrdoob.com/projects/glsl_sandbox/),
    and *Thibaut Despoulain* has written one as well at [http://shdr.bkcore.com/](http://shdr.bkcore.com/).
    Note that shaders can be used to display pretty much anything, and most shaders
    don't make sense as postprocessors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to manage 3D models and animation. We also explored
    particle systems, sound, and visual effects. Additionally, we used what we learned
    to transform our first-person shooter game from [Chapter 3](ch03.html "Chapter 3. Exploring
    and Interacting"), *Exploring and Interacting* into a Capture-the-Flag game. In
    the next chapter, we'll discuss game design concepts, workflow processes, performance
    considerations, and networking.
  prefs: []
  type: TYPE_NORMAL
