<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Building a Photo-sharing Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Building a Photo-sharing Application</h1></div></div></div><p>You've done a great job of understanding the most basic Backbone features. I think you're ready to level <a id="id97" class="indexterm"/>up and build something a little bigger, a little tougher. So in this chapter, we'll be building an Instagram clone of sorts; users will be able to create accounts, upload photos, follow other users, and comment on photos. We'll use a lot of the features that we used in the last chapter, but we'll also look at a bunch of new ones. We'll cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How user accounts affect a Backbone application</li><li class="listitem" style="list-style-type: disc">Writing your own model sync function</li><li class="listitem" style="list-style-type: disc">Alternate uses for models</li><li class="listitem" style="list-style-type: disc">Uploading files via AJAX</li></ul></div><div class="section" title="Creating user accounts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Creating user accounts</h1></div></div></div><p>We're going<a id="id98" class="indexterm"/> to start with the application template that we created in the first part of the last chapter. So, in the code download that <a id="id99" class="indexterm"/>comes with this book, find the <code class="literal">template</code> folder and make a copy of it. You'll need to install the necessary Node.js packages, of course; so, run <code class="literal">npm install</code> in the terminal.</p><p>The main difference between this application and the one we wrote in the last chapter is that this app has a much more significant server component; we want to be able to create user accounts and allow users to log in and log out. In fact, that's where we have to start. There's a really great Node.js package called <a id="id100" class="indexterm"/>Passport (<a class="ulink" href="http://passportjs.org/">http://passportjs.org/</a>), which makes authentication easy. We'll begin by installing the library, as well as the <code class="literal">bcrypt</code> package, which we'll use to encrypt users' passwords. Do this with these commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install passport --save</strong></span>
<span class="strong"><strong>npm install passport-local --save</strong></span>
<span class="strong"><strong>npm install bcrypt --save</strong></span>
</pre></div><p>The <code class="literal">--save</code> flag will add these packages to the <code class="literal">package.json</code> file.</p><p>There are <a id="id101" class="indexterm"/>several dozen lines of setup for this, so we're going to put them in their own file. In the project folder, create a <code class="literal">signin.js</code> file. The first step is to pull in the libraries that we need:</p><div class="informalexample"><pre class="programlisting">var bcrypt = require("bcrypt");
var LocalStrategy = require("passport-local").Strategy;
var salt = bcrypt.genSaltSync(10);</pre></div><p>A strategy, in the <a id="id102" class="indexterm"/>Passport terminology, is a method of authentication. We're authenticating locally, as opposed to using Twitter or Facebook. The <code class="literal">salt</code> variable will be used when we encrypt a user's password; it's a good practice in encryption to ensure our user's passwords are stored safely.</p><p>Next, we'll create our <code class="literal">strategy</code> object, like so:</p><div class="informalexample"><pre class="programlisting">exports.strategy = function (db) {
  return new LocalStrategy(function (username, password, done) {
    db.findOne({ username: username }, function (err, user) {
      if (!user) {
        done(null, false, { message: "Incorrect username." });
      } else if(!bcrypt.compareSync(password,user.passwordHash)) {
        done(null, false, { message: "Incorrect password." });
      } else {
        done(null, user);
      }
    });
  });
};</pre></div><p>First things first: we're assigning a property to an <code class="literal">exports</code> object. This is a Node.js module's object that can be exported from this file. When we require this file from the <code class="literal">server.js</code> file, anything that is a property of the <code class="literal">exports</code> object will be a property of the object returned from our <code class="literal">require</code> call.</p><p>Now, about the code here: this might look a little weird to you, but hang on. We can't just create the <code class="literal">strategy</code> method<a id="id103" class="indexterm"/>, because we need to use the database inside the <code class="literal">strategy</code> object. So, instead, we create a function that will take the database and return a <code class="literal">strategy</code> object. The <code class="literal">strategy</code> object constructor takes a function that will do the authentication and that function takes three parameters: the username, the password, and a callback function, which we call <code class="literal">done</code>.</p><p>Inside the function, we search the database for a user with the username we received as a parameter. Inside the callback, we first check to see if the user exists; if not, we call the <code class="literal">done</code> method by passing three parameters. The first is any error that occurred: that can just be <code class="literal">null</code>, because there's no error. Second is <code class="literal">false</code>; would be a user object, but we pass <code class="literal">false</code> because there isn't one. The last parameter is a message that we could display to the user.</p><p>However, if we <a id="id104" class="indexterm"/>do find a user, we'll need to match the password that we were given. When we begin creating users in the database, we'll<a id="id105" class="indexterm"/> use the <code class="literal">bcrypt</code> package to convert the plaintext password to a hash, so we don't store the plaintext version. Then, here, we can compare the results using the <code class="literal">bcrypt.compareSync</code> method; it takes the password we're comparing and the <code class="literal">user.passwordHash</code> property from the user object we got out of the database. Finally, if that comparison doesn't fail, we'll authenticate the user by sending the user object back in the <code class="literal">done</code> method.</p><p>This is a lot to start with, but it's important to begin with the authentication. We'll also need the<a id="id106" class="indexterm"/> <code class="literal">serialize</code> and<a id="id107" class="indexterm"/> <code class="literal">deserialize</code> methods; these will be used by the Passport's session feature to keep the user object available over page refreshes. The methods:</p><div class="informalexample"><pre class="programlisting">exports.serialize = function (user, done) {
  done(null, user.id);
};

exports.deserialize = function (db) {
  return function (id, done) {
    db.findOne({ id: id }, function (user) {
      done(null, user);
    });
  };
};</pre></div><p>The <code class="literal">serialize</code> method will send only the user's ID; in the <code class="literal">deserialize</code> method, we pull the same trick that we did with the <code class="literal">strategy</code> object, because we need the database inside the <code class="literal">deserialize</code> function. We return the function, which takes the ID, and send the user object to the <code class="literal">done</code> method.</p><p>One final piece for the module; when creating a user account, we'll need to convert the plaintext password to the hashed version. To do this, we'll use the<a id="id108" class="indexterm"/> <code class="literal">bcrypt.hashSync</code> method:</p><div class="informalexample"><pre class="programlisting">exports.hashPassword = function (password) {
  return bcrypt.hashSync(password, salt);
};</pre></div><p>Our function will take a single parameter—the plaintext password—and will hash it. Don't forget to pass the <code class="literal">salt</code> object we created as the second parameter to the <code class="literal">hashSync</code> method.</p><p>Now, we're <a id="id109" class="indexterm"/>ready to go to the <code class="literal">server.js</code> file and start things in there. We start by pulling in the Passport library and our <code class="literal">signin.js</code> file, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var passport = require("passport");
var signin   = require("./signin");</pre></div><p>If you're not <a id="id110" class="indexterm"/>familiar with requesting local Node.js modules, we can just pass a relative path to the <code class="literal">require</code> function, as you see here. We don't need to include the <code class="literal">.js</code> extension.</p><p>We also need to create the database instances that we'll need for the application; we do that like this:</p><div class="informalexample"><pre class="programlisting">var users = new Bourne("users.json");
var photos = new Bourne("photos.json");
var comments = new Bourne("comments.json");</pre></div><p>Next, we need to set up the passport functions that we put in the <code class="literal">signin.js</code> file. Use this code to do that:</p><div class="informalexample"><pre class="programlisting">passport.use(signin.strategy(users));
passport.serializeUser(signin.serialize);
passport.deserializeUser(signin.deserialize(users));</pre></div><p>We pass the function that creates our strategy to <code class="literal">passport.use</code>. Then, we set the <code class="literal">serialize</code> and <code class="literal">deserialize</code> functions. Notice that <code class="literal">strategy</code> and <code class="literal">deserialize</code> take the <code class="literal">users</code> database as arguments and return the correct function.</p><p>The next step is to prepare the middleware for the application. In our previous application, we didn't need much middleware, because we weren't doing that much on the server. But this time, we have to manage users' sessions. So here's what we have:</p><div class="informalexample"><pre class="programlisting">app.configure(function () {
  app.use(express.urlencoded());
  app.use(express.json());
  app.use(express.multipart());
  app.use(express.cookieParser());
  app.use(express.session({ secret: 'photo-application' }));
  app.use(passport.initialize());
  app.use(passport.session());
  app.use(express.static('public'));
});</pre></div><p>All the extra pieces of middleware—the ones that we didn't use in the previous chapter—are here for <a id="id111" class="indexterm"/>managing <a id="id112" class="indexterm"/>the user session. Actually, most of Express's middleware comes from the Connect library<a id="id113" class="indexterm"/> (<a class="ulink" href="https://github.com/senchalabs/connect">https://github.com/senchalabs/connect</a>); it might seem like we're adding a lot of middleware pieces here, but the truth is that they're broken into many small pieces, so you can choose exactly what you need. You can find out more about each individual piece on the Connect website (<a class="ulink" href="http://www.senchalabs.org/connect/">http://www.senchalabs.org/connect/</a>), but here are the pieces of middleware in this application that we haven't used before:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">urlencoded</code>: This <a id="id114" class="indexterm"/>method parses <code class="literal">x-ww-form-urlencoded</code> request bodies, providing the parsed object as <code class="literal">req.body</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">multipart</code>: This<a id="id115" class="indexterm"/> method parses multipart/form-data request bodies, providing the parsed object as <code class="literal">req.body</code> and <code class="literal">req.files</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">cookieParser</code>: This<a id="id116" class="indexterm"/> method parses the cookie header and provides that data as <code class="literal">req.cookies</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">session</code>: This<a id="id117" class="indexterm"/> method sets up the session store with the given options</li><li class="listitem" style="list-style-type: disc"><code class="literal">passport.initialize</code>: This <a id="id118" class="indexterm"/>method sets up Passport</li><li class="listitem" style="list-style-type: disc"><code class="literal">passport.session</code>: This <a id="id119" class="indexterm"/>method sets up persistent logins with Passport</li></ul></div><p>Now that these pieces are in place, we're ready to start writing some routes. We'll start with the routes that are specifically related to logging a user in and out. Here's the route for logging in:</p><div class="informalexample"><pre class="programlisting">app.get("/login", function (req, res) {
  res.render("login.ejs");
});</pre></div><p>The first one is simple; at the <code class="literal">/login</code> route, we'll render the <code class="literal">login.ejs</code> template. More on the content of this file soon. However, you can probably guess that there's going to be a form on that page. The users will put in their usernames and passwords; when they submit the form, the data will be posted back to this URL. So, we'll need to accept POST requests on the same URL. So, here's the <code class="literal">post</code> method version:</p><div class="informalexample"><pre class="programlisting">app.post('/login', passport.authenticate('local', {
  successRedirect: '/',
  failureRedirect: '/login'
}));</pre></div><p>You'll notice something different about this route; we're not writing our own function. Instead, we're calling the <code class="literal">passport.authenticate</code> function<a id="id120" class="indexterm"/>. As you saw earlier, we're using a local <a id="id121" class="indexterm"/>strategy, so that's the first parameter. After<a id="id122" class="indexterm"/> that, we have an object with two properties. It defines the routes to which the user will be redirected, depending on whether the user is authenticated or not. Obviously, if the user is successfully logged in, they will be sent to the root route; otherwise, they'll be sent back to the login page. The <code class="literal">get</code> method is given in the following code:</p><div class="informalexample"><pre class="programlisting">app.get("/logout", function (req, res) {
  req.logout();
  res.redirect('/');
});</pre></div><p>This one's simple too: to log out, we'll just call the <code class="literal">logout</code> method that Passport adds to the request object, and then redirect to the root route again.</p><p>Let's take care of the <code class="literal">login.ejs</code> file now. This will have to go in the <code class="literal">view</code> folder:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt; Sign In &lt;/h1&gt;
&lt;form method="post" action="/login"&gt;
  &lt;p&gt;Username: &lt;input name='username' type='text' /&gt;&lt;/p&gt;
  &lt;p&gt;Password: &lt;input name='password' type='password' /&gt;&lt;/p&gt;
  &lt;button&gt; Login &lt;/button&gt;
&lt;/form&gt;
&lt;h1&gt; Create Account &lt;/h1&gt;
&lt;form method="post" action="/create"&gt;
  &lt;p&gt;Username: &lt;input name='username' type='text' /&gt;&lt;/p&gt;
  &lt;p&gt;Password: &lt;input name='password' type='password' /&gt;&lt;/p&gt;
  &lt;button&gt; Create &lt;/button&gt;
&lt;/form&gt;</pre></div><p>We have two forms here: one for logging in, and one for creating users. Really, they're pretty much identical, but they'll be posted to different routes. We've already written the route for the first one, but we don't yet have a route for creating new users. So, guess what's next?</p><div class="informalexample"><pre class="programlisting">app.post('/create', function (req, res, next) {
  var userAttrs = {
    username: req.body.username,
    passwordHash: signin.hashPassword(req.body.password),
    following: []
  };
  users.findOne({ username: userAttrs.username }, function (existingUser) {
    if (!existingUser) {
      users.insert(userAttrs, function (user) {
        req.login(user, function (err) {
          res.redirect("/");
        });
      });
    } else {
      res.redirect("/");
    }
  });
});</pre></div><p>In this route's function, we start by creating the <code class="literal">userAttrs</code> object. We'll get the username and <a id="id123" class="indexterm"/>the password from the <code class="literal">req.body</code> object, making<a id="id124" class="indexterm"/> sure we use the <code class="literal">hashPassword</code> method<a id="id125" class="indexterm"/> to hash the password. We'll also include an empty array called <code class="literal">following</code>; we'll be storing the list of IDs of the users that they are following in this array.</p><p>Next, we'll search our database to see if another user has that username. If not, we can insert the user attribute objects we just created. Once we've stored the user, we can set the session up by using the <code class="literal">req.login</code> method<a id="id126" class="indexterm"/> that Passport gives us. Once they're logged in, we can redirect them to the root route.</p><p>That pretty much completes our user accounts feature. I should point out that I've left out some bits that would be important in a production application; for example, there will be no helpful messages for the user if they mistype their usernames or passwords when logging in, or try to create a user account with a username that already exists. They'll just be directed back to the forms. Of course, this as well as other important account-related features could be implemented (such as, changing a password); but we want to get to the Backbone code. That's what you're here for, right?</p><p>As we've seen, a user will be directed back to the root route once they are logged in. We actually don't have the root route method yet, so let's create it now, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">app.get('/*', function (req, res) {
  if (!req.user) {
    res.redirect("/login");
    return;
  }
  res.render("index.ejs", {
    user: JSON.stringify(safe(req.user))
  });
});</pre></div><p>It's actually not just the root route; it will collect many routes. The first step is to check for the <code class="literal">req.user</code> object, <a id="id127" class="indexterm"/>to see if the user is logged in. <a id="id128" class="indexterm"/>Remember the <code class="literal">deserialize</code> method we wrote? Passport will be using that behind the scenes to make sure that this <code class="literal">req.user</code> object is exactly the record we have in our database. If that isn't set, we'll send the user to the <code class="literal">/login</code> route. Otherwise, things can continue.</p><p>Right now, we're keeping things very simple; we're just rendering the <code class="literal">index.ejs</code> template. The only piece of data we're sending into that is the user. We already know why we need to wrap it in <code class="literal">JSON.stringify</code>, but what's the <code class="literal">safe</code> function? This is something we're about to write: the idea here is that we don't want to send the whole user record back to the browser; we want to remove some classified properties, such as <code class="literal">passwordHash</code>. Here is the <code class="literal">safe</code> function:</p><div class="informalexample"><pre class="programlisting">function safe(user){
  var toHide = ['passwordHash'], clone = JSON.parse(JSON.stringify(user));

  toHide.forEach(function (prop) {
    delete clone[prop];
  });
  return clone;
}</pre></div><p>It's very basic; we have an array of property names we want to remove. We start by cloning the <code class="literal">user</code> parameter. Then, we loop over the <code class="literal">toHide</code> variable, and delete those properties on the clone. Finally, we return the safe <code class="literal">user</code> object.</p><p>Well, things are really coming together here on the server. We're finally ready to turn our attention to the client-side code. We'll start with the <code class="literal">index.ejs</code> file.</p></div></div>
<div class="section" title="Creating our application navigation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Creating our application navigation</h1></div></div></div><p>We've already<a id="id129" class="indexterm"/> got a basic version of this from the template. However, <a id="id130" class="indexterm"/>we need to adjust the script tags at the bottom. After the tag for <code class="literal">backbone.js</code>, but before the tag for <code class="literal">app.js</code>, you'll want to add the following line:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;var USER = &lt;%- user %&gt;;&lt;/script&gt;</pre></div><p>This is the <code class="literal">user</code> object that is the user that is currently logged in. We'll need to be able to work with some of its properties inside our application components, which is why we need to load it before the <code class="literal">app.js</code> file.</p><p>Speaking of the <code class="literal">app.js</code> file, that's our next stop. This time, we're going to begin with a router:</p><div class="informalexample"><pre class="programlisting">var AppRouter = Backbone.Router.extend({
  initialize: function (options) {
    this.main = options.main;
    this.navView = new NavView();
  },
  routes: {
    '': 'index'
  },
  index: function () {
    this.main.html(this.navView.render().el);
  }
});</pre></div><p>This is very similar to the router from our previous application. Any options—such as DOM elements, models, or collections—that we'll want to use inside our application will be passed into the router constructor. As you can see, we're prepared for the <code class="literal">main</code> element (mother of all that's displayed to the user). We'll also create a <code class="literal">navView</code> property. You can probably guess that this will display some navigation; our app will have several important links, and we want to make it simple for our users to get around. We'll write this view next.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>You might wonder why we've made <code class="literal">USER</code> a global variable instead of a property of our router. After all, as we saw last time, those properties are data from the server that we need inside views here on the browser, right? There's really no reason you couldn't, but I prefer to do it this way because our application isn't really about manipulating user records. While we will have a <code class="literal">User</code> class, it will just be for convenience. User records are not created or modified on the client side.</p></div></div><p>In our <code class="literal">routes</code> object, we're setting up our index route. Right now, we will only be rendering the navigation in that <code class="literal">index</code> method, but it's a good start.</p><p>Let's <a id="id131" class="indexterm"/>write<a id="id132" class="indexterm"/> the navigation view. It's the simplest view we have in this application, which is created by the following code:</p><div class="informalexample"><pre class="programlisting">var NavView = Backbone.View.extend({
  template: _.template($("#navView").html()),
  render: function () {
    this.el.innerHTML = this.template(USER);
    return this;
  }
});</pre></div><p>This code is<a id="id133" class="indexterm"/> pretty standard view code. Notice that we're using the <code class="literal">USER</code> object as the data for this template. Here's the template content, which goes in the <code class="literal">index.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="navView"&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/users"&gt;All Users&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/users/{{id}}"&gt;My Profile&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/upload"&gt;Add Photo&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;Logged in as &lt;strong&gt;{{ username }}&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/logout"&gt;Log out&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;hr /&gt;
&lt;/script&gt;</pre></div><p>We've got enough here to give this a try. In the <code class="literal">index.ejs</code> file, make sure we're creating and starting the router by using the following code:</p><div class="informalexample"><pre class="programlisting">var r = new AppRouter({ 
  main: $("#main")
});
Backbone.history.start({ pushState: true });</pre></div><p>Start up the server (<code class="literal">npm start</code>) and head to <code class="literal">http://localhost:3000</code>. You should see something like the following screenshot:</p><div class="mediaobject"><img src="graphics/6997OS_02_01.jpg" alt="Creating our application navigation"/></div><p>Go ahead and create a new user account by putting a username and password into the bottom<a id="id134" class="indexterm"/> form. <a id="id135" class="indexterm"/>When<a id="id136" class="indexterm"/> you click on the <span class="strong"><strong>Create</strong></span> button, you'll be sent to a screen like this:</p><div class="mediaobject"><img src="graphics/6997OS_02_02.jpg" alt="Creating our application navigation"/></div><p>That's great! Things are shaping up.</p><p>As you work through building this application, you're going to find something annoying; every time you make a change, <code class="literal">nodemon</code> will restart the server, and the session that keeps you logged in will disappear. You'll have to log in again, every time. To get around this, I added the following code at the top of the <code class="literal">server.js</code> file:</p><div class="informalexample"><pre class="programlisting">var requser = {
  username: "andrew",
  id: 1
};</pre></div><p>Then,<a id="id137" class="indexterm"/> everywhere that you use <code class="literal">req.user</code>, use <code class="literal">requser</code> instead. It's easy to do a search and replace on this, and it will keep you logged in over server refreshes. I'll continue to use <code class="literal">req.user</code> in the<a id="id138" class="indexterm"/> code snippets ahead. However, this convenience hack isn't perfect. When we get to the feature of following other users, you'll have to remove this <code class="literal">requser</code> variable, or things won't make sense.</p></div>
<div class="section" title="Uploading photos"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Uploading photos</h1></div></div></div><p>Let's tackle <a id="id139" class="indexterm"/>the file uploads next. This is a photo <a id="id140" class="indexterm"/>sharing website, so it's one of the most important features. Let's begin by creating a view for the upload form:</p><div class="informalexample"><pre class="programlisting">var AddPhotoView = Backbone.View.extend({
  tagName: "form",
  initialize: function (options) {
    this.photos = options.photos;
  },
  template: _.template($("#addPhotoView").html()),
  events: {
    "click button": "uploadFile"
  },
  render: function () {
    this.el.innerHTML = this.template();
    return this;
  },
  uploadFile: function (evt) {
    evt.preventDefault();
    var photo = new Photo({
      file: $("#imageUpload")[0].files[0],
      caption: $("#imageCaption").val()
    });
    this.photos.create(photo, { wait: true });
    this.el.reset();
  }
});</pre></div><p>We start with an <code class="literal">initialize</code> function that assigns a property called <code class="literal">photos</code> that we get from the <code class="literal">options</code> object. This <code class="literal">photos</code> object is actually a collection, so you might wonder why we're <a id="id141" class="indexterm"/>not calling it <code class="literal">collection</code> in the <code class="literal">options</code> object; as you know, Backbone would handle this assignment automatically for us. The reason we're not doing it that way is so that it's clear that this view isn't for displaying this collection; it needs the collection for another reason (namely, to add a <code class="literal">Photo</code> model instance). You can write this off as semantics, but I hope the break from a Backbone convention makes someone reading the code pause and look for a reason.</p><p>The <code class="literal">template</code>, <code class="literal">events</code>, and <code class="literal">render</code> properties are self-explanatory. The template that we're pulling in is very <a id="id142" class="indexterm"/>simple: a little form that takes a file and a caption. This is the code for the template:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="addPhotoView"&gt;
  &lt;p&gt;Photo: &lt;input type="file" id="imageUpload" /&gt;&lt;/p&gt;
  &lt;p&gt;Caption: &lt;input type="text" id="imageCaption" /&gt;&lt;/p&gt;
  &lt;button&gt; Upload &lt;/button&gt;
&lt;/script&gt;</pre></div><p>When that button is pressed, the <code class="literal">uploadFile</code> method is called. In there, we'll cancel the default behavior of submitting the form and use the data to create an instance of the Photo model (coming soon). The <code class="literal">caption</code> property is obvious, but the <code class="literal">file</code> property is a little trickier. We start by getting the file input element, and then get the first item in the array property called <code class="literal">files</code>. This is the data we need to upload the file via AJAX. Then, we save this object by passing it to the collection's <code class="literal">create</code> method. You might be curious about the <code class="literal">{ wait: true }</code> part. Hold that thought for a minute, however. It will be explained soon; when it will make sense, I'll explain it.</p><p>Finally, we'll clear the form, so they can upload another one if they want to.</p><p>Before we can actually get this working, there are a couple of other pieces to build. Most obviously, we need the Photo model and Photos collection. In the last application, our models were pretty simple, but this one is more complex; this is the model class's code:</p><div class="informalexample"><pre class="programlisting">var Photo = Backbone.Model.extend({
  urlRoot: "/photos",
  sync: function (method, model, options) {
    var opts = {
      url: this.url(),
      success: function (data) {
        if (options.success) {
          options.success(data);
        }
      }
    };
            
    switch (method) {
      case "create":
        opts.type = "POST";
        opts.data = new FormData();
        opts.data.append("file", model.get('file'));
        opts.data.append("caption", model.get('caption'));
        opts.processData = false;
        opts.contentType = false;
        break;
      default:
        opts.type = "GET";
    }
    return $.ajax(opts);
  }
});</pre></div><p>As you know, the <code class="literal">urlRoot</code> object is the base of the route that this model will GET and POST to on the server, but the big story here is the <code class="literal">sync</code> method. Normally, all models and collections<a id="id143" class="indexterm"/> use the <code class="literal">Backbone.sync</code> method. This is the method that is called every time we're reading or writing one or more models<a id="id144" class="indexterm"/> to or from the server. We can overwrite this at the model level if we need to do something a bit differently, and that's exactly the case here. Backbone doesn't support AJAX file uploads out of the box, so we need to write a <code class="literal">sync</code> function to do that.</p><p>The trick here is that we can't just write a function that does file uploads for creating new photo records. This is because of the fact that this is the method that is used for reading, updating, and deleting this model's instances. As you can see, the <code class="literal">sync</code> method takes three parameters: the first is the CRUD method that we're about to perform (create, read, update, and delete), the second is the <code class="literal">model</code> instance, and the third is an <code class="literal">options</code> object.</p><p>Since we'll be using jQuery to do the AJAX call, we only need to set up an <code class="literal">options</code> object of our own. That's how we start. Of course, it will need a URL, so we call this model class's <code class="literal">url</code> method. We also need to define a <code class="literal">success</code> callback. It's important that this callback calls the <code class="literal">success</code> method of the <code class="literal">options</code> object; this method will handle some important behind-the-scenes stuff. These properties are important no matter what method we're calling.</p><p>Then, we have <a id="id145" class="indexterm"/>a <code class="literal">switch</code> statement; this is for the properties that will differ, depending on the method. In the case that we have <code class="literal">create</code>, we want to set the type to <code class="literal">POST</code>. We set the <code class="literal">data</code> property to a new <code class="literal">FormData</code> instance; this is how we send the file data. All we do is append the <code class="literal">file</code> property that we put on the model; we can append the caption as well.</p><p>We also need to set <code class="literal">processData</code> and <code class="literal">contentType</code> to <code class="literal">false</code>. This way, we can be sure the file data will get to the server in the way we expect, so we can save it to a file.</p><p>We're also setting a default case here, which sets the type to GET. We're not preparing this method for doing updates or deletes, because that's not part of the application we're building. If we ever needed these features, we'd have to expand this.</p><p>Finally, we just<a id="id146" class="indexterm"/> need to make the AJAX call by using <code class="literal">$.ajax</code> and passing it in our <code class="literal">options</code> object.</p><p>We also need a <code class="literal">Photos</code> collection. For now, we'll keep it simple. We'll create it by using the following code:</p><div class="informalexample"><pre class="programlisting">var Photos = Backbone.Collection.extend({
  model: Photo
});</pre></div><p>The <code class="literal">sync</code> method allows us to send our images to the server, but we don't have a route ready to handle the incoming data, so that's our next priority:</p><div class="informalexample"><pre class="programlisting">app.post("/photos", function (req, res) {
  var oldPath = req.files.file.path,
      publicPath = path.join("images", requser.id + "_" + (photos.data.length + 1) + ".jpg"),
      newPath = path.join(__dirname, "public", publicPath);
    
  fs.rename(oldPath, newPath, function (err) {
    if (!err) {
      photos.insert({
        userId: requser.id,
        path: "/" + publicPath,
        caption: req.body.caption,
        username: requser.username
      }, function (photo) {
        res.send(photo);
      });
    } else {
      res.send(err);
    }
  });
});</pre></div><p>As you saw, we're posting to <code class="literal">/photos</code>. Since this function is going to store a photo that needs to be viewable from the browser, we need to put it in the <code class="literal">public</code> folder. Go ahead and make a folder inside <code class="literal">public</code> called <code class="literal">images</code>, which is where we'll put them.</p><p>We start with a <a id="id147" class="indexterm"/>few paths. First, there's <code class="literal">oldPath</code>; that's the path to where the file is temporarily stored at <a id="id148" class="indexterm"/>the time of the request. Then, there's <code class="literal">publicPath</code>: this is the path that we'll use in the browser to view the photo; it's just <code class="literal">images</code> plus the name of the file. We're going to give the image a unique name based on the user's ID and the number of photos we have in the database. Thirdly, there's <code class="literal">newPath</code>, which is where we're going to store the image relative to the current location.</p><p>To work with files like this in Node.js, we need to use the filesystem module, so add the following line to the top of the file:</p><div class="informalexample"><pre class="programlisting">var fs = require("fs");</pre></div><p>Then, we can use the <code class="literal">rename</code> method to move the file. If this goes well, and there's no error, we can store the record for this image in the <code class="literal">photos</code> database. Notice that instead of a <code class="literal">file</code> property, we're just storing the <code class="literal">path</code> property. Once we send this object back to the browser, it will replace the attributes that we had. Once we store the photo, we'll send it back to the browser as confirmation that the deed is done.</p><p>Next, move back to the client code in the <code class="literal">app.js</code> file. We need a route from which to access the upload form. If you look back at our navigation view, you'll see that the route we want to make is <code class="literal">/upload</code>. You can add the following line to the <code class="literal">routes</code> object in <code class="literal">AppRouter</code>:</p><div class="informalexample"><pre class="programlisting">'upload': 'upload',</pre></div><p>Then, let's create the <code class="literal">upload</code> function by doing this:</p><div class="informalexample"><pre class="programlisting">upload: function () {
  var apv = new AddPhotoView({ photos: this.userPhotos }),
    photosView = new PhotosView({ collection: this.userPhotos });
  this.main.html(this.navView.render().el);
  this.main.append(apv.render().el);
  this.main.append(photosView.render().el);
}</pre></div><p>We're actually <a id="id149" class="indexterm"/>doing a bit more than you bargained for here; there's a second view that we're rendering: a <code class="literal">PhotosView</code> instance. Before we get to that though, notice that we're using a <code class="literal">userPhotos</code> property; we have to add that to the router. Add the following line in the <code class="literal">AppRouter</code> class's <code class="literal">initialize</code> function:</p><div class="informalexample"><pre class="programlisting">this.userPhotos = options.userPhotos;</pre></div><p>This gives us access to whatever collection we pass to the router as <code class="literal">userPhotos</code>. Then, in the <code class="literal">index.ejs</code> file, where we instantiate the router this line will create that collection:</p><div class="informalexample"><pre class="programlisting">userPhotos: new Photos()</pre></div><p>Okay, now we create the <code class="literal">PhotosView</code> class:</p><div class="informalexample"><pre class="programlisting">var PhotosView = Backbone.View.extend({
  tagName: 'ul',
  template: _.template($("#photosView").html()),
  initialize: function () {
    this.collection.on("add", this.addPhoto, this);
  },
  render: function () {
    this.collection.forEach(this.addPhoto, this);
      return this;
  },
  addPhoto: function (photo) {
    this.$el.append(this.template(photo.toJSON()));
  }
});</pre></div><p>This is the <code class="literal">PhotosView</code> class. Notice that we set the <code class="literal">tagName</code> property to <code class="literal">ul</code>; then, inside the <code class="literal">render</code> function, we just loop over the collection and call the <code class="literal">addPhoto</code> function, which renders the<a id="id150" class="indexterm"/> template and puts the result in the list. This time, instead of using the <code class="literal">template</code> function for the whole view, we use it to render each model in the collection. Also, notice that in the <code class="literal">initialize</code> function that we're listening for whenever new photos are added to the collection, we can add them to the list. Now's the time to recall that <code class="literal">{ wait: true }</code> option that we added when we made the <code class="literal">create</code> call. When we tell Backbone to wait like this, it won't trigger this <code class="literal">add</code> event on a model until we've heard back from the server. This is important in this case, because otherwise we won't have the public path for our image. The last piece for this class is the template; of course, the following code goes in the <code class="literal">index.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="photosView"&gt;
  &lt;a href="/photo/{{id}}"&gt;&lt;img src="{{path}}" /&gt;&lt;/a&gt;
&lt;/script&gt;</pre></div><p>It should all be in place now! You can go to <code class="literal">http://localhost:3000/upload</code>, choose a file, type a <a id="id151" class="indexterm"/>caption, and click on the <span class="strong"><strong>Upload</strong></span> button. The file will be uploaded, and you'll see it appear beneath the form. Congrats! You've just uploaded your first photo. The following screenshot shows how the photo might look like:</p><div class="mediaobject"><img src="graphics/6997OS_02_03.jpg" alt="Uploading photos"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>While building this application, I used photos from <a class="ulink" href="http://unsplash.com">http://unsplash.com</a>; a great source for free high-resolution photos.</p></div></div></div>
<div class="section" title="Sending photos from the server to the client"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Sending photos from the server to the client</h1></div></div></div><p>Before we work on another specific page, we need a route from which to get photos from the server.<a id="id152" class="indexterm"/> These<a id="id153" class="indexterm"/> photos will need to go in a <code class="literal">Photos</code> collection, but if you think about it for a second, you'll realize that there are several different sets of photos we might get. For example, we could get all the photos from one user, <a id="id154" class="indexterm"/>or all the photos from the users that the current user follows. So, hold your breath, here's that route's code:</p><div class="informalexample"><pre class="programlisting">app.get(/\/photos(\/)?([\w\/]+)?/, function (req, res) {
  var getting = req.params[1],
      match;

  if (getting) {
    if (!isNaN(parseInt(getting, 10))) {
      photos.findOne({ id: parseInt(getting, 10) },
        function (photo) { res.json(photo); });
    } else {
      match = getting.match(/user\/(\d+)?/);
      if (match) {
        photos.find({ userId: parseInt(match[1], 10) }, 
          function (photos) { res.json(photos); });
      } else if (getting === "following") {
        var allPhotos = [];
        req.user.following.forEach(function (f) {
          photos.find({ userId: f }, function (photos) {
            allPhotos = allPhotos.concat(photos);
          });
        });
        res.json(allPhotos);
      } else {
        res.json({});
      }
    }
  } else {
    res.json({});
  }
});</pre></div><p>Yes, it's a doozy. Let's start with the route; instead of a string, we're using a regular expression that <a id="id155" class="indexterm"/>matches the routes we want it to catch. This one catches pretty much anything that begins with <code class="literal">/photos</code>. We're interested in the following patterns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/photos/11</code>: Photo with ID 11</li><li class="listitem" style="list-style-type: disc"><code class="literal">/photos/following</code>: Photos of all the users the logged-in user is following</li><li class="listitem" style="list-style-type: disc"><code class="literal">/photos/user/2</code>: Photos of users with ID 2</li></ul></div><p>The capture groups from the route are put into <code class="literal">req.params</code>, so <code class="literal">req.params[1]</code> is the second capture group. We're putting that into the <code class="literal">getting</code> variable, and then we have to inspect if further. <a id="id156" class="indexterm"/>Assuming it exists, we check first to see if it's a number (by parsing it and passing it through <code class="literal">isNaN</code>). If it is a number, which is the easiest case, we find the photo with that ID and send it back.</p><p>If it's not a number, we run the <code class="literal">getting</code> variable against another regular expression to see if it matches <code class="literal">user/ID</code>. If it does, we'll return all the photos with the matching <code class="literal">userId</code>.</p><p>Finally, if the <code class="literal">getting</code> variable is the string <code class="literal">following</code>, we're going to loop over the current user's <code class="literal">following</code> array and get the photos from each of those users, pushing their photos into the <code class="literal">allPhotos</code> array, which we'll then return.</p><p>At any point, if we run into a pattern we weren't expecting, we'll just return an empty JSON object.</p></div>
<div class="section" title="Creating profile pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Creating profile pages</h1></div></div></div><p>Now that <a id="id157" class="indexterm"/>we have this route available, we can do <a id="id158" class="indexterm"/>a lot more. How about a profile page? If you look back at the navigation view again, you'll see that we created a <span class="strong"><strong>My Profile</strong></span> link, which takes us to <code class="literal">/users/1</code> (or whatever your ID number is). Of course, this means that we can use it for more than just our own profile page. It will work for any user, if we make the code generic enough.</p><p>First, we'll need a way to get the user data from the server (remember, this could be a profile for someone other than the logged-in user). We'll use a model for this by using the following code:</p><div class="informalexample"><pre class="programlisting">var User = Backbone.Model.extend({
  url: function () {
    return '/user-' + this.get('id') + '.json';
  }
});</pre></div><p>The URL is different from what we would usually do, but it shows the flexibility of Backbone; we can make the URL look like a path to a JSON file. Of course, this wouldn't be so great if we needed to post to this URL to save a user (especially because a model doesn't usually have an ID until it has been saved). However, since I know we won't need to do that, we can have fun with this one and do it that way. As you might imagine, the server-side code is pretty simple as you can see in the following code:</p><div class="informalexample"><pre class="programlisting">app.get("/user-:id.json", function (req, res) {
  users.findOne({ id : parseInt(req.params.id, 10) }, 
    function (user) {
      res.json(safe(user));
    });
});</pre></div><p>Now <a id="id159" class="indexterm"/>that<a id="id160" class="indexterm"/> we can get a user, let's add the profile page route to the router by using the following code:</p><div class="informalexample"><pre class="programlisting">'users/:id': 'showUser',</pre></div><p>Now, add the following method to the router:</p><div class="informalexample"><pre class="programlisting">showUser: function (id) {
  var thiz = this,
      user,
      photos;
        
  id = parseInt(id, 10);
        
  function render() {
    var userView = new UserView({ 
      model: user.toJSON(), 
      collection: photos 
    });
    thiz.main.html(thiz.navView.render().el);
    thiz.main.append(userView.render().el);
  }
        
  if (id === USER.id) {
    user = new User(USER);
    photos = this.userPhotos;
    render();
  } else {
    user = new User({ id: id });
    photos = new Photos({ url: "/photos/user/" + id });
    user.fetch().then(function () {
      photos.fetch().then(render);
    });
  }
},</pre></div><p>Again, let's do something that's a little different. Here's the scenario: if users are viewing their own page, there's no reason to pull their user and photo data from the server again; we can use the data we already have in the browser. To see<a id="id161" class="indexterm"/> if a user is viewing their own profile, we compare the ID in the route (which we get as a parameter) to the ID on the <code class="literal">USER</code> object. If the user is viewing another user's profile, we create a user model and photos collection with just enough data: a model only needs <code class="literal">id</code>, and a collection only needs <code class="literal">url</code>. Then, we can have them both fetch the rest of the needed data from the server. In both cases, the <code class="literal">fetch</code> method returns a jQuery deferred object. If you aren't familiar with deferreds or promises in JavaScript, think of them as a way to wait for data to be ready; we call the deferred's <code class="literal">then</code> method, passing it a function to call when the data is ready. We'll use promises a lot more in a later chapter.</p><p>Wait, can we just hand a URL to a collection object? Not usually. We need to add an <code class="literal">initialize</code> method to our <code class="literal">Photos</code> collection class, like so:</p><div class="informalexample"><pre class="programlisting">initialize: function (options) {
  if (options &amp;&amp; options.url) {
    this.url = options.url;
  }
}</pre></div><p>Clever, eh? This way, we can use any URL we want. That's why we created the URL-flexible backend for this class.</p><p>In both cases, <a id="id162" class="indexterm"/>we then call our internal <code class="literal">render</code> method. There's something to note about this function. Even though it's inside out router method, it will still be run in the global namespace; this is why we create the <code class="literal">thiz</code> variable, for use inside the <code class="literal">render</code> function. Of course, in one case we call it procedurally and in another we call it as a callback, but the same thing will be done; we will render the <code class="literal">UserView</code> instance. Here's the code for that class:</p><div class="informalexample"><pre class="programlisting">var UserView = Backbone.View.extend({
  template: _.template($("#userView").html()),
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON());
    var ul = this.$("ul");
    this.collection.forEach(function (photo) {
      ul.append(new PhotoView({ 
        model: photo 
      }).render().el);
    });
    return this;
  }
});</pre></div><p>Very simple; it's just a username and a list of your photos. We can even reuse the <code class="literal">PhotoView</code> class that we made earlier to display individual photos. Notice our use of the <code class="literal">this.$</code> method; it allows us to search for elements and create a jQuery object for those elements, but it limits the search to elements inside this view instance's <code class="literal">el</code> property. Finally, here's the template:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="userView"&gt;
  &lt;h1&gt;{{username}}&lt;/h1&gt;
  &lt;ul&gt;&lt;/ul&gt;
&lt;/script&gt;</pre></div><p>If you try this out, you might notice a problem; when viewing the current user's profile, there won't be any<a id="id163" class="indexterm"/> photos. That's because we're using the <code class="literal">userPhotos</code> property from the router, which is just an empty collection. When we load the page, we should load the user's photos data too. This isn't hard to do. First, back in your <code class="literal">server.js</code> file, in the <code class="literal">/*</code> route function, swap out your <code class="literal">res.render</code> call for the following code:</p><div class="informalexample"><pre class="programlisting">photos.find({ userId: req.user.id }, function (err, photos) {
  res.render("index.ejs", {
    user: JSON.stringify(safe(req.user)),
    userPhotos: JSON.stringify(photos)
  });
});</pre></div><p>Then, in <a id="id164" class="indexterm"/>the <code class="literal">index.ejs</code> file, use your template delimiters to put that in its place, inside the router instantiation:</p><div class="informalexample"><pre class="programlisting">userPhotos: new Photos(&lt;%- userPhotos %&gt;)</pre></div><p>Now, you should see your own photos on your profile page, because we're loading photos from the server.</p></div>
<div class="section" title="Creating the individual photo page"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Creating the individual photo page</h1></div></div></div><p>We've<a id="id165" class="indexterm"/> used the <code class="literal">PhotoView</code> class twice now; it creates a link, as you might recall, to an individual page for each photo. Let's create that page next. This time, we'll start in the router. First, add this route to the <code class="literal">routes</code> property:</p><div class="informalexample"><pre class="programlisting">'photo/:id': 'showPhoto',</pre></div><p>Then, here's the <code class="literal">showPhoto</code> method is partners with:</p><div class="informalexample"><pre class="programlisting">showPhoto: function (id) {
  var thiz = this,
    photo = new Photo({ id : parseInt(id, 10) });
        
  photo.fetch().then(function () {
    var comments = new Comments({ photo: photo }),
    var photoView = new PhotoPageView({ 
      model: photo, 
      collection: comments 
    });
            
    comments.fetch().then(function () {
      thiz.main.html(thiz.navView.render().el);
      thiz.main.append(photoView.render().el);
    });
  });
},</pre></div><p>Just as we did with the <code class="literal">showUser</code> function<a id="id166" class="indexterm"/>, we get the photo data by creating a <code class="literal">Photo</code> instance with <code class="literal">id</code>, and then calling the <code class="literal">fetch</code> method. However, we're also creating a <code class="literal">Comments</code> collection<a id="id167" class="indexterm"/> based on this photo. Then, <a id="id168" class="indexterm"/>we create a <code class="literal">PhotoPageView</code> instance, which has both a model (the photo) and a collection (the comments). Once we fetch the comments from the server, we render it. So here's the view:</p><div class="informalexample"><pre class="programlisting">var PhotoPageView = Backbone.View.extend({
  template: _.template($("#photoPageView").html()),
  initialize: function () {
    this.collection.on("add", this.showComment, this);
  },
  events: {
    'click button': 'addComment'
  },
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON());
    this.collection.forEach(this.showComment.bind(this));
    return this;
  }
});</pre></div><p>As you can probably tell, this isn't all of it. In the <code class="literal">initialize</code> function, we're setting an event to call the <code class="literal">showComment</code> method<a id="id169" class="indexterm"/> whenever a new comment is added to the collection. This is also the method we use inside the <code class="literal">render</code> method to show each of the already-existing comments. <a id="id170" class="indexterm"/>Then, we have an event: a button-click that triggers an <code class="literal">addComment</code> method. Before we get to these methods, you might want to see the button as well as the rest of the template; here's the template's code, which you should add to the <code class="literal">index.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="photoPageView"&gt;
  &lt;img src="{{path}}" /&gt;
  &lt;p&gt; {{caption}} &lt;small&gt; by {{username}}&lt;/small&gt;&lt;/p&gt;
  &lt;div&gt;
    &lt;textarea id="commentText"&gt;&lt;/textarea&gt;&lt;br /&gt;
    &lt;button&gt; Comment &lt;/button&gt;
  &lt;/div&gt;
  &lt;ul&gt;&lt;/ul&gt;
&lt;/script&gt;</pre></div><p>So, let's add those methods now, shall we? We'll tackle the longer one first. The following is the code for the <code class="literal">addComment</code> function:</p><div class="informalexample"><pre class="programlisting">addComment: function () {
  var textarea = this.$("#commentText"),
      text = textarea.val(),
      comment = {
        text: text,
        photoId: this.model.get("id"),
        username: USER.username
      };
  textarea.val("");
  this.collection.create(comment);
},</pre></div><p>This is pretty similar to the <code class="literal">addPhoto</code> method in our <code class="literal">AddPhotoView</code> class. We create an attributes object <a id="id171" class="indexterm"/>with the text from the textbox, the ID of the photo we're commenting on, and the username of the commenter. Then, we send them to the server through the collection's <code class="literal">create</code> method.</p><p>When we do this, our <code class="literal">add</code> event will be triggered, and the <code class="literal">showComment</code> method will be called. Here's that method:</p><div class="informalexample"><pre class="programlisting">showComment: function (comment) {
  var commentView = new CommentView({ model: comment });
  this.$("ul").append(commentView.render().el);
}</pre></div><p>Once again, the magic is elsewhere. You want to see the <code class="literal">CommentView</code> instance, which is shown in the following code:</p><div class="informalexample"><pre class="programlisting">var CommentView = Backbone.View.extend({
  tagName: "li",
  template: _.template($("#commentView").html()),
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON());
    return this;
  }
});</pre></div><p>It's so simple; even its template is simple. Its template's code is given as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="commentView"&gt;
  &lt;p&gt;&lt;strong&gt;{{username}}&lt;/strong&gt; said&lt;/p&gt;
  &lt;p&gt;{{text}}&lt;/p&gt;
&lt;/script&gt;</pre></div><p>Throughout all this, <a id="id172" class="indexterm"/>we got so excited that we completely overlooked an important factor: we don't have a <code class="literal">Comment</code> model or a <code class="literal">Comments</code> collection yet. Not to worry. We create these by using the following code:</p><div class="informalexample"><pre class="programlisting">var Comment = Backbone.Model.extend();
var Comments = Backbone.Collection.extend({
  model: Comment,
  initialize: function (options) {
    this.photo = options.photo;
  },
  url: function () {
    return this.photo.url() + '/comments';
  }
});</pre></div><p>Notice the <code class="literal">Comments</code> collection's <code class="literal">url</code> function. It takes the <code class="literal">url</code> of the photo instance that was assigned<a id="id173" class="indexterm"/> as a property and appends <code class="literal">/comments</code> to the end. So, in our <code class="literal">server.js</code> file, we need to create the GET and POST methods for this route, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">app.get('/photos/:id/comments', function (req, res) {
  comments.find({ photoId: parseInt(req.params.id, 10) }, 
    function (comments) {
      res.json(comments);
    });
});</pre></div><p>The GET route will return all the photos with the <code class="literal">photoId</code> property matching the URL parameter. Here's the POST route:</p><div class="informalexample"><pre class="programlisting">app.post('/photos/:id/comments', function (req, res) {
  var comment = {
    text: req.body.text,
    photoId: req.body.photoId,
    username: req.body.username
  };
  comments.insert(comment, function (data) {
    res.json(data);
  });
});</pre></div><p>This route will take the attributes, create an object out of them, store them in the <code class="literal">comments</code> database, and return the saved version as JSON.</p><p>That's a<a id="id174" class="indexterm"/> wrap on the comments feature! You should be able to go to an individual photo page, type a <a id="id175" class="indexterm"/>comment in, click on the button, and see your comment appear below. Even better, the comment will still be there when you refresh the page. The following screenshot shows what it may look like:</p><div class="mediaobject"><img src="graphics/6997OS_02_04.jpg" alt="Creating the individual photo page"/></div></div>
<div class="section" title="Following users"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Following users</h1></div></div></div><p>This brings <a id="id176" class="indexterm"/>us to what is easily the most complicated feature of our application: following other users. We want users to be able to choose which users they want to follow, and have those users' photos show up on the home page.</p><p>We'll start with the <code class="literal">/users</code> route. Add the following line to the router's <code class="literal">routes</code> object:</p><div class="informalexample"><pre class="programlisting">'users': 'showUsers',</pre></div><p>Now, let's create the <code class="literal">showUsers</code> function:</p><div class="informalexample"><pre class="programlisting">showUsers: function () {
  var users = new Users(),
      thiz  = this;
  this.main.html(this.navView.render().el);
  users.fetch().then(function () {
    thiz.main.append(new UserListView({ 
      collection: users 
    }).render().el);
  });
},</pre></div><p>We don't really<a id="id177" class="indexterm"/> have a <code class="literal">Users</code> collection class yet; that's next. However, you can see that we'll fetch all the users here, and then render a <code class="literal">UserListView</code> instance.</p><p>The <code class="literal">Users</code> collection is very straightforward, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var Users = Backbone.Collection.extend({
  model: User,
  url: '/users.json'
});</pre></div><p>Also, we'll need to put the server-side bits in place, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">app.get("/users.json", function (req, res) {
  users.find(function (users) {
    res.json(users.map(safe));
  });
});</pre></div><p>Now, we can look at the <code class="literal">UserListView</code> instance. Actually, it's another one of our wrapper views, only there to pull together a collection of individual model views, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var UserListView = Backbone.View.extend({
  tagName: "ul",
  render: function () {
    this.collection.forEach(function (model) {
      this.$el.append((new UserListItemView({ 
        model: model 
      })).render().el);
    }, this);
    return this;
  }
});</pre></div><p>As you can see from this code, the one we're really interested in is the <code class="literal">UserListItemView</code> instance. This is probably the biggest view you'll see today (or at least in this chapter). We'll take it piece by piece, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var UserListItemView = Backbone.View.extend({
  tagName: "li",
  template: _.template('&lt;a href="/users/{{id}}"&gt;{{username}}&lt;/a&gt;'),
  events: {
    'click .follow': 'follow',
    'click .unfollow': 'unfollow'
  },
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON());
    if (USER.username === this.model.get("username")) {
      this.$el.append(" (me)");
    } else {
      this.update();
    }
    return this;
  }
});</pre></div><p>This is the start. As you can see from the events, we will have follow and unfollow buttons that will<a id="id178" class="indexterm"/> trigger respective methods. The <code class="literal">render</code> function starts by rendering the template, which we'll put inline, because it's small.</p><p>More interesting things happen after rendering. First, we check to see if the user we're creating a list item for is the currently logged-in user; if it is, we'll add the text <code class="literal">(me)</code> to the end of it. Otherwise, we'll call the <code class="literal">update</code> method.</p><p>The <code class="literal">update</code> method is actually pretty basic. Its goal is to see if the current user is following the user that we're making the list item for. If they're already following that user, we'll put in an <span class="strong"><strong>Unfollow</strong></span> button; otherwise, we'll use the <span class="strong"><strong>Follow</strong></span> button. This method will also be called when one of these buttons is clicked on, so we'll remove buttons when appropriate:</p><div class="informalexample"><pre class="programlisting">update: function () {
  if (USER.following.indexOf(this.model.get("id")) === -1) {
    this.$("#unfollow").remove();
    this.$el.append("&lt;button id='follow'&gt; Follow &lt;/button&gt;");
  } else {
    this.$("#follow").remove();
    this.$el.append("&lt;button id='unfollow'&gt; Unfollow &lt;/button&gt;");
  }
}</pre></div><p>It's pretty simple, actually. If the view's user ID is in the current user's <code class="literal">following</code> array, we remove an <span class="strong"><strong>Unfollow</strong></span> button and add a <span class="strong"><strong>Follow</strong></span> button. Otherwise, we remove the <span class="strong"><strong>Follow</strong></span> button and add an <span class="strong"><strong>Unfollow</strong></span> button. At this point, we could load the <code class="literal">/users</code> page, and we'll have a list of users with follow buttons. However, clicking on them won't do anything. We need to write those <code class="literal">follow</code> and <code class="literal">unfollow</code> functions (in the <code class="literal">UserListItemView</code> class). </p><p>These two functions are almost identical, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">follow: function (evt) {
  var thiz = this,
    f = new Follow({ userId: thiz.model.id });
  f.save().then(function (user) {
    USER.following = user.following;
    thiz.update();
  });
},
unfollow: function (evt) {
  var thiz = this,
    f = new Follow({ id: thiz.model.id });
  f.destroy().then(function (user) {
    USER.following = user.following;
    thiz.update();
  });
},</pre></div><p>In both cases, we create a new <code class="literal">Follow</code> model instance. When the goal is to save the <code class="literal">following</code> array, <a id="id179" class="indexterm"/>we set the <code class="literal">userId</code> property; when the goal is to delete the <code class="literal">following</code> array, we set the <code class="literal">id</code> property. In the case of the <code class="literal">follow</code> function, we save that model; on the server side, this will add the user to the <code class="literal">following</code> array of the current user. In the case of the <code class="literal">unfollow</code> function, we delete the model; on the server side, this will remove the user from the <code class="literal">following</code> array. Again, in both cases, the method that calls to the server will return a deferred object. We'll pass the <code class="literal">then</code> method, a function that will reset the <code class="literal">following</code> array on the <code class="literal">USER</code> object with the <code class="literal">following</code> array from the server. In both cases, we'll then call the <code class="literal">update</code> method to correct the buttons.</p><p>The last step is to create the <code class="literal">Follow</code> model. Really, we don't need to use a Backbone model here; we just need two AJAX requests. However, we can make hacky use of a model class to do all the hard work for us. The following is the code for the <code class="literal">Follow</code> model:</p><div class="informalexample"><pre class="programlisting">var Follow = Backbone.Model.extend({
  urlRoot: '/follow'
});</pre></div><p>That's really it. We can use this class in two ways. If we give a <code class="literal">Follow</code> instance a <code class="literal">userId</code> property, we can then call the <code class="literal">save</code> method to POST to <code class="literal">/follow</code>. Or, if we create a <code class="literal">Follow</code> instance with an <code class="literal">id</code> property, we can call the <code class="literal">destroy</code> method to send a DELETE request to <code class="literal">/follow/id</code>.</p><p>Things are a little more complicated on the server side. First, let's take a look at the POST route:</p><div class="informalexample"><pre class="programlisting">app.post("/follow", function (req, res) {
  var id = parseInt(req.body.userId, 10);
  if (req.user.following.indexOf(id) === -1) {
    req.user.following.push(id);
    users.update({ id: req.user.id }, req.user, function (err, users) {
      res.json(safe(users[0]));
    });
  } else {
    res.json(safe(req.user));
  }
});</pre></div><p>We begin by finding out whether the ID is in the user's <code class="literal">following</code> list. If it isn't, we'll push it into the array<a id="id180" class="indexterm"/> and update the user record in the database. Then, we'll send back the updated user record. Even if the user is already following the chosen user, we'll still send the user data back.</p><p>The DELETE route is similar to that POST route:</p><div class="informalexample"><pre class="programlisting">app.delete("/follow/:id", function (req, res) {
  var id = parseInt(req.params.id, 10),
    index = req.user.following.indexOf(id);
  if (index !== -1) {
    req.user.following.splice(index, 1);
    users.update({ id: req.user.id }, req.user, function (err, users) {
      res.json(safe(users[0]));
    });
  } else {
    res.json(safe(req.user));
  }
});</pre></div><p>If the current user is following this user, we'll use the JavaScript <code class="literal">splice</code> method to remove the item from the array (this method mutates the array, so we don't reassign it to <code class="literal">req.user.following</code>). Then, we'll update user records in the database and send the updated user back as JSON (we're sending <code class="literal">users[0]</code> because the <code class="literal">update</code> function gives an array to the <code class="literal">callback</code> function, but in our case that array should have only one record).</p><p>Now that this is in <a id="id181" class="indexterm"/>place, our <code class="literal">/users</code> route will have working follow/unfollow buttons. We can follow a few other users.</p></div>
<div class="section" title="Displaying a followed user's photos"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Displaying a followed user's photos</h1></div></div></div><p>What do <a id="id182" class="indexterm"/>we do with followed users? We<a id="id183" class="indexterm"/> want to show the photos from the followed users on the home page. First, in the <code class="literal">server.js</code> file, we need to be able to get all the photos from all the users the current user is following. We're going to write a separate function for this:</p><div class="informalexample"><pre class="programlisting">function followingPhotos(user, callback) {
  var allPhotos = [];
  user.following.forEach(function (f) {
    photos.find({ userId: f }, function (err, photos) {
      allPhotos = allPhotos.concat(photos);
    });
  });
  callback(allPhotos);
}</pre></div><p>Does it look familiar? It's almost identical to some of the code we had in our photo-fetching route, you know, the one with the regular expression route. Since we've put this code in a function, you can replace the appropriate lines in that function, so they look like the following code:</p><div class="informalexample"><pre class="programlisting">} else if (getting === "following") {
<span class="strong"><strong>  followingPhotos(req.user, function (allPhotos) {</strong></span>
<span class="strong"><strong>    res.json(allPhotos);</strong></span>
<span class="strong"><strong>  });</strong></span>
} else {</pre></div><p>The last step on the server side is to send these following photos to the client, where we'll display them on the home page. Let's wrap our previous <code class="literal">res.render</code> call with the function we just wrote:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>followingPhotos(req.user, function (followingPhotos) {</strong></span>
  photos.find({ userId: req.user.id }, function (photos) {
    res.render("index.ejs", {
      user: JSON.stringify(safe(req.user)),
      userPhotos: JSON.stringify(photos),
<span class="strong"><strong>      followingPhotos: JSON.stringify(followingPhotos)</strong></span>
    });
  });
<span class="strong"><strong>});</strong></span>
</pre></div><p>Now, in the <code class="literal">index.ejs</code> file, we can add <code class="literal">followingPhotos</code> to our router options object:</p><div class="informalexample"><pre class="programlisting">followingPhotos: new Photos(&lt;%- followingPhotos %&gt;)</pre></div><p>We'll<a id="id184" class="indexterm"/> have to <a id="id185" class="indexterm"/>use the property in our <code class="literal">AppRouter</code> class, so add the following line to the <code class="literal">initialize</code> method:</p><div class="informalexample"><pre class="programlisting">this.followingPhotos = options.followingPhotos;</pre></div><p>The last step is to use this in the router's <code class="literal">index</code> method; the whole body of that method should now look like the following code:</p><div class="informalexample"><pre class="programlisting">index: function () {
<span class="strong"><strong>  var photosView = new PhotosView({ </strong></span>
<span class="strong"><strong>    collection: this.followingPhotos </strong></span>
<span class="strong"><strong>  });</strong></span>
  this.main.html(this.navView.render().el);
<span class="strong"><strong>  this.main.append(photosView.render().el);</strong></span>
},</pre></div><p>Now, if you go to the home page, you'll be able to see the photos of the users you are following! Excellent!</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Summary</h1></div></div></div><p>We've covered a lot of ground in the chapter, so let's retrace our steps a bit before moving on.</p><p>One of the most important things I want you to take away from this chapter is how data is sent from the server to the client. We've used two different methods here: first, we use a server-side template to put them into the HTML response and send them as part of that. Secondly, we use <code class="literal">fetch</code> commands from the client and create a completely separate HTTP request for that data. The advantage of the first method is that individual "chunks" of data don't have their own HTTP headers; also, since they're part of the initial request, the user will never wait for data while using the application. The advantage of the second method is that we never load more data than we need to from the server; when we need it, it's easy to request it. This is especially important in an application like this one, where a single user could have hundreds of posted photos over time, and people are likely to follow a lot of users; you wouldn't want to load all the data right from the start. We've mixed it up here so that you can get a feel of how both methods work.</p><p>However, you should note that this mixing-it-up actually causes us to load more data than necessary most of the time. This is because we're loading the current user's photos and the photos of the people they follow even when we aren't using that data (for example, on the user's list page). We've actually written all our Backbone code so that we could override the default anchor tag behavior and navigate our entire app with the router's <code class="literal">navigate</code> method; no page refreshes would be necessary. That might be a good exercise: try implementing functionality that uses Backbone's navigation instead of refreshing the page. If you get stuck, review the code from the last chapter.</p><p>Apart from data loading techniques, we saw that the Backbone model and collection classes are actually very flexible and can be used in "nontraditional" ways. I hope you're finding that when you take the magic out of Backbone, and understand exactly what it's doing, you can use it more efficiently. These ideas will be very useful when we build a live data dashboard in the next chapter.</p></div></body></html>