<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor175"/>12</h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor176"/>Stores and Animations</h1>
<p>In this chapter, we will delve into the world of Svelte animations, focusing on the power and versatility<a id="_idIndexMarker449"/> of the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores. The <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores are writable stores in which their store value changes over time when the <strong class="source-inline">set</strong> or <strong class="source-inline">update</strong> method is invoked, enabling us to develop more complex and visually appealing animations. By effectively harnessing these stores, you can elevate the user experience and create applications that are both dynamic <span class="No-Break">and captivating.</span></p>
<p>We begin this chapter by delving into the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores, learning how to create animations using these stores. Following that, we explore interpolation and the use of custom interpolations. Throughout the chapter, we examine various examples, such as animated graphs and image lightboxes, to illustrate the concepts. By the end of this chapter, you will have acquired the skills necessary to harness the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores effectively, enabling you to create intricate and engaging animations in your <span class="No-Break">Svelte projects.</span></p>
<p>This chapter covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Introduction to the <strong class="source-inline">tweened</strong> and <span class="No-Break"><strong class="source-inline">spring</strong></span><span class="No-Break"> stores</span></li>
<li>Custom interpolation and <span class="No-Break">its usage</span></li>
<li>Animating with the <strong class="source-inline">tweened</strong> and <span class="No-Break"><strong class="source-inline">spring</strong></span><span class="No-Break"> stores</span></li>
</ul>
<h1 id="_idParaDest-175"><a id="_idTextAnchor177"/>Technical requirements</h1>
<p>You can find the code used in this chapter on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12</span></a></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor178"/>Introducing the tweened and spring stores</h1>
<p>Let us begin our journey into the world of Svelte animations by understanding the concept of <strong class="source-inline">tweened</strong> and <span class="No-Break"><strong class="source-inline">spring</strong></span><span class="No-Break"> stores.</span></p>
<p>The <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores are writable stores that typically hold numeric values. To see the features they offer, let us compare them with a regular <span class="No-Break">numeric variable.</span></p>
<p>If you are not<a id="_idIndexMarker450"/> familiar with writable stores, you can check out <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, where we extensively explained Svelte stores and creating writable Svelte stores using the built-in <span class="No-Break"><strong class="source-inline">writable()</strong></span><span class="No-Break"> function.</span></p>
<p>Usually, when you have a numeric variable and you update the variable, the value of the variable changes instantly. In the following example, we have a numeric variable, <strong class="source-inline">height</strong>, whose initial value is <strong class="source-inline">10</strong>. When we assign a new value of <strong class="source-inline">20</strong> to the variable, the value of the variable changes to <span class="No-Break"><strong class="source-inline">20</strong></span><span class="No-Break"> immediately:</span></p>
<pre class="source-code">
let height = 10;
height = 20;</pre> <p>If we use this numeric variable to represent the height of an element or the progress in a progress bar, the height or progress jumps to the new value as soon as it is assigned. These abrupt changes can <span class="No-Break">be jarring.</span></p>
<p>So, how can we ensure a smooth transition when updating the <span class="No-Break">target value?</span></p>
<p>Svelte provides two built-in stores, <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong>, specifically designed for storing numeric values and allowing for smooth transitions to new values over a <span class="No-Break">specified duration.</span></p>
<p>Let’s look at an example to get a <span class="No-Break">clearer idea.</span></p>
<p>In the example, we create a <strong class="source-inline">tweened</strong> store with an initial value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import { tweened } from 'svelte/motion';
const height = tweened(10, {
  duration: 1000 /* 1 second */
});</pre> <p>Then, we assign a new value of <strong class="source-inline">20</strong> to <span class="No-Break">the store:</span></p>
<pre class="source-code">
$height = 20;</pre> <p>When that is done, the store value gradually increases from <strong class="source-inline">10</strong> to <strong class="source-inline">20</strong> over one second. If we use this store value as the height of an element, the element’s height will smoothly grow or shrink toward the target value as we assign a new value to the store, resulting in a visually appealing and <span class="No-Break">fluid transition.</span></p>
<p>Let us try changing<a id="_idIndexMarker451"/> the height from a <strong class="source-inline">tweened</strong> store to a <strong class="source-inline">spring</strong> store. Do not worry about the options in the <strong class="source-inline">spring</strong> function, as we will explain them in the <span class="No-Break">next section:</span></p>
<pre class="source-code">
import { spring } from 'svelte/motion';
const height = spring(10, {
  stiffness: 0.1,
  damping: 0.25
});</pre> <p>Now, as you assign a new value to the store, you will notice that, similar to when using the <strong class="source-inline">tweened</strong> store, the store value changes over time to the new value but at a <span class="No-Break">different rate.</span></p>
<p>As you can see, the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores are powerful features in Svelte that enable you to create smooth animations and transitions in your applications. These stores allow for eased value changes. When used as component states, they allow state updates in a more natural and <span class="No-Break">fluid manner.</span></p>
<p>The difference between<a id="_idIndexMarker452"/> a <strong class="source-inline">tweened</strong> store and a <strong class="source-inline">spring</strong> store is that a <strong class="source-inline">tweened</strong> store provides a way to smoothly transition between two values over a specified duration using an easing function, whereas<a id="_idIndexMarker453"/> a <strong class="source-inline">spring</strong> store is designed for physics-based animations, where elements behave as if they were attached to <span class="No-Break">a spring.</span></p>
<p>Let us dive in and look at how we can use the <strong class="source-inline">tweened</strong> and <span class="No-Break"><strong class="source-inline">spring</strong></span><span class="No-Break"> stores.</span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor179"/>Using the tweened and spring stores</h2>
<p><strong class="source-inline">tweened</strong> is a<a id="_idIndexMarker454"/> store <a id="_idIndexMarker455"/>that smoothly transitions between numeric values over a specified duration using a chosen <span class="No-Break">easing function.</span></p>
<p>Here is how<a id="_idIndexMarker456"/> you can create a <span class="No-Break"><strong class="source-inline">tweened</strong></span><span class="No-Break"> store:</span></p>
<pre class="source-code">
import { tweened } from 'svelte/motion';
import { cubicOut } from 'svelte/easing';
const progress = tweened(0, {
  duration: 1000,
  easing: cubicOut,
  delay: 500,
});</pre> <p>In the preceding snippet, we created a <strong class="source-inline">tweened</strong> store called <strong class="source-inline">progress</strong>, with <strong class="source-inline">0</strong> as the initial store value. When<a id="_idIndexMarker457"/> you set a new value for the <strong class="source-inline">progress</strong> store, the store value of the <strong class="source-inline">progress</strong> store stays the same for 0.5 seconds, then transitions to the new value in 1 second, using the <strong class="source-inline">cubicOut</strong> <span class="No-Break">easing function.</span></p>
<p>The function signature for <a id="_idIndexMarker458"/>the <strong class="source-inline">tweened</strong> store is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import { tweened } from 'svelte/motion';
const value = tweened(initialValue, options);</pre> <p><strong class="source-inline">initialValue</strong> is the initial numeric value of <span class="No-Break">the store.</span></p>
<p><strong class="source-inline">options</strong> is an object containing the <span class="No-Break">following properties:</span></p>
<ul>
<li><strong class="source-inline">duration</strong> (default: <strong class="source-inline">400</strong>): The duration of the transition <span class="No-Break">in milliseconds.</span></li>
<li><strong class="source-inline">easing</strong> (default: <strong class="source-inline">linear</strong>): The easing function to use for <span class="No-Break">the transition.</span><p class="list-inset">Svelte provides various easing functions in the <strong class="source-inline">svelte/easing</strong> module, such as <strong class="source-inline">linear</strong>, <strong class="source-inline">quadIn</strong>, and <strong class="source-inline">expoOut</strong>. You can also create a custom <span class="No-Break">easing function.</span></p></li>
<li><strong class="source-inline">delay</strong> (default: <strong class="source-inline">0</strong>): The delay in milliseconds before the <span class="No-Break">transition starts.</span></li>
</ul>
<p>On the other hand, <strong class="source-inline">spring</strong> is a store that smoothly transitions between numeric values using a spring-based <span class="No-Break">physics simulation.</span></p>
<p>Here’s how you can<a id="_idIndexMarker459"/> create a <span class="No-Break"><strong class="source-inline">spring</strong></span><span class="No-Break"> store:</span></p>
<pre class="source-code">
import { spring } from 'svelte/motion';
const position = spring(0, {
  stiffness: 0.2,
  damping: 0.5,
  precision: 0.001,
});</pre> <p>In the preceding<a id="_idIndexMarker460"/> snippet, we created a <strong class="source-inline">spring</strong> store called <strong class="source-inline">position</strong>, with <strong class="source-inline">0</strong> as the initial store value. When you set a new value for the <strong class="source-inline">position</strong> store, this value will bounce toward the target value and oscillate around the target value for a while until it settles at it. The amplitude and duration of the oscillations depend on the <strong class="source-inline">stiffness</strong>, <strong class="source-inline">damping</strong>, and <strong class="source-inline">precision</strong> <span class="No-Break">values configured.</span></p>
<p>The function signature <a id="_idIndexMarker461"/>for the <strong class="source-inline">spring</strong> store is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import { spring } from 'svelte/motion';
const value = spring(initialValue, options);</pre> <p><strong class="source-inline">initialValue</strong> is the initial numeric value of <span class="No-Break">the store.</span></p>
<p><strong class="source-inline">options</strong> is an object containing the <span class="No-Break">following properties:</span></p>
<ul>
<li><strong class="source-inline">stiffness</strong> (default: <strong class="source-inline">0.15</strong>): The stiffness of the spring. Higher values result in a stiffer spring, which causes quicker and more <span class="No-Break">forceful transitions.</span></li>
<li><strong class="source-inline">damping</strong> (default: <strong class="source-inline">0.8</strong>): The damping coefficient of the spring. Higher values result in more damping, which causes the spring to settle <span class="No-Break">more quickly.</span></li>
<li><strong class="source-inline">precision</strong> (default: <strong class="source-inline">0.01</strong>): The threshold at which the spring is considered to be at rest. Smaller values result in more accurate simulations but may take longer <span class="No-Break">to settle.</span></li>
</ul>
<h2 id="_idParaDest-178"><a id="_idTextAnchor180"/>Using tweened and spring stores with arrays and objects</h2>
<p>Both <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores can handle not just single numeric values, but also arrays <a id="_idIndexMarker462"/>of numbers and objects with numeric properties. This makes it easy to create complex animations involving <span class="No-Break">multiple values.</span></p>
<p>When you pass an array of numbers as the initial value, the stores will smoothly transition each element of the array independently. Here’s an example using an array of <span class="No-Break">two numbers:</span></p>
<pre class="source-code">
import { tweened } from 'svelte/motion';
const coordinates = tweened([0, 0], { duration: 1000 });
// Updating the coordinates
$coordinates = [100, 200];</pre> <p>Similarly, when <a id="_idIndexMarker463"/>you pass an object with numeric properties as the initial value, the stores will smoothly transition each property independently. Here’s an example using an object with two <span class="No-Break">numeric properties:</span></p>
<pre class="source-code">
import { tweened } from 'svelte/motion';
const position = tweened({ x: 0, y: 0 }, { duration: 1000 });
// Updating the position
$position = { x: 100, y: 200 };</pre> <p>When using arrays or objects, you can access and use the individual values in your Svelte component <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { tweened } from 'svelte/motion';
  const position = tweened({ x: 0, y: 0 }, { duration: 1000 });
&lt;/script&gt;
&lt;div style="transform: translate({$position.x}px, {$position.y}px)"&gt;&lt;/div&gt;</pre> <p>This capability to handle arrays and objects makes the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores even more versatile and powerful, enabling you to create intricate animations <span class="No-Break">with ease.</span></p>
<p>Now that we know how to use the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores, let us use them to create an <span class="No-Break">animated graph.</span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor181"/>Examples – creating an animated graph with the tweened and spring stores</h1>
<p>In this <a id="_idIndexMarker464"/>section, we will explore an example that demonstrates the power of the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores. We will create an animated bar chart where the bars dynamically resize to reflect updated <a id="_idIndexMarker465"/>data values. By adding animation to the bar chart, we can effectively highlight data changes and provide insights into <span class="No-Break">complex datasets.</span></p>
<p>Firstly, let us create a bar <span class="No-Break">chart component:</span></p>
<pre class="source-code">
&lt;script&gt;
  let data = generateData(10);
  function generateData(length) {
    const result = new Array(length);
    for (let i = 0; i &lt; length; i ++) {
      result[i] = Math.random() * 300;
    }
    return result;
  }
&lt;/script&gt;
&lt;style&gt;
  .bar {
    background-color: steelblue;
    height: 50px;
  }
&lt;/style&gt;
&lt;div&gt;
  {#each data as value}
    &lt;div class="bar" style="width: {value}px"&gt;&lt;/div&gt;
  {/each}
&lt;/div&gt;</pre> <p>In the<a id="_idIndexMarker466"/> code snippet provided, we initialize the <strong class="source-inline">data</strong> variable with an array of 10 randomly generated items, created using the <strong class="source-inline">generateData</strong> function. The <strong class="source-inline">generateData</strong> function takes a <strong class="source-inline">length</strong> parameter and creates an array of randomly generated data of the <span class="No-Break">specified length.</span></p>
<p>With the <strong class="source-inline">data</strong> array, we use the <strong class="source-inline">{#each}</strong> block to create a <strong class="source-inline">&lt;div&gt;</strong> element for each item in the array, setting the width of the <strong class="source-inline">&lt;div&gt;</strong> element to the value of the corresponding item in <span class="No-Break">the array.</span></p>
<p>As a result, we<a id="_idIndexMarker467"/> have a horizontal bar chart displaying 10 bars with randomly <span class="No-Break">generated widths.</span></p>
<p>To make things more engaging, we will update the values of the bar chart at <span class="No-Break">fixed intervals:</span></p>
<pre class="source-code">
import { onMount } from 'svelte';
onMount(() =&gt; {
  const intervalId = setInterval(() =&gt; {
    data = generateData(10);
  }, 1000);
  return () =&gt; clearInterval(intervalId);
});</pre> <p>We initiate an interval of 1 second using <strong class="source-inline">setInterval</strong> as soon as the component is mounted. On each interval, we update the data by regenerating it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">generateData(10)</strong></span><span class="No-Break">.</span></p>
<p>With this new code addition, you’ll observe that the horizontal bars alter their width during each interval. The width of the horizontal bars adjusts suddenly, creating a jarring <span class="No-Break">visual effect.</span></p>
<p>Now, let’s utilize the <strong class="source-inline">tweened</strong> store to make the bars grow or shrink smoothly every time the <span class="No-Break">data changes:</span></p>
<ol>
<li>First, let’s import the <strong class="source-inline">tweened</strong> store from <strong class="source-inline">svelte/motion</strong>. We’ll then wrap the <strong class="source-inline">data</strong> array with the <strong class="source-inline">tweened</strong> store. As shown in the previous section, we can pass an array of numbers to the <strong class="source-inline">tweened</strong> function to create a <strong class="source-inline">tweened</strong> store. This store will smoothly transition each number in the array independently <span class="No-Break">when updated:</span><pre class="source-code">
import { tweened } from 'svelte/motion';
const data = tweened(generateData(10));</pre></li> <li>Now, since <strong class="source-inline">data</strong> is a Svelte store, we need to update its value using the <strong class="source-inline">$data</strong> variable instead when <span class="No-Break">making changes:</span><pre class="source-code">
<strong class="bold">$data</strong> = generateData(10);</pre></li> <li>Similarly, when we want to iterate through the store value of <strong class="source-inline">data</strong> in the <strong class="source-inline">{#each}</strong> block, we need to use the <strong class="source-inline">$data</strong> variable <span class="No-Break">as well:</span><pre class="source-code">
{#each <strong class="bold">$data</strong> as value}</pre></li> </ol>
<p>Putting <a id="_idIndexMarker468"/>all these changes<a id="_idIndexMarker469"/> together, you will now observe that the horizontal bars grow and shrink smoothly, greatly improving the visual appeal and user experience of the <span class="No-Break">bar chart.</span></p>
<p>As you can see, creating a smoothly animating chart using the <strong class="source-inline">tweened</strong> store is quite straightforward. Before we move on to the next section, we encourage you to try this on your own: replace the <strong class="source-inline">tweened</strong> function with <strong class="source-inline">spring</strong> and observe the changes in <span class="No-Break">the animation.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor182"/>Exercise – creating an animating line graph</h2>
<p>Now that you’ve seen <a id="_idIndexMarker470"/>how to <a id="_idIndexMarker471"/>create an animating bar chart, it’s time for you to have a shot at creating an animating <span class="No-Break">line graph.</span></p>
<p>You can use the <strong class="source-inline">d3-shape</strong> library (<a href="https://github.com/d3/d3-shape">https://github.com/d3/d3-shape</a>), which offers a convenient <strong class="source-inline">line</strong> method that generates an SVG path based on an array of items. Here is an example of using the <span class="No-Break"><strong class="source-inline">line</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
const pathGenerator = line().x((d, i) =&gt; i).y((d) =&gt; d);
const path = pathGenerator(data);</pre> <p>In the preceding<a id="_idIndexMarker472"/> code snippet, we utilize the <strong class="source-inline">line</strong> method to create a <strong class="source-inline">pathGenerator</strong> function, which generates<a id="_idIndexMarker473"/> an SVG path by mapping the array’s values to the <em class="italic">y</em> coordinates. You can create a line graph by using the returned SVG path with the <strong class="source-inline">&lt;path&gt;</strong> element in <span class="No-Break">an SVG.</span></p>
<p>Once you’ve completed your implementation, feel free to compare your results with our example at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12/02-line-chart">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12/02-line-chart</a>. Good luck and have fun experimenting with your animated <span class="No-Break">line graph!</span></p>
<p>After familiarizing ourselves with using the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores with numbers, arrays, and objects, it is now time for us to incorporate non-numeric values. This will be achieved through the creation of custom tweened interpolators, which we will explore in the <span class="No-Break">next section.</span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor183"/>Creating custom tweened interpolators</h1>
<p>Sometimes, you <a id="_idIndexMarker474"/>may want to transition between non-numeric values, such as colors. Fortunately, this doesn’t prevent us from using the <strong class="source-inline">tweened</strong> store. The <strong class="source-inline">tweened</strong> function offers an option to define custom interpolation between <span class="No-Break">two values.</span></p>
<p>In this <a id="_idIndexMarker475"/>section, we’ll explore how to create a custom interpolation to smoothly transition between <span class="No-Break">two colors.</span></p>
<p>But what <span class="No-Break">is interpolation?</span></p>
<p>When transitioning between two values, interpolating means generating intermediate values between the values, to create a <span class="No-Break">smooth transition.</span></p>
<p>For example, consider a <strong class="source-inline">tweened</strong> store initialized at <strong class="source-inline">0</strong>, and we set it to <strong class="source-inline">100</strong>. The <strong class="source-inline">tweened</strong> store generates intermediate values between <strong class="source-inline">0</strong> and <strong class="source-inline">100</strong>, such as <strong class="source-inline">20</strong>, <strong class="source-inline">40</strong>, <strong class="source-inline">60</strong>, and so on, while updating the store value with these intermediate values. As a result, during the transition from <strong class="source-inline">0</strong> to <strong class="source-inline">100</strong>, the store value smoothly changes, providing a visually appealing progression from <strong class="source-inline">0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">100</strong></span><span class="No-Break">.</span></p>
<p>This <a id="_idIndexMarker476"/>process of generating intermediate values is known <span class="No-Break">as interpolation.</span></p>
<p>The <a id="_idIndexMarker477"/>default <strong class="source-inline">tweened</strong> store is capable of interpolating between two numbers, two arrays of numbers, and two objects with numeric property values. However, it doesn’t know how to interpolate between two colors. In such cases, we can pass a custom interpolation function when creating a <span class="No-Break"><strong class="source-inline">tweened</strong></span><span class="No-Break"> store.</span></p>
<p>The function signature of the <strong class="source-inline">tweened</strong> store interpolation looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
function interpolate(a, b) {
  return function (t) {
    // calculate the intermediate value between 'a' and 'b' based on 't'
  };
}</pre> <p>In this function, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> represent the starting and ending values, while <strong class="source-inline">t</strong> is a value between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong> indicating the progress of the transition. The <strong class="source-inline">interpolate</strong> function should return another function that calculates and returns the intermediate value based on <strong class="source-inline">t</strong>, the progress of <span class="No-Break">the transition.</span></p>
<p>For example, an <strong class="source-inline">interpolate</strong> function that interpolates between two numbers linearly looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
function interpolate(a, b) {
  return function (t) {
    return a + t * (b – a);
  };
}</pre> <p>The <strong class="source-inline">interpolate</strong> function returns another function that takes a progress value, <strong class="source-inline">t</strong>, and calculates a linear interpolation between <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> based on the <strong class="source-inline">t</strong> value. When <strong class="source-inline">t</strong> is <strong class="source-inline">0</strong>, the function returns <strong class="source-inline">a</strong>, and when <strong class="source-inline">t</strong> is <strong class="source-inline">1</strong>, it returns <strong class="source-inline">b</strong>. For values of <strong class="source-inline">t</strong> between 0 and 1, the result is proportionally between <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>.To create an interpolation function for colors, we could break the colors down into individual <strong class="bold">red, green, and blue</strong> (<strong class="bold">RGB</strong>) components and interpolate each of the components separately. After interpolating each component, we could then recombine them to form the <span class="No-Break">intermediate color.</span></p>
<p>Alternatively, we <a id="_idIndexMarker478"/>could <a id="_idIndexMarker479"/>use a library that has already implemented such interpolation. A good example of such a library is <strong class="source-inline">d3-interpolate</strong> (<a href="https://github.com/d3/d3-interpolate">https://github.com/d3/d3-interpolate</a>). By using a well-tested library such as <strong class="source-inline">d3-interpolate</strong>, we can save time and ensure that our color interpolation is accurate <span class="No-Break">and efficient.</span></p>
<p>Here’s an example <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">d3-interpolate</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import { interpolateRgb } from 'd3-interpolate';
function interpolate(a, b) {
  const interpolateColor = interpolateRgb(a, b);
  return function (t) {
    return interpolateColor(t);
  };
}</pre> <p>In the preceding code snippet, we import the <strong class="source-inline">interpolateRgb</strong> function from <strong class="source-inline">d3-interpolate</strong>, which returns an interpolator function for the colors <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. We then create our custom interpolate function, <strong class="source-inline">interpolateColor</strong>, which returns a function that calculates the intermediate color based on the <span class="No-Break">progress, </span><span class="No-Break"><strong class="source-inline">t</strong></span><span class="No-Break">.</span></p>
<p>To use our custom <strong class="source-inline">interpolate</strong> function when creating a <strong class="source-inline">tweened</strong> store, we can pass the <strong class="source-inline">interpolate</strong> function in the <span class="No-Break">second argument:</span></p>
<pre class="source-code">
tweened(color, { interpolate: interpolate });</pre> <p>And that’s it; you can now create a <strong class="source-inline">tweened</strong> store for colors that can smoothly transition <span class="No-Break">between them.</span></p>
<p>You can find a code example of using color interpolation on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12/04-interpolation"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12/04-interpolation</span></a><span class="No-Break">.</span></p>
<p>By now, you’ve learned how to use a <strong class="source-inline">tweened</strong> store to create animated graphs and how to <a id="_idIndexMarker480"/>transition <a id="_idIndexMarker481"/>between non-numeric values using a custom <span class="No-Break"><strong class="source-inline">interpolate</strong></span><span class="No-Break"> function.</span></p>
<p>Let’s explore more examples using the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores to create fluid <span class="No-Break">user interfaces.</span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor184"/>Examples – creating an animated image preview</h1>
<p>In this<a id="_idIndexMarker482"/> example, we’ll create an image preview feature that allows users to view a larger, more detailed version of a thumbnail image when they click on it, enhancing the user’s visual experience and allowing them to inspect images <span class="No-Break">more closely.</span></p>
<p>While <a id="_idIndexMarker483"/>building this feature, you’ll see how we can utilize the <strong class="source-inline">spring</strong> store to create a more fluid and natural user experience, making the transitions between images and their larger previews feel smooth <span class="No-Break">and engaging.</span></p>
<p>To begin, let’s create a list of images that will be displayed on <span class="No-Break">our page:</span></p>
<pre class="source-code">
&lt;script&gt;
  const images = [
    "path/to/image1.jpg",
    "path/to/image2.jpg",
    // ...more image paths
  ];
  const imgElements = [];
&lt;/script&gt;
&lt;div class="image-container"&gt;
  {#each images as image, index}
    &lt;div&gt;
      &lt;img src={image} bind:this={imgElements[index]} /&gt;
    &lt;/div&gt;
  {/each}
&lt;/div&gt;</pre> <p>In this <a id="_idIndexMarker484"/>example, we create an array <a id="_idIndexMarker485"/>of images containing the paths to our image files. We use the <strong class="source-inline">{#each}</strong> block to loop through the images and create a <strong class="source-inline">&lt;div&gt;</strong> element containing an <strong class="source-inline">&lt;img&gt;</strong> element for <span class="No-Break">each image.</span></p>
<p>In the preceding snippet, the <strong class="source-inline">&lt;style&gt;</strong> section is omitted because it is not essential for understanding how the code functions. If you would like to know what the styles look like, you can find them <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12/03-image-preview"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter12/03-image-preview</span></a><span class="No-Break">.</span></p>
<p>We keep the references to the <strong class="source-inline">&lt;img&gt;</strong> elements inside the <strong class="source-inline">imgElements</strong> variable. This will be <span class="No-Break">useful later.</span></p>
<p>To preview the images and close the preview, we need to implement two functions, <strong class="source-inline">openPreview</strong> and <strong class="source-inline">closePreview</strong>, along with a variable, <strong class="source-inline">selectedImageIndex</strong>, to keep track of the currently <span class="No-Break">previewed image:</span></p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  let selectedImageIndex = -1;</strong>
<strong class="bold">  function openPreview(index) {</strong>
<strong class="bold">    selectedImageIndex = index;</strong>
<strong class="bold">  }</strong>
<strong class="bold">  function closePreview() {</strong>
<strong class="bold">    selectedImageIndex = -1;</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;
...
      &lt;img
        src={image}
        bind:this={imgElements[index]}
        <strong class="bold">on:click={() =&gt; openPreview(index)}</strong>
      /&gt;</pre> <p>In the preceding code snippet, we initialize <strong class="source-inline">selectedImageIndex</strong> to <strong class="source-inline">-1</strong>, indicating that no image is selected. The <strong class="source-inline">openPreview</strong> function sets <strong class="source-inline">selectedImageIndex</strong>, while <strong class="source-inline">closePreview</strong> unsets it. Lastly, we add a click event listener to call <strong class="source-inline">openPreview</strong> for the <span class="No-Break">clicked image.</span></p>
<p>To create<a id="_idIndexMarker486"/> a black <a id="_idIndexMarker487"/>backdrop for our image preview, we add a <strong class="source-inline">&lt;div&gt;</strong>element, which will have the <strong class="source-inline">.backdrop</strong> class only when an image is selected. Clicking on the backdrop would close <span class="No-Break">the preview:</span></p>
<pre class="source-code">
&lt;div
  class:backdrop={selectedImageIndex !== -1}
  on:click={closePreview}
/&gt;</pre> <p>To display the image preview, our goal is to emphasize, enlarge, and center the image on the screen. In order to accomplish this, we must determine the target width and height for the enlarged image and calculate the <em class="italic">x</em> and <em class="italic">y</em> positions required to <span class="No-Break">center it.</span></p>
<p>For simplicity, let’s assume that the image has a 1:1 aspect ratio. We’ll set the target width and height to be 80% of the smaller value between the window height and window width. With the target height and width determined, we can use these values to calculate the <em class="italic">x</em> and <em class="italic">y</em> positions required to center the image on the screen. Let’s <span class="No-Break">see how:</span></p>
<pre class="source-code">
&lt;script&gt;
  let selectedImageIndex = -1;
  <strong class="bold">let width, height, left, top;</strong>
  function openPreview(index) {
    selectedImageIndex = index;
    <strong class="bold">width = Math.min(window.innerWidth, window.innerHeight) * 0.8;</strong>
    <strong class="bold">height = width; // same as width, assuming 1:1 ratio</strong>
    <strong class="bold">left = (window.innerWidth - width) / 2;</strong>
    <strong class="bold">top = (window.innerHeight - height) / 2;</strong>
  }
&lt;/script&gt;
...
      &lt;img
        src={image}
        bind:this={imgElements[index]}
        on:click={() =&gt; openPreview(index)}
        <strong class="bold">style={selectedImageIndex === index ? `</strong>
          <strong class="bold">position: fixed;</strong>
          <strong class="bold">left: ${left}px;</strong>
          <strong class="bold">top: ${top}px;</strong>
          <strong class="bold">width: ${width}px;</strong>
          <strong class="bold">height: ${height}px;</strong>
        <strong class="bold">` : ''}</strong>
      /&gt;</pre> <p>In<a id="_idIndexMarker488"/> the<a id="_idIndexMarker489"/> code snippet, we set the style for the selected image. When an image is selected, we use <strong class="source-inline">position: fixed</strong> to position it, allowing us to set the <strong class="source-inline">left</strong> and <strong class="source-inline">top</strong> positions of the image relative to the viewport. At this point, we have a simple image <span class="No-Break">preview component.</span></p>
<p>Now, let’s move on to an interesting question: how can we use the <strong class="source-inline">spring</strong> store to make the preview more fluid, rather than abruptly placing the image at the center of <span class="No-Break">the screen?</span></p>
<p>One idea is to use <strong class="source-inline">transform: translate</strong> instead of directly setting the left and top positions to center the image. We can keep the left and top positions unchanged, and use <strong class="source-inline">transform: translate</strong> to move the image to the center of the screen. The values for the translation offsets would come from the <span class="No-Break"><strong class="source-inline">spring</strong></span><span class="No-Break"> store.</span></p>
<p>The reason for using <strong class="source-inline">transform: translate</strong> instead of updating the left and top positions is that it allows for smoother and more efficient animations, as it doesn’t trigger layout recalculations and repaints as frequently as updating positional properties such as <strong class="source-inline">left</strong> and <strong class="source-inline">top</strong>. Also, using <strong class="source-inline">transform: translate</strong> makes it much easier to reset the image back to its original position by simply resetting the translation offset back <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
<p>Similarly, we <a id="_idIndexMarker490"/>can apply this idea to the <a id="_idIndexMarker491"/>width and height of the image. We can maintain the original image dimensions and utilize <strong class="source-inline">transform: scale</strong> to resize <span class="No-Break">the image.</span></p>
<p>With this idea ready, let’s get to the code. Here, I initialize the transformation as a <span class="No-Break"><strong class="source-inline">spring</strong></span><span class="No-Break"> store:</span></p>
<pre class="source-code">
const transform = spring(
  { translate: { x: 0, y: 0 }, scale: { x: 1, y: 1 } },
  { stiffness: 0.1, damping: 0.25 }
);</pre> <p>The default value of the <strong class="source-inline">transform</strong> <strong class="source-inline">spring</strong> store is a <strong class="source-inline">0</strong> translation offset and <strong class="source-inline">1</strong> as <span class="No-Break">the scale.</span></p>
<p>To keep the image in its original position after setting it to use <strong class="source-inline">position: fixed</strong>, we need to get the <strong class="source-inline">&lt;img&gt;</strong> element’s current position and dimension, which can be obtained <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">getBoundingClientRect</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
function openPreview(index) {
  // ...
  const rect = imgElements[index].getBoundingClientRect();
  left = rect.left;
  top = rect.top;
  width = rect.width;
  height = rect.height;
}</pre> <p>The previous formula we calculated for the <strong class="source-inline">left</strong>, <strong class="source-inline">top</strong>, <strong class="source-inline">width</strong>, and <strong class="source-inline">height</strong> values to center and <a id="_idIndexMarker492"/>enlarge the image will be our target <strong class="source-inline">left</strong>, <strong class="source-inline">top</strong>, <strong class="source-inline">width</strong>, and <strong class="source-inline">height</strong>. They will be used to <a id="_idIndexMarker493"/>calculate the translation offset <span class="No-Break">and scale:</span></p>
<pre class="source-code">
  const targetWidth = Math.min(window.innerWidth, window.innerHeight) * 0.8;
  const targetHeight = targetWidth;
  const targetLeft = (window.innerWidth - targetWidth) / 2;
  const targetTop = (window.innerHeight - targetHeight) / 2;
  $transform = {
    translate: {
      x: targetLeft - left,
      y: targetTop - top
    },
    scale: {
      x: targetWidth / width,
      y: targetHeight / height
    },
  };</pre> <p>The translation offset is calculated using the difference between the target position and the actual position, while the scale is the ratio between the target width and height compared to the actual width <span class="No-Break">and height.</span></p>
<p>Incorporating the transform values into the <strong class="source-inline">&lt;img&gt;</strong> styles looks <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;img
  style={selectedImageIndex === index ? `
  ...
  <strong class="bold">transform: translate(${$transform.translate.x}px, ${$transform.translate.y}px) scale(${$transform.scale.x}, ${$transform.scale.y});</strong>
  ` : ''}</pre> <p>With <a id="_idIndexMarker494"/>these changes, the image will <a id="_idIndexMarker495"/>smoothly spring into the center when clicked, creating a more fluid and natural <span class="No-Break">user experience.</span></p>
<p>Now it’s your turn to try it for yourself. Experiment with creating an opacity value using the <strong class="source-inline">spring</strong> store and use this value to adjust the dimness of the image preview backdrop. This will further enhance the fluidity and visual appeal of the image <span class="No-Break">preview component.</span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor185"/>Summary</h1>
<p>In this chapter, we looked at the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores <span class="No-Break">from Svelte.</span></p>
<p>We explored how to use the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores to create smooth animations and transitions, enhancing the visual appeal and user experience. By working with custom interpolation functions and applying them to non-numeric values, such as colors, we’ve expanded the possibilities for creating dynamic and engaging user <span class="No-Break">interface elements.</span></p>
<p>Throughout the chapter, we’ve seen multiple examples of the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores in action, seeing how easy it is to use the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores to create animations. Hopefully, you are now more comfortable using the <strong class="source-inline">tweened</strong> and <strong class="source-inline">spring</strong> stores in your <span class="No-Break">Svelte projects.</span></p>
<p>This is our last chapter discussing Svelte context and Svelte stores. In the next chapter, we will look into transitions, namely, how to use transitions in our <span class="No-Break">Svelte components.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer039">
<h1 id="_idParaDest-184" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor186"/>Part 4: Transitions</h1>
<p>In this final section, we will delve into Svelte transitions. We will begin by understanding how to incorporate built-in transitions in our Svelte components. Following that, we will guide you through creating your own custom transitions. To end the section, we will wrap up by emphasizing accessibility and how we can create an accessible application with transitions that caters to <span class="No-Break">all users.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18887_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a><em class="italic">, Using Transitions</em></li>
<li><a href="B18887_14.xhtml#_idTextAnchor202"><em class="italic">Chapter 14</em></a><em class="italic">, Exploring Custom Transitions</em></li>
<li><a href="B18887_15.xhtml#_idTextAnchor211"><em class="italic">Chapter 15</em></a><em class="italic">, Accessibility with Transitio</em>n</li>
</ul>
</div>
<div>
<div id="_idContainer040">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer041">
</div>
</div>
</div></body></html>