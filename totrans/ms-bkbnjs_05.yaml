- en: Chapter 5. Dealing with Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are building a Backbone application you will consume resources from
    a RESTful web service; however most of the RESTful services use the JSON format
    to encode information, but JSON is not suitable to send and receive files. How
    we can send files to a RESTful server?
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing an application that is not JavaScript–intensive, you can
    send files through an HTML form, but in **Single Page Applications** (**SPA**)
    this is not the best way to do it. Another issue is that Backbone does not provide
    an easy mechanism to send files because it is not compatible with the RESTful
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'But web applications need to work with files. There are some approaches to
    deal with this common issue. For example, you could use a traditional POST form
    on resources where files may be included; however, that''s not a good option.
    In this chapter you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle file uploads from an Express server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopt strategies to send files to a RESTful server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a resource that includes a file in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by adding support for uploading files to an Express server because
    it is important to know how a server can respond to upload requests.
  prefs: []
  type: TYPE_NORMAL
- en: Express server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how to send files to a server, in this chapter we will work with
    the latest version of Express (the latest version available at the time of writing
    is Express 4.x). The server will be responsible for storing the REST resources
    and handling file uploads. Please consult the GitHub repo for this book to get
    the implementation of the server for the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the current server is able to create, get, update, and delete contact
    resources; we need to add a mechanism to upload an avatar image for a contact.
    For simplicity the application does not use a database to store its data, but
    instead uses a hash table to store all data in memory. For example, the next snippet
    demonstrates how to store a contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Attaching a file into a resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start receiving files in the Express server, we need to set up a strategy
    for that. We still want to use the RESTful services, so changing the format of
    the transmission data is not an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Respecting the RESTful standard (for more on the REST design for file uploads,
    see [http://bit.ly/1GXqPNY](http://bit.ly/1GXqPNY)), we can attach a subresource
    endpoint under the target resource to handle the uploads, so that it will not
    disturb the original resource. However, this approach has a limitation: the resource
    should exist first, which means that you cannot create a contact and its avatar
    photo at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this approach, the endpoint for the avatar file uploading can be
    located at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Attaching a file into a resource](img/B01962_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 File uploading schema
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows the schema for how file uploading should be handled
    by the server; the avatar endpoint will handle POST requests encoded as `multipart/form-data`
    instead of JSON, because that''s the only way to upload files using the HTTP protocol.
    Note that in the endpoint it''s included the contact id; in this way, once the
    file is uploaded we can associate the file with the resource. Though the endpoint
    does not accept a JSON as input, it can return a JSON to inform about the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example result, the server is telling us that we can access the avatar
    through the `http://example.com/avatar/something.jpg` URL. We need to modify the
    contact resource to include this new information in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The contact resource now includes the avatar information so that it can be used
    to show the avatar wherever it's needed—for example, in the contact list. To display
    the avatar image, the only thing you need to do is include the avatar URL in an
    `img` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The server should be able serve these files too. In the simplest workflow, you
    can put all the avatar images in a common path and serve that path as regular
    assets; the downside of this approach is that anyone can see the files if they
    have the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the avatar photo to contacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating the endpoint to upload avatar photos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Express itself does not process files automatically; it needs a plug-in that
    transforms the raw request into a more user-friendly API. This plug-in is named
    `multer`; it processes `multipart/form-data`, saving the file into a temporary
    path or making a buffer object, and then provides a JSON object with metadata
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With the default configuration, it will save all the uploaded files into the
    temporary path of your operating system, which is `/tmp` in Unix systems; `multer`
    will attach a `files` attribute in the `req` object, which we can inspect to retrieve
    information about the uploaded files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first steps, we validate that user has been uploaded a valid file and
    then we get the target user from the database and, if doesn't exist, we return
    an Http `404` error. The `multer` plug-in stores the uploaded file in memory,
    and can be processed before saving the file to the final path; for example, maybe
    we want to generate a thumbnail file or process the image to save space on disk.
  prefs: []
  type: TYPE_NORMAL
- en: We ensure that the avatar path exists; if doesn't we then create the path. In
    the next steps, we generate a filename to be assigned to the uploaded file in
    order to prevent filename collisions; the `generateFilename()` function generates
    that filename and then checks if it already exists; if it does, then we generate
    another filename and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a unique filename for the uploaded file, we store the file from
    the in-memory buffer to the generated path. Now that the file is in the avatar
    path, we can build the URL where we can get the image from the browser, and finally
    assign the URL to the `avatar` field in the contact resource.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the avatar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can upload images and the contact resource has the information
    about where the avatar is located, we can show the avatar in our views by pointing
    an `img` tag to the `avatar.url` property in the `Contact` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the image, if any; otherwise it will show a default one. We
    should modify the Contact model to include a default avatar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If no avatar image is retrieved from the server, then we use a null image.
    The following screenshot shows how it looks like when you upload an image. This
    is enough to show an avatar image where it''s necessary. It is very easy to show
    images. In the rest of the chapter, we will see how to perform the upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the avatar](img/B01962_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 Showing the Contact avatar
  prefs: []
  type: TYPE_NORMAL
- en: Uploading images from Backbone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow us to upload files from our Backbone application, we should create
    an input file to be able to show a **Choose** file dialog. This could be done
    in the `ContactEditor` sub-application by changing the `ContactPreview` class
    to add this functionality. So let''s change the current template and add the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have created a hidden input file field; we don''t want to show
    the input field, but we want the control to open a **Select File** dialog. As
    the input is hidden, when the user clicks on the current image, we will show the
    file chooser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks on the image, it triggers a click event on the input;
    this will open the **Open file** dialog and allow the user to select a file from
    his/her hard drive. After the user selects the file, the browser triggers a `change`
    event on the file input that we can use to process the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `change` event will call the `fileSelected()`method that is responsible
    for processing the selected file. As we have seen in [Chapter 1](ch01.html "Chapter 1. Architecture
    of a Backbone application"), *Architecture of a Backbone application* views should
    not talk to the server directly; for this reason, the view should not make any
    `AJAX` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to upload the image is in the Contact model, so the view should
    only get the selected file and delegate this process to the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When a file is selected, we create a `blob` object and trigger an event with
    the object attached to be processed by the controller. Note that we use the HTML
    5 API to immediately show the selected image as the avatar preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `uploadAvatar()` method takes a file blob as argument and delegates the
    server connection to the `Contact` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The controller will trigger `''avatar:uploading:*''` events to reflect the
    status of the uploading process. These events can be listened for the view to
    give visual feedback to the user. Figure 5.3 graphically shows the communication
    between the controller and the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading images from Backbone](img/B01962_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 Event communication between the view and controller
  prefs: []
  type: TYPE_NORMAL
- en: The `uploadEvent()` method in the Contact model accepts a blob object as the
    first argument, which is the file that will be uploaded, and an `options` object
    with three possible functions that will be called as the communication with the
    server proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may guess, `success` and `error` callbacks will be called if the server
    accepts the file or if a error happens, respectively. Large files are divided
    and uploaded to the server in chunks; the `progress()`callback is called as the
    chunks are received in the server. With the information provided in the `progress()`
    handler, we can update a progress bar to show the progress to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As the events are triggered by the controller, the view updates the message
    displayed to the user, so that the user can see if an error occurs, or supplies
    an uploading message to show what the application is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should pass the controller instance to the view at creation time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Uploading a file with AJAX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Client` model receive the blob object, builds the URL to the `avatar`
    endpoint, and makes the appropriate calls to the callback objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See how the model builds the endpoint from its own data so that the view is
    decoupled of any server connection. As the `multipart/form-data` `POST` is not
    managed natively by the browser, we should create a `FormData` object that represents
    a form data structure, and add an `avatar` field (the field name that is expecting
    the server).
  prefs: []
  type: TYPE_NORMAL
- en: 'They key attribute in the `$.ajax()` call is `processData`, which is set to
    `false`; you can read the following in the jQuery documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*By default, data passed in to the data option as an object (technically, anything
    other than a string) will be processed and transformed into a query string, fitting
    to the default content-type "application/x-www-form-urlencoded". If you want to
    send a DOMDocument, or other non-processed data, set this option to false.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't set this attribute to `false`, or leave it at the default, jQuery
    will try transform the `formData` object and the file will not be sent.
  prefs: []
  type: TYPE_NORMAL
- en: If a progress attribute is set in the `options` object, we overwrite the original
    `xhr()` function called by jQuery to get an `XMLHttpRequest` object instance;
    this allow us to listen for the `progress` event triggered by the browser while
    uploading the file.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the avatar image at creation time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, to upload and attach a file to a resource, it must already
    exist. How we can create a resource with a file attached? How can we create a
    contact that includes an avatar image?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will need to create the resource in two steps. In the first step,
    we create the resource itself, and then in a second step we can upload all files
    we want to that resource. Yes, it''s not possible to do this in a single server
    connection, at least without encoding the files you want to send:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading the avatar image at creation time](img/B01962_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 Create contact process
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how the process is done. Note that the model is responsible
    for handling these connections while the controller orchestrates the order of
    the communication and error handling. As we have seen previously, the `ContactEditor`
    triggers several events that the view can use to show to the user what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'The views can be left as is; we should only modify the `ContactEditor` controller
    by changing how the `saveContact()` method behaves. However, we want to keep the
    feature of uploading the image as the user makes the selection. If the Contact
    model is new, this feature will break the application because no valid endpoint
    exists to upload the avatar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When an avatar is selected, instead of immediately uploading the file to the
    server, we check if the contact is new or not. If the model is not new, we can
    perform the upload by calling the `uploadAvatar()`method; otherwise, we keep a
    reference to the blob object in the `avatarSelected` attribute that the `uploadAvatar()`
    method will use when it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `saveContact()` method is responsible for orchestrating the algorithm described
    in the previous figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Before calling the `save()` method in the Contact model, it's necessary to save
    whether the model is new or not; if we call this method after the save, the `isNew()`
    method will always return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: If the model wasn't new, then any changes in the avatar image were already uploaded
    by the `'avatar:selected'` event handler, so we don't need to upload the image
    again. But if the image was new, then we should upload the avatar by calling the
    `uploadAvatar()` method; note that the method accepts an `options` object to register
    callbacks. This is necessary to provide feedback to the user; when the upload
    is done it calls the `notifyAndRedirect()` function to show a notification message
    and returns to the list of contacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to change the implementation of `uploadAvatar()` to include the
    callbacks described earlier and to instead receive the blob as soon as it uses
    the `avatarSelected` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The method is basically the same; we just add the `options` callbacks and change
    the source of the blob object.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding the upload file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach to uploading files is to encode the file into `base64`. When
    you encode a binary file to `base64`, the result is a string that we can use as
    an attribute in the request object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though it can be useful to create objects with the file attached in the resource,
    or to use it as another resource in the server, this is not a recommended approach.
    This approach has some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: If the backend server is a node, the thread will be locked until the server
    decodes the `base64` string. This will lead to a low-performance app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot upload large amounts of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is large, the Backbone application will freeze until the file is
    encoded to `base64`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are uploading very small amounts of data and don''t have a huge amount
    of traffic, you can use this technique; otherwise, I encourage you to avoid it.
    Instead of uploading the file we can encode it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course the server implementation should be able to decode the `avatarImage`
    and store it as an image file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to upload files to the server; this is not
    the only way to do it, but is the more extended and flexible approach. Another
    possible method is to serialize the image into `base64` in the browser, then set
    the output string as an attribute in the model; when ten models are saved, the
    file encoded in `base64` will be part of the payload. The server should decode
    the string and process the result as a file.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to decouple the view from the business logic. The view should only
    process DOM events and trigger business logic level events; then a controller
    can deal with blob objects instead of low-level DOM nodes. This approach helped
    us to move upload processing from the view to the model, which is the ideal way
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we dealt with the creation process; we cannot create a resource and
    attach files at the same time. We should first create the resource and then send
    all the files to the server as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to store information directly in the
    browser. Instead of using a RESTful server, it might be nice to run standalone
    web applications that don't need a server to run.
  prefs: []
  type: TYPE_NORMAL
