- en: Chapter 5. Dealing with Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。处理文件
- en: When you are building a Backbone application you will consume resources from
    a RESTful web service; however most of the RESTful services use the JSON format
    to encode information, but JSON is not suitable to send and receive files. How
    we can send files to a RESTful server?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个 Backbone 应用程序时，你将从一个 RESTful 网络服务中消费资源；然而，大多数 RESTful 服务使用 JSON 格式来编码信息，但
    JSON 不适合发送和接收文件。我们如何将文件发送到 RESTful 服务器？
- en: If you are developing an application that is not JavaScript–intensive, you can
    send files through an HTML form, but in **Single Page Applications** (**SPA**)
    this is not the best way to do it. Another issue is that Backbone does not provide
    an easy mechanism to send files because it is not compatible with the RESTful
    specification.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个不是 JavaScript 密集型的应用程序，你可以通过 HTML 表单发送文件，但在 **单页应用程序**（**SPA**）中这不是最好的方法。另一个问题是
    Backbone 不提供发送文件的简单机制，因为它与 RESTful 规范不兼容。
- en: 'But web applications need to work with files. There are some approaches to
    deal with this common issue. For example, you could use a traditional POST form
    on resources where files may be included; however, that''s not a good option.
    In this chapter you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Web 应用程序需要处理文件。有一些方法可以处理这个常见问题。例如，你可以在可能包含文件的资源上使用传统的 POST 表单；然而，这并不是一个好的选择。在本章中，你将学习以下内容：
- en: Handle file uploads from an Express server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Express 服务器处理文件上传
- en: Adopt strategies to send files to a RESTful server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用策略将文件发送到 RESTful 服务器
- en: Upload files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传文件
- en: Create a resource that includes a file in it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含文件的资源
- en: We will start by adding support for uploading files to an Express server because
    it is important to know how a server can respond to upload requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加对 Express 服务器上传文件的支持，因为了解服务器如何响应上传请求是很重要的。
- en: Express server
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express 服务器
- en: To demonstrate how to send files to a server, in this chapter we will work with
    the latest version of Express (the latest version available at the time of writing
    is Express 4.x). The server will be responsible for storing the REST resources
    and handling file uploads. Please consult the GitHub repo for this book to get
    the implementation of the server for the previous chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何将文件发送到服务器，在本章中我们将使用 Express 的最新版本（撰写本文时可用的最新版本是 Express 4.x）。服务器将负责存储
    REST 资源和处理文件上传。请查阅本书的 GitHub 仓库以获取前几章服务器的实现。
- en: 'For now, the current server is able to create, get, update, and delete contact
    resources; we need to add a mechanism to upload an avatar image for a contact.
    For simplicity the application does not use a database to store its data, but
    instead uses a hash table to store all data in memory. For example, the next snippet
    demonstrates how to store a contact:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当前服务器能够创建、获取、更新和删除联系人资源；我们需要添加一个机制来上传联系人的头像图片。为了简化，应用程序不使用数据库来存储其数据，而是使用散列表在内存中存储所有数据。例如，下面的代码片段演示了如何存储一个联系人：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Attaching a file into a resource
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件附加到资源中
- en: Before we start receiving files in the Express server, we need to set up a strategy
    for that. We still want to use the RESTful services, so changing the format of
    the transmission data is not an option.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在 Express 服务器接收文件之前，我们需要为它设置一个策略。我们仍然想使用 RESTful 服务，所以改变传输数据的格式不是一种选择。
- en: 'Respecting the RESTful standard (for more on the REST design for file uploads,
    see [http://bit.ly/1GXqPNY](http://bit.ly/1GXqPNY)), we can attach a subresource
    endpoint under the target resource to handle the uploads, so that it will not
    disturb the original resource. However, this approach has a limitation: the resource
    should exist first, which means that you cannot create a contact and its avatar
    photo at the same time.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尊重 RESTful 标准（有关文件上传的 REST 设计更多信息，请参阅 [http://bit.ly/1GXqPNY](http://bit.ly/1GXqPNY))，我们可以在目标资源下附加一个子资源端点来处理上传，这样就不会干扰原始资源。然而，这种方法有一个限制：资源必须先存在，这意味着你不能同时创建一个联系人和其头像照片。
- en: 'Following this approach, the endpoint for the avatar file uploading can be
    located at:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法，头像文件上传的端点可以定位在：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Attaching a file into a resource](img/B01962_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![将文件附加到资源中](img/B01962_05_01.jpg)'
- en: Figure 5.1 File uploading schema
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 文件上传方案
- en: 'The preceding figure shows the schema for how file uploading should be handled
    by the server; the avatar endpoint will handle POST requests encoded as `multipart/form-data`
    instead of JSON, because that''s the only way to upload files using the HTTP protocol.
    Note that in the endpoint it''s included the contact id; in this way, once the
    file is uploaded we can associate the file with the resource. Though the endpoint
    does not accept a JSON as input, it can return a JSON to inform about the process:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了服务器处理文件上传的架构；头像端点将处理编码为`multipart/form-data`的POST请求，而不是JSON，因为这是使用HTTP协议上传文件的唯一方式。注意，在端点中包含了联系ID；这样，一旦文件上传，我们就可以将文件与资源关联起来。尽管端点不接受JSON作为输入，但它可以返回JSON来通知处理过程：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example result, the server is telling us that we can access the avatar
    through the `http://example.com/avatar/something.jpg` URL. We need to modify the
    contact resource to include this new information in it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例结果中，服务器告诉我们可以通过`http://example.com/avatar/something.jpg` URL访问头像。我们需要修改联系资源，以包含这个新信息：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The contact resource now includes the avatar information so that it can be used
    to show the avatar wherever it's needed—for example, in the contact list. To display
    the avatar image, the only thing you need to do is include the avatar URL in an
    `img` tag.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 联系资源现在包括头像信息，以便可以在需要的地方使用它——例如，在联系人列表中。要显示头像图像，你只需要在`img`标签中包含头像URL即可。
- en: The server should be able serve these files too. In the simplest workflow, you
    can put all the avatar images in a common path and serve that path as regular
    assets; the downside of this approach is that anyone can see the files if they
    have the name of the file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也应该能够提供这些文件。在最简单的流程中，你可以将所有头像图像放在一个公共路径中，并将该路径作为常规资源提供服务；这种方法的缺点是，如果有人知道文件名，任何人都可以看到文件。
- en: Uploading the avatar photo to contacts
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传头像照片到联系人
- en: 'Let''s start by creating the endpoint to upload avatar photos:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建上传头像照片的端点：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Express itself does not process files automatically; it needs a plug-in that
    transforms the raw request into a more user-friendly API. This plug-in is named
    `multer`; it processes `multipart/form-data`, saving the file into a temporary
    path or making a buffer object, and then provides a JSON object with metadata
    information:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表达自身不自动处理文件；它需要一个插件，将原始请求转换为更用户友好的API。这个插件名为`multer`；它处理`multipart/form-data`，将文件保存到临时路径或创建一个缓冲对象，然后提供一个包含元数据信息的JSON对象：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the default configuration, it will save all the uploaded files into the
    temporary path of your operating system, which is `/tmp` in Unix systems; `multer`
    will attach a `files` attribute in the `req` object, which we can inspect to retrieve
    information about the uploaded files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置下，它将所有上传的文件保存到操作系统的临时路径中，在Unix系统中是`/tmp`；`multer`将在`req`对象中附加一个`files`属性，我们可以检查它以检索有关上传文件的信息：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first steps, we validate that user has been uploaded a valid file and
    then we get the target user from the database and, if doesn't exist, we return
    an Http `404` error. The `multer` plug-in stores the uploaded file in memory,
    and can be processed before saving the file to the final path; for example, maybe
    we want to generate a thumbnail file or process the image to save space on disk.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们验证用户是否上传了有效的文件，然后从数据库中获取目标用户，如果不存在，则返回Http `404`错误。`multer`插件将上传的文件存储在内存中，可以在将文件保存到最终路径之前进行处理；例如，我们可能想要生成缩略图文件或处理图像以节省磁盘空间。
- en: We ensure that the avatar path exists; if doesn't we then create the path. In
    the next steps, we generate a filename to be assigned to the uploaded file in
    order to prevent filename collisions; the `generateFilename()` function generates
    that filename and then checks if it already exists; if it does, then we generate
    another filename and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保头像路径存在；如果不存在，我们则创建该路径。在接下来的步骤中，我们生成一个要分配给上传文件的文件名，以防止文件名冲突；`generateFilename()`函数生成该文件名，然后检查它是否已存在；如果存在，则生成另一个文件名，依此类推。
- en: Once we have a unique filename for the uploaded file, we store the file from
    the in-memory buffer to the generated path. Now that the file is in the avatar
    path, we can build the URL where we can get the image from the browser, and finally
    assign the URL to the `avatar` field in the contact resource.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为上传的文件找到一个唯一的文件名，我们就将文件从内存缓冲区存储到生成的路径。现在文件在头像路径中，我们可以构建一个URL，从浏览器中获取图像，并最终将URL分配给联系资源中的`avatar`字段。
- en: Showing the avatar
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示头像
- en: 'Now that we can upload images and the contact resource has the information
    about where the avatar is located, we can show the avatar in our views by pointing
    an `img` tag to the `avatar.url` property in the `Contact` model:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以上传图片，并且联系资源包含了头像的位置信息，我们可以通过将 `img` 标签指向 `Contact` 模型中的 `avatar.url` 属性来在我们的视图中显示头像：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will show the image, if any; otherwise it will show a default one. We
    should modify the Contact model to include a default avatar:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示图片，如果没有则显示默认图片。我们应该修改 `Contact` 模型以包含默认头像：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If no avatar image is retrieved from the server, then we use a null image.
    The following screenshot shows how it looks like when you upload an image. This
    is enough to show an avatar image where it''s necessary. It is very easy to show
    images. In the rest of the chapter, we will see how to perform the upload:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从服务器未检索到头像图片，则使用空图片。以下截图显示了上传图片时的外观。这足以在需要的地方显示头像图片。显示图片非常简单。在本章的其余部分，我们将看到如何执行上传：
- en: '![Showing the avatar](img/B01962_05_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![显示头像](img/B01962_05_02.jpg)'
- en: Figure 5.2 Showing the Contact avatar
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 显示联系人的头像
- en: Uploading images from Backbone
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Backbone 上传图片
- en: 'To allow us to upload files from our Backbone application, we should create
    an input file to be able to show a **Choose** file dialog. This could be done
    in the `ContactEditor` sub-application by changing the `ContactPreview` class
    to add this functionality. So let''s change the current template and add the input:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许我们从 Backbone 应用程序上传文件，我们应该创建一个输入文件以显示 **选择** 文件对话框。这可以通过在 `ContactEditor`
    子应用程序中更改 `ContactPreview` 类来实现，以添加此功能。因此，让我们更改当前模板并添加输入：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that we have created a hidden input file field; we don''t want to show
    the input field, but we want the control to open a **Select File** dialog. As
    the input is hidden, when the user clicks on the current image, we will show the
    file chooser:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们创建了一个隐藏的输入文件字段；我们不希望显示输入字段，但希望控件打开 **选择文件** 对话框。由于输入是隐藏的，当用户点击当前图片时，我们将显示文件选择器：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the user clicks on the image, it triggers a click event on the input;
    this will open the **Open file** dialog and allow the user to select a file from
    his/her hard drive. After the user selects the file, the browser triggers a `change`
    event on the file input that we can use to process the selection:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击图片时，它会在输入上触发一个点击事件；这将打开 **打开文件** 对话框，并允许用户从其硬盘驱动器中选择文件。用户选择文件后，浏览器会在文件输入上触发一个
    `change` 事件，我们可以使用该事件来处理选择：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `change` event will call the `fileSelected()`method that is responsible
    for processing the selected file. As we have seen in [Chapter 1](ch01.html "Chapter 1. Architecture
    of a Backbone application"), *Architecture of a Backbone application* views should
    not talk to the server directly; for this reason, the view should not make any
    `AJAX` calls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`change` 事件将调用 `fileSelected()` 方法，该方法负责处理所选文件。正如我们在 [第 1 章](ch01.html "第 1
    章。Backbone 应用程序的架构") 中所看到的，*Backbone 应用程序的架构* 视图不应直接与服务器通信；因此，视图不应进行任何 `AJAX`
    调用。'
- en: 'The best place to upload the image is in the Contact model, so the view should
    only get the selected file and delegate this process to the controller:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的上传图片位置是在 `Contact` 模型中，因此视图应该只获取所选文件并将此过程委托给控制器：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When a file is selected, we create a `blob` object and trigger an event with
    the object attached to be processed by the controller. Note that we use the HTML
    5 API to immediately show the selected image as the avatar preview:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择文件时，我们创建一个 `blob` 对象，并触发一个带有对象的事件，由控制器进行处理。注意我们使用 HTML 5 API 立即显示所选图片作为头像预览：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `uploadAvatar()` method takes a file blob as argument and delegates the
    server connection to the `Contact` model:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`uploadAvatar()` 方法接受一个文件 blob 作为参数，并将服务器连接委托给 `Contact` 模型：'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The controller will trigger `''avatar:uploading:*''` events to reflect the
    status of the uploading process. These events can be listened for the view to
    give visual feedback to the user. Figure 5.3 graphically shows the communication
    between the controller and the view:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器将触发 `'avatar:uploading:*'` 事件以反映上传过程的状态。这些事件可以被视图监听，以向用户提供视觉反馈。图 5.3 图形化地显示了控制器和视图之间的通信：
- en: '![Uploading images from Backbone](img/B01962_05_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![从 Backbone 上传图片](img/B01962_05_03.jpg)'
- en: Figure 5.3 Event communication between the view and controller
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 视图和控制器之间的事件通信
- en: The `uploadEvent()` method in the Contact model accepts a blob object as the
    first argument, which is the file that will be uploaded, and an `options` object
    with three possible functions that will be called as the communication with the
    server proceeds.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 联系模型中的 `uploadEvent()` 方法接受一个 blob 对象作为第一个参数，这是将要上传的文件，以及一个 `options` 对象，其中包含三个可能被调用的函数，这些函数将在与服务器通信的过程中被调用。
- en: 'As you may guess, `success` and `error` callbacks will be called if the server
    accepts the file or if a error happens, respectively. Large files are divided
    and uploaded to the server in chunks; the `progress()`callback is called as the
    chunks are received in the server. With the information provided in the `progress()`
    handler, we can update a progress bar to show the progress to the user:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，如果服务器接受文件或发生错误，将分别调用 `success` 和 `error` 回调。大文件将被分割并分块上传到服务器；当块在服务器上接收时，将调用
    `progress()` 回调。通过 `progress()` 处理程序提供的信息，我们可以更新进度条以向用户显示进度：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As the events are triggered by the controller, the view updates the message
    displayed to the user, so that the user can see if an error occurs, or supplies
    an uploading message to show what the application is doing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件是由控制器触发的，视图更新显示给用户的消息，因此用户可以看到是否发生错误，或者提供上传消息以显示应用程序正在执行的操作。
- en: 'We should pass the controller instance to the view at creation time:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在创建时将控制器实例传递给视图：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Uploading a file with AJAX
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AJAX 上传文件
- en: 'The `Client` model receive the blob object, builds the URL to the `avatar`
    endpoint, and makes the appropriate calls to the callback objects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client` 模型接收 blob 对象，构建到 `avatar` 端点的 URL，并对回调对象进行适当的调用：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See how the model builds the endpoint from its own data so that the view is
    decoupled of any server connection. As the `multipart/form-data` `POST` is not
    managed natively by the browser, we should create a `FormData` object that represents
    a form data structure, and add an `avatar` field (the field name that is expecting
    the server).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看看模型如何从其自身数据构建端点，这样视图就可以与任何服务器连接解耦。由于 `multipart/form-data` `POST` 不会被浏览器原生管理，我们应该创建一个表示表单数据结构的
    `FormData` 对象，并添加一个 `avatar` 字段（服务器期望的字段名）。
- en: 'They key attribute in the `$.ajax()` call is `processData`, which is set to
    `false`; you can read the following in the jQuery documentation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `$.ajax()` 调用中，键属性是 `processData`，设置为 `false`；你可以在 jQuery 文档中阅读以下内容：
- en: '*By default, data passed in to the data option as an object (technically, anything
    other than a string) will be processed and transformed into a query string, fitting
    to the default content-type "application/x-www-form-urlencoded". If you want to
    send a DOMDocument, or other non-processed data, set this option to false.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，传递给数据选项的对象（技术上，任何非字符串）将被处理并转换成查询字符串，适合默认的内容类型 "application/x-www-form-urlencoded"。如果你想要发送一个
    DOMDocument 或其他未处理的数据，请将此选项设置为 false。
- en: If you don't set this attribute to `false`, or leave it at the default, jQuery
    will try transform the `formData` object and the file will not be sent.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不将此属性设置为 `false`，或者保留默认值，jQuery 将尝试转换 `formData` 对象，文件将不会发送。
- en: If a progress attribute is set in the `options` object, we overwrite the original
    `xhr()` function called by jQuery to get an `XMLHttpRequest` object instance;
    this allow us to listen for the `progress` event triggered by the browser while
    uploading the file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `options` 对象中设置了进度属性，我们将覆盖 jQuery 调用的原始 `xhr()` 函数以获取 `XMLHttpRequest` 对象实例；这允许我们在上传文件时监听浏览器触发的
    `progress` 事件。
- en: Uploading the avatar image at creation time
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在创建时上传头像图像
- en: As we have seen so far, to upload and attach a file to a resource, it must already
    exist. How we can create a resource with a file attached? How can we create a
    contact that includes an avatar image?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，要上传并附加文件到资源，该资源必须已经存在。我们如何创建一个带有附件的文件资源？我们如何创建一个包含头像图像的联系人？
- en: 'To do so, we will need to create the resource in two steps. In the first step,
    we create the resource itself, and then in a second step we can upload all files
    we want to that resource. Yes, it''s not possible to do this in a single server
    connection, at least without encoding the files you want to send:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们需要分两步创建资源。在第一步中，我们创建资源本身，然后在第二步中，我们可以上传所有我们想要上传到该资源的文件。是的，这不可能在单个服务器连接中完成，至少在没有对要发送的文件进行编码的情况下：
- en: '![Uploading the avatar image at creation time](img/B01962_05_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![在创建时上传头像图像](img/B01962_05_04.jpg)'
- en: Figure 5.4 Create contact process
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 创建联系过程
- en: The preceding figure shows how the process is done. Note that the model is responsible
    for handling these connections while the controller orchestrates the order of
    the communication and error handling. As we have seen previously, the `ContactEditor`
    triggers several events that the view can use to show to the user what's happening.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了这个过程是如何进行的。注意，模型负责处理这些连接，而控制器则协调通信的顺序和错误处理。正如我们之前看到的，`ContactEditor`
    触发了几个视图可以使用的事件，向用户展示正在发生的事情。
- en: 'The views can be left as is; we should only modify the `ContactEditor` controller
    by changing how the `saveContact()` method behaves. However, we want to keep the
    feature of uploading the image as the user makes the selection. If the Contact
    model is new, this feature will break the application because no valid endpoint
    exists to upload the avatar:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以保持原样；我们只需通过更改 `saveContact()` 方法的行为来修改 `ContactEditor` 控制器。然而，我们希望保留用户在做出选择时上传图片的功能。如果联系人模型是新的，此功能将破坏应用程序，因为没有有效的端点来上传头像：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When an avatar is selected, instead of immediately uploading the file to the
    server, we check if the contact is new or not. If the model is not new, we can
    perform the upload by calling the `uploadAvatar()`method; otherwise, we keep a
    reference to the blob object in the `avatarSelected` attribute that the `uploadAvatar()`
    method will use when it is called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择头像时，我们不会立即将文件上传到服务器，而是检查联系人是否是新的。如果模型不是新的，我们可以通过调用 `uploadAvatar()` 方法来执行上传；否则，我们将在
    `avatarSelected` 属性中保留 blob 对象的引用，`uploadAvatar()` 方法将在被调用时使用它。
- en: 'The `saveContact()` method is responsible for orchestrating the algorithm described
    in the previous figure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveContact()` 方法负责协调前面图示中描述的算法：'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before calling the `save()` method in the Contact model, it's necessary to save
    whether the model is new or not; if we call this method after the save, the `isNew()`
    method will always return `true`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用联系人模型的 `save()` 方法之前，有必要保存模型是否是新的；如果我们在此方法之后调用它，`isNew()` 方法将始终返回 `true`。
- en: If the model wasn't new, then any changes in the avatar image were already uploaded
    by the `'avatar:selected'` event handler, so we don't need to upload the image
    again. But if the image was new, then we should upload the avatar by calling the
    `uploadAvatar()` method; note that the method accepts an `options` object to register
    callbacks. This is necessary to provide feedback to the user; when the upload
    is done it calls the `notifyAndRedirect()` function to show a notification message
    and returns to the list of contacts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型不是新的，那么头像图像的任何更改已经通过 `'avatar:selected'` 事件处理程序上传，所以我们不需要再次上传图像。但如果图像是新的，那么我们应该通过调用
    `uploadAvatar()` 方法来上传头像；请注意，该方法接受一个 `options` 对象来注册回调。这是必要的，以便向用户提供反馈；上传完成后，它调用
    `notifyAndRedirect()` 函数来显示通知消息，并返回到联系人列表。
- en: 'We will need to change the implementation of `uploadAvatar()` to include the
    callbacks described earlier and to instead receive the blob as soon as it uses
    the `avatarSelected` attribute:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改 `uploadAvatar()` 的实现，以包括前面描述的回调，并立即在它使用 `avatarSelected` 属性时接收 blob：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The method is basically the same; we just add the `options` callbacks and change
    the source of the blob object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 方法基本上是相同的；我们只是添加了 `options` 回调，并更改了 blob 对象的来源。
- en: Encoding the upload file
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码上传文件
- en: Another approach to uploading files is to encode the file into `base64`. When
    you encode a binary file to `base64`, the result is a string that we can use as
    an attribute in the request object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件的另一种方法是将其编码为 `base64`。当你将二进制文件编码为 `base64` 时，结果是我们可以用作请求对象属性的字符串。
- en: 'Though it can be useful to create objects with the file attached in the resource,
    or to use it as another resource in the server, this is not a recommended approach.
    This approach has some limitations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在资源中创建附加文件的对象或将其用作服务器上的另一个资源可能很有用，但这不是推荐的方法。这种方法有一些限制：
- en: If the backend server is a node, the thread will be locked until the server
    decodes the `base64` string. This will lead to a low-performance app.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果后端服务器是节点，线程将锁定，直到服务器解码 `base64` 字符串。这将导致性能低下的应用程序。
- en: You cannot upload large amounts of data.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能上传大量数据。
- en: If the file is large, the Backbone application will freeze until the file is
    encoded to `base64`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件很大，Backbone 应用程序将冻结，直到文件被编码为 `base64`。
- en: 'If you are uploading very small amounts of data and don''t have a huge amount
    of traffic, you can use this technique; otherwise, I encourage you to avoid it.
    Instead of uploading the file we can encode it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上传的数据量非常小，并且没有大量的流量，你可以使用这种技术；否则，我鼓励你避免使用。我们不必上传文件，可以对其进行编码：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course the server implementation should be able to decode the `avatarImage`
    and store it as an image file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，服务器实现应该能够解码`avatarImage`并将其存储为图像文件。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to upload files to the server; this is not
    the only way to do it, but is the more extended and flexible approach. Another
    possible method is to serialize the image into `base64` in the browser, then set
    the output string as an attribute in the model; when ten models are saved, the
    file encoded in `base64` will be part of the payload. The server should decode
    the string and process the result as a file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何将文件上传到服务器；这不是唯一的方法，但这是更广泛和灵活的方法。另一种可能的方法是在浏览器中将图像序列化为`base64`，然后将输出字符串设置为模型中的属性；当保存十个模型时，编码为`base64`的文件将成为有效负载的一部分。服务器应该解码字符串并将结果作为文件处理。
- en: We saw how to decouple the view from the business logic. The view should only
    process DOM events and trigger business logic level events; then a controller
    can deal with blob objects instead of low-level DOM nodes. This approach helped
    us to move upload processing from the view to the model, which is the ideal way
    to do it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何将视图与业务逻辑解耦。视图应该只处理DOM事件并触发业务逻辑级别的事件；然后控制器可以处理blob对象而不是低级别的DOM节点。这种方法帮助我们将上传处理从视图移动到模型，这是理想的做法。
- en: Finally, we dealt with the creation process; we cannot create a resource and
    attach files at the same time. We should first create the resource and then send
    all the files to the server as needed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理了创建过程；我们不能同时创建资源并附加文件。我们应该首先创建资源，然后根据需要将所有文件发送到服务器。
- en: In the next chapter, you will learn how to store information directly in the
    browser. Instead of using a RESTful server, it might be nice to run standalone
    web applications that don't need a server to run.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何直接在浏览器中存储信息。与其使用RESTful服务器，不如运行不需要服务器即可运行的独立Web应用程序。
