- en: Exploring Elm in Greater Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [Chapter 6](651ea5bb-9106-4053-b8b4-6481508a775b.xhtml), *Exploring
    Elm in Greater Detail*. While the previous chapter was more on the practical side,
    this chapter will deal with more theoretical concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring values in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Elm deal with randomness?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscriptions in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `Html.program`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Improve your apps by understanding more advanced Elm concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send commands to deal with randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe to events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desctructure values and work with them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin the chapter by looking at a very important topic: destructuring
    values in Elm.'
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring values in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Destructuring is an elegant and effective way to extract values from data structures
    in Elm. Destructuring is also referred to as pattern matching. The syntax is terse,
    and for the uninitiated, it can be slightly confusing, precisely because it is
    so short. However, once understood, it feels like a natural and practical way
    to get the values out from Elm data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of destructuring a tuple in Elm. As a reminder, a tuple
    is a data structure similar to a record. The difference is that it is usually
    shorter, and we do not care about naming the values stored in a tuple. If you
    really must name values in your data structure, you need to use records.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring tuples in Elm using let-in expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that a 400-meter race took place. The race involved five participants.
    We will use a tuple to store all the times of all the race participants (in seconds).
    Let''s use Elm REPL to store those times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the times, we want to do some analysis. However, to perform
    the analysis, we first need to know how to extract those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the values, we''ll use a `let-in` expression. The first task we
    have is to calculate the total time of all the racers. We will do that by adding
    up all the individual times, or, put differently, by adding up all the values
    stored in the tuple. Easy enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now calculate the average time by dividing the result by `5` (since
    there were five racers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'How did we destructure the preceding tuple? To understand what is happening
    in the preceding code, we need to discuss this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code follows the `let` keyword, which, as explained previously,
    allows us to scope variables and use them only in the `in` part of a `let-in`
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we have pattern-matched a five-tuple (containing variables `a`, `b`,
    `c`, `d`, and `e`) to the specific tuple we declared previously, and gave it the
    name `aTuple`. In other words, if we pretend that Elm REPL is a person, the preceding
    line of code is the same as if we said: *Hey Elm REPL, use the values from aTuple,
    and match the values to letters a,b,c,d, and e, because I want to perform some
    calculations on those values*.'
  prefs: []
  type: TYPE_NORMAL
- en: Then in the `in` part of our `let-in` expression, we simply performed our calculations
    as needed. The preceding example shows what destructuring essentially is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, let''s see how easy it is to work with only some of the
    values from our `aTuple`. We''ll calculate the average time of the first three
    runners. This is really easy. Along the lines of what we did earlier, we''ll simply
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what Elm REPL returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s calculate the time difference between the last to the finish
    line and the first racer to have crossed it. We''ll do another simple calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The Elm REPL will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, everything works as expected. Let''s now imagine a similar use of tuple
    destructuring. This time, we''ll be using a five-tuple of Strings. The goal is
    to play around with destructuring only some values from a tuple, just like we
    did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s print out a ''''Hello World'''' to the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this will not work like we thought it would. The error is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This poses a problem. While we already know, from the examples of calculating
    race times, that we could pattern-match all the values from a tuple using a one-to-one
    mapping, with temporary variables, this approach might not always be the most
    efficient. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Because sometimes we might have to assign longer, more expressive variable names
    in our let expressions, to satisfy the compiler. And then, once we don't get the
    error, we'd never actually use those variable names. This is impractical. Realistically,
    we will not be able to always type one-letter temporary variables and still be
    able to easily make sense of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the solution is simple—when we don''t care about some of the values
    that will appear in a tuple while we are destructuring it, we can use the underscore
    character to signify it. Effectively, what we are saying to the Elm REPL is—d*on''t
    pay attention to these values*. Let''s rewrite the previous example so that it
    works with underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Elm REPL responds with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s replace the one-letter variables with something more meaningful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Elm REPL will still return the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring tuples in Elm using case-of expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will destructure tuples using `case-of` expressions. To
    see the effects of tuple destructuring, we''ll have to use the Ellie app rather
    than Elm REPL. To begin, let''s set up the following basic example in the Ellie
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding code does should be easy to understand—using the values from
    the greeting variable, the main function will pattern-match using the case-of
    expression, and return text based on the values destructured from the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we check for literal match on both `Strings` in the two-tuple of `greeting`.
    Then, we check for literal match on only the first `String`. Next, we check only
    for the match of the `"World"`—the second `String` in our greeting two-tuple.
    Finally, we cover all other possible cases by matching for anything else, using
    the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now test our application with various combinations. First, we''ll use
    the code as is. Pressing the Compile button in the Ellie app will produce the
    following text printed to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the greeting tuple so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile the Ellie app, and you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s try changing the greeting to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon compilation, the Ellie app will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll use our newly-found knowledge of tuple destructuring
    and apply it in an improved version of our FizzBuzz app.
  prefs: []
  type: TYPE_NORMAL
- en: Building a FizzBuzz app using tuple destructuring inside of a case-of expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revisit our FizzBuzz problem. This time we can use our modulus operations
    as conditions of a `case` expression. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To keep the preceding code concise, we have set the value of `n` to a single
    fixed number of 100\. Feel free to test out the app by replacing that value with
    a different number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code should be easy to understand—we set our `modulusTest` to
    a tuple that contains the calculation of `n % 5` and `n % 3`. Then, in `main`,
    we use the `text` function on the `let-in` expression. The `<|` is the backward
    function application operator. It takes the value that gets evaluated to its right,
    and passes it as an argument to whatever sits on its left—in this case, a `text`
    function. Essentially, it is used in place of parentheses. In other words, we
    could have written the `main` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It would do the exact same thing as the code we used prior to the preceding
    snippet. Finally, our case expression takes the value returned from the calculations
    performed in `modulusTest` and pattern-matches it to appropriate values. The beauty
    of this setup is that now it is very easy to check for different numbers. For
    example, we could print out threes and sevens, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at how to destructure tuples inside of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring nested tuples using let-in expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try this in Elm REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s destructure the value of `i` from the innermost tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we did not even have to declare the `nestedTuples` variable. Instead,
    we could have destructured values on the fly, inside the let-in statement. For
    example, let''s use the Ellie app to compile the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we could have used the underscore when suitable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this, we wrap up our discussion of tuple destructuring. Next, we'll look
    at record destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring records in Elm using let-in expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records in Elm are destructured similar to tuples. Let''s rewrite our example
    of race times using a record instead of a tuple. Compile the following app in
    the Ellie app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, the following text should be displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The code used in the preceding app is essentially the same code we used in the
    example on destructuring tuples. The difference comes  from the way that records
    work in Elm—since they *must* have named values, we *must* use these names when
    destructuring values out of records.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring records on the fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When destructuring records, we don''t even have to use the underscore character.
    Since all the values in a record are named, it''s enough to use that name to extract
    the value from a record. Using our previous example of race times, let''s put
    the record that stores them inside Elm REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at extracting the time of the fifth runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The REPL returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the Ellie app to destructure the time of the fifth runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'But why do we need to use our custom `extactorFunction`? Can''t we just go
    without it? Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon compilation, the Ellie app will print this on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we really wanted to do it without the extractor function, we could have
    done it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, the Ellie app will print out the expected value of `90` on the
    screen. Finally, let''s deconstruct and use only two values. We will begin with
    faulty code, which will throw an error. The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code, when compiled, will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? Give yourself some time to think it through. It will be a useful discovery.
    For the impatient reader, here is the appropriate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The error was due to the fact that initially, we gave a confusing expression
    to the Elm compiler, and it simply did not know what to do with it. Let''s look
    at the offending code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler sees: a value, a comma, and a value, and it has no idea how to
    return a single value from this line of code. We''ve already seen one way of solving
    this error; by extracting the values from a record into a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach would be to print these values out as a string, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have completed our discussion of destructuring values in Elm. Next,
    we will look into the ways in which Elm deals with randomness.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with randomness in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, values in Elm are immutable. The functions are pure; they
    allow for no side effects. When a specific value goes in, a function will operate
    on it and always return another specific value.
  prefs: []
  type: TYPE_NORMAL
- en: This poses a problem—just how do we deal with randomness? For example, how do
    we generate random numbers? Or, for that matter, how do we perform anything that
    involves a side effect? We do that by *having functions return commands*.
  prefs: []
  type: TYPE_NORMAL
- en: Commands in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a command, you are telling the Elm runtime to do something you are not
    allowed to do, since doing it would break the concept of guarantees. Thus, a command
    that you return from a function is just a static, immutable value. What does this
    value do? It just *names* the desired result. It does not tell Elm how to do it.
    It is just a name for one or more things that need to be done by the Elm runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For example, since the concept of guarantees says that for every input into
    a pure function, we should receive the same kind of output, we cannot have a function
    return a random number, since doing so would break the concept of guarantees.
    In order to make the preceding scenario possible, we need to send a command to
    the Elm runtime, *asking it* to give us a random number.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, once the Elm runtime receives a command, such as a request for a random
    number, *it will return a message*. Then we can use that message in the update
    function, as explained in [Chapter 2](c80584ff-97c8-411b-8ec3-a4b122121579.xhtml),
    *Building Your First Elm App*.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this very basic introduction to commands in Elm is that there are
    no ambiguities about the new code that we will introduce, or, put differently,
    that we have at least some knowledge about what each piece of code does. Next,
    we'll look at subscriptions, and how they fit into the Elm architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Subscriptions in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commands allow us to tell the Elm runtime to *do random things* without breaking
    Elm's guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's say we want the Elm runtime to tell us when some changes happen
    in the outside world (that is, anything that we cannot directly control in our
    app). We cannot control the changes in the outside world with commands—because *we
    are not the source* of these changes.
  prefs: []
  type: TYPE_NORMAL
- en: That's why subscriptions exist. They allow us to listen for things such as mouse
    movements, keyboard presses, time changes, and so on. With commands, *we order
    the Elm runtime to do random things*; with subscriptions, *the Elm runtime tells
    us of random things being done*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we want to track when a keyboard button is pressed. We'll have
    our app subscribe to those keyboard presses. Once that specific keyboard button
    is pressed, the Elm runtime will send a message, and in our update function, we
    specify how it should behave when such a message is received.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with commands and subscriptions in Elm, we can look
    at how they can be used to extend our current concept of the Elm architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Elm architecture by adding effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we knew about commands in Elm, we used to implement the Elm architecture
    using the `beginnerProgram` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: However, using only `beginnerProgram`, we have no way to deal with either commands
    or subscriptions. Practically, our `beginnerProgram` function is just a watered-down
    version of the `Html.program` function.
  prefs: []
  type: TYPE_NORMAL
- en: Put differently, using `Html.program`, we have the ability to extend our Elm
    architecture so that we keep Elm's guarantees and still deal with randomness,
    that is, side effects, regardless of these side effects' origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, rather than using  `Html.beginnerProgram` (like we did previously), let''s
    see how we can set up our main function so that it is using `Html.program`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The change in the code is minimal, but our Elm program just got a lot more
    capable. This concludes our brief introduction to dealing with randomness in Elm.
    In the next section, we will look at a very useful concept in Elm: partial application.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we have a function that takes in two parameters. The function is very
    simple—it just takes two `Strings` and concatenates them, with an added space
    in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function signature will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the function, we might pass two words like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function will evaluate to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement this as a tiny program that we can run in the Ellie app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon compilation, the Ellie app will show the words User Experience in the
    right-hand preview pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e194a6f6-022b-4b74-81bf-b5aa243198db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we have also added type annotation preceding the function definition.
    The type annotation reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the type annotation, we could say that our `concatTwoWords` function
    takes two strings and returns a string. After all, that is what the type annotation
    looks like. What would happen if we passed only one argument to our `concatTWoWords`
    function? Let''s try it. Run the following code in the Ellie app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we got a `Type Mismatch` error, which reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: So, obviously, if our function is expecting two arguments, we can't just pass
    one argument to it and call it a day, since, as we have just seen, that will cause
    the compiler to throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what we can do is a neat little trick. We can define a new function.
    This new function that we'll define will store the result of passing only one
    String to `concatTwoWords`. In other words, it will store the result of partial
    application of the `concatTwoWords` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For lack of a better name, we will give this new function the name `partiallyApply`,
    and define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done here is that, we have *partially applied* our `concatTwoWords`
    function by *passing it only one argument.* Then, we stored the result in another
    function that we called `partiallyApply`. We can still pass an argument to our
    `partiallyApply` function, and we will store it in the `partiallyApplyAgain` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated code, ready to be run in the Ellie app, will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code will result in the words `User Experience` displayed
    on the right-hand pane of the Ellie app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered a number of important topics, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring values in Elm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Elm deal with randomness?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing effects to our apps by using `Html.program`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will begin building a fully functional weather app which
    will connect to a remote API to fetch weather information.
  prefs: []
  type: TYPE_NORMAL
