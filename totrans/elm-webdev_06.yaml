- en: Exploring Elm in Greater Detail
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更深入地探索 Elm
- en: Welcome to [Chapter 6](651ea5bb-9106-4053-b8b4-6481508a775b.xhtml), *Exploring
    Elm in Greater Detail*. While the previous chapter was more on the practical side,
    this chapter will deal with more theoretical concepts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第 6 章，*更深入地探索 Elm*。虽然上一章更侧重于实践方面，但这一章将涉及更多理论概念。
- en: 'The topics we will cover include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题包括：
- en: Destructuring values in Elm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 中的解构值
- en: How does Elm deal with randomness?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 如何处理随机性？
- en: Commands in Elm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 中的命令
- en: Subscriptions in Elm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 中的订阅
- en: Working with `Html.program`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Html.program` 进行操作
- en: 'After completing this chapter, you will be able to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你将能够：
- en: Improve your apps by understanding more advanced Elm concepts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过理解更高级的 Elm 概念来改进你的应用
- en: Send commands to deal with randomness
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送命令来处理随机性
- en: Subscribe to events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅事件
- en: Desctructure values and work with them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构值并与之交互
- en: 'Let''s begin the chapter by looking at a very important topic: destructuring
    values in Elm.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Elm 中解构值的一个非常重要的主题开始这一章。
- en: Destructuring values in Elm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 中的解构值
- en: Destructuring is an elegant and effective way to extract values from data structures
    in Elm. Destructuring is also referred to as pattern matching. The syntax is terse,
    and for the uninitiated, it can be slightly confusing, precisely because it is
    so short. However, once understood, it feels like a natural and practical way
    to get the values out from Elm data structures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是 Elm 中从数据结构中提取值的一种优雅而有效的方法。解构也被称为模式匹配。语法简洁，对于初学者来说，可能会有些困惑，正是因为它如此简短。然而，一旦理解了，它感觉就像是从
    Elm 数据结构中获取值的一种自然且实用的方法。
- en: Let's look at an example of destructuring a tuple in Elm. As a reminder, a tuple
    is a data structure similar to a record. The difference is that it is usually
    shorter, and we do not care about naming the values stored in a tuple. If you
    really must name values in your data structure, you need to use records.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个 Elm 中解构元组的例子开始这一章。作为提醒，元组是一种类似于记录的数据结构。区别在于它通常更短，我们不需要关心存储在元组中的值的命名。如果你真的需要在你的数据结构中命名值，你需要使用记录。
- en: Destructuring tuples in Elm using let-in expressions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let-in 表达式在 Elm 中解构元组
- en: 'Let''s imagine that a 400-meter race took place. The race involved five participants.
    We will use a tuple to store all the times of all the race participants (in seconds).
    Let''s use Elm REPL to store those times:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一场 400 米赛跑发生了。这场比赛涉及五位参赛者。我们将使用元组来存储所有参赛者的所有时间（以秒为单位）。让我们使用 Elm REPL 来存储这些时间：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The REPL will return the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: REPL将返回以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have the times, we want to do some analysis. However, to perform
    the analysis, we first need to know how to extract those values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了时间，我们想要进行一些分析。然而，为了执行分析，我们首先需要知道如何提取这些值。
- en: 'To extract the values, we''ll use a `let-in` expression. The first task we
    have is to calculate the total time of all the racers. We will do that by adding
    up all the individual times, or, put differently, by adding up all the values
    stored in the tuple. Easy enough:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取值，我们将使用一个`let-in`表达式。我们面临的第一项任务是计算所有赛跑者的总时间。我们将通过将所有单独的时间相加来完成这项任务，或者说，通过将元组中存储的所有值相加。这很简单：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The REPL returns the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now calculate the average time by dividing the result by `5` (since
    there were five racers):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过将结果除以`5`（因为有五个赛跑者）来计算平均时间：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This time, the REPL returns the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，REPL 返回以下内容：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'How did we destructure the preceding tuple? To understand what is happening
    in the preceding code, we need to discuss this line of code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何解构前面的元组的？为了理解前面代码中发生的事情，我们需要讨论这一行代码：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding line of code follows the `let` keyword, which, as explained previously,
    allows us to scope variables and use them only in the `in` part of a `let-in`
    expression.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码遵循了`let`关键字，正如之前所解释的，这允许我们在`let-in`表达式的`in`部分作用域内使用变量。
- en: 'Thus, we have pattern-matched a five-tuple (containing variables `a`, `b`,
    `c`, `d`, and `e`) to the specific tuple we declared previously, and gave it the
    name `aTuple`. In other words, if we pretend that Elm REPL is a person, the preceding
    line of code is the same as if we said: *Hey Elm REPL, use the values from aTuple,
    and match the values to letters a,b,c,d, and e, because I want to perform some
    calculations on those values*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将一个五元组（包含变量 `a`、`b`、`c`、`d` 和 `e`）与之前声明的特定元组进行模式匹配，并给它命名为 `aTuple`。换句话说，如果我们把
    Elm REPL 当作一个人，那么前面的代码行就相当于我们说：“嘿 Elm REPL，使用 `aTuple` 中的值，并将这些值与字母 a、b、c、d 和
    e 匹配，因为我想要对这些值进行一些计算”。
- en: Then in the `in` part of our `let-in` expression, we simply performed our calculations
    as needed. The preceding example shows what destructuring essentially is.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 `let-in` 表达式的 `in` 部分中，我们只需按需执行计算。前面的例子展示了解构本质上是什么。
- en: 'In the next example, let''s see how easy it is to work with only some of the
    values from our `aTuple`. We''ll calculate the average time of the first three
    runners. This is really easy. Along the lines of what we did earlier, we''ll simply
    do this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，让我们看看如何轻松地处理 `aTuple` 中的一些值。我们将计算前三名运动员的平均时间。这真的很简单。沿着我们之前做的路线，我们只需这样做：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what Elm REPL returns:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Elm REPL 返回的结果：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, let''s calculate the time difference between the last to the finish
    line and the first racer to have crossed it. We''ll do another simple calculation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们计算最后一名到达终点线和第一名冲过终点的运动员之间的时间差。我们将进行另一个简单的计算：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Elm REPL will return the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Elm REPL 将返回以下结果：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Great, everything works as expected. Let''s now imagine a similar use of tuple
    destructuring. This time, we''ll be using a five-tuple of Strings. The goal is
    to play around with destructuring only some values from a tuple, just like we
    did before:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，一切如预期工作。现在，让我们想象一个类似的元组解构用法。这次，我们将使用一个字符串的五元组。目标是像之前一样，只解构元组中的某些值：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let''s print out a ''''Hello World'''' to the REPL:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 REPL 中打印出 "Hello World"：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unfortunately, this will not work like we thought it would. The error is self-explanatory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会像我们想象的那样工作。错误是自解释的：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This poses a problem. While we already know, from the examples of calculating
    race times, that we could pattern-match all the values from a tuple using a one-to-one
    mapping, with temporary variables, this approach might not always be the most
    efficient. Why?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了一个问题。虽然我们已经从计算比赛时间的例子中知道，我们可以使用一对一映射和临时变量来匹配元组中的所有值，但这种方法可能并不总是最有效的。为什么？
- en: Because sometimes we might have to assign longer, more expressive variable names
    in our let expressions, to satisfy the compiler. And then, once we don't get the
    error, we'd never actually use those variable names. This is impractical. Realistically,
    we will not be able to always type one-letter temporary variables and still be
    able to easily make sense of our programs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有时我们可能需要在 let 表达式中分配更长、更具有表达性的变量名，以满足编译器的要求。然后，一旦我们不再收到错误，我们就永远不会真正使用这些变量名。这是不切实际的。现实情况下，我们不可能总是能够输入单字母的临时变量，同时还能轻松理解我们的程序。
- en: 'Luckily, the solution is simple—when we don''t care about some of the values
    that will appear in a tuple while we are destructuring it, we can use the underscore
    character to signify it. Effectively, what we are saying to the Elm REPL is—d*on''t
    pay attention to these values*. Let''s rewrite the previous example so that it
    works with underscores:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，解决方案很简单——当我们解构元组时，如果我们不关心其中的一些值，我们可以使用下划线字符来表示它。实际上，我们告诉 Elm REPL 的就是——不要注意这些值。让我们重写之前的例子，使其使用下划线工作：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Elm REPL responds with the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Elm REPL 以以下方式响应：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s replace the one-letter variables with something more meaningful:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更有意义的东西替换单字母变量：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Elm REPL will still return the same result.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Elm REPL 仍然会返回相同的结果。
- en: Destructuring tuples in Elm using case-of expressions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 case-of 表达式在 Elm 中解构元组
- en: 'In this section, we will destructure tuples using `case-of` expressions. To
    see the effects of tuple destructuring, we''ll have to use the Ellie app rather
    than Elm REPL. To begin, let''s set up the following basic example in the Ellie
    app:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `case-of` 表达式解构元组。为了看到元组解构的效果，我们必须使用 Ellie 应用程序而不是 Elm REPL。首先，让我们在
    Ellie 应用程序中设置以下基本示例：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What the preceding code does should be easy to understand—using the values from
    the greeting variable, the main function will pattern-match using the case-of
    expression, and return text based on the values destructured from the tuple.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码所做的事情应该很容易理解——使用问候变量中的值，主函数将使用 case-of 表达式进行模式匹配，并根据从元组中解构的值返回文本。
- en: 'First we check for literal match on both `Strings` in the two-tuple of `greeting`.
    Then, we check for literal match on only the first `String`. Next, we check only
    for the match of the `"World"`—the second `String` in our greeting two-tuple.
    Finally, we cover all other possible cases by matching for anything else, using
    the following pattern:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在问候的双元组中的两个 `Strings` 上检查字面匹配。然后，我们只检查第一个 `String` 的字面匹配。接下来，我们只检查 `"World"`
    的匹配——我们的问候双元组中的第二个 `String`。最后，我们通过使用以下模式匹配所有其他可能的案例：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s now test our application with various combinations. First, we''ll use
    the code as is. Pressing the Compile button in the Ellie app will produce the
    following text printed to the screen:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用各种组合测试我们的应用程序。首先，我们将使用原始代码。在 Ellie 应用程序中按下编译按钮将在屏幕上打印以下文本：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s change the greeting tuple so that it looks as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变问候元组，使其看起来如下：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, compile the Ellie app, and you should get the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译 Ellie 应用程序，你应该会得到以下内容：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, let''s try changing the greeting to this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试将问候语改为以下内容：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Upon compilation, the Ellie app will produce the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，Ellie 应用程序将生成以下输出：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next section, we'll use our newly-found knowledge of tuple destructuring
    and apply it in an improved version of our FizzBuzz app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用我们新发现的元组解构知识，并将其应用于 FizzBuzz 应用程序的改进版本。
- en: Building a FizzBuzz app using tuple destructuring inside of a case-of expression
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 case-of 表达式内部的元组解构构建 FizzBuzz 应用程序
- en: 'Let''s revisit our FizzBuzz problem. This time we can use our modulus operations
    as conditions of a `case` expression. The code will be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的 FizzBuzz 问题。这次我们可以使用我们的取模运算作为 `case` 表达式的条件。代码如下：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To keep the preceding code concise, we have set the value of `n` to a single
    fixed number of 100\. Feel free to test out the app by replacing that value with
    a different number.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码简洁，我们将 `n` 的值设为单个固定的数字 100。请随意通过替换该值以不同的数字测试应用程序。
- en: 'The preceding code should be easy to understand—we set our `modulusTest` to
    a tuple that contains the calculation of `n % 5` and `n % 3`. Then, in `main`,
    we use the `text` function on the `let-in` expression. The `<|` is the backward
    function application operator. It takes the value that gets evaluated to its right,
    and passes it as an argument to whatever sits on its left—in this case, a `text`
    function. Essentially, it is used in place of parentheses. In other words, we
    could have written the `main` function as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该很容易理解——我们将 `modulusTest` 设置为一个包含 `n % 5` 和 `n % 3` 计算的元组。然后在 `main` 中，我们对
    let-in 表达式使用 `text` 函数。`<|` 是向后函数应用操作符。它将评估为右侧的值，并将其作为参数传递给其左侧的任何内容——在这种情况下，是一个
    `text` 函数。本质上，它用于替代括号。换句话说，我们本来可以像下面这样编写 `main` 函数：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It would do the exact same thing as the code we used prior to the preceding
    snippet. Finally, our case expression takes the value returned from the calculations
    performed in `modulusTest` and pattern-matches it to appropriate values. The beauty
    of this setup is that now it is very easy to check for different numbers. For
    example, we could print out threes and sevens, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它将做与前面代码片段之前使用的代码完全相同的事情。最后，我们的 case 表达式将 `modulusTest` 中执行的计算返回的值与适当的值进行模式匹配。这种设置的优点是现在很容易检查不同的数字。例如，我们可以打印出三和七，如下所示：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's now look at how to destructure tuples inside of tuples.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在元组内部解构元组。
- en: Destructuring nested tuples using let-in expressions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let-in 表达式解构嵌套元组
- en: 'Let''s try this in Elm REPL:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Elm REPL 中尝试这个：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The REPL will return the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将返回以下内容：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, let''s destructure the value of `i` from the innermost tuple:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从最内层的元组中解构 `i` 的值：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The REPL returns the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that we did not even have to declare the `nestedTuples` variable. Instead,
    we could have destructured values on the fly, inside the let-in statement. For
    example, let''s use the Ellie app to compile the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们甚至不需要声明 `nestedTuples` 变量。相反，我们可以在 let-in 语句中即时解构值。例如，让我们使用 Ellie 应用程序来编译以下代码：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we could have used the underscore when suitable, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在适当的时候使用下划线，如下所示：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this, we wrap up our discussion of tuple destructuring. Next, we'll look
    at record destructuring.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们结束了关于元组解构的讨论。接下来，我们将探讨记录解构。
- en: Destructuring records in Elm using let-in expressions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let-in 表达式在 Elm 中解构记录
- en: 'Records in Elm are destructured similar to tuples. Let''s rewrite our example
    of race times using a record instead of a tuple. Compile the following app in
    the Ellie app:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的记录解构类似于元组。让我们用记录而不是元组重写我们的比赛时间示例。在 Ellie 应用程序中编译以下应用程序：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once compiled, the following text should be displayed on the screen:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，屏幕上应显示以下文本：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The code used in the preceding app is essentially the same code we used in the
    example on destructuring tuples. The difference comes  from the way that records
    work in Elm—since they *must* have named values, we *must* use these names when
    destructuring values out of records.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的应用程序中使用的代码基本上与我们用于解构元组的示例中使用的代码相同。区别在于 Elm 中记录的工作方式——由于它们*必须*有命名值，我们在解构记录中的值时*必须*使用这些名称。
- en: Destructuring records on the fly
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Elm 中动态解构记录
- en: 'When destructuring records, we don''t even have to use the underscore character.
    Since all the values in a record are named, it''s enough to use that name to extract
    the value from a record. Using our previous example of race times, let''s put
    the record that stores them inside Elm REPL:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在解构记录时，我们甚至不需要使用下划线字符。由于记录中的所有值都有名称，只需使用该名称即可从记录中提取值。以我们之前的比赛时间示例为例，让我们将存储这些时间的记录放入
    Elm REPL 中：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The REPL returns the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, let''s look at extracting the time of the fifth runner:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何提取第五名运动员的时间：
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The REPL returns the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s use the Ellie app to destructure the time of the fifth runner:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Ellie 应用程序来解构第五名运动员的时间：
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But why do we need to use our custom `extactorFunction`? Can''t we just go
    without it? Let''s try this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们需要使用我们的自定义 `extactorFunction`？我们不能没有它吗？让我们试试这个：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Upon compilation, the Ellie app will print this on the screen:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，Ellie 应用程序将在屏幕上打印以下内容：
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we really wanted to do it without the extractor function, we could have
    done it like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想不使用提取函数来做这件事，我们可以这样做：
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When compiled, the Ellie app will print out the expected value of `90` on the
    screen. Finally, let''s deconstruct and use only two values. We will begin with
    faulty code, which will throw an error. The code will look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，Ellie 应用程序将在屏幕上打印出预期的 `90` 值。最后，让我们解构并只使用两个值。我们将从有错误的代码开始，这将抛出错误。代码如下所示：
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code, when compiled, will throw the following error:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编译前面的代码时，将会抛出以下错误：
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Why? Give yourself some time to think it through. It will be a useful discovery.
    For the impatient reader, here is the appropriate code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？给自己一些时间思考。这将是一个有用的发现。对于急于求成的读者，以下是相应的代码：
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The error was due to the fact that initially, we gave a confusing expression
    to the Elm compiler, and it simply did not know what to do with it. Let''s look
    at the offending code again:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是由于我们最初给 Elm 编译器提供了一个令人困惑的表达式，它根本不知道如何处理它。让我们再次看看有问题的代码：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The compiler sees: a value, a comma, and a value, and it has no idea how to
    return a single value from this line of code. We''ve already seen one way of solving
    this error; by extracting the values from a record into a tuple.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器看到：一个值，一个逗号，然后是一个值，它不知道如何从这个代码行返回一个单一值。我们之前已经看到一种解决这个错误的方法；通过将记录中的值提取到元组中。
- en: 'An alternative approach would be to print these values out as a string, like
    so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将这些值作为字符串打印出来，如下所示：
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With this, we have completed our discussion of destructuring values in Elm. Next,
    we will look into the ways in which Elm deals with randomness.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们完成了 Elm 中解构值的讨论。接下来，我们将探讨 Elm 处理随机性的方法。
- en: Dealing with randomness in Elm
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Elm 中处理随机性
- en: As mentioned before, values in Elm are immutable. The functions are pure; they
    allow for no side effects. When a specific value goes in, a function will operate
    on it and always return another specific value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Elm 中的值是不可变的。函数是纯函数；它们不允许任何副作用。当特定的值传入时，函数将对其操作，并始终返回另一个特定的值。
- en: This poses a problem—just how do we deal with randomness? For example, how do
    we generate random numbers? Or, for that matter, how do we perform anything that
    involves a side effect? We do that by *having functions return commands*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了一个问题——我们该如何处理随机性？例如，我们如何生成随机数？或者，更确切地说，我们如何执行任何涉及副作用的事情？我们通过*让函数返回命令*来实现这一点。
- en: Commands in Elm
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 中的命令
- en: With a command, you are telling the Elm runtime to do something you are not
    allowed to do, since doing it would break the concept of guarantees. Thus, a command
    that you return from a function is just a static, immutable value. What does this
    value do? It just *names* the desired result. It does not tell Elm how to do it.
    It is just a name for one or more things that need to be done by the Elm runtime.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令，你是在告诉 Elm 运行时做一些你被禁止做的事情，因为这样做会破坏保证的概念。因此，从函数返回的命令只是一个静态的、不可变的价值。这个值做什么？它只是*命名*了期望的结果。它不会告诉
    Elm 如何实现它。它只是 Elm 运行时需要完成的一个或多个事情的名字。
- en: For example, since the concept of guarantees says that for every input into
    a pure function, we should receive the same kind of output, we cannot have a function
    return a random number, since doing so would break the concept of guarantees.
    In order to make the preceding scenario possible, we need to send a command to
    the Elm runtime, *asking it* to give us a random number.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于保证的概念指出，对于纯函数的每个输入，我们都应该收到相同类型的输出，因此我们不能让一个函数返回一个随机数，因为这样做会破坏保证的概念。为了使前面的场景成为可能，我们需要向
    Elm 运行时发送一个命令，*请求它*给我们一个随机数。
- en: Thus, once the Elm runtime receives a command, such as a request for a random
    number, *it will return a message*. Then we can use that message in the update
    function, as explained in [Chapter 2](c80584ff-97c8-411b-8ec3-a4b122121579.xhtml),
    *Building Your First Elm App*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦 Elm 运行时收到命令，例如请求一个随机数，*它将返回一条消息*。然后我们可以使用这条消息在更新函数中，正如在[第 2 章](c80584ff-97c8-411b-8ec3-a4b122121579.xhtml)，“构建你的第一个
    Elm 应用”中解释的那样。
- en: The goal of this very basic introduction to commands in Elm is that there are
    no ambiguities about the new code that we will introduce, or, put differently,
    that we have at least some knowledge about what each piece of code does. Next,
    we'll look at subscriptions, and how they fit into the Elm architecture.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节对 Elm 命令的基本介绍的目标是，关于我们将要引入的新代码没有歧义，或者换句话说，我们至少对每段代码的作用有一些了解。接下来，我们将探讨订阅，以及它们如何融入
    Elm 架构。
- en: Subscriptions in Elm
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 中的订阅
- en: Commands allow us to tell the Elm runtime to *do random things* without breaking
    Elm's guarantees.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 命令允许我们告诉 Elm 运行时执行一些随机的事情，而不会破坏 Elm 的保证。
- en: However, let's say we want the Elm runtime to tell us when some changes happen
    in the outside world (that is, anything that we cannot directly control in our
    app). We cannot control the changes in the outside world with commands—because *we
    are not the source* of these changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们想让 Elm 运行时告诉我们外部世界发生了一些变化（即我们无法直接控制在我们应用中的任何东西）。我们不能用命令控制外部世界的变化——因为*我们不是这些变化的来源*。
- en: That's why subscriptions exist. They allow us to listen for things such as mouse
    movements, keyboard presses, time changes, and so on. With commands, *we order
    the Elm runtime to do random things*; with subscriptions, *the Elm runtime tells
    us of random things being done*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为如此，订阅才存在。它们允许我们监听诸如鼠标移动、键盘按键、时间变化等等的事情。使用命令，*我们指示 Elm 运行时执行随机的事情*；使用订阅，*Elm
    运行时会告诉我们正在执行随机的事情*。
- en: For example, we want to track when a keyboard button is pressed. We'll have
    our app subscribe to those keyboard presses. Once that specific keyboard button
    is pressed, the Elm runtime will send a message, and in our update function, we
    specify how it should behave when such a message is received.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要跟踪键盘按钮被按下时的情况。我们的应用将订阅这些键盘按键。一旦按下特定的键盘按钮，Elm 运行时会发送一条消息，在我们的更新函数中，我们指定当接收到此类消息时应该如何处理。
- en: Now that we are familiar with commands and subscriptions in Elm, we can look
    at how they can be used to extend our current concept of the Elm architecture.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 Elm 中的命令和订阅，我们可以看看它们如何用来扩展我们当前对 Elm 架构的概念。
- en: Improving the Elm architecture by adding effects
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过添加效果改进 Elm 架构
- en: 'Before we knew about commands in Elm, we used to implement the Elm architecture
    using the `beginnerProgram` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解 Elm 的命令之前，我们通常使用 `beginnerProgram` 函数来实现 Elm 架构：
- en: '[PRE48]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: However, using only `beginnerProgram`, we have no way to deal with either commands
    or subscriptions. Practically, our `beginnerProgram` function is just a watered-down
    version of the `Html.program` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅使用 `beginnerProgram`，我们无法处理命令或订阅。实际上，我们的 `beginnerProgram` 函数只是 `Html.program`
    函数的稀释版。
- en: Put differently, using `Html.program`, we have the ability to extend our Elm
    architecture so that we keep Elm's guarantees and still deal with randomness,
    that is, side effects, regardless of these side effects' origin.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，使用 `Html.program`，我们有能力扩展我们的 Elm 架构，以便我们保持 Elm 的保证，同时仍然处理随机性，即副作用，无论这些副作用的来源如何。
- en: 'Thus, rather than using  `Html.beginnerProgram` (like we did previously), let''s
    see how we can set up our main function so that it is using `Html.program`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是使用 `Html.beginnerProgram`（就像我们之前做的那样），让我们看看我们如何设置主函数，使其使用 `Html.program`：
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The change in the code is minimal, but our Elm program just got a lot more
    capable. This concludes our brief introduction to dealing with randomness in Elm.
    In the next section, we will look at a very useful concept in Elm: partial application.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的变化很小，但我们的 Elm 程序的能力大大增强。这结束了我们对 Elm 中处理随机性的简要介绍。在下一节中，我们将探讨 Elm 中一个非常有用的概念：部分应用。
- en: Understanding partial application
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解部分应用
- en: Let's say we have a function that takes in two parameters. The function is very
    simple—it just takes two `Strings` and concatenates them, with an added space
    in between.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个接受两个参数的函数。这个函数非常简单——它只是接受两个 `Strings` 并将它们连接起来，中间加上一个空格。
- en: 'The function signature will look as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名将如下所示：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we call the function, we might pass two words like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，我们可能会传递两个单词，如下所示：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding function will evaluate to the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将评估为以下内容：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s now implement this as a tiny program that we can run in the Ellie app:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将其实现为一个可以运行在 Ellie 应用程序中的小程序：
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Upon compilation, the Ellie app will show the words User Experience in the
    right-hand preview pane:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，Ellie 应用程序将在右侧预览窗格中显示“用户体验”字样：
- en: '![](img/e194a6f6-022b-4b74-81bf-b5aa243198db.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e194a6f6-022b-4b74-81bf-b5aa243198db.png)'
- en: 'Note that we have also added type annotation preceding the function definition.
    The type annotation reads:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在函数定义之前添加了类型注解。类型注解如下：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Looking at the type annotation, we could say that our `concatTwoWords` function
    takes two strings and returns a string. After all, that is what the type annotation
    looks like. What would happen if we passed only one argument to our `concatTWoWords`
    function? Let''s try it. Run the following code in the Ellie app:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 观察类型注解，我们可以这样说，我们的 `concatTwoWords` 函数接受两个字符串并返回一个字符串。毕竟，类型注解看起来就是这样。如果我们只向我们的
    `concatTWoWords` 函数传递一个参数会发生什么？让我们试一试。在 Ellie 应用程序中运行以下代码：
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This time we got a `Type Mismatch` error, which reads as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们得到了一个 `Type Mismatch` 错误，内容如下：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, obviously, if our function is expecting two arguments, we can't just pass
    one argument to it and call it a day, since, as we have just seen, that will cause
    the compiler to throw an error.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显然，如果我们的函数期望两个参数，我们不能只传递一个参数并称之为结束，因为我们刚刚看到，这将导致编译器抛出错误。
- en: Instead, what we can do is a neat little trick. We can define a new function.
    This new function that we'll define will store the result of passing only one
    String to `concatTwoWords`. In other words, it will store the result of partial
    application of the `concatTwoWords` function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们能够做的是一个小巧的技巧。我们可以定义一个新的函数。我们将定义的这个新函数将存储只传递一个 `String` 给 `concatTwoWords`
    的结果。换句话说，它将存储 `concatTwoWords` 函数的部分应用结果。
- en: 'For lack of a better name, we will give this new function the name `partiallyApply`,
    and define it as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有更好的名字，我们将给这个新函数命名为 `partiallyApply`，并定义如下：
- en: '[PRE57]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'What we have done here is that, we have *partially applied* our `concatTwoWords`
    function by *passing it only one argument.* Then, we stored the result in another
    function that we called `partiallyApply`. We can still pass an argument to our
    `partiallyApply` function, and we will store it in the `partiallyApplyAgain` function,
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是，我们通过只传递一个参数来*部分应用*我们的 `concatTwoWords` 函数。然后，我们将结果存储在另一个我们称之为 `partiallyApply`
    的函数中。我们仍然可以向我们的 `partiallyApply` 函数传递一个参数，然后我们将它存储在 `partiallyApplyAgain` 函数中，如下所示：
- en: '[PRE58]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The updated code, ready to be run in the Ellie app, will now look as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 准备在 Ellie 应用程序中运行的更新后的代码现在如下所示：
- en: '[PRE59]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Running the preceding code will result in the words `User Experience` displayed
    on the right-hand pane of the Ellie app.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将在Ellie应用右侧面板上显示单词`用户体验`。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have covered a number of important topics, namely:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些重要主题，包括：
- en: Destructuring values in Elm
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 中的值解构
- en: How does Elm deal with randomness?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 如何处理随机性？
- en: Understanding partial application
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解部分应用
- en: Introducing effects to our apps by using `Html.program`
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `Html.program` 向我们的应用引入效果
- en: In the next chapter, we will begin building a fully functional weather app which
    will connect to a remote API to fetch weather information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始构建一个功能齐全的天气应用，该应用将连接到远程API以获取天气信息。
