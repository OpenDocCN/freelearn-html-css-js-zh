- en: Chapter 2. The Fundamentals of Babylon.js and Available Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents the fundamentals of Babylon.js. It includes the notions
    of *engine*, *scene*, *camera*, *light*, *mesh*, and so on. By practicing, you'll
    understand the basic tools used in 3D such as vectors and how/where they are used
    in 3D engines. You'll also practice with graph structures and understand the architecture
    of Babylon.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussing the Babylon.js structure and graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Babylon.js structure and graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's create and explain the necessary tools to draw things on the screen,
    such as an engine that will handle a scene to draw a 3D object and use a camera
    and light.
  prefs: []
  type: TYPE_NORMAL
- en: The engine and a scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The engine is the core of Babylon.js and a scene allows you to create and manage
    entities that you''ll draw on the screen (objects, lights, cameras, and so on),
    thanks to an engine. You can see the engine like a gateway to communicate with
    the video card (GPU) while a scene is a high-level interface that handles the
    following multiple entities:'
  prefs: []
  type: TYPE_NORMAL
- en: 3D objects (more on this in [Chapter 3](ch03.html "Chapter 3. Create, Load,
    and Draw 3D Objects on the Screen"), *Create, Load, and Draw 3D Objects on the
    Screen*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle systems (smoke, rain, and others)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skeletons (animated 3D objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-processes (effects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Materials (more on this in [Chapter 4](ch04.html "Chapter 4. Using Materials
    to Customize 3D Objects Appearance"), *Using Materials to Customize 3D Objects
    Appearance*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, a scene handles multiple entities and will call the engine to
    draw these entities on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To draw on the screen, the web page (`index.html`) must contain a canvas. The
    canvas is used to create the WebGL context that the engine will use. The only
    parameter needed to create an engine is the canvas and the only parameter needed
    to create a scene is an engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The canvas in the web page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is performed to render on the entire page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an engine, you have to give the canvas reference as a parameter.
    Get the reference of the DOM object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an engine by passing the canvas reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a scene as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each new scene created is stored in `engine.scenes`, which is an array of `BABYLON.Scene`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create a scene, you can render every frame (60 frames per second in
    a perfect case and less if your hardware isn''t sufficient). To perform this action,
    you have to call the `engine.runRunderLoop(function)` function. The anonymous
    function `function` is called every frame and this is the place to draw the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `scene.render()` function is called to draw every object on the screen during
    the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Adding cameras and lights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you create a scene, you can create objects such as lights and cameras.
    The minimal scene requirement is composed of a camera (needed to get a view in
    the scene) and light (that illuminates the 3D objects in the scene, but this is
    not required if objects in the scene are self-illuminated).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several types of cameras and lights. The Babylon.js framework provides
    you with a fixed camera (no movements), FPS camera, rotation camera (turns around
    a point), gamepad camera (XBOX 360 gamepad), and touch camera (for touch devices).
    All these cameras can be created in the scene with a minimum number of lines of
    code. For example, let''s start with a free camera (FPS) with its position at
    coordinates (`x=10`,`y=20`,`z=30`). This is the occasion to introduce the `BABYLON.Vector3`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The constructor needs a name (`cameraName`), position for the camera, and scene
    reference (where to add the camera). The position is in the `BABYLON.Vector3(x,
    y, z)` type, which is the 3D vector class of Babylon.js. The `Vector3` object
    provides mathematical functions such as addition, subtraction, multiplication,
    division, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create the camera, let''s change the camera''s position and perform
    a `Vector3` addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `.addInPlace` method modifies the current instance of `Vector3`, but you
    can also call the `.add` method that will return a new instance of `Vector3` with
    the addition applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new position of the camera is now (`x=10`,`y=10`,`z=10`). Modifying the
    `.position` property does not work for all the cameras, especially the rotation
    camera (`BABYLON.ArcRotateCamera`). The rotation camera turns around a point (which
    is the target of the camera) and can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a camera](img/image_02_001-1024x768.png)'
  prefs: []
  type: TYPE_IMG
- en: The cube is at the position (`x=0`,`y=0`,`z=0`) and is the target of the camera.
    To change the camera's position, you have to call the `camera.setPosition(position)`
    function. This function will calculate the appropriate values for the alpha (angle
    around Y), beta (angle around X), and radius. Then, the .`position` property is
    only left to read.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you create your camera, let's add a light. The different lights allow you
    to perform lighting in your scene with different features. The point lights and
    hemispheric lights tend to illuminate the objects in the scene, while the spot
    lights and directional lights also provide support for the real-time shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a point light. Lights work like cameras, which means that
    you have to provide the scene reference (where to add the light):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter is the light position. `BABYLON.Vector3.Zero()` is a static
    method that is a shortcut to create a `Vector3` instance with coordinates (`x=0`,`y=0`,`z=0`).
    Now, let''s play with the light''s parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The`.diffuse` parameter represents the native color of the light, which is green
    in the example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The`.specular` parameter represents the light color reflected by a surface,
    which is red here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The`.intensity` parameter is the light's intensity that is equal to 1.0 by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the result of these parameters applied to a 3D object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a light](img/image_02_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is achieved by modifying the specular color to red and blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a light](img/image_02_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What are meshes? In fact, 3D objects are what we call meshes. Their structure
    is pretty simple as they have two important buffers in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex buffer is an array of 3D points: the vertices. The vertices represent
    the 3D points needed to build geometrical forms such as cubes, spheres, characters,
    weapons, and so on. For example, a cube has eight vertices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index buffer, which is an array of numbers, represents the indices in the
    vertex buffer to build triangles. Indeed, graphic cards are optimized to calculate
    and render triangles on the screen. For example, a face of a cube will be rendered
    using two triangles, as shown in the following image, where the green lines show
    the face:![Adding a mesh](img/image_02_004.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The job of graphic cards is separated into two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: They project (transformation) the vertices (3D points) of the vertex buffer
    on the screen. These operations are performed by a GPU program named vertex shader.
    In other words, the vertex shader computes the 2D position of each triangle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They fill the pixels associated with the triangles with their colors using a
    GPU program named pixel shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To conclude the graphic cards' job, the vertex shader computes the 2D triangles
    on the screen and the pixel shader illuminates the pixels with different colors.
  prefs: []
  type: TYPE_NORMAL
- en: Using Babylon.js to create meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Babylon.js provides you with static methods in the `BABYLON.Mesh` class that
    allow you to create basic meshes such as boxes, spheres, and torus. Every created
    mesh is an instance of `BABYLON.Mesh`. Let''s start with a box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `size` parameter represents the distance between the vertices (for example,
    5) and the `scene` parameter is the scene reference (where to add the mesh). Once
    you get the mesh created, you can access its properties and methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `.rotation` parameter represents the mesh's rotation expressed in radians `[0,
    2π]`, and then, in degrees, `π = 180 degrees` and `2π = 360 degrees`.
  prefs: []
  type: TYPE_NORMAL
- en: The `.scaling` parameter represents the mesh's scale in three directions (*x*,*y*,*z*).
    In the example, the mesh is two times bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the result if you modify its rotation only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Babylon.js to create meshes](img/image_02_005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image is the result of applying a new scale, (`x=2`,`y=2`,`z=2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Babylon.js to create meshes](img/image_02_006.png)'
  prefs: []
  type: TYPE_IMG
- en: Some other basic meshes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There exist multiple basic meshes that `BABYLON.Mesh` can create for you, such
    as spheres and planes. Let''s create a sphere and plane using the `BABYLON.Mesh`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The sphere's `segments` parameter represents the level of detail for the sphere,
    for example, 10.
  prefs: []
  type: TYPE_NORMAL
- en: The plane's `size` parameter represents the distance between vertices, for example,
    10.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a scene graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scene can be managed using a graph of nodes named scene graph. In Babylon.js,
    each mesh, light, and camera extends the `BABYLON.Node` class. In other words,
    each `BABYLON.Node` is in the scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: Each node has an array of children and one, and only one, parent. Each created
    node is a child of the graph's root by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the parent of a node, just modify the node''s reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, because the light is a child of the camera, the light's position depends
    on the camera's position. Indeed, the light space is a subspace of the camera.
    In other words, you can see the position (`x=0`,`y=0`,`z=0`) as the position of
    the camera.
  prefs: []
  type: TYPE_NORMAL
- en: When setting a parent, the transformation properties (position, rotation, and
    scaling) of the children are influenced by the parent.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s manage the scene graph with two nodes (`node1` and `node2`) and compare
    it with the equivalent code if you were to do it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following schema explains the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example](img/image_02_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating your first scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you have all the necessary elements to build your first scene. Here, the
    scene will be composed of a rotation camera, point light, and box. Let's create
    a class using TypeScript and practice with Babylon.js.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class and the scene nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following class creates the Babylon.js elements directly in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Call the runRenderLoop method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a method to the class that will call the `runRenderLoop` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This scene is exactly the same as mentioned in the previous image—there is a
    box and green light.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the scene graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To practice with the scene graph, let''s create a method that will set the
    light as a child of the camera. The method will set the light''s position at coordinates
    (`x=0`,`y=0`,`z=0`) and set the parent of the light as the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a minimal HTML page to handle a Babylon.js
    engine and draw a scene. You also learned how to use Babylon.js' built-in nodes
    such as lights, cameras, and meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Don't hesitate to practice with the built-in meshes such as torus, torus-knots,
    and spheres and play with the scene graph and node's properties such as position.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how scenes are built with designers and how
    they are imported using Babylon.js. You'll also see that interfacing 3D software
    to create scenes with Babylon.js is pretty easy as all the tools are provided
    by the Babylon.js solution (such as exporters and importers).
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will also explain how artists work to create 3D scenes for
    the web as their problems are different from desktop software such as games for
    consoles and PCs.
  prefs: []
  type: TYPE_NORMAL
