- en: Chapter 2. The Fundamentals of Babylon.js and Available Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。Babylon.js 的基础和可用工具
- en: This chapter presents the fundamentals of Babylon.js. It includes the notions
    of *engine*, *scene*, *camera*, *light*, *mesh*, and so on. By practicing, you'll
    understand the basic tools used in 3D such as vectors and how/where they are used
    in 3D engines. You'll also practice with graph structures and understand the architecture
    of Babylon.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Babylon.js 的基础。它包括 *引擎*、*场景*、*相机*、*灯光*、*网格* 等概念。通过实践，你会了解 3D 中使用的基工具，如向量以及它们在
    3D 引擎中如何/在哪里使用。你还将使用图结构进行实践，并了解 Babylon.js 的架构。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Discussing the Babylon.js structure and graphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Babylon.js的结构和图
- en: Creating your first scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个场景
- en: The Babylon.js structure and graphs
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babylon.js 的结构和图
- en: First, let's create and explain the necessary tools to draw things on the screen,
    such as an engine that will handle a scene to draw a 3D object and use a camera
    and light.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建并解释在屏幕上绘制东西所需的必要工具，例如一个处理场景以绘制 3D 对象并使用相机和灯光的引擎。
- en: The engine and a scene
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引擎和场景
- en: 'The engine is the core of Babylon.js and a scene allows you to create and manage
    entities that you''ll draw on the screen (objects, lights, cameras, and so on),
    thanks to an engine. You can see the engine like a gateway to communicate with
    the video card (GPU) while a scene is a high-level interface that handles the
    following multiple entities:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎是 Babylon.js 的核心，场景允许你创建和管理你将在屏幕上绘制的实体（对象、灯光、相机等），这得益于引擎。你可以将引擎视为与视频卡（GPU）通信的网关，而场景是一个高级接口，处理以下多个实体：
- en: 3D objects (more on this in [Chapter 3](ch03.html "Chapter 3. Create, Load,
    and Draw 3D Objects on the Screen"), *Create, Load, and Draw 3D Objects on the
    Screen*)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D 对象（更多内容请参考[第 3 章](ch03.html "第 3 章。在屏幕上创建、加载和绘制 3D 对象")，*在屏幕上创建、加载和绘制 3D
    对象*)
- en: Cameras
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机
- en: Lights
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光
- en: Particle systems (smoke, rain, and others)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统（烟雾、雨等）
- en: Textures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理
- en: Skeletons (animated 3D objects)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼（动画 3D 对象）
- en: Post-processes (effects)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后处理（效果）
- en: Materials (more on this in [Chapter 4](ch04.html "Chapter 4. Using Materials
    to Customize 3D Objects Appearance"), *Using Materials to Customize 3D Objects
    Appearance*)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质（更多内容请参考[第 4 章](ch04.html "第 4 章。使用材质自定义 3D 对象的外观")，*使用材质自定义 3D 对象的外观*)
- en: Sprites
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵
- en: In other words, a scene handles multiple entities and will call the engine to
    draw these entities on the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个场景处理多个实体，并将调用引擎在屏幕上绘制这些实体。
- en: To draw on the screen, the web page (`index.html`) must contain a canvas. The
    canvas is used to create the WebGL context that the engine will use. The only
    parameter needed to create an engine is the canvas and the only parameter needed
    to create a scene is an engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上绘制，网页（`index.html`）必须包含一个画布。画布用于创建引擎将使用的 WebGL 上下文。创建引擎所需的唯一参数是画布，创建场景所需的唯一参数是引擎。
- en: 'The canvas in the web page is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网页中的画布如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following code is performed to render on the entire page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在整个页面上执行以进行渲染：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create an engine, you have to give the canvas reference as a parameter.
    Get the reference of the DOM object as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个引擎，你必须将画布引用作为参数。获取 DOM 对象的引用如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create an engine by passing the canvas reference:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递画布引用来创建一个引擎：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a scene as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建场景如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each new scene created is stored in `engine.scenes`, which is an array of `BABYLON.Scene`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每创建一个新的场景，都会存储在 `engine.scenes` 中，它是一个 `BABYLON.Scene` 的数组。
- en: 'Once you create a scene, you can render every frame (60 frames per second in
    a perfect case and less if your hardware isn''t sufficient). To perform this action,
    you have to call the `engine.runRunderLoop(function)` function. The anonymous
    function `function` is called every frame and this is the place to draw the scene:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个场景，你就可以渲染每一帧（在理想情况下每秒 60 帧，如果硬件不足则更少）。要执行此操作，你必须调用 `engine.runRenderLoop(function)`
    函数。匿名函数 `function` 在每一帧被调用，这是绘制场景的地方：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `scene.render()` function is called to draw every object on the screen during
    the frame.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧绘制屏幕上的每个对象时，都会调用 `scene.render()` 函数。
- en: Adding cameras and lights
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加相机和灯光
- en: Once you create a scene, you can create objects such as lights and cameras.
    The minimal scene requirement is composed of a camera (needed to get a view in
    the scene) and light (that illuminates the 3D objects in the scene, but this is
    not required if objects in the scene are self-illuminated).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个场景，你就可以创建诸如灯光和相机等对象。最小场景需求由一个相机（用于在场景中获取视图）和灯光（照亮场景中的3D对象，但如果场景中的对象是自发光的，则此不是必需的）组成。
- en: Adding a camera
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加相机
- en: 'There are several types of cameras and lights. The Babylon.js framework provides
    you with a fixed camera (no movements), FPS camera, rotation camera (turns around
    a point), gamepad camera (XBOX 360 gamepad), and touch camera (for touch devices).
    All these cameras can be created in the scene with a minimum number of lines of
    code. For example, let''s start with a free camera (FPS) with its position at
    coordinates (`x=10`,`y=20`,`z=30`). This is the occasion to introduce the `BABYLON.Vector3`
    class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的相机和灯光。Babylon.js框架为你提供了固定相机（无移动）、FPS相机、旋转相机（围绕一个点旋转）、游戏手柄相机（XBOX 360游戏手柄）和触摸相机（用于触摸设备）。所有这些相机都可以用最少的代码行在场景中创建。例如，让我们从一个位置在坐标(`x=10`,`y=20`,`z=30`)的免费相机（FPS）开始。这是介绍`BABYLON.Vector3`类的好机会：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The constructor needs a name (`cameraName`), position for the camera, and scene
    reference (where to add the camera). The position is in the `BABYLON.Vector3(x,
    y, z)` type, which is the 3D vector class of Babylon.js. The `Vector3` object
    provides mathematical functions such as addition, subtraction, multiplication,
    division, and more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要一个名称（`cameraName`），相机的位置以及场景引用（在哪里添加相机）。位置是`BABYLON.Vector3(x, y, z)`类型，它是Babylon.js的3D向量类。`Vector3`对象提供了加法、减法、乘法、除法等数学函数。
- en: 'Once you create the camera, let''s change the camera''s position and perform
    a `Vector3` addition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了相机，让我们改变相机的位置并执行`Vector3`加法：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `.addInPlace` method modifies the current instance of `Vector3`, but you
    can also call the `.add` method that will return a new instance of `Vector3` with
    the addition applied.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`.addInPlace`方法修改了当前的`Vector3`实例，但你也可以调用`.add`方法，它将返回一个应用了加法的新`Vector3`实例。'
- en: 'The new position of the camera is now (`x=10`,`y=10`,`z=10`). Modifying the
    `.position` property does not work for all the cameras, especially the rotation
    camera (`BABYLON.ArcRotateCamera`). The rotation camera turns around a point (which
    is the target of the camera) and can be explained as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相机的新的位置是 (`x=10`,`y=10`,`z=10`)。修改`.position`属性并不适用于所有相机，特别是旋转相机（`BABYLON.ArcRotateCamera`）。旋转相机围绕一个点（即相机的目标点）旋转，可以解释如下：
- en: '![Adding a camera](img/image_02_001-1024x768.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![添加相机](img/image_02_001-1024x768.png)'
- en: The cube is at the position (`x=0`,`y=0`,`z=0`) and is the target of the camera.
    To change the camera's position, you have to call the `camera.setPosition(position)`
    function. This function will calculate the appropriate values for the alpha (angle
    around Y), beta (angle around X), and radius. Then, the .`position` property is
    only left to read.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体位于位置 (`x=0`,`y=0`,`z=0`)，并且是相机的目标。要改变相机的位置，你必须调用`camera.setPosition(position)`函数。此函数将计算alpha（围绕Y轴的角度）、beta（围绕X轴的角度）和半径的适当值。然后，`.position`属性仅用于读取。
- en: Adding a light
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加灯光
- en: Once you create your camera, let's add a light. The different lights allow you
    to perform lighting in your scene with different features. The point lights and
    hemispheric lights tend to illuminate the objects in the scene, while the spot
    lights and directional lights also provide support for the real-time shadows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的相机，让我们添加一个灯光。不同的灯光允许你在场景中使用不同的功能进行照明。点光源和半球光源倾向于照亮场景中的对象，而聚光灯和方向光源也提供了实时阴影的支持。
- en: 'Let''s start with a point light. Lights work like cameras, which means that
    you have to provide the scene reference (where to add the light):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从点光源开始。灯光的工作方式类似于相机，这意味着你必须提供场景引用（在哪里添加灯光）：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second parameter is the light position. `BABYLON.Vector3.Zero()` is a static
    method that is a shortcut to create a `Vector3` instance with coordinates (`x=0`,`y=0`,`z=0`).
    Now, let''s play with the light''s parameters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是灯光的位置。`BABYLON.Vector3.Zero()`是一个静态方法，它是创建一个坐标为(`x=0`,`y=0`,`z=0`)的`Vector3`实例的快捷方式。现在，让我们玩一下灯光的参数：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the parameters of the preceding code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的参数说明：
- en: The`.diffuse` parameter represents the native color of the light, which is green
    in the example
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.diffuse`参数表示光的固有颜色，在示例中是绿色。'
- en: The`.specular` parameter represents the light color reflected by a surface,
    which is red here
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.specular` 参数表示表面反射的光的颜色，这里为红色'
- en: The`.intensity` parameter is the light's intensity that is equal to 1.0 by default
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.intensity` 参数是灯光的强度，默认值为 1.0'
- en: 'The following is the result of these parameters applied to a 3D object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下参数应用于 3D 对象的结果如下：
- en: '![Adding a light](img/image_02_002.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![添加灯光](img/image_02_002.png)'
- en: 'The following is achieved by modifying the specular color to red and blue:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改反射颜色为红色和蓝色，以下效果得以实现：
- en: '![Adding a light](img/image_02_003.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![添加灯光](img/image_02_003.png)'
- en: Adding a mesh
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加网格
- en: 'What are meshes? In fact, 3D objects are what we call meshes. Their structure
    is pretty simple as they have two important buffers in memory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网格是什么？实际上，3D 对象就是我们所说的网格。它们的结构相当简单，因为它们在内存中有两个重要的缓冲区：
- en: 'The vertex buffer is an array of 3D points: the vertices. The vertices represent
    the 3D points needed to build geometrical forms such as cubes, spheres, characters,
    weapons, and so on. For example, a cube has eight vertices.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点缓冲区是一个 3D 点的数组：顶点。顶点表示构建几何形状（如立方体、球体、角色、武器等）所需的 3D 点。例如，一个立方体有八个顶点。
- en: The index buffer, which is an array of numbers, represents the indices in the
    vertex buffer to build triangles. Indeed, graphic cards are optimized to calculate
    and render triangles on the screen. For example, a face of a cube will be rendered
    using two triangles, as shown in the following image, where the green lines show
    the face:![Adding a mesh](img/image_02_004.png)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引缓冲区是一个数字数组，表示顶点缓冲区中的索引，用于构建三角形。实际上，图形卡被优化来计算和渲染屏幕上的三角形。例如，一个立方体的面将使用两个三角形来渲染，如下面的图像所示，其中绿色线条显示了面：![添加网格](img/image_02_004.png)
- en: 'The job of graphic cards is separated into two steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图形卡的工作分为两个步骤：
- en: They project (transformation) the vertices (3D points) of the vertex buffer
    on the screen. These operations are performed by a GPU program named vertex shader.
    In other words, the vertex shader computes the 2D position of each triangle.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将顶点缓冲区的顶点（3D 点）投影（变换）到屏幕上。这些操作由一个名为顶点着色器的 GPU 程序执行。换句话说，顶点着色器计算每个三角形的 2D 位置。
- en: They fill the pixels associated with the triangles with their colors using a
    GPU program named pixel shader.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使用一个名为像素着色器的 GPU 程序用颜色填充与三角形相关的像素。
- en: To conclude the graphic cards' job, the vertex shader computes the 2D triangles
    on the screen and the pixel shader illuminates the pixels with different colors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结图形卡的工作，顶点着色器计算屏幕上的 2D 三角形，像素着色器用不同的颜色照亮像素。
- en: Using Babylon.js to create meshes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Babylon.js 创建网格
- en: 'Babylon.js provides you with static methods in the `BABYLON.Mesh` class that
    allow you to create basic meshes such as boxes, spheres, and torus. Every created
    mesh is an instance of `BABYLON.Mesh`. Let''s start with a box:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 在 `BABYLON.Mesh` 类中提供了静态方法，允许您创建基本网格，如盒子、球体和环面。每个创建的网格都是 `BABYLON.Mesh`
    的一个实例。让我们从一个盒子开始：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `size` parameter represents the distance between the vertices (for example,
    5) and the `scene` parameter is the scene reference (where to add the mesh). Once
    you get the mesh created, you can access its properties and methods as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 参数表示顶点之间的距离（例如，5）和 `scene` 参数是场景引用（在哪里添加网格）。一旦创建了网格，您就可以像以下这样访问其属性和方法：'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `.rotation` parameter represents the mesh's rotation expressed in radians `[0,
    2π]`, and then, in degrees, `π = 180 degrees` and `2π = 360 degrees`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`.rotation` 参数表示网格的旋转，以弧度表示 `[0, 2π]`，然后以度数表示，`π = 180 度` 和 `2π = 360 度`。'
- en: The `.scaling` parameter represents the mesh's scale in three directions (*x*,*y*,*z*).
    In the example, the mesh is two times bigger.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`.scaling` 参数表示网格在三个方向上的缩放（*x*、*y*、*z*）。在示例中，网格是原来的两倍大。'
- en: 'Let''s see the result if you modify its rotation only:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只修改其旋转，看看结果会怎样：
- en: '![Using Babylon.js to create meshes](img/image_02_005.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Babylon.js 创建网格](img/image_02_005.png)'
- en: 'The following image is the result of applying a new scale, (`x=2`,`y=2`,`z=2`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是应用新的缩放（`x=2`、`y=2`、`z=2`）的结果：
- en: '![Using Babylon.js to create meshes](img/image_02_006.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Babylon.js 创建网格](img/image_02_006.png)'
- en: Some other basic meshes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些其他的基本网格
- en: 'There exist multiple basic meshes that `BABYLON.Mesh` can create for you, such
    as spheres and planes. Let''s create a sphere and plane using the `BABYLON.Mesh`
    class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多个基本网格，`BABYLON.Mesh` 可以为您创建，例如球体和平面。让我们使用 `BABYLON.Mesh` 类创建一个球体和平面：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The sphere's `segments` parameter represents the level of detail for the sphere,
    for example, 10.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 球体的 `segments` 参数表示球体的细节级别，例如，10。
- en: The plane's `size` parameter represents the distance between vertices, for example,
    10.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 平面的 `size` 参数表示顶点之间的距离，例如，10。
- en: Managing a scene graph
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理场景图
- en: The scene can be managed using a graph of nodes named scene graph. In Babylon.js,
    each mesh, light, and camera extends the `BABYLON.Node` class. In other words,
    each `BABYLON.Node` is in the scene graph.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 场景可以通过名为场景图的节点图来管理。在Babylon.js中，每个网格、灯光和摄像机都扩展了 `BABYLON.Node` 类。换句话说，每个 `BABYLON.Node`
    都在场景图中。
- en: Each node has an array of children and one, and only one, parent. Each created
    node is a child of the graph's root by default.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都有一个子节点数组和唯一的一个父节点。每个创建的节点默认是图根的子节点。
- en: 'To modify the parent of a node, just modify the node''s reference:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改节点的父节点，只需修改节点的引用：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, because the light is a child of the camera, the light's position depends
    on the camera's position. Indeed, the light space is a subspace of the camera.
    In other words, you can see the position (`x=0`,`y=0`,`z=0`) as the position of
    the camera.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为灯光是摄像机的子节点，所以灯光的位置取决于摄像机的位置。确实，灯光空间是摄像机的一个子空间。换句话说，你可以将位置（`x=0`,`y=0`,`z=0`）视为摄像机的位置。
- en: When setting a parent, the transformation properties (position, rotation, and
    scaling) of the children are influenced by the parent.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置父节点时，子节点的变换属性（位置、旋转和缩放）会受到父节点的影响。
- en: An example
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Let''s manage the scene graph with two nodes (`node1` and `node2`) and compare
    it with the equivalent code if you were to do it manually:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用两个节点（`node1` 和 `node2`）来管理场景图，并比较如果你手动操作时等效的代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is equivalent to the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下代码等效：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following schema explains the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构解释了前面的代码：
- en: '![An example](img/image_02_007.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/image_02_007.png)'
- en: Creating your first scene
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个场景
- en: Now, you have all the necessary elements to build your first scene. Here, the
    scene will be composed of a rotation camera, point light, and box. Let's create
    a class using TypeScript and practice with Babylon.js.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了构建第一个场景所需的所有必要元素。在这里，场景将由旋转摄像机、点光源和盒子组成。让我们使用TypeScript创建一个类并使用Babylon.js进行练习。
- en: Creating a class and the scene nodes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类和场景节点
- en: 'The following class creates the Babylon.js elements directly in the constructor:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类在构造函数中直接创建Babylon.js元素：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Call the runRenderLoop method
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用 runRenderLoop 方法
- en: 'Let''s add a method to the class that will call the `runRenderLoop` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在类中添加一个方法来调用 `runRenderLoop` 方法：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This scene is exactly the same as mentioned in the previous image—there is a
    box and green light.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景与之前提到的图像完全相同——有一个盒子和绿色的灯光。
- en: Managing the scene graph
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理场景图
- en: 'To practice with the scene graph, let''s create a method that will set the
    light as a child of the camera. The method will set the light''s position at coordinates
    (`x=0`,`y=0`,`z=0`) and set the parent of the light as the camera:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习场景图，让我们创建一个方法，该方法将灯光设置为摄像机的子节点。该方法将灯光的位置设置为坐标（`x=0`,`y=0`,`z=0`）并将灯光的父节点设置为摄像机：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a minimal HTML page to handle a Babylon.js
    engine and draw a scene. You also learned how to use Babylon.js' built-in nodes
    such as lights, cameras, and meshes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建一个最小的HTML页面来处理Babylon.js引擎并绘制场景。你还学习了如何使用Babylon.js的内置节点，如灯光、摄像机和网格。
- en: Don't hesitate to practice with the built-in meshes such as torus, torus-knots,
    and spheres and play with the scene graph and node's properties such as position.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要犹豫，使用内置网格如环面、环面结和球体进行练习，并玩转场景图和节点的属性，如位置。
- en: In the next chapter, you'll learn how scenes are built with designers and how
    they are imported using Babylon.js. You'll also see that interfacing 3D software
    to create scenes with Babylon.js is pretty easy as all the tools are provided
    by the Babylon.js solution (such as exporters and importers).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习场景是如何由设计师构建的，以及它们是如何使用Babylon.js导入的。你还将看到，使用Babylon.js创建场景与3D软件接口相当简单，因为所有工具都由Babylon.js解决方案提供（如导出器和导入器）。
- en: The next chapter will also explain how artists work to create 3D scenes for
    the web as their problems are different from desktop software such as games for
    consoles and PCs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章也将解释艺术家如何创建用于网络的3D场景，因为他们的问题与控制台和PC游戏等桌面软件不同。
