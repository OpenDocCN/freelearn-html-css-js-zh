- en: Chapter 2. The Fundamentals of Babylon.js and Available Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents the fundamentals of Babylon.js. It includes the notions
    of *engine*, *scene*, *camera*, *light*, *mesh*, and so on. By practicing, you'll
    understand the basic tools used in 3D such as vectors and how/where they are used
    in 3D engines. You'll also practice with graph structures and understand the architecture
    of Babylon.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Discussing the Babylon.js structure and graphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Babylon.js structure and graphs
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's create and explain the necessary tools to draw things on the screen,
    such as an engine that will handle a scene to draw a 3D object and use a camera
    and light.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The engine and a scene
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The engine is the core of Babylon.js and a scene allows you to create and manage
    entities that you''ll draw on the screen (objects, lights, cameras, and so on),
    thanks to an engine. You can see the engine like a gateway to communicate with
    the video card (GPU) while a scene is a high-level interface that handles the
    following multiple entities:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 3D objects (more on this in [Chapter 3](ch03.html "Chapter 3. Create, Load,
    and Draw 3D Objects on the Screen"), *Create, Load, and Draw 3D Objects on the
    Screen*)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cameras
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lights
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle systems (smoke, rain, and others)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skeletons (animated 3D objects)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-processes (effects)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Materials (more on this in [Chapter 4](ch04.html "Chapter 4. Using Materials
    to Customize 3D Objects Appearance"), *Using Materials to Customize 3D Objects
    Appearance*)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprites
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, a scene handles multiple entities and will call the engine to
    draw these entities on the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: To draw on the screen, the web page (`index.html`) must contain a canvas. The
    canvas is used to create the WebGL context that the engine will use. The only
    parameter needed to create an engine is the canvas and the only parameter needed
    to create a scene is an engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The canvas in the web page is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following code is performed to render on the entire page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create an engine, you have to give the canvas reference as a parameter.
    Get the reference of the DOM object as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create an engine by passing the canvas reference:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a scene as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each new scene created is stored in `engine.scenes`, which is an array of `BABYLON.Scene`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create a scene, you can render every frame (60 frames per second in
    a perfect case and less if your hardware isn''t sufficient). To perform this action,
    you have to call the `engine.runRunderLoop(function)` function. The anonymous
    function `function` is called every frame and this is the place to draw the scene:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `scene.render()` function is called to draw every object on the screen during
    the frame.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Adding cameras and lights
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you create a scene, you can create objects such as lights and cameras.
    The minimal scene requirement is composed of a camera (needed to get a view in
    the scene) and light (that illuminates the 3D objects in the scene, but this is
    not required if objects in the scene are self-illuminated).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several types of cameras and lights. The Babylon.js framework provides
    you with a fixed camera (no movements), FPS camera, rotation camera (turns around
    a point), gamepad camera (XBOX 360 gamepad), and touch camera (for touch devices).
    All these cameras can be created in the scene with a minimum number of lines of
    code. For example, let''s start with a free camera (FPS) with its position at
    coordinates (`x=10`,`y=20`,`z=30`). This is the occasion to introduce the `BABYLON.Vector3`
    class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The constructor needs a name (`cameraName`), position for the camera, and scene
    reference (where to add the camera). The position is in the `BABYLON.Vector3(x,
    y, z)` type, which is the 3D vector class of Babylon.js. The `Vector3` object
    provides mathematical functions such as addition, subtraction, multiplication,
    division, and more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create the camera, let''s change the camera''s position and perform
    a `Vector3` addition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `.addInPlace` method modifies the current instance of `Vector3`, but you
    can also call the `.add` method that will return a new instance of `Vector3` with
    the addition applied.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The new position of the camera is now (`x=10`,`y=10`,`z=10`). Modifying the
    `.position` property does not work for all the cameras, especially the rotation
    camera (`BABYLON.ArcRotateCamera`). The rotation camera turns around a point (which
    is the target of the camera) and can be explained as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a camera](img/image_02_001-1024x768.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: The cube is at the position (`x=0`,`y=0`,`z=0`) and is the target of the camera.
    To change the camera's position, you have to call the `camera.setPosition(position)`
    function. This function will calculate the appropriate values for the alpha (angle
    around Y), beta (angle around X), and radius. Then, the .`position` property is
    only left to read.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Adding a light
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you create your camera, let's add a light. The different lights allow you
    to perform lighting in your scene with different features. The point lights and
    hemispheric lights tend to illuminate the objects in the scene, while the spot
    lights and directional lights also provide support for the real-time shadows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a point light. Lights work like cameras, which means that
    you have to provide the scene reference (where to add the light):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second parameter is the light position. `BABYLON.Vector3.Zero()` is a static
    method that is a shortcut to create a `Vector3` instance with coordinates (`x=0`,`y=0`,`z=0`).
    Now, let''s play with the light''s parameters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the parameters of the preceding code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The`.diffuse` parameter represents the native color of the light, which is green
    in the example
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The`.specular` parameter represents the light color reflected by a surface,
    which is red here
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The`.intensity` parameter is the light's intensity that is equal to 1.0 by default
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the result of these parameters applied to a 3D object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a light](img/image_02_002.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'The following is achieved by modifying the specular color to red and blue:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a light](img/image_02_003.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Adding a mesh
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What are meshes? In fact, 3D objects are what we call meshes. Their structure
    is pretty simple as they have two important buffers in memory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex buffer is an array of 3D points: the vertices. The vertices represent
    the 3D points needed to build geometrical forms such as cubes, spheres, characters,
    weapons, and so on. For example, a cube has eight vertices.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index buffer, which is an array of numbers, represents the indices in the
    vertex buffer to build triangles. Indeed, graphic cards are optimized to calculate
    and render triangles on the screen. For example, a face of a cube will be rendered
    using two triangles, as shown in the following image, where the green lines show
    the face:![Adding a mesh](img/image_02_004.png)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The job of graphic cards is separated into two steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: They project (transformation) the vertices (3D points) of the vertex buffer
    on the screen. These operations are performed by a GPU program named vertex shader.
    In other words, the vertex shader computes the 2D position of each triangle.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They fill the pixels associated with the triangles with their colors using a
    GPU program named pixel shader.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To conclude the graphic cards' job, the vertex shader computes the 2D triangles
    on the screen and the pixel shader illuminates the pixels with different colors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Using Babylon.js to create meshes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Babylon.js provides you with static methods in the `BABYLON.Mesh` class that
    allow you to create basic meshes such as boxes, spheres, and torus. Every created
    mesh is an instance of `BABYLON.Mesh`. Let''s start with a box:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `size` parameter represents the distance between the vertices (for example,
    5) and the `scene` parameter is the scene reference (where to add the mesh). Once
    you get the mesh created, you can access its properties and methods as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `.rotation` parameter represents the mesh's rotation expressed in radians `[0,
    2π]`, and then, in degrees, `π = 180 degrees` and `2π = 360 degrees`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The `.scaling` parameter represents the mesh's scale in three directions (*x*,*y*,*z*).
    In the example, the mesh is two times bigger.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the result if you modify its rotation only:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Babylon.js to create meshes](img/image_02_005.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'The following image is the result of applying a new scale, (`x=2`,`y=2`,`z=2`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Babylon.js to create meshes](img/image_02_006.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Some other basic meshes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There exist multiple basic meshes that `BABYLON.Mesh` can create for you, such
    as spheres and planes. Let''s create a sphere and plane using the `BABYLON.Mesh`
    class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The sphere's `segments` parameter represents the level of detail for the sphere,
    for example, 10.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 球体的 `segments` 参数表示球体的细节级别，例如，10。
- en: The plane's `size` parameter represents the distance between vertices, for example,
    10.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 平面的 `size` 参数表示顶点之间的距离，例如，10。
- en: Managing a scene graph
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理场景图
- en: The scene can be managed using a graph of nodes named scene graph. In Babylon.js,
    each mesh, light, and camera extends the `BABYLON.Node` class. In other words,
    each `BABYLON.Node` is in the scene graph.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 场景可以通过名为场景图的节点图来管理。在Babylon.js中，每个网格、灯光和摄像机都扩展了 `BABYLON.Node` 类。换句话说，每个 `BABYLON.Node`
    都在场景图中。
- en: Each node has an array of children and one, and only one, parent. Each created
    node is a child of the graph's root by default.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都有一个子节点数组和唯一的一个父节点。每个创建的节点默认是图根的子节点。
- en: 'To modify the parent of a node, just modify the node''s reference:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改节点的父节点，只需修改节点的引用：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, because the light is a child of the camera, the light's position depends
    on the camera's position. Indeed, the light space is a subspace of the camera.
    In other words, you can see the position (`x=0`,`y=0`,`z=0`) as the position of
    the camera.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为灯光是摄像机的子节点，所以灯光的位置取决于摄像机的位置。确实，灯光空间是摄像机的一个子空间。换句话说，你可以将位置（`x=0`,`y=0`,`z=0`）视为摄像机的位置。
- en: When setting a parent, the transformation properties (position, rotation, and
    scaling) of the children are influenced by the parent.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置父节点时，子节点的变换属性（位置、旋转和缩放）会受到父节点的影响。
- en: An example
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: 'Let''s manage the scene graph with two nodes (`node1` and `node2`) and compare
    it with the equivalent code if you were to do it manually:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用两个节点（`node1` 和 `node2`）来管理场景图，并比较如果你手动操作时等效的代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is equivalent to the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下代码等效：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following schema explains the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构解释了前面的代码：
- en: '![An example](img/image_02_007.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/image_02_007.png)'
- en: Creating your first scene
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个场景
- en: Now, you have all the necessary elements to build your first scene. Here, the
    scene will be composed of a rotation camera, point light, and box. Let's create
    a class using TypeScript and practice with Babylon.js.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了构建第一个场景所需的所有必要元素。在这里，场景将由旋转摄像机、点光源和盒子组成。让我们使用TypeScript创建一个类并使用Babylon.js进行练习。
- en: Creating a class and the scene nodes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类和场景节点
- en: 'The following class creates the Babylon.js elements directly in the constructor:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类在构造函数中直接创建Babylon.js元素：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Call the runRenderLoop method
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用 runRenderLoop 方法
- en: 'Let''s add a method to the class that will call the `runRenderLoop` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在类中添加一个方法来调用 `runRenderLoop` 方法：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This scene is exactly the same as mentioned in the previous image—there is a
    box and green light.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景与之前提到的图像完全相同——有一个盒子和绿色的灯光。
- en: Managing the scene graph
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理场景图
- en: 'To practice with the scene graph, let''s create a method that will set the
    light as a child of the camera. The method will set the light''s position at coordinates
    (`x=0`,`y=0`,`z=0`) and set the parent of the light as the camera:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习场景图，让我们创建一个方法，该方法将灯光设置为摄像机的子节点。该方法将灯光的位置设置为坐标（`x=0`,`y=0`,`z=0`）并将灯光的父节点设置为摄像机：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a minimal HTML page to handle a Babylon.js
    engine and draw a scene. You also learned how to use Babylon.js' built-in nodes
    such as lights, cameras, and meshes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建一个最小的HTML页面来处理Babylon.js引擎并绘制场景。你还学习了如何使用Babylon.js的内置节点，如灯光、摄像机和网格。
- en: Don't hesitate to practice with the built-in meshes such as torus, torus-knots,
    and spheres and play with the scene graph and node's properties such as position.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要犹豫，使用内置网格如环面、环面结和球体进行练习，并玩转场景图和节点的属性，如位置。
- en: In the next chapter, you'll learn how scenes are built with designers and how
    they are imported using Babylon.js. You'll also see that interfacing 3D software
    to create scenes with Babylon.js is pretty easy as all the tools are provided
    by the Babylon.js solution (such as exporters and importers).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习场景是如何由设计师构建的，以及它们是如何使用Babylon.js导入的。你还将看到，使用Babylon.js创建场景与3D软件接口相当简单，因为所有工具都由Babylon.js解决方案提供（如导出器和导入器）。
- en: The next chapter will also explain how artists work to create 3D scenes for
    the web as their problems are different from desktop software such as games for
    consoles and PCs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章也将解释艺术家如何创建用于网络的3D场景，因为他们的问题与控制台和PC游戏等桌面软件不同。
