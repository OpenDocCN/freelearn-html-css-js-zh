<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor163"/>11</h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor164"/>Renderless Components</h1>
<p>A renderless component is an advanced concept in Svelte that allows developers to create reusable components without rendering any HTML elements within the component itself.</p>
<p>This technique is particularly useful when leveraging Svelte to render on a canvas or in a 3D context, where the rendering of an HTML template by Svelte is not required. Instead, the canvas<a id="_idIndexMarker412"/> and <strong class="bold">Web Graphics Library</strong> (<strong class="bold">WebGL</strong>) offer an imperative API to produce graphics on the canvas. With the renderless component technique, it becomes possible to design components that enable users to describe the canvas declaratively, allowing the component to translate it into imperative instructions.</p>
<p>Another use case for a renderless component is to create components that only manage states and behaviors, leaving the parent component control over what should actually be rendered. This will come in handy when developing a component library and you want to make it easy for users to customize how your component looks and lets you have control over the state and behaviors.</p>
<p>In this chapter, we will utilize Svelte context to create our renderless component. If you are new to Svelte context, please refer to <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a>, where we explain its meaning.</p>
<p>Initially, we will explore the concept of renderless components and subsequently build techniques to create them. As we develop our renderless component, we will share a few examples of renderless components.</p>
<p>At the end of the chapter, you should possess the ability to employ the renderless component technique to convert imperative APIs into declarative components.</p>
<p>The topics discussed in this chapter are as follows:</p>
<ul>
<li>What are renderless components?</li>
<li>Building renderless components with Svelte context</li>
</ul>
<h1 id="_idParaDest-163"><a id="_idTextAnchor165"/>Technical requirements</h1>
<p>You can find the code used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11</a>.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor166"/>What are renderless components?</h1>
<p>A<a id="_idIndexMarker413"/> renderless component, as its name implies, is a type of component that does not render any HTML elements of its own.</p>
<p>You might wonder, what’s the purpose of a component that doesn’t render anything?</p>
<p>Well, despite not rendering HTML, there are still several useful things that a component can do, including <a id="_idIndexMarker414"/>the following:</p>
<ul>
<li><strong class="bold">Accepting props, processing their values, and triggering side effects as their values change</strong>: Even though the prop values are not used directly in the template, they are still reactive. You can write reactive statements with props in the component and have them run whenever the prop values change. You can see this in the following example code snippet:<pre class="source-code">
&lt;script&gt;
  export let title;
  export let description;
  $: document.title = `${title} - ${description}`;
&lt;/script&gt;</pre><p class="list-inset">Even though the <code>title</code> and <code>description</code> props are not used in the template, both <code>title</code> and <code>description</code> are used in a reactive statement. Whenever the <code>title</code> or <code>description</code> props change, the reactive statement in line 4 will rerun and update the title of the document.</p><p class="list-inset">Setting the document title, updating the cookie value, and modifying context are good examples of side effects.</p></li> <li><code>onMount</code> and <code>onDestroy</code>, still run even if no elements are mounted and destroyed in the component.</li>
<li><code>&lt;slot&gt;</code><code>&lt;slot&gt;</code> element that allows the user of the component to pass in child elements or components.<p class="list-inset">For example, in<a id="_idIndexMarker415"/> the following <code>Parent</code> component, we render a <code>default</code> slot:</p><pre class="source-code">
&lt;!-- Parent.svelte --&gt;
&lt;slot /&gt;</pre><p class="list-inset">Then, the user of the <code>Parent</code> component can pass in child elements or components under the <code>Parent</code> component:</p><pre class="source-code">&lt;script&gt;
  import Parent from './Parent.svelte';
&lt;/script&gt;
&lt;Parent&gt;
  &lt;Child /&gt; &lt;!-- example of child components --&gt;
  &lt;div /&gt; &lt;!-- example of child elements --&gt;
&lt;/Parent&gt;</pre><p class="list-inset">The <code>Parent</code> component can pass data to the child components or elements through two avenues – setting context data and setting slot props.</p><p class="list-inset">You can read more about setting slot props in <a href="B18887_04.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>.</p></li> <li><code>getContext()</code> to retrieve the context value set by its parent component. Depending on the type of context value provided by the parent, we can use the context value to communicate <a id="_idIndexMarker416"/>with the parent or inform it about the existence of the child component.<p class="list-inset">In the <em class="italic">Writing declarative canvas components</em> section later in the chapter, you will see an example of such a technique.</p></li>
</ul>
<p>Throughout the upcoming sections, we will challenge ourselves by creating components that perform only the operations listed in the preceding list, without rendering any HTML elements.</p>
<p>In this chapter, we will explore two use cases for renderless components, which are turning reusable renderless components and declarative descriptions into imperative instructions. Let’s take an in-depth look at them.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor167"/>Exploring reusable renderless components</h1>
<p>The first use <a id="_idIndexMarker417"/>case for renderless components involves creating components that solely focus on the logic of the component. These components are not your typical ones, such as buttons or text inputs. Instead, think of components with slightly complex logic, such as carousels, tabs, or drop-down menus. Although the logic of a carousel component is relatively standard, its appearance can vary significantly based on where and how it is used.</p>
<p>So, how can we create a reusable carousel component that can look different based on where it is used?</p>
<p>One solution is to create a carousel component that only contains the carousel logic, without any specific styling or HTML structure. Then, the consumer of the component can decide how the carousel should look by passing in their own styling and HTML structure. This allows for greater flexibility and customization, making the component more versatile and reusable in different contexts.</p>
<p>For example, the carousel component could accept props such as <code>items</code>, which would determine the list of items in the carousel. The carousel component could render a <code>slot</code> element that takes in slot props such as <code>currentIndex</code> and <code>setIndex</code>, which would be the index of the currently active item and the function to set the index. This allows the carousel component to manage the carousel item cycling logic, while leaving the consumer of the carousel component to determine the actual carousel styling and structure.</p>
<p>By separating<a id="_idIndexMarker418"/> the carousel logic from the specific styling and structure, we can create a more modular and reusable component that can be used in various contexts, without having to rewrite the same logic over and over again. This is the power of renderless components – they allow us to create components that focus solely on their core functionality, without being tied to any specific rendering or styling requirements.</p>
<p>Of course, before we proceed, it’s essential to clarify when not to use a renderless component to create a carousel. If you require a fully functional carousel component, including the design and style, a renderless component may not be suitable for your needs, as its main purpose is to handle the logic and behavior of the carousel without dictating its appearance.</p>
<p>Ultimately, the decision to create a renderless component for a carousel depends on your specific needs and goals. Consider your project requirements and design preferences before deciding on the best approach.</p>
<p>In the next section, I will show you step by step how we can build a renderless carousel component.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor168"/>Example – building a renderless carousel component</h2>
<p>A <a id="_idIndexMarker419"/>carousel component is a UI <a id="_idIndexMarker420"/>component that displays a set of items in a loop. It allows users to view a collection of items in a slideshow-like format. A carousel component is usually found on websites such as e-commerce platforms, news portals, and social media platforms.</p>
<div><div><img alt="Figure 11.1: An example of a carousel component" height="308" src="img/B18887_11_01.jpg" width="803"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: An example of a carousel component</p>
<p>We will <a id="_idIndexMarker421"/>create a renderless<a id="_idIndexMarker422"/> carousel component that accepts a list of items through props named <code>items</code>. The carousel component will render a <code>slot</code> element to allow customization of its appearance.</p>
<p>The <code>slot</code> element will take in a few slot props:</p>
<ul>
<li><code>currentIndex</code>: This represents the index of the currently displayed item in the carousel.</li>
<li><code>currentItem</code>: This represents the currently displayed item in the carousel.</li>
<li><code>setCurrentIndex</code>: This is a function that can be used to update the current index of the carousel. It can be used to implement custom navigation controls.</li>
<li><code>next</code> and <code>prev</code>: These <code>slot</code> props are functions that can be used to navigate to the next or previous item in the carousel. They can be used to implement custom navigation controls or respond to user input, such as clicks or swipes.</li>
</ul>
<p>These <code>slot</code> props allow the consumer to decide how to use them to build their own carousel UI.</p>
<p>To determine the appropriate <code>slot</code> props for the carousel component, we consider the essential states and functions required for users to build their own carousel UI. In this case, the key states are <code>currentIndex</code> and <code>currentItem</code>, while the necessary functions to interact with the carousel UI include <code>setCurrentIndex</code>, <code>next</code>, and <code>prev</code>, which are helpful to implement custom navigation controls.</p>
<p>An example<a id="_idIndexMarker423"/> of a carousel UI is one that displays the current item and has buttons to navigate forward and backward through the carousel:</p>
<pre class="source-code">
&lt;Carousel {items} let:currentItem let:next let:prev&gt;
  &lt;button on:click={prev}&gt;{'&lt;'}&lt;/button&gt;
  &lt;img src={currentItem} /&gt;
  &lt;button on:click={next}&gt;{'&gt;'}&lt;/button&gt;
&lt;/Carousel&gt;</pre> <p>In the preceding code snippet, we use the <code>currentItem</code>, <code>next</code>, and <code>prev</code> slot props to build a simple carousel UI. We decide how to use the <code>slot</code> props and control the structure and styling of the HTML elements.</p>
<p>Another example of a <a id="_idIndexMarker424"/>carousel UI is displaying a list of item numbers at the bottom of it, enabling the user to quickly jump to a selected item by clicking on its number:</p>
<pre class="source-code">
&lt;Carousel {items} let:currentItem let:setCurrentIndex&gt;
  &lt;img src={currentItem} /&gt;
  {#each items as _, index}
    &lt;button on:click={() =&gt; setCurrentIndex(index)}&gt;
      {index}
    &lt;/button&gt;
  {/each}
&lt;/Carousel&gt;</pre> <p>In the preceding code, I used Svelte’s <code>{#each}</code> block to create a list of buttons, labeled with a different index number. Each of the buttons has a click event listener that sets the current index of the carousel to the index number of the button. When you click on the button, the carousel will jump to the item at the index that is specified by the button.</p>
<p>The second<a id="_idIndexMarker425"/> carousel UI is different from the first carousel UI, and you can create and style a totally different carousel UI. You can see that the appearance of the carousel UI is entirely up to the user. The renderless carousel component focuses on the carousel logic and allows the user to decide on the UI structure and styling.</p>
<p>Without further ado, let’s explore how to write the carousel component.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor169"/>Writing a renderless carousel component</h2>
<p>In the <a id="_idIndexMarker426"/>previous section, we decided on the props of our <code>Carousel</code> component, <code>items</code>, and decided that it should have a default <code>&lt;slot&gt;</code>.</p>
<p>Based on this information, let’s create the structure of our <code>Carousel</code> component:</p>
<pre class="source-code">
&lt;script&gt;
  export let items;
&lt;/script&gt;
&lt;slot&gt;</pre> <p>In the preceding code snippet, the <code>&lt;slot&gt;</code> element will be the only element we will have in our <code>Carousel</code> component. This <code>&lt;slot&gt;</code> element is needed; otherwise, the child elements inside the <code>&lt;Carousel&gt;</code> component, indicated in the following code snippet, will be ignored and discarded if there’s no <code>&lt;slot&gt;</code> element in the <code>Carousel</code> component:</p>
<pre class="source-code">
&lt;Carousel&gt;
  <strong class="bold">&lt;!-- content over here will be ignored if the Carousel don't have a &lt;slot&gt; element --&gt;</strong>
&lt;/Carousel&gt;</pre> <p>In the <code>&lt;slot&gt;</code> element, we define the following <code>slot</code> props – <code>currentIndex</code>, <code>currentItem</code>, <code>setCurrentIndex</code>, <code>prev</code>, and <code>next</code>:</p>
<pre class="source-code">
&lt;slot {currentIndex} {currentItem} {setCurrentIndex} {prev} {next} /&gt;</pre> <p>However, these<a id="_idIndexMarker427"/> <code>slot</code> props are not defined in our <code>Carousel</code> component yet, so let’s define them.</p>
<p>We initialize <code>currentIndex</code> to <code>0</code> at the start of the component:</p>
<pre class="source-code">
let currentIndex = 0;</pre> <p><code>setCurrentIndex</code> is used to update <code>currentIndex</code> to the value being passed in:</p>
<pre class="source-code">
const setCurrentIndex = (value) =&gt; { currentIndex = value; };</pre> <p><code>currentItem</code> will be the item in the <code>items</code> array at the index position of <code>currentIndex</code>. Here, I’ll use the reactive statements so that we will have a new <code>currentItem</code> slot prop whenever the <code>items</code> array or <code>currentIndex</code> changes:</p>
<pre class="source-code">
$: currentItem = items[currentIndex];</pre> <p>Finally, the <code>prev</code> and <code>next</code> functions will be used to set <code>currentIndex</code>, based on its current value:</p>
<pre class="source-code">
const prev = () =&gt; setCurrentIndex((currentIndex - 1 + items.length) % items.length);
const next = () =&gt; setCurrentIndex((currentIndex + 1) % items.length);</pre> <p>In the preceding snippet, I used <code>% items.length</code> so that the index is always within the bounds of the length of the <code>items</code> array. This way, we ensure that the carousel can loop back to the beginning of the <code>items</code> array after reaching the end, creating a seamless looping effect for the user.</p>
<p>And that’s it. If you add all the preceding code snippets to the <code>Carousel</code> component, you’ll have a working renderless component. The full code is available on GitHub at<a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel</a> as well.</p>
<p>Creating a renderless component is not hard; it doesn’t take us much time to create a renderless <code>Carousel</code> component. The key here is to figure out the props for our renderless component, then figure out the <code>slot</code> props needed, and finally, create a default <code>&lt;slot&gt;</code> element <a id="_idIndexMarker428"/>with the <code>slot</code> props.</p>
<p>Before we move on, let’s have an exercise to create a reusable renderless component yourself.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor170"/>Exercise 1 – a renderless autocomplete component</h2>
<p>An <a id="_idIndexMarker429"/>autocomplete component is an input with an auto-suggest dropdown that shows a list of matching options as a user types in the input. It helps users quickly and easily find and select an option from a large set of choices. autocomplete components are commonly used in search bars, forms, and other areas where users need to enter data quickly and accurately.</p>
<p>In this exercise, we’ll create a renderless autocomplete component.</p>
<p>The autocomplete component will take in only one prop, a <code>search</code> function, which takes in a search value <a id="_idIndexMarker430"/>and returns <code>Promise</code>, which resolves to an array of string results.</p>
<p>What about the slot props that our renderless <code>Autocomplete</code> component would provide?</p>
<p>We need three states for our autocomplete component:</p>
<ul>
<li><code>value</code>: To represent the current value in the input box</li>
<li><code>searching</code>: A Boolean value to represent whether the autocomplete currently searches for results</li>
<li><code>suggestions</code>: An array of autocomplete results returned from the <code>search</code> function</li>
</ul>
<p>For a user to interact with the <code>Autocomplete</code> component, we need two functions:</p>
<ul>
<li><code>setValue</code>: To update the value of the input box</li>
<li><code>selectSuggestion</code>: To select the suggestion and apply it to the input box</li>
</ul>
<p>So, the preceding three states and two functions will be the <code>slot</code> props for our <code>Autocomplete</code> component.</p>
<p>Here is an example of how<a id="_idIndexMarker431"/> the <code>Autocomplete</code> component could be used:</p>
<pre class="source-code">
&lt;Autocomplete {search} let:value let:setValue let:searching let:suggestions let:selectSuggestion&gt;
  &lt;input {value} on:input={event =&gt; setValue(event.currentTarget.value)}&gt;
  {#if searching}Searching...{/if}
  {#if suggestions}
    &lt;ul&gt;
      {#each suggestions as suggestion}
        &lt;li on:click={() =&gt; selectSuggestion(suggestion)}&gt;{suggestion}&lt;/li&gt;
      {/each}
    &lt;/ul&gt;
  {/if}
&lt;/Autocomplete&gt;</pre> <p>In the<a id="_idIndexMarker432"/> preceding code snippet, we use the <code>Autocomplete</code> component to render an autocomplete textbox, with an <code>&lt;input&gt;</code> element and an <code>&lt;ul&gt;</code> element in the default slot.</p>
<p>The <code>&lt;input&gt;</code> element uses the <code>value</code> and <code>setValue</code> slot props to access and modify <code>value</code>, held by the <code>Autocomplete</code> component.</p>
<p>The <code>&lt;ul&gt;</code> element uses the <code>suggestions</code> slot prop to showcase the list of suggestions provided by the <code>Autocomplete</code> component and the <code>selectSuggestion</code> slot props are used in the <code>click</code> event handler of the <code>&lt;li&gt;</code> element to select the chosen suggestion and apply it to the textbox.</p>
<p>A sample solution can be found at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete</a>.</p>
<p>Now, let us look at the second use case for a renderless component.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor171"/>Turning a declarative description into imperative instructions</h1>
<p>The second <a id="_idIndexMarker433"/>use case for a renderless component involves allowing users to describe their needs declaratively and then translating them into imperative instructions.</p>
<p>A good example of this use case is when working with a canvas or WebGL.</p>
<p>For example, in a canvas, to create a red rectangle with a green border, you would need to use imperative APIs to create and style the rectangle:</p>
<pre class="source-code">
ctx.fillStyle = 'red';
ctx.strokeStyle = 'green';
ctx.rect(10, 10, 100, 100);
ctx.stroke();
ctx.fill();</pre> <p>Step by step, we instruct the canvas context to set <code>fillStyle</code> and <code>strokeStyle</code> and then draw a rectangle, based on the fill color and stroke color set.</p>
<p>When interacting with the canvas in an imperative manner, the code focuses on how to do things rather than what to do. This can result in code that is difficult to read and maintain, with a lot of low-level details that can make it hard to see the bigger picture.</p>
<p>Conversely, if you write code declaratively, you describe what you want to happen, rather than how it should happen. This makes the code more expressive and easier to read, as well as more flexible and reusable.</p>
<p>Continuing with the example of the red rectangle, we can create a Svelte component that handles drawing the rectangle on the canvas. Instead of manually coding the instructions to draw the rectangle, we can simply describe how we want it to appear on the canvas through the component. The component then takes care of rendering the rectangle on the canvas for us.</p>
<p>Here’s an example of code that describes the same rectangle through a Svelte component:</p>
<pre class="source-code">
&lt;script&gt;
  let x = 10, y = 10, height = 100, width = 100;
&lt;/script&gt;
&lt;Canvas&gt;
  &lt;Rectangle
    fill="red" stroke="green"
    {x} {y} {height} {width}
  /&gt;
&lt;/Canvas&gt;</pre> <p>In the <a id="_idIndexMarker434"/>preceding code snippet, we see a <code>Rectangle</code> component nested within a <code>Canvas</code> component. The <code>Rectangle</code> component has its fill, stroke, <em class="italic">x</em> position, <em class="italic">y</em> position, width, and height specified.</p>
<p>The following diagram illustrates how<a id="_idIndexMarker435"/> the <code>Rectangle</code> component from the preceding code renders a red square with a green border.</p>
<div><div><img alt="Figure 11.2: A red square with a green border" height="80" src="img/B18887_11_02.jpg" width="245"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: A red square with a green border</p>
<p>Even though explicit instructions to draw on the canvas are nowhere to be seen in the code, we can visualize a rectangle being drawn on the canvas based on the <code>Rectangle</code> component. This rectangle, with a width and height of 100 px each, is positioned 10 px from the left and 10 px from the top, filled with a red color and a green border.</p>
<p>By creating <a id="_idIndexMarker436"/>a renderless component that handles the low-level canvas instructions, we can separate the logic of drawing the rectangle from the specifics of how it should be rendered. This allows for more flexibility in how the rectangle is displayed on the canvas, as well as easier maintenance of the code.</p>
<p>Furthermore, by allowing a user to describe their needs declaratively, we create a more intuitive and user-friendly interface to work with the canvas and other low-level technologies. This can lead to faster development times and a more enjoyable development experience.</p>
<p>Let me show you an example of how declaratively describing a canvas is much faster than instructing it imperatively. If I want to animate the size of the rectangle, rather than coding the animation manually using imperative APIs, I can simply animate the <code>height</code> and <code>width</code> variables' value, just like the following code snippet:</p>
<pre class="source-code">
&lt;script&gt;
  let x = 10, y = 10, height = 100, width = 100;
<strong class="bold">  setInterval(() =&gt; {</strong>
<strong class="bold">    height += 10;</strong>
<strong class="bold">    width += 10;</strong>
<strong class="bold">  }, 100);</strong>
&lt;/script&gt;
&lt;Canvas&gt;
  &lt;Rectangle
    fill="red" stroke="green"
    {x} {y} {height} {width}
  /&gt;
&lt;/Canvas&gt;</pre> <p>Although the use of <code>setInterval</code> may not be the best to create an animation, the preceding code snippet attempts to demonstrate how easy it is to change the height and width of the rectangle in the canvas.</p>
<p>In the preceding code snippet, we update <code>height</code> and <code>width</code> on every interval. We pass <code>height</code> and <code>width</code> into the <code>Rectangle</code> component. As you can see, the height and width of the rectangle on the canvas increases by 10 px every 100 ms.</p>
<p>Conversely, if <a id="_idIndexMarker437"/>we were to animate it imperatively, we would have to clear the canvas and redraw a rectangle with a new height and width on each interval. These implementation details are now abstracted away in the declarative component, making it easier to reason about the animation and modify it in the future.</p>
<p>Overall, using renderless components to handle low-level imperative tasks can greatly improve the readability, maintainability, and flexibility of our code, while also making it more accessible and user-friendly.</p>
<p>So, how do we implement the <code>Canvas</code> and the <code>Rectangle</code> component shown in the preceding code snippet? Let’s find out.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor172"/>Writing declarative Canvas components</h2>
<p>We’ll start<a id="_idIndexMarker438"/> with the <code>Canvas</code> component.</p>
<p>Similar to the <a id="_idIndexMarker439"/>component structure of the <code>Carousel</code> component in the<a id="_idIndexMarker440"/> previous section, the <code>Canvas</code> component will render a <code>&lt;slot&gt;</code> element to insert all the child components.</p>
<p>However, what’s different is that it will also render a <code>&lt;canvas&gt;</code> element, which is what we will interact with and draw on:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let canvas, ctx;
  onMount(() =&gt; {
    ctx = canvas.getContext('2d');
  });
&lt;/script&gt;
&lt;canvas bind:this={canvas} /&gt;
&lt;slot /&gt;</pre> <p>In the preceding code snippet, we bind the reference of the <code>&lt;canvas&gt;</code> element to the variable named <code>canvas</code>. After the <code>&lt;canvas&gt;</code> element is mounted onto the DOM, we get the drawing context of the <code>&lt;canvas&gt;</code> element and assign it to the variable named <code>ctx</code>.</p>
<p>If you recall the <a id="_idIndexMarker441"/>previous code example, we placed the <code>&lt;Rectangle&gt;</code> component inside the <code>&lt;Canvas&gt;</code> component to draw a rectangle onto the canvas. The <code>&lt;Rectangle&gt;</code> component does not receive any data or slot props from the <code>&lt;Canvas&gt;</code> component. So, how does the <code>&lt;Rectangle&gt;</code> component inform the <code>&lt;Canvas&gt;</code> component that it is a child of the <code>&lt;Canvas&gt;</code> component? How does the <code>&lt;Canvas&gt;</code> component communicate with the <code>&lt;Rectangle&gt;</code> component to know what to draw and how to draw on its <code>&lt;</code><code>canvas&gt;</code> element?</p>
<p>If you recall <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a>, we introduced Svelte context as a mechanism to set data and make it available to child components. Svelte context allows parent components to share data and functions with the child components without explicitly passing them as props.</p>
<p>We can use Svelte context for communication between the <code>&lt;Canvas&gt;</code> and <code>&lt;</code><code>Rectangle&gt;</code> components.</p>
<p>The <code>&lt;Canvas&gt;</code> component can set the context with the drawing context, <code>ctx</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { setContext } from 'svelte';
  // setting the context with the drawing context
  setContext('canvas', () =&gt; ctx);
&lt;/script&gt;</pre> <p>When the <code>&lt;Rectangle&gt;</code> component is rendered as a child of the <code>&lt;Canvas&gt;</code> component, it can access the context set by the <code>&lt;Canvas&gt;</code> component and retrieve the <code>ctx</code> variable. In <code>onMount</code>,  <code>&lt;Rectangle&gt;</code> retrieves the drawing context of the <code>&lt;canvas&gt;</code> element and draws a rectangle on the canvas:</p>
<pre class="source-code">
&lt;script&gt;
  import { getContext, onMount } from 'svelte';
  const getCtx = getContext('canvas');
  onMount(() =&gt; {
    const ctx = getCtxt();
    // draws a rectangle onto the canvas
    ctx.fillRect(...);
  });
&lt;/script&gt;</pre> <p>The <a id="_idIndexMarker442"/>reason we pass a function that returns <code>ctx</code> instead of directly passing <code>ctx</code> in the context is that the <code>ctx</code> value is only available in <code>onMount</code> after the <code>&lt;canvas&gt;</code> element is mounted onto the DOM, yet <code>setContext</code> has to be called during component initialization, which is before <code>onMount</code>. In the <code>&lt;Rectangle&gt;</code> component, you should only call <code>getCtx()</code>within <code>onMount</code> to retrieve the latest value of <code>ctx</code>.</p>
<p>By leveraging Svelte context, the <code>&lt;Canvas&gt;</code> and <code>&lt;Rectangle&gt;</code> components can maintain a clear and efficient communication channel. The <code>&lt;Canvas&gt;</code> component creates the canvas and provides the drawing context, while the <code>&lt;Rectangle&gt;</code> component accesses the canvas and performs the drawing tasks.</p>
<p>To complete the <code>&lt;Rectangle&gt;</code> component, we need to redraw the rectangle whenever the <em class="italic">x</em> or <em class="italic">y</em> positions or the width and height dimensions change. To do that, we will use a reactive statement:</p>
<pre class="source-code">
&lt;script&gt;
  // ...
  export let x, y, width, height;
  <strong class="bold">$: draw(x, y, width, height);</strong>
<strong class="bold">  function draw(x, y, width, height) {</strong>
<strong class="bold">    const ctx = getCtx();</strong>
<strong class="bold">    ctx.fillRect(x, y, width, height);</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;</pre> <p>In the preceding reactive statement, the <code>draw</code> function is rerun whenever the <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code> values change. By using this approach, the <code>&lt;Rectangle&gt;</code> component can efficiently update its appearance in response to changes in position or dimensions, ensuring that the rendered rectangle always reflects the latest state.</p>
<p>However, you might<a id="_idIndexMarker443"/> notice that it doesn’t work as expected. You’ll see that the new rectangle is drawn on top of the old rectangle. This is because we need to clear the canvas before drawing another rectangle. We cannot do that with our <code>draw</code> function, as it would lead to undesirable results if we have more than one <code>&lt;Rectangle&gt;</code> component. Each component would clear the canvas before drawing its own rectangle, resulting in only the last <code>&lt;Rectangle&gt;</code> component being visible.</p>
<p>To fix this issue, we need the <code>&lt;Canvas&gt;</code> component to clear the canvas before redrawing all the child rectangles. This function can be called whenever any of the child rectangle components request an update.</p>
<p>Let us define a <code>redrawCanvas</code> function in the <code>&lt;Canvas&gt;</code> component to redraw the canvas. In the <code>redrawCanvas</code> function, we first clear the canvas through <code>ctx.clearRect()</code>. Here is the update code for the <code>&lt;</code><code>Canvas&gt;</code> component:</p>
<pre class="source-code">
&lt;script&gt;
  // ...
<strong class="bold">  function redrawCanvas() {</strong>
<strong class="bold">    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);</strong>
<strong class="bold">    // TODO: here we need to redraw all the rectangles</strong>
<strong class="bold">  }</strong>
  // Provide both the drawing context and the clearCanvas function to child components
  setContext('canvas', { getCtx: () =&gt; ctx, <strong class="bold">redrawCanvas</strong> });
&lt;/script&gt;</pre> <p>In the <code>redrawCanvas</code> function, we <a id="_idIndexMarker444"/>want to redraw all the rectangles after we clear the canvas. But how do we do that? One idea is that instead of providing the drawing context, <code>ctx</code>, to all the child components and letting the components decide when and how to draw on the canvas, we could provide a function for the components to register their <code>draw</code> functions. This way, the <code>&lt;Canvas&gt;</code> component can call the <code>draw</code> functions when it needs to redraw the canvas.</p>
<p>In the <code>&lt;Canvas&gt;</code> component, we change the <code>getCtx</code> function into <code>registerDrawFunction</code>:</p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  const drawFunctions = new Set();</strong>
<strong class="bold">  function registerDrawFunction(drawFn) {</strong>
<strong class="bold">    drawFunctions.add(drawFn);</strong>
<strong class="bold">    return () =&gt; {</strong>
<strong class="bold">      drawFunctions.delete(drawFn);</strong>
<strong class="bold">    };</strong>
<strong class="bold">  }</strong>
  function redrawCanvas() {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
<strong class="bold">    // Redraw all the rectangles</strong>
<strong class="bold">    for (const drawFn of drawFunctions) {</strong>
<strong class="bold">      drawFn(ctx);</strong>
<strong class="bold">    }</strong>
  }
  setContext('canvas', { <strong class="bold">registerDrawFunction</strong>, redrawCanvas });
&lt;/script&gt;</pre> <p>In the <a id="_idIndexMarker445"/>preceding <code>redrawCanvas</code> function, we loop through the <code>drawFunctions</code> registered from child components and call them with the drawing context, <code>ctx</code>. This way, we don’t need to provide <code>ctx</code> through Svelte context, yet the child components can get the latest <code>ctx</code> in their <code>draw</code> functions.</p>
<p>Finally, let us register our <code>draw</code> function in the <code>&lt;</code><code>Rectangle&gt;</code> component:</p>
<pre class="source-code">
&lt;script&gt;
  // ...
  const { registerDrawFunction, redrawCanvas } = getContext('canvas');
  function draw(ctx) {
    ctx.fillRect(x, y, width, height);
  }
  onMount(() =&gt; {
    // register the draw function
    <strong class="bold">const unregister = registerDrawFunction(draw);</strong>
    <strong class="bold">return () =&gt; {</strong>
      <strong class="bold">unregister();</strong>
      <strong class="bold">redrawCanvas();</strong>
    <strong class="bold">};</strong>
  });
  // call redrawCanvas when x, y, height, width changes
  <strong class="bold">$: x, y, height, width, redrawCanvas()</strong>;
&lt;/script&gt;</pre> <p>In<a id="_idIndexMarker446"/> the <code>onMount</code> callback, we register the <code>draw</code> function of the <code>&lt;Rectangle&gt;</code> component through Svelte context. When the component is destroyed and removed from the DOM, the <code>&lt;Rectangle&gt;</code> component unregisters itself and calls the <code>redrawCanvas</code> function. This ensures that the <code>&lt;Canvas&gt;</code> component is updated, and the canvas is cleared of the removed rectangle.</p>
<p>Moreover, by calling the <code>redrawCanvas</code> function in a reactive statement whenever <code>x</code>, <code>y</code>, <code>height</code>, or <code>width</code> changes, the <code>&lt;Rectangle&gt;</code> component ensures that its position and dimensions are accurately reflected on the canvas. This way, the <code>&lt;Canvas&gt;</code> component always maintains an up-to-date visual representation of its child components.</p>
<p>Now, the <code>&lt;Canvas&gt;</code> component has full control over redrawing the entire canvas, and the <code>&lt;Rectangle&gt;</code> components can register their <code>draw</code> functions with the <code>&lt;Canvas&gt;</code> component. This approach ensures that the canvas is always cleared before redrawing and allows multiple <code>&lt;Rectangle&gt;</code> components to coexist without interfering with each other’s drawings.</p>
<p>We now have functional <code>&lt;Canvas&gt;</code> and <code>&lt;Rectangle&gt;</code> components. Throughout the process of creating these components, we have transformed imperative canvas operations into more manageable, declarative components.</p>
<p>To facilitate communication between parent and child components, we utilized Svelte context as the communication channel. As demonstrated in the preceding code snippets, the parent <code>&lt;Canvas&gt;</code> component maintains a list of <code>draw</code> functions from its child components, enabling it to invoke them as needed. This general pattern can be applied to parent components that need to track and call methods from their child components.</p>
<p>While the code we’ve written is functional, it may still require some refinements. To access the full working code, including any additional features or optimizations necessary for a polished and comprehensive implementation, please visit the GitHub repository: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas%0D">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas</a>.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor173"/>Exercise 2 – expanding shape components</h2>
<p>In this exercise, we <a id="_idIndexMarker447"/>challenge you to create additional <a id="_idIndexMarker448"/>shape components to expand the capabilities of your existing <code>&lt;</code><code>Canvas&gt;</code> component.</p>
<p>Examples of shapes you can create include the following:</p>
<ul>
<li>A <code>&lt;Circle&gt;</code> component that takes in <code>x</code>, <code>y</code>, <code>radius</code>, and <code>color</code> as props. The component should draw a circle on the canvas at the given coordinates and with the specified radius and color.</li>
<li>A <code>&lt;Line&gt;</code> component that takes in <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, and <code>color</code> as props. The component should draw a line on the canvas between the two sets of coordinates with the specified color.</li>
<li>Other shape components, such as <code>&lt;Ellipse&gt;</code> and <code>&lt;Triangle&gt;</code>.</li>
</ul>
<p>You may need to refer to the Canvas API documentation to learn how to draw different shapes.</p>
<p>You can find the code for the <code>&lt;Circle&gt;</code> and <code>&lt;Line&gt;</code> components at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas</a>.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor174"/>Summary</h1>
<p>Throughout this chapter, we have delved into the concept of renderless components in Svelte and explored their various use cases. Understanding renderless components equips you with a new toolset to create reusable components. A renderless component emphasizes reusability by focusing on the core logic, state, and behavior, leaving the visual presentation flexible for customization.</p>
<p>By using slot props, we demonstrated how to build a renderless component that is reusable and gives users control over its appearance, while maintaining the component logic and transforming imperative operations into declarative Svelte components.</p>
<p>We also presented practical examples of transforming imperative operations into declarative Svelte components. We demonstrated how to create <code>&lt;Canvas&gt;</code> and <code>&lt;Rectangle&gt;</code> components that draw a rectangle on a canvas, which can change in size dynamically.</p>
<p>In the next chapter, we will explore how Svelte stores and animations can be combined to create fluid, animated applications.</p>
</div>
<div><p class="hidden">Renderless Components</p>
</div>
<div><div></div>
</div>
</div></body></html>