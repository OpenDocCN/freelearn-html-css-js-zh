<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor163"/>11</h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor164"/>Renderless Components</h1>
<p>A renderless component is an advanced concept in Svelte that allows developers to create reusable components without rendering any HTML elements within the <span class="No-Break">component itself.</span></p>
<p>This technique is particularly useful when leveraging Svelte to render on a canvas or in a 3D context, where the rendering of an HTML template by Svelte is not required. Instead, the canvas<a id="_idIndexMarker412"/> and <strong class="bold">Web Graphics Library</strong> (<strong class="bold">WebGL</strong>) offer an imperative API to produce graphics on the canvas. With the renderless component technique, it becomes possible to design components that enable users to describe the canvas declaratively, allowing the component to translate it into <span class="No-Break">imperative instructions.</span></p>
<p>Another use case for a renderless component is to create components that only manage states and behaviors, leaving the parent component control over what should actually be rendered. This will come in handy when developing a component library and you want to make it easy for users to customize how your component looks and lets you have control over the state <span class="No-Break">and behaviors.</span></p>
<p>In this chapter, we will utilize Svelte context to create our renderless component. If you are new to Svelte context, please refer to <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, where we explain <span class="No-Break">its meaning.</span></p>
<p>Initially, we will explore the concept of renderless components and subsequently build techniques to create them. As we develop our renderless component, we will share a few examples of <span class="No-Break">renderless components.</span></p>
<p>At the end of the chapter, you should possess the ability to employ the renderless component technique to convert imperative APIs into <span class="No-Break">declarative components.</span></p>
<p>The topics discussed in this chapter are <span class="No-Break">as follows:</span></p>
<ul>
<li>What are <span class="No-Break">renderless components?</span></li>
<li>Building renderless components with <span class="No-Break">Svelte context</span></li>
</ul>
<h1 id="_idParaDest-163"><a id="_idTextAnchor165"/>Technical requirements</h1>
<p>You can find the code used in this chapter on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor166"/>What are renderless components?</h1>
<p>A<a id="_idIndexMarker413"/> renderless component, as its name implies, is a type of component that does not render any HTML elements of <span class="No-Break">its own.</span></p>
<p>You might wonder, what’s the purpose of a component that doesn’t <span class="No-Break">render anything?</span></p>
<p>Well, despite not rendering HTML, there are still several useful things that a component can do, including <a id="_idIndexMarker414"/><span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Accepting props, processing their values, and triggering side effects as their values change</strong>: Even though the prop values are not used directly in the template, they are still reactive. You can write reactive statements with props in the component and have them run whenever the prop values change. You can see this in the following example <span class="No-Break">code snippet:</span><pre class="source-code">
&lt;script&gt;
  export let title;
  export let description;
  $: document.title = `${title} - ${description}`;
&lt;/script&gt;</pre><p class="list-inset">Even though the <strong class="source-inline">title</strong> and <strong class="source-inline">description</strong> props are not used in the template, both <strong class="source-inline">title</strong> and <strong class="source-inline">description</strong> are used in a reactive statement. Whenever the <strong class="source-inline">title</strong> or <strong class="source-inline">description</strong> props change, the reactive statement in line 4 will rerun and update the title of <span class="No-Break">the document.</span></p><p class="list-inset">Setting the document title, updating the cookie value, and modifying context are good examples of <span class="No-Break">side effects.</span></p></li> <li><strong class="bold">Exhibiting component lifecycles, and performing actions as the component mounts and gets destroyed</strong>: The component lifecycles, such as <strong class="source-inline">onMount</strong> and <strong class="source-inline">onDestroy</strong>, still run even if no elements are mounted and destroyed in <span class="No-Break">the component.</span></li>
<li><strong class="bold">Providing data to child elements via context setup or by passing data through the </strong><strong class="source-inline">&lt;slot&gt;</strong><strong class="bold"> element</strong>: Even though a renderless component does not render any HTML elements, it can still render a <strong class="source-inline">&lt;slot&gt;</strong> element that allows the user of the component to pass in child elements <span class="No-Break">or components.</span><p class="list-inset">For example, in<a id="_idIndexMarker415"/> the following <strong class="source-inline">Parent</strong> component, we render a <span class="No-Break"><strong class="source-inline">default</strong></span><span class="No-Break"> slot:</span></p><pre class="source-code">
&lt;!-- Parent.svelte --&gt;
&lt;slot /&gt;</pre><p class="list-inset">Then, the user of the <strong class="source-inline">Parent</strong> component can pass in child elements or components under the <span class="No-Break"><strong class="source-inline">Parent</strong></span><span class="No-Break"> component:</span></p><pre class="source-code">&lt;script&gt;
  import Parent from './Parent.svelte';
&lt;/script&gt;
&lt;Parent&gt;
  &lt;Child /&gt; &lt;!-- example of child components --&gt;
  &lt;div /&gt; &lt;!-- example of child elements --&gt;
&lt;/Parent&gt;</pre><p class="list-inset">The <strong class="source-inline">Parent</strong> component can pass data to the child components or elements through two avenues – setting context data and setting <span class="No-Break">slot props.</span></p><p class="list-inset">You can read more about setting slot props in <a href="B18887_04.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p></li> <li><strong class="bold">Communicating with the parent component using context</strong>: Similar to any other component, a renderless component can use <strong class="source-inline">getContext()</strong> to retrieve the context value set by its parent component. Depending on the type of context value provided by the parent, we can use the context value to communicate <a id="_idIndexMarker416"/>with the parent or inform it about the existence of the <span class="No-Break">child component.</span><p class="list-inset">In the <em class="italic">Writing declarative canvas components</em> section later in the chapter, you will see an example of such <span class="No-Break">a technique.</span></p></li>
</ul>
<p>Throughout the upcoming sections, we will challenge ourselves by creating components that perform only the operations listed in the preceding list, without rendering any <span class="No-Break">HTML elements.</span></p>
<p>In this chapter, we will explore two use cases for renderless components, which are turning reusable renderless components and declarative descriptions into imperative instructions. Let’s take an in-depth look <span class="No-Break">at them.</span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor167"/>Exploring reusable renderless components</h1>
<p>The first use <a id="_idIndexMarker417"/>case for renderless components involves creating components that solely focus on the logic of the component. These components are not your typical ones, such as buttons or text inputs. Instead, think of components with slightly complex logic, such as carousels, tabs, or drop-down menus. Although the logic of a carousel component is relatively standard, its appearance can vary significantly based on where and how it <span class="No-Break">is used.</span></p>
<p>So, how can we create a reusable carousel component that can look different based on where it <span class="No-Break">is used?</span></p>
<p>One solution is to create a carousel component that only contains the carousel logic, without any specific styling or HTML structure. Then, the consumer of the component can decide how the carousel should look by passing in their own styling and HTML structure. This allows for greater flexibility and customization, making the component more versatile and reusable in <span class="No-Break">different contexts.</span></p>
<p>For example, the carousel component could accept props such as <strong class="source-inline">items</strong>, which would determine the list of items in the carousel. The carousel component could render a <strong class="source-inline">slot</strong> element that takes in slot props such as <strong class="source-inline">currentIndex</strong> and <strong class="source-inline">setIndex</strong>, which would be the index of the currently active item and the function to set the index. This allows the carousel component to manage the carousel item cycling logic, while leaving the consumer of the carousel component to determine the actual carousel styling <span class="No-Break">and structure.</span></p>
<p>By separating<a id="_idIndexMarker418"/> the carousel logic from the specific styling and structure, we can create a more modular and reusable component that can be used in various contexts, without having to rewrite the same logic over and over again. This is the power of renderless components – they allow us to create components that focus solely on their core functionality, without being tied to any specific rendering or <span class="No-Break">styling requirements.</span></p>
<p>Of course, before we proceed, it’s essential to clarify when not to use a renderless component to create a carousel. If you require a fully functional carousel component, including the design and style, a renderless component may not be suitable for your needs, as its main purpose is to handle the logic and behavior of the carousel without dictating <span class="No-Break">its appearance.</span></p>
<p>Ultimately, the decision to create a renderless component for a carousel depends on your specific needs and goals. Consider your project requirements and design preferences before deciding on the <span class="No-Break">best approach.</span></p>
<p>In the next section, I will show you step by step how we can build a renderless <span class="No-Break">carousel component.</span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor168"/>Example – building a renderless carousel component</h2>
<p>A <a id="_idIndexMarker419"/>carousel component is a UI <a id="_idIndexMarker420"/>component that displays a set of items in a loop. It allows users to view a collection of items in a slideshow-like format. A carousel component is usually found on websites such as e-commerce platforms, news portals, and social <span class="No-Break">media platforms.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 11.1: An example of a carousel component" height="308" src="image/B18887_11_01.jpg" width="803"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: An example of a carousel component</p>
<p>We will <a id="_idIndexMarker421"/>create a renderless<a id="_idIndexMarker422"/> carousel component that accepts a list of items through props named <strong class="source-inline">items</strong>. The carousel component will render a <strong class="source-inline">slot</strong> element to allow customization of <span class="No-Break">its appearance.</span></p>
<p>The <strong class="source-inline">slot</strong> element will take in a few <span class="No-Break">slot props:</span></p>
<ul>
<li><strong class="source-inline">currentIndex</strong>: This represents the index of the currently displayed item in <span class="No-Break">the carousel.</span></li>
<li><strong class="source-inline">currentItem</strong>: This represents the currently displayed item in <span class="No-Break">the carousel.</span></li>
<li><strong class="source-inline">setCurrentIndex</strong>: This is a function that can be used to update the current index of the carousel. It can be used to implement custom <span class="No-Break">navigation controls.</span></li>
<li><strong class="source-inline">next</strong> and <strong class="source-inline">prev</strong>: These <strong class="source-inline">slot</strong> props are functions that can be used to navigate to the next or previous item in the carousel. They can be used to implement custom navigation controls or respond to user input, such as clicks <span class="No-Break">or swipes.</span></li>
</ul>
<p>These <strong class="source-inline">slot</strong> props allow the consumer to decide how to use them to build their own <span class="No-Break">carousel UI.</span></p>
<p>To determine the appropriate <strong class="source-inline">slot</strong> props for the carousel component, we consider the essential states and functions required for users to build their own carousel UI. In this case, the key states are <strong class="source-inline">currentIndex</strong> and <strong class="source-inline">currentItem</strong>, while the necessary functions to interact with the carousel UI include <strong class="source-inline">setCurrentIndex</strong>, <strong class="source-inline">next</strong>, and <strong class="source-inline">prev</strong>, which are helpful to implement custom <span class="No-Break">navigation controls.</span></p>
<p>An example<a id="_idIndexMarker423"/> of a carousel UI is one that displays the current item and has buttons to navigate forward and backward through <span class="No-Break">the carousel:</span></p>
<pre class="source-code">
&lt;Carousel {items} let:currentItem let:next let:prev&gt;
  &lt;button on:click={prev}&gt;{'&lt;'}&lt;/button&gt;
  &lt;img src={currentItem} /&gt;
  &lt;button on:click={next}&gt;{'&gt;'}&lt;/button&gt;
&lt;/Carousel&gt;</pre> <p>In the preceding code snippet, we use the <strong class="source-inline">currentItem</strong>, <strong class="source-inline">next</strong>, and <strong class="source-inline">prev</strong> slot props to build a simple carousel UI. We decide how to use the <strong class="source-inline">slot</strong> props and control the structure and styling of the <span class="No-Break">HTML elements.</span></p>
<p>Another example of a <a id="_idIndexMarker424"/>carousel UI is displaying a list of item numbers at the bottom of it, enabling the user to quickly jump to a selected item by clicking on <span class="No-Break">its number:</span></p>
<pre class="source-code">
&lt;Carousel {items} let:currentItem let:setCurrentIndex&gt;
  &lt;img src={currentItem} /&gt;
  {#each items as _, index}
    &lt;button on:click={() =&gt; setCurrentIndex(index)}&gt;
      {index}
    &lt;/button&gt;
  {/each}
&lt;/Carousel&gt;</pre> <p>In the preceding code, I used Svelte’s <strong class="source-inline">{#each}</strong> block to create a list of buttons, labeled with a different index number. Each of the buttons has a click event listener that sets the current index of the carousel to the index number of the button. When you click on the button, the carousel will jump to the item at the index that is specified by <span class="No-Break">the button.</span></p>
<p>The second<a id="_idIndexMarker425"/> carousel UI is different from the first carousel UI, and you can create and style a totally different carousel UI. You can see that the appearance of the carousel UI is entirely up to the user. The renderless carousel component focuses on the carousel logic and allows the user to decide on the UI structure <span class="No-Break">and styling.</span></p>
<p>Without further ado, let’s explore how to write the <span class="No-Break">carousel component.</span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor169"/>Writing a renderless carousel component</h2>
<p>In the <a id="_idIndexMarker426"/>previous section, we decided on the props of our <strong class="source-inline">Carousel</strong> component, <strong class="source-inline">items</strong>, and decided that it should have a <span class="No-Break">default </span><span class="No-Break"><strong class="source-inline">&lt;slot&gt;</strong></span><span class="No-Break">.</span></p>
<p>Based on this information, let’s create the structure of our <span class="No-Break"><strong class="source-inline">Carousel</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let items;
&lt;/script&gt;
&lt;slot&gt;</pre> <p>In the preceding code snippet, the <strong class="source-inline">&lt;slot&gt;</strong> element will be the only element we will have in our <strong class="source-inline">Carousel</strong> component. This <strong class="source-inline">&lt;slot&gt;</strong> element is needed; otherwise, the child elements inside the <strong class="source-inline">&lt;Carousel&gt;</strong> component, indicated in the following code snippet, will be ignored and discarded if there’s no <strong class="source-inline">&lt;slot&gt;</strong> element in the <span class="No-Break"><strong class="source-inline">Carousel</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
&lt;Carousel&gt;
  <strong class="bold">&lt;!-- content over here will be ignored if the Carousel don't have a &lt;slot&gt; element --&gt;</strong>
&lt;/Carousel&gt;</pre> <p>In the <strong class="source-inline">&lt;slot&gt;</strong> element, we define the following <strong class="source-inline">slot</strong> props – <strong class="source-inline">currentIndex</strong>, <strong class="source-inline">currentItem</strong>, <strong class="source-inline">setCurrentIndex</strong>, <strong class="source-inline">prev</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">next</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;slot {currentIndex} {currentItem} {setCurrentIndex} {prev} {next} /&gt;</pre> <p>However, these<a id="_idIndexMarker427"/> <strong class="source-inline">slot</strong> props are not defined in our <strong class="source-inline">Carousel</strong> component yet, so let’s <span class="No-Break">define them.</span></p>
<p>We initialize <strong class="source-inline">currentIndex</strong> to <strong class="source-inline">0</strong> at the start of <span class="No-Break">the component:</span></p>
<pre class="source-code">
let currentIndex = 0;</pre> <p><strong class="source-inline">setCurrentIndex</strong> is used to update <strong class="source-inline">currentIndex</strong> to the value being <span class="No-Break">passed in:</span></p>
<pre class="source-code">
const setCurrentIndex = (value) =&gt; { currentIndex = value; };</pre> <p><strong class="source-inline">currentItem</strong> will be the item in the <strong class="source-inline">items</strong> array at the index position of <strong class="source-inline">currentIndex</strong>. Here, I’ll use the reactive statements so that we will have a new <strong class="source-inline">currentItem</strong> slot prop whenever the <strong class="source-inline">items</strong> array or <span class="No-Break"><strong class="source-inline">currentIndex</strong></span><span class="No-Break"> changes:</span></p>
<pre class="source-code">
$: currentItem = items[currentIndex];</pre> <p>Finally, the <strong class="source-inline">prev</strong> and <strong class="source-inline">next</strong> functions will be used to set <strong class="source-inline">currentIndex</strong>, based on its <span class="No-Break">current value:</span></p>
<pre class="source-code">
const prev = () =&gt; setCurrentIndex((currentIndex - 1 + items.length) % items.length);
const next = () =&gt; setCurrentIndex((currentIndex + 1) % items.length);</pre> <p>In the preceding snippet, I used <strong class="source-inline">% items.length</strong> so that the index is always within the bounds of the length of the <strong class="source-inline">items</strong> array. This way, we ensure that the carousel can loop back to the beginning of the <strong class="source-inline">items</strong> array after reaching the end, creating a seamless looping effect for <span class="No-Break">the user.</span></p>
<p>And that’s it. If you add all the preceding code snippets to the <strong class="source-inline">Carousel</strong> component, you’ll have a working renderless component. The full code is available on GitHub at<a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel</a> <span class="No-Break">as well.</span></p>
<p>Creating a renderless component is not hard; it doesn’t take us much time to create a renderless <strong class="source-inline">Carousel</strong> component. The key here is to figure out the props for our renderless component, then figure out the <strong class="source-inline">slot</strong> props needed, and finally, create a default <strong class="source-inline">&lt;slot&gt;</strong> element <a id="_idIndexMarker428"/>with the <span class="No-Break"><strong class="source-inline">slot</strong></span><span class="No-Break"> props.</span></p>
<p>Before we move on, let’s have an exercise to create a reusable renderless <span class="No-Break">component yourself.</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor170"/>Exercise 1 – a renderless autocomplete component</h2>
<p>An <a id="_idIndexMarker429"/>autocomplete component is an input with an auto-suggest dropdown that shows a list of matching options as a user types in the input. It helps users quickly and easily find and select an option from a large set of choices. autocomplete components are commonly used in search bars, forms, and other areas where users need to enter data quickly <span class="No-Break">and accurately.</span></p>
<p>In this exercise, we’ll create a renderless <span class="No-Break">autocomplete component.</span></p>
<p>The autocomplete component will take in only one prop, a <strong class="source-inline">search</strong> function, which takes in a search value <a id="_idIndexMarker430"/>and returns <strong class="source-inline">Promise</strong>, which resolves to an array of <span class="No-Break">string results.</span></p>
<p>What about the slot props that our renderless <strong class="source-inline">Autocomplete</strong> component <span class="No-Break">would provide?</span></p>
<p>We need three states for our <span class="No-Break">autocomplete component:</span></p>
<ul>
<li><strong class="source-inline">value</strong>: To represent the current value in the <span class="No-Break">input box</span></li>
<li><strong class="source-inline">searching</strong>: A Boolean value to represent whether the autocomplete currently searches <span class="No-Break">for results</span></li>
<li><strong class="source-inline">suggestions</strong>: An array of autocomplete results returned from the <span class="No-Break"><strong class="source-inline">search</strong></span><span class="No-Break"> function</span></li>
</ul>
<p>For a user to interact with the <strong class="source-inline">Autocomplete</strong> component, we need <span class="No-Break">two functions:</span></p>
<ul>
<li><strong class="source-inline">setValue</strong>: To update the value of the <span class="No-Break">input box</span></li>
<li><strong class="source-inline">selectSuggestion</strong>: To select the suggestion and apply it to the <span class="No-Break">input box</span></li>
</ul>
<p>So, the preceding three states and two functions will be the <strong class="source-inline">slot</strong> props for our <span class="No-Break"><strong class="source-inline">Autocomplete</strong></span><span class="No-Break"> component.</span></p>
<p>Here is an example of how<a id="_idIndexMarker431"/> the <strong class="source-inline">Autocomplete</strong> component could <span class="No-Break">be used:</span></p>
<pre class="source-code">
&lt;Autocomplete {search} let:value let:setValue let:searching let:suggestions let:selectSuggestion&gt;
  &lt;input {value} on:input={event =&gt; setValue(event.currentTarget.value)}&gt;
  {#if searching}Searching...{/if}
  {#if suggestions}
    &lt;ul&gt;
      {#each suggestions as suggestion}
        &lt;li on:click={() =&gt; selectSuggestion(suggestion)}&gt;{suggestion}&lt;/li&gt;
      {/each}
    &lt;/ul&gt;
  {/if}
&lt;/Autocomplete&gt;</pre> <p>In the<a id="_idIndexMarker432"/> preceding code snippet, we use the <strong class="source-inline">Autocomplete</strong> component to render an autocomplete textbox, with an <strong class="source-inline">&lt;input&gt;</strong> element and an <strong class="source-inline">&lt;ul&gt;</strong> element in the <span class="No-Break">default slot.</span></p>
<p>The <strong class="source-inline">&lt;input&gt;</strong> element uses the <strong class="source-inline">value</strong> and <strong class="source-inline">setValue</strong> slot props to access and modify <strong class="source-inline">value</strong>, held by the <span class="No-Break"><strong class="source-inline">Autocomplete</strong></span><span class="No-Break"> component.</span></p>
<p>The <strong class="source-inline">&lt;ul&gt;</strong> element uses the <strong class="source-inline">suggestions</strong> slot prop to showcase the list of suggestions provided by the <strong class="source-inline">Autocomplete</strong> component and the <strong class="source-inline">selectSuggestion</strong> slot props are used in the <strong class="source-inline">click</strong> event handler of the <strong class="source-inline">&lt;li&gt;</strong> element to select the chosen suggestion and apply it to <span class="No-Break">the textbox.</span></p>
<p>A sample solution can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete</span></a><span class="No-Break">.</span></p>
<p>Now, let us look at the second use case for a <span class="No-Break">renderless component.</span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor171"/>Turning a declarative description into imperative instructions</h1>
<p>The second <a id="_idIndexMarker433"/>use case for a renderless component involves allowing users to describe their needs declaratively and then translating them into <span class="No-Break">imperative instructions.</span></p>
<p>A good example of this use case is when working with a canvas <span class="No-Break">or WebGL.</span></p>
<p>For example, in a canvas, to create a red rectangle with a green border, you would need to use imperative APIs to create and style <span class="No-Break">the rectangle:</span></p>
<pre class="source-code">
ctx.fillStyle = 'red';
ctx.strokeStyle = 'green';
ctx.rect(10, 10, 100, 100);
ctx.stroke();
ctx.fill();</pre> <p>Step by step, we instruct the canvas context to set <strong class="source-inline">fillStyle</strong> and <strong class="source-inline">strokeStyle</strong> and then draw a rectangle, based on the fill color and stroke <span class="No-Break">color set.</span></p>
<p>When interacting with the canvas in an imperative manner, the code focuses on how to do things rather than what to do. This can result in code that is difficult to read and maintain, with a lot of low-level details that can make it hard to see the <span class="No-Break">bigger picture.</span></p>
<p>Conversely, if you write code declaratively, you describe what you want to happen, rather than how it should happen. This makes the code more expressive and easier to read, as well as more flexible <span class="No-Break">and reusable.</span></p>
<p>Continuing with the example of the red rectangle, we can create a Svelte component that handles drawing the rectangle on the canvas. Instead of manually coding the instructions to draw the rectangle, we can simply describe how we want it to appear on the canvas through the component. The component then takes care of rendering the rectangle on the canvas <span class="No-Break">for us.</span></p>
<p>Here’s an example of code that describes the same rectangle through a <span class="No-Break">Svelte component:</span></p>
<pre class="source-code">
&lt;script&gt;
  let x = 10, y = 10, height = 100, width = 100;
&lt;/script&gt;
&lt;Canvas&gt;
  &lt;Rectangle
    fill="red" stroke="green"
    {x} {y} {height} {width}
  /&gt;
&lt;/Canvas&gt;</pre> <p>In the <a id="_idIndexMarker434"/>preceding code snippet, we see a <strong class="source-inline">Rectangle</strong> component nested within a <strong class="source-inline">Canvas</strong> component. The <strong class="source-inline">Rectangle</strong> component has its fill, stroke, <em class="italic">x</em> position, <em class="italic">y</em> position, width, and <span class="No-Break">height specified.</span></p>
<p>The following diagram illustrates how<a id="_idIndexMarker435"/> the <strong class="source-inline">Rectangle</strong> component from the preceding code renders a red square with a <span class="No-Break">green border.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 11.2: A red square with a green border" height="80" src="image/B18887_11_02.jpg" width="245"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: A red square with a green border</p>
<p>Even though explicit instructions to draw on the canvas are nowhere to be seen in the code, we can visualize a rectangle being drawn on the canvas based on the <strong class="source-inline">Rectangle</strong> component. This rectangle, with a width and height of 100 px each, is positioned 10 px from the left and 10 px from the top, filled with a red color and a <span class="No-Break">green border.</span></p>
<p>By creating <a id="_idIndexMarker436"/>a renderless component that handles the low-level canvas instructions, we can separate the logic of drawing the rectangle from the specifics of how it should be rendered. This allows for more flexibility in how the rectangle is displayed on the canvas, as well as easier maintenance of <span class="No-Break">the code.</span></p>
<p>Furthermore, by allowing a user to describe their needs declaratively, we create a more intuitive and user-friendly interface to work with the canvas and other low-level technologies. This can lead to faster development times and a more enjoyable <span class="No-Break">development experience.</span></p>
<p>Let me show you an example of how declaratively describing a canvas is much faster than instructing it imperatively. If I want to animate the size of the rectangle, rather than coding the animation manually using imperative APIs, I can simply animate the <strong class="source-inline">height</strong> and <strong class="source-inline">width</strong> variables' value, just like the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
&lt;script&gt;
  let x = 10, y = 10, height = 100, width = 100;
<strong class="bold">  setInterval(() =&gt; {</strong>
<strong class="bold">    height += 10;</strong>
<strong class="bold">    width += 10;</strong>
<strong class="bold">  }, 100);</strong>
&lt;/script&gt;
&lt;Canvas&gt;
  &lt;Rectangle
    fill="red" stroke="green"
    {x} {y} {height} {width}
  /&gt;
&lt;/Canvas&gt;</pre> <p>Although the use of <strong class="source-inline">setInterval</strong> may not be the best to create an animation, the preceding code snippet attempts to demonstrate how easy it is to change the height and width of the rectangle in <span class="No-Break">the canvas.</span></p>
<p>In the preceding code snippet, we update <strong class="source-inline">height</strong> and <strong class="source-inline">width</strong> on every interval. We pass <strong class="source-inline">height</strong> and <strong class="source-inline">width</strong> into the <strong class="source-inline">Rectangle</strong> component. As you can see, the height and width of the rectangle on the canvas increases by 10 px every <span class="No-Break">100 ms.</span></p>
<p>Conversely, if <a id="_idIndexMarker437"/>we were to animate it imperatively, we would have to clear the canvas and redraw a rectangle with a new height and width on each interval. These implementation details are now abstracted away in the declarative component, making it easier to reason about the animation and modify it in <span class="No-Break">the future.</span></p>
<p>Overall, using renderless components to handle low-level imperative tasks can greatly improve the readability, maintainability, and flexibility of our code, while also making it more accessible <span class="No-Break">and user-friendly.</span></p>
<p>So, how do we implement the <strong class="source-inline">Canvas</strong> and the <strong class="source-inline">Rectangle</strong> component shown in the preceding code snippet? Let’s <span class="No-Break">find out.</span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor172"/>Writing declarative Canvas components</h2>
<p>We’ll start<a id="_idIndexMarker438"/> with the <span class="No-Break"><strong class="source-inline">Canvas</strong></span><span class="No-Break"> component.</span></p>
<p>Similar to the <a id="_idIndexMarker439"/>component structure of the <strong class="source-inline">Carousel</strong> component in the<a id="_idIndexMarker440"/> previous section, the <strong class="source-inline">Canvas</strong> component will render a <strong class="source-inline">&lt;slot&gt;</strong> element to insert all the <span class="No-Break">child components.</span></p>
<p>However, what’s different is that it will also render a <strong class="source-inline">&lt;canvas&gt;</strong> element, which is what we will interact with and <span class="No-Break">draw on:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let canvas, ctx;
  onMount(() =&gt; {
    ctx = canvas.getContext('2d');
  });
&lt;/script&gt;
&lt;canvas bind:this={canvas} /&gt;
&lt;slot /&gt;</pre> <p>In the preceding code snippet, we bind the reference of the <strong class="source-inline">&lt;canvas&gt;</strong> element to the variable named <strong class="source-inline">canvas</strong>. After the <strong class="source-inline">&lt;canvas&gt;</strong> element is mounted onto the DOM, we get the drawing context of the <strong class="source-inline">&lt;canvas&gt;</strong> element and assign it to the variable <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">ctx</strong></span><span class="No-Break">.</span></p>
<p>If you recall the <a id="_idIndexMarker441"/>previous code example, we placed the <strong class="source-inline">&lt;Rectangle&gt;</strong> component inside the <strong class="source-inline">&lt;Canvas&gt;</strong> component to draw a rectangle onto the canvas. The <strong class="source-inline">&lt;Rectangle&gt;</strong> component does not receive any data or slot props from the <strong class="source-inline">&lt;Canvas&gt;</strong> component. So, how does the <strong class="source-inline">&lt;Rectangle&gt;</strong> component inform the <strong class="source-inline">&lt;Canvas&gt;</strong> component that it is a child of the <strong class="source-inline">&lt;Canvas&gt;</strong> component? How does the <strong class="source-inline">&lt;Canvas&gt;</strong> component communicate with the <strong class="source-inline">&lt;Rectangle&gt;</strong> component to know what to draw and how to draw on its <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">canvas&gt;</strong></span><span class="No-Break"> element?</span></p>
<p>If you recall <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we introduced Svelte context as a mechanism to set data and make it available to child components. Svelte context allows parent components to share data and functions with the child components without explicitly passing them <span class="No-Break">as props.</span></p>
<p>We can use Svelte context for communication between the <strong class="source-inline">&lt;Canvas&gt;</strong> and <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Rectangle&gt;</strong></span><span class="No-Break"> components.</span></p>
<p>The <strong class="source-inline">&lt;Canvas&gt;</strong> component can set the context with the drawing <span class="No-Break">context, </span><span class="No-Break"><strong class="source-inline">ctx</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { setContext } from 'svelte';
  // setting the context with the drawing context
  setContext('canvas', () =&gt; ctx);
&lt;/script&gt;</pre> <p>When the <strong class="source-inline">&lt;Rectangle&gt;</strong> component is rendered as a child of the <strong class="source-inline">&lt;Canvas&gt;</strong> component, it can access the context set by the <strong class="source-inline">&lt;Canvas&gt;</strong> component and retrieve the <strong class="source-inline">ctx</strong> variable. In <strong class="source-inline">onMount</strong>,  <strong class="source-inline">&lt;Rectangle&gt;</strong> retrieves the drawing context of the <strong class="source-inline">&lt;canvas&gt;</strong> element and draws a rectangle on <span class="No-Break">the canvas:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { getContext, onMount } from 'svelte';
  const getCtx = getContext('canvas');
  onMount(() =&gt; {
    const ctx = getCtxt();
    // draws a rectangle onto the canvas
    ctx.fillRect(...);
  });
&lt;/script&gt;</pre> <p>The <a id="_idIndexMarker442"/>reason we pass a function that returns <strong class="source-inline">ctx</strong> instead of directly passing <strong class="source-inline">ctx</strong> in the context is that the <strong class="source-inline">ctx</strong> value is only available in <strong class="source-inline">onMount</strong> after the <strong class="source-inline">&lt;canvas&gt;</strong> element is mounted onto the DOM, yet <strong class="source-inline">setContext</strong> has to be called during component initialization, which is before <strong class="source-inline">onMount</strong>. In the <strong class="source-inline">&lt;Rectangle&gt;</strong> component, you should only call <strong class="source-inline">getCtx()</strong>within <strong class="source-inline">onMount</strong> to retrieve the latest value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ctx</strong></span><span class="No-Break">.</span></p>
<p>By leveraging Svelte context, the <strong class="source-inline">&lt;Canvas&gt;</strong> and <strong class="source-inline">&lt;Rectangle&gt;</strong> components can maintain a clear and efficient communication channel. The <strong class="source-inline">&lt;Canvas&gt;</strong> component creates the canvas and provides the drawing context, while the <strong class="source-inline">&lt;Rectangle&gt;</strong> component accesses the canvas and performs the <span class="No-Break">drawing tasks.</span></p>
<p>To complete the <strong class="source-inline">&lt;Rectangle&gt;</strong> component, we need to redraw the rectangle whenever the <em class="italic">x</em> or <em class="italic">y</em> positions or the width and height dimensions change. To do that, we will use a <span class="No-Break">reactive statement:</span></p>
<pre class="source-code">
&lt;script&gt;
  // ...
  export let x, y, width, height;
  <strong class="bold">$: draw(x, y, width, height);</strong>
<strong class="bold">  function draw(x, y, width, height) {</strong>
<strong class="bold">    const ctx = getCtx();</strong>
<strong class="bold">    ctx.fillRect(x, y, width, height);</strong>
<strong class="bold">  }</strong>
&lt;/script&gt;</pre> <p>In the preceding reactive statement, the <strong class="source-inline">draw</strong> function is rerun whenever the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">width</strong>, or <strong class="source-inline">height</strong> values change. By using this approach, the <strong class="source-inline">&lt;Rectangle&gt;</strong> component can efficiently update its appearance in response to changes in position or dimensions, ensuring that the rendered rectangle always reflects the <span class="No-Break">latest state.</span></p>
<p>However, you might<a id="_idIndexMarker443"/> notice that it doesn’t work as expected. You’ll see that the new rectangle is drawn on top of the old rectangle. This is because we need to clear the canvas before drawing another rectangle. We cannot do that with our <strong class="source-inline">draw</strong> function, as it would lead to undesirable results if we have more than one <strong class="source-inline">&lt;Rectangle&gt;</strong> component. Each component would clear the canvas before drawing its own rectangle, resulting in only the last <strong class="source-inline">&lt;Rectangle&gt;</strong> component <span class="No-Break">being visible.</span></p>
<p>To fix this issue, we need the <strong class="source-inline">&lt;Canvas&gt;</strong> component to clear the canvas before redrawing all the child rectangles. This function can be called whenever any of the child rectangle components request <span class="No-Break">an update.</span></p>
<p>Let us define a <strong class="source-inline">redrawCanvas</strong> function in the <strong class="source-inline">&lt;Canvas&gt;</strong> component to redraw the canvas. In the <strong class="source-inline">redrawCanvas</strong> function, we first clear the canvas through <strong class="source-inline">ctx.clearRect()</strong>. Here is the update code for the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Canvas&gt;</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
&lt;script&gt;
  // ...
<strong class="bold">  function redrawCanvas() {</strong>
<strong class="bold">    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);</strong>
<strong class="bold">    // TODO: here we need to redraw all the rectangles</strong>
<strong class="bold">  }</strong>
  // Provide both the drawing context and the clearCanvas function to child components
  setContext('canvas', { getCtx: () =&gt; ctx, <strong class="bold">redrawCanvas</strong> });
&lt;/script&gt;</pre> <p>In the <strong class="source-inline">redrawCanvas</strong> function, we <a id="_idIndexMarker444"/>want to redraw all the rectangles after we clear the canvas. But how do we do that? One idea is that instead of providing the drawing context, <strong class="source-inline">ctx</strong>, to all the child components and letting the components decide when and how to draw on the canvas, we could provide a function for the components to register their <strong class="source-inline">draw</strong> functions. This way, the <strong class="source-inline">&lt;Canvas&gt;</strong> component can call the <strong class="source-inline">draw</strong> functions when it needs to redraw <span class="No-Break">the canvas.</span></p>
<p>In the <strong class="source-inline">&lt;Canvas&gt;</strong> component, we change the <strong class="source-inline">getCtx</strong> function <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">registerDrawFunction</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  const drawFunctions = new Set();</strong>
<strong class="bold">  function registerDrawFunction(drawFn) {</strong>
<strong class="bold">    drawFunctions.add(drawFn);</strong>
<strong class="bold">    return () =&gt; {</strong>
<strong class="bold">      drawFunctions.delete(drawFn);</strong>
<strong class="bold">    };</strong>
<strong class="bold">  }</strong>
  function redrawCanvas() {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
<strong class="bold">    // Redraw all the rectangles</strong>
<strong class="bold">    for (const drawFn of drawFunctions) {</strong>
<strong class="bold">      drawFn(ctx);</strong>
<strong class="bold">    }</strong>
  }
  setContext('canvas', { <strong class="bold">registerDrawFunction</strong>, redrawCanvas });
&lt;/script&gt;</pre> <p>In the <a id="_idIndexMarker445"/>preceding <strong class="source-inline">redrawCanvas</strong> function, we loop through the <strong class="source-inline">drawFunctions</strong> registered from child components and call them with the drawing context, <strong class="source-inline">ctx</strong>. This way, we don’t need to provide <strong class="source-inline">ctx</strong> through Svelte context, yet the child components can get the latest <strong class="source-inline">ctx</strong> in their <span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break"> functions.</span></p>
<p>Finally, let us register our <strong class="source-inline">draw</strong> function in the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Rectangle&gt;</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
&lt;script&gt;
  // ...
  const { registerDrawFunction, redrawCanvas } = getContext('canvas');
  function draw(ctx) {
    ctx.fillRect(x, y, width, height);
  }
  onMount(() =&gt; {
    // register the draw function
    <strong class="bold">const unregister = registerDrawFunction(draw);</strong>
    <strong class="bold">return () =&gt; {</strong>
      <strong class="bold">unregister();</strong>
      <strong class="bold">redrawCanvas();</strong>
    <strong class="bold">};</strong>
  });
  // call redrawCanvas when x, y, height, width changes
  <strong class="bold">$: x, y, height, width, redrawCanvas()</strong>;
&lt;/script&gt;</pre> <p>In<a id="_idIndexMarker446"/> the <strong class="source-inline">onMount</strong> callback, we register the <strong class="source-inline">draw</strong> function of the <strong class="source-inline">&lt;Rectangle&gt;</strong> component through Svelte context. When the component is destroyed and removed from the DOM, the <strong class="source-inline">&lt;Rectangle&gt;</strong> component unregisters itself and calls the <strong class="source-inline">redrawCanvas</strong> function. This ensures that the <strong class="source-inline">&lt;Canvas&gt;</strong> component is updated, and the canvas is cleared of the <span class="No-Break">removed rectangle.</span></p>
<p>Moreover, by calling the <strong class="source-inline">redrawCanvas</strong> function in a reactive statement whenever <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">height</strong>, or <strong class="source-inline">width</strong> changes, the <strong class="source-inline">&lt;Rectangle&gt;</strong> component ensures that its position and dimensions are accurately reflected on the canvas. This way, the <strong class="source-inline">&lt;Canvas&gt;</strong> component always maintains an up-to-date visual representation of its <span class="No-Break">child components.</span></p>
<p>Now, the <strong class="source-inline">&lt;Canvas&gt;</strong> component has full control over redrawing the entire canvas, and the <strong class="source-inline">&lt;Rectangle&gt;</strong> components can register their <strong class="source-inline">draw</strong> functions with the <strong class="source-inline">&lt;Canvas&gt;</strong> component. This approach ensures that the canvas is always cleared before redrawing and allows multiple <strong class="source-inline">&lt;Rectangle&gt;</strong> components to coexist without interfering with each <span class="No-Break">other’s drawings.</span></p>
<p>We now have functional <strong class="source-inline">&lt;Canvas&gt;</strong> and <strong class="source-inline">&lt;Rectangle&gt;</strong> components. Throughout the process of creating these components, we have transformed imperative canvas operations into more manageable, <span class="No-Break">declarative components.</span></p>
<p>To facilitate communication between parent and child components, we utilized Svelte context as the communication channel. As demonstrated in the preceding code snippets, the parent <strong class="source-inline">&lt;Canvas&gt;</strong> component maintains a list of <strong class="source-inline">draw</strong> functions from its child components, enabling it to invoke them as needed. This general pattern can be applied to parent components that need to track and call methods from their <span class="No-Break">child components.</span></p>
<p>While the code we’ve written is functional, it may still require some refinements. To access the full working code, including any additional features or optimizations necessary for a polished and comprehensive implementation, please visit the GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas%0D"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor173"/>Exercise 2 – expanding shape components</h2>
<p>In this exercise, we <a id="_idIndexMarker447"/>challenge you to create additional <a id="_idIndexMarker448"/>shape components to expand the capabilities of your existing <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">Canvas&gt;</strong></span><span class="No-Break"> component.</span></p>
<p>Examples of shapes you can create include <span class="No-Break">the following:</span></p>
<ul>
<li>A <strong class="source-inline">&lt;Circle&gt;</strong> component that takes in <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">radius</strong>, and <strong class="source-inline">color</strong> as props. The component should draw a circle on the canvas at the given coordinates and with the specified radius <span class="No-Break">and color.</span></li>
<li>A <strong class="source-inline">&lt;Line&gt;</strong> component that takes in <strong class="source-inline">x1</strong>, <strong class="source-inline">y1</strong>, <strong class="source-inline">x2</strong>, <strong class="source-inline">y2</strong>, and <strong class="source-inline">color</strong> as props. The component should draw a line on the canvas between the two sets of coordinates with the <span class="No-Break">specified color.</span></li>
<li>Other shape components, such as <strong class="source-inline">&lt;Ellipse&gt;</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">&lt;Triangle&gt;</strong></span><span class="No-Break">.</span></li>
</ul>
<p>You may need to refer to the Canvas API documentation to learn how to draw <span class="No-Break">different shapes.</span></p>
<p>You can find the code for the <strong class="source-inline">&lt;Circle&gt;</strong> and <strong class="source-inline">&lt;Line&gt;</strong> components <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor174"/>Summary</h1>
<p>Throughout this chapter, we have delved into the concept of renderless components in Svelte and explored their various use cases. Understanding renderless components equips you with a new toolset to create reusable components. A renderless component emphasizes reusability by focusing on the core logic, state, and behavior, leaving the visual presentation flexible <span class="No-Break">for customization.</span></p>
<p>By using slot props, we demonstrated how to build a renderless component that is reusable and gives users control over its appearance, while maintaining the component logic and transforming imperative operations into declarative <span class="No-Break">Svelte components.</span></p>
<p>We also presented practical examples of transforming imperative operations into declarative Svelte components. We demonstrated how to create <strong class="source-inline">&lt;Canvas&gt;</strong> and <strong class="source-inline">&lt;Rectangle&gt;</strong> components that draw a rectangle on a canvas, which can change in <span class="No-Break">size dynamically.</span></p>
<p>In the next chapter, we will explore how Svelte stores and animations can be combined to create fluid, <span class="No-Break">animated applications.</span></p>
</div>
<div class="Basic-Text-Frame" id="_idContainer036">
<p class="hidden">Renderless Components</p>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer037">
</div>
</div>
</div></body></html>