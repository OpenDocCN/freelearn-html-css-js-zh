["```js\nconst exporter = new GLTFExporter()\nconst options = {\n  trs: false,\n  onlyVisible: true,\n  binary: false\n}\nexporter.parse(\n  scene,\n  (result) => {\n    const output = JSON.stringify(result, null, 2)\n    save(new Blob([output], { type: 'text/plain' }),\n      'out.gltf')\n  },\n  (error) => {\n    console.log('An error happened during parsing of the\n      scene', error)\n  },\n  options\n)\n```", "```js\nconst save = (blob, filename) => {\n  const link = document.createElement('a')\n  link.style.display = 'none'\n  document.body.appendChild(link)\n  link.href = URL.createObjectURL(blob)\n  link.download = filename\n  link.click()\n}\n```", "```js\n{\n  \"asset\": {\n    \"version\": \"2.0\",\n    \"generator\": \"THREE.GLTFExporter\"\n  },\n  \"scenes\": [\n    {\n      \"nodes\": [\n        0,\n        1,\n        2,\n        3\n      ]\n    }\n  ],\n  \"scene\": 0,\n  \"nodes\": [\n    {},\n...\n```", "```js\n  const loader = new GLTFLoader()\n  return loader.loadAsync('/assets/gltf/\n    blender-export/monkey.glb').then((structure) => {\n    return structure.scene\n  })\n```", "```js\nconst mixers = []\nconst modelAsync = () => {\n  const loader = new GLTFLoader()\n  return loader.loadAsync('/assets/models/\n     blender-cells/fracture.glb').then((structure) => {\n    console.log(structure)\n    // setup the ground plane\n    const planeMesh = structure.scene.\n      getObjectByName('Plane')\n    planeMesh.material.side = THREE.DoubleSide\n    planeMesh.material.color = new THREE.Color(0xff5555)\n    // setup the material for the pieces\n    const materialPieces = new THREE.MeshStandardMaterial({ color: 0xffcc33 })\n    structure.animations.forEach((animation) => {\n      const meshName = animation.name.substring\n     (0, animation.name.indexOf('Action')).replace('.', '')\n      const mesh = structure.scene.\n        getObjectByName(meshName)\n      mesh.material = materialPieces\n      const mixer = new THREE.AnimationMixer(mesh)\n      const action = mixer.clipAction(animation)\n      action.play()\n      mixers.push(mixer)\n    })\n    applyShadowsAndDepthWrite(structure.scene)\n    return structure.scene\n  })\n}\n```", "```js\nconst clock = new THREE.Clock()\nconst onRender = () => {\n  const delta = clock.getDelta()\n  mixers.forEach((mixer) => {\n    mixer.update(delta)\n  })\n}\n```", "```js\nconst cubeLightMap = new THREE.TextureLoader().load\n  ('/assets/models/blender-lightmaps/cube-light-map.png')\nconst cylinderLightMap = new THREE.TextureLoader().load\n('/assets/models/blender-lightmaps/cylinder-light-map.png')\nconst roomLightMap = new THREE.TextureLoader().load\n  ('/assets/models/blender-lightmaps/room-light-map.png')\nconst torusLightMap = new THREE.TextureLoader().load\n  ('/assets/models/blender-lightmaps/torus-light-map.png')\nconst addLightMap = (mesh, lightMap) => {\n  const uv1 = mesh.geometry.getAttribute('uv')\n  const uv2 = uv1.clone()\n  mesh.geometry.setAttribute('uv2', uv2)\n  mesh.material.lightMap = lightMap\n  lightMap.flipY = false\n}\nconst modelAsync = () => {\n  const loader = new GLTFLoader()\n  return loader.loadAsync('/assets/models/blender-\n    lightmaps/light-map.glb').then((structure) => {\n    const cubeMesh = structure.scene.\n      getObjectByName('Cube')\n    const cylinderMesh = structure.scene.\n      getObjectByName('Cylinder')\n    const torusMesh = structure.scene.\n      getObjectByName('Torus')\n    const roomMesh = structure.scene.\n      getObjectByName('Plane')\n    addLightMap(cubeMesh, cubeLightMap)\n    addLightMap(cylinderMesh, cylinderLightMap)\n    addLightMap(torusMesh, torusLightMap)\n    addLightMap(roomMesh, roomLightMap)\n    return structure.scene\n  })\n}\n```"]