- en: Chapter 9. Automate Your Testing with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to work with Grunt and Gulp to automate
    our development process. These two Node.js modules have a huge collection of plugins,
    which we can use in almost every case. In this chapter, we will talk about testing,
    its importance, and how to integrate it in our workflow. The following is a list
    of topics that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Popular testing methodologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Jasmine framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mocha framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with PhantomJS and DalekJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the importance of writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing software, the code we write can be put in the browser, run as
    a desktop program, or started as a Node.js script. In all these cases, we expect
    specific results. Every line of code has some significance, and we need to know
    whether the final product will do the job. Normally, we debug our applications,
    that is, we write part of the program and run it. By monitoring the output or
    its behavior, we assess whether everything is okay or whether there is a problem.
    However, this approach is time-consuming, especially if the project is big. Iterations
    through every single feature of the application costs a lot of time and money.
    Automated testing helps in such cases. From an architectural viewpoint, testing
    is very important. That's because when the system is complex and we have numerous
    relationships between the modules, it is difficult to add new features or introduce
    major changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t really guarantee that everything will work as it worked before the
    modifications. So, instead of relying on manual testing, it is much better to
    create scripts that can do this for us. Writing tests has several major benefits,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This proves that our software is stable and works as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This saves a lot of time because we don't have to repeatedly perform manual
    testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A badly written code with a lot of dependencies cannot be tested easily. Writing
    tests in most of these cases leads to better code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a solid test suite, we can extend the system without worrying about
    damaging something.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the tests cover all the application's features, then they can be used as
    the application's documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a testing methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are few popular ways of writing tests. Let's see which are they and the
    differences between them.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**) is a process that relies on the repetition
    of short development cycles. In other words, we write our test while writing the
    implementation. The shorter the cycles, the better. The following diagram shows
    the TDD flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test-driven development](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before we write the actual code that does the job for us, we need to prepare
    a test. Of course, after the first run, the test will fail because nothing has
    been implemented. So, we need to ensure that the test passes all the cycles. Once
    this happens, we may spend some time refactoring what has been done so far and
    continue with the next method, class, or feature. Note that everything spins around
    the test, which is a really good thing because this is where we define what our
    code should do. With this as a basis, we avoid delivering unnecessary code. We
    can also be sure that the implementation meets the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**) is similar to TDD. In fact, if the
    project is a small one, we can''t really spot the differences. The idea of this
    approach is to focus more on the specification and the application''s processes,
    rather than the actual code. For example, if we test a module that posts messages
    on Twitter with TDD, we will probably ask the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the message empty?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the message length less than 140 symbols?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the Ajax request made properly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the returned JSON contain certain fields?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However with BDD, we ask only the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the message sent to Twitter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both processes are interrelated and, as we said, sometimes there is no difference
    at all. What we should remember is that BDD focuses on what the code is doing
    and TDD on how the code is doing it.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several types of tests that you may write, which evaluate our system
    by giving an input and expecting a specific output. However, they also perform
    this evaluation on different parts. It is good to know their names, which are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Unit testing performs checks on a single part of the application;
    it focuses on one unit. Often, we face difficulties in writing such tests because
    we can''t split our code into units; this is usually a bad sign. If there is no
    clearly defined module, we can''t proceed with such tests. Distributing the logic
    to different units not only helps in testing but also contributes to the overall
    stability of the program. Let''s illustrate the problem with the following diagram:![Classifying
    tests](img/00039.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s assume we have an e-commerce site that sells products to our users.
    In the preceding diagram, processes such as log in, ordering, and logout are handled
    by one class, defined in the `App.js` file. Yes, it works. We may achieve the
    goal and successfully close the circle, but this is absolutely not unit testable
    because there are no units. It is much better if we split the responsibilities
    into different classes, as shown in the following diagram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Classifying tests](img/00040.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We continue to use `App.js` and it still controls everything. However, the
    different parts of the whole flow are divided between three classes: `Router`,
    `Users`, and `Payments`. Now, we are able to write unit tests.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Integration testing**: Integration tests output a result for several units
    or components. If we look at the preceding example, the integration test will
    simulate the whole process of ordering a product, that is, logging in, buying,
    and logging out. Normally, integration tests use several modules of the system
    and ensure that the modules work properly together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional testing**: The functional tests are closely related to integration
    tests and focus on a specific functionality in the system. It may involve several
    modules or components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System testing**: The system tests test our program in different environments.
    In the context of Node.js, this could be when running our scripts on different
    operating systems and monitoring the output. Sometimes there are differences and
    if we want to globally distribute our work, we need to ensure that our program
    is compatible with the most popular systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress or performance testing**: These tests evaluate our application beyond
    the defined specifications and show how our code reacts to heavy traffic or complex
    queries. They are really helpful when making a decision about the program''s architecture
    or choosing a framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some other types of testing, but the previously mentioned testing
    methods are the most popular. There is no strict policy on what tests to write.
    Of course, there are good practices, but what we should focus on is writing a
    testable code. There is nothing better than an application fully covered with
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'As testing is a really important part of the development process, there are
    frameworks specifically oriented toward writing tests. In general, when we use
    a framework, we need the following two tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test runner**: This is the part of the framework that runs our tests and
    displays messages whether they pass or fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertions**: These methods are used for the actual checks, that is, if we
    need to see whether an variable is `true`, then we can write `expect(active).toBe(true)`
    instead of just `if(active === true)`. It''s better for the reader and also prevents
    some strange situations; for example, if we want to see whether a variable is
    defined or not, the `if` statement in the following code returns `true` because
    the `status` variable has a value and this value is `null`. In fact, we are asking
    whether the `status` variable initialized, and if we leave the test in this manner,
    we will get wrong results. That''s why we need an assertion library that has proper
    methods for testing. The following code is the example that shows that the `status`
    variable is actually defined and its type is `object`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is a framework to test the JavaScript code. It is available as a Node.js
    module and also as a library, which we can use in the browser. It comes with its
    own assertion methods.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use the Node.js version of the framework. It''s a module, so
    it can be installed via the Node.js package manager, `npm`, as shown in the following
    code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will set up Jasmine globally, so we can run `jasmine-node`
    in every directory of our choice. The tests could be organized into different
    files placed in one folder or in subfolders. The only requirement is to end the
    filenames with `spec.js`, for example, `testing-payments.spec.js` or `testing-authorization.spec.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the module for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we write the actual test, let''s define the application we want to build.
    Let''s say we need a Node.js module that reads a file and finds specific words
    inside it. The following is the basic file structure that we are starting from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the module for testing](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code that tests the application will be placed in `tests/test.spec.js`,
    the implementation of the logic will be in `app.js`, and the file that we will
    read from will be `file.txt`. Let''s open the `file.txt` file and add the following
    text inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's a phrase used to test typewriter's keys. It contains all the letters
    from the English alphabet and is perfect for our small project.
  prefs: []
  type: TYPE_NORMAL
- en: Following the test-driven development concept
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The task is simple and we can probably solve it in around 20 lines of code.
    For sure, we can wrap all the code in one function and perform everything there.
    The downside is that if something goes wrong, we can''t detect where the problem
    occurs. That''s why we will split the logic into two parts and test them separately
    in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the file's content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for a certain word inside the file's content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we explained in the beginning of this chapter, we will write the test first,
    we will see it fail, and then will write the code for `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the file-reading process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests, just like any other task, can be challenging. Sometimes, we can't
    determine what to test and what to exclude. There is a certain unsaid rule that
    advices users to avoid working on features that are tested by other developers—in
    our example, we need not test whether the file is read successfully. If we do
    that, it will look like we are testing the filesystem API of Node.js, which is
    not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every test written with Jasmine starts with the `describe` clause. Add the
    following code to `tests/test.spec.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are adding meaningful information that tells what exactly we are going to
    test. The second argument of `it` is again a function. The difference is that
    it accepts an argument, which is another function. We need to call it once we
    are done with the checks. Many scripts in JavaScript are asynchronous, and the
    `done` callback helps us in handling such operations.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code block includes the `app.js` module and verifies the result.
    The `expect` method accepts a subject of the assertion, and the following chained
    methods perform the actual check.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a test ready, so we can execute it. Run `jasmine-node ./tests` and
    you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the file-reading process](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The test case passes. The `app.js` file is empty, but even then Node.js doesn''t
    fail. The value of the `app` variable is actually an empty object. Let''s continue
    and try to imagine the methods that we will need. In the following code we are
    adding one more block testing a `read` API method of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `it` runs well but the second one raises an error. That''s because
    there is nothing in `app.js`. We don''t have a `read` method there. The error
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the file-reading process](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that we can clearly see what went wrong. If someone, for some reason, deletes
    or renames the used method, this test will fail. Even if the function exists,
    we expect to see a specific result that validates the job of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to start writing the actual code of the application. We should
    make the test passing. Place the following code in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the test, it will fail but for another reason, and that''s because
    there is no logic inside the `read` method. The following screenshot is the result
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the file-reading process](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time the `read` method is defined, but it doesn''t return anything and
    `expect(content).toBe("The quick brown fox jumps over the lazy dog.")` fails.
    Let''s read `file.txt` with the Node.js file API and return its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the color of the test is in green, which indicates that the module has
    the method we used and that method returns what we expect, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the file-reading process](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finding strings in the file content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using the same methodology, we will implement the second part of our application:
    finding words inside the file. The following is the new `describe` block, which
    we will start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We require a `check` method that accepts two arguments. The first one is the
    word we want to find, and the second one is the string that will contain it. Note
    that we are not using the `read` method. The idea is to test the function separately
    and guarantee that it works properly. This is a very important step because it
    makes our `check` method universal. It is not bound to the idea of matching the
    text inside a file; however, it does match the text inside a string. If we don''t
    use the test-driven workflow, we may end up with one function that does both the
    operations: reading the file and scanning its content. However, in our case, we
    can use the same module with the text fetched from a database or via an HTTP request.
    And, if we find that our module doesn''t find a particular word, we will know
    that the problem lies in the `check` function because it is tested as separate
    unit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code of the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is now passed with three assertions as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding strings in the file content](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Writing an integration test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tests we have written so far were unit tests, that is, they tested the
    two units of our application. Now, let''s add an integration test. Again, we need
    a failing test that uses the module. So, we are starting with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are not keeping the content of the file in a temporary variable,
    and we are not passing it to the `check` method. In fact, we are not interested
    in the actual content of the file. We are interested only if it contains a specific
    string. So, our module should handle this and keep the text in it. The preceding
    test fails and the following message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing an integration test](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the changes needed to make `app.js` work as we want it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will simply store the text in a local variable named `fileContent`. Note
    that we are making changes carefully and keeping the return logic of the `read`
    method. This is needed because there is a test that requires this functionality.
    This shows one more benefit of TDD. We ensure that the code, before including
    our modifications, works in its original form. In complex systems or applications,
    this is extremely important, and without tests, this will be really difficult
    to achieve. The final result is again a screenshot with a green message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing an integration test](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha is a little more advanced testing framework than Jasmine. It is more configurable,
    supports TDD or BDD testing, and even has several types of reporters. It is also
    quite popular and portable for client-side usage in the browser, which makes it
    a good candidate for our testing.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to Jasmine, we need the Node.js''s package manager to install Mocha.
    By running the following command, the framework will be set up globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation finishes, we can run `mocha ./tests`. By default, the
    tool searches for JavaScript files and tries to run them. Here, let's use the
    same example used with Jasmine and pass it through Mocha. It actually uses the
    same syntax of the `describe` and `it` blocks. However, it doesn't come with its
    own assertion library. In fact, there is a built-in Node.js module for such purposes
    named `assert`. There are also libraries developed by other developers, for example,
    `should.js`, `chai`, or `expect.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'They differ in certain aspects but do the same job: checking actual and expected
    values and raising an error if they don''t match. After that, the framework catches
    the error and displays the results.'
  prefs: []
  type: TYPE_NORMAL
- en: Translating our example using Mocha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everything is the same but the `expect` module calls are replaced with `assert.equal`.
    We used `assert.fail` to notify the framework that there is something wrong. The
    following are the other `describe` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the latest changes, the tests should pass and we should see the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Translating our example using Mocha](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting a reporter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mocha is quite flexible when we talk about reporters. The reporter is the part
    of the framework that displays the results on the screen. There are a dozen of
    options we can choose from. To set the type of the reporter, we should use the
    `-R` option in the command line, for example, the closest thing to Jasmine''s
    reporter is the `dot` type, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a reporter](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see more detailed information about the passed or failed tests, we can use
    the `spec` reporter as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a reporter](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is also a reporter that looks like a landing plane (the `landing` type)
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a reporter](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing with a headless browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we learned how to test our code. We can write a module, class, or library,
    and if it has an API, we can test it. However, if we need to test a user interface,
    it gets a little bit complex. Frameworks such as Jasmine and Mocha can run the
    code we write but can't visit a page, click a button, or send a form; at least,
    not alone. For such testing, we need to use a headless browser. A headless browser
    is a web browser without a user interface. There is a way to control it programmatically
    and perform actions such as accessing DOM elements, clicking on links, and filling
    forms. We are able to do the same things as we use a real browser. This gives
    us a really nice instrument to test the user interface. In the next few pages,
    we will see how to use a headless browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the subject of our test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to explore the possibilities of such testing, we need a simple site.
    Let''s create two pages. The first one will contain an input field and a button.
    The second page will be visited when the button on the first one is clicked. The
    page''s `h1` tag title will change depending on the text written in the field.
    Create a new directory and insert the following code in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We need only two of the Node.js native modules to launch our server. The `http`
    module runs the server, and the `url` module gets the `GET` parameters from the
    URL. The markup of the pages is stored in simple variables. There is a check in
    the handler of the HTTP request, which serves `pageB` if the form on `pageA` is
    submitted. If we run the server with `node app.js`, we will see how the pages
    look, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the subject of our test](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the text entered in the text field is set as the title of the second
    page. There is also a **back** button we can use to return to the home page. We
    have a subject to run our tests on. We''ll define the actions we need to verify
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the page properly rendered? We should check whether the tags of `pageA` are
    actually on the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should add some string to the text field and submit the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title of the newly loaded page should match the text that we entered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should be able to click on the **back** button and return to the home page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with PhantomJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know how our application is suppose to work, so let''s write the tests.
    The headless browser we will use is **PhantomJS**. Visit [http://phantomjs.org](http://phantomjs.org)
    and download the package suitable for your operating system. Like we did for Node.js,
    we will write our test in a JavaScript file and run it at the command line. Let''s
    say that our file structure looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing with PhantomJS](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that PhantomJS is not a Node.js module. The JavaScript code we
    write for PhantomJS is not exactly a valid Node.js code. We can't directly use
    native modules such as `assert`. Also, there isn't a test runner or test framework
    integrated. It's a browser based on **Webkit** but controlled from the command
    line or via the code. It comes across as binary, and once it is installed, we
    will be able to run the `phantom ./tests/phantom.js` command in our terminal.
    The test code will open `http://127.0.0.1:3000` and will interact with the pages
    there. Of course, the JavaScript community developed tools to combine testing
    frameworks such as Jasmine or Mocha with PhantomJS, but we are not going to use
    them in this chapter. We will write our own small utility—that's what the `framework.js`
    file is for.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the micro testing framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final result should be a simple function ready to use, such as `describe`
    or `it`, in Jasmine. It should also have something similar to the assertion library
    so we don''t have to use the usual `if-else` statements or report the failing
    test manually. In the following code, we can see the proper implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The function accepts description and function. The first argument is just printed
    out to the console, which indicates what we are going to test. Just after that,
    we call the passed `callback` function with another function as the parameter,
    which plays the role of an assertion library. It accepts the subject of testing
    and executes two methods against it: `toBe` and `toBeDefined`. The following is
    a simple usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, the result will be as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing the micro testing framework](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding how PhantomJS works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PhantomJS accepts instructions written in JavaScript. We can save them to a
    file and execute them via the command line by using the `phantom` command. Let''s
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `page` variable is an access to the PhantomJS API. There is a method, `open`,
    which loads a new page. We are mostly interested in two events dispatched from
    the headless browser. The first one, `onConsoleMessage`, is fired when the loaded
    page uses the `console` command, for example, `console.log` or `console.error`.
    The second event, `onLoadFinished`, is also quite important. We have a function
    that is called when the page is loaded. That''s the place where we should place
    our tests. Along with listening for events, we are going to use the following
    two other methods of PhantomJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`injectJs`: This method requires path to a file on our hard disk. The passed
    file is included on the page. We may also use `includeJs` that does the same thing,
    but it loads the file from an external source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Evaluate`: This method accepts a function that is executed in the context
    of the currently loaded page. This is important because we need to check whether
    certain elements are in the DOM tree. We need to interact with them by filling
    in the text field and clicking on a button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the actual test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start using PhantomJS, we need to run our application with `node
    ./app.js`. By doing this, we are running a server that listens on a particular
    port. PhantomJS will make requests to that server. Now, let''s start filling in
    the `tests/phantom.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already discussed, we are able to create a `page` variable and open
    a particular URL. In our case, we are using the address of the test application.
    The `onConsoleMessage` listener just prints out the message to our terminal. When
    the page loads, we inject our micro unit testing framework. This means that we
    are able to call the `test` function in the context of the page. If we run the
    script with `phantom ./tests/phantom.js`, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the actual test](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows exactly what should happen. The browser goes
    to the page and fires `onLoadFinished`. It's important to call `phantom.exit()`;
    otherwise, PhantomJS's process will stay active.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `framework.js` file is injected to the page and we can write the first
    test, that is, to check whether the title contains **First page**, fill in the
    test field, and submit the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The function that is executed by the `evaluate` method is run in the context
    of the page, so it gets an access to the usual document object. We are able to
    use the `getElementById`, `querySelector`, or `submit` methods. The script''s
    result obtained now is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the actual test](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it gets interesting. Indeed, the form is submitted, but we immediately
    called `phantom.exit()`, which terminates our script. If we remove it, the browser
    will stay active and the `onLoadFinished` event will be fired again because a
    new page is successfully loaded. However, the script fails because there is no
    text field or a `form` element on the next page. We need to evaluate another function.
    The following is one of the possible solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `steps` array is a global variable that contains a series of functions
    that need to be evaluated. On every `onLoadFinished` event, we are fetching one
    of those functions until the `steps` array is empty. This is where we call `phantom.exit()`
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the actual test](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: PhantomJS opens the home page. It enters **Phantom test** in the text field
    and submits the form. Then, on the next page, it checks whether the title contains
    the valid value, and when you click on the **back link** button, it loads the
    previous page again.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with DalekJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we learned how to test our JavaScript code. After that, we found out
    how to write user interface tests with Phantom.js. All these are really helpful,
    but it will be even better if we are able to run a real browser and control it.
    With DalekJS, this is possible. It's a really nice Node.js module that comes with
    a command-line interface tool and submodules for major browsers such as Google
    Chrome, Firefox, and Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how everything works and install the command-line tool of DalekJS
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick `npm install` command will create the `node_modules` directory with
    both dependencies included in it. DalekJS has a detailed documentation published
    on [http://dalekjs.com](http://dalekjs.com). It states that we can load pages,
    fill forms, and click on different DOM elements. It also comes with its own testing
    API, so we don''t have to think about this. The test we have to write is actually
    pretty short. The following is the content of `tests/dalek.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will make a request to `http://127.0.0.1:3000` and expect to see
    certain elements on the page. We will also enter some text inside the text field
    (the `type` method) and submit the form (the `submit` method). To run the test,
    we need to type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we skip the `-b` parameter, DalekJS will use Phantom.js. That''s the default
    browser type of the library. When the preceding command is launched at the terminal,
    a new instance of the Google Chrome browser is opened. It executes what we defined
    in the test and closes the browser. In order to get the example working, we need
    to run the application by executing `node ./app.js`. The result is reported to
    the console as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing with DalekJS](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can even make screenshots of the current browser''s screenshot. It''s simply
    calling the `screenshot` API method as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are making a screenshot of the second page, the one
    that is loaded after the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how important testing is. Thankfully, there are great
    tools available in the Node.js ecosystem. Frameworks such as Jasmine and Mocha
    make our life easier. Instruments such as Phantom.js save a lot of time by automating
    the testing and putting our code in a browser context. With DalekJS, we can even
    run tests directly in Firefox, Google Chrome, or Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to write flexible and modular CSS. Node.js
    has few great modules oriented for the frontend developers who write a lot of
    CSS.
  prefs: []
  type: TYPE_NORMAL
