- en: Chapter 4. Learn about Swipes through the making of Sokoban
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you know the Sokoban game? It's a funny puzzle game featuring a player pushing
    crates to some designated places. Normally, on a computer, these kinds of games—called
    tile-based games—are controlled by arrow keys, but since our game has to be cross-platform,
    we will let the player control in-game movements using swipes.
  prefs: []
  type: TYPE_NORMAL
- en: The game we will build is very similar to an iOS game I made called BWBan. It's
    free; you can play it at [http://bit.ly/1fUXP8c](http://bit.ly/1fUXP8c).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process of making this game, which we''ll call Cocosban, you will learn
    about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to detect swipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load graphic assets through a sprite sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create 8-bit-like pixel games by playing with anti-aliasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a lot to do, so let's start with the good old blueprint made in the
    first chapter and work on it.
  prefs: []
  type: TYPE_NORMAL
- en: Loading graphic assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Needless to say, the first thing you should do is place your graphic assets
    in the `assets` folder, but there is something new about this step.
  prefs: []
  type: TYPE_NORMAL
- en: In previous examples, we always filled our `assets` folder with one `PNG` image
    for each game actor—the spaceship and asteroid had their own image. This also
    applies for all Concentration tiles and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Cocos2d-JS has no problems in dealing with multiple images, but as a golden
    rule, remember the less images you have to deal with, the better your game performs.
  prefs: []
  type: TYPE_NORMAL
- en: So, where's the trick? In order to have a spaceship and an asteroid, you would
    think you have to load a spaceship image and an asteroid image, but there's another
    better way to do it, using **sprite sheets**.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite sheet is a single image made by combining various small images into
    it. If you are in to web designing, they are called **CSS sprites**, and if you
    have already made some native iOS applications, they are called texture atlases.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that you have to manually create a large image and place all
    your graphic assets inside of it? Well, although you can do it manually, there
    are several software solutions to speed up the process. The one I use and recommend
    to you is TexturePacker, which you can find at [www.codeandweb.com/texturepacker](http://www.codeandweb.com/texturepacker).
    It works with an intuitive drag-and-drop interface and supports Cocos2d export.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the four images I created for the game, directly from my Photoshop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading graphic assets](img/0075OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I would like you to notice the zoom factor of the images—actually, they are
    really tiny. Since we are making a pixel game, the image I made are really small,
    from 96 x 64 pixels for the title image down to 5 x 5 pixels for the crate and
    the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once processed by TexturePacker and exported to Cocos2d, your assets folder
    should contain the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading graphic assets](img/0075OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should easily recognize all previously drawn graphic assets packed into
    `spritesheet.png`, and you will wonder why we need the `spritesheet.plist` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open it and you will basically find an XML file with all the information for
    the images, from their original file names to their current sizes and coordinates
    inside `spritesheet.plist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In various Cocos2d-JS guides and references, this is referred to as a sprite
    sheet. Actually, it's more of a texture atlas; thanks to the XML file, which explains
    and describes each image included in the sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it''s time to load both files with `loadassets.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, `main.js` will set our resolution policy at 480 x 320 pixels in
    portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to create the game itself.
  prefs: []
  type: TYPE_NORMAL
- en: Building a level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, tile-based levels are stored in two-dimensional arrays, and Cocosban
    follows this trend. So, the first global variable we''ll declare in `gamescript.js`,
    which is an array containing level data, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each item represents a tile, and each value represents an item, which I coded
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: This item is an empty tile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: This item is a wall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: This item is the place where to drop a crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: This item is the crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: This item is the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5`: This item is the crate on a place where to drop a crate (3+2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6`: This item is the player on a place where to drop a crate (4+2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `gameScene` declaration is always the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we are ready to extend the `game` class.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, I want to quickly discuss mobile tile-based games.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the `level` array, you will see it's a *7x7=49* items array.
    This means we are going to place *49 tiles = 49 sprites* on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: That's OK, but placing stuff on the screen costs performance. Since we don't
    know on which devices our game will run, the less potentially moving stuff on
    the screen, the better the performances.
  prefs: []
  type: TYPE_NORMAL
- en: Since the only moving stuff in our game are the crates and the hero, while all
    wall and floor tiles always remain in their place, I simply hand-drew the level,
    adding only moveable characters as tiles.
  prefs: []
  type: TYPE_NORMAL
- en: You should do the same when designing for cross-platform purposes unless you
    are using random or procedurally generated content.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, this is how the `game` class is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, most of the code has already been explained in the previous
    chapters. We enable the game to be touch-driven and add some sprites on the stage.
    Just look at how I am loading the sprite sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how you can select a single image from a sprite sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, since our sprites are very, very tiny, they need to be scaled up.
    The `setScale` method allows us to scale sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to launch the game and see our sprites scaled up by 5x:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a level](img/0075OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is not a blurred, low-resolution image. It's the actual
    game as you will see on the screen, because Cocos2d-JS applies an anti-aliasing
    effect, which, in this case, wastes the 8-bit look we wanted to give the game.
    Anti-aliasing is very useful when you want to get smooth images, but will make
    your game look really bad if you plan to create a pixel game.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent anti-aliasing from being applied to a texture with the `setAliasTexParameters`
    method by just adding this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the game again, and you will see your pixel-perfect game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a level](img/0075OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also, I would like you to notice that the `setAliasTexParameters` method is
    called once and works on both sprites—and will work on every other sprite created
    in this game—because it's applied on the whole sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: At this time, we can create the player and the crates. They are just sprites
    manually positioned in the right place according to their position in the `level`
    array and the position of the level image in the stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the script to build the level has nothing to do with Cocos2d-JS
    since it''s pure JavaScript, so I am going to speed up a bit. First, I need three
    more global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cratesArray`: This is the array that will contain all crate sprites'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playerPosition`: This is the variable that will be used to store a player''s
    position inside the maze'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playerSprite`: This variable represents the player itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, after the line that added the `level` sprite, we can place the player
    and the crates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Did you see? Through pure JavaScript, we just added the crate sprite when the
    `level` array item is 3 or 5 and the player sprite when the `level` array item
    is 4 or 6.
  prefs: []
  type: TYPE_NORMAL
- en: The strange math operations are just used to place tiles in the right place
    according to their position.
  prefs: []
  type: TYPE_NORMAL
- en: 'This following screenshot is the result you should see when you run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a level](img/0075OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And that's it! You have your pixel level ready to be played. Let's detect player
    movements.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting swipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we analyze a swipe, we can break it down into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The player is touching the stage at a certain point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player is dragging their finger in a certain direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player is releasing the finger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By comparing the coordinates of the points where the drag started and ended,
    we can determine the direction of the swipe and move the player accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add three new global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Their names are quite self-explicative: `startTouch` and `endTouch` will store
    the starting and ending points of the swipe, while `swipeTolerance` is the minimum
    allowed distance in pixels between `startTouch` and `endTouch` in order to consider
    the whole action as a swipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will let `game` detect when a touch starts or ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we added a listener attached to a variable called `listener`, which
    we''ll define this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `onTouchBegan` function will register the initial touch and update the `startTouch`
    content; thanks to the `getLocation` method. Also, notice the function returns
    `true`. It's very important you make this function return `true`, or `onTouchEnded`
    won't be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies for `onTouchEnded`, which will update `endTouch`. Then, the
    `swipeDirection` function is called. It will allow us to move the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the game and the following screenshot is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting swipes](img/0075OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you swipe in a direction, the player moves accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens in the `swipeDirection` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Horizontal and vertical distances from the start to the end of the touch are
    calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole function is executed only if the sum of horizontal and vertical distances
    is greater than the minimum pixel tolerance allowed to say that the movement is
    actually a swipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to determine whether the player swiped horizontally or vertically.
    There''s no check to see whether a swipe was strictly horizontal or vertical;
    so, diagonal swipes will be seen as either horizontal or vertical, according to
    their biggest component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know whether the movement is horizontal or vertical, it''s time to
    check for the direction: left or right? Up or down? The rest of the code just
    checks for these questions and moves the player by 25 pixels accordingly. Unfortunately,
    you will be able to walk through crates and walls. It''s time to code game rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Completing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code I am about to write has nothing to do with Cocos2d-JS as it's just
    plain JavaScript, and explaining it would go beyond the scope of this book. I
    am just checking for legal moves and will move the player and the crates accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is managed by the `move` function, which will check for legal moves
    and update crates and player positions. The `move` function has two arguments,
    `deltaX` and `deltaY`, which represent the amount of tiles the player is trying
    to move horizontally or vertically.
  prefs: []
  type: TYPE_NORMAL
- en: This means `move(0,1)` will try to move the player up (0 tiles horizontally,
    1 tile vertically), `move(-1,0)` will try to move the player left, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `swipeDirection` function changes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A valid swipe is detected each time the `move` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `move` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Enjoy your game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use sprite sheets to manage your assets,
    create pixel-perfect games, and detect swipes. You also created a great puzzle
    game called Cocosban.
  prefs: []
  type: TYPE_NORMAL
- en: If you noticed, player and crate movements are made by making assets jump to
    their destination. Why don't you add a tween to create a smooth movement? It would
    be a great achievement for you to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there's no check to see whether the player completed the level. A completed
    level has no crates outside crate goals. Try to develop it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, follow me through a path full of music; we will add sound effects to our
    games!
  prefs: []
  type: TYPE_NORMAL
