<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Module Augmentation</h1></div></div></div><p>In the previous chapter, we started creating simple modules for our fictitious <strong>Images Inc.</strong> web application. In this chapter, we will take one of the modules that we have already built and add more <a id="id190" class="indexterm"/>functionality to it using an approach known as <strong>module augmentation</strong>.</p><p>This approach allows us to extend our modules without the need to change the original implementation. There are different techniques which can be used to implement module augmentation, and we will cover a couple of them in this chapter.</p><p>Module augmentation can be very useful when working on projects that have many contributors to the code base. This type of projects usually require us to extend our modules by adding new code and functionality to what has been already developed by other developers.</p><p>The concepts that we will cover in this chapter are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The idea behind module augmentation</li><li class="listitem" style="list-style-type: disc">Loose augmentation</li><li class="listitem" style="list-style-type: disc">Tight augmentation</li><li class="listitem" style="list-style-type: disc">Generating our application's content area</li><li class="listitem" style="list-style-type: disc">Module augmentation and script loading order</li><li class="listitem" style="list-style-type: disc">Advantages and disadvantage of different augmentation techniques</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec23"/>Principles of module augmentation</h1></div></div></div><p>As you saw in the previous chapter, we created specialized modules to do some specific tasks for us. However, as we move forward and develop our application further, we are going to require<a id="id191" class="indexterm"/> more functionality from our modules, and we will also require additional specialized modules.</p><p>When you are working on a large project, it is quite normal to have many developers working on various pieces of the application. It is also possible to have many developers work on the same part of the application together which requires a seamless approach for combining their efforts and the functionality that they add to the application.</p><p>Let's consider <a id="id192" class="indexterm"/>our <code class="literal">GlobalData</code> module from the previous chapter as an example. This module was responsible for storing and caching application-level data. However, in its current state, it holds a very limited amount of application-level data. It is quite feasible to assume that when different developers are working on other pieces of the application, they too need to store specific application-level data in the same module.</p><p>One way to do this, is by modifying the <code class="literal">GlobalData</code> module manually and adding more data and interfaces to it. But we need to keep in mind that the more people who modify the module, the higher possibility of something breaking in the module's code and for accidental modification to the important application-level data in an undesirable way.</p><p>On the other hand, the original module file may not be accessible to some developers for various reasons, which may hinder the cooperative development of our application.</p><p>What if we could come up with a way which would enable each developer to add the required functionality to the original module without the need to modify or require the original module's code?</p><p>Module augmentation allows us to do just that in a very robust way. As the name implies, this concept is about adding functionality (properties) to the original module, without changing the original module's code directly. The general idea is that we can create a namespace which imports the original module at runtime and then adds new functionality to it as required.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Implementing module augmentation</h1></div></div></div><p>Imagine<a id="id193" class="indexterm"/> that we have a module called <code class="literal">ModuleA</code> and, as a developer, you want to add more functionality to this module. However, for some reason, you decide to implement this new functionality in a completely separate module and then dynamically augment the original module with all the data and capabilities of this new module. You can achieve this as shown here:</p><div><pre class="programlisting">var ModuleA = (function(coreModule){
    var someData = "this is some data to be used later";
    coreModule.someMethod = function(){
        return someData;
    };

    return coreModule;
})(ModuleA);</pre></div><p>As you can see, we are again using the module pattern here, as the intent is to add the new functionality in a modular fashion.</p><p>In this <a id="id194" class="indexterm"/>IIFE, a reference to <code class="literal">coreModule</code> object is returned.. There is, however, one important thing to keep in mind here. We are passing <code class="literal">ModuleA</code> as a parameter to our anonymous container function. Also, the property <code class="literal">someMethod</code> is being added to the passed-in <code class="literal">coreModule</code>, which is in fact a reference to <code class="literal">ModuleA</code>.</p><p>Therefore, at the end of this function execution, <code class="literal">ModuleA</code> has a new property method called <code class="literal">someMethod</code>, which has access to the value of <code class="literal">someData</code> variable.</p><p>There is one assumption that we are making here. We are assuming that <code class="literal">ModuleA</code> does exist as an object, and if not, we will get an execution error when we run the preceding code. You will see shortly how we can fix this issue, but for now, let's take this augmentation concept and use it to extend <code class="literal">ImagesInc_GlobalData</code> module in our application.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>
<strong>Module naming conventions</strong>
</p><p>As we are <a id="id195" class="indexterm"/>getting more involved with module implementation in our application, it is best to use more specific naming for our modules. Generally speaking, it is a good idea to use names that are as specific as possible for our modules. This minimizes the chance of naming conflicts between our application modules and third-party modules that we might be loading in our application. For this reason, as we move forward, we will be adding <code class="literal">ImagesInc_</code> prefix to all of our module names, to make the names more specific to our application.</p><p>It is also worth mentioning that some developers choose to use all capital lettering for the name of their modules in the code, as a convention. We will not be using this convention in our application. In your own coding practices, whether to use all capital lettering for your module names or not is something that you should decide on with your team. This is so you can establish a set of standards which all the members of the team would be required to follow.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Simple augmentation of ImagesInc_GlobalData</h1></div></div></div><p>As you may<a id="id196" class="indexterm"/> recall, we used <a id="id197" class="indexterm"/>our <code class="literal">ImagesInc_GlobalData</code> module (previously named <code class="literal">GlobalData</code>) to store application-level data for us. This module also provided a couple of interfaces, so other pieces of the application could have access to the private data that we had stored in this module.</p><p>Let's create <a id="id198" class="indexterm"/>another JavaScript file, which <a id="id199" class="indexterm"/>adds more data and a new interface to this module. We can call this file <code class="literal">Modules_2.js</code> and add it to the list of JavaScript files that our main page loads at runtime, as follows:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/Modules.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/Modules_2.js" &gt;&lt;/script&gt;</pre></div><p>As you can see, this file is added as any other JavaScript file would be in our <code class="literal">index.html</code>. However, one thing to notice in the preceding code is the order that the two module files have been added. This order is important and we will talk more about it shortly, but for now, keep in mind that our <code class="literal">ImageInc_GlobalData</code> module is loaded first in our application (as it resides in <code class="literal">Modules.js</code>). Then, the code residing in <code class="literal">Modules_2.js</code> will add more functionality to this module, as it is loaded afterwards.</p><p>We need to add the following lines of code to <code class="literal">Modules_2.js</code>:</p><div><pre class="programlisting">(function(coreModule){
    
    coreModule.someText = "this is a test for module augmentation";
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };

})(ImagesInc_GlobalData);</pre></div><p>Here, we have used an<a id="id200" class="indexterm"/> anonymous function to create a <strong>namespace</strong>, using an IIFE. We have also passed in a reference to the <code class="literal">ImagesInc_GlobalData</code> object (module) in the form of a parameter to this function.</p><p>Inside this anonymous function, we have added two properties to the passed-in object reference, <code class="literal">coreModule</code>. This means that our <code class="literal">ImagesInc_GlobalData</code> now has two new properties added to it. Let's verify this by running a test, as follows:</p><div><pre class="programlisting">// displays "this is a test for module augmentation"
ImagesInc_GlobalData.getExtendedModuleMsg(); </pre></div><p>When we call <code class="literal">getExtendedModuleMsg</code> method on <code class="literal">ImagesInc_GlobalData</code> object, we see that the code runs properly and the expected message is shown in the console.</p><p>As the <code class="literal">ImagesInc_GlobalData</code> module did not originally have the method <code class="literal">getExtendedModuleMsg</code>, it now appears that it has been augmented with these new properties.</p><p>This simple <a id="id201" class="indexterm"/>example demonstrates how<a id="id202" class="indexterm"/> we can augment our original module without directly modifying the code in that module. We also saw that the augmentation can be done in a separate file, which means a different developer could add more functionality to our original module, without ever having direct access to the original module's code file.</p><p>Of course, this type of augmentation can just as easily be done when both the original module and the augmenting code are in the same file. It is good to have the flexibility to pick and choose which approach we would like to take: to either have the original module and its augmenting code in separate files or in the same file.</p><p>We will soon talk about this type of augmentation in greater depth, and will even give it a technical name.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>The order of things in module augmentation</h1></div></div></div><p>When we added <code class="literal">Modules_2.js</code> file to our <code class="literal">index.html</code>, I mentioned that we need to load this file after we load <code class="literal">Modules.js</code> file for things to work properly.</p><p>The reason<a id="id203" class="indexterm"/> for this is not hard to discover. If the order of loading these files is reversed, and subsequently the order of the code execution, we will be trying to add properties to an object (<code class="literal">ImagesInc_GlobalData</code>) that does not exist yet, which will result in a code execution error.</p><p>There are <a id="id204" class="indexterm"/>ways that we can work around this, which brings us to our next topic, <strong>loose augmentation</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Loose augmentation of modules</h1></div></div></div><p>When we try to <a id="id205" class="indexterm"/>enhance a module using the augmentation<a id="id206" class="indexterm"/> technique previously discussed, we pass a reference of the module to another part of our code which is responsible for doing the augmentation work.</p><p>How can we add functionality to an object that has not been loaded or created yet?</p><p>The answer to this question becomes very important when our modules (files) are loaded in an asynchronous fashion, and we have no way of making sure that our original module is loaded before the augmentation code that enhances the module.</p><p>One of the beautiful and powerful aspects of JavaScript is its ability to add properties to objects dynamically, at any time during code execution. This allows us to add functionality or modify our original module's implementation even before the module is loaded, as long as we provide a temporary object in the absence of the module. This temporary object will be added to the original module after the module is loaded (or more accurately, it becomes one with the original module).</p><p>If it sounds <a id="id207" class="indexterm"/>complicated, it really is simpler than you think. Let's<a id="id208" class="indexterm"/> revisit our previous augmenting code and examine it a little closer:</p><div><pre class="programlisting">(function(coreModule){
    
    coreModule.someText = "this is a test for module augmentation";
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };

})(ImagesInc_GlobalData);</pre></div><p>I mentioned that for the augmentation to work properly, we needed to load this code, which is responsible for augmenting the <code class="literal">ImageInc_GlobalData</code> module, after the original module is loaded. Otherwise, a code execution error will be thrown. While that remains true, what if we compensate for when <code class="literal">ImagesInc_GlobalData</code> does not yet exist in the application by using an empty object?</p><p>As you probably know, we can call a function as follows:</p><div><pre class="programlisting">someFunc(someParameter || someotherParameter);</pre></div><p>When we do this, we are telling the JavaScript interpreter to pass <code class="literal">someParameter</code> when calling <code class="literal">someFunc</code>, if it has a value; and if not, pass <code class="literal">someotherParameter</code> to the function. That is how the <code class="literal">||</code> operator works in the preceding code snippet.</p><p>We can use the same technique and pass an empty object to our anonymous function, as follows:</p><div><pre class="programlisting">(ImagesInc_GlobalData || {});</pre></div><p>We tell the interpreter to pass a reference of our <code class="literal">ImagesInc_GlobalData</code> object when calling the function, if the object exists, or pass a reference of an empty object which will replace our original module for the time being.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Loose augmentation of ImagesInc_GlobalData</h2></div></div></div><p>Let's rewrite <a id="id209" class="indexterm"/>our previous augmenting <a id="id210" class="indexterm"/>code for <code class="literal">ImagesInc_GlobalData</code> as follows:</p><div><pre class="programlisting">var ImagesInc_GlobalData = (function(coreModule){
    
    coreModule.someText = "this is a test for loose module augmentation";
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };

    return coreModule;

})(ImagesInc_GlobalData || {});</pre></div><p>In the preceding<a id="id211" class="indexterm"/> code, we are calling <a id="id212" class="indexterm"/>our anonymous function and passing a reference of <code class="literal">ImagesInc_GlobalData</code> to it, if <code class="literal">ImagesInc_GlobalData</code> does exist. Otherwise, we are passing a reference to an anonymous empty object into the function.</p><p>Our augmenting code still adds new properties to the passed-in object; however, this time it returns a reference to <code class="literal">coreModule</code> to the <code class="literal">ImagesInc_GlobalData</code> variable.</p><p>For everything to work properly, we also need to modify our original <code class="literal">ImagesInc_GlobalData</code> as follows:</p><div><pre class="programlisting">var ImagesInc_GlobalData = (<strong>function(module)</strong>{
    
    var headerContainerDef = {
 
    sectionHTML :  '&lt;div class="logo_titleClass" &gt;' +
                '&lt;a href=""&gt;&lt;img src="img/ImagesIncLogo.png" alt="Company Logo" style="max-height:100%;"&gt;&lt;/a&gt;' +
                '&lt;div class="siteTitleClass"&gt;Images Inc.&lt;/div&gt;' +
        '&lt;/div&gt;' +
        '&lt;nav role="navigation" itemscope itemtype="https://schema.org/SiteNavigationElement"&gt;' +
            '&lt;h1 class="hiddenClass"&gt;Main Navigation&lt;/h1&gt;' +
            '&lt;ul class="navmenuClass" &gt;' +
                '&lt;li&gt;&lt;a href="#" class="active"&gt;Home&lt;/a&gt;&lt;/li&gt;' +
                '&lt;li&gt;&lt;a href="#"&gt;Our Company&lt;/a&gt;&lt;/li&gt;' +
                '&lt;li&gt;&lt;a href="#"&gt;Pricing&lt;/a&gt;&lt;/li&gt;' +
                '&lt;li&gt;&lt;a href="#"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;' +
            '&lt;/ul&gt;' +
        '&lt;/nav&gt;' 
    };
    
    var footerContainerDef = {

        sectionHTML:'&lt;div&gt;' +
                   '&lt;a href="#"&gt;Latest News&lt;/a&gt;' +
                '&lt;/div&gt;' +
                '&lt;div&gt;' +
                    '&lt;a href="#"&gt;Services&lt;/a&gt;' +
                '&lt;/div&gt;' +
                '&lt;div&gt;' +
                    '&lt;a href="#"&gt;Support&lt;/a&gt;' +
                '&lt;/div&gt;'
    };
    
    <strong>module.getHeaderHTMLTxt= function(){</strong>
<strong>        return headerContainerDef.sectionHTML;</strong>
<strong>    };</strong>

<strong>    module.getFooterHTMLTxt= function(){</strong>
<strong>        return footerContainerDef.sectionHTML;</strong>
<strong>    };</strong>

    return module;
   
})(<strong>ImagesInc_GlobalData || {}</strong>);</pre></div><p>As you can see, we have made a few modifications to the code.</p><p>If you recall, we<a id="id213" class="indexterm"/> used to create an <a id="id214" class="indexterm"/>anonymous object in our original module and return a reference to it like so:</p><div><pre class="programlisting">return {
        
            getHeaderHTMLTxt: function(){
                return headerContainerDef.sectionHTML;
            },
        
            getFooterHTMLTxt: function(){
                return footerContainerDef.sectionHTML;
            }
    };</pre></div><p>However, in our new augmenting implementation we are adding our module interface methods directly to the module object that is passed into the anonymous function. Also, the module object passed into our anonymous function is either a reference to <code class="literal">ImagesInc_GlobalData</code> or a reference to an empty object.</p><p>There is one other subtle point to notice here. Both the augmenting code and our original module code are returning an object reference to the <code class="literal">ImagesInc_GlobalData</code> variable, and this is very important.</p><p>To explain this point, we need to dig a little deeper. There are times in our applications that the module code and the code that is augmenting it are loaded asynchronously. This means that we cannot be sure ahead of time which code is executed first. When we return a reference to our object from both the original module and the augmenting code, we can be sure that regardless of the code execution order, our module is augmented properly.</p><p>In our example, if there is an <code class="literal">ImagesInc_GlobalData</code> object that already exists in the global namespace, we augment it with the new properties, and if not, we create it and then add new properties to it. That is why in both instances (the original module code and the augmenting code), we execute our IIFE with the following call:</p><div><pre class="programlisting">(ImagesInc_GlobalData || {});</pre></div><p>This provides us with the ability to create or augment our module in a non-strict order, hence the term <strong>loose augmentation</strong>.</p><p>Of course, the <a id="id215" class="indexterm"/>main advantage<a id="id216" class="indexterm"/> of this technique is that we don't have to worry about which file is loaded first; either way, our module is created and augmented as intended.</p><p>Keep in mind that in both cases, we need to make sure that we create the same global variable, <code class="literal">ImagesInc_GlobalData</code>, so that when we check for the existence of this object in the global namespace, the correct reference is passed in.</p><p>It is time to put our code to the test. After making the modifications mentioned previously, we can run the following line of code:</p><div><pre class="programlisting">// displays "this is a test for module augmentation"
ImagesInc_GlobalData.getExtendedModuleMsg(); </pre></div><p>As you can see, the correct message is shown in the console. Now, let's see what happens if we change the order in which our JavaScript module files are loaded in the application.</p><p>First, we make the following change in our <code class="literal">index.html</code> file:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/Modules_2.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/Modules.js" &gt;&lt;/script&gt;</pre></div><p>This is to make sure that our augmenting code is loaded first. Then we execute the same line of code as before:</p><div><pre class="programlisting">// displays "this is a test for module augmentation"
ImagesInc_GlobalData.getExtendedModuleMsg();</pre></div><p>We can see that both our original module and our augmenting code are working as expected, regardless of which was loaded and executed first.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec31"/>Testing ImagesInc_GlobalData data encapsulation</h2></div></div></div><p>We can test and<a id="id217" class="indexterm"/> see how encapsulation and privacy have been preserved in our module. This can be done by running the following code:</p><div><pre class="programlisting">try{
        console.log(ImagesInc_GlobalData.headerContainerDef.sectionHTML);
        
    }catch(e){
        ImagesInc_LoggingHandler.logError('could not access the property');
    }</pre></div><p>This code will display <strong>could not access the property</strong> in the console, which confirms our original module encapsulation is still in effect, as we would like it to be.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>
<strong>A note about the project code</strong>
</p><p>As always, I <a id="id218" class="indexterm"/>highly recommend that you download the related code for this chapter from the accompanying website for this book. In the code for this chapter, I have created a new file called <code class="literal">AppTester.js</code>, which is used to test the application as we modify and enhance it. I recommend this approach of testing our application every time we run it during the development phase. This is so we can be sure that our changes in one part do not cause any problems in other parts of the application. This is also aligned <a id="id219" class="indexterm"/>with <strong>Test-Driven Development</strong> (<strong>TDD</strong>) approach, but in a very rudimentary way.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Tight augmentation of modules</h1></div></div></div><p>So far in this <a id="id220" class="indexterm"/>chapter, we have talked about what module augmentation is<a id="id221" class="indexterm"/> in general and have also covered the loose augmentation technique. It is time to explore a different technique used in augmenting modules, known as <strong>tight augmentation</strong>.</p><p>You might wonder if tight augmentation is the opposite of loose augmentation, and you are correct to think that, but with a couple of considerations which we will talk about a little later.</p><p>Tight augmentation is used for adding properties (functionality) to our modules when we do want to enforce a set order of file loading and code execution, and therefore it is less flexible. This type of augmentation is usually used when we need to make sure that a certain property from the original module is available for our augmenting code.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Tight augmentation of ImagesInc_GlobalData</h2></div></div></div><p>Consider our<a id="id222" class="indexterm"/> augmenting<a id="id223" class="indexterm"/> code for <code class="literal">ImagesInc_GlobalData</code> module from the previous section, when loose augmentation was being used. As mentioned previously, since we are passing a reference to <code class="literal">ImagesInc_GlobalData</code> or an empty anonymous object into our IIFE, we can load our original module and our augmenting code in any order that we like.</p><p>This was shown as follows:</p><div><pre class="programlisting">var ImagesInc_GlobalData = (function(coreModule){
    
    coreModule.someText = "this is a test for loose module augmentation";
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };

    return coreModule;

})(ImagesInc_GlobalData || {});</pre></div><p>However, this also means that if we wanted to override one of the original module's properties, depending on what code gets loaded and executed first (the original module or the augmenting code), our "override" might be overridden by another piece of code, unintentionally and unexpectedly.</p><p>To understand this better, let's create another file, <code class="literal">Modules_3.js</code>, and add the following code to it:</p><div><pre class="programlisting">var ImagesInc_GlobalData = (function(coreModule){
    
    coreModule.someText = "this is a test for overriding module properties with loose augmentation";
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };
    return coreModule;

})(ImagesInc_GlobalData || {});</pre></div><p>Also, let's load this file in our application as follows:</p><div><pre class="programlisting">&lt;script type="text/javascript" async src="img/Modules_3.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"   src="img/Modules_2.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"   src="img/Modules.js" &gt;&lt;/script&gt;</pre></div><p>Here we are loading two files (<code class="literal">Modules_3.js</code> and <code class="literal">Modules_2.js</code>), which augment our original module. <code class="literal">Modules_2.js</code> is being loaded before <code class="literal">Modules.js</code>, but <code class="literal">Modules_3.js</code> can be loaded in any order since we are using the <code class="literal">async</code> property on the <code class="literal">&lt;script&gt;</code> tag for this file. This property tells the browser to load the file in any order that it can.</p><p>Both of these <a id="id224" class="indexterm"/>augmenting codes add the <a id="id225" class="indexterm"/>same property, <code class="literal">coreModule.someText</code>, to the original module. However, depending on which code is loaded and executed first, only one of two pieces of text will be printed in the console.</p><p>We can test this by executing the following code:</p><div><pre class="programlisting">ImagesInc_GlobalData.getExtendedModuleMsg();</pre></div><p>The console will display one of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>this is a test for module augmentation</strong> (from <code class="literal">Modules_2.js</code>)</li><li class="listitem" style="list-style-type: disc"><strong>this is a test for overriding module properties with loose augmentation</strong> (from <code class="literal">Modules_3.js</code>)</li></ul></div><p>Keep in mind that in this scenario, we have no control over which one of the strings will be the value of the <code class="literal">coreModule.someText</code> property after all the code execution is completed. This is because we don't know which augmenter code will be loaded and executed last. This also means that by using loose augmentation technique and asynchronous loading, augmenter code precedence is determined dynamically at runtime and not necessarily in the order that we think or desire.</p><p>On such basis, if our intent was that the value of <code class="literal">coreModule.someText</code> should be overridden by the code in <code class="literal">Modules_3.js</code>, then we could not be sure of such an override taking place.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>
<strong>Simulating asynchronous script loading</strong>
</p><p>To simulate the<a id="id226" class="indexterm"/> asynchronous loading of our augmenters, you can reload the <code class="literal">index.html</code> page a few times in a row (from the application code accompanying this chapter). You'll see that the message displayed in the console may change from time to time. The message displayed depends on which file, <code class="literal">Modules_2.js</code> or <code class="literal">Modules_3.js</code>, is loaded first by the browser.</p></div></div><p>Tight augmentation, on the other hand, guarantees the order of code execution and therefore how our modules get augmented. By using this technique, we can be sure that when a module property is overridden, it will be in the order that we intended and the result will be as expected.</p><p>This guarantee is provided by the fact that we don't have any choice but to load our module and its augmenting code in the correct order, otherwise a code execution error will be generated.</p><p>Let's examine this by modifying the code in our <code class="literal">Moduels_3.js</code> as follows:</p><div><pre class="programlisting">var ImagesInc_GlobalData = (function(coreModule){
    
    if(!coreModule){
        ImagesInc_LoggingHandler.logError('coreModule was not found to be augmented!');
        alert('coreModule was not found to be augmented!');
        return false;
        
    }
    
    coreModule.someText = "this is a test for overriding module properties with TIGHT augmentation";
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };

    return coreModule;

})(ImagesInc_GlobalData);</pre></div><p>In this<a id="id227" class="indexterm"/> version of the augmenting <a id="id228" class="indexterm"/>code, we are no longer passing in a reference to an empty anonymous object to our IIFE. Therefore, if <code class="literal">ImagesInc_GlobalData</code> module has not been already loaded, we cannot augment it with any new properties.</p><p>Note that at the start of the preceding code we are checking to see whether <code class="literal">coreModule</code> exists, and if not we are using our <code class="literal">ImagesInc_LoggingHandler</code> module to log an error to the console. We are also using an alert box in the browser to make sure that the situation really catches the user's attention (try not to use alert boxes in production code as it looks unprofessional; I'm just using it here for ease of demonstration).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Loading ImagesInc_GlobalData augmenting code</h2></div></div></div><p>To examine how<a id="id229" class="indexterm"/> tight augmentation enforces a set order of script loading and code execution, we can change our <code class="literal">index.html</code> as follows:</p><div><pre class="programlisting">&lt;script type="text/javascript"   src="img/Modules_3.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"   src="img/Modules_2.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"   src="img/Modules.js" &gt;&lt;/script&gt;</pre></div><p>As you can see, we are no longer loading the <code class="literal">Modules_3.js</code> file asynchronously and it will be the first module-related file that gets loaded. Considering that we have modified the augmenting<a id="id230" class="indexterm"/> code in this file to only augment the module when the module (<code class="literal">ImagesInc_GlobalData</code>) is already present in the global scope, an error message will be logged and an <strong>alert box</strong> will be displayed in the<a id="id231" class="indexterm"/> browser when we load the page.</p><p>Because we are using the tight augmentation technique now, we need to load this augmenting code after either <code class="literal">Modules.js</code> or <code class="literal">Modules_2.js</code>. This is necessary so we can be sure that the <code class="literal">ImagesInc_GlobalData</code> module (object) is already present in the global scope.</p><p>Also, since our intention is to override the value of <code class="literal">someText</code> by using the code in <code class="literal">Modules_3.js</code>, and this property was added to the module by the augmenting code in <code class="literal">Modules_2.js</code>, we need to load both <code class="literal">Modules.js</code> and <code class="literal">Modules_2.js</code> first. This is the only way we can guarantee that an override of the value of <code class="literal">someText</code> is taking place as intended.Therefore, to achieve the proper override, we need to modify the loading order of our scripts as follows:</p><div><pre class="programlisting">&lt;script type="text/javascript"   src="img/Modules.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"   src="img/Modules_2.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"   src="img/Modules_3.js" &gt;&lt;/script&gt;</pre></div><p>This rearrangement of the order of scripts in our <code class="literal">index.html</code> file ensures that the override of the value of the <code class="literal">someText</code> property for the module will produce the expected result. This is of course, because our original module is loaded first, then it is augmented with the <code class="literal">someText</code> property, using the augmenting code in <code class="literal">Modules_2.js</code>. At the end, the value of this property is overridden by the tight augmenting code in <code class="literal">Module_3.js</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Considerations in tight augmentation</h2></div></div></div><p>At the beginning <a id="id232" class="indexterm"/>of this section, I mentioned that there are a couple of considerations regarding tight augmentation that we need to keep in mind.</p><p>First, we do not really need to create a global variable to store the returned value from the augmenting code that implements the tight augmentation technique.</p><p>This is so since this type of augmentation can only take place if the module already exists in the global context. In fact, the following code will work just as well as the previous version:</p><div><pre class="programlisting">(function(coreModule){
    
    if(!coreModule){
        ImagesInc_LoggingHandler.logError('coreModule was not found to be augmented!');
        alert('coreModule was not found to be augmented!');
        return false;
        
    }
    
    coreModule.someText = "this is a test for overriding module properties with TIGHT augmentation!!!";
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };

})(ImagesInc_GlobalData);</pre></div><p>Second, before <a id="id233" class="indexterm"/> we override a property that already exists in the module, we can preserve the original value of the property by storing it in another property. This allows us to have access to both the original value of the property and its overridden value.</p><p>Let's do that in our <code class="literal">Modules_3.js</code> file, as follows:</p><div><pre class="programlisting">(function(coreModule){
    
    if(!coreModule){
        ImagesInc_LoggingHandler.logError('coreModule was not found to be augmented!');
        alert('coreModule was not found to be augmented!');
        return false;
        
    }
    
    coreModule.original_someText = coreModule.someText;
    
    coreModule.someText = "this is a test for overriding module properties with TIGHT augmentation!";
    
    coreModule.getExtendedModuleMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.someText);
    };
    coreModule.getExtendedModuleOriginalMsg = function(){
        ImagesInc_LoggingHandler.logInfo(coreModule.original_someText);
    };

})(ImagesInc_GlobalData);</pre></div><p>We can get the original value of the <code class="literal">someText</code> property by running the following in the console:</p><div><pre class="programlisting">// displays ""this is a test for module augmentation"
ImagesInc_GlobalData.getExtendedModuleOriginalMsg();</pre></div><p>As you can <a id="id234" class="indexterm"/>see, not only tight augmentation technique is a nice way to override our module properties, it also allows us to hold on to the original (previous) values of our properties, in case we ever need to use them again.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Generating our application's content area</h1></div></div></div><p>If you have read the previous sections of this chapter, you have a pretty good grasp of what module augmentation is by now. You also know of a couple of techniques to add dynamic <a id="id235" class="indexterm"/>properties to our modules using augmentation.</p><p>As it stands, our application (<code class="literal">Images Inc.</code>) has code that dynamically generates the header and footer sections of our pages. But we still have an empty space in the middle (the content area), which needs to be populated with content.</p><p>Let's put the techniques that we have learned in this chapter to good use and add functionality to our application that will generate the content area dynamically.</p><p>Note that the refactored augmenting code in <code class="literal">Modules_3.js</code> is now as follows:</p><div><pre class="programlisting">(function(originalModule){
    
    if(!originalModule){
        ImagesInc_LoggingHandler.logError('originalModule was not found to be augmented!');
        return false;  
    }
    
    //object definition for the index.html content area
    originalModule.mainContentContainerDef = {
         sectionHTML: (function(){
                var htmlStr = "";

                for(var i=0; i&lt;=15; i++){
                    htmlStr += '&lt;div class="productDiv"&gt;&lt;/div&gt;';
                }
                return htmlStr; 
            })()
        
    }; 
    
    originalModule.getContentAreaHTMLTxt= function(){
        return originalModule.mainContentContainerDef.sectionHTML;
    };

})(ImagesInc_GlobalData);</pre></div><p>A few things<a id="id236" class="indexterm"/> have happened here. As you can see, we are using tight augmentation to augment our <code class="literal">ImagesInc_GlobalData</code> module. We have also created a new property for this module, <code class="literal">originalModule.mainContentContainerDef</code>, which holds the object definition for the content area of the page. Since the content area uses a repeated structure of rectangles to display the desired images on the page, we have used an inner IIFE, which creates that structure and stores it in <code class="literal">sectionHTML</code> property of the content area object definition as a string.</p><p>In order for the external code to have access to this string, and to be able to render the content area of our <code class="literal">index.html</code> page, we have created <code class="literal">originalModule.getContentAreaHTMLTxt</code> method. This is added as an interface to our original <code class="literal">ImagesInc_GlobalData</code> module.</p><p>When we load the application's <code class="literal">index.html</code> page now, it is displayed as shown here:</p><div><img src="img/B04910_05_01.jpg" alt="Generating our application's content area"/></div><p>Of course, for the time being, I'm using the previous color coding schema that you have seen before for our various page fragments. For ease of identification, the image boxes are shown in pink (if you are reading the book in color).</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>
<strong>A caveat to keep in mind</strong>
</p><p>In our augmenting code, we added the <code class="literal">mainContentContainerDef</code> property to our module without using a closure. Therefore, this property is not implemented with the same type of encapsulation and private access as <code class="literal">headerContainerDef</code> and <code class="literal">footerContainerDef</code>. These properties were defined in our original module as private variables, and access to them was only possible through the interfaces that we created for external use. Of course, we created that private access using a closure.</p><p>If you'd like to restrict access to them in your modules, it is best to define the properties in the original modules (using closures) as opposed to adding them to the modules using the augmentation techniques (unless you use closures in your augmenting code too).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, we covered what module augmentation is and explored a couple of different techniques, known as loose augmentation and tight augmentation, to implement module augmentation.</p><p>We saw how each approach is used in different circumstances and for different application requirements, as well as the pros and cons related to each technique.</p><p>The order in which scripts should be loaded was also discussed, based on the augmentation technique used.</p><p>Once we had a good grasp of these augmentation implementations, we refactored part of our application code to augment <code class="literal">ImagesInc_GlobalData</code> module. Subsequently, we generated the content area of <code class="literal">index.html</code> page and populated it with containers, which will host the images for our application in the future.</p><p>In the next chapter, we will look at some more techniques in modular design which will enable us to extend and clone our modules as needed.</p></div></body></html>