["```js\n// Creates a timer that calls our function in no less\n// than 300MS. We can use the \"console.time()\" and the\n// \"console.timeEnd()\" functions to see how long it actually\n// takes.\n//\n// This is typically around 301MS, which isn't at all \n// noticeable by the user, but is unreliable for\n// accurately scheduling function calls.\nvar timer = setTimeout(() => {\n    console.timeEnd('setTimeout');\n}, 300);\n\nconsole.time('setTimeout');\n```", "```js\n// Be careful, this function hogs the CPU...\nfunction expensive(n = 25000) {\n    var i = 0;\n    while (++i < n * n) {}\n    return i;\n}\n\n// Creates a timer, the callback uses\n// \"console.timeEnd()\" to see how long we\n// really waited, compared to the 300MS\n// we were expecting.\nvar timer = setTimeout(() => {\n    console.timeEnd('setTimeout');\n}, 300);\n\nconsole.time('setTimeout');\n\n// This takes a number of seconds to\n// complete on most CPUs. All the while, a\n// task has been queued to run our callback\n// function. But the event loop can't get\n// to that task until \"expensive()\" completes.\nexpensive();\n```", "```js\n// A counter for keeping track of which\n// interval we're on.\nvar cnt = 0;\n\n// Set up an interval timer. The callback will\n// log which interval scheduled the callback.\nvar timer = setInterval(() => {\n    console.log('Interval', ++cnt);\n}, 3000);\n\n// Block the CPU for a while. When we're no longer\n// blocking the CPU, the first interval is called,\n// as expected. Then the second, when expected. And\n// so on. So while we block the callback tasks, we're\n// also blocking tasks that schedule the next interval.\nexpensive(50000);\n```", "```js\n// A generic event callback, logs the event timestamp.\nfunction onClick(e) {\n    console.log('click', new Date(e.timeStamp));\n}\n\n// The element we're going to use as the event\n// target.\nvar button = document.querySelector('button');\n\n// Setup our \"onClick\" function as the\n// event listener for \"click\" events on this target.\nbutton.addEventListener('click', onClick);\n\n// In addition to users clicking the button, the\n// EventTarget interface lets us manually dispatch\n// events.\nbutton.dispatchEvent(new Event('click'));\n```", "```js\n// Keeps track of the number of \"mousemove\" events.\nvar events = 0;\n\n// The \"debounce()\" takes the provided \"func\" an limits\n// the frequency at which it is called using \"limit\"\n// milliseconds.\nfunction debounce(func, limit) {\n    var timer;\n\n    return function debounced(...args) {\n        // Remove any existing timers.\n        clearTimeout(timer);\n\n        // Call the function after \"limit\" milliseconds.\n        timer = setTimeout(() => {\n            timer = null;\n            func.apply(this, args);\n        }, limit);\n    };\n}\n\n// Logs some information about the mouse event. Also log\n// the total number of events.\nfunction onMouseMove(e) {\n    console.log(`X ${e.clientX} Y ${e.clientY}`);\n    console.log('events', ++events);\n}\n\n// Log what's being typed into the text input.\nfunction onInput(e) {\n    console.log('input', e.target.value);\n}\n\n// Listen to the \"mousemove\" event using the debounced\n// version of the \"onMouseMove()\" function. If we \n// didn't wrap this callback with \"debounce()\"\nwindow.addEventListener('mousemove', debounce(onMouseMove, 300));\n\n// Listen to the \"input\" event using the debounced version\n// of the \"onInput()\" function to prevent triggering events\n// on every keystroke.\ndocument.querySelector('input')\n    .addEventListener('input', debounce(onInput, 250));\n```", "```js\n// Callback for successful network request,\n// parses JSON data.\nfunction onLoad(e) {\n    console.log('load', JSON.parse(this.responseText));\n}\n\n// Callback for problematic network request,\n// logs error.\nfunction onError() {\n    console.error('network', this.statusText || \n        'unknown error');\n}\n\n// Callback for a cancelled network request,\n// logs warning.\nfunction onAbort() {\n    console.warn('request aborted...');\n}\n\nvar request = new XMLHttpRequest();\n\n// Uses the \"EventTarget\" interface to attach event \n// listeners, for each of the potential conditions.\nrequest.addEventListener('load', onLoad);\nrequest.addEventListener('error', onError);\nrequest.addEventListener('abort', onAbort);\n\n// Sends a \"GET\" request for \"api.json\".\nrequest.open('get', 'api.json');\nrequest.send();\n```", "```js\n// The function that's called when a response arrives ,\n// it's also responsible for coordinating responses.\nfunction onLoad() {\n\n    // When the response is ready, we push the parsed\n    // response onto the \"responses\" array, so that we\n    // can use responses later on when the rest of them\n    // arrive.\n    responses.push(JSON.parse(this.responseText));\n\n    // Have all the respected responses showed up yet?\n    if (responses.length === 3) {\n        // How we can do whatever we need to, in order\n        // to render the UI component because we have\n        // all the data.\n        for (let response of responses) {\n            console.log('hello', response.hello);\n        }\n    }\n}\n\n// Creates our API request instances, and a \"responses\"\n// array used to hold out-of-sync responses.\nvar req1 = new XMLHttpRequest(),\n    req2 = new XMLHttpRequest(),\n    req3 = new XMLHttpRequest(),\n    responses = [];\n\n// Issue network requests for all our network requests.\nfor (let req of [ req1, req2, req3 ]) {\n    req.addEventListener('load', onLoad);\n\n    req.open('get', 'api.json');\n    req.send();\n}\n```"]