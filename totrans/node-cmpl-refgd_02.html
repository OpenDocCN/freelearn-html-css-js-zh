<html><head></head><body><div><h1 class="header-title">Setting up Node.js</h1>
                
            
            
                
<p>Before getting started with using Node.js, you must set up your development environment. In the following chapters, we'll use this for development and for non-production deployment.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to install Node.js from source and prepackaged binaries on Linux, macOS, or Windows</li>
<li>How to install <strong>Node Package Manager</strong> (<strong>NPM</strong>) and some popular tools </li>
<li>The Node.js module system</li>
<li>Node.js and JavaScript language improvements from the ECMAScript committee</li>
</ul>
<p>So let's get on with it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">System requirements</h1>
                
            
            
                
<p>Node.js runs on POSIX-like operating systems, various UNIX derivatives (Solaris, for example) or workalikes (Linux, macOS, and so on), as well as on Microsoft Windows. It can run on machines both large and small, including the tiny ARM devices such as the Raspberry Pi microscale embeddable computer for DIY software/hardware projects.</p>
<p>Node.js is now available via package management systems, limiting the need to compile and install from source.</p>
<p>Because many Node.js packages are written in C or C++, you must have a C compiler (such as GCC), Python 2.7 (or later), and the <kbd>node-gyp</kbd> package. If you plan to use encryption in your networking code, you will also need the OpenSSL cryptographic library. The modern UNIX derivatives almost certainly come with these, and Node.js's configure script, used when installing from source, will detect their presence. If you need to install them, Python is available at <a href="http://python.org">http://python.org</a> and OpenSSL is available at <a href="http://openssl.org">http://openssl.org</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing Node.js using package managers</h1>
                
            
            
                
<p>The preferred method for installing Node.js, now, is to use the versions available in package managers, such as <kbd>apt-get</kbd>, or MacPorts. Package managers simplify your life by helping to maintain the current version of the software on your computer, ensuring to update dependent packages as necessary, all by typing a simple command such as <kbd>apt-get update</kbd>. Let's go over this first.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing on macOS with MacPorts</h1>
                
            
            
                
<p>The MacPorts project (<a href="http://www.macports.org/">http://www.macports.org/</a>) has for years been packaging a long list of open source software packages for macOS, and they have packaged Node.js. After you have installed MacPorts using the installer on their website, installing Node.js is pretty much this simple:</p>
<pre class="p1"><strong>$ port search nodejs npm<br/>...<br/>nodejs6 @6.12.0 (devel, net)<br/>    Evented I/O for V8 JavaScript<br/><br/>nodejs7 @7.10.1 (devel, net)<br/>    Evented I/O for V8 JavaScript<br/><br/>nodejs8 @8.9.1 (devel, net)<br/>    Evented I/O for V8 JavaScript<br/><br/>nodejs9 @9.2.0 (devel, net)<br/>    Evented I/O for V8 JavaScript<br/><br/>Found 6 ports.<br/>--<br/>npm4 @4.6.1 (devel)<br/>    node package manager<br/><br/>npm5 @5.5.1 (devel)<br/>    node package manager<br/><br/>Found 4 ports.<br/><br/>$ sudo port install nodejs8 npm5
.. long log of downloading and installing prerequisites and Node
$ which node
/opt/local/bin/node
$ node --version
v8.9.1  </strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing on macOS with Homebrew</h1>
                
            
            
                
<p>Homebrew is another open source software package manager for macOS, which some say is the perfect replacement for MacPorts. It is available through their home page at <a href="http://brew.sh/">http://brew.sh/</a>. After installing Homebrew using the instructions on their website and ensuring that Homebrew is correctly set up, use the following:</p>
<pre><strong>$ brew update</strong><br/><strong>... long wait and lots of output</strong><br/><strong>$ brew search node</strong><br/><strong>==&gt; Searching local taps...</strong><br/><strong>node <img src="img/90a4fbe7-81ae-4745-b906-6e957914cf11.png" style="width:1.67em;height:1.67em;" width="150" height="150"/> libbitcoin-node node-build node@6 nodeenv</strong><br/><strong>leafnode llnode node@4 nodebrew nodenv</strong><br/><strong>==&gt; Searching taps on GitHub...</strong><br/><strong>caskroom/cask/node-profiler</strong><br/><strong>==&gt; Searching blacklisted, migrated and deleted formulae...</strong></pre>
<p>Then, install it this way:</p>
<pre><strong>$ brew install node</strong><br/><strong>...</strong><br/><strong>==&gt; Installing node</strong><br/><strong>==&gt; Downloading https://homebrew.bintray.com/bottles/node-8.9.1.el_capitan.bottle.tar.gz</strong><br/><strong>######################################################################## 100.0%</strong><br/><strong>==&gt; Pouring node-8.9.1.el_capitan.bottle.tar.gz</strong><br/><strong>==&gt; Caveats</strong><br/><strong>Bash completion has been installed to:</strong><br/><strong> /usr/local/etc/bash_completion.d</strong><br/><strong>==&gt; Summary</strong><br/><strong><img src="img/8c8a799a-4067-46f2-a277-cc926bd598f1.png" style="width:1.33em;height:1.33em;" width="150" height="150"/>/usr/local/Cellar/node/8.9.1: 5,012 files, 49.6MB</strong></pre>
<p>Once installed this way, the Node.js command can be run as follows:</p>
<pre><strong>$ node --version
v8.9.1 </strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing on Linux, *BSD, or Windows from package management systems</h1>
                
            
            
                
<p>Node.js is now available through most of the package management systems. Instructions on the Node.js website currently list packaged versions of Node.js for a long list of Linux, as well as FreeBSD, OpenBSD, NetBSD, macOS, and even Windows. Visit <a href="https://nodejs.org/en/download/package-manager/">https://nodejs.org/en/download/package-manager/</a> for more information.</p>
<p>For example, on Debian and other Debian-based Linux distro's (such as Ubuntu), use the following commands:</p>
<pre><strong># curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
# sudo apt-get install -y nodejs
# sudo apt-get install -y build-essential </strong> </pre>
<p>To download other Node.js versions (this example shows version 10.x), modify the URL to suit.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing Node.js in the Windows Subsystem for Linux (WSL)</h1>
                
            
            
                
<p>The <strong>Windows Subsystem for Linux</strong> (<strong>WSL</strong>) lets you install Ubuntu, openSUSE, or SUSE Linux Enterprise on Windows. All three are available via the Store built into Windows 10. You may need to update your Windows for the installation to work.</p>
<p>Once installed, the Linux-specific instructions will install Node.js within the Linux subsystem.</p>
<p>To install the WSL, see <a href="https://msdn.microsoft.com/en-us/commandline/wsl/install-win10">https://msdn.microsoft.com/en-us/commandline/wsl/install-win10</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Opening an administrator-privileged PowerShell on Windows</h1>
                
            
            
                
<p>Some of the commands you'll run while installing tools on Windows are to be executed in a PowerShell window with elevated privileges. We mention this because the process of enabling the WSL includes a command to be run in such a PowerShell window.</p>
<p>The process is simple:</p>
<ol>
<li>In the Start menu, enter PowerShell in the applications search box.</li>
<li>The resultant menu will list PowerShell.</li>
<li>Right-click the PowerShell entry.</li>
<li>The context menu that comes up will have an entry Run as Administrator. Click on that.</li>
</ol>
<p>The resultant command window will have administrator privileges, and the title bar will say Administrator: Windows PowerShell.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing the Node.js distribution from nodejs.org</h1>
                
            
            
                
<p>The <a href="https://nodejs.org/en/">https://nodejs.org/en/</a> website offers built-in binaries for Windows, macOS, Linux, and Solaris. We can simply go to the website, click on the Install button, and run the installer. For systems with package managers, such as the ones we've just discussed, it's preferable to use the package management system. That's because you'll find it easier to stay up-to-date with the latest version. But, that doesn't serve all people because:</p>
<ul>
<li>Some will prefer to install a binary rather than deal with the package manager</li>
<li>Their chosen system doesn't have a package management system</li>
<li>The Node.js implementation in their package management system is out-of-date</li>
</ul>
<p>Simply go to the Node.js website and you'll see something like the following screenshot. The page does its best to determine your OS and supply the appropriate download. If you need something different, click on the DOWNLOADS link in the header for all possible downloads:</p>
<div><img src="img/ffdbcc7f-0d3c-4da4-8ecf-62b4826a0a24.png" style="width:31.58em;height:26.92em;" width="651" height="555"/></div>
<p>For macOS, the installer is a <kbd>PKG</kbd> file giving the typical installation process. For Windows, the installer simply takes you through the typical Install Wizard process.</p>
<p>Once finished with the installer, you have command-line tools, such as <kbd>node</kbd> and <kbd>npm</kbd>, with which you can run Node.js programs. On Windows, you're supplied with a version of the Windows command shell preconfigured to work nicely with Node.js.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing from source on POSIX-like systems</h1>
                
            
            
                
<p>Installing the prepackaged Node.js distributions is the preferred installation method. However, installing Node.js from source is desirable in a few situations:</p>
<ul>
<li>It can let you optimize the compiler settings as desired</li>
<li>It can let you cross-compile, say, for an embedded ARM system</li>
<li>You might need to keep multiple Node.js builds for testing</li>
<li>You might be working on Node.js itself</li>
</ul>
<p>Now that you have the high-level view, let's get our hands dirty mucking around in some build scripts. The general process follows the usual <kbd>configure</kbd>, <kbd>make</kbd>, and <kbd>make install</kbd> routine that you may already have performed with other open source software packages. If not, don't worry, we'll guide you through the process.</p>
<p>The official installation instructions are in the <kbd>README.md</kbd> contained within the source distribution at <a href="https://github.com/nodejs/node/blob/master/README.md">https://github.com/nodejs/node/blob/master/README.md</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing prerequisites</h1>
                
            
            
                
<p>There are three prerequisites: a C compiler, Python, and the OpenSSL libraries. The Node.js compilation process checks for their presence and will fail if the C compiler or Python is not present. The specific method of installing these is dependent on your operating system.</p>
<p>These sorts of commands will check for their presence:</p>
<pre><strong>$ cc --version
Apple LLVM version 7.0.2 (clang-700.1.81)
Target: x86_64-apple-darwin15.3.0
Thread model: posix
$ python
Python 2.7.11 (default, Jan  8 2016, 22:23:13) 
[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;</strong></pre>
<p>See this for details: <a href="https://github.com/nodejs/node/blob/master/BUILDING.md">https://github.com/nodejs/node/blob/master/BUILDING.md</a>.</p>
<p>The Node.js build tools do not support Python 3.x.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing developer tools on macOS</h1>
                
            
            
                
<p>Developer tools (such as GCC) are an optional installation on macOS. Fortunately, they're easy to acquire.</p>
<p>You start with Xcode, which is available for free through the Mac App Store. Simply search for Xcode and click on the Get button. Once you have Xcode installed, open a Terminal window and type the following:</p>
<pre><strong>$ xcode-select --install</strong></pre>
<p>This installs the Xcode command-line tools:</p>
<div><img src="img/3094a2d2-ccb5-4c1b-8234-878a78d6463a.png" style="width:35.00em;height:22.25em;" width="570" height="362"/></div>
<p>For additional information, visit <a href="http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/">http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing from source for all POSIX-like systems</h1>
                
            
            
                
<p>Compiling Node.js from source follows this process:</p>
<ol>
<li>Download the source from <a href="http://nodejs.org/download"/></li>
<li><a href="http://nodejs.org/download">http://nodejs.org/download.</a>Configure the source for building using <kbd>./configure</kbd>.</li>
<li>Run <kbd>make</kbd>, then <kbd>make install</kbd>.</li>
</ol>
<p>The source bundle can be downloaded with your browser, or as follows, substituting your preferred version:</p>
<pre><strong>$ mkdir src
$ cd src
$ wget https://nodejs.org/dist/v10.0.0/node-v10.0.0.tar.gz
$ tar xvfz node-v10.0.0.tar.gz
$ cd node-v10.0.0</strong></pre>
<p>Now we configure the source so that it can be built. This is just like many other open source packages, and there are a long list of options to customize the build:</p>
<pre><strong>$ ./configure --help</strong></pre>
<p>To cause the installation to land in your home directory, run it this way:</p>
<pre><strong>$ ./configure --prefix=$HOME/node/10.0.0
..output from configure </strong> </pre>
<p>If you're going to install multiple Node.js versions side by side, it's useful to put the version number in the path like this. That way, each version will sit in a separate directory. It's a simple matter of switching between Node.js versions by changing the <kbd>PATH</kbd> variable appropriately:</p>
<pre><strong># On bash shell:</strong><br/><strong>$ export PATH=${HOME}/node/VERSION-NUMBER/bin:${PATH}</strong><br/><strong># On csh</strong><br/><strong>$ setenv PATH ${HOME}/node/VERSION-NUMBER/bin:${PATH}</strong></pre>
<p>A simpler way to install multiple Node.js versions is the <kbd>nvm</kbd> script described later.</p>
<p>If you want to install Node.js in a system-wide directory, simply leave off the <kbd>--prefix</kbd> option and it will default to installing in <kbd>/usr/local</kbd>.</p>
<p>After a moment, it'll stop and will likely have successfully configured the source tree for installation in your chosen directory. If this doesn't succeed, the error messages that are printed will describe what needs to be fixed. Once the configure script is satisfied, you can go on to the next step.</p>
<p>With the configure script satisfied, you compile the software:</p>
<pre><strong>$ make
.. a long log of compiler output is printed
$ make install</strong></pre>
<p>If you are installing into a system-wide directory, do the last step this way instead:</p>
<pre><strong>$ make
$ sudo make install</strong></pre>
<p>Once installed, you should make sure that you add the installation directory to your <kbd>PATH</kbd> variable as follows:</p>
<pre><strong>$ echo 'export PATH=$HOME/node/10.0.0/bin:${PATH}' &gt;&gt;~/.bashrc
$ . ~/.bashrc </strong> </pre>
<p>Alternatively, for <kbd>csh</kbd> users, use this syntax to make an exported environment variable:</p>
<pre><strong>$ echo 'setenv PATH $HOME/node/10.0.0/bin:${PATH}' &gt;&gt;~/.cshrc
$ source ~/.cshrc </strong> </pre>
<p>This should result in some directories, as follows:</p>
<pre><strong>$ ls ~/node/10.0.0/
bin   include   lib   share
$ ls ~/node/10.0.0/bin </strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing from source on Windows</h1>
                
            
            
                
<p>The <kbd>BUILDING.md</kbd> document referenced previously has instructions. One uses the build tools from Visual Studio, or else the full Visual Studio 2017 product: </p>
<ul>
<li>Visual Studio 2017: <a href="https://www.visualstudio.com/downloads/">https://www.visualstudio.com/downloads/</a></li>
<li>Build tools: <a href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017">https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017</a></li>
</ul>
<p>Three additional tools are required:</p>
<ul>
<li>Git for Windows: <a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a>  </li>
<li>Python: <a href="https://www.python.org/">https://www.python.org/</a></li>
<li>OpenSSL: <a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a> and <a href="https://wiki.openssl.org/index.php/Binaries">https://wiki.openssl.org/index.php/Binaries</a></li>
</ul>
<p>Then, run the included <kbd>.\vcbuild</kbd> script to perform the build. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing multiple Node.js instances with nvm</h1>
                
            
            
                
<p>Normally, you won't install multiple versions of Node.js and doing so adds complexity to your system. But if you are hacking on Node.js itself, or are testing your software against different Node.js releases, you may want to have multiple Node.js installations. The method to do so is a simple variation on what we've already discussed.</p>
<p>Earlier, while discussing building Node.js from source, we noted that one can install multiple Node.js instances in separate directories. It's only necessary to build from source if you need a customized Node.js build, and most folks will be satisfied with pre-built Node.js binaries. They, too, can be installed into separate directories.</p>
<p>To switch between Node.js versions is simply a matter of changing the <kbd>PATH</kbd> variable (on POSIX systems), as follows, using the directory where you installed Node.js:</p>
<pre><strong>$ export PATH=/usr/local/node/VERSION-NUMBER/bin:${PATH} </strong> </pre>
<p>It starts to be a little tedious to maintain this after a while. For each release, you have to set up Node.js, NPM, and any third-party modules you desire in your Node.js installation. Also, the command shown to change your <kbd>PATH</kbd> is not quite optimal. Inventive programmers have created several version managers to simplify managing multiple Node.js/NPM releases and providing commands to change your <kbd>PATH</kbd> the smart way:</p>
<ul>
<li>Node version manager: <a href="https://github.com/tj/n">https://github.com/tj/n</a></li>
<li>Node version manager: <a href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a></li>
</ul>
<p>Both maintain multiple simultaneous versions of Node and let you easily switch between versions. Installation instructions are available on their respective websites.</p>
<p>For example, with <kbd>nvm</kbd>, you can run commands like these:</p>
<pre><strong>$ nvm ls</strong><br/><strong>...</strong><br/><strong>         v6.0.0</strong><br/><strong>         v6.1.0</strong><br/><strong>         v6.2.2</strong><br/><strong>         v6.3.1</strong><br/><strong>         v6.4.0</strong><br/><strong>            ...</strong><br/><strong>        v6.11.2</strong><br/><strong>         v7.0.0</strong><br/><strong>         v7.1.0</strong><br/><strong>        v7.10.0</strong><br/><strong>         v8.0.0</strong><br/><strong>         v8.1.3</strong><br/><strong>         v8.2.1</strong><br/><strong>         v8.5.0</strong><br/><strong>         v8.9.1</strong><br/><strong>         v8.9.3</strong><br/><strong>         v9.2.0</strong><br/><strong>         v9.4.0</strong><br/><strong>         v9.5.0</strong><br/><strong>        v9.10.1</strong><br/><strong>        v9.11.1</strong><br/><strong>     -&gt; v10.0.0</strong><br/><strong>     -&gt; system</strong><br/><strong>node -&gt; stable (-&gt; v8.9.1) (default)</strong><br/><strong>stable -&gt; 8.9 (-&gt; v8.9.1) (default)</strong><br/><strong>iojs -&gt; N/A (default)</strong><br/><strong>$ nvm use 10</strong><br/><strong>Now using node v10.0.0 (npm v5.6.0)</strong><br/><strong>$ node --version</strong><br/><strong>v10.0.0</strong><br/><strong>$ nvm use v4.2
Now using node v4.2.0 (npm v2.14.7)
$ node --version
v4.2.0</strong><br/><strong>$ nvm install 9</strong><br/><strong>Downloading https://nodejs.org/dist/v9.2.0/node-v9.2.0-darwin-x64.tar.xz...</strong><br/><strong>######################################################################## 100.0%</strong><br/><strong>WARNING: checksums are currently disabled for node.js v4.0 and later</strong><br/><strong>Now using node v9.2.0 (npm v5.5.1)</strong><br/><strong>$ node --version</strong><br/><strong>v9.2.0</strong><br/><strong>$ which node</strong><br/><strong>/Users/david/.nvm/versions/node/v9.2.0/bin/node</strong><br/><strong>$ /usr/local/bin/node --version</strong><br/><strong>v8.9.1</strong><br/><strong>$ /opt/local/bin/node --version</strong><br/><strong>v8.9.1</strong></pre>
<p>This demonstrates that you can have a system-wide Node.js installed, keep multiple private Node.js versions managed by <kbd>nvm</kbd>, and switch between them as needed. When new Node.js versions are released, they are simple to install with <kbd>nvm</kbd> even if the official packaged version for your OS doesn't immediately update.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing nvm on Windows</h1>
                
            
            
                
<p>Unfortunately, <kbd>nvm</kbd> does not support Windows. Fortunately, a couple of Windows-specific clones of the <kbd>nvm</kbd> concept exist:</p>
<ul>
<li><a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></li>
<li><a href="https://github.com/marcelklehr/nodist">https://github.com/marcelklehr/nodist</a></li>
</ul>
<p>Another route is to use the WSL. Because in WSL you're interacting with a Linux command line, you can use <kbd>nvm</kbd> itself.</p>
<p>Many of the examples in this book were tested using the <kbd>nvm-windows</kbd> application. There are slight behavior differences, but it acts largely the same as <kbd>nvm</kbd> for Linux and macOS. The biggest change is the version number specifier in the <kbd>nvm use</kbd> and <kbd>nvm install</kbd> commands.</p>
<p>With <kbd>nvm</kbd> for Linux and macOS one can type a simple version number, like <kbd>nvm use 8</kbd>, and it will automatically substitute the latest release of the named Node.js version. With <kbd>nvm-windows</kbd> the same command acts as if you typed "<kbd>nvm use 8.0.0</kbd>". In other words, with <kbd>nvm-windows</kbd> you must use the exact version number. Fortunately, the list of supported versions is easily available using the "<kbd>nvm list available</kbd>" command.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Native code modules and node-gyp</h1>
                
            
            
                
<p>While we won't discuss native code module development in this book, we do need to make sure that they can be built. Some modules in the NPM repository are native code, and they must be compiled with a C or C++ compiler to build the corresponding <kbd>.node</kbd> files  (the <kbd>.node</kbd> extension is used for binary native-code modules).</p>
<p>The module will often describe itself as a wrapper for some other library. For example, the <kbd>libxslt</kbd> and <kbd>libxmljs</kbd> modules are wrappers around the C/C++ libraries of the same name. The module includes the C/C++ source code, and when installed, a script is automatically run to do the compilation with <kbd>node-gyp</kbd>.</p>
<p>The <kbd>node-gyp</kbd> tool is a cross-platform command-line tool written in Node.js for compiling native add-on modules for Node.js. We've mentioned native code modules several times, and it is this tool that compiles them for use with Node.js.</p>
<p>You can easily see this in action by running these commands:</p>
<pre><strong>$ mkdir temp
$ cd temp
$ npm install libxmljs libxslt </strong> </pre>
<p>This is done in a temporary directory, so you can delete it afterward. If your system does not have the tools installed to compile native code modules, you'll see error messages. Otherwise, you'll see in the output a <kbd>node-gyp</kbd> execution, followed by many lines of text obviously related to compiling C/C++ files.</p>
<p>The <kbd>node-gyp</kbd> tool has prerequisites similar to those for compiling Node.js from source. Namely, a C/C++ compiler, a Python environment, and other build tools such as Git. For Unix/macOS/Linux systems those are easy to come by. For Windows, you should install:</p>
<ul>
<li>Visual Studio Build Tools: <a href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017">https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017</a></li>
<li>Git for Windows: <a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a></li>
<li>Python for Windows: <a href="https://www.python.org/">https://www.python.org/</a></li>
</ul>
<p>Normally, you won't need to worry about installing <kbd>node-gyp</kbd>. That's because it is installed behind the scenes as part of NPM. That's done so that NPM can automatically build native code modules.</p>
<p>Its GitHub repository contains documentation at <a href="https://github.com/nodejs/node-gyp">https://github.com/nodejs/node-gyp</a>.</p>
<p>Reading the <kbd>node-gyp</kbd> documentation, in its repository, will give you a clearer understanding of the compilation prerequisites discussed previously, as well as of developing native code modules.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Node.js versions policy and what to use</h1>
                
            
            
                
<p>We just threw around so many different Node.js version numbers in the previous section that you may have become confused over which version to use. This book is targeting Node.js version 10.x, and it's expected that everything we'll cover is compatible with Node.js 10.x and any subsequent release.</p>
<p>Starting with Node.js 4.x, the Node.js team is following a dual-track approach. The even-numbered releases (4.x, 6.x, 8.x, and so on) are what they're calling <strong>Long Term Support</strong> (<strong>LTS</strong>), while the odd-numbered releases (5.x, 7.x, 9.x, and so on) are where current new feature development occurs. While the development branch is kept stable, the LTS releases are positioned as being for production use and will receive updates for several years.</p>
<p>At the time of writing, Node.js 8.x is the current LTS release; Node.js 9.x was just released and will eventually become Node.js 10.x, which in turn will eventually become the LTS release. For complete details about the release schedule, refer to <a href="https://github.com/nodejs/LTS/">https://github.com/nodejs/LTS/</a>.</p>
<p>A major impact of each new Node.js release, beyond the usual performance improvements and bug fixes, is bringing in the latest V8 JavaScript engine release. In turn, this means bringing in more of the ES-2015/2016/2017 features as the V8 team implements those features. In Node.js 8.x, <kbd>async/await</kbd> functions arrived, and in Node.js 10.x support for the standard ES6 module format has arrived.</p>
<p>A practical consideration is whether a new Node.js release will break your code. New language features are always being added as V8 catches up with ECMA Script, and the Node.js team sometimes makes breaking changes in the Node.js API. If you've tested on one Node.js version, will it work on an earlier version? Will a Node.js change break some assumptions we made?</p>
<p class="mce-root"/>
<p>The NPM Package Manager helps us ensure that our packages execute on the correct Node.js version. This means that we can specify in the <kbd>package.json</kbd> file, which we'll explore in <a href="">Chapter 3</a>, <em>Node.js Modules</em>, the compatible Node.js versions for a package.</p>
<p>We can add an entry to <kbd>package.json</kbd> as follows:</p>
<pre>engines: { 
  "node": "&gt;=6.x" 
} </pre>
<p>This means exactly what it implies—that the given package is compatible with Node.js version 6.x or later.</p>
<p>Of course, your development machine(s) could have several Node.js versions installed. You'll need the version your software is declared to support, plus any later versions you wish to evaluate.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Editors and debuggers</h1>
                
            
            
                
<p>Since Node.js code is JavaScript, any JavaScript-aware editor will be useful. Unlike some other languages that are so complex that an IDE with code completion is a necessity, a simple programming editor is perfectly sufficient for Node.js development.</p>
<p>Two editors are worth calling out because they are written in Node.js: Atom and Microsoft Visual Studio Code. </p>
<p>Atom (<a href="https://atom.io/">https://atom.io/</a>) bills itself as a hackable editor for the 21st century. It is extendable by writing Node.js modules using the Atom API, and the configuration files are easily editable. In other words, it's hackable in the same way plenty of other editors have been, going back to Emacs, meaning one writes a software module to add capabilities to the editor. The Electron framework was invented in order to build Atom, and Electron is a super easy way to build desktop applications using Node.js.</p>
<p>Microsoft Visual Studio Code (<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>) is also a hackable editor—well, the home page says extensible and customizable, which means the same thing—that is also open source, and is also implemented in Electron. But it's not a hollow me-too editor, aping Atom while adding nothing of its own.  Instead, Visual Studio Code is a solid programmers editor in its own right, bringing interesting functionality to the table.</p>
<p>As for debuggers, there are several interesting choices. Starting with Node.js 6.3, the <kbd>inspector</kbd> protocol made it possible to use the Google Chrome debugger. Visual Studio Code has a built-in debugger that also uses the <kbd>inspector</kbd> protocol.</p>
<p>For a full list of debugging options and tools, see <a href="https://nodejs.org/en/docs/guides/debugging-getting-started/">https://nodejs.org/en/docs/guides/debugging-getting-started/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Running and testing commands</h1>
                
            
            
                
<p>Now that you've installed Node.js, we want to do two things—verify that the installation was successful, and familiarize you with the command-line tools.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Node.js's command-line tools</h1>
                
            
            
                
<p>The basic installation of Node.js includes two commands, <kbd>node</kbd> and <kbd>npm</kbd>. We've already seen the <kbd>node</kbd> command in action. It's used either for running command-line scripts or server processes. The other, <kbd>npm</kbd>, is a package manager for Node.js.</p>
<p>The easiest way to verify that your Node.js installation works is also the best way to get help with Node.js. Type the following command:</p>
<pre><strong>$ node --help</strong><br/><strong>Usage: node [options] [ -e script | script.js | - ] [arguments]</strong><br/><strong>       node inspect script.js [arguments]</strong><br/><br/><strong>Options:</strong><br/><strong>  -v, --version print Node.js version</strong><br/><strong>  -e, --eval script evaluate script</strong><br/><strong>  -p, --print evaluate script and print result</strong><br/><strong>  -c, --check syntax check script without executing</strong><br/><strong>  -i, --interactive always enter the REPL even if stdin</strong><br/><strong>                             does not appear to be a terminal</strong><br/><strong>  -r, --require module to preload (option can be repeated)</strong><br/><strong>  - script read from stdin (default; interactive mode if a tty)</strong><br/><strong>  --inspect[=[host:]port] activate inspector on host:port</strong><br/><strong>                             (default: 127.0.0.1:9229)</strong><br/><strong>  --inspect-brk[=[host:]port]</strong><br/><strong>                             activate inspector on host:port</strong><br/><strong>                             and break at start of user script</strong><br/><strong>  --inspect-port=[host:]port</strong><br/><strong>                             set host:port for inspector</strong><br/><br/><strong>... many more options</strong><br/><strong>Environment variables:</strong><br/><strong>NODE_DEBUG ','-separated list of core modules</strong><br/><strong>                             that should print debug information</strong><br/><strong>NODE_DISABLE_COLORS set to 1 to disable colors in the REPL</strong><br/><strong>NODE_EXTRA_CA_CERTS path to additional CA certificates</strong><br/><strong>                             file</strong><br/><strong>NODE_ICU_DATA data path for ICU (Intl object) data</strong><br/><strong>                             (will extend linked-in data)</strong><br/><strong>NODE_NO_WARNINGS set to 1 to silence process warnings</strong><br/><strong>NODE_NO_HTTP2 set to 1 to suppress the http2 module</strong><br/><strong>NODE_OPTIONS set CLI options in the environment</strong><br/><strong>                             via a space-separated list</strong><br/><strong>NODE_PATH ':'-separated list of directories</strong><br/><strong>                             prefixed to the module search path</strong><br/><strong>NODE_PENDING_DEPRECATION set to 1 to emit pending deprecation</strong><br/><strong>                             warnings</strong><br/><strong>NODE_REPL_HISTORY path to the persistent REPL history</strong><br/><strong>                             file</strong><br/><strong>NODE_REDIRECT_WARNINGS write warnings to path instead of</strong><br/><strong>                             stderr</strong><br/><strong>OPENSSL_CONF load OpenSSL configuration from file</strong><br/><br/><strong>Documentation can be found at https://nodejs.org/</strong></pre>
<p>Note that there are options for both Node.js and V8 (not shown in the previous command line). Remember that Node.js is built on top of V8; it has its own universe of options that largely focus on details of bytecode compilation or garbage collection and heap algorithms. Enter <kbd>node --v8-options</kbd> to see the full list of them.</p>
<p>On the command line, you can specify options, a single script file, and a list of arguments to that script. We'll discuss script arguments further in the next section, <em>Running a simple script with Node.js</em>.</p>
<p>Running Node.js with no arguments plops you into an interactive JavaScript shell:</p>
<pre><strong>$ node
&gt; console.log('Hello, world!');
Hello, world!
undefined </strong> </pre>
<p>Any code you can write in a Node.js script can be written here. The command interpreter gives a good Terminal-oriented user experience and is useful for interactively playing with your code. You do play with your code, don't you? Good!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Running a simple script with Node.js</h1>
                
            
            
                
<p>Now, let's see how to run scripts with Node.js. It's quite simple; let's start by referring to the help message shown previously. The command-line pattern is just a script filename and some script arguments, which should be familiar to anyone who has written scripts in other languages.</p>
<p>Creating and editing Node.js scripts can be done with any text editor that deals with plain text files, such as VI/VIM, Emacs, Notepad++, Atom, Visual Studio Code, Jedit, BB Edit, TextMate, or Komodo. It's helpful if it's a programmer-oriented editor, if only for the syntax coloring.</p>
<p>For this and other examples in this book, it doesn't truly matter where you put the files. However, for the sake of neatness, you can start by making a directory named <kbd>node-web-dev</kbd> in the home directory of your computer, and inside that creating one directory per chapter (for example, <kbd>chap02</kbd> and <kbd>chap03</kbd>).</p>
<p>First, create a text file named <kbd>ls.js</kbd> with the following content:</p>
<pre><strong>const fs = require('fs');</strong><br/><strong>const util = require('util');</strong><br/><strong>const fs_readdir = util.promisify(fs.readdir);</strong><br/><br/><strong>(async () =&gt; {</strong><br/><strong>  const files = await fs_readdir('.');</strong><br/><strong>  for (let fn of files) {</strong><br/><strong>    console.log(fn);</strong><br/><strong>  }</strong><br/><strong>})().catch(err =&gt; { console.error(err); });</strong></pre>
<p>Next, run it by typing the following command:</p>
<pre><strong>$ node ls.js
ls.js</strong></pre>
<p>This is a pale cheap imitation of the Unix <kbd>ls</kbd> command (as if you couldn't figure that out from the name). The <kbd>readdir</kbd> function is a close analog to the Unix <kbd>readdir</kbd> system call (type <kbd>man 3 readdir</kbd> in a Terminal window to learn more) and is used to list the files in a directory.</p>
<p>We have written this using an inline <kbd>async</kbd> function, the <kbd>await</kbd> keyword, and an ES2015 <kbd>for..of</kbd> loop. Using <kbd>util.promisify</kbd>, we can convert any callback-oriented function so it returns a Promise, so that the Promise plays well with the <kbd>await</kbd> keyword.</p>
<p>By default <kbd>fs</kbd> module functions use the callback paradigm, as does most Node.js modules. But within <kbd>async</kbd> functions it is more convenient if functions instead return promises. Using <kbd>util.promisify</kbd> we can make it so.</p>
<p>This script is hardcoded to list files in the current directory. The real <kbd>ls</kbd> command takes a directory name, so let's modify the script a little.</p>
<p>Command-line arguments land in a global array named <kbd>process.argv</kbd>. Therefore we can modify <kbd>ls.js</kbd>, copying it as <kbd>ls2.js</kbd>, as follows to see how this array works:</p>
<pre>const fs = require('fs');<br/>const util = require('util');<br/>const fs_readdir = util.promisify(fs.readdir);<br/><br/>(async () =&gt; {<br/>  var dir = '.';<br/>  if (process.argv[2]) dir = process.argv[2];<br/>  const files = await fs_readdir(dir);<br/>  for (let fn of files) {<br/>    console.log(fn);<br/>  }<br/>})().catch(err =&gt; { console.error(err); });</pre>
<p>You can run it as follows:</p>
<pre><strong>$ pwd</strong><br/><strong>/Users/David/chap02</strong><br/><strong>$ node ls2 ..</strong><br/><strong>chap01</strong><br/><strong>chap02</strong><br/><strong>$ node ls2</strong><br/><strong>app.js</strong><br/><strong>ls.js</strong><br/><strong>ls2.js</strong></pre>
<p>We simply checked if a command-line argument was present, <kbd>if (process.argv[2])</kbd>. If it was, we overrode the value of the <kbd>dir</kbd> variable, <kbd>dir = process.argv[2]</kbd>, and we then used that as the <kbd>readdir</kbd> argument.</p>
<p>If you give it a non-existent directory pathname, an error will be thrown and printed using the <kbd>catch</kbd> clause. That looks like so:</p>
<pre>$ node ls2.js /nonexistent<br/>{ Error: ENOENT: no such file or directory, scandir '/nonexistent'<br/> errno: -2,<br/> code: 'ENOENT',<br/> syscall: 'scandir',<br/> path: '/nonexistent' }</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Conversion to async functions and the Promise paradigm</h1>
                
            
            
                
<p>In the previous section we discussed the <kbd>util.promisify</kbd> and its ability to convert a callback-oriented function into one that returns a Promise. The latter play well within async functions and therefore it is preferable for functions to return a Promise.</p>
<p>To be more precise, <kbd>util.promisify</kbd> is to be given a function that uses the error-first-callback paradigm. The last argument of such functions is a callback function whose first argument is interpreted as an error indicator, hence the phrase error-first-callback. What <kbd>util.promisify</kbd> returns is another function that returns a Promise. </p>
<p>The Promise serves the same purpose as the error-first-callback. If an error is indicated, the Promise resolves to the rejected status, while if success is indicated the Promise resolves to a success status. As we see in these examples, within an <kbd>async</kbd> function the Promise is handled very nicely.</p>
<p>The Node.js ecosystem has a large body of functions using the error-first-callback. The community has begun a conversion process where functions will return a Promise, and possibly also take an error-first-callback for API compatibility.</p>
<p>One of the new features in Node.js 10 is an example of such a conversion. Within the <kbd>fs</kbd> module is a submodule, named <kbd>fs.promises</kbd>, with the same API but producing Promise objects. We could rewrite the previous example as so:</p>
<pre>const fs = require('fs').promises;<br/>(async () =&gt; {<br/> var dir = '.';<br/> if (process.argv[2]) dir = process.argv[2];<br/> const files = await fs.readdir(dir);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre> for (let fn of files) {<br/>     console.log(fn);<br/> }<br/>})().catch(err =&gt; { console.error(err); });</pre>
<p>As you can see, the functions in the <kbd>fs.promises</kbd> module returns a Promise without requiring a callback function. The new program, which you can save as <kbd>ls2-promises.js</kbd>, is run as so:</p>
<pre><strong>$ node ls2-promises.js </strong><br/><strong>(node:40329) ExperimentalWarning: The fs.promises API is experimental</strong><br/><strong>app.js<br/></strong><strong>ls.js</strong><br/><strong>ls2-promises.js</strong><br/><strong>ls2.js</strong></pre>
<p>The API is currently in an experimental state and therefore we're shown this warning.</p>
<p>Another choice is a 3rd party module, <kbd>fs-extra</kbd>. This module has an extended API beyond the standard <kbd>fs</kbd> module. On the one hand its functions return a Promise if no callback function is provided, or else invokes the callback. In addition it includes several useful functions.</p>
<p>In the rest of this book we will be using <kbd>fs-extra</kbd> because of those additional functions. For documentation of the module, see: <a href="https://www.npmjs.com/package/fs-extra">https://www.npmjs.com/package/fs-extra</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Launching a server with Node.js</h1>
                
            
            
                
<p>Many scripts that you'll run are server processes. We'll be running lots of these scripts later on. Since we're still in the dual mode of verifying the installation and familiarizing you with using Node.js, we want to run a simple HTTP server. Let's borrow the simple server script on the Node.js home page (<a href="http://nodejs.org">http://nodejs.org</a>).</p>
<p>Create a file named <kbd>app.js</kbd> containing the following:</p>
<pre>const http = require('http'); 
http.createServer(function (req, res) { 
  res.writeHead(200, {'Content-Type': 'text/plain'}); 
  res.end('Hello, World!\n'); 
}).listen(8124, '127.0.0.1'); 
console.log('Server running at http://127.0.0.1:8124'); </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Run it as follows:</p>
<pre><strong>$ node app.js
Server running at http://127.0.0.1:8124 </strong> </pre>
<p>This is the simplest of web servers you can build with Node.js. If you're interested in how it works, flip forward to <a href="2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml">Chapter 4</a>, <em>HTTP Servers and Clients</em>; <a href="e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml">Chapter 5</a>, <em>Your First Express Application</em>; and <a href="">Chapter 6</a>, <em>Implementing the Mobile-First Paradigm</em>. For the moment, just visit <kbd>http://127.0.0.1:8124</kbd> in your browser to see the Hello, World! message:</p>
<div><img src="img/2e7c2753-e616-42e7-99ac-1ecad972774c.png" style="width:30.00em;height:12.83em;" width="502" height="215"/></div>
<p>A question to ponder is why this script did not exit when <kbd>ls.js</kbd> did exit. In both cases, execution of the script reaches the end of the script; the Node.js process does not exit in <kbd>app.js</kbd>, while in <kbd>ls.js</kbd> it does.</p>
<p>The reason is the presence of active event listeners. Node.js always starts up an event loop, and in <kbd>app.js</kbd>, the <kbd>listen</kbd> function creates an event <kbd>listener</kbd> that implements the HTTP protocol. This event listener keeps <kbd>app.js</kbd> running until you do something such as typing <em>Ctrl</em> + <em>C</em> in the Terminal window. In <kbd>ls.js</kbd>, there is nothing that creates a long-running event listener, so when <kbd>ls.js</kbd> reaches the end of its script, the <kbd>node</kbd> process will exit.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">NPM – the Node.js package manager</h1>
                
            
            
                
<p>Node.js by itself is a pretty basic system, being a JavaScript interpreter with a few interesting asynchronous I/O libraries. One of the things that makes Node.js interesting is the rapidly growing ecosystem of third-party modules for Node.js.</p>
<p>At the center of that ecosystem is NPM. While Node.js modules can be downloaded as source and assembled manually for use with Node.js programs, that's tedious and it's difficult to implement a repeatable build process. NPM gives us a simpler way; NPM is the de facto standard package manager for Node.js and it greatly simplifies downloading and using these modules. We will talk about NPM at length in the next chapter.</p>
<p>The sharp-eyed will have noticed that <kbd>npm</kbd> is already installed via all the installation methods discussed previously. In the past, <kbd>npm</kbd> was installed separately, but today it is bundled with Node.js.</p>
<p>Now that we have <kbd>npm</kbd> installed, let's take it for a quick spin. The <strong>hexy</strong> program is a utility for printing hex dumps of files. That's a very 1970 thing to do, but is still extremely useful. It serves our purpose right now in giving us something to quickly install and try out:</p>
<pre><strong>$ npm install -g hexy</strong><br/><strong>/opt/local/bin/hexy -&gt; /opt/local/lib/node_modules/hexy/bin/hexy_cmd.js</strong><br/><strong>+ hexy@0.2.10</strong><br/><strong>added 1 package in 1.107s</strong></pre>
<p>Adding the <kbd>-g</kbd> flag makes the module available globally, irrespective of the present-working-directory of your command shell. A global install is most useful when the module provides a command-line interface. When a package provides a command-line script, <kbd>npm</kbd> sets that up. For a global install, the command is installed correctly for use by all users of the computer.</p>
<p>Depending on how Node.js is installed for you, that may need to be run with <kbd>sudo</kbd>:</p>
<pre><strong>$ sudo npm install -g hexy</strong></pre>
<p>Once it is installed, you'll be able to run the newly–installed program this way:</p>
<pre><strong>$ hexy --width 12 ls.js</strong><br/><strong>00000000: 636f 6e73 7420 6673 203d 2072 const.fs.=.r</strong><br/><strong>0000000c: 6571 7569 7265 2827 6673 2729 equire('fs')</strong><br/><strong>00000018: 3b0a 636f 6e73 7420 7574 696c ;.const.util</strong><br/><strong>00000024: 203d 2072 6571 7569 7265 2827 .=.require('</strong><br/><strong>00000030: 7574 696c 2729 3b0a 636f 6e73 util');.cons</strong><br/><strong>0000003c: 7420 6673 5f72 6561 6464 6972 t.fs_readdir</strong><br/><strong>00000048: 203d 2075 7469 6c2e 7072 6f6d .=.util.prom</strong><br/><strong>00000054: 6973 6966 7928 6673 2e72 6561 isify(fs.rea</strong><br/><strong>00000060: 6464 6972 293b 0a0a 2861 7379 ddir);..(asy</strong><br/><strong>0000006c: 6e63 2028 2920 3d3e 207b 0a20 nc.().=&gt;.{..</strong><br/><strong>00000078: 2063 6f6e 7374 2066 696c 6573 .const.files</strong><br/><strong>00000084: 203d 2061 7761 6974 2066 735f .=.await.fs_</strong><br/><strong>00000090: 7265 6164 6469 7228 272e 2729 readdir('.')</strong><br/><strong>0000009c: 3b0a 2020 666f 7220 2866 6e20 ;...for.(fn.</strong><br/><strong>000000a8: 6f66 2066 696c 6573 2920 7b0a of.files).{.</strong><br/><strong>000000b4: 2020 2020 636f 6e73 6f6c 652e ....console.</strong><br/><strong>000000c0: 6c6f 6728 666e 293b 0a20 207d log(fn);...}</strong><br/><strong>000000cc: 0a7d 2928 292e 6361 7463 6828 .})().catch(</strong><br/><strong>000000d8: 6572 7220 3d3e 207b 2063 6f6e err.=&gt;.{.con</strong><br/><strong>000000e4: 736f 6c65 2e65 7272 6f72 2865 sole.error(e</strong><br/><strong>000000f0: 7272 293b 207d 293b           rr);.});</strong></pre>
<p>Again, we'll be doing a deep dive into NPM in the next chapter. The <kbd>hexy</kbd> utility is both a Node.js library and a script for printing out these old-style hex dumps.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Node.js, ECMAScript 2015/2016/2017, and beyond </h1>
                
            
            
                
<p>In 2015, the ECMAScript committee released a long-awaited major update of the JavaScript language. The update brought in many new features to JavaScript, such as Promises, arrow functions, and Class objects. The language update set the stage for improvements. since that should dramatically improve our ability to write clean, understandable JavaScript code.</p>
<p>The browser makers are adding those much-needed features, meaning the V8 engine is adding those features as well. These features are making their way into Node.js starting with version 4.x.</p>
<p>To learn about the current status of ES-2015 in Node.js, visit <a href="https://nodejs.org/en/docs/es6/">https://nodejs.org/en/docs/es6/</a>.</p>
<p>By default, only the ES-2015/2016/2017 features that V8 considers stable are enabled by Node.js. Further features can be enabled with command-line options. The almost-complete features are enabled with the <kbd>--es_staging</kbd> option. The website documentation gives more information.</p>
<p>The Node green website (<a href="http://node.green/">http://node.green/</a>) has a table listing the status of a long list of features in Node.js versions.</p>
<p>The ES2017 language spec is published at: <br/>
<a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a>.<a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm"/></p>
<p>The TC-39 committee does its work on GitHub <a href="https://github.com/tc39">https://github.com/tc39</a>.</p>
<p>The ES-2015 features make a big improvement in the JavaScript language. One feature, the <kbd>Promise</kbd> class, should mean a fundamental rethinking of common idioms in Node.js programming. In ES-2017, a pair of new keywords, <kbd>async</kbd> and <kbd>await</kbd>, will simplify writing asynchronous code in Node.js, and it should encourage the Node.js community to further rethink the common idioms of the platform.</p>
<p>There's a long list of new JavaScript features, but let's quickly go over two of them that we'll use extensively.</p>
<p>The first is a lighter-weight function syntax called the arrow function:</p>
<pre>fs.readFile('file.txt', 'utf8', (err, data) =&gt; { 
  if (err) ...; // do something with the error 
  else ...;  // do something with the data 
}); </pre>
<p>This is more than the syntactic sugar of replacing the <kbd>function</kbd> keyword with the fat arrow. Arrow functions are lighter-weight as well as being easier to read. The lighter weight comes at the cost of changing the value of <kbd>this</kbd> inside the arrow function. In regular functions, <kbd>this</kbd> has a unique value inside the function. In an arrow function, <kbd>this</kbd> has the same value as the scope containing the arrow function. This means that, when using an arrow function, we don't have to jump through hoops to bring <kbd>this</kbd> into the callback function because <kbd>this</kbd> is the same at both levels of the code.</p>
<p>The next feature is the <kbd>Promise</kbd> class, which is used for deferred and asynchronous computations. Deferred code execution to implement asynchronous behavior is a key paradigm for Node.js, and it requires two idiomatic conventions:</p>
<ul>
<li>The last argument to an asynchronous function is a callback function, which is called when an asynchronous execution is to be performed</li>
<li>The first argument to the callback function is an error indicator</li>
</ul>
<p>While convenient, these conventions resulted in multilayer code pyramids that can be difficult to understand and maintain:</p>
<pre>doThis(arg1, arg2, (err, result1, result2) =&gt; { 
    if (err) ...; 
    else { 
         // do some work 
         doThat(arg2, arg3, (err2, results) =&gt; { 
              if (err2) ...; 
              else { 
                     doSomethingElse(arg5, err =&gt; { 
                             if (err) .. ; 
                             else ..; 
                     }); 
              } 
         }); 
    } 
}); </pre>
<p>Depending on how many steps are required for a specific task, a code pyramid can get quite deep. Promises will let us unravel the code pyramid and improve reliability, because error handling is more straightforward and easily captures all errors.</p>
<p>A <kbd>Promise</kbd> class is created as follows:</p>
<pre>function doThis(arg1, arg2) { 
    return new Promise((resolve, reject) =&gt; { 
        // execute some asynchronous code 
        if (errorIsDetected) return reject(errorObject); 
        // When the process is finished call this: 
        resolve(result1, result2); 
    }); 
}</pre>
<p>Rather than passing in a callback function, the caller receives a <kbd>Promise</kbd> object. When properly utilized, the preceding pyramid can be coded as follows:</p>
<pre>doThis(arg1, arg2) 
.then(result =&gt; { <br/>  // This can receive only one value, hence to<br/>  // receive multiple values requires an object or array
  return doThat(arg2, arg3); 
}) 
.then((results) =&gt; { 
  return doSomethingElse(arg5); 
}) 
.then(() =&gt; { 
   // do a final something 
}) 
.catch(err =&gt; { 
   // errors land here 
}); </pre>
<p>This works because the <kbd>Promise</kbd> class supports chaining if a <kbd>then</kbd> function returns a <kbd>Promise</kbd> object.</p>
<p>The <kbd>async/await</kbd> feature implements the promise of the Promise class to simplify asynchronous coding. This feature becomes active within an <kbd>async</kbd> function:</p>
<pre>async function mumble() {<br/>   // async magic happens here<br/>}</pre>
<p>An <kbd>async</kbd> arrow function is as follows: </p>
<pre>const mumble = async () =&gt; {<br/>    // async magic happens here<br/>};</pre>
<p>It's used as so:</p>
<pre>async function doSomething(arg1, arg2, arg3, arg4, arg5) {<br/>    var { result1, result2 } = await doThis(arg1, arg2);<br/>    var results = await doThat(arg2, arg3);<br/>    await doSomethingElse(arg5);<br/>    // do a final something<br/>    return finalResult;<br/>}</pre>
<p>Isn't this a breath of fresh air compared to the nested structure we started with?</p>
<p>The <kbd>await</kbd> keyword is used with a Promise. It automatically waits for the Promise to resolve. If the Promise resolves successfully then the value is returned, and if it resolves with an error then that error is thrown. Both handling results and throwing errors are handled in the natural manner.</p>
<p>This example also shows another ES2015 feature: destructuring. The fields of an object can be extracted using the following:</p>
<pre>var { value1, value2 } = {<br/>    value1: "Value 1", value2: "Value 2", value3: "Value3"<br/>};<strong> </strong></pre>
<p>We have an object with three fields, but extract only two of the fields.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using Babel to use experimental JavaScript features</h1>
                
            
            
                
<p>The Babel transpiler (<a href="http://babeljs.io/">http://babeljs.io/</a>) is a great way to use cutting-edge JavaScript features on older implementations. The word <strong>transpile</strong> means Babel rewrites JavaScript code into other JavaScript code, specifically to rewrite ES-2015 or ES-2016 features to older JavaScript code. Babel converts JavaScript source to an abstract syntax tree, then manipulates that tree to rewrite the code using older JavaScript features, and then writes that tree to a JavaScript source code file.</p>
<p>Put another way, Babel rewrites JavaScript code into JavaScript code, applying desired transformations such as converting ES2015/2016 features into ES5 code that can run in a web browser.</p>
<p>Many use Babel to experiment with new JavaScript feature proposals working their way through the TC-39 committee. Others use Babel to use new JavaScript features in projects on JavaScript engines that do not support those features.</p>
<p>The Node Green website makes it clear that Node.js supports pretty much all of the ES2015/2016/2017 features. Therefore, as a practical matter, we no longer need to use Babel for Node.js projects. </p>
<p>For web browsers, there is a much longer time lag between a set of ECMAScript features and when we can reliably use those features in browser-side code. It's not that the web browser makers are slow in adopting new features, because the Google, Mozilla, and Microsoft teams are proactive about adopting the latest features. Apple's Safari team seems slow to adopt new features, unfortunately. What's slower, however, is the penetration of new browsers into the fleet of computers in the field. </p>
<p>Therefore, modern JavaScript programmers need to familiarize themselves with Babel.</p>
<p>We're not ready to show example code for these features, but we can go ahead and document the setup of the Babel tool. For further information on setup documentation, visit <a href="http://babeljs.io/docs/setup/">http://babeljs.io/docs/setup/</a>, and then click on the CLI button.</p>
<p>To get a brief introduction to Babel, we'll use it to transpile the scripts we saw earlier to run on Node.js 6.x. In those scripts we used async functions, which are not supported in Node.js 6.x. </p>
<p class="mce-root"/>
<p>In the directory containing <kbd>ls.js</kbd> and <kbd>ls2.js</kbd>, type these commands:</p>
<pre><strong>$ npm install babel-cli \
       babel-plugin-transform-es2015-modules-commonjs \<br/>       babel-plugin-transform-async-to-generator</strong></pre>
<p>This installs the Babel software, along with a couple of transformation plugins. Babel has a plugin system so that you enable the transformations required by your project. Our primary goal in this example is converting the <kbd>async</kbd> functions shown earlier into Generator functions. Generators are a new sort of function introduced with ES2015, which form the foundation for implementation of <kbd>async</kbd> functions.</p>
<p>Because Node.js 6.x does not have <kbd>util.promisify</kbd>, we need to make one substitution:</p>
<pre>// const fs_readdir = util.promisify(fs.readdir);<br/>const fs_readdir = dir =&gt; {<br/>   return new Promise((resolve, reject) =&gt; {<br/>       fs.readdir(dir, (err, fileList) =&gt; {<br/>           if (err) reject(err);<br/>           else resolve(fileList);<br/>       });<br/>    });<br/>};</pre>
<p>This structure is more or less what the <kbd>util.promisify</kbd> function does.</p>
<p>Next, create a file named <kbd>.babelrc</kbd> containing the following:</p>
<pre>{<br/> "plugins": [<br/>   "transform-es2015-modules-commonjs",<br/>   "transform-async-to-generator"<br/> ]<br/>}</pre>
<p>This file instructs Babel to use the named transformation plugins that we installed earlier.</p>
<p>Because we installed <kbd>babel-cli</kbd>, a <kbd>babel</kbd> command is installed such that we can type the following:</p>
<pre><strong>$ ./node_modules/.bin/babel -help </strong> </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>To transpile your code, run the following command:</p>
<pre><strong>$ ./node_modules/.bin/babel ls2.js -o ls2-babel.js </strong> </pre>
<p>This command transpiles the named file, producing a new file. The new file is as follows:</p>
<pre>'use strict';<br/><br/>function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }<br/><br/>const fs = require('fs');<br/>const util = require('util');<br/>// const fs_readdir = util.promisify(fs.readdir);<br/><br/>const fs_readdir = dir =&gt; {<br/> return new Promise((resolve, reject) =&gt; {<br/>   fs.readdir(dir, (err, fileList) =&gt; {<br/>     if (err) reject(err);<br/>     else resolve(fileList);<br/>   });<br/> });<br/>};<br/><br/>_asyncToGenerator(function* () {<br/> var dir = '.';<br/> if (process.argv[2]) dir = process.argv[2];<br/> const files = yield fs_readdir(dir);<br/> for (let fn of files) {<br/>     console.log(fn);<br/> }<br/>})().catch(err =&gt; {<br/> console.error(err);<br/>});</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This code isn't meant to be easy to read by humans. Instead, it's meant that you edit the original source file, and then convert it for your target JavaScript engine. The main thing to notice is that the transpiled code uses a Generator function in place of the <kbd>async</kbd> function, and the <kbd>yield</kbd> keyword in place of the <kbd>await</kbd> keyword. The <kbd>_asyncToGenerator</kbd> function implements functionality similar to async functions.</p>
<p>The transpiled script is run as follows:</p>
<pre><strong>$ node ls2-babel</strong><br/><strong>.babelrc</strong><br/><strong>app.js</strong><br/><strong>babel</strong><br/><strong>ls.js</strong><br/><strong>ls2-babel.js</strong><br/><strong>ls2.js</strong><br/><strong>node_modules</strong></pre>
<p>In other words, it runs the same as the <kbd>async</kbd> version, but on an older Node.js release.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>You learned a lot in this chapter about installing Node.js, using its command-line tools, and running a Node.js server. We also breezed past a lot of details that will be covered later in the book, so be patient.</p>
<p>Specifically, we covered downloading and compiling the Node.js source code, installing Node.js either for development use in your home directory or for deployment in system directories and installing NPM—the de facto standard package manager used with Node.js. We also saw how to run Node.js scripts or Node.js servers. We then took a look at the new features in ES-2015/2016/2017. Finally, we saw how to use Babel to implement those features in your code.</p>
<p>Now that we've seen how to set up the basic system, we're ready to start working on implementing applications with Node.js. First, you must learn the basic building blocks of Node.js applications and modules, which we will cover in the next chapter.</p>


            

            
        
    </div>



  </body></html>