["```js\n// The executor function used by our promise.\n// The first argument is the resolver function,\n// which is called in 1 second to resolve the promise.\nfunction executor(resolve) {\n    setTimeout(resolve, 1000);\n}\n\n// The fulfillment callback for our promise. This\n// simply stopsthe fullfillment timer that was\n// started after our executor function was run.\nfunction fulfilled() {\n    console.timeEnd('fulfillment');\n}\n\n// Creates the promise, which will run the executor\n// function immediately. Then we start a timer to see\n// how long it takes for our fulfillment function to\n// be called.\nvar promise = new Promise(executor);\npromise.then(fulfilled);\nconsole.time('fulfillment');\n```", "```js\n// The executor function used by our promise.\n// Sets a timeout that calls \"resolve()\" one second\n// after the promise is created. It's resolving\n// a string value - \"done!\".\nfunction executor(resolve) {\n    setTimeout(() => {\n        resolve('done!');\n    }, 1000);\n}\n\n// The fulfillment callback for our promise accepts\n// a value argument. This is the value that's passed\n// to the resolver.\nfunction fulfilled(value) {\n    console.log('resolved', value);\n}\n\n// Create our promise, providing the executor and\n// fulfillment function callbacks.\nvar promise = new Promise(executor);\npromise.then(fulfilled);\n```", "```js\n// This executor function rejects the promise after\n// a timeout of one second. It uses the rejector function\n// to change the state, and to provide the rejected\n// callbacks with a value.\nfunction executor(resolve, reject) {\n    setTimeout(() => {\n        reject('Failed');\n    }, 1000);\n}\n\n// The function used as a rejected callback function. It\n// expects a reason for the rejection to be provided.\nfunction rejected(reason) {\n    console.error(reason);\n}\n\n// Creates the promise, and runs the executor. Uses the\n// \"catch()\" method to assing the rejector callback function.\nvar promise = new Promise(executor);\npromise.catch(rejected);\n```", "```js\n// This promise executor throws an error, and the rejected\n// callback function is called as a result.\nnew Promise(() => {\n    throw new Error('Problem executing promise');\n}).catch((reason) => {\n    console.error(reason);\n});\n\n// This promise executor catches an error, and rejects\n// the promise with a more useful message.\nnew Promise((resolve, reject) => {\n    try {\n        var size = this.name.length;\n    } catch(error) {\n        reject(error instanceof TypeError ?\n            'Missing \"name\" property' : error);\n    }\n}).catch((reason) => {\n    console.error(reason);\n});\n```", "```js\n// This promise is able to run the executor\n// function without issue. The \"then()\" callback\n// is never executed.\nnew Promise(() => {\n    console.log('executing promise');\n}).then(() => {\n    console.log('never called');\n});\n\n// At this point, we have no idea what's\n// wrong with the promise.\nconsole.log('finished executing, promise hangs');\n```", "```js\n// A wrapper for promise executor functions, that\n// throws an error after the given timeout.\nfunction executorWrapper(func, timeout) {\n\n    // This is the function that's actually called by the\n    // promise. It takes the resolver and rejector functions\n    // as arguments.\n    return function executor(resolve, reject) {\n        // Setup our timer. When time runs out, we can\n        // reject the promise with a timeout message.\n        var timer = setTimeout(() => {\n            reject(`Promise timed out after ${timeout}MS`);\n        }, timeout);\n\n        // Call the original executor function that we're\n        // wrapping. We're actually wrapping the resolver\n        // and rejector functions as well, so that when the\n        // executor calls them, the timer is cleared.\n        func((value) => {\n            clearTimeout(timer);\n            resolve(value);\n        }, (value) => {\n            clearTimeout(timer);\n            reject(value);\n        });\n    };\n}\n\n// This promise executor times out, and a timeout\n// error message is passed to the rejected callback.\nnew Promise(executorWrapper((resolve, reject) => {\n    setTimeout(() => {\n        resolve('done');\n    }, 2000);\n}, 1000)).catch((reason) => {\n    console.error(reason);\n});\n\n// This promise resolves as expected, since the executor\n// calls \"resolve()\" before time's up.\nnew Promise(executorWrapper((resolve, reject) => {\n    setTimeout(() => {\n        resolve(true);\n    }, 500);\n}, 1000)).then((value) => {\n    console.log('resolved', value);\n});\n```", "```js\n// Creates 5 promises that log when they're\n// executing, and when they're reacting to a\n// resolved value.\nfor (let i = 0; i < 5; i++) {\n    new Promise((resolve) => {\n        console.log('executing promise');\n        resolve(i);\n    }).then((value) => {\n        console.log('resolved', i);\n    });\n}\n\n// This is called before any of the fulfilled\n// callbacks, because this call stack job needs\n// to complete before the interpreter reaches into\n// the promise resolution callback queue, where\n// the 5 \"then()\" callbacks are currently sitting.\nconsole.log('done executing');\n\n// â†’\n// executing promise\n// executing promise\n// ...\n// done executing\n// resolved 1\n// resolved 2\n// ...\n```", "```js\n// A generic function used to fetch resources\n// from the server, returns a promise.\nfunction get(path) {\n    return new Promise((resolve, reject) => {\n        var request = new XMLHttpRequest();\n\n        // The promise is resolved with the parsed\n        // JSON data when the data is loaded.\n        request.addEventListener('load', (e) => {\n            resolve(JSON.parse(e.target.responseText));\n        });\n\n        // When there's an error with the request, the\n        // promise is rejected with the appropriate reason.\n        request.addEventListener('error', (e) => {\n            reject(e.target.statusText || 'unknown error');\n        });\n\n        // If the request is aborted, we simply resolve the\n        // request.\n        request.addEventListener('abort', resolve);\n\n        request.open('get', path);\n        request.send();\n    });\n}\n\n// We can attach our \"then()\" handler directly\n// to \"get()\" since it returns a promise. The\n// value used here was a true asynchronous operation\n// that had to go fetch a remote value, and parse it,\n// before resolving it here.\nget('api.json').then((value) => {\n    console.log('hello', value.hello);\n});\n```", "```js\n// This promise executor will randomly resolve\n// or reject the promise.\nfunction executor(resolve, reject) {\n    cnt++;\n    Math.round(Math.random()) ?\n        resolve(`fulfilled promise ${cnt}`) :\n        reject(`rejected promise ${cnt}`);\n}\n\n// Make \"log()\" and \"error()\" functions for easy\n// callback functions.\nvar log = console.log.bind(console),\n    error = console.error.bind(console),\n    cnt = 0;\n\n// Creates a promise, then assigns the error\n// callback via the \"catch()\" method.\nnew Promise(executor).then(log).catch(error);\n\n// Creates a promise, then assigns the error\n// callback via the \"then()\" method.\nnew Promise(executor).then(log, error);\n```", "```js\n// Extends the promise prototype with an \"always()\"\n// method. The given function will always be called,\n// whether the promise is fulfilled or rejected.\nPromise.prototype.always = function(func) {\n    return this.then(func, func);\n};\n\n// Creates a promise that's randomly resolved or\n// rejected.\nvar promise = new Promise((resolve, reject) => {\n    Math.round(Math.random()) ?\n        resolve('fulfilled') : reject('rejected');\n});\n\n// Give the promise fulfillment and rejection callbacks.\npromise.then((value) => {\n    console.log(value);\n}, (reason) => {\n    console.error(reason);\n});\n\n// This callback is always called after the one of\n// the callbacks above.\npromise.always((value) => {\n    console.log('cleaning up...');\n});\n```", "```js\n// Keeps a list of resolver functions.\nvar resolvers = [];\n\n// Creates 5 new promises, and in each executor\n// function, the resolver is pushed onto the\n// \"resolvers\" array. We also give each promise\n// a fulfillment callback.\nfor (let i = 0; i < 5; i++) {\n    new Promise((resolve) => {\n        resolvers.push(resolve);\n    }).then((value) => {\n        console.log(`resolved ${i + 1}`, value);\n    });\n}\n\n// Sets a timeout that runs the function after 2\n// seconds. When it runs, we iterate over every\n// resolver function in the \"resolvers\" array,\n// and we call it with a value.\nsetTimeout(() => {\n    for (let resolver of resolvers) {\n        resolver(true);\n    }\n}, 2000);\n```", "```js\n// The \"Promise.resolve()\" method can resolve thenable\n// objects. This is an object with a \"then()\" method\n// which serves as the executor. This executor will\n// randomly resolve or reject the promise.\nPromise.resolve({ then: (resolve, reject) => {\n    Math.round(Math.random()) ?\n        resolve('fulfilled') : reject('rejected');\n\n// This method returns a promise, so we're able\n// to setup our fulfilled and rejected callbacks as\n// usual.\n}}).then((value) => {\n    console.log('resolved', value);\n}, (reason) => {\n    console.error('reason', reason);\n});\n```", "```js\n// This executor function attempts to resolve the\n// promise twice, but the fulfilled callback is\n// only called once.\nnew Promise((resolve, reject) => {\n    resolve('fulfilled');\n    resolve('fulfilled');\n}).then((value) => {\n    console.log('then', value);\n});\n\n// This executor function attempts to reject the\n// promise twice, but the rejected callback is\n// only called once.\nnew Promise((resolve, reject) => {\n    reject('rejected');\n    reject('rejected');\n}).catch((reason) => {\n    console.error('reason');\n});\n```", "```js\n// This executor function resolves the promise immediately.\n// By the time the \"then()\" callback is added, the promise\n// is already resolved. But the callback is still called\n// with the resolved value.\nnew Promise((resolve, reject) => {\n    resolve('done');\n    console.log('executor', 'resolved');\n}).then((value) => {\n    console.log('then', value);\n});\n\n// Creates a new promise that's resolved immediately by\n// the executor function.\nvar promise = new Promise((resolve, reject) => {\n    resolve('done');\n    console.log('executor', 'resolved');\n});\n\n// This callback is run immediately, since the promise\n// has already been resolved.\npromise.then((value) => {\n    console.log('then 1', value);\n});\n\n// This callback isn't added to the promise for another\n// second after it's been resolved. It's still called\n// right away with the resolved value.\nsetTimeout(() => {\n    promise.then((value) => {\n        console.log('then 2', value);\n    });\n}, 1000);\n```", "```js\n// Creates a promise that's resolved immediately, and\n// is stored in \"promise1\".\nvar promise1 = new Promise((resolve, reject) => {\n    resolve('fulfilled');\n});\n\n// Use the \"then()\" method of \"promise1\" to create a\n// new promise instance, which is stored in \"promise2\".\nvar promise2 = promise1.then((value) => {\n    console.log('then 1', value);\n    // â†’ then 1 fulfilled\n});\n\n// Create a \"then()\" callback for \"promise2\". This actually\n// creates a third promise instance, but we don't do anything\n// with it.\npromise2.then((value) => {\n    console.log('then 2', value);\n    // â†’ then 2 undefined\n});\n\n// Make sure that \"promise1\" and \"promise2\" are in fact\n// different objects.\nconsole.log('equal', promise1 === promise2);\n// â†’ equal false\n```", "```js\n// Creates a new promise that's randomly resolved or\n// rejected.\nnew Promise((resolve, reject) => {\n    Math.round(Math.random()) ?\n        resolve('fulfilled') : reject('rejected');\n}).then((value) => {\n    // Called when the original promise is resolved,\n    // returns the value in case there's another\n    // promise chained to this one.\n    console.log('then 1', value);\n    return value;\n}).catch((reason) => {\n    // Chained to the second promise, called\n    // when it's rejected.\n    console.error('catch 1', reason);\n}).then((value) => {\n    // Chained to the third promise, gets the\n    // value as expected, and returns it for any\n    // downstream promise callbacks to consume.\n    console.log('then 2', value);\n    return value;\n}).catch((reason) => {\n    // This is never called - rejections do not\n    // proliferate through promise chains.\n    console.error('catch 2', reason)\n});\n```", "```js\n// Simple utilty to compose a larger function, out\n// of smaller functions.\nfunction compose(...funcs) {\n    return function(value) {\n        var result = value;\n\n        for (let func of funcs) {\n            result = func(value);\n        }\n\n        return result;\n    };\n}\n\n// Accepts a promise or a resolved value. If it's a promise,\n// it adds a \"then()\" callback and returns a new promise.\n// Otherwise, it performs the \"update\" and returns the\n// value.\nfunction updateFirstName(value) {\n    if (value instanceof Promise) {\n        return value.then(updateFirstName);\n    }\n\n    console.log('first name', value.first);\n    return value;\n}\n\n// Works the same way as the above function, except it\n// performs a different UI \"update\".\nfunction updateLastName(value) {\n    if (value instanceof Promise) {\n        return value.then(updateLastName);\n    }\n\n    console.log('last name', value.last);\n    return value;\n}\n\n// Works the same way as the above function, except it\n// performs a different UI \"update\".\nfunction updateAge(value) {\n    if (value instanceof Promise) {\n        return value.then(updateAge);\n    }\n\n    console.log('age', value.age);\n    return value;\n}\n\n// A promise object that's resolved with a data object\n// after one second.\nvar promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve({\n            first: 'John',\n            last: 'Smith',\n            age: 37\n        });\n    }, 1000);\n});\n\n// We compose an \"update()\" function that updates the\n// various UI components.\nvar update = compose(\n    updateFirstName,\n    updateLastName,\n    updateAge\n);\n\n// Call our update function with a promise.\nupdate(promise);\n```", "```js\n// Utility to send a \"GET\" HTTP request, and return\n// a promise that's resolved with the parsed response.\nfunction get(path) {\n    return new Promise((resolve, reject) => {\n        var request = new XMLHttpRequest();\n\n        // The promise is resolved with the parsed\n        // JSON data when the data is loaded.\n        request.addEventListener('load', (e) => {\n            resolve(JSON.parse(e.target.responseText));\n        });\n\n        // When there's an error with the request, the\n        // promise is rejected with the appropriate reason.\n        request.addEventListener('error', (e) => {\n            reject(e.target.statusText || 'unknown error');\n        });\n\n        // If the request is aborted, we simply resolve the\n        // request.\n        request.addEventListener('abort', resolve);\n\n        request.open('get', path);\n        request.send();\n    });\n}\n\n// For our request promises.\nvar requests = [];\n\n// Issues 5 API requests, and places the 5 corresponding\n// promises in the \"requests\" array.\nfor (let i = 0; i < 5; i++) {\n    requests.push(get('api.json'));\n}\n\n// Using \"Promise.all()\" let's us pass in an array of\n// promises, returning a new promise that's resolved\n// when all promises resolve. Our callback gets an array\n// of resolved values that correspond to the promises.\nPromise.all(requests).then((values) => {\n    console.log('first', values.map(x => x[0]));\n    console.log('second', values.map(x => x[1]));\n});\n```", "```js\n// The resolver function used to cancel data requests.\nvar cancelResolver;\n\n// A simple \"constant\" value, used to resolved cancel\n// promises.\nvar CANCELLED = {};\n\n// Our UI components.\nvar buttonLoad = document.querySelector('button.load'),\n    buttonCancel = document.querySelector('button.cancel');\n\n// Requests data, returns a promise.\nfunction getDataPromise() {\n\n    // Creates the cancel promise. The executor assigns\n    // the \"resolve\" function to \"cancelResolver\", so\n    // it can be called later.\n    var cancelPromise = new Promise((resolve) => {\n        cancelResolver = resolve;\n    });\n\n    // The actual data we want. This would normally be\n    // an HTTP request, but we're simulating one here\n    // for brevity using setTimeout().\n    var dataPromise = new Promise((resolve) => {\n        setTimeout(() => {\n            resolve({ hello: 'world' });\n        }, 3000);\n    });\n\n    // The \"Promise.race()\" method returns a new promise,\n    // and it's resolved with whichever input promise is\n    // resolved first.\n    return Promise.race([\n        cancelPromise,\n        dataPromise\n    ]);\n}\n\n// When the cancel button is clicked, we use the\n// \"cancelResolver()\" function to resolve the\n// cancel promise.\nbuttonCancel.addEventListener('click', () => {\n    cancelResolver(CANCELLED);\n});\n\n// When the load button is clicked, we make a request\n// for data using \"getDataPromise()\".\nbuttonLoad.addEventListener('click', () => {\n    buttonLoad.disabled = true;\n\n    getDataPromise().then((value) => {\n        buttonLoad.disabled = false;\n\n        // The promise was resolved, but it was because\n        // the user cancelled the request. So we exit\n        // here by returning the CANCELLED \"constant\".\n        // Otherwise, we have data to work with.\n        if (Object.is(value, CANCELLED)) {\n            return value;\n        }\n\n        console.log('loaded data', value);\n    });\n});\n```", "```js\n// Example function that returns \"value\" from\n// a cache, or \"fetchs\" it asynchronously.\nfunction getData(value) {\n\n    // If it exists in the cache, we return\n    // this value.\n    var index = getData.cache.indexOf(value);\n\n    if (index > -1) {\n        return getData.cache[index];\n    }\n\n    // Otherwise, we have to go \"fetch\" it. This\n    // \"resolve()\" call would typically be found in\n    // a network request callback function.\n    return new Promise((resolve) => {\n        getData.cache.push(value);\n        resolve(value);\n    });\n}\n\n// Creates the cache.\ngetData.cache = [];\n\nconsole.log('getting foo', getData('foo'));\n// â†’ getting foo Promise \nconsole.log('getting bar', getData('bar'));\n// â†’ getting bar Promise\nconsole.log('getting foo', getData('foo'));\n// â†’ getting foo foo\n```", "```js\n// Example function that returns \"value\" from\n// a cache, or \"fetchs\" it asynchronously.\nfunction getData(value) {\n    var cache = getData.cache;\n\n    // If there's no cache for this function, let's\n    // reject the promise. Gotta have cache.\n    if (!Array.isArray(cache)) {\n        return Promise.reject('missing cache');\n    }\n\n    // If it exists in the cache, we return\n    // a promise that's resolved using the\n    // cached value.\n    var index = getData.cache.indexOf(value);\n\n    if (index > -1) {\n        return Promise.resolve(getData.cache[index]);\n    }\n\n    // Otherwise, we have to go \"fetch\" it. This\n    // \"resolve()\" call would typically be found in\n    // a network request callback function.\n    return new Promise((resolve) => {\n        getData.cache.push(value);\n        resolve(value);\n    });\n}\n\n// Creates the cache.\ngetData.cache = [];\n\n// Each call to \"getData()\" is consistent. Even\n// when synchronous values are used, they still\n// get resolved as promises.\ngetData('foo').then((value) => {\n    console.log('getting foo', `\"${value}\"`);\n}, (reason) => {\n    console.error(reason);\n});\n\ngetData('bar').then((value) => {\n    console.log('getting bar', `\"${value}\"`);\n}, (reason) => {\n    console.error(reason);\n});\n\ngetData('foo').then((value) => {\n    console.log('getting foo', `\"${value}\"`);\n}, (reason) => {\n    console.error(reason);\n});\n```"]