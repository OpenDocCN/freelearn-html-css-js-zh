- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transitions are essential in creating smooth and engaging user experiences.
    By defining how elements appear, disappear, or change within a user interface,
    transitions can turn ordinary interactions into captivating experiences that leave
    lasting impressions on users.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next three chapters, we will explore the topic of transitions in Svelte,
    beginning with a comprehensive understanding of how to use transitions in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by learning how to add transitions to elements
    in Svelte. We will explore the different transition directives and learn how to
    customize the transitions.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will discuss when and how the transitions are being played. We
    will look at different scenarios, such as where there’s a mix of elements with
    and without transitions, or when the elements are within nested logical blocks.
  prefs: []
  type: TYPE_NORMAL
- en: To truly master transitions, it’s important to understand the inner workings
    of the Svelte transition system. We will conclude the chapter by examining the
    underlying mechanics and offering insights that will help you optimize your use
    of transitions in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid foundation in Svelte transitions,
    allowing you to create engaging and dynamic user interfaces with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes sections on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to add transitions to elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the transitions for the elements are played
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How transitions work under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code used in this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding transitions to elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Svelte provides a simple and powerful way to add transitions to your application
    elements. The framework offers built-in transition functions that can be easily
    applied to elements, allowing for smooth animations and seamless user experiences.
    You can also define your own custom transitions, which we will learn about in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions in Svelte are applied to elements when the elements are mounted
    or unmounted from the DOM. This ensures that elements appear and disappear gracefully,
    rather than just abruptly popping in and out of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a transition to an element in Svelte, you can use the `transition:`
    directive with the desired transition function. Here’s an example of adding a
    transition to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we imported `fade` from `svelte/transition` and
    applied it to the `<``div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: What you will see with the preceding code is that when the `<div>` element is
    mounted onto the DOM, the `<div>` element will smoothly fade in. When the `<div>`
    element is unmounted from the DOM, the `<div>` element will smoothly fade out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transition:` directive sets the transitions played when the element is
    both mounted onto the DOM and unmounted from the DOM. If you want to have finer
    control over which transitions are played as the element is mounted or unmounted,
    you can use the `in:` and `out:` directives instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we applied `fade` as the in transition and `blur`
    as the out transition. When the `<div>` element is mounted onto the DOM, the `<div>`
    element will smoothly fade in. When the `<div>` element is unmounted from the
    DOM, the `<div>` element will smoothly blur out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the `transition:` directive is essentially a shorthand for both `in:`
    and `out:` transitions. In other words, the transitions applied to the two elements
    in the following snippet are functionally identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the preceding code snippet is similar to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding examples, we have seen two of Svelte’s built-in transitions,
    `fade` and `blur` – let us look at more of them!
  prefs: []
  type: TYPE_NORMAL
- en: Svelte’s built-in transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Svelte’s built-in transitions are exported from the `svelte/transition` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides an overview of Svelte’s built-in transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fade`: This transition smoothly fades an element in or out, adjusting its
    opacity over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blur`: The `blur` transition gradually applies or removes a blur effect on
    an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slide`: The `slide` transition makes an element slide smoothly in or out of
    view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fly`: The `fly` transition makes an element smoothly translate from a specified
    `x` and `y` offset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`: This transition causes an element to grow or shrink in size while
    appearing or disappearing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw`: The `draw` transition creates a drawing or erasing effect on SVG paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you go through the list of built-in transitions, you may notice that some
    of these transitions rely on user-specified values. For example, the `fly` transition
    depends on the specified `x` and `y` offset from which the element should fly
    when transitioning in.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing a transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make use of these transitions with their required values, you can pass a
    configuration object containing the necessary properties to the transition directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we apply the `fly` transition with the specified
    `x` and `y` offsets, indicating that the element will fly in from 200 pixels to
    the right and 100 pixels down. By providing the appropriate values, you can achieve
    a wide range of customized transition effects in your Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be particularly useful when you want an element to fly to
    a different location as it transitions out, compared to the location from which
    it flies in during the transition.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `transition:` directive and having only one configuration
    for both in and out transitions, you can separate it into the `in:` and `out:`
    directives and pass different configuration objects to each directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `<div>` element flies in from 200 pixels to the right and 100 pixels down,
    while it flies out 200 pixels to the left and 50 pixels down. By separating the
    `transition:` directive into `in:` and `out:` directives, you can control the
    in and out transition with different configuration objects, having more intricate
    transition effects in your Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to custom configurations specific to each transition, all of Svelte’s
    built-in transitions accept `delay`, `duration`, and `easing` as part of the transition
    configuration. These parameters allow you to control the timing of your animations,
    providing greater flexibility in designing your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `delay` parameter determines the waiting time before the transition begins
    while the `duration` parameter specifies how long the transition lasts. By modifying
    these values, you can coordinate when a transition begins and how long each transition
    takes, creating more complex and engaging animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of adjusting the `delay` and `duration` values of a `fade`
    transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: import { fade } from 'svelte/transition';
  prefs: []
  type: TYPE_NORMAL
- en: import { quadInOut } from 'svelte/easing';
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <div transition:fade=fade transition uses the quadInOut easing function, which
    causes the animation to start slowly, accelerate, and then end slowly. By incorporating
    different easing functions into your transitions, you can create a variety of
    animations for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – discovering Svelte’s built-in transitions
  prefs: []
  type: TYPE_NORMAL
- en: As a practice exercise, try to visit the official Svelte documentation and identify
    the list of configurable properties for each built-in transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get you started, here is a list of Svelte’s built-in transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fade`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slide`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know that transitions are played when elements are mounted or unmounted from
    the DOM, but when and how exactly are the transitions played?
  prefs: []
  type: TYPE_NORMAL
- en: Let us explore the timing and manner in which the transitions are played in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: When are the transitions played?
  prefs: []
  type: TYPE_NORMAL
- en: The transitions in Svelte are played when elements are added or removed from
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '`in:` transitions are executed when an element is added to the DOM. This usually
    occurs when a component is initialized or when a condition that controls the element’s
    rendering becomes `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in an `{#if}` block, when the `if` condition turns from falsy
    to truthy, the elements inside the `{#if}` block are added to the DOM. All the
    `in:` transitions applied to these elements will be **played simultaneously**
    as soon as the elements are inserted into the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, as `condition` turns to `true`, both `<div>`
    elements will be inserted into the DOM. As soon as both `<div>` elements are inserted,
    both the `fade` and `blur` transitions will start playing simultaneously. Whether
    both the `fade` and `blur` transitions end at the same time depends on the specified
    duration for each transition.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, `out:` transitions are executed when an element is removed from
    the DOM. This can happen when a component is destroyed, or when a condition that
    controls the element’s rendering becomes `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The transition begins as soon as the element is scheduled for removal from the
    DOM. After the transition is complete, the element is removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us illustrate this with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, when `condition` turns to `false`, both the `<div>`
    elements remain in the DOM, even though the condition is no longer true. This
    is because the `out:` transition needs to be played on both `<div>` elements before
    they are removed from the DOM. If the `<div>` elements were removed from the DOM
    immediately, they would no longer be visible to users, rendering any subsequent
    `out:` transitions ineffective and invisible.
  prefs: []
  type: TYPE_NORMAL
- en: Both `fade` and `blur` transitions will play simultaneously on both the `<div>`
    elements as `out:` transitions. Similar to the `in:` transition, the duration
    of each transition depends on the specified duration for each transition.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the `out:` transitions have finished playing, both `<div>` elements
    will be removed from the DOM together, making the DOM state consistent with the
    updated value of `condition`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples explaining when `in:` and `out:` transitions are played,
    all elements within the `{#if}` block had transitions applied to them, resulting
    in the transitions being played simultaneously in all the elements in the `{#if}`
    block. But, what happens if not all elements inside the `{#if}` block have transitions
    applied? Let’s discuss that next.
  prefs: []
  type: TYPE_NORMAL
- en: Handling mixed transition and static elements
  prefs: []
  type: TYPE_NORMAL
- en: When some elements inside an `{#if}` block have transitions applied and others
    do not, Svelte handles each element differently based on the specified transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when `condition` becomes `true`, the elements with transitions
    applied will animate as they are inserted into the DOM, while the static element
    without a transition will simply appear without any animation.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding code snippet, the second `<div>` element will be inserted
    and visible on the DOM immediately, as the first and third `<div>` elements fade
    and slide in, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when `condition` turns to `false`, the elements with `out``:` transitions
    (in this case, only the third `<div>` element, since the `transition:` directive
    implies both `in:` and `out:` transition) will play their respective out transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding code snippet, you will see that both the first and second
    `<div>` elements remain unchanged, and the slide transition is played on the third
    `<div>` element. All elements within the `{#if}` block will only be removed from
    the DOM together after all the `out:` transitions have finished playing.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, when you have a mix of elements with and without transitions inside
    the same logical block, all the elements will be added into and removed from the
    DOM at the same time. Svelte animates only the elements with transitions applied,
    while the static elements without transitions will be inserted or removed without
    any animations.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only seen examples using the `{#if}` block as a means of adding
    or removing elements, but there are other logical blocks in Svelte that can also
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Other Svelte logical blocks for transitions
  prefs: []
  type: TYPE_NORMAL
- en: The `{#if}` block adds or removes elements based on the `if` condition. In addition
    to the `{#if}` block, there are other logical blocks in Svelte that provide opportunities
    for applying transitions when adding or removing elements, such as `{#each}`,
    `{#await}`, and `{#key}`. These blocks can also have transitions applied to the
    elements they contain, providing a wide range of possibilities for animating your
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `{#each}` block is used to iterate over a list of items and
    render elements for each item. You can apply transitions to the elements within
    an `{#each}` block in a similar way as you would with an `{#if}` block. Let’s
    look at an example of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, as new items are added or removed from the `items` array, the
    elements within the `{#each}` block will have their respective `in:` and `out:`
    transitions played. When there is a new item in the `items` array, the new `<div>`
    element will fade into the end of the list. When an element is removed from the
    `items` array, the respective `<div>` element will slide out of the list. Using
    transitions in a list allows you to create a dynamic and engaging user experience,
    providing clear visual cues when items are added to or removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can use transitions with `{#await}` and `{#key}` blocks to create
    visually appealing animations while managing the addition and removal of elements
    in various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The `transition:`, `in:`, and `out:` directives can be applied to any elements,
    and elements within the same logical block will be added or removed at the same
    time. This also holds true for nested logical blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let us consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When `condition` changes from `false` to `true`, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `<p>` element with the `blur` transition will animate as it is inserted
    into the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simultaneously, for each item in the `items` array, the `<div>` elements with
    the `fade` transition will animate as they are inserted into the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last `<p>` element, which does not have any transition, will simply appear
    in the DOM without animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversely, when `condition` changes from `true` to `false`, the following
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `<p>` element with the `blur` transition will animate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simultaneously, for each item in the `items` array, the `<div>` elements with
    the `fade` transition will animate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last `<p>` element, which does not have a transition, will remain unchanged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all the transitions in the `<p>` element and all the `<div>` elements in
    the `{#each}` block have finished, both the `<p>` and `<div>` elements will be
    removed from the DOM together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using transitions in combination with nested logical blocks, you can create
    intricate animations that enhance the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: By default, transitions are only played when the nearest logical block causes
    an addition or removal of the element. However, we can change this behavior with
    the `global` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: The global modifier
  prefs: []
  type: TYPE_NORMAL
- en: Transitions being played only when the nearest logical block causes an addition
    or removal of the element helps limit the number of simultaneous animations, making
    the user experience more focused and less overwhelming. This is called the *local*
    mode; that is, transitions are only applied for local changes.
  prefs: []
  type: TYPE_NORMAL
- en: To change this behavior, we can apply the `global` modifier. The `global` modifier,
    when applied to the `transition:`, `in:`, and `out:` directives, ensures that
    the animation is played whenever the element is added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the `global` modifier, simply suffix the directive with `|global`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As per the preceding example, before applying the `global` modifier, the `fade`
    animation was only being played when the nearest logical block, the `{#if}` block,
    triggered the insertion or removal of the `<div>` element. This means that if
    another parent logical block caused the addition or removal of the element, the
    animation would not be played. With the `global` modifier, the transition will
    be played whenever the `<div>` element is added or removed, irrespective of which
    logical block causes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To elaborate further, let us look at the following nested `{#if}` block example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let us start with `condition1` as `false` and `condition2` as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When `condition1` turns `true`, the three `<div>` elements will be inserted
    into the DOM together. Since `condition2` has always been `true`, at this point,
    the `{#if}` block that causes all the `<div>` elements to be inserted is the one
    with `condition1`.
  prefs: []
  type: TYPE_NORMAL
- en: The first `<div>` element will fade in because its nearest logical block, `{#if
    condition1}`, is responsible for the insertion of the `<``div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: The second `<div>` element will be immediately visible on the screen without
    playing the `fade` transition. This is because, by default, the transition is
    in *local* mode, and its nearest logical block, `{#if condition2}`, is not the
    cause of the `<div>` element being inserted at this point.
  prefs: []
  type: TYPE_NORMAL
- en: The third `<div>` element will fade in simultaneously with the first `<div>`
    element. Because the `<div>` element has the `|global` modifier applied to its
    transition, it doesn’t matter which logical block is responsible for its insertion.
    The transition will play regardless of the specific logical block that causes
    the `<div>` element to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Now what if `condition1` turns from `true` to `false`?
  prefs: []
  type: TYPE_NORMAL
- en: The same logic applies; therefore, the second `<div>` element will remain unchanged,
    and only the first and third `<div>` elements will fade out. Once the fade transition
    has finished, all three `<div>` elements will be removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenarios we have walked through, the second `<div>` element’s `fade`
    transition has not been played yet. So, when will the `fade` transition of the
    second `<div>` element be played?
  prefs: []
  type: TYPE_NORMAL
- en: To understand when the `fade` transition of the second `<div>` element will
    be played, let’s consider the situation where `condition1` remains `true` and
    `condition2` changes from `false` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When `condition1` is `true` and `condition2` changes from `false` to `true`,
    the second `<div>` element will be inserted into the DOM. Since its nearest logical
    block, `{#if condition2}`, is now responsible for the insertion, the `transition:fade`
    transition will be played.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with the `global` modifier, we can change when transitions are
    played in response to changes. Instead of playing the transition only when they
    are relevant to specific conditions affecting the elements, we can change it to
    be played all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between Svelte 3 and Svelte 4
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve explained earlier, Svelte transitions are in *local* mode by default.
    However, this is only changed in Svelte 4, where in Svelte 3 it is the other way
    around. In Svelte 3, transitions are in *global* mode by default, and you would
    need to apply the `local` modifier to the transition to change it to *local* mode.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered how to add a transition to an element, using the `transition:`,
    `in:`, and `out:` directives. We have learned when and how the transitions are
    played. Before we end the chapter, let us dive deeper into the inner workings
    of transitions in Svelte to better understand their mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: How Svelte transition works under the hood
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into the inner workings of Svelte transitions, let us first
    briefly discuss the general methods for creating animations on the web. Understanding
    these fundamental concepts provides a solid foundation for grasping how Svelte
    transitions work.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you can create animations using either CSS or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations with CSS
  prefs: []
  type: TYPE_NORMAL
- en: To create animations using CSS, you can use the CSS `animation` property along
    with the `@keyframes` rules. The `@keyframes` rule is used to define a sequence
    of styles, specifying the CSS styles at each keyframe (from 0% to 100%) during
    the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'See this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we defined an animation keyframe named `example`
    that changes the opacity from 100% to 0% and the scale from 1 to 1.75 simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the `example` animation to an element, we use the CSS `animation`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we set the animation to the `example` animation
    keyframe, with a duration of four seconds, a delay of one second, and only play
    the animation exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: The `@keyframes` rule is versatile. We have fine-grained control over the intermediate
    steps of the animation sequence through `@keyframes` declarations. Combining it
    with the `animation` property, we control how the animation would look, and when
    and how long it will play.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using CSS to create animations are that it does not involve
    JavaScript, and the browser can optimize for the CSS animation on its own. This
    saves JavaScript bandwidth, and as a result, the animation can run smoothly even
    if you have intensive JavaScript tasks running concurrently. This ensures a better
    performance and user experience, as the animations remain responsive and fluid
    even under heavy processing loads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations with JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: Creating animation using JavaScript involves manipulating the DOM elements’
    styles and properties dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let us write a fade-in animation using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need to gradually change the element’s opacity from `0`
    to `1`. To set a `<div>` element’s opacity to `0` in JavaScript, we set it directly
    through the element’s `style.opacity` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we assumed that we have obtained a reference
    to the `<div>` element, which we have stored in the variable named `div`. We then
    set the opacity of the `<div>` element to `0` through the `div` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To animate the opacity of an element from one value to another, you would need
    to update the styles at regular intervals over a specified duration of time.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of setting a fixed interval through `setInterval`, the interval for
    updating styles is usually achieved using the `requestAnimationFrame` method.
    `requestAnimationFrame` is a browser method that optimizes the animation performance
    by calling the specified function before the next repaint occurs. `requestAnimationFrame`
    helps ensure that your animations run smoothly and efficiently by allowing the
    browser to determine the best time to update the styles, avoiding unnecessary
    work or redundant repaints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `requestAnimationFrame` to create an animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we schedule the `loop` function in the next animation
    frame until the progress is finished. We calculate `progress` as the percentage
    of time passed over the total duration of the animation. With the value of `progress`,
    we calculate the opacity and the scale of the `<``div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the end result of using JavaScript animation with `requestAnimationFrame`
    is the same as the end result achieved with the examples of using CSS animations
    from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The `<div>` element starts at opacity `1` and scale `1` at the beginning of
    the animation and ends up with opacity `0` and scale `1.75` at the end of the
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript for animations offers more control over the animation logic,
    enabling you to create complex and interactive animations that can respond to
    user input or other events.
  prefs: []
  type: TYPE_NORMAL
- en: However, one of the downsides of using JavaScript for animations is that it
    can be more resource-intensive as the animations rely on the browser’s JavaScript
    engine to process and execute the animation logic.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the two different approaches to creating animations
    on the web, which one does the Svelte transition use?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is both.
  prefs: []
  type: TYPE_NORMAL
- en: Animating transitions in Svelte
  prefs: []
  type: TYPE_NORMAL
- en: Although all of Svelte’s built-in transitions use CSS for animating, Svelte
    is capable of animating transitions using both CSS and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: To animate the transition through CSS, Svelte generates a one-time-only `@keyframes`
    rule for each element, based on the transition and the specified configuration
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a `fly` transition as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the `fly` transition is applied to a `<div>`
    element. In response to that, Svelte generates a `@keyframes` rule that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This generated `@keyframes` rule will be applied to the element for the duration
    of the transition. The `unique-id` part of the keyframe name ensures that each
    generated keyframe is unique and doesn’t interfere with other elements.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the specified `duration` and `delay` of the transition, Svelte will
    calculate the appropriate timing for the animation and apply the generated `@keyframes`
    rule to the element, using the CSS `animation` property. The element will then
    animate according to the specified `transition`, `duration`, and `delay`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code snippet, we have a `fly` transition applied
    to a `<div>` element with a specified duration of 500 ms and a delay of 200 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To animate the `fly` transition in the preceding code snippet, Svelte will
    generate the corresponding keyframe animation, and apply the generated keyframe
    animation to the element with the specified duration and delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to animate a transition using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte will schedule a loop through `requestAnimationFrame` to run the animation
    throughout the specified duration.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t delve further into the specifics of how the `requestAnimationFrame`
    loop works with the animation at this point. In the next chapter, we will explore
    the creation of custom transitions using JavaScript, which will provide a deeper
    understanding of how the `requestAnimationFrame` loop interacts with animations
    and how to effectively utilize it for smooth, engaging transitions. Stay tuned
    to learn more about crafting your own unique animations with Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to add a transition onto an element. We explored
    the `transition:`, `in:`, and `out:` directives, and how to customize them.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we looked at when and how the transitions are played. We discussed
    how the transitions are played when we have a mix of elements with and without
    transitions, and also how the transitions are played when used inside elements
    within nested logical blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we dug deeper into how the transition animations are played
    by Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you can now confidently apply transitions into elements
    when working with Svelte. This will allow you to enhance the interactivity and
    visual appeal of your applications, thereby providing a more engaging user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look beyond the built-in transitions and will explore
    the creation of custom transitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
