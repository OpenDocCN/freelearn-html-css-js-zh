<html><head></head><body>
        

                            
                    <h1 class="header-title">Inheritance and Composition</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Extending a class</li>
<li>Assigning additional properties with constructor arguments</li>
<li>Overriding parent class instance methods</li>
<li>Overriding parent class static methods</li>
<li>Calling super methods</li>
<li>Using composition rather than inheritance to add behavior</li>
<li>Using mix-ins to add behavior</li>
<li>Passing a class as an argument</li>
<li>Checking class inheritance with Object.getPrototypeOf</li>
<li>Using throw to simulate abstract classes</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In the previous chapter, we saw how to use the new class syntax to implement behavior that was only slightly more difficult to implement directly with a prototype. A developer could be excused for thinking that this complexity of the language was not worth it. After all, it's only a line (or perhaps a character) or two extra to get the same behavior.</p>
<p>The real advantage of using the new ES6 class syntax to create object prototypes is revealed when more complicated structures and techniques are used. In essence, we'll see that it's much easier to understand code when the behavior is defined with keywords, rather than context-sensitive operators.</p>
<p>In this chapter, we'll look at how to implement some more sophisticated behaviors using classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending a class</h1>
                
            
            
                
<p>Extending classes can be used to allow for new behaviors, while adhering to common interfaces. While it's not always the best way to organize relationships between objects, there are many situations where extension (sometimes called inheritance) is the most effective way to structure behavior.</p>
<p>In this recipe, we'll see a very simple example of extension.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-01-extending-classes</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd> that takes a constructor argument <kbd>name</kbd> and assigns it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor(name) { 
    this.name = name; 
  } 
} </pre>
<ol start="5">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket {} </pre>
<ol start="6">
<li>Create a <kbd>main</kbd> function that creates instances of both classes and logs out their names:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V'); 
  const falconHeavy = new Rocket('Falcon Heavy'); 
 
  console.log(saturnV.name, ' is a rocket.'); 
  console.log(falconHeavy.name, ' is also a rocket.'); 
} </pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser:<br/>
 <kbd>http://localhost:8000/</kbd>.</li>
<li>You will see output like the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/34960f81-4db0-4ab7-b4cf-59a0521933b9.png" style="width:51.08em;height:31.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>classInactiveRocket</kbd> extends <kbd>Rocket</kbd>. This means that all of the properties on the prototype of <kbd>Rocket</kbd> end up on the instance of <kbd>InactiveRocket</kbd> unless they are overridden. The constructor is special, but it is also a property on the <kbd>Rocket</kbd> prototype. Therefore, when the two instances are created, the <kbd>Rocket</kbd> class constructor is executed for both the <kbd>Rocket</kbd> and <kbd>InactiveRocket</kbd> instances. So, we see the <kbd>name</kbd> property assigned on both instances.</p>
<p>We'll see how to override methods and other behaviors in future recipes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Assigning additional properties with constructor arguments</h1>
                
            
            
                
<p>If we are extending a class, we'll want it to be a little bit different. Otherwise, what's the point of extending it? In this recipe we'll differentiate a child class by adding additional properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-02-additional-constructor-args</kbd>.</li>
</ol>
<ol start="3">
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd> that takes a constructor argument <kbd>name</kbd> and assigns it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor(name) { 
    this.name = name; 
  } 
} </pre>
<ol start="4">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class, and assigns an additional <kbd>lastFlown</kbd> property in the constructor:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket { 
  constructor(name, lastFlown) { 
    super(name); 
    this.lastFlown = lastFlown; 
  } 
} </pre>
<ol start="5">
<li>Create a <kbd>main</kbd> function that creates instances of both classes and logs out their names, and the <kbd>lastFlown</kbd> property of the <kbd>InactiveRocket</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V', new Date('May <br/>  14,1973')); 
  const falconHeavy = new Rocket('Falcon Heavy'); 
     
  console.log(falconHeavy.name + ' is a Rocket'); 
  console.log(saturnV.name + ' is an inactive rocket'); 
  console.log(`${saturnV.name} was last flown:<br/>  ${rocket.lastFlown}`); 
} </pre>
<ol start="6">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="7">
<li>You should see output like the following:</li>
</ol>
<div><img src="img/b8e2d1cd-fe69-487a-87a6-17e37c415772.png" style="width:50.42em;height:31.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This recipe differs from the previous simple extension example. By implementing a constructor on <kbd>InactiveRocket</kbd>, we are able to pass a different set of arguments. The <kbd>lastFlown</kbd> property is unique to <kbd>InactiveRocket</kbd>. Thus, we see that property on instances of <kbd>InactiveRocket</kbd>, but not on instances of <kbd>Rocket</kbd>.</p>
<p>You'll notice that the <kbd>super</kbd> method is called in the constructor of <kbd>InactiveRocket</kbd>. This manually executes the <kbd>Rocket</kbd> constructor for the current instance. That is why the <kbd>name</kbd> property is also attached. If we did not execute <kbd>super</kbd>, then the <kbd>Rocket</kbd> constructor would not have been called.</p>
<p>In this way, we've kept the properties from the parent class <kbd>Rocket</kbd> as well as adding an additional property to the <kbd>InactiveRocket</kbd> child class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overriding parent class instance methods</h1>
                
            
            
                
<p>Ideally, classes contain more than just properties. Well-designed classes also define behavior. Thus, sub-classes should also be extending behavior, not just adding additional properties.</p>
<p>In this recipe, we'll see how to override methods from a parent class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-03-defining-methods</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd><strong>.</strong> Add a constructor that takes a constructor argument <kbd>name</kbd> and assigns it to an instance property. Then, define a simple <kbd>print</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor(name) { 
    this.name = name; 
  } 
 
  print() { 
    console.log(this.name + ' is a Rocket'); 
  } 
}  </pre>
<ol start="5">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class and assigns an additional <kbd>lastFlow</kbd> property in the constructor. Then, override the <kbd>print</kbd> method to include the new property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket { 
  constructor(name, lastFlown) { 
    super(name); 
    this.lastFlown = lastFlown; 
  } 
 
  print() { 
    console.log(this.name + ' is an inactive rocket'); 
    console.log(`${this.name} was last flown: <br/>    ${this.lastFlown}`); 
  } 
} </pre>
<ol start="6">
<li>Create a <kbd>main</kbd> function that creates instances of both classes and calls the <kbd>print</kbd> method of both:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V', new Date('May <br/>  14,1973')); 
  const falconHeavy = new Rocket('Falcon Heavy'); 
 
  [saturnV, falconHeavy].forEach((r) =&gt; r.print()); 
}  </pre>
<ol start="7">
<li>Start you Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="8">
<li>You should see output like the following:</li>
</ol>
<div><img src="img/ff3f5923-208c-480d-850d-71842d757873.png" style="width:51.92em;height:32.42em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Adding methods to the body of a class definition is the same as attaching properties to the prototype of a function, with functions as their values. This means that those properties are added as properties to the instance of the new object. When these methods are called, the context (the value of <kbd>this</kbd>) is the current instance.</p>
<p>This is similar to the <em>Defining function properties as methods on a plain object</em> recipe in <a href="0ff0c6a3-a324-4346-8ba5-37275e85aa1b.xhtml">Chapter 6</a>, <em>Plain Objects</em>. In that recipe, we overrode methods by direct assignment. By contrast, in this recipe, we are doing this on the prototype. That means that this override applies to every instance of the <kbd>InactiveRocket</kbd> subclass.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overriding parent class static methods</h1>
                
            
            
                
<p>We've seen previously that behaviors are not limited to class instances but are also attached to the classes themselves. These <kbd>static</kbd> methods can also be overridden by subclasses.</p>
<p>In this recipe, we'll see how to override static methods.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-04-checking-with-instanceof</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create two objects <kbd>rocketMap</kbd> and <kbd>inactiveRocketMap</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
let rocketMap = {};  
let inactiveRocketMap = {}; </pre>
<ol start="5">
<li>Define a new class named <kbd>Rocket</kbd>. Add a constructor. Use the name to assign the instance to the <kbd>rocketMap</kbd> and define a simple <kbd>print</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor(name) { 
    this.name = name; 
    rocketMap[name] = this; 
     } 
  print() { 
    console.log(this.name + ' is a rocket'); 
  } 
}  </pre>
<ol start="6">
<li>Add a static <kbd>find</kbd> method that retrieves an instance from the <kbd>rocketMap</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  static find (name) { 
    return rocketMap[name]; 
  } 
} </pre>
<ol start="7">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class and assigns an additional <kbd>lastFlow</kbd> property in the constructor. Use the <kbd>name</kbd> to assign the instance to the <kbd>inactiveRocketMap</kbd> and override the <kbd>print</kbd> method to include the new property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket { 
 constructor(name, lastFlown) { 
    super(name); 
    this.lastFlown = lastFlown; 
    inactiveRocketMap[name] = this; 
  } 
 
  print() { 
    console.log(this.name + ' is an inactive rocket'); 
    console.log(`${this.name} was last flown: <br/>    ${this.lastFlown}`); 
  } 
} </pre>
<ol start="8">
<li>Add a static <kbd>find</kbd> method that retrieves an instance from the <kbd>rocketMap</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket { 
  static find (name) { 
    return inactiveRocketMap[name]; 
  } 
} </pre>
<ol start="9">
<li>Create a <kbd>main</kbd> function that creates instances of both classes and try to retrieve the instances from the maps:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V'); 
  const falconHeavy = new Rocket('Falcon Heavy'); 
 
  // print rocket for saturn V and falcon heavy 
  console.log('All Rockets:'); 
  Rocket.find('Saturn V').print(); 
  Rocket.find('Falcon Heavy').print(); 
  
  // print inactive entry for saturn v and attempt falcon 
  console.log('Inactive Rockets:'); 
  InactiveRocket.find('Saturn V').print(); 
  // throws an error 
  InactiveRocket.find('Falcon Heavy').print(); 
} </pre>
<ol start="10">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see output like the following:</li>
</ol>
<div><img src="img/b9d04b51-a108-4f0f-876e-1d1103705a64.png" style="width:55.42em;height:34.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Just like the instance methods, static methods defined on the child override those on the parent class. We created the <kbd>Rocket</kbd> class with a static method that locates a <kbd>Rocket</kbd> instance based on its name. We also created an <kbd>InactiveRocket</kbd> class with its own <kbd>find</kbd> method that searches in a different map. Because the <kbd>InactiveRocket</kbd> class calls <kbd>super</kbd> in its constructor, instances of both classes are added to the map used by the <kbd>Rocket</kbd> class's <kbd>find</kbd> method. While only instances of <kbd>InactiveRocket</kbd> are added to the map used in that class's <kbd>find</kbd> method.<strong><br/></strong></p>
<p>When we call <kbd>find</kbd> on the <kbd>Rocket</kbd> class we are able to retrieve instances of both classes. You'll notice that we are unable to locate instances of the <kbd>base</kbd> class using the <kbd>InactiveRocket</kbd> class's find method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling super methods</h1>
                
            
            
                
<p>Overriding methods is awesome for extending behavior. However, we sometimes want to continue to use behavior from a parent class. This is possible by using the <kbd>super</kbd> keyboard to access parent class methods.</p>
<p>In this recipe, we'll see how to use this keyword to access those methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-05-getters-read-only</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd>. Add a constructor that takes a constructor argument <kbd>name</kbd> and assigns it to an instance property. Then, define a simple <kbd>print</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor(name) { 
    this.name = name; 
  } 
 
  print() { 
    console.log(this.name + ' is a Rocket'); 
  } 
} </pre>
<ol start="5">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class and assigns an additional <kbd>lastFlow</kbd> property in the constructor. Then, override the <kbd>print</kbd> method and call <kbd>super.print</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket { 
  constructor(name, lastFlown) { 
    super(name); 
    this.lastFlown = lastFlown; 
  } 
 
  print() { 
    super.print(); 
    console.log(`${this.name} was last flown: <br/>    ${this.lastFlown}`); 
  } 
} </pre>
<ol start="6">
<li>Create a <kbd>main</kbd> function that creates instances of both classes and calls their <kbd>print</kbd> method of both:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V', new Date('May <br/>  14, 1973')); 
  const falconHeavy = new Rocket('Falcon Heavy'); 
 
  falconHeavy.print(); 
  saturnV.print(); 
} </pre>
<ol start="7">
<li>
<p>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</p>
</li>
<li>
<p>You should see output like the following:</p>
</li>
</ol>
<div><img src="img/870ebdea-fff4-403e-bb04-7863f3868ccc.png" style="width:52.17em;height:32.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Because we overrode the <kbd>print</kbd> method in the <kbd>InactiveRocket</kbd> class, calling that method will execute the code defined in that class, rather than the parents. The <kbd>super</kbd> keyword allows us to reference the prototype of the parent class. So, when the <kbd>print</kbd> method is called on the <kbd>super</kbd> keyword, the method as defined on the parent prototype is executed. Thus, we see the output of both <kbd>print</kbd> methods for the <kbd>saturnV</kbd> instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using composition rather than inheritance to add behavior</h1>
                
            
            
                
<p>So far, we've seen how to use inheritance to add behavior and compose larger structures. This is not always the ideal approach. In many situations, it's better to use a method known as composition instead. This involves using distinct classes in connection without establishing a hierarchical relationship. The chief advantage here is code clarity and flexibility.</p>
<p>In this recipe, we'll see how to use composition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-06-using-composition-instead-of-inherritence</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd>. Add a constructor that takes a constructor argument <kbd>name</kbd> and assigns it to an instance property. Then, define a simple <kbd>print</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor(name) { 
    this.name = name; 
  } 
 
  print() { 
    console.log(this.name + ' is a Rocket'); 
  } 
}  </pre>
<ol start="5">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class and assigns an additional <kbd>lastFlow</kbd> property in the constructor. Then, override the <kbd>print</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket { 
 constructor(name, lastFlown) { 
    super(name); 
    this.lastFlown = lastFlown; 
  } 
 
  print() { 
    console.log(this.name + ' is an inactive rocket'); 
    console.log(`${this.name} was last flown: <br/>    ${this.lastFlown}`); 
  } 
} </pre>
<ol start="6">
<li>Create a class named <kbd>Launcher</kbd> that takes a constructor argument <kbd>rocket</kbd>. Add a method, named <kbd>prepareForLaunch</kbd>, that aborts if the rocket is inactive:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Launcher { 
  constructor (rocket) { 
    this.rocket = rocket; 
  } 
 
  prepareForLaunch () { 
    const { rocket } = this; 
 
    if (rocket instanceof InactiveRocket) { 
      console.error(`Unable to launch, rocket ${rocket.name} has <br/>      been inactive since ${rocket.lastFlown}`); 
    } else { 
      console.log(`${rocket.name} is ready to launch.`); 
    } 
  } 
}  </pre>
<ol start="7">
<li>Create a <kbd>main</kbd> function that creates two instances of <kbd>Launcher</kbd>; one for each class of rocket:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V', new Date('May <br/>  14,1973')); 
  const falconHeavy = new Rocket('Falcon Heavy'); 
 
  const saturnVLauncher = new Launcher(saturnV); 
  const falconHeavyLauncher = new Launcher(falconHeavy); 
 
  saturnVLauncher.prepareForLaunch(); 
  falconHeavyLauncher.prepareForLaunch(); 
} </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see output like the following:</li>
</ol>
<div><img src="img/b9830c81-fb99-498a-88f4-f0a8bf881308.png" style="width:50.17em;height:31.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, we've added an instance of one class (one of the two <kbd>Rocket</kbd> classes) and used it within the instance of another class (<kbd>Launcher</kbd>), that isn't related via inheritance. It would be possible to add this launch functionality through a <kbd>LaunchableRocket</kbd> class, but that would become cumbersome as the kinds of rockets and their relationships change.</p>
<p>In general, adding behaviors through inheritance is constricting; it should be limited to small changes and they should not differ in public interface. The <strong>Dependency Inversion Principle </strong>(<strong>DIP</strong>) is an important concept when considering inheritance.</p>
<p>Visit the following link to learn more about the DIP: <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using mix-ins to add behavior</h1>
                
            
            
                
<p>We've seen how to use inheritance and composition to add behavior. There is a different method of composition that appends behavior onto existing classes without inheritance. Using mix-ins attaches properties to an object instance at runtime.</p>
<p>In this recipe, we'll see how to use the mix-ins to add shared behavior to classes without inheritance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-08-using-mixins</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd>. In the constructor, extend the current instance with an object named <kbd>Launcher</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor(name) { 
    Object.assign(this, Launcher); 
    this.name = name; 
  } 
   
  print() { 
    console.log(this.name + ' is a rocket'); 
  } 
}  </pre>
<ol start="5">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class and assigns an additional <kbd>lastFlow</kbd> property in the constructor:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket { 
 constructor(name, lastFlown) { 
    super(name); 
    this.lastFlown = lastFlown; 
  } 
 
  print() { 
    console.log(this.name + ' is an inactive rocket'); 
    console.log(`${this.name} was last flown: <br/>    ${this.lastFlown}`); 
  } 
} </pre>
<ol start="6">
<li>Create an object named <kbd>Launcher</kbd> that defines a method named <kbd>prepareForLaunch</kbd>, which aborts if the rocket is inactive:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
const Launcher = { 
  prepareForLaunch () { 
    if (this instanceof InactiveRocket) { 
      console.error(`Unable to launch, rocket ${this.name} has <br/>      been inactive since ${this.lastFlown}`); 
    } else { 
      console.log(`${this.name} is ready to launch.`); 
    } 
  } 
}  </pre>
<ol start="7">
<li>Create a <kbd>main</kbd> function that creates instances of each class of <kbd>Rocket</kbd> and calls <kbd>prepareForLaunch</kbd> on each:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V', new Date('May <br/>  14,1973')); 
  const falconHeavy = new Rocket('Falcon Heavy'); 
 
  saturnV.prepareForLaunch(); 
  falconHeavy.prepareForLaunch(); 
} </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see output like the following:</li>
</ol>
<div><img src="img/7351290c-c83a-48a2-9cd7-8df703152dad.png" style="width:45.50em;height:28.42em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>Object.assign</kbd> adds all the properties from one object to another. Assigning all of the properties from the <kbd>Launcher</kbd> onto the new instance makes those available after the object is created. Remember that methods on <kbd>this</kbd> are simply properties on the prototype with function values. So, adding methods this way is the equivalent of defining these methods on the prototype. </p>
<p>Thus, after applying this mix-in with <kbd>Object.assign</kbd> we can call methods defined as properties on <kbd>Launcher</kbd> as instance methods of  <kbd>Rocket</kbd> and <kbd>InactiveRocket</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Passing a class as an argument</h1>
                
            
            
                
<p>Classes, like functions, are first class citizens in JavaScript. This means that they can be returned from functions or passed as arguments. In this recipe, we'll see how to use the latter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-08-passing-class-as-an-argument</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket {<br/>  constructor(name) { 
    this.name = name; <br/>  }<br/>}</pre>
<ol start="5">
<li>Create a class named <kbd>InactiveRocket</kbd> that extends the <kbd>Rocket</kbd> class and assigns a <kbd>name</kbd> and a <kbd>lastFlow</kbd> property in the constructor:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class InactiveRocket extends Rocket { 
 constructor(name, lastFlown) { 
    super(); 
    this.lastFlown = lastFlown; 
 } 
} </pre>
<ol start="6">
<li>Create a function <kbd>isA</kbd> that takes an instance and a <kbd>klass</kbd> argument and returns <kbd>true</kbd> if the constructor is the passed class:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
function isA(instance, klass) { 
  return instance.constructor === klass; 
} </pre>
<ol start="7">
<li>Create a <kbd>main</kbd> function that creates an instance of <kbd>InactiveRocket</kbd>. Call <kbd>isA</kbd> to compare the instance against both <kbd>Rocket</kbd> classes:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V', new Date('May <br/>  14,1973')); 
 
  console.log(saturnV.name + ' instance of Rocket: ' + <br/>  isA(saturnV,Rocket)); 
  console.log(saturnV.name + ' instance of InactiveRocket: ' + <br/>  isA(saturnV, InactiveRocket)); 
} </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="9">
<li>You should see output like the following:</li>
</ol>
<div><img src="img/721847f1-9c2f-413f-9dda-a7ab9f72ca3e.png" style="width:50.42em;height:31.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>isA</kbd> function compares the identity of the <kbd>instance</kbd> constructor property against the passed <kbd>klass</kbd>. This will be <kbd>true</kbd> if the <kbd>instance</kbd> argument is an instance of <kbd>klass</kbd> (in this case we are comparing an instance of the <kbd>InactiveRocket</kbd> class). It will return <kbd>false</kbd> for any other class, including <kbd>Rocket</kbd>.</p>
<p>Because we are comparing the constructor to the class directly, inheritance is not taken into account. If we were to use <kbd>instanceOf</kbd>, the function would return <kbd>true</kbd> for <kbd>Rocket</kbd> as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking class inheritance with Object.getPrototypeOf</h1>
                
            
            
                
<p>We've seen how to check for inheritance and identity of the instantiated class as a Boolean expression. We might want to also see the full ancestry of an instance at once. In this recipe, we'll see how to do just that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-09-checking-class-inheritance</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines three new <kbd>Rocket</kbd> classes:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket {} 
class ActiveRocket extends Rocket {} 
class OrbitingRocket extends ActiveRocket {}  </pre>
<ol start="5">
<li>Create a function <kbd>listInheritance</kbd> that takes an instance and uses <kbd>Object.getPrototypeOf</kbd> to get the names of all the classes until you reach the null type:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
function listInheritance (instance) { 
  const hierarchy = []; 
  let currClass = instance.constructor; 
 
  while (currClass.name) { 
    hierarchy.push(currClass.name); 
    currClass = Object.getPrototypeOf(currClass) 
  } 
 
  console.log(hierarchy.join(' -&gt; ')); 
} </pre>
<ol start="6">
<li>Create a <kbd>main</kbd> function that creates an instance of <kbd>OrbitingRocket</kbd> and lists its inheritance:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const orbitingRocket = new OrbitingRocket(); 
  listInheritance(orbitingRocket); 
} </pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
<li>You should see output like the following:</li>
</ol>
<div><img src="img/1f1e5408-4f1d-407d-b95d-6d1880d722d8.png" style="width:49.92em;height:31.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>All JavaScript prototypes exist in a hierarchy. This means each prototype is extended from another, which in turn extends from another. At the top of the hierarchy is the null type. <kbd>Object.getPrototypeOf</kbd> traverses up this inheritance tree and climbs its way from the prototype of the instance, all the way to the null type. We can then use the <kbd>name</kbd> property of each, which will give us the name of that prototype (or class in our case).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using throw to simulate abstract classes</h1>
                
            
            
                
<p>So far, we've seen how to create and combine classes into a variety of different shapes. Sometimes, however, we want to be able to prevent the creation of a class and only allow instances of extending classes. Other languages provide a facility known as abstract classes. In this recipe, we'll see how to simulate this by throwing errors.<br/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>08-10-use-throw-to-simulate-abstract-class</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that defines a new class named <kbd>Rocket</kbd>. In the constructor, check the constructor of the instance, if it's <kbd>Rocket</kbd>, then throw an error:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor (name) { 
    this.name = name; 
    if (this.constructor === Rocket) { 
      throw new Error('Abstract Class Should not be <br/>      instantiated'); 
    } 
  } 
}  </pre>
<ol start="5">
<li>Create two child classes of <kbd>Rocket</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class ActiveRocket extends Rocket {} 
class InactiveRocket extends Rocket {} </pre>
<ol start="6">
<li>Create a <kbd>main</kbd> function that creates instances of each class of rocket. Notice that the <kbd>Rocket</kbd> class can't be instantiated:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const saturnV = new InactiveRocket('Saturn V'); 
  console.log(saturnV.name, ' is a Rocket ', saturnV instanceof <br/>  Rocket); 
 
  const falconHeavy = new ActiveRocket('Falcon Heavy'); 
  console.log(falconHeavy.name, ' is a Rocket ', falconHeavy <br/>  instanceof Rocket); 
 
  // throws an error; 
  new Rocket('Not going to make it!'); 
} </pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="8">
<li>You should see output like the following:</li>
</ol>
<div><img src="img/3ea7105c-7f1f-424d-a82a-1518b25fecc9.png" style="width:52.08em;height:32.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The goal of this was to force users of the class to extend the <kbd>Rocket</kbd> class, rather than instantiate it directly. However, we still want to be able to define behavior in the <kbd>base</kbd> class. In the constructor of the <kbd>Rocket</kbd> class you can see how this is done. By comparing the constructor property of the instance with <kbd>Rocket</kbd> we can see if this has been instantiated directly. If the class is extended, then this comparison will evaluate <kbd>false</kbd> and the error will not be throw. Thus, we can create <kbd>ActiveRocket</kbd> and <kbd>InactiveRocket</kbd> instances.</p>
<p>When creating an instance of <kbd>Rocket</kbd> directly, the constructor comparison evaluates to <kbd>true</kbd> and the error is thrown. Thus, we can't create instances of the <kbd>Rocket</kbd> class, only it's sub-classes.</p>


            

            
        
    </body></html>