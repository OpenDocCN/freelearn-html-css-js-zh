- en: Real-World Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter of this book, we have learned about functional programming
    and functional reactive programming. We tried to avoid using external libraries,
    because our main goal was to understand the techniques, patterns, and principles
    of the functional programming and functional-reactive programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Composing with Ramda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying and partial application with Ramda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lenses with Ramda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Immutable.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Immer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Funfix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to revisit once more some of the main concepts that we have explored
    throughout this book. However, this time, our focus will not be to understand
    these concepts (it is assumed that we already do). Instead, we are going to focus
    on the usage of some production-ready functional programming libraries, such as
    Ramda or Immutable.js.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ramda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ramda is an open source functional programming library that which includes many
    utility functions that can help us to put some of the main functional programming
    techniques into practice. Ramda can be compared to other libraries, such as Lodash
    or Underscore. However, the Ramda API is much more influenced by the functional
    programming principle than these other libraries. For example, Ramda has been
    designed in a way that makes composability and immutability two of the main characteristics
    of its components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install Ramda using the following **npm** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we are going to learn how to use Ramda to implement
    function compositions and lenses.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we declared a higher-order function named `compose`,
    which allows us to compose two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compose` function allowed us to demonstrate how function composition works,
    but it had some limitations. For example, the compose function only takes one
    generic type, parameter `T`, which means that we can only compose two unary functions, `f`
    and `g`, that take one argument of type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In a real-world application, we may need to compose two functions `f` and `g`
    that take an argument of two different types `T1` and `T2`. The following code
    snippet uses the `compose` function from Ramda instead of the one that we declared previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `compose` function from Ramda is a much better alternative for real-world
    applications because it has been used in hundreds of projects and tested with
    thousands of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application and currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have also learned that the functional composition only works with unary
    functions and that if we wish to compose functions, that are not unary, such as
    binary functions we can use function partial application to invoke one of the
    function with only some of its arguments and generate new functions that take
    the remaining arguments. Finally, we also learned that we can use currying to
    transform a given function into a function that can be partially applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet uses the `curry3` function to transform a ternary
    function into a function that can be partially applied. Again, in a real-world
    application, it is not recommended to create a custom implementation, and we should
    try to use a battle-tested library instead. Fortunately, we are not going to need
    to search around for very long because Ramda includes a function named `curry`
    that can be used to achieve just what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet declares three functions in a way that is completely
    agnostic of Ramda. We then use the Ramda utility functions, `compose` and `curry`,
    to generate a new function named `trimCapitalizeAndReplace`.
  prefs: []
  type: TYPE_NORMAL
- en: Lenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about lenses in some of the previous chapters. In one of the last
    examples, we implemented lenses in a way that is very close to the implementation
    provided by Ramda.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented a higher-order function named `lens` that can be used to create
    a `Lens` implementation. The `lens` function takes two functions that must implement
    the `Prop` and `Assoc` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a `Lens` implementation passing the `Assoc` and `Prop` implementations
    to the `Lens` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a `Lens` instance, we can use the `set` and `view` functions to
    `read` and `set` the value of a property in an immutable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know the basics about Ramda, we can implement the preceding code
    snippet once more using some of its utility functions. Ramda includes the following
    utility functions, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: The `prop` function allows us to declare a property getter. It expects the name
    of a property as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assoc` function allows us to declare a property setter. It expects the
    name of a property as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lens` function allows us to declare a lens instance. It expects a property
    getter (`prop`) and setter (`assoc`) as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lensProp` function allows us to declare a lens instance. It expects the
    name of a property as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `view` function allows us to get the value of a property in an object. It
    expects a lens instance and an object as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `set` function allows us to set the value of a property in an object. It
    expects a lens instance, a new value, and an object as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code snippet, we use the `lensProp`, `view`, and `set` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Use of the `prop` and `assoc` functions are not required in most cases thanks
    to the `lensProp` instead of the `lens` function.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Immutable.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding chapters, we also learned about immutability and the benefits
    of using immutable data objects. We learned that we can use the `readonly` keyword
    to declare immutable objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also learned that working with immutable objects can sometimes be very verbose
    and tedious and that lenses can help us to overcome these difficulties. We are
    now going to learn about a library that can help us to declare immutable objects.
    The library is known as **Immutable.js**, and it also includes an API similar
    tot he lenses API. We can install Immutable.js using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define type-safe immutable classes with Immutable.js, using the `Record`
    type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to define one more immutable class named `Address`. The `Address`
    class contains an instance of the `Street` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an instance of an immutable class, we need to pass all the required
    properties as a plain object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we declare an immutable class with Immutable.js, the class inherits some
    methods that behave like a lens. We can use the `get` method to get the value
    of a property and the `set` method to create a new immutable instance using an
    updated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Declaring an immutable class with Immutable.js is more tedious than declaring
    them with the `readonly` access modifier, but we get lenses as a built-in feature
    in exchange for our effort.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Immer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to take a look at another popular immutability library. The library
    is known as **Immer**, and it can be installed using the following `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Immer allows us to define immutable classes using the `readonly` access modifier.
    This means that we can also create instances of our classes using a standard class
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Immer can generate a new version of an immutable object using a method named
    `produce`. The `produce` function takes the current version of an immutable object
    as its first argument. The second argument is a callback function that takes one
    argument known as the draft state. The draft state is a mutable version of the
    initial version and, within the callback function, we can mutate it as much as
    we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `produce` function returns a new immutable object without mutating the original
    object. The Immer API can be considered superior to the Immutable.js API, because
    it imposes fewer constraints in our class declarations and constructors. Immer
    is not based on lenses and allows us to work with immutable objects using an innovative
    approach that utilizes proxies internally.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Funfix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Funfix** is a collection of functional programming utility functions. Funfix
    can be compared with Ramda. Just like Ramda, Funfix can be used to compose functions
    or partially apply functions. However, in this section, we are going to focus
    on the usage of some of the Funfix features that are related to some of the data
    types that we previously explored in Chapter 7, *Category Theory*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by installing Funfix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples that we are going to implement in this section are going to require
    a couple of additional `npm` modules. We are going to use `node-fetch` to send
    HTTP requests from a Node.js application. We are also going to use some of the
    Node.js core modules, which means that we are going to need the type definitions
    for Node.js as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In our first Funfix example, we are going to define a monad named `argsIO`
    using the `IO.of` factory method. As we learned in the previous chapters, a monad
    is a functor, and a functor is a container. In this case, the container contains
    a function that performs an I/O operation: reading the command-line arguments
    (`process.argv`). The `IO` type is used to store a function that describes some
    computation with side effects, such as reading some data from a file or mutating
    the elements in the **Document Object Model** (**DOM**). Describing actions in
    this way allows for `IO` instances to be composed and passed around, while keeping
    functions pure and maintaining referential transparency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also going to declare two functions named `readFile` and `stdoutWrite`.
    Both of these functions return a monad instance, and both monads contain I/O operations.
    The first one reads a file from the filesystem, and the second one prints some
    information in the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet also declares a monad named `loudCat` using the `chain`
    method to pass the command line arguments to the file reading operation and the
    `map` method to transform the file contents into upper case. Finally, it uses
    the `chain` method one last time to pass the uppercase text to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main characteristics of monads in Funfix is that they are lazily
    evaluated, and all of the preceding operations don''t take place until we invoke
    the `run` method. If everything goes well, we can pass the name of a file using
    the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The uppercase contents of the file should be displayed on the standard output.
    The following example uses the `node-fetch` module to send an HTTP request. The
    function that performs the HTTP request is contained by a monad. This time, the
    monad is not created by the `IO.of` factory function because it is created with
    the `IO.async` factory function instead. We use the `IO.async` factory function
    because it is required by Funfix when an asynchronous operation is wrapped by
    a monad. The example also uses the `Either` type, which is another Functor and
    monad. It can be used to wrap a value that can be of two possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The error-handling logic is very simple because the `map` method of the `Either`
    type only maps the values when the type of its value is not an error. Just as
    before, the entire logic is lazily evaluated and nothing really happens until
    we invoke the `run` method in the `logTodos` monad.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use some real-world functional programming
    libraries, including Ramda, Fundix, Immer, and Immutable.js. Throughout this book,
    we have learned about the main characteristics, principles, patterns, and principles
    of the functional programming and functional-reactive programming paradigm. These
    concepts provide you with a set of powerful tools that will help you to useapplications
    that are easier to reason about, more testable, and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you enjoy this book and that you are eager to continue your functional
    programming-learning journey. In the appendices, you will find a guide that can
    be used to discover new functional libraries and additional functional programming
    concepts that you can explore on your own if you wish to learn more.
  prefs: []
  type: TYPE_NORMAL
