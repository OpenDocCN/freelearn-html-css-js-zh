- en: Real-World Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用中的函数式编程
- en: In the preceding chapter of this book, we have learned about functional programming
    and functional reactive programming. We tried to avoid using external libraries,
    because our main goal was to understand the techniques, patterns, and principles
    of the functional programming and functional-reactive programming paradigms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前一章中，我们学习了函数式编程和函数式响应式编程。我们试图避免使用外部库，因为我们的主要目标是理解函数式编程和函数式响应式编程范式的技术、模式和原则。
- en: 'In this chapter, we are going to learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Composing with Ramda
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ramda 进行组合
- en: Currying and partial application with Ramda
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ramda 进行柯里化和部分应用
- en: Lenses with Ramda
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ramda 的透镜
- en: Working with Immutable.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Immutable.js 一起工作
- en: Working with Immer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Immer 一起工作
- en: Working with Funfix
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Funfix 一起工作
- en: We are going to revisit once more some of the main concepts that we have explored
    throughout this book. However, this time, our focus will not be to understand
    these concepts (it is assumed that we already do). Instead, we are going to focus
    on the usage of some production-ready functional programming libraries, such as
    Ramda or Immutable.js.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次回顾本书中探索的一些主要概念。然而，这一次，我们的重点不是理解这些概念（假设我们已经做到了）。相反，我们将专注于一些生产就绪的函数式编程库的使用，例如
    Ramda 或 Immutable.js。
- en: Working with Ramda
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Ramda 一起工作
- en: Ramda is an open source functional programming library that which includes many
    utility functions that can help us to put some of the main functional programming
    techniques into practice. Ramda can be compared to other libraries, such as Lodash
    or Underscore. However, the Ramda API is much more influenced by the functional
    programming principle than these other libraries. For example, Ramda has been
    designed in a way that makes composability and immutability two of the main characteristics
    of its components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Ramda 是一个开源的函数式编程库，它包含许多实用函数，可以帮助我们将一些主要的函数式编程技术付诸实践。Ramda 可以与其他库，如 Lodash 或
    Underscore 相比较。然而，Ramda 的 API 受函数式编程原则的影响比这些其他库更大。例如，Ramda 的设计使得可组合性和不可变性成为其组件的两个主要特性。
- en: 'We can install Ramda using the following **npm** command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 **npm** 命令安装 Ramda：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the following sections, we are going to learn how to use Ramda to implement
    function compositions and lenses.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将学习如何使用 Ramda 实现函数组合和透镜。
- en: Composition
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: 'In the previous chapters, we declared a higher-order function named `compose`,
    which allows us to compose two functions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们声明了一个名为 `compose` 的高阶函数，它允许我们组合两个函数：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `compose` function allowed us to demonstrate how function composition works,
    but it had some limitations. For example, the compose function only takes one
    generic type, parameter `T`, which means that we can only compose two unary functions, `f`
    and `g`, that take one argument of type `T`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose` 函数使我们能够展示函数组合是如何工作的，但它有一些限制。例如，`compose` 函数只接受一个通用类型参数 `T`，这意味着我们只能组合两个接受类型
    `T` 参数的一元函数 `f` 和 `g`：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a real-world application, we may need to compose two functions `f` and `g`
    that take an argument of two different types `T1` and `T2`. The following code
    snippet uses the `compose` function from Ramda instead of the one that we declared previously:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们可能需要组合两个接受不同类型 `T1` 和 `T2` 参数的函数 `f` 和 `g`。以下代码片段使用 Ramda 的 `compose`
    函数而不是我们之前声明的函数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `compose` function from Ramda is a much better alternative for real-world
    applications because it has been used in hundreds of projects and tested with
    thousands of functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ramda 的 `compose` 函数是实际应用中更好的替代方案，因为它已经在数百个项目中使用，并且与数千个函数进行了测试。
- en: Partial application and currying
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用和柯里化
- en: 'We have also learned that the functional composition only works with unary
    functions and that if we wish to compose functions, that are not unary, such as
    binary functions we can use function partial application to invoke one of the
    function with only some of its arguments and generate new functions that take
    the remaining arguments. Finally, we also learned that we can use currying to
    transform a given function into a function that can be partially applied:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，函数组合仅适用于一元函数，如果我们希望组合非一元函数，例如二元函数，我们可以使用函数部分应用来调用其中一个函数，只传递部分参数，并生成新的函数，这些函数接受剩余的参数。最后，我们还了解到我们可以使用柯里化将给定的函数转换成可以部分应用的函数：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code snippet uses the `curry3` function to transform a ternary
    function into a function that can be partially applied. Again, in a real-world
    application, it is not recommended to create a custom implementation, and we should
    try to use a battle-tested library instead. Fortunately, we are not going to need
    to search around for very long because Ramda includes a function named `curry`
    that can be used to achieve just what we want:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用`curry3`函数将三元函数转换为一个可以部分应用的函数。在实际应用中，不建议创建自定义实现，而应尝试使用经过实战检验的库。幸运的是，我们不需要搜索很长时间，因为Ramda包括一个名为`curry`的函数，可以用来实现我们想要的功能：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code snippet declares three functions in a way that is completely
    agnostic of Ramda. We then use the Ramda utility functions, `compose` and `curry`,
    to generate a new function named `trimCapitalizeAndReplace`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段以完全与Ramda无关的方式声明了三个函数。然后我们使用Ramda的实用函数`compose`和`curry`来生成一个名为`trimCapitalizeAndReplace`的新函数：
- en: Lenses
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透镜
- en: We learned about lenses in some of the previous chapters. In one of the last
    examples, we implemented lenses in a way that is very close to the implementation
    provided by Ramda.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些前面的章节中，我们学习了关于透镜的内容。在最后一个例子中，我们以一种非常接近Ramda提供的实现方式实现了透镜。
- en: 'We implemented a higher-order function named `lens` that can be used to create
    a `Lens` implementation. The `lens` function takes two functions that must implement
    the `Prop` and `Assoc` interfaces:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个名为`lens`的高阶函数，可以用来创建`Lens`实现。`lens`函数接受两个必须实现`Prop`和`Assoc`接口的函数：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can then create a `Lens` implementation passing the `Assoc` and `Prop` implementations
    to the `Lens` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`Lens`实现，将`Assoc`和`Prop`实现传递给`Lens`函数：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have a `Lens` instance, we can use the `set` and `view` functions to
    `read` and `set` the value of a property in an immutable object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个`Lens`实例，我们可以使用`set`和`view`函数来`读取`和`设置`不可变对象中属性的值：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we know the basics about Ramda, we can implement the preceding code
    snippet once more using some of its utility functions. Ramda includes the following
    utility functions, among others:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了关于Ramda的基础知识，我们可以再次实现前面的代码片段，使用其中的一些实用函数。Ramda包括以下实用函数，以及其他一些：
- en: The `prop` function allows us to declare a property getter. It expects the name
    of a property as an argument.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prop`函数允许我们声明一个属性获取器。它期望一个属性名称作为参数。'
- en: The `assoc` function allows us to declare a property setter. It expects the
    name of a property as an argument.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assoc`函数允许我们声明一个属性设置器。它期望一个属性名称作为参数。'
- en: The `lens` function allows us to declare a lens instance. It expects a property
    getter (`prop`) and setter (`assoc`) as arguments.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lens`函数允许我们声明一个透镜实例。它期望一个属性获取器（`prop`）和一个设置器（`assoc`）作为参数。'
- en: The `lensProp` function allows us to declare a lens instance. It expects the
    name of a property as an argument.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lensProp`函数允许我们声明一个透镜实例。它期望一个属性名称作为参数。'
- en: The `view` function allows us to get the value of a property in an object. It
    expects a lens instance and an object as arguments.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view`函数允许我们获取对象中属性的值。它期望一个透镜实例和一个对象作为参数。'
- en: The `set` function allows us to set the value of a property in an object. It
    expects a lens instance, a new value, and an object as arguments.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`函数允许我们在对象中设置属性的值。它期望一个透镜实例、一个新值和一个对象作为参数。'
- en: 'In the following code snippet, we use the `lensProp`, `view`, and `set` functions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们使用了`lensProp`、`view`和`set`函数：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Use of the `prop` and `assoc` functions are not required in most cases thanks
    to the `lensProp` instead of the `lens` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有`lensProp`而不是`lens`函数，大多数情况下不需要使用`prop`和`assoc`函数。
- en: Working with Immutable.js
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Immutable.js
- en: 'In the preceding chapters, we also learned about immutability and the benefits
    of using immutable data objects. We learned that we can use the `readonly` keyword
    to declare immutable objects:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们还学习了不可变性和使用不可变数据对象的优点。我们了解到我们可以使用`readonly`关键字来声明不可变对象：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also learned that working with immutable objects can sometimes be very verbose
    and tedious and that lenses can help us to overcome these difficulties. We are
    now going to learn about a library that can help us to declare immutable objects.
    The library is known as **Immutable.js**, and it also includes an API similar
    tot he lenses API. We can install Immutable.js using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，与不可变对象一起工作有时可能非常冗长且繁琐，而 lenses 可以帮助我们克服这些困难。现在我们将学习一个可以帮助我们声明不可变对象的库。这个库被称为
    **Immutable.js**，它还包括一个类似于 lenses API 的 API。我们可以使用以下命令安装 Immutable.js：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can define type-safe immutable classes with Immutable.js, using the `Record`
    type as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Record` 类型定义类型安全的不可变类，如下所示：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are going to define one more immutable class named `Address`. The `Address`
    class contains an instance of the `Street` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为 `Address` 的更多不可变类。`Address` 类包含 `Street` 类的一个实例：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To create an instance of an immutable class, we need to pass all the required
    properties as a plain object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不可变类的实例，我们需要将所有必需的属性作为普通对象传递：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we declare an immutable class with Immutable.js, the class inherits some
    methods that behave like a lens. We can use the `get` method to get the value
    of a property and the `set` method to create a new immutable instance using an
    updated value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Immutable.js 声明一个不可变类时，该类继承了一些类似 lenses 的方法。我们可以使用 `get` 方法获取属性的值，使用 `set`
    方法通过更新值创建一个新的不可变实例：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declaring an immutable class with Immutable.js is more tedious than declaring
    them with the `readonly` access modifier, but we get lenses as a built-in feature
    in exchange for our effort.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Immutable.js 声明不可变类比使用 `readonly` 访问修饰符声明它们更为繁琐，但作为交换，我们得到了内置的 lenses 功能。
- en: Working with Immer
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Immer
- en: 'We are going to take a look at another popular immutability library. The library
    is known as **Immer**, and it can be installed using the following `npm` command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看另一个流行的不可变性库。这个库被称为 **Immer**，可以使用以下 `npm` 命令安装：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Immer allows us to define immutable classes using the `readonly` access modifier.
    This means that we can also create instances of our classes using a standard class
    constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Immer 允许我们使用 `readonly` 访问修饰符定义不可变类。这意味着我们也可以使用标准的类构造函数创建我们类的实例：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Immer can generate a new version of an immutable object using a method named
    `produce`. The `produce` function takes the current version of an immutable object
    as its first argument. The second argument is a callback function that takes one
    argument known as the draft state. The draft state is a mutable version of the
    initial version and, within the callback function, we can mutate it as much as
    we want:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Immer 可以使用名为 `produce` 的方法生成不可变对象的新版本。`produce` 函数将当前不可变对象的版本作为其第一个参数。第二个参数是一个回调函数，它接受一个称为草稿状态的参数。草稿状态是初始版本的可变版本，在回调函数内部，我们可以尽可能多地修改它：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `produce` function returns a new immutable object without mutating the original
    object. The Immer API can be considered superior to the Immutable.js API, because
    it imposes fewer constraints in our class declarations and constructors. Immer
    is not based on lenses and allows us to work with immutable objects using an innovative
    approach that utilizes proxies internally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`produce` 函数返回一个新不可变对象，而不修改原始对象。Immer API 可以被认为是优于 Immutable.js API 的，因为它在我们的类声明和构造函数中施加了更少的约束。Immer
    不基于 lenses，并允许我们使用一种创新的内部使用代理的方法来与不可变对象一起工作。'
- en: Working with Funfix
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Funfix
- en: '**Funfix** is a collection of functional programming utility functions. Funfix
    can be compared with Ramda. Just like Ramda, Funfix can be used to compose functions
    or partially apply functions. However, in this section, we are going to focus
    on the usage of some of the Funfix features that are related to some of the data
    types that we previously explored in Chapter 7, *Category Theory*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Funfix** 是一组函数式编程实用函数集合。Funfix 可以与 Ramda 相比。就像 Ramda 一样，Funfix 可以用来组合函数或部分应用函数。然而，在本节中，我们将关注一些与我们在第
    7 章 *范畴论* 中之前探索的一些数据类型相关的 Funfix 功能的使用。'
- en: 'We are going to start by installing Funfix:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装 Funfix：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The examples that we are going to implement in this section are going to require
    a couple of additional `npm` modules. We are going to use `node-fetch` to send
    HTTP requests from a Node.js application. We are also going to use some of the
    Node.js core modules, which means that we are going to need the type definitions
    for Node.js as well:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中实现的示例将需要一些额外的`npm`模块。我们将使用`node-fetch`从Node.js应用程序发送HTTP请求。我们还将使用一些Node.js核心模块，这意味着我们还需要Node.js的类型定义：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our first Funfix example, we are going to define a monad named `argsIO`
    using the `IO.of` factory method. As we learned in the previous chapters, a monad
    is a functor, and a functor is a container. In this case, the container contains
    a function that performs an I/O operation: reading the command-line arguments
    (`process.argv`). The `IO` type is used to store a function that describes some
    computation with side effects, such as reading some data from a file or mutating
    the elements in the **Document Object Model** (**DOM**). Describing actions in
    this way allows for `IO` instances to be composed and passed around, while keeping
    functions pure and maintaining referential transparency.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个Funfix示例中，我们将使用`IO.of`工厂方法定义一个名为`argsIO`的单子。正如我们在前面的章节中学到的，单子是一种函子，而函子是一种容器。在这种情况下，容器包含一个执行I/O操作（如读取命令行参数`process.argv`）的函数。`IO`类型用于存储描述某些带有副作用的计算（如从文件读取数据或修改**文档对象模型**（**DOM**）中的元素）的函数。以这种方式描述动作允许`IO`实例被组合并传递，同时保持函数的纯度和维护引用透明性。
- en: 'We are also going to declare two functions named `readFile` and `stdoutWrite`.
    Both of these functions return a monad instance, and both monads contain I/O operations.
    The first one reads a file from the filesystem, and the second one prints some
    information in the standard output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将声明两个名为`readFile`和`stdoutWrite`的函数。这两个函数都返回一个单子实例，并且这两个单子都包含I/O操作。第一个从文件系统中读取文件，第二个在标准输出中打印一些信息：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code snippet also declares a monad named `loudCat` using the `chain`
    method to pass the command line arguments to the file reading operation and the
    `map` method to transform the file contents into upper case. Finally, it uses
    the `chain` method one last time to pass the uppercase text to the standard output.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段还使用`chain`方法声明了一个名为`loudCat`的单子，将命令行参数传递给文件读取操作，并使用`map`方法将文件内容转换为大写。最后，它再次使用`chain`方法将大写文本传递到标准输出。
- en: 'One of the main characteristics of monads in Funfix is that they are lazily
    evaluated, and all of the preceding operations don''t take place until we invoke
    the `run` method. If everything goes well, we can pass the name of a file using
    the command-line interface:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Funfix中单子的一个主要特征是它们是惰性求值的，并且所有前面的操作都不会发生，直到我们调用`run`方法。如果一切顺利，我们可以通过命令行界面传递文件名：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The uppercase contents of the file should be displayed on the standard output.
    The following example uses the `node-fetch` module to send an HTTP request. The
    function that performs the HTTP request is contained by a monad. This time, the
    monad is not created by the `IO.of` factory function because it is created with
    the `IO.async` factory function instead. We use the `IO.async` factory function
    because it is required by Funfix when an asynchronous operation is wrapped by
    a monad. The example also uses the `Either` type, which is another Functor and
    monad. It can be used to wrap a value that can be of two possible values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的大写内容应显示在标准输出上。以下示例使用`node-fetch`模块发送HTTP请求。执行HTTP请求的函数包含在一个单子中。这次，单子不是由`IO.of`工厂函数创建的，而是由`IO.async`工厂函数创建的。我们使用`IO.async`工厂函数是因为Funfix在将异步操作包装在单子中时需要它。示例还使用了`Either`类型，它也是一种函子和单子。它可以用来包装可能有两个可能值的值：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The error-handling logic is very simple because the `map` method of the `Either`
    type only maps the values when the type of its value is not an error. Just as
    before, the entire logic is lazily evaluated and nothing really happens until
    we invoke the `run` method in the `logTodos` monad.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理逻辑非常简单，因为`Either`类型的`map`方法仅在它的值的类型不是错误时映射值。就像之前一样，整个逻辑是惰性求值的，直到我们在`logTodos`单子中调用`run`方法，实际上什么都不会发生。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to use some real-world functional programming
    libraries, including Ramda, Fundix, Immer, and Immutable.js. Throughout this book,
    we have learned about the main characteristics, principles, patterns, and principles
    of the functional programming and functional-reactive programming paradigm. These
    concepts provide you with a set of powerful tools that will help you to useapplications
    that are easier to reason about, more testable, and easier to maintain.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用一些实际的函数式编程库，包括 Ramda、Fundix、Immer 和 Immutable.js。贯穿整本书，我们了解了函数式编程和函数式响应式编程范式的核心特性、原则、模式和原则。这些概念为您提供了一套强大的工具，将帮助您使用更容易推理、更易测试和更易维护的应用程序。
- en: I hope that you enjoy this book and that you are eager to continue your functional
    programming-learning journey. In the appendices, you will find a guide that can
    be used to discover new functional libraries and additional functional programming
    concepts that you can explore on your own if you wish to learn more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您喜欢这本书，并且渴望继续您的函数式编程学习之旅。在附录中，您将找到一份指南，可用于发现新的函数式库以及您可以自行探索的额外函数式编程概念，如果您想了解更多的话。
