["```js\ninterface ReusableInterface1 {\n    entity: any;\n}\n```", "```js\ninterface ReusableInterface2 {\n   entity: object;\n}\n\nconst ri2a: ReusableInterface2 = { entity: 1 }; // Does not compile\nconst ri2b: ReusableInterface2 = { entity: { test: \"\" } };\n```", "```js\nconst value = ri2b.entity; // value -> \"object\"\n```", "```js\nconst valueCasted = value as { test: string };\nconsole.log(valueCasted.test);\n```", "```js\ninterface MyCustomTypeA {\n   test: string;\n}\n\ninterface MyCustomTypeB {\n   anything: boolean;\n}\n\ninterface ReusableInterface3<T> {\n   entity: T;\n}\n```", "```js\nconst ri3a: ReusableInterface3<MyCustomTypeA> = { entity: { test: \"yes\" } };\nconst ri3b: ReusableInterface3<MyCustomTypeB> = { entity: { anything: true } };\nconst ri3c: ReusableInterface3<number> = { entity: 1 };\n```", "```js\nconsole.log(ri3a.entity.test); // \"yes\" -> string\nconsole.log(ri3b.entity.anything); // true -> boolean\nconsole.log(ri3c.entity); // 1 -> number\n```", "```js\ntype MyTypeA<T> = T | string; // Type\n\ninterface MyInterface<TField, YField> { // Interface wiht two types\n  entity1: TField;\n  myFunction(): YField;\n}\n\nclass MyClass<T>{ // Class\n list: T[] = [];\n public displayFirst(): void {\n   const first: T = this.list[0]; // Variable\n   console.log(first);\n }\n}\n```", "```js\nfunction extractFirstElement<T, R>(list: T[], param2: R): T {\n  console.log(param2);\n  return list[0];\n}\n```", "```js\ninterface ReusableInterface2 {\n  entity: object;\n}\n\nconst a = {\n  what: \"ever\"\n};\n\nconst c: ReusableInterface2 = { entity: a };\nconsole.log(c.entity.what); // Does not compile because \"what\" is not of object\n```", "```js\ninterface AnyKindOfObject {\n  what: string;\n}\n\ninterface ReusableInterface3<T extends object> {\n  entity: T;\n}\n\nconst d: ReusableInterface3<AnyKindOfObject> = { entity: a };\nconsole.log(d.entity.what); // Compile\n```", "```js\ninterface ObjectWithId {\n id: number;\n what: string;\n}\n\ninterface ReusableInterface4<T extends { id: number }> {\n entity: T;\n}\n\nconst e: ReusableInterface4<AnyKindOfObject> = { entity: a }; // Doesn't compile\nconst f: ReusableInterface4<ObjectWithId> = { entity: { id: 1, what: \"1\" } }; // Compile\nconst g: ReusableInterface4<string> = { entity: \"test\" }; // Doesn't compile\n```", "```js\ninterface ReusableInterface5<T extends ObjectWithId> {\n   entity: T;\n}\n```", "```js\nfunction funct1<T extends ObjectWithId>(p: T): void {\n   console.log(`Access to ${p.what} and ${p.id}`);\n}\n```", "```js\nclass ReusableClass<T extends ObjectWithId>{\n public list: T[] = [];\n public funct1(): void {\n   this.list.forEach((p) => {\n    console.log(`Access to ${p.what} and ${p.id}`);\n    });\n }\n}\n```", "```js\ninterface WithId {\n id: number;\n}\n\ninterface User {\n name: string;\n}\n\ninterface Developer extends User {\n favoriteLanguage: string;\n}\n\nfunction identifyUser<T extends User>(user: T): T & WithId {\n const newUser = (<any>Object).assign({}, user, { id: 1 });\n return newUser;\n}\n\nconst user: Developer = { name: \"Patrick\", favoriteLanguage: \"TypeScript\" };\nconst userWithId = identifyUser(user);\nconsole.log(`${userWithId.name} (${userWithId.id}) favorite language\n is ${userWithId.favoriteLanguage}`);\n```", "```js\nfunction merge<T, U>(obj1: T, obj2: U): T & U {\n   return Object.assign({}, obj1, obj2);\n}\n```", "```js\nassign<T, U, V>(target: T, source1: U, source2: V): T & U & V;\n```", "```js\ninterface BaseType<T = string> {\n id: T;\n}\nlet entity1: BaseType;\nlet entity2: BaseType<string>;\nlet entity3: BaseType<number>;\n```", "```js\ninterface User<T = string, U> { // Does not compile\n  id: T;\n  name: U;\n}\n\ninterface User<U, T = string> {\n  id: T;\n  name: U;\n}\n```", "```js\ninterface WithId {\n id: number;\n}\n\ninterface UserWithDefault<T extends WithId = number> { } // Does not compile\n```", "```js\ninterface User<T = string> {\n id: T;\n}\n\ninterface WithId {\n id: number;\n}\n\ninterface UserWithDefault<T extends WithId = User<number>> { }\n// Does not compile because User<string>\ninterface UserWithDefault<T extends WithId = User { }\n```", "```js\nfunction shows<T>(p1?: T): void {\n console.log(p1);\n}\n\nshows(); // p1 is {} | undefined\nshows(\"123\");\nshows(123);\n```", "```js\nfunction shows<T = number>(p1?: T): void {\n console.log(p1);\n}\nshows(); // p1 is number | undefined\n```", "```js\ninterface ObjectWithAge {\n kind: \"ObjectWithAge\";\n age: number;\n}\n\nfunction funct2<T extends ObjectWithAge | ObjectWithAge[]>(p: T): T {\n if (p instanceof Array) {\n   return p[0];\n }\n return p;\n}\n```", "```js\ninterface Human {\n name: string;\n birthdate: Date;\n isHappy: boolean;\n}\n\nconst me: Human = {\n name: \"Patrick\",\n birthdate: new Date(1912, 0, 1),\n isHappy: true\n}\n\nconsole.log(me[\"name\"]);\n```", "```js\nfunction showMe1(obj: Human, field: string): void {\n  console.log(obj[field]); // Does not compile\n}\n```", "```js\nfunction showMe2(obj: Human, field: keyof Human): void {\n  console.log(obj[field]);\n}\n```", "```js\nshowMe2(me, \"name\"); // Compile\nshowMe2(me, \"NOname\"); // Does not compile\n```", "```js\nfunction prop<TObject, TMember extends keyof TObject>(\n obj: TObject,\n key: TMember\n): TObject[TMember] {\n return obj[key];\n}\n\ninterface ObjectWithName {\n name: string;\n age: number;\n}\n\nconst obj1: ObjectWithName = { name: \"Patrick\", age: 212 };\nconst result1: string = prop(obj1, \"name\");\nconst result2: number = prop(obj1, \"age\");\n```", "```js\nfunction nameof<T>(instance: T, key: keyof T): keyof T {\n   return key;\n}\n\nconst name1 = nameof(obj1, \"name\");\nconst name2 = nameof(obj1, \"nasme\"); // Does not compile\nconsole.log(name1); // \"name\"\n```", "```js\ntype Readonly<T> = {\n readonly [P in keyof T]: T[P];\n}\n\ntype Partial<T> = {\n [P in keyof T]?: T[P];\n}\n```", "```js\ninterface MyEntity {\n readonly id: number;\n name: string;\n}\n\nconst e1: MyEntity = { id: 1, name: \"Name1\" };\n```", "```js\nconst e1: MyEntity = { id: 1, name: \"Name1\" };\nconst e2: Readonly<MyEntity> = e1;\ne1.name = \"I can change\";\ne2.name = \"I cannot change\"; // Does not compile\n```", "```js\nfunction edit<T>(original: T, obj: Partial<T>): T {\n const returnObject: T = Object.assign({}, original, obj);\n return returnObject;\n}\n\nedit(e1, { name: \"Super\" }); // The returned object is: {id: 1, name: \"Super\"}\nedit(e1, { memberNoExist: \"Super\" }); // Does not compile\n```", "```js\ntype Stringify<T> = { [P in keyof T]: string; };\ntype UnReadonly<T> = { -readonly [P in keyof T]: T[P]; };\n```", "```js\nconst e3: UnReadonly<Stringify<MyEntity>> = e1;\n```", "```js\nfunction castAllFieldToString<T>(obj: T): Stringify<T> {\n let returnValue: any = {};\n for (var property in obj) {\n   if (obj.hasOwnProperty(property)) {\n     returnValue[property] = obj[property].toString();\n   }\n }\n return returnValue as Stringify<T>;\n}\n\nconst e3: UnReadonly<Stringify<MyEntity>> = castAllFieldToString(e1);\ne3.id = \"123\";\n```", "```js\ninterface MyTsxProps<T> {\n item: T;\n}\n\nclass CallGenericComponent extends React.Component<{}>{\n  public render(): JSX.Element {\n    return <MyTsxComponent<string> item={\"123\"} />\n  }\n}\n\nclass MyTsxComponent<T> extends React.Component<MyTsxProps<T>>{\n  // ...\n}\n```"]