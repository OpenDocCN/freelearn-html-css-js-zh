["```js\n<html> \n  <head> \n    <title>TypeScript</title> \n  </head> \n  <body> \n    <h1>TypeScript</h1> \n    <img /> \n  </body> \n</html> \n\n```", "```js\nimport * as Path from 'path'; \nimport * as FS from 'fs'; \n\n```", "```js\nabstract class FileSystemObject { \n  constructor( \n    public path: string, \n    public parent?: FileSystemObject \n  ) { } \n\n  get basename(): string { \n    return Path.basename(this.path); \n  } \n} \n\n```", "```js\nclass FolderObject extends FileSystemObject { \n  items: FileSystemObject[]; \n\n  constructor(path: string, parent?: FileSystemObject) { \n    super(path, parent); \n  } \n} \n\n```", "```js\nthis.items = FS \n  .readdirSync(this.path) \n  .map(path => { \n    let stats = FS.statSync(path); \n\n    if (stats.isFile()) { \n      return new FileObject(path, this); \n    } else if (stats.isDirectory()) { \n      return new FolderObject(path, this); \n    } else { \n      throw new Error('Not supported');\n    } \n  }); \n\n```", "```js\nclass FileObject extends FileSystemObject { \n  readAll(): Buffer { \n    return FS.readFileSync(this.path); \n  } \n} \n\n```", "```js\nconst _log = console.log; \nconsole.log = function () { \n  let timestamp = `[${new Date().toTimeString()}]`;\n  return _log.apply(this, [timestamp, ...arguments]);\n}; \n\n```", "```js\nclass Target { \n  @decorator \n  method() { \n    // ... \n  } \n} \n\n```", "```js\nabstract class UIComponent { \n  abstract draw(): void; \n} \n\n```", "```js\nclass Text { \n  content: string; \n\n  setColor(color: string): void { } \n  setFont(font: string): void { } \n\n  draw(): void { } \n} \n\nclass TextComponent extends UIComponent { \n  texts: Text[]; \n\n  draw(): void { \n    for (let text of this.texts) { \n      text.draw(); \n    } \n  } \n} \n\n```", "```js\nclass Decorator extends UIComponent { \n  constructor( \n    public component: TextComponent \n  ) { \n    super(); \n  } \n\n  get texts(): Text[] { \n    return this.component.texts; \n  } \n\n  draw(): void { \n    this.component.draw(); \n  } \n} \n\n```", "```js\nclass ColorDecorator extends Decorator { \n  constructor( \n    component: TextComponent, \n    public color: string \n  ) { \n    super(component); \n  } \n\n  draw(): void { \n    for (let text of this.texts) { \n      text.setColor(this.color); \n    } \n\n    super.draw(); \n  } \n} \n\nclass FontDecorator extends Decorator { \n  constructor( \n    component: TextComponent, \n    public font: string \n  ) { \n    super(component); \n  } \n\n  draw(): void { \n    for (let text of this.texts) { \n      text.setFont(this.font); \n    } \n\n    super.draw(); \n  } \n} \n\n```", "```js\nlet decoratedComponent = new ColorDecorator( \n  new FontDecorator( \n    new TextComponent(), \n    'sans-serif' \n  ), \n  'black' \n); \n\n```", "```js\nclass Foo { \n  @prefix \n  @suffix \n  getContent(): string { \n    return '...'; \n  } \n} \n\n```", "```js\nfunction prefix( \n  target: Object, \n  name: string, \n  descriptor: PropertyDescriptor \n): PropertyDescriptor { \n  let method = descriptor.value as Function; \n\n  if (typeof method !== 'function') { \n    throw new Error('Expecting decorating a method'); \n  } \n\n  return { \n    value: function () { \n      return '[prefix] ' + method.apply(this, arguments); \n    }, \n    enumerable: descriptor.enumerable, \n    configurable: descriptor.configurable, \n    writable: descriptor.writable \n  }; \n} \n\n```", "```js\ninterface Storage { \n  get<T>(key: string): Promise<T>; \n  set<T>(key: string, value: T): Promise<void>; \n} \n\n```", "```js\nclass IndexedDBStorage implements Storage { \n  constructor( \n    public db: IDBDatabase, \n    public storeName = 'default' \n  ) { } \n\n  open(name: string): Promise<IndexedDBStorage> { \n    return new Promise<IndexedDBStorage>( \n      (resolve, reject) => { \n      let request = indexedDB.open(name); \n\n      // ... \n    }); \n  } \n} \n\n```", "```js\nlet request = indexedDB.open(name); \n\nrequest.onsuccess = event => { \n  let db = request.result as IDBDatabase; \n  let storage = new IndexedDBStorage(db); \n  resolve(storage); \n}; \n\nrequest.onerror = event => { \n  reject(request.error); \n}; \n\n```", "```js\nget<T>(key: string): Promise<T> { \n  return new Promise<T>((resolve, reject) => { \n    let transaction = this.db.transaction(this.storeName); \n    let store = transaction.objectStore(this.storeName); \n\n    let request = store.get(key); \n\n    request.onsuccess = event => { \n      resolve(request.result); \n    }; \n\n    request.onerror = event => { \n      reject(request.error); \n    }; \n  }); \n} \n\n```", "```js\nset<T>(key: string, value: T): Promise<void> { \n  return new Promise<void>((resolve, reject) => { \n    let transaction = \n      this.db.transaction(this.storeName, 'readwrite'); \n    let store = transaction.objectStore(this.storeName); \n\n    let request = store.put(value, key); \n\n    request.onsuccess = event => { \n      resolve(); \n    }; \n\n    request.onerror = event => { \n      reject(request.error); \n    }; \n  }); \n} \n\n```", "```js\ninterface UIToolkit { \n  drawBorder(): void; \n  drawImage(src: string): void; \n  drawText(text: string): void; \n} \n\nabstract class UIElement { \n  constructor( \n    public toolkit: UIToolkit \n  ) { } \n\n  abstract render(): void; \n} \n\n```", "```js\nclass TextElement extends UIElement { \n  constructor( \n    public text: string, \n    toolkit: UIToolkit \n  ) { \n    super(toolkit); \n  } \n\n  render(): void { \n    this.toolkit.drawText(this.text); \n  } \n} \n\n```", "```js\nclass ImageElement extends UIElement { \n  constructor( \n    public src: string, \n    toolkit: UIToolkit \n  ) { \n    super(toolkit); \n  } \n\n  render(): void { \n    this.toolkit.drawImage(this.src); \n  } \n} \n\n```", "```js\nlet toolkit: UIToolkit; \n\nlet imageElement = new ImageElement('foo.jpg', toolkit); \nlet textElement = new TextElement('bar', toolkit); \n\nimageElement.render(); \ntextElement.render(); \n\n```", "```js\nclass Leg { \n  thigh: Thigh; \n  shank: Shank; \n  foot: Foot; \n\n  motionController: MotionController; \n  feedbackController: FeedbackController; \n} \n\n```", "```js\nclass MotionController { \n  constructor( \n    public leg: Leg \n  ) { } \n\n  setAngle(angle: number): void { \n    let { \n      thigh, \n      shank, \n      foot \n    } = this.leg; \n\n    // ... \n  } \n} \n\n```", "```js\nimport { EventEmitter } from 'events'; \n\nclass FeedbackController extends EventEmitter { \n  constructor( \n    public foot: Foot \n  ) { \n    super(); \n  } \n} \n\n```", "```js\nclass Leg { \n  thigh = new Thigh(); \n  shank = new Shank(); \n  foot = new Foot(); \n\n  motionController: MotionController; \n  feedbackController: FeedbackController; \n\n  constructor() { \n    this.motionController = \n      new MotionController(this); \n    this.feedbackController = \n      new FeedbackController(this.foot); \n\n    this.feedbackController.on('touch', () => { \n      // ... \n    }); \n  } \n} \n\n```", "```js\nclass Robot { \n  leftLegMotion: MotionController; \n  rightLegMotion: MotionController; \n\n  leftFootFeedback: FeedbackController; \n  rightFootFeedback: FeedbackController; \n\n  walk(steps: number): void { } \n  jump(strength: number): void { } \n} \n\n```", "```js\nclass Image { \n  constructor(url: string) { } \n} \n\n```", "```js\nclass Snowflake { \n  image: Image; \n\n  constructor( \n    public style: string \n  ) { \n    let url = style + '.png'; \n    this.image = new Image(url); \n  } \n\n  render(x: number, y: number, angle: number): void { \n    // ... \n  } \n} \n\n```", "```js\nconst hasOwnProperty = Object.prototype.hasOwnProperty; \n\nclass SnowflakeFactory { \n  cache: { \n    [style: string]: Snowflake; \n  } = {}; \n\n  get(style: string): Snowflake { \n    let cache = this.cache; \n    let snowflake: Snowflake; \n\n    if (hasOwnProperty.call(cache, style)) { \n      snowflake = cache[style]; \n    } else { \n      snowflake = new Snowflake(style); \n      cache[style] = snowflake; \n    } \n\n    return snowflake; \n  } \n} \n\n```", "```js\nconst SNOW_STYLES = ['A', 'B', 'C']; \n\nclass Sky { \n  constructor( \n    public width: number, \n    public height: number \n  ) { } \n\n  snow(factory: SnowflakeFactory, count: number) { } \n} \n\n```", "```js\nfunction getRandomInteger(max: number): number { \n  return Math.floor(Math.random() * max); \n} \n\n```", "```js\nsnow(factory: SnowflakeFactory, count: number) { \n    let stylesCount = SNOW_STYLES.length; \n\n    for (let i = 0; i < count; i++) { \n        let style = SNOW_STYLES[getRandomInteger(stylesCount)]; \n        let snowflake = factory.get(style); \n\n        let x = getRandomInteger(this.width); \n        let y = getRandomInteger(this.height); \n\n        let angle = getRandomInteger(60); \n\n        snowflake.render(x, y, angle); \n    } } \n\n```", "```js\nlet ready = new Promise<string>(resolve => { \n  setTimeout(() => { \n    resolve('biu~'); \n  }, Math.random() * 1000); \n}); \n\nsetTimeout(() => { \n  ready.then(text => { \n    console.log(text); \n  }); \n}, 999); \n\n```", "```js\nprivate dbPromise: Promise<IDBDatabase>; \n\nconstructor( \n  public name: string, \n  public storeName = 'default' \n) { } \n\nprivate get dbReady(): Promise<IDBDatabase> { \n  if (!this.dbPromise) { \n    this.dbPromise = \n      new Promise<IDBDatabase>((resolve, reject) => { \n      let request = indexedDB.open(name); \n\n      request.onsuccess = event => { \n        resolve(request.result); \n      }; \n\n      request.onerror = event => { \n        reject(request.error); \n      }; \n    }); \n  } \n\n  return this.dbPromise; \n} \n\n```", "```js\nget<T>(key: string): Promise<T> { \n  return this \n    .dbReady \n    .then(db => new Promise<T>((resolve, reject) => { \n      let transaction = db.transaction(this.storeName); \n      let store = transaction.objectStore(this.storeName); \n\n      let request = store.get(key); \n\n      request.onsuccess = event => { \n        resolve(request.result); \n      }; \n\n      request.onerror = event => { \n        reject(request.error); \n      }; \n    })); \n} \n\n```", "```js\nset<T>(key: string, value: T): Promise<void> { \n  return this \n    .dbReady \n    .then(db => new Promise<void>((resolve, reject) => { \n      let transaction = db\n         .transaction(this.storeName, 'readwrite'); \n      let store = transaction.objectStore(this.storeName); \n\n      let request = store.put(value, key); \n\n      request.onsuccess = event => { \n        resolve(); \n      }; \n\n      request.onerror = event => { \n        reject(request.error); \n      }; \n    })); \n} \n\n```", "```js\ninterface Permission { \n  write: boolean; \n  read: boolean; \n} \n\n```", "```js\nget<T>(key: string): Promise<T> { \n  if (!this.permission.read) { \n    return Promise.reject<T>(new Error('Permission denied')); \n  } \n\n  // ... \n} \n\nset<T>(key: string, value: T): Promise<void> { \n  if (!this.permission.write) { \n    return Promise.reject(new Error('Permission denied')); \n  } \n\n  // ... \n} \n\n```"]