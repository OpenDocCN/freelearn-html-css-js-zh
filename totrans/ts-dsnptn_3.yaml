- en: Chapter 5. Behavioral Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, behavioral design patterns are patterns about how objects
    or classes interact with each other. The implementation of behavioral design patterns
    usually requires certain data structures to support the interaction in a system.
    However, behavioral patterns and structural patterns focus on different aspects
    when applied. As a result, you might find patterns in the category of behavioral
    design patterns usually have simpler or more straightforward structures compared
    to structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to talk about some of the following common behavioral
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain of Responsibility**: Organizes behaviors with different scopes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: Exposes commands from the internal with encapsulated context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: Provides an approach for managing states outside of their owners
    without exposing detailed implementations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator**: Provides a universal interface for traversing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mediator**: It groups coupling and logically related objects and makes interconnections
    cleaner in a system that manages many objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of Responsibility Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many scenarios under which we might want to apply certain actions
    that can fall back from a detailed scope to a more general one.
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice example would be the help information of a GUI application: when a user
    requests help information for a certain part of the user interface, it is expected
    to show information as specific as possible. This can be done with different implementations,
    and the most intuitive one for a web developer could be events bubbling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a DOM structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user clicks on the `span.origin` element, a `click` event would start
    bubbling from the `span` element to the document root (if `useCapture` is `false`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, it will trigger both event listeners added in the preceding code.
    To stop the propagation as soon as an event gets handled, we can call its `stopPropagation`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Though a `click` event is not exactly the same as the help information request,
    with the support of custom events, it's quite easy to handle help information
    with necessary detailed or general information in the same chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important implementation of the Chain of Responsibility Pattern is
    related to error handling. A primitive example for this could be using `try...catch`.
    Consider code like this: we have three functions: `foo`, `bar`, and `biu`, `foo`
    is called by `bar` while `bar` is called by `biu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside both functions `bar` and `biu`, we can do some error catching. Assuming
    function `foo` throws two kinds of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In function `bar` we would like to handle the `TypeError` and leave other errors
    throwing on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And in function `biu`, we would like to add more general handling that catches
    all the errors so that the program will not crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So by using `try...catch` statements, you may have been using the Chain of Responsibility
    Pattern constantly without paying any attention to it. Just like you may have
    been using other well-known design patterns all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we abstract the structure of Chain of Responsibility Pattern into objects,
    we could have something as illustrated in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chain of Responsibility Pattern](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of the Chain of Responsibility Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handler**: Defines the interface of the handler with successor and method
    to handle requests. This is done implicitly with classes like `EventEmitter` and
    `try...catch` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete handler**: `EventListener`, `catch` block and `HandlerA`/`HandlerB`
    in the class version. Defines handlers in the form of callbacks, code blocks and
    classes that handle requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: Initiates the requests that go through the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chain of Responsibility Pattern itself could be applied to many different
    scopes in a program. It requires a multi-level chain to work, but this chain could
    be in different forms. We've been playing with events as well as `try...catch`
    statements that have structural levels, this pattern could also be applied to
    scenarios that have logical levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider objects marked with different scopes using string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we have two objects with related scopes specified by string, and by adding
    filters to these scope strings, we can apply operations from specific ones to
    general ones.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this part, we are going to implement the class version we''ve mentioned
    at the end of the introduction to the Chain of Responsibility Pattern. Consider
    requests that could either ask for help information or feedback prompts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are using string literal type here with union type. It is a pretty useful
    feature provided in TypeScript that plays well with existing JavaScript coding
    styles. See the following link for more information: [http://www.typescriptlang.org/docs/handbook/advanced-types.html](http://www.typescriptlang.org/docs/handbook/advanced-types.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the key processes for this pattern is going through the handlers'' chain
    and finding out the most specific handler that''s available for the request. There
    are several ways to achieve this: by recursively invoking the `handle` method
    of a successor, or having a separate logic walking through the handler successor
    chain until the request is confirmed as handled.'
  prefs: []
  type: TYPE_NORMAL
- en: The logic walking through the chain in the second way requires the acknowledgment
    of whether a request has been properly handled. This can be done either by a state
    indicator on the request object or by the return value of the `handle` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll go with the recursive implementation in this part. Firstly, we want
    the default handling behavior of a handler to be forwarding requests to its successor
    if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now for `HelpHandler`, it handles help requests but forwards others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for `FeedbackHandler` is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Thus, a chain of handlers could be made up in some way. And if a request got
    in this chain, it would be passed on until a handler recognizes and handles it.
    However, it is not necessary to have all requests *handled* after processing them.
    The handlers can always pass a request on whether this request gets processed
    by this handler or not.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chain of Responsibility Pattern decouples the connection between objects
    that issue the requests and logic that handles those requests. The sender assumes
    that its requests could, but not necessarily, be properly handled without knowing
    the details. For some implementations, it is also very easy to add new responsibilities
    to a specific handler on the chain. This provides notable flexibility for handling
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the examples we''ve been talking about, there is another important
    mutation of `try...catch` that can be treated in the Chain of Responsibility Pattern
    - Promise. Within a smaller scope, the chain could be represented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard `catch` method on an ES Promise object does not provide the overload
    that accepts an error type as a parameter, but many implementations do.
  prefs: []
  type: TYPE_NORMAL
- en: In a larger scope, this chain would usually appear when the code is playing
    with third-party libraries. A common usage would be converting errors produced
    by other libraries to errors known to the current project. We'll talk more about
    error handling of asynchronous code later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Command Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command Pattern involves encapsulating operations as executable commands and
    could either be in the form of objects or functions in JavaScript. It is common
    that we may want to make operations rely on certain context and states that are
    not accessible for the invokers. By storing those pieces of information with a
    command and passing it out, this situation could be properly handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an extremely simple example: we want to provide a function called
    `wait`, which returns a `cancel` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `cancel` handler in the preceding code is just a command we were talking
    about. It stores the context (`$layer`) using closure and is passed out as the
    return value of function `wait`.
  prefs: []
  type: TYPE_NORMAL
- en: Closure in JavaScript provides a really simple way to store command context
    and states, however, the direct disadvantage would be compromised flexibility
    between context/states and command functions because closure is lexically determined
    and cannot be changed at runtime. This would be okay if the command is only expected
    to be invoked with fixed context and states, but for more complex situations,
    we might need to construct them as objects with a proper data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the overall relations between participants of Command
    Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Command Pattern](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By properly splitting apart context and states with the command object, Command
    Pattern could also play well with Flyweight Pattern if you wanted to reuse command
    objects multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Other common extensions based on Command Pattern include undo support and macros
    with multiple commands. We are going to play with those later in the implementation
    part.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Command Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**: Defines the general interface of commands passing around, it could
    be a function signature if the commands are in the form of functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete command**: Defines the specific behaviors and related data structure.
    It could also be a function that matches the signature declared as `Command`.
    The `cancel` handler in the very first example is a concrete command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context**: The context or receiver that the command is associated with. In
    the first example, it is the `$layer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: Creates concrete commands and their contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoker**: Executes concrete commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Command Pattern suggests two separate parts in a single application or a larger
    system: *client* and *invoker*. In the simplified example `wait` and `cancel`,
    it could be hard to distinguish the difference between those parts. But the line
    is clear: *client* knows or controls the context of commands to be executed with,
    while *invoker* does not have access or does not need to care about that information.'
  prefs: []
  type: TYPE_NORMAL
- en: The key to the Command Pattern is the separation and bridging between those
    two parts through commands that store context and states.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s common for an editor to expose commands for third-party extensions to
    modify the text content. Consider a `TextContext` that contains information about
    the text file being edited and an abstract `TextCommand` class associated with
    that context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Certainly, `TextContext` could contain much more information like language,
    encoding, and so on. You can add them in your own implementation for more functionality.
    Now we are going to create two commands: `ReplaceCommand` and `InsertCommand`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Those two commands share similar logic and actually `InsertCommand` can be treated
    as a subset of `ReplaceCommand`. Or if we have a new delete command, then replace
    command can be treated as the combination of delete and insert commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s assemble those commands with the client and invoker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go further, we can actually have a command that executes other commands.
    Namely, we can have macro commands. Though the preceding example alone does not
    make it necessary to create a macro command, there would be scenarios where macro
    commands help. As those commands are already associated with their contexts, a
    macro command usually does not need to have an explicit context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command Pattern decouples the client (who knows or controls context) and the
    invoker (who has no access to or does not care about detailed context).
  prefs: []
  type: TYPE_NORMAL
- en: 'It plays well with Composite Pattern. Consider the example of macro commands
    we mentioned above: a macro command can have other macro commands as its components,
    thus we make it a composite command.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important case of Command Pattern is adding support for undo operations.
    A direct approach is to add the `undo` method to every command. When an undo operation
    is requested, invoke the `undo` method of commands in reverse order, and we can
    pray that every command would be undone correctly. However, this approach relies
    heavily on a flawless implementation of the `undo` method as every mistake will
    accumulate. To implement more stable undo support, redundant information or snapshots
    could be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Memento Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve talked about an undo support implementation in the previous section
    on the Command Pattern, and found it was not easy to implement the mechanism purely
    based on reversing all the operations. However, if we take snapshots of objects
    as their history, we may manage to avoid accumulating mistakes and make the system
    more stable. But then we have a problem: we need to store the states of objects
    while the states are encapsulated with objects themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memento Pattern helps in this situation. While a memento carries the state
    of an object at a certain time point, it also controls the process of setting
    the state back to an object. This makes the internal state implementation hidden
    from the undo mechanism in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memento Pattern](img/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have the instances of the memento controlling the state restoration in the
    preceding structure. It can also be controlled by the caretaker, namely the undo
    mechanism, for simple state restoring cases.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Memento Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memento**: Stores the state of an object and defines method `restore` or
    other APIs for restoring the states to specific objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Originator**: Deals with objects that need to have their internal states
    stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caretaker**: Manages mementos without intervening with what''s inside'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Memento Pattern mainly does two things: it prevents the caretaker from knowing
    the internal state implementation and decouples the state retrieving and restoring
    process from states managed by the `Caretaker` or `Originator.`'
  prefs: []
  type: TYPE_NORMAL
- en: When the state retrieving and restoring processes are simple, having separated
    mementos does not help much if you are already keeping the decoupling idea in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start with an empty `State` interface and `Memento` class. As we do not want
    `Caretaker` to know the details about state inside an `Originator` or `Memento`,
    we would like to make `state` property of `Memento` private. Having restoration
    logic inside `Memento` does also help with this, and thus we need method `restore`.
    So that we don't need to expose a public interface for reading state inside a
    memento.
  prefs: []
  type: TYPE_NORMAL
- en: 'And as an object assignment in JavaScript assigns only its reference, we would
    like to do a quick copy for the states (assuming state objects are single-level):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For `Originator` we use a getter and a setter for creating and restoring specific
    mementos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `Caretaker` would manage the history accumulated with mementos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In some implementations of Memento Pattern, a `getState` method is provided
    for instances of `Originator` to read state from a memento. But to prevent classes
    other than `Originator` from accessing the `state` property, it may rely on language
    features like a *friend modifier* to restrict the access (which is not yet available
    in TypeScript).
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memento Pattern makes it easier for a caretaker to manage the states of originators
    and it becomes possible to extend state retrieving and restoring. However, a perfect
    implementation that seals everything might rely on language features as we've
    mentioned before. Using mementos could also bring a performance cost as they usually
    contain redundant information in trade of stability.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterator Pattern provides a universal interface for accessing internal elements
    of an aggregate without exposing the underlying data structure. A typical iterator
    contains the following methods or getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first()`: moves the cursor to the *first* element in the aggregates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next()`: moves the cursor to the *next* element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: a getter that returns a Boolean indicates whether the cursor is at the
    end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`item`: a getter that returns the element at the position of the current cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: a getter that returns the index of the element at the current cursor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterators for aggregates with different interfaces or underlying structures
    usually end with different implementations as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Iterator Pattern](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Though the client does not have to worry about the structure of an aggregate,
    an iterator would certainly need to. Assuming we have everything we need to build
    an iterator, there could be a variety of ways for creating one. The factory method
    is widely used when creating iterators, or a *factory getter* if no parameter
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with ES6, syntax sugar `for...of` is added and works for all objects
    with property `Symbol.iterator`. This makes it even easier and more comfortable
    for developers to work with customized lists and other classes that can be iterated.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Iterator Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterator**: `AbstractListIterator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the universal iterator interface that is going to transverse different
    aggregates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete iterator**: `ListIterator`, `SkipListIterator` and `ReversedListIterator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements specific iterator that transverses and keeps track of a specific
    aggregate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Aggregate**: `AbstractList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines a basic interface of aggregates that iterators are going to work with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concreate aggregate**: `List` and `SkipList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the data structure and factory method/getter for creating associated
    iterators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iterator Pattern provides a unified interface for traversing aggregates. In
    a system that doesn't rely on iterators, the main functionality provided by iterators
    could be easily taken over by simple helpers. However, the reusability of those
    helpers could be reduced as the system grows.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part, we are going to implement a straightforward array iterator, as
    well as an ES6 iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Simple array iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by creating an iterator for a JavaScript array, which should be
    extremely easy. Firstly, the universal interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please notice that the TypeScript declaration for ES6 has already declared an
    interface called `Iterator`. Consider putting the code in this part into a namespace
    or module to avoid conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the implementation of a simple array iterator could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to extend the prototype of native `Array` to add an `iterator`
    getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To make `iterator` a valid property of the  `Array` instance, we also need
    to extend the interface of `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This should be written outside the namespace under the global scope. Or if you
    are in a module or ambient module, you might want to try `declare global { ...
    }` for adding new properties to existing global interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 provides syntax sugar `for...of` and other helpers for *iterable* objects,
    namely the objects that have implemented the `Iterable` interface of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume we have a class with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And we would like to make it iterable. More specifically, we would like to
    make it iterates reversely. As the `Iterable` interface suggests, we just need
    to add a method with a special name `Symbol.iterator` for creating an `Iterator`.
    Let''s call the iterator `SomeIterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And then define the `iterator` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we would have `SomeData` that works with `for...of`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Iterators also play well with generators; see the following link for more examples:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).'
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iterator Pattern decouples iteration usage from the data structure that is being
    iterated. The direct benefit of this is enabling an interchangeable data class
    that may have completely different internal structures, like an array and binary
    tree. Also, one data structure can be iterated via different iterators with different
    traversal mechanisms and results in different orders and efficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: A unified iterator interface in one system could also help the developer from
    being confused when facing different aggregates. As we mentioned previously, some
    language like your beloved JavaScript provides a language level abstraction for
    iterators and makes life even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The connections between UI components and related objects could be extremely
    complex. Object-oriented programming distributes functionalities among objects.
    This makes coding easier with cleaner and more intuitive logic; however, it does
    not ensure the reusability and sometimes makes it difficult to understand if you
    look at the code again after some days (you may still understand every single
    operation but would be confused about the interconnections if the network becomes
    really intricate).
  prefs: []
  type: TYPE_NORMAL
- en: Consider a page for editing user profile. There are standalone inputs like nickname
    and tagline, as well as inputs that are related to each other. Taking location
    selection for example, there could easily be a tree-level location and the options
    available in lower levels are determined by the selection of higher levels. However,
    if those objects are managed directly by a single huge controller, it will result
    in a page that has limited reusability. The code formed under this situation would
    also tend to have a hierarchy that's less clean for people to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mediator Pattern tries to solve this problem by separating coupling elements
    and objects as groups, and adding a *director* between a group of elements and
    other objects as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mediator Pattern](img/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Those objects form a mediator with their colleagues that can interact with other
    objects as a single object. With proper encapsulation, the mediator will have
    better reusability as it has just the right size and properly divided functionality.
    In the world of web front end development, there are concepts or implementations
    that fit Mediator Pattern well, like *Web Component* and *React*.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Mediator Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mediator**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, the abstraction or skeleton predefined by a framework. Defines the
    interface that colleagues in a mediator communicate through.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete mediator**: `LocationPicker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages the colleagues and makes them cooperate, providing a higher level interface
    for objects outside.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Colleague classes**: `CountryInput`, `ProvinceInput`, `CityInput`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines references to their mediator and notifies its changes to the mediator
    and accepts modifications issued by the mediator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mediator Pattern could connect many parts of a project, but does not have direct
    or enormous impact on the outline. Most of the credit is given because of increased
    usability and cleaner interconnections introduced by mediators. However, along
    with a nice overall architecture, Mediator Pattern can help a lot with refined
    code quality, and make the project easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using libraries like React would make it very easy to implement Mediator Pattern,
    but for now, we are going with a relatively primitive way and handle changes by
    hand. Let''s think about the result we want for a `LocationPicker` we''ve discussed,
    and hopefully, it includes `country`, `province` and `city` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can sketch the overall structure of class `LocationPicker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can tell how the colleagues are going to cooperate, we would like
    to add a helper method `setOptions` for updating options in a `select` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'I personally tend to have methods that do not depend on a specific instance
    static methods and this applies to methods `getCountries`, `getProvincesByCountry`,
    and `getCitiesByCountryAndProvince` that simply return a list by the information
    given as function arguments (though we are not going to actually implement that
    part):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we may add methods for updating options in the `select` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, weave those colleagues together and add listeners to the `change`
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mediator Pattern, like many other design patterns, downgrades a level-100 problem
    into two level-10 problems and solves them separately. A well-designed mediator
    usually has a proper size and usually tends to be reused in the future. For example,
    we might not want to put nickname input together with the country, province, and
    city inputs as this combination doesn't tend to occur in other situations (which
    means they are not strongly related).
  prefs: []
  type: TYPE_NORMAL
- en: As the project evolves, a mediator may grow to a size that's not efficient anymore.
    So a properly designed mediator should also take the dimension of time into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about some common behavioral patterns for different
    scopes and different scenarios. Chain of Responsibility Pattern and Command Pattern
    can apply to a relatively wide range of scopes, while other patterns mentioned
    in this chapter usually care more about the scope with objects and classes directly
    related.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns we've talked about in this chapter are less like each other
    compared to creational patterns and structural patterns we previously walked through.
    Some of the behavioral patterns could compete with others, but many of them could
    cooperate. For example, we talked about Command Pattern with Memento Pattern to
    implement undo support. Many others may cooperate in parallel and do their own
    part.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue talking about other behavioral design patterns
    that are useful and widely used.
  prefs: []
  type: TYPE_NORMAL
