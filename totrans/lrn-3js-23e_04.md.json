["```js\n    var material = new THREE.MeshBasicMaterial(\n    {\n      color: 0xff0000, name: 'material-1', opacity: 0.5, transparency: true, ...\n    });\n    ```", "```js\n    var material = new THREE.MeshBasicMaterial();\n    material.color = new THREE.Color(0xff0000);\n    material.name = 'material-1';\n    material.opacity = 0.5;\n    material.transparency = true;\n    ```", "```js\nvar meshMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff});\n```", "```js\nvar scene = new THREE.Scene();\nscene.overrideMaterial = new THREE.MeshDepthMaterial();\n```", "```js\nvar cubeMaterial = new THREE.MeshDepthMaterial();\nvar colorMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, transparent: true, blending: THREE.MultiplyBlending})\nvar cube = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry, [colorMaterial, cubeMaterial]);\ncube.children[1].scale.set(0.99, 0.99, 0.99);\n```", "```js\ncube.children[1].scale.set(0.99, 0.99, 0.99);\n```", "```js\nfor (var f = 0, fl = sphere.geometry.faces.length; f < fl; f++) {\n  var face = sphere.geometry.faces[ f ];\n  var centroid = new THREE.Vector3(0, 0, 0);\n  centroid.add(sphere.geometry.vertices[face.a]);\n  centroid.add(sphere.geometry.vertices[face.b]);\n  centroid.add(sphere.geometry.vertices[face.c]);\n  centroid.divideScalar(3);\n\n  var arrow = new THREE.ArrowHelper(face.normal, centroid, 2, 0x3333FF, 0.5, 0.5);\n  sphere.add(arrow);\n}\n```", "```js\nvar matArray = [];\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0x009e60 }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0x009e60 }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0x0051ba }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0x0051ba }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xffd500 }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xffd500 }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xff5800 }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xff5800 }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xC41E3A }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xC41E3A }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xffffff }));\nmatArray.push(new THREE.MeshBasicMaterial( { color: 0xffffff }));\n\nvar faceMaterial = new THREE.MeshFaceMaterial(matArray);\n\nvar cubeGeom = new THREE.BoxGeometry(3,3,3);\nvar cube = new THREE.Mesh(cubeGeom, faceMaterial);\n```", "```js\nvar group = new THREE.Mesh();\n// add all the rubik cube elements\nvar mats = [];\nmats.push(new THREE.MeshBasicMaterial({ color: 0x009e60 }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0x009e60 }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xffd500 }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xffd500 }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xff5800 }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xff5800 }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xC41E3A }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xC41E3A }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xffffff }));\nmats.push(new THREE.MeshBasicMaterial({ color: 0xffffff }));\n\nvar faceMaterial = new THREE.MeshFaceMaterial(mats);\n\nfor (var x = 0; x < 3; x++) {\n  for (var y = 0; y < 3; y++) {\n    for (var z = 0; z < 3; z++) {\n      var cubeGeom = new THREE.BoxGeometry(2.9, 2.9, 2.9);\n      var cube = new THREE.Mesh(cubeGeom, faceMaterial);\n      cube.position.set(x * 3 - 3, y * 3, z * 3 - 3);\n\n      group.add(cube);\n    }\n  }\n}\n```", "```js\ngroup.rotation.y=step+=0.01;\n```", "```js\nvar meshMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});\n```", "```js\nvar meshMaterial = new THREE.MeshPhongMaterial({color: 0x7777ff});\n```", "```js\n<script id=\"vertex-shader\" type=\"x-shader/x-vertex\">\n  uniform float time;\n\n  void main()\n  {\n    vec3 posChanged = position;\n    posChanged.x = posChanged.x*(abs(sin(time*1.0)));\n    posChanged.y = posChanged.y*(abs(cos(time*1.0)));\n    posChanged.z = posChanged.z*(abs(sin(time*1.0)));\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);\n  }\n</script>\n```", "```js\nvec3 posChanged = position;\nposChanged.x = posChanged.x*(abs(sin(time*1.0)));\nposChanged.y = posChanged.y*(abs(cos(time*1.0)));\nposChanged.z = posChanged.z*(abs(sin(time*1.0)));\n```", "```js\ngl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);\n```", "```js\nfunction createMaterial(vertexShader, fragmentShader) {\n  var vertShader = document.getElementById(vertexShader).innerHTML;\n  var fragShader = document.getElementById(fragmentShader).innerHTML;\n\n  var attributes = {};\n  var uniforms = {\n    time: {type: 'f', value: 0.2},\n    scale: {type: 'f', value: 0.2},\n    alpha: {type: 'f', value: 0.6},\n    resolution: { type: \"v2\", value: new THREE.Vector2() }\n  };\n\n  uniforms.resolution.value.x = window.innerWidth;\n  uniforms.resolution.value.y = window.innerHeight;\n\n  var meshMaterial = new THREE.ShaderMaterial({\n    uniforms: uniforms,\n    attributes: attributes,\n    vertexShader: vertShader,\n    fragmentShader: fragShader,\n    transparent: true\n\n  });\n  return meshMaterial;\n}\n```", "```js\nfunction render() {\n  stats.update();\n\n  cube.rotation.y = step += 0.01;\n  cube.rotation.x = step;\n  cube.rotation.z = step;\n\n  cube.material.materials.forEach(function (e) {\n    e.uniforms.time.value += 0.01;\n  });\n\n  // render using requestAnimationFrame\n  requestAnimationFrame(render);\n  renderer.render(scene, camera);\n}\n```", "```js\nvar cubeGeometry = new THREE.CubeGeometry(20, 20, 20);\n\nvar meshMaterial1 = createMaterial(\"vertex-shader\", \"fragment-shader-1\");\nvar meshMaterial2 = createMaterial(\"vertex-shader\", \"fragment-shader-2\");\nvar meshMaterial3 = createMaterial(\"vertex-shader\", \"fragment-shader-3\");\nvar meshMaterial4 = createMaterial(\"vertex-shader\", \"fragment-shader-4\");\nvar meshMaterial5 = createMaterial(\"vertex-shader\", \"fragment-shader-5\");\nvar meshMaterial6 = createMaterial(\"vertex-shader\", \"fragment-shader-6\");\n\nvar material = new THREE.MeshFaceMaterial([meshMaterial1, meshMaterial2, meshMaterial3, meshMaterial4, meshMaterial5, meshMaterial6]);\n\nvar cube = new THREE.Mesh(cubeGeometry, material);\n```", "```js\n<script id=\"fragment-shader-6\" type=\"x-shader/x-fragment\">\n  #ifdef GL_ES\n  precision mediump float;\n  #endif\n\n  uniform float time;\n  uniform vec2 resolution;\n\n  void main( void )\n  {\n\n    vec2 uPos = ( gl_FragCoord.xy / resolution.xy );\n\n    uPos.x -= 1.0;\n    uPos.y -= 0.5;\n\n    vec3 color = vec3(0.0);\n    float vertColor = 2.0;\n    for( float i = 0.0; i < 15.0; ++i ) {\n      float t = time * (0.9);\n\n      uPos.y += sin( uPos.x*i + t+i/2.0 ) * 0.1;\n      float fTemp = abs(1.0 / uPos.y / 100.0);\n      vertColor += fTemp;\n      color += vec3( fTemp*(10.0-i)/10.0, fTemp*i/10.0, pow(fTemp,1.5)*1.5 );\n    }\n\n    vec4 color_final = vec4(color, 1.0);\n    gl_FragColor = color_final;\n  }\n</script>\n```", "```js\nvar points = gosper(4, 60);\nvar lines = new THREE.Geometry();\nvar colors = [];\nvar i = 0;\npoints.forEach(function (e) {\n  lines.vertices.push(new THREE.Vector3(e.x, e.z, e.y));\n  colors[ i ] = new THREE.Color(0xffffff);\n  colors[ i ].setHSL(e.x / 100 + 0.5, (  e.y * 20 ) / 300, 0.8);\n  i++;\n});\n\nlines.colors = colors;\nvar material = new THREE.LineBasicMaterial({\n  opacity: 1.0,\n  linewidth: 1,\n  vertexColors: THREE.VertexColors });\n\nvar line = new THREE.Line(lines, material);\n```", "```js\nlines.computeLineDistances();\nvar material = new THREE.LineDashedMaterial({ vertexColors: true, color: 0xffffff, dashSize: 10, gapSize: 1, scale: 0.1 });\n```"]