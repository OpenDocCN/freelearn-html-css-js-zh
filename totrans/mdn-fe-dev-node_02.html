<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-25" lang="en-GB"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-26" lang="en-GB"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.2.1">Dividing Code into Modules and Packages</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.3.1">One of the most important aspects to consider when writing professional software is reusability. </span><span class="koboSpan" id="kobo.3.2">Reusability means that parts of our code base can be purposed to work in several places or under different circumstances. </span><span class="koboSpan" id="kobo.3.3">This implies that we can actually use existing functionality </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.4.1">quite easily.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.5.1">As we learned, a key part of the Node.js success story is down to the fact that it comes with a module system. </span><span class="koboSpan" id="kobo.5.2">So far, we’ve only touched upon the basic concept of CommonJS, which is the default way of importing and exporting functionality </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.6.1">from modules.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.7.1">In this chapter, we’ll take the chance to become familiar with more module formats, including their history, use cases, and development models. </span><span class="koboSpan" id="kobo.7.2">We’ll learn how to divide our code into modules and packages efficiently. </span><span class="koboSpan" id="kobo.7.3">In addition to learning about CommonJS, we will see what a package is and how we can define our own packages. </span><span class="koboSpan" id="kobo.7.4">All in all, this will help us to achieve great reusability – not only for our tooling in Node.js but also for our applications running in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.8.1">the browser.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.9.1">We will cover the following key topics in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.11.1">Using the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.12.1">ESM standard</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.13.1">Learning the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.14.1">AMD specification</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.15.1">Being universal </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.16.1">with UMD</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.17.1">Understanding SystemJS and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.18.1">import maps</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.19.1">Knowing the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.20.1">package.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.21.1"> fundamentals</span></span></li>
</ul>
<h1 id="_idParaDest-27" lang="en-GB"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.23.1">The complete source code for this chapter can be found </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.24.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.25.1">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.26.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.27.1">The CiA videos for this chapter can be accessed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.28.1">at </span></span><a href="http://bit.ly/3FZ6ivk"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.29.1">http://bit.ly/3FZ6ivk</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.30.1">.</span></span></p>
<h1 id="_idParaDest-28" lang="en-GB"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.31.1">Using the ESM standard</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.32.1">CommonJS has </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.33.1">been a good solution for Node.js, but not a desirable solution for JavaScript as a language. </span><span class="koboSpan" id="kobo.33.2">For instance, in the browser, CommonJS does not work. </span><span class="koboSpan" id="kobo.33.3">Doing synchronous imports on URLs is just not possible. </span><span class="koboSpan" id="kobo.33.4">The module resolution of CommonJS was also way too flexible in terms of adding extensions and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.34.1">trying directories.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.35.1">To standardize modules in JavaScript, the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.36.1">ECMAScript Module</span></strong><span class="koboSpan" id="kobo.37.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.38.1">ESM</span></strong><span class="koboSpan" id="kobo.39.1">) standard was established. </span><span class="koboSpan" id="kobo.39.2">It is capable of defining modules that run in the browser, as well as Node.js. </span><span class="koboSpan" id="kobo.39.3">Furthermore, instead of using an arbitrary function such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.40.1">require</span></strong><span class="koboSpan" id="kobo.41.1">, the whole module system relies on language constructs using reserved words. </span><span class="koboSpan" id="kobo.41.2">This way, the module system can be brought over to the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.42.1">browser, too.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.43.1">The ECMAScript standard specified two keywords </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.44.1">for this:</span></span></p>
<ul>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.45.1">import</span></strong><span class="koboSpan" id="kobo.46.1">: Used to import functionality from </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.47.1">other modules</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.48.1">export</span></strong><span class="koboSpan" id="kobo.49.1">: Used to declare the functionality that can be imported into </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.50.1">other modules</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.51.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.52.1">import</span></strong><span class="koboSpan" id="kobo.53.1"> keyword must appear at the beginning of a file – before any other code. </span><span class="koboSpan" id="kobo.53.2">The reason for this choice lies in the demand for ESM files to be used not only within Node.js, but also in the browser. </span><span class="koboSpan" id="kobo.53.3">By placing the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.54.1">import</span></strong><span class="koboSpan" id="kobo.55.1"> statements on top, each ESM file can safely wait until all the imports have </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.56.1">been resolved.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.57.1">Rewriting the example from the previous chapter, we get the following </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.58.1">for </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.59.1">a.js</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.60.1">:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.61.1">import * as b from './b.js'; // get all things from b.js
// use imports
console.log('The value of b is:', b.myValue);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.62.1">The rewrite of the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.63.1">b.js</span></strong><span class="koboSpan" id="kobo.64.1"> file to be valid per the ESM standard is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.65.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.66.1">export const myValue = 42;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.67.1">There are multiple possibilities with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.68.1">import</span></strong><span class="koboSpan" id="kobo.69.1"> keyword. </span><span class="koboSpan" id="kobo.69.2">We can use </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.70.1">the following:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.71.1">Wildcard (using </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.72.1">*</span></strong><span class="koboSpan" id="kobo.73.1">) imports with a name selected by </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.74.1">the developer</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.75.1">Named imports such </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.76.1">as </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.77.1">myValue</span></strong></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.78.1">Default imports with a name selected by </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.79.1">the developer</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.80.1">An empty import that does not get anything, but makes sure to run </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.81.1">the module</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.82.1">Using a named import, we can get a cleaner version </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.83.1">of </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.84.1">a.js</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.85.1">:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.86.1">// get only selected things
import { myValue } from './b.js';
console.log('The value of b is:', myValue); // use imports</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.87.1">The</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.88.1"> preceding code is very similar to the destructuring assignment, which decomposes an object into its fields using the assignment operator (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.89.1">=</span></strong><span class="koboSpan" id="kobo.90.1">). </span><span class="koboSpan" id="kobo.90.2">There are crucial differences, however. </span><span class="koboSpan" id="kobo.90.3">One of these differences is how to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.91.1">make aliases.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.92.1">For instance, when using a destructuring assignment, we can use the colon (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.93.1">:</span></strong><span class="koboSpan" id="kobo.94.1">) to rename the variables, which would have the name of the respective fields by default. </span><span class="koboSpan" id="kobo.94.2">If we wanted to give the variable a different name (e.g., </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.95.1">otherValue</span></strong><span class="koboSpan" id="kobo.96.1">) from its original field (e.g., </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.97.1">myValue</span></strong><span class="koboSpan" id="kobo.98.1">), we’d have to write </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.99.1">the following:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.100.1">// gets all the things, but only uses myValue
const { myValue: otherValue } = require('./b.js');</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.101.1">With an </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.102.1">import</span></strong><span class="koboSpan" id="kobo.103.1"> statement, you need to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.104.1">as</span></strong><span class="koboSpan" id="kobo.105.1"> keyword to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.106.1">achieve this:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.107.1">// gets only myValue – but renames it
import { myValue as otherValue } from './b.js';</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.108.1">A topic that becomes relevant quite quickly is the notion of a default export. </span><span class="koboSpan" id="kobo.108.2">Especially when handling exports from an unknown module, there is a great need to define the export name. </span><span class="koboSpan" id="kobo.108.3">In CommonJS, developers therefore picked the whole module; however, this is no longer possible with ESM. </span><span class="koboSpan" id="kobo.108.4">Every export needs to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.109.1">be named.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.110.1">Luckily, the standardization committee thought about the topic of default exports. </span><span class="koboSpan" id="kobo.110.2">An export is considered to be a default export if it uses the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.111.1">default</span></strong><span class="koboSpan" id="kobo.112.1"> keyword. </span><span class="koboSpan" id="kobo.112.2">For instance, changing the export in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.113.1">b.js</span></strong><span class="koboSpan" id="kobo.114.1"> to use default values could look </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.115.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.116.1">export default 42;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.117.1">Importing</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.118.1"> the default export is quite convenient, too. </span><span class="koboSpan" id="kobo.118.2">Here, we are free to select a name to refer to the default export within our module. </span><span class="koboSpan" id="kobo.118.3">Instead of being able to rename the import, we are forced to give it </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.119.1">a name:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.120.1">import otherValue from './b.js'; // gets only default
console.log('The value of b is:', otherValue);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.121.1">The whole idea is to use default exports as much as possible. </span><span class="koboSpan" id="kobo.121.2">In the end, modules that are effectively written to revolve around exporting a single functionality are often considered </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.122.1">the goal.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.123.1">We’ve already learned that CommonJS does not work in the browser. </span><span class="koboSpan" id="kobo.123.2">In contrast, the modern ESM specification is supposed to work, as imports are declared in the beginning. </span><span class="koboSpan" id="kobo.123.3">This modification allows the browser to safely suspend module evaluation until the imports are fully processed. </span><span class="koboSpan" id="kobo.123.4">This kind of suspension to wait for the dependencies to finish loading was actually taken from another attempt at a module system</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.124.1"> called </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.125.1">Asynchronous Module </span></strong><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.126.1">Definition</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.127.1"> (</span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.128.1">AMD</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.129.1">).</span></span></p>
<h1 id="_idParaDest-29" lang="en-GB"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.130.1">Learning the AMD specification</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.131.1">Before</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.132.1"> ESM was established, people tried to make modules work in the browser, too. </span><span class="koboSpan" id="kobo.132.2">One of the earliest attempts was a small library </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.133.1">called </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.134.1">RequireJS</span></strong><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">RequireJS is a module loader that works in the browser as well as in Node.js. </span><span class="koboSpan" id="kobo.135.3">Initially, the essential idea was that a script reference to RequireJS would be embedded in the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.136.1">&lt;head&gt;</span></strong><span class="koboSpan" id="kobo.137.1"> of a document. </span><span class="koboSpan" id="kobo.137.2">The script would then load and run a defined root module, which would process even </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.138.1">more modules.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.139.1">An example</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.140.1"> website using RequireJS is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.141.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.142.1">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My Sample Project&lt;/title&gt;
    &lt;!--
      data-main attribute tells RequireJS to load
      ./main.js after ./require.js has been loaded
    --&gt;
    &lt;script data-main="./main" src="./require.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.143.1">RequireJS was</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.144.1"> born at a time when promises had not yet been established in the JavaScript world. </span><span class="koboSpan" id="kobo.144.2">Therefore, the module loader was based on the next best thing: callbacks. </span><span class="koboSpan" id="kobo.144.3">Consequently, a module is loaded by calling a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.145.1">requirejs</span></strong><span class="koboSpan" id="kobo.146.1"> function defined by RequireJS. </span><span class="koboSpan" id="kobo.146.2">The whole process can then start loading modules asynchronously as shown in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.147.1">Figure 2</span></em></span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.148.1">.1</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.149.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.150.1"><img alt="Figure 2.1 – Loading modules sequentially vs. asynchronously " src="image/Figure_2.1_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.151.1">Figure 2.1 – Loading modules sequentially vs. </span><span class="koboSpan" id="kobo.151.2">asynchronously</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.152.1">To achieve asynchronous module loading, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.153.1">requirejs</span></strong><span class="koboSpan" id="kobo.154.1"> function takes two arguments. </span><span class="koboSpan" id="kobo.154.2">The first argument is an array with all the dependencies. </span><span class="koboSpan" id="kobo.154.3">The second argument is a callback that receives the exports of the dependencies and returns the exports of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.155.1">current module.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.156.1">The</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.157.1"> whole idea behind RequireJS is very similar to that of ESM today, which shifts the two parts (loading the dependencies and the code that uses the dependencies) into the same module – but still distinguishes between the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.158.1">import</span></strong><span class="koboSpan" id="kobo.159.1"> statements and all the other statements. </span><span class="koboSpan" id="kobo.159.2">Here, ESM leverages the fact that it’s actually a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.160.1">language construct.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.161.1">In short, a module that uses RequireJS looks </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.162.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.163.1">requirejs(['./helper/util'], (util) =&gt; {
  // This is called when ./helper/util.js. </span><span class="koboSpan" id="kobo.163.2">has been processed
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.164.1">The shape of these modules was not arbitrarily decided. </span><span class="koboSpan" id="kobo.164.2">Instead, the RequireJS library is merely one implementation of a specification for an asynchronous module system. </span><span class="koboSpan" id="kobo.164.3">This specification is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.165.1">called AMD.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.166.1">Using AMD, the previous RequireJS-specific example could be rewritten </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.167.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.168.1">define(['./helper/util'], (util) =&gt; {
  // This is called when ./helper/util.js. </span><span class="koboSpan" id="kobo.168.2">has been processed
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.169.1">In addition to the two-argument variant of the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.170.1">define</span></strong><span class="koboSpan" id="kobo.171.1"> function, there is also a three-argument version, where the first argument helps to name the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.172.1">defined module.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.173.1">An example of the three-argument call to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.174.1">define</span></strong><span class="koboSpan" id="kobo.175.1"> is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.176.1">shown here:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.177.1">define('myModule', ['dep1', 'dep2'], (dep1, dep2) =&gt; {
  // Define the module exports by returning a value.
</span><span class="koboSpan" id="kobo.177.2">  return {};
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.178.1">Now, the only thing left before we can use AMD universally is to learn how we can integrate it into Node.js. </span><span class="koboSpan" id="kobo.178.2">First, we need to grab </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.179.1">r.js</span></strong><span class="koboSpan" id="kobo.180.1"> from the official download page: </span><a href="https://requirejs.org/docs/download.html#rjs"><span class="koboSpan" id="kobo.181.1">https://requirejs.org/docs/download.html#rjs</span></a><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">Download it via the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.183.1">Download</span></strong><span class="koboSpan" id="kobo.184.1"> button as shown in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.185.1">Figure 2</span></em></span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.186.1">.2</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.187.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 2.2 – The Download button for r.js on the RequireJS website " src="image/Figure_2.2_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 2.2 – The Download button for r.js on the RequireJS website</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.190.1">Store the</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.191.1"> downloaded file in the directory where you have placed the scripts to run via </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.192.1">node</span></strong><span class="koboSpan" id="kobo.193.1">. </span><span class="koboSpan" id="kobo.193.2">Create a new </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.194.1">a.js</span></strong><span class="koboSpan" id="kobo.195.1"> script in the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.196.1">same </span></span><span class="No-Break" lang=""><a id="_idIndexMarker058"/></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.197.1">directory:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">a.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.199.1">const define = require('./r.js'); // gets the loader
define.config({
  // Will also correctly resolve other Node.js dependencies
  nodeRequire: require
});
define(['./b'], (b) =&gt; {
  console.log('The value of b is:', b.myValue);
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.200.1">The code here does not look so different from the CommonJS example. </span><span class="koboSpan" id="kobo.200.2">After all, only the initialization of the RequireJS loader has been added. </span><span class="koboSpan" id="kobo.200.3">The actual content of the module</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.201.1"> is now part of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.202.1">the callback.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.203.1">Let’s see what the</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.204.1"> transformed </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.205.1">b.js</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.206.1">looks like:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.207.1">b.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.208.1">const define = require('./r.js'); // gets the loader
define.config({
  // Will also correctly resolve other Node.js dependencies
  nodeRequire: require
});
define([], () =&gt; {
  return {
    myValue: 42,
  };
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.209.1">In the preceding code for </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.210.1">b.js</span></strong><span class="koboSpan" id="kobo.211.1">, again, we have added the same envelope, just as in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.212.1">a.js</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">Remember that each module needs to be treated as standalone code. </span><span class="koboSpan" id="kobo.213.3">While how explicit this is may seem rather redundant, the real advantage becomes obvious once it’s used with an unknown number of other modules. </span><span class="koboSpan" id="kobo.213.4">In this case, we never know what has been loaded or used already. </span><span class="koboSpan" id="kobo.213.5">Being independent means being predictable in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.214.1">these scenarios.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.215.1">The problem with the preceding approach is that while this works in Node.js, it certainly does not work in the browser. </span><span class="koboSpan" id="kobo.215.2">Even though we’ve chosen AMD for this specific reason, we failed to make it work in the browser. </span><span class="koboSpan" id="kobo.215.3">The problem lies in the initial call to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.216.1">require</span></strong><span class="koboSpan" id="kobo.217.1">, which uses CommonJS to obtain the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.218.1">AMD loader.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.219.1">To mitigate the problem and use AMD in different</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.220.1"> JavaScript environments, the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.221.1">Universal Module Definition</span></strong><span class="koboSpan" id="kobo.222.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.223.1">UMD</span></strong><span class="koboSpan" id="kobo.224.1">) specification </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.225.1">was created.</span></span></p>
<h1 id="_idParaDest-30" lang="en-GB"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.226.1">Being universal with UMD</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.227.1">When the </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.228.1">UMD specification was brought up, there was a lot of hype in the community. </span><span class="koboSpan" id="kobo.228.2">After all, the label </span><em class="italic" lang=""><span class="koboSpan" id="kobo.229.1">universal</span></em><span class="koboSpan" id="kobo.230.1"> already claims that UMD is the final module system – the one to rule them all. </span><span class="koboSpan" id="kobo.230.2">It tries to do this by supporting essentially three different kinds of JavaScript </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.231.1">module formats:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.232.1">The classic way of doing things without a module system – that is, just by running JavaScript using </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.233.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.234.1"> tags in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.235.1">the browser</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.236.1">The CommonJS format that is used </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.237.1">by Node.js</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.238.1">The previously discussed asynchronously loaded modules from the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.239.1">AMD specification</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.240.1">When you write a JavaScript file with the UMD specification in mind, you essentially make sure that every popular JavaScript runtime can read it. </span><span class="koboSpan" id="kobo.240.2">For instance, UMD works perfectly in Node.js and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.241.1">the browser.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.242.1">To achieve this universality, UMD makes an educated guess regarding what module system can be used and selects it. </span><span class="koboSpan" id="kobo.242.2">For example, if a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.243.1">define</span></strong><span class="koboSpan" id="kobo.244.1"> function is detected, then AMD might be used. </span><span class="koboSpan" id="kobo.244.2">Alternatively, detecting something such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.245.1">exports</span></strong><span class="koboSpan" id="kobo.246.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.247.1">module</span></strong><span class="koboSpan" id="kobo.248.1"> hints towards CommonJS. </span><span class="koboSpan" id="kobo.248.2">If nothing is found, then the assumption is that the module runs in the browser without AMD present. </span><span class="koboSpan" id="kobo.248.3">In this case, the exports of the module would be </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.249.1">stored globally.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.250.1">The main target group for UMD is library authors. </span><span class="koboSpan" id="kobo.250.2">When you build a library, you want it to be useful. </span><span class="koboSpan" id="kobo.250.3">Consequently, you’ll also need to make sure that the library can be used. </span><span class="koboSpan" id="kobo.250.4">By providing your library in the UMD format, you ensure that it can be used on pretty much all platforms – in Node.js and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.251.1">the browser.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.252.1">So, how would our code from</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.253.1"> the previous example look if we used UMD as the format of choice? </span><span class="koboSpan" id="kobo.253.2">Let’s have </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.254.1">a look:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.255.1">a.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.256.1">((root, factory) =&gt; { // context and export callback
  if (typeof define === 'function' &amp;&amp; define.amd) {
    // there is a define function that follows AMD – use it
    define(['b'], factory);
  } else if (typeof exports === 'object' &amp;&amp; typeof module
    !== 'undefined') {
    // there is module and exports: CommonJS
    factory(require('b'));
  } else {
    // we just take the global context
    factory(root.b);
  }
})(typeof self !== 'undefined' ? </span><span class="koboSpan" id="kobo.256.2">self : this, (b) =&gt; {
  // this is the body of the module, follows AMD
  console.log('The value of b is:', b.myValue);
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.257.1">As before, the </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.258.1">preceding code consists of two sections. </span><span class="koboSpan" id="kobo.258.2">The first section establishes the module system and sets up the callback. </span><span class="koboSpan" id="kobo.258.3">The second section puts the actual content of our module into </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.259.1">the callback.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.260.1">The only thing left is to see how we can mark our exports with UMD. </span><span class="koboSpan" id="kobo.260.2">For this part, we will look at </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.261.1">b.js</span></strong><span class="koboSpan" id="kobo.262.1"> in</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.263.1"> the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.264.1">UMD format:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1">b.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.266.1">((root, factory) =&gt; {
  if (typeof define === 'function' &amp;&amp; define.amd) {
    // in AMD we depend on the special "exports" dependency
    define(['exports'], factory);
  } else if (typeof exports === 'object' &amp;&amp; typeof module
    !== 'undefined') {
    // in CommonJS we'll forward the exports
    factory(exports);
  } else {
    // for scripts we define a new global and forward it
    factory(root.b = {});
  }
})(typeof self !== 'undefined' ? </span><span class="koboSpan" id="kobo.266.2">self : this, (exports) =&gt;
{
  // use the CommonJS format in here
  exports.myValue = 42;
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.267.1">With all</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.268.1"> the boilerplate code in place, the </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.269.1">script is universal. </span><span class="koboSpan" id="kobo.269.2">The defined callback (named </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.270.1">factory</span></strong><span class="koboSpan" id="kobo.271.1"> in the two examples in this section) is either called indirectly from the AMD runtime or directly in the other </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.272.1">two cases.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.273.1">Usually, we will not write the whole boilerplate code shown here ourselves. </span><span class="koboSpan" id="kobo.273.2">The boilerplate will be generated by tooling, which we will look into in </span><a href="B18989_06.xhtml#_idTextAnchor057"><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.274.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.275.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.276.1">Building Web Apps with Bundlers</span></em><span class="koboSpan" id="kobo.277.1">. </span><span class="koboSpan" id="kobo.277.2">Instead, the ideal option for writing modules in many cases is ESM. </span><span class="koboSpan" id="kobo.277.3">Since it’s syntax-based, we follow the language’s standard. </span><span class="koboSpan" id="kobo.277.4">The other formats can then be used by our tooling as </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.278.1">output formats.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.279.1">One more module format to have a closer </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.280.1">look at is SystemJS. </span><span class="koboSpan" id="kobo.280.2">One of the reasons why SystemJS is interesting is that it brings support for import maps, which can simplify dealing with </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.281.1">module systems.</span></span></p>
<h1 id="_idParaDest-31" lang="en-GB"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.282.1">Understanding SystemJS and import maps</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.283.1">Earlier in this chapter, we</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.284.1"> learned that ESM is arguably the best module system for JavaScript. </span><span class="koboSpan" id="kobo.284.2">After all, it is integrated into the JavaScript language. </span><span class="koboSpan" id="kobo.284.3">One of the reasons why other formats are still relevant today is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.285.1">backward compatibility.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.286.1">Backward compatibility allows formats such as AMD or UMD to be used in older JavaScript runtimes, such as older versions of browsers such as Internet Explorer, but even if we don’t need backward compatibility, the alternative formats still have one or more advantages </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.287.1">over ESM.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.288.1">One of the core problems with ESM is that it does not define how modules are resolved. </span><span class="koboSpan" id="kobo.288.2">In fact, the only specified way to resolve a module is explicitly via the filesystem. </span><span class="koboSpan" id="kobo.288.3">When we used ESM, we explicitly stated our module imports, such as in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.289.1">./b.js</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">As mentioned, we are not allowed to implicitly use something such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.291.1">./b</span></strong><span class="koboSpan" id="kobo.292.1"> or even </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.293.1">just </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.294.1">b</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.295.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.296.1">When doing frontend development, the notion of dependencies has become quite elementary. </span><span class="koboSpan" id="kobo.296.2">From boilerplate libraries to UI frameworks, frontend developers make use of a wide array of given code. </span><span class="koboSpan" id="kobo.296.3">That code is usually packaged into libraries and then installed locally for development purposes, but how should these dependencies </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.297.1">be used?</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.298.1">Turns out that Node.js solved this problem already in the early stages of its development. </span><span class="koboSpan" id="kobo.298.2">We have seen that using CommonJS we are able to write code such as </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.299.1">the </span></span><span class="No-Break" lang=""><a id="_idIndexMarker070"/></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.300.1">following:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.301.1">host-cjs.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.302.1">const os = require('os');
console.log('The current hostname is:', os.hostname());</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.303.1">The reference to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.304.1">os</span></strong><span class="koboSpan" id="kobo.305.1"> is resolved by Node.js through CommonJS. </span><span class="koboSpan" id="kobo.305.2">In this special case, the reference leads to one framework library of Node.js. </span><span class="koboSpan" id="kobo.305.3">However, it could also lead to a third-party dependency that has been installed </span><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.306.1">by us. </span><span class="koboSpan" id="kobo.306.2">In </span><a href="B18989_03.xhtml#_idTextAnchor033"><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.307.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.308.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.309.1">Choosing a Package Manager</span></em><span class="koboSpan" id="kobo.310.1">, we will see how </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.311.1">this works.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.312.1">Let’s translate the preceding</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.313.1"> code </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.314.1">into ESM:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.315.1">host-esm.js</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.316.1">import { hostname } from 'node:os';
console.log('The current hostname is:', hostname());</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.317.1">The</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.318.1"> conversion of the little snippet is not very complicated, with the exception of the module name. </span><span class="koboSpan" id="kobo.318.2">Previously, we used </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.319.1">os</span></strong><span class="koboSpan" id="kobo.320.1"> as an identifier. </span><span class="koboSpan" id="kobo.320.2">Node.js has chosen to also allow this for backward compatibility – at least for now. </span><span class="koboSpan" id="kobo.320.3">The preferred way, however, is to use a custom protocol. </span><span class="koboSpan" id="kobo.320.4">In the case of Node.js framework libraries, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.321.1">node:</span></strong><span class="koboSpan" id="kobo.322.1"> protocol has </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.323.1">been chosen.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.324.1">Leveraging custom protocols to resolve dependencies is possible in the browser. </span><span class="koboSpan" id="kobo.324.2">However, it is also cumbersome. </span><span class="koboSpan" id="kobo.324.3">After all, the whole resolution would now need to be done by us. </span><span class="koboSpan" id="kobo.324.4">This also represents a classic chicken-egg problem. </span><span class="koboSpan" id="kobo.324.5">To define custom protocols, we need to have some JavaScript running; however, if this piece of JavaScript relies on third-party dependencies that are actually resolved via the custom protocol, then we cannot successfully implement the resolution </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.325.1">of dependencies.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.326.1">One way that we can still use convenient references such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.327.1">os</span></strong><span class="koboSpan" id="kobo.328.1"> is to define a so-called import map. </span><span class="koboSpan" id="kobo.328.2">An import map helps the browser map module names to actual URLs. </span><span class="koboSpan" id="kobo.328.3">It uses </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.329.1">JSON</span></strong><span class="koboSpan" id="kobo.330.1"> with an</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.331.1"> object stored in the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.332.1">imports</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.333.1"> field.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.334.1">The following is an</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.335.1"> import map to find an implementation of the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.336.1">os</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.337.1"> module:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.338.1">{
  "imports": {
    "os": "https://example.com/js/os.min.js"
  }
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.339.1">The URLs don’t have to be fully qualified. </span><span class="koboSpan" id="kobo.339.2">In the case of relative URLs, the module’s URL is computed from the base URL of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.340.1">import map.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.341.1">The integration of import maps into a website is relatively simple. </span><span class="koboSpan" id="kobo.341.2">All we need to do is to specify a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.342.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.343.1"> tag with the type </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.344.1">being </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.345.1">importmap</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.346.1">:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.347.1">&lt;script type="importmap"&gt;
{
  "imports": {
    "os": "https://example.com/js/os.min.js"
  }
}
&lt;/script&gt;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.348.1">In addition, import maps </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.349.1">may be loaded from external files, too. </span><span class="koboSpan" id="kobo.349.2">In any case, the specified mapping of module names to URLs only works for </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.350.1">import</span></strong><span class="koboSpan" id="kobo.351.1"> statements. </span><span class="koboSpan" id="kobo.351.2">It will not work in other places where a URL is expected. </span><span class="koboSpan" id="kobo.351.3">For instance, the following example </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.352.1">does </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.353.1">not work:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.354.1">fail.html</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.355.1">&lt;script type="importmap"&gt;
{
  "imports": {
    "/app.mjs": "/app.8e0d62a03.mjs"
  }
}
&lt;/script&gt;
&lt;script type="module" src="/app.mjs"&gt;&lt;/script&gt;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.356.1">In the preceding code, we have tried to load </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.357.1">/app.mjs</span></strong><span class="koboSpan" id="kobo.358.1"> directly, which will fail. </span><span class="koboSpan" id="kobo.358.2">We need to </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.359.1">use an </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.360.1">import</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.361.1"> statement:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.362.1">success.html</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.363.1">&lt;script type="importmap"&gt;
{
  "imports": {
    "/app.mjs": "/app.8e0d62a03.mjs"
  }
}
&lt;/script&gt;
&lt;script type="module"&gt;import "/app.mjs";&lt;/script&gt;</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.364.1">There is a</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.365.1"> lot more that can be written about import maps; however, for now, the most important detail is that they only work partially – that is, without external files, in recent versions of </span><em class="italic" lang=""><span class="koboSpan" id="kobo.366.1">Google Chrome</span></em><span class="koboSpan" id="kobo.367.1"> (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.368.1">89</span></em><span class="koboSpan" id="kobo.369.1"> and higher) and </span><em class="italic" lang=""><span class="koboSpan" id="kobo.370.1">Microsoft Edge</span></em><span class="koboSpan" id="kobo.371.1"> (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.372.1">89</span></em><span class="koboSpan" id="kobo.373.1"> and higher). </span><span class="koboSpan" id="kobo.373.2">In most other browsers, the import map support is either not there or must explicitly </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.374.1">be enabled.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.375.1">The </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.376.1">alternative is to use </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.377.1">SystemJS. </span><span class="koboSpan" id="kobo.377.2">SystemJS is a module loader similar to RequireJS. </span><span class="koboSpan" id="kobo.377.3">The main difference is that SystemJS provides support for multiple module systems and module system capabilities, such as using </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.378.1">import maps.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.379.1">While SystemJS also supports various formats such as ESM, it also comes with its own format. </span><span class="koboSpan" id="kobo.379.2">Without going into too much detail, the shape of a native SystemJS module looks </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.380.1">as follows:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.381.1">System.register(['dependency'], (_export, _context) =&gt; {
  let dependency;
  return {
    setters: [(_dep) =&gt; {
      dependency = _dep;
    }],
    execute: () =&gt; {
      _export({
        myValue: 42,
      });
    },
  };
});</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.382.1">The preceding code is structurally quite similar to the AMD boilerplate, with the only difference being how the callback is structured. </span><span class="koboSpan" id="kobo.382.2">While AMD runs the module’s body in the callback, SystemJS specifies </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.383.1">some more sections in the callback. </span><span class="koboSpan" id="kobo.383.2">These sections are then run on demand. </span><span class="koboSpan" id="kobo.383.3">The real body of a module is defined in the returned </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.384.1">execute</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.385.1"> section.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.386.1">As before, the short snippet already illustrates quite nicely that SystemJS modules are rarely written by hand. </span><span class="koboSpan" id="kobo.386.2">Instead, they are generated by tooling. </span><span class="koboSpan" id="kobo.386.3">We’ll therefore come back to SystemJS once we have more powerful tooling on hand to automate the task of creating valid </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.387.1">SystemJS modules.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.388.1">Now that we have heard enough about libraries and packages, we also need to know how we can define our own package. </span><span class="koboSpan" id="kobo.388.2">To indicate a package, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.389.1">package.json</span></strong><span class="koboSpan" id="kobo.390.1"> file has to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.391.1">be used.</span></span></p>
<h1 id="_idParaDest-32" lang="en-GB"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.392.1">Knowing package.json fundamentals</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.393.1">The aggregation </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.394.1">of multiple modules forms a package. </span><span class="koboSpan" id="kobo.394.2">A package is defined by a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.395.1">package.json</span></strong><span class="koboSpan" id="kobo.396.1"> file in a directory. </span><span class="koboSpan" id="kobo.396.2">This marks the directory as the root of a package. </span><span class="koboSpan" id="kobo.396.3">A minimal valid </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.397.1">package.json</span></strong><span class="koboSpan" id="kobo.398.1"> to indicate a package is </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.399.1">as follows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.400.1">package.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.401.1">{
  "name": "my-package",
  "version": "1.0.0"
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.402.1">Some fields, such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.403.1">name</span></strong><span class="koboSpan" id="kobo.404.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.405.1">version</span></strong><span class="koboSpan" id="kobo.406.1">, have special meanings. </span><span class="koboSpan" id="kobo.406.2">For instance, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.407.1">name</span></strong><span class="koboSpan" id="kobo.408.1"> field is used to give the package a name. </span><span class="koboSpan" id="kobo.408.2">Node.js has some rules to decide what is a valid name and what </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.409.1">is not.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.410.1">For now, it is sufficient to know that valid names can be formed with lowercase letters and dashes. </span><span class="koboSpan" id="kobo.410.2">Since package names may appear in URLs, a package name is not allowed to contain any </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.411.1">non-URL-safe characters.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.412.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.413.1">version</span></strong><span class="koboSpan" id="kobo.414.1"> field has to follow the specification for </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.415.1">semantic versioning</span></strong><span class="koboSpan" id="kobo.416.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.417.1">semver</span></strong><span class="koboSpan" id="kobo.418.1">). </span><span class="koboSpan" id="kobo.418.2">The</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.419.1"> GitHub repository at </span><a href="https://github.com/npm/node-semver"><span class="koboSpan" id="kobo.420.1">https://github.com/npm/node-semver</span></a><span class="koboSpan" id="kobo.421.1"> contains the Node.js implementation </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.422.1">and many examples for valid versions. </span><span class="koboSpan" id="kobo.422.2">Even more important is that semver also allows you to select a matching version using a range notation, which is useful </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.423.1">for dependencies.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.424.1">Semver</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.425.1">Besides the rules and constraints for version identifiers, the concept of semver is used to clearly communicate the impact of changes to package users when updating dependencies. </span><span class="koboSpan" id="kobo.425.2">According to semver, the three parts of a version (X.Y.Z – for example, 1.2.3) all serve a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.426.1">different purpose.</span></span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.427.1">The leading number (X) is the major version, which indicates the compatibility level. </span><span class="koboSpan" id="kobo.427.2">The middle number (Y) is the minor version, which indicates the feature level. </span><span class="koboSpan" id="kobo.427.3">Finally, the last number (Z) is the patch level, which is useful for hotfixes. </span><span class="koboSpan" id="kobo.427.4">Generally, patch-level changes should always be applied, while feature-level changes are optional. </span><span class="koboSpan" id="kobo.427.5">Compatibility-level changes should never be applied automatically, as they usually involve </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.428.1">some refactoring.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.429.1">By default, if the same directory contains an </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.430.1">index.js</span></strong><span class="koboSpan" id="kobo.431.1"> file, then this is considered the </span><em class="italic" lang=""><span class="koboSpan" id="kobo.432.1">main</span></em><span class="koboSpan" id="kobo.433.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.434.1">root</span></em><span class="koboSpan" id="kobo.435.1">, or </span><em class="italic" lang=""><span class="koboSpan" id="kobo.436.1">entry</span></em><span class="koboSpan" id="kobo.437.1"> module of the package. </span><span class="koboSpan" id="kobo.437.2">Alternatively, we can specify the main module of a package using the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.438.1">main</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.439.1"> field.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.440.1">To change the location of the main module of the package to an </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.441.1">app.js</span></strong><span class="koboSpan" id="kobo.442.1"> file located within the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.443.1">lib</span></strong><span class="koboSpan" id="kobo.444.1"> subdirectory, we can write </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.445.1">the following:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.446.1">package.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.447.1">{
  "name": "my-package",
  "version": "1.0.0",
  "main": "./lib/app.js"
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.448.1">Furthermore, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.449.1">package.json</span></strong><span class="koboSpan" id="kobo.450.1"> can be used to include some metadata about the package itself. </span><span class="koboSpan" id="kobo.450.2">This can be very helpful for users of the package. </span><span class="koboSpan" id="kobo.450.3">Sometimes, this metadata is also used in tooling – for example, to automatically open the website of the package or</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.451.1"> the issue tracker or show other packages from the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.452.1">same author.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.453.1">Among the most useful metadata, we have </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.454.1">the following:</span></span></p>
<ul>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.455.1">description</span></strong><span class="koboSpan" id="kobo.456.1">: A description of the package, which will be shown on websites that list </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.457.1">the package.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.458.1">license</span></strong><span class="koboSpan" id="kobo.459.1">: A license using a </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.460.1">valid </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.461.1">Software Package Data Exchange</span></strong><span class="koboSpan" id="kobo.462.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.463.1">SPDX</span></strong><span class="koboSpan" id="kobo.464.1">) identifier such as </span><em class="italic" lang=""><span class="koboSpan" id="kobo.465.1">MIT</span></em><span class="koboSpan" id="kobo.466.1"> or </span><em class="italic" lang=""><span class="koboSpan" id="kobo.467.1">BSD-2</span></em><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">License expressions such as (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.469.1">ISC OR GPL-3.0</span></strong><span class="koboSpan" id="kobo.470.1">) are also possible. </span><span class="koboSpan" id="kobo.470.2">These will be shown on websites that list </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.471.1">the package.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.472.1">author</span></strong><span class="koboSpan" id="kobo.473.1">: Either a simple string or an object containing information about the author (for example, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.474.1">name</span></strong><span class="koboSpan" id="kobo.475.1">, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.476.1">email</span></strong><span class="koboSpan" id="kobo.477.1">, or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.478.1">url</span></strong><span class="koboSpan" id="kobo.479.1">). </span><span class="koboSpan" id="kobo.479.2">Will be shown on websites that list </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.480.1">the package.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.481.1">contributors</span></strong><span class="koboSpan" id="kobo.482.1">: Essentially, an array of authors or people who contributed in one way or another to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.483.1">the package.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.484.1">repository</span></strong><span class="koboSpan" id="kobo.485.1">: An object with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.486.1">url</span></strong><span class="koboSpan" id="kobo.487.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.488.1">type</span></strong><span class="koboSpan" id="kobo.489.1"> (for example, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.490.1">git</span></strong><span class="koboSpan" id="kobo.491.1">) of the code repository – that is, where the source code of the package is stored </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.492.1">and maintained.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.493.1">bugs</span></strong><span class="koboSpan" id="kobo.494.1">: The URL of an issue tracker that can be used to report issues and make </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.495.1">feature requests.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.496.1">keywords</span></strong><span class="koboSpan" id="kobo.497.1">: An array of words that can be used to categorize the package. </span><span class="koboSpan" id="kobo.497.2">This is very useful for finding packages and is the main source of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.498.1">search engines.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.499.1">homepage</span></strong><span class="koboSpan" id="kobo.500.1">: The URL of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.501.1">package’s website.</span></span></li>
<li lang="en-GB"><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.502.1">funding</span></strong><span class="koboSpan" id="kobo.503.1">: An object with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.504.1">url</span></strong><span class="koboSpan" id="kobo.505.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.506.1">type</span></strong><span class="koboSpan" id="kobo.507.1"> (for example, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.508.1">patreon</span></strong><span class="koboSpan" id="kobo.509.1">) of the package’s financial support platform. </span><span class="koboSpan" id="kobo.509.2">This object is also integrated into tooling and websites showing </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.510.1">the package.</span></span></li>
</ul>
<p lang="en-GB"><span class="koboSpan" id="kobo.511.1">There are a couple more fields that are necessary to specify when dealing with third-party packages. </span><span class="koboSpan" id="kobo.511.2">We’ll cover those in </span><a href="B18989_03.xhtml#_idTextAnchor033"><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.512.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.513.1">, </span><em class="italic" lang=""><span class="koboSpan" id="kobo.514.1">Choosing a Package Manager</span></em><span class="koboSpan" id="kobo.515.1">, when we discuss package managers in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.516.1">great detail.</span></span></p>
<h1 id="_idParaDest-33" lang="en-GB"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.517.1">Summary</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.518.1">In this chapter, you learned about a set of different module formats as alternatives to the CommonJS module format. </span><span class="koboSpan" id="kobo.518.2">You have been introduced to the current standard approach of writing ESMs, which brings a module system directly to the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.519.1">JavaScript language.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.520.1">You also saw how alternative module formats such as AMD or UMD can be used to run JavaScript modules on other older JavaScript runtimes. </span><span class="koboSpan" id="kobo.520.2">We discussed that by using the specialized module loader, SystemJS, you can actually make use of truly convenient and current features as a web standard today. </span><span class="koboSpan" id="kobo.520.3">The need for import maps is particularly striking when talking about </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.521.1">third-party dependencies.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.522.1">You learned that most third-party dependencies are actually deployed in the form of packages. </span><span class="koboSpan" id="kobo.522.2">In this chapter, you also saw how a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.523.1">package.json</span></strong><span class="koboSpan" id="kobo.524.1"> file defines the root of a package and what kind of data may be included in </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.525.1">package.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.526.1"> file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.527.1">In the next chapter, we will learn how packages using the discussed formats can be installed and managed by using special applications called package managers. </span><span class="koboSpan" id="kobo.527.2">We’ll see how these package managers operate under the hood and how we can use them to improve our </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.528.1">development experience.</span></span></p>
</div>
</body></html>