<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-25" lang="en-GB"><a id="_idTextAnchor023"/>2</h1>
<h1 id="_idParaDest-26" lang="en-GB"><a id="_idTextAnchor024"/>Dividing Code into Modules and Packages</h1>
<p lang="en-GB">One of the most important aspects to consider when writing professional software is reusability. Reusability means that parts of our code base can be purposed to work in several places or under different circumstances. This implies that we can actually use existing functionality quite easily.</p>
<p lang="en-GB">As we learned, a key part of the Node.js success story is down to the fact that it comes with a module system. So far, we’ve only touched upon the basic concept of CommonJS, which is the default way of importing and exporting functionality from modules.</p>
<p lang="en-GB">In this chapter, we’ll take the chance to become familiar with more module formats, including their history, use cases, and development models. We’ll learn how to divide our code into modules and packages efficiently. In addition to learning about CommonJS, we will see what a package is and how we can define our own packages. All in all, this will help us to achieve great reusability – not only for our tooling in Node.js but also for our applications running in the browser.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Using the ESM standard</li>
<li lang="en-GB">Learning the AMD specification</li>
<li lang="en-GB">Being universal with UMD</li>
<li lang="en-GB">Understanding SystemJS and import maps</li>
<li lang="en-GB">Knowing the <code>package.json</code> fundamentals</li>
</ul>
<h1 id="_idParaDest-27" lang="en-GB"><a id="_idTextAnchor025"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter02</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="http://bit.ly/3FZ6ivk">http://bit.ly/3FZ6ivk</a>.</p>
<h1 id="_idParaDest-28" lang="en-GB"><a id="_idTextAnchor026"/>Using the ESM standard</h1>
<p lang="en-GB">CommonJS has <a id="_idIndexMarker048"/>been a good solution for Node.js, but not a desirable solution for JavaScript as a language. For instance, in the browser, CommonJS does not work. Doing synchronous imports on URLs is just not possible. The module resolution of CommonJS was also way too flexible in terms of adding extensions and trying directories.</p>
<p lang="en-GB">To standardize modules in JavaScript, the <code>require</code>, the whole module system relies on language constructs using reserved words. This way, the module system can be brought over to the browser, too.</p>
<p lang="en-GB">The ECMAScript standard specified two keywords for this:</p>
<ul>
<li lang="en-GB"><code>import</code>: Used to import functionality from other modules</li>
<li lang="en-GB"><code>export</code>: Used to declare the functionality that can be imported into other modules</li>
</ul>
<p lang="en-GB">The <code>import</code> keyword must appear at the beginning of a file – before any other code. The reason for this choice lies in the demand for ESM files to be used not only within Node.js, but also in the browser. By placing the <code>import</code> statements on top, each ESM file can safely wait until all the imports have been resolved.</p>
<p lang="en-GB">Rewriting the example from the previous chapter, we get the following for <code>a.js</code>:</p>
<pre class="source-code" lang="en-GB">import * as b from './b.js'; // get all things from b.js
// use imports
console.log('The value of b is:', b.myValue);</pre>
<p lang="en-GB">The rewrite of the <code>b.js</code> file to be valid per the ESM standard is as follows:</p>
<pre class="source-code" lang="en-GB">export const myValue = 42;</pre>
<p lang="en-GB">There are multiple possibilities with the <code>import</code> keyword. We can use the following:</p>
<ul>
<li lang="en-GB">Wildcard (using <code>*</code>) imports with a name selected by the developer</li>
<li lang="en-GB">Named imports such as <code>myValue</code></li>
<li lang="en-GB">Default imports with a name selected by the developer</li>
<li lang="en-GB">An empty import that does not get anything, but makes sure to run the module</li>
</ul>
<p lang="en-GB">Using a named import, we can get a cleaner version of <code>a.js</code>:</p>
<pre class="source-code" lang="en-GB">// get only selected things
import { myValue } from './b.js';
console.log('The value of b is:', myValue); // use imports</pre>
<p lang="en-GB">The<a id="_idIndexMarker049"/> preceding code is very similar to the destructuring assignment, which decomposes an object into its fields using the assignment operator (<code>=</code>). There are crucial differences, however. One of these differences is how to make aliases.</p>
<p lang="en-GB">For instance, when using a destructuring assignment, we can use the colon (<code>:</code>) to rename the variables, which would have the name of the respective fields by default. If we wanted to give the variable a different name (e.g., <code>otherValue</code>) from its original field (e.g., <code>myValue</code>), we’d have to write the following:</p>
<pre class="source-code" lang="en-GB">// gets all the things, but only uses myValue
const { myValue: otherValue } = require('./b.js');</pre>
<p lang="en-GB">With an <code>import</code> statement, you need to use the <code>as</code> keyword to achieve this:</p>
<pre class="source-code" lang="en-GB">// gets only myValue – but renames it
import { myValue as otherValue } from './b.js';</pre>
<p lang="en-GB">A topic that becomes relevant quite quickly is the notion of a default export. Especially when handling exports from an unknown module, there is a great need to define the export name. In CommonJS, developers therefore picked the whole module; however, this is no longer possible with ESM. Every export needs to be named.</p>
<p lang="en-GB">Luckily, the standardization committee thought about the topic of default exports. An export is considered to be a default export if it uses the <code>default</code> keyword. For instance, changing the export in <code>b.js</code> to use default values could look as follows:</p>
<pre class="source-code" lang="en-GB">export default 42;</pre>
<p lang="en-GB">Importing<a id="_idIndexMarker050"/> the default export is quite convenient, too. Here, we are free to select a name to refer to the default export within our module. Instead of being able to rename the import, we are forced to give it a name:</p>
<pre class="source-code" lang="en-GB">import otherValue from './b.js'; // gets only default
console.log('The value of b is:', otherValue);</pre>
<p lang="en-GB">The whole idea is to use default exports as much as possible. In the end, modules that are effectively written to revolve around exporting a single functionality are often considered the goal.</p>
<p lang="en-GB">We’ve already learned that CommonJS does not work in the browser. In contrast, the modern ESM specification is supposed to work, as imports are declared in the beginning. This modification allows the browser to safely suspend module evaluation until the imports are fully processed. This kind of suspension to wait for the dependencies to finish loading was actually taken from another attempt at a module system<a id="_idIndexMarker051"/> called <strong class="bold" lang="">Asynchronous Module </strong><strong class="bold" lang="">Definition</strong> (<strong class="bold" lang="">AMD</strong>).</p>
<h1 id="_idParaDest-29" lang="en-GB"><a id="_idTextAnchor027"/>Learning the AMD specification</h1>
<p lang="en-GB">Before<a id="_idIndexMarker052"/> ESM was established, people tried to make modules work in the browser, too. One of the earliest attempts was a small library <a id="_idIndexMarker053"/>called <code>&lt;head&gt;</code> of a document. The script would then load and run a defined root module, which would process even more modules.</p>
<p lang="en-GB">An example<a id="_idIndexMarker054"/> website using RequireJS is as follows:</p>
<pre class="source-code" lang="en-GB">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My Sample Project&lt;/title&gt;
    &lt;!--
      data-main attribute tells RequireJS to load
      ./main.js after ./require.js has been loaded
    --&gt;
    &lt;script data-main="./main" src="img/require.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</pre>
<p lang="en-GB">RequireJS was<a id="_idIndexMarker055"/> born at a time when promises had not yet been established in the JavaScript world. Therefore, the module loader was based on the next best thing: callbacks. Consequently, a module is loaded by calling a <code>requirejs</code> function defined by RequireJS. The whole process can then start loading modules asynchronously as shown in <em class="italic" lang="">Figure 2</em><em class="italic" lang="">.1</em>:</p>
<div><div><img alt="Figure 2.1 – Loading modules sequentially vs. asynchronously " src="img/Figure_2.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Loading modules sequentially vs. asynchronously</p>
<p lang="en-GB">To achieve asynchronous module loading, the <code>requirejs</code> function takes two arguments. The first argument is an array with all the dependencies. The second argument is a callback that receives the exports of the dependencies and returns the exports of the current module.</p>
<p lang="en-GB">The<a id="_idIndexMarker056"/> whole idea behind RequireJS is very similar to that of ESM today, which shifts the two parts (loading the dependencies and the code that uses the dependencies) into the same module – but still distinguishes between the <code>import</code> statements and all the other statements. Here, ESM leverages the fact that it’s actually a language construct.</p>
<p lang="en-GB">In short, a module that uses RequireJS looks as follows:</p>
<pre class="source-code" lang="en-GB">requirejs(['./helper/util'], (util) =&gt; {
  // This is called when ./helper/util.js. has been processed
});</pre>
<p lang="en-GB">The shape of these modules was not arbitrarily decided. Instead, the RequireJS library is merely one implementation of a specification for an asynchronous module system. This specification is called AMD.</p>
<p lang="en-GB">Using AMD, the previous RequireJS-specific example could be rewritten as follows:</p>
<pre class="source-code" lang="en-GB">define(['./helper/util'], (util) =&gt; {
  // This is called when ./helper/util.js. has been processed
});</pre>
<p lang="en-GB">In addition to the two-argument variant of the <code>define</code> function, there is also a three-argument version, where the first argument helps to name the defined module.</p>
<p lang="en-GB">An example of the three-argument call to <code>define</code> is shown here:</p>
<pre class="source-code" lang="en-GB">define('myModule', ['dep1', 'dep2'], (dep1, dep2) =&gt; {
  // Define the module exports by returning a value.
  return {};
});</pre>
<p lang="en-GB">Now, the only thing left before we can use AMD universally is to learn how we can integrate it into Node.js. First, we need to grab <code>r.js</code> from the official download page: <a href="https://requirejs.org/docs/download.html#rjs">https://requirejs.org/docs/download.html#rjs</a>. Download it via the <strong class="bold" lang="">Download</strong> button as shown in <em class="italic" lang="">Figure 2</em><em class="italic" lang="">.2</em>:</p>
<div><div><img alt="Figure 2.2 – The Download button for r.js on the RequireJS website " src="img/Figure_2.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The Download button for r.js on the RequireJS website</p>
<p lang="en-GB">Store the<a id="_idIndexMarker057"/> downloaded file in the directory where you have placed the scripts to run via <code>node</code>. Create a new <code>a.js</code> script in the same <a id="_idIndexMarker058"/>directory:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">a.js</p>
<pre class="source-code" lang="en-GB">const define = require('./r.js'); // gets the loader
define.config({
  // Will also correctly resolve other Node.js dependencies
  nodeRequire: require
});
define(['./b'], (b) =&gt; {
  console.log('The value of b is:', b.myValue);
});</pre>
<p lang="en-GB">The code here does not look so different from the CommonJS example. After all, only the initialization of the RequireJS loader has been added. The actual content of the module<a id="_idIndexMarker059"/> is now part of the callback.</p>
<p lang="en-GB">Let’s see what the<a id="_idIndexMarker060"/> transformed <code>b.js</code> looks like:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">b.js</p>
<pre class="source-code" lang="en-GB">const define = require('./r.js'); // gets the loader
define.config({
  // Will also correctly resolve other Node.js dependencies
  nodeRequire: require
});
define([], () =&gt; {
  return {
    myValue: 42,
  };
});</pre>
<p lang="en-GB">In the preceding code for <code>b.js</code>, again, we have added the same envelope, just as in <code>a.js</code>. Remember that each module needs to be treated as standalone code. While how explicit this is may seem rather redundant, the real advantage becomes obvious once it’s used with an unknown number of other modules. In this case, we never know what has been loaded or used already. Being independent means being predictable in these scenarios.</p>
<p lang="en-GB">The problem with the preceding approach is that while this works in Node.js, it certainly does not work in the browser. Even though we’ve chosen AMD for this specific reason, we failed to make it work in the browser. The problem lies in the initial call to <code>require</code>, which uses CommonJS to obtain the AMD loader.</p>
<p lang="en-GB">To mitigate the problem and use AMD in different<a id="_idIndexMarker061"/> JavaScript environments, the <strong class="bold" lang="">Universal Module Definition</strong> (<strong class="bold" lang="">UMD</strong>) specification was created.</p>
<h1 id="_idParaDest-30" lang="en-GB"><a id="_idTextAnchor028"/>Being universal with UMD</h1>
<p lang="en-GB">When the <a id="_idIndexMarker062"/>UMD specification was brought up, there was a lot of hype in the community. After all, the label <em class="italic" lang="">universal</em> already claims that UMD is the final module system – the one to rule them all. It tries to do this by supporting essentially three different kinds of JavaScript module formats:</p>
<ul>
<li lang="en-GB">The classic way of doing things without a module system – that is, just by running JavaScript using <code>&lt;script&gt;</code> tags in the browser</li>
<li lang="en-GB">The CommonJS format that is used by Node.js</li>
<li lang="en-GB">The previously discussed asynchronously loaded modules from the AMD specification</li>
</ul>
<p lang="en-GB">When you write a JavaScript file with the UMD specification in mind, you essentially make sure that every popular JavaScript runtime can read it. For instance, UMD works perfectly in Node.js and the browser.</p>
<p lang="en-GB">To achieve this universality, UMD makes an educated guess regarding what module system can be used and selects it. For example, if a <code>define</code> function is detected, then AMD might be used. Alternatively, detecting something such as <code>exports</code> or <code>module</code> hints towards CommonJS. If nothing is found, then the assumption is that the module runs in the browser without AMD present. In this case, the exports of the module would be stored globally.</p>
<p lang="en-GB">The main target group for UMD is library authors. When you build a library, you want it to be useful. Consequently, you’ll also need to make sure that the library can be used. By providing your library in the UMD format, you ensure that it can be used on pretty much all platforms – in Node.js and the browser.</p>
<p lang="en-GB">So, how would our code from<a id="_idIndexMarker063"/> the previous example look if we used UMD as the format of choice? Let’s have a look:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">a.js</p>
<pre class="source-code" lang="en-GB">((root, factory) =&gt; { // context and export callback
  if (typeof define === 'function' &amp;&amp; define.amd) {
    // there is a define function that follows AMD – use it
    define(['b'], factory);
  } else if (typeof exports === 'object' &amp;&amp; typeof module
    !== 'undefined') {
    // there is module and exports: CommonJS
    factory(require('b'));
  } else {
    // we just take the global context
    factory(root.b);
  }
})(typeof self !== 'undefined' ? self : this, (b) =&gt; {
  // this is the body of the module, follows AMD
  console.log('The value of b is:', b.myValue);
});</pre>
<p lang="en-GB">As before, the <a id="_idIndexMarker064"/>preceding code consists of two sections. The first section establishes the module system and sets up the callback. The second section puts the actual content of our module into the callback.</p>
<p lang="en-GB">The only thing left is to see how we can mark our exports with UMD. For this part, we will look at <code>b.js</code> in<a id="_idIndexMarker065"/> the UMD format:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">b.js</p>
<pre class="source-code" lang="en-GB">((root, factory) =&gt; {
  if (typeof define === 'function' &amp;&amp; define.amd) {
    // in AMD we depend on the special "exports" dependency
    define(['exports'], factory);
  } else if (typeof exports === 'object' &amp;&amp; typeof module
    !== 'undefined') {
    // in CommonJS we'll forward the exports
    factory(exports);
  } else {
    // for scripts we define a new global and forward it
    factory(root.b = {});
  }
})(typeof self !== 'undefined' ? self : this, (exports) =&gt;
{
  // use the CommonJS format in here
  exports.myValue = 42;
});</pre>
<p lang="en-GB">With all<a id="_idIndexMarker066"/> the boilerplate code in place, the <a id="_idIndexMarker067"/>script is universal. The defined callback (named <code>factory</code> in the two examples in this section) is either called indirectly from the AMD runtime or directly in the other two cases.</p>
<p lang="en-GB">Usually, we will not write the whole boilerplate code shown here ourselves. The boilerplate will be generated by tooling, which we will look into in <a href="B18989_06.xhtml#_idTextAnchor057"><em class="italic" lang="">Chapter 6</em></a>, <em class="italic" lang="">Building Web Apps with Bundlers</em>. Instead, the ideal option for writing modules in many cases is ESM. Since it’s syntax-based, we follow the language’s standard. The other formats can then be used by our tooling as output formats.</p>
<p lang="en-GB">One more module format to have a closer <a id="_idIndexMarker068"/>look at is SystemJS. One of the reasons why SystemJS is interesting is that it brings support for import maps, which can simplify dealing with module systems.</p>
<h1 id="_idParaDest-31" lang="en-GB"><a id="_idTextAnchor029"/>Understanding SystemJS and import maps</h1>
<p lang="en-GB">Earlier in this chapter, we<a id="_idIndexMarker069"/> learned that ESM is arguably the best module system for JavaScript. After all, it is integrated into the JavaScript language. One of the reasons why other formats are still relevant today is backward compatibility.</p>
<p lang="en-GB">Backward compatibility allows formats such as AMD or UMD to be used in older JavaScript runtimes, such as older versions of browsers such as Internet Explorer, but even if we don’t need backward compatibility, the alternative formats still have one or more advantages over ESM.</p>
<p lang="en-GB">One of the core problems with ESM is that it does not define how modules are resolved. In fact, the only specified way to resolve a module is explicitly via the filesystem. When we used ESM, we explicitly stated our module imports, such as in <code>./b.js</code>. As mentioned, we are not allowed to implicitly use something such as <code>./b</code> or even just <code>b</code>.</p>
<p lang="en-GB">When doing frontend development, the notion of dependencies has become quite elementary. From boilerplate libraries to UI frameworks, frontend developers make use of a wide array of given code. That code is usually packaged into libraries and then installed locally for development purposes, but how should these dependencies be used?</p>
<p lang="en-GB">Turns out that Node.js solved this problem already in the early stages of its development. We have seen that using CommonJS we are able to write code such as the <a id="_idIndexMarker070"/>following:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">host-cjs.js</p>
<pre class="source-code" lang="en-GB">const os = require('os');
console.log('The current hostname is:', os.hostname());</pre>
<p lang="en-GB">The reference to <code>os</code> is resolved by Node.js through CommonJS. In this special case, the reference leads to one framework library of Node.js. However, it could also lead to a third-party dependency that has been installed <a id="_idTextAnchor030"/>by us. In <a href="B18989_03.xhtml#_idTextAnchor033"><em class="italic" lang="">Chapter 3</em></a>, <em class="italic" lang="">Choosing a Package Manager</em>, we will see how this works.</p>
<p lang="en-GB">Let’s translate the preceding<a id="_idIndexMarker071"/> code into ESM:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">host-esm.js</p>
<pre class="source-code" lang="en-GB">import { hostname } from 'node:os';
console.log('The current hostname is:', hostname());</pre>
<p lang="en-GB">The<a id="_idIndexMarker072"/> conversion of the little snippet is not very complicated, with the exception of the module name. Previously, we used <code>os</code> as an identifier. Node.js has chosen to also allow this for backward compatibility – at least for now. The preferred way, however, is to use a custom protocol. In the case of Node.js framework libraries, the <code>node:</code> protocol has been chosen.</p>
<p lang="en-GB">Leveraging custom protocols to resolve dependencies is possible in the browser. However, it is also cumbersome. After all, the whole resolution would now need to be done by us. This also represents a classic chicken-egg problem. To define custom protocols, we need to have some JavaScript running; however, if this piece of JavaScript relies on third-party dependencies that are actually resolved via the custom protocol, then we cannot successfully implement the resolution of dependencies.</p>
<p lang="en-GB">One way that we can still use convenient references such as <code>os</code> is to define a so-called import map. An import map helps the browser map module names to actual URLs. It uses <code>imports</code> field.</p>
<p lang="en-GB">The following is an<a id="_idIndexMarker074"/> import map to find an implementation of the <code>os</code> module:</p>
<pre class="source-code" lang="en-GB">{
  "imports": {
    "os": "https://example.com/js/os.min.js"
  }
}</pre>
<p lang="en-GB">The URLs don’t have to be fully qualified. In the case of relative URLs, the module’s URL is computed from the base URL of the import map.</p>
<p lang="en-GB">The integration of import maps into a website is relatively simple. All we need to do is to specify a <code>&lt;script&gt;</code> tag with the type being <code>importmap</code>:</p>
<pre class="source-code" lang="en-GB">&lt;script type="importmap"&gt;
{
  "imports": {
    "os": "https://example.com/js/os.min.js"
  }
}
&lt;/script&gt;</pre>
<p lang="en-GB">In addition, import maps <a id="_idIndexMarker075"/>may be loaded from external files, too. In any case, the specified mapping of module names to URLs only works for <code>import</code> statements. It will not work in other places where a URL is expected. For instance, the following example <a id="_idIndexMarker076"/>does not work:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">fail.html</p>
<pre class="source-code" lang="en-GB">&lt;script type="importmap"&gt;
{
  "imports": {
    "/app.mjs": "/app.8e0d62a03.mjs"
  }
}
&lt;/script&gt;
&lt;script type="module" src="img/app.mjs"&gt;&lt;/script&gt;</pre>
<p lang="en-GB">In the preceding code, we have tried to load <code>/app.mjs</code> directly, which will fail. We need to <a id="_idIndexMarker077"/>use an <code>import</code> statement:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">success.html</p>
<pre class="source-code" lang="en-GB">&lt;script type="importmap"&gt;
{
  "imports": {
    "/app.mjs": "/app.8e0d62a03.mjs"
  }
}
&lt;/script&gt;
&lt;script type="module"&gt;import "/app.mjs";&lt;/script&gt;</pre>
<p lang="en-GB">There is a<a id="_idIndexMarker078"/> lot more that can be written about import maps; however, for now, the most important detail is that they only work partially – that is, without external files, in recent versions of <em class="italic" lang="">Google Chrome</em> (<em class="italic" lang="">89</em> and higher) and <em class="italic" lang="">Microsoft Edge</em> (<em class="italic" lang="">89</em> and higher). In most other browsers, the import map support is either not there or must explicitly be enabled.</p>
<p lang="en-GB">The <a id="_idIndexMarker079"/>alternative is to use <a id="_idIndexMarker080"/>SystemJS. SystemJS is a module loader similar to RequireJS. The main difference is that SystemJS provides support for multiple module systems and module system capabilities, such as using import maps.</p>
<p lang="en-GB">While SystemJS also supports various formats such as ESM, it also comes with its own format. Without going into too much detail, the shape of a native SystemJS module looks as follows:</p>
<pre class="source-code" lang="en-GB">System.register(['dependency'], (_export, _context) =&gt; {
  let dependency;
  return {
    setters: [(_dep) =&gt; {
      dependency = _dep;
    }],
    execute: () =&gt; {
      _export({
        myValue: 42,
      });
    },
  };
});</pre>
<p lang="en-GB">The preceding code is structurally quite similar to the AMD boilerplate, with the only difference being how the callback is structured. While AMD runs the module’s body in the callback, SystemJS specifies <a id="_idIndexMarker081"/>some more sections in the callback. These sections are then run on demand. The real body of a module is defined in the returned <code>execute</code> section.</p>
<p lang="en-GB">As before, the short snippet already illustrates quite nicely that SystemJS modules are rarely written by hand. Instead, they are generated by tooling. We’ll therefore come back to SystemJS once we have more powerful tooling on hand to automate the task of creating valid SystemJS modules.</p>
<p lang="en-GB">Now that we have heard enough about libraries and packages, we also need to know how we can define our own package. To indicate a package, the <code>package.json</code> file has to be used.</p>
<h1 id="_idParaDest-32" lang="en-GB"><a id="_idTextAnchor031"/>Knowing package.json fundamentals</h1>
<p lang="en-GB">The aggregation <a id="_idIndexMarker082"/>of multiple modules forms a package. A package is defined by a <code>package.json</code> file in a directory. This marks the directory as the root of a package. A minimal valid <code>package.json</code> to indicate a package is as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  "name": "my-package",
  "version": "1.0.0"
}</pre>
<p lang="en-GB">Some fields, such as <code>name</code> or <code>version</code>, have special meanings. For instance, the <code>name</code> field is used to give the package a name. Node.js has some rules to decide what is a valid name and what is not.</p>
<p lang="en-GB">For now, it is sufficient to know that valid names can be formed with lowercase letters and dashes. Since package names may appear in URLs, a package name is not allowed to contain any non-URL-safe characters.</p>
<p lang="en-GB">The <code>version</code> field has to follow the specification for <strong class="bold" lang="">semantic versioning</strong> (<strong class="bold" lang="">semver</strong>). The<a id="_idIndexMarker083"/> GitHub repository at <a href="https://github.com/npm/node-semver">https://github.com/npm/node-semver</a> contains the Node.js implementation <a id="_idIndexMarker084"/>and many examples for valid versions. Even more important is that semver also allows you to select a matching version using a range notation, which is useful for dependencies.</p>
<p class="callout-heading" lang="en-GB">Semver</p>
<p class="callout" lang="en-GB">Besides the rules and constraints for version identifiers, the concept of semver is used to clearly communicate the impact of changes to package users when updating dependencies. According to semver, the three parts of a version (X.Y.Z – for example, 1.2.3) all serve a different purpose.</p>
<p class="callout" lang="en-GB">The leading number (X) is the major version, which indicates the compatibility level. The middle number (Y) is the minor version, which indicates the feature level. Finally, the last number (Z) is the patch level, which is useful for hotfixes. Generally, patch-level changes should always be applied, while feature-level changes are optional. Compatibility-level changes should never be applied automatically, as they usually involve some refactoring.</p>
<p lang="en-GB">By default, if the same directory contains an <code>index.js</code> file, then this is considered the <em class="italic" lang="">main</em>, <em class="italic" lang="">root</em>, or <em class="italic" lang="">entry</em> module of the package. Alternatively, we can specify the main module of a package using the <code>main</code> field.</p>
<p lang="en-GB">To change the location of the main module of the package to an <code>app.js</code> file located within the <code>lib</code> subdirectory, we can write the following:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  "name": "my-package",
  "version": "1.0.0",
  "main": "./lib/app.js"
}</pre>
<p lang="en-GB">Furthermore, the <code>package.json</code> can be used to include some metadata about the package itself. This can be very helpful for users of the package. Sometimes, this metadata is also used in tooling – for example, to automatically open the website of the package or<a id="_idIndexMarker085"/> the issue tracker or show other packages from the same author.</p>
<p lang="en-GB">Among the most useful metadata, we have the following:</p>
<ul>
<li lang="en-GB"><code>description</code>: A description of the package, which will be shown on websites that list the package.</li>
<li lang="en-GB"><code>license</code>: A license using a <a id="_idIndexMarker086"/>valid <code>ISC OR GPL-3.0</code>) are also possible. These will be shown on websites that list the package.</li>
<li lang="en-GB"><code>author</code>: Either a simple string or an object containing information about the author (for example, <code>name</code>, <code>email</code>, or <code>url</code>). Will be shown on websites that list the package.</li>
<li lang="en-GB"><code>contributors</code>: Essentially, an array of authors or people who contributed in one way or another to the package.</li>
<li lang="en-GB"><code>repository</code>: An object with the <code>url</code> and <code>type</code> (for example, <code>git</code>) of the code repository – that is, where the source code of the package is stored and maintained.</li>
<li lang="en-GB"><code>bugs</code>: The URL of an issue tracker that can be used to report issues and make feature requests.</li>
<li lang="en-GB"><code>keywords</code>: An array of words that can be used to categorize the package. This is very useful for finding packages and is the main source of search engines.</li>
<li lang="en-GB"><code>homepage</code>: The URL of the package’s website.</li>
<li lang="en-GB"><code>funding</code>: An object with the <code>url</code> and <code>type</code> (for example, <code>patreon</code>) of the package’s financial support platform. This object is also integrated into tooling and websites showing the package.</li>
</ul>
<p lang="en-GB">There are a couple more fields that are necessary to specify when dealing with third-party packages. We’ll cover those in <a href="B18989_03.xhtml#_idTextAnchor033"><em class="italic" lang="">Chapter 3</em></a>, <em class="italic" lang="">Choosing a Package Manager</em>, when we discuss package managers in great detail.</p>
<h1 id="_idParaDest-33" lang="en-GB"><a id="_idTextAnchor032"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned about a set of different module formats as alternatives to the CommonJS module format. You have been introduced to the current standard approach of writing ESMs, which brings a module system directly to the JavaScript language.</p>
<p lang="en-GB">You also saw how alternative module formats such as AMD or UMD can be used to run JavaScript modules on other older JavaScript runtimes. We discussed that by using the specialized module loader, SystemJS, you can actually make use of truly convenient and current features as a web standard today. The need for import maps is particularly striking when talking about third-party dependencies.</p>
<p lang="en-GB">You learned that most third-party dependencies are actually deployed in the form of packages. In this chapter, you also saw how a <code>package.json</code> file defines the root of a package and what kind of data may be included in <code>package.json</code> file.</p>
<p lang="en-GB">In the next chapter, we will learn how packages using the discussed formats can be installed and managed by using special applications called package managers. We’ll see how these package managers operate under the hood and how we can use them to improve our development experience.</p>
</div>
</body></html>