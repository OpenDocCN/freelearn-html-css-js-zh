<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;A JavaScript Primer" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. A JavaScript Primer</h1></div></div></div><p>It's important to have a solid understanding of JavaScript to write Node.js applications. JavaScript is not a large or complex language, but it may seem unusual, and has a few quirks and gotchas to watch out for.</p><p>The recent release of ECMAScript 2015 (previously named ES6) introduces a number of new language features to make JavaScript programming easier and safer. Not all ES2015 features are available in all implementations yet. However, all the ES2015 features we'll mention in this chapter are available in Node.js and in most other JavaScript environments.</p><p>In this chapter, we'll familiarize ourselves with JavaScript so we can write Node.js applications with confidence. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The JavaScript type system</li><li class="listitem">JavaScript as a functional programming language</li><li class="listitem">Object-oriented programming in JavaScript</li><li class="listitem">JavaScript's prototype-based inheritance</li></ul></div><div class="section" title="Introducing JavaScript types"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Introducing JavaScript types</h1></div></div></div><p>JavaScript is a<a id="id82" class="indexterm"/> dynamically-typed language. These means that types are checked at runtime when you try to do something with a variable, rather than by a compiler. For example, the following is valid JavaScript code:</p><div class="informalexample"><pre class="programlisting">var myVariable = 0; 
console.log(typeof myVariable); // Prints "number"
myVariable = "1";
console.log(typeof myVariable); // Prints "string"</pre></div><p>Although variables do have a type, this may change throughout the lifetime of the variable.</p><p>JavaScript also tries to implicitly convert types where possible, for example, using the equality operator:</p><div class="informalexample"><pre class="programlisting">console.log(2 == "2"); // Prints "true"</pre></div><p>Although this <a id="id83" class="indexterm"/>might make sense for frontend JavaScript (for example comparing against the value of a form input), in general, it is more likely to be a source of errors or confusion. For this reason, it is recommended to always use the strict equality and inequality operators:</p><div class="informalexample"><pre class="programlisting">console.log(2 === "2"); // Prints "false"
console.log(2 !== "2"); // Prints "true"</pre></div><div class="section" title="JavaScript primitive types"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>JavaScript primitive types</h2></div></div></div><p>JavaScript has a <a id="id84" class="indexterm"/>small number of primitive types, similar to <a id="id85" class="indexterm"/>C# and Java. These are string, number, and Boolean, as well as the special single-valued types, null and undefined. ES2015 also adds the symbol type, but we won't cover it here as its use cases are more advanced.</p><p>
<span class="strong"><strong>Strings</strong></span><a id="id86" class="indexterm"/> are immutable, like in C# and Java. Concatenating strings creates a new string instance. String literals can be defined with double quotes (as in C# or Java) or single quotes. These can be used interchangeably (usually whatever is easier to avoid escaping).</p><p>ES2015 also introduces support for template strings, which are defined using backticks and can include interpolated expressions.</p><p>Here are several ways to define the same string:</p><div class="informalexample"><pre class="programlisting">var singleQuoted = '"Hey", I said, "I\'m a string"';
var doubleQuoted = "\"Hey\", I said, \"I'm a string\"";
console.log(doubleQuoted === singleQuoted); // Prints "true"

var expression = 'Hey';
var templated = `"${expression}", I said, "I'm a string"`;
console.log(templated === singleQuoted); // Prints "true"</pre></div><p>
<span class="strong"><strong>Number</strong></span> is<a id="id87" class="indexterm"/> JavaScript's only built-in numeric type. It is a double-precision 64-bit floating-point number, like <code class="literal">double</code> in C# or Java. It has special values <code class="literal">NaN</code> (not a number) and <code class="literal">Infinity</code> for values that cannot be represented otherwise:</p><div class="informalexample"><pre class="programlisting">console.log(1 / 0); // Prints "Infinity"
console.log(Infinity + 1); // Prints "Infinity" 
console.log((1 / 0) === (2 / 0)); // Prints "true"

var notANumber = parseInt("foo");
console.log(notANumber); // Prints "NaN"
console.log(notANumber === NaN); // Prints "false"
console.log(isNaN(notANumber)); // Prints "true"</pre></div><div class="note" title="Note"><h3 class="title"><a id="note04"/>Note</h3><p>Note that although there is only a single <code class="literal">NaN</code> value, it is not treated as equal to itself. JavaScript provides the special <code class="literal">isNaN</code> function for testing whether a variable contains the <code class="literal">NaN</code> value.</p></div><p>The <span class="strong"><strong>null</strong></span> type<a id="id88" class="indexterm"/> has a single instance, represented by the literal <code class="literal">null</code>, just as in C# or Java. JavaScript<a id="id89" class="indexterm"/> also has the <span class="strong"><strong>undefined</strong></span> type. Variables or parameters that have never been assigned will have the value <code class="literal">undefined</code>:</p><div class="informalexample"><pre class="programlisting">var declared;
console.log(typeof declared); // Prints "undefined"
console.log(declared === undefined); // Prints "true"

console.log(typeof undeclared); // Prints "undefined"
console.log(undeclared === undefined); // throws ReferenceError</pre></div><p>Note that<a id="id90" class="indexterm"/> our <code class="literal">undeclared</code> identifier cannot be accessed as a variable in <a id="id91" class="indexterm"/>normal code because it has not been declared. However, we can pass it to the <code class="literal">typeof</code> operator, which evaluates to the undefined type.</p></div></div></div>
<div class="section" title="Functional object-oriented programming"><div class="titlepage" id="aid-LTSU2"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Functional object-oriented programming</h1></div></div></div><p>JavaScript is a<a id="id92" class="indexterm"/> functional object-oriented programming language. However, it is quite different to other object-oriented programming languages such as C# or Java. Despite having a similar syntax, there are some important differences.</p><div class="section" title="Functional programming in JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Functional programming in JavaScript</h2></div></div></div><p>In JavaScript, functions <a id="id93" class="indexterm"/>are first-class objects. This means that functions can be treated like any other object: they can be created <a id="id94" class="indexterm"/>dynamically, assigned to variables, or passed into methods as arguments.</p><p>This makes it very easy to specify event callbacks, or to program in a more functional style <a id="id95" class="indexterm"/>using <span class="strong"><strong>higher-order functions</strong></span>. Higher-order functions are functions that take other functions as arguments, and/or return another function. Here's a trivial example of filtering an array of numbers first in an imperative style and then in a functional style. Note that this example also shows JavaScript's <span class="strong"><strong>array literal notation</strong></span><a id="id96" class="indexterm"/> for creating arrays, using square brackets. It also demonstrates JavaScript's conditional construct and one of its loop constructs, which should be familiar from other languages:</p><div class="informalexample"><pre class="programlisting">var numbers = [1,2,3,4,5,6,7,8];

var filteredImperatively = [];
for (var i = 0; i &lt; numbers.length; ++i) {
    var number = numbers[i];
    if (number % 2 === 0) {
        filteredImperatively.push(number);
    }
}
console.log(filteredImperatively); // Prints [2, 4, 6, 8]

var filteredFunctionally =
    numbers.filter(function(x) { return x % 2 === 0; });
console.log(filteredFunctionally); // Prints [2, 4, 6, 8]</pre></div><p>The second<a id="id97" class="indexterm"/> approach in the example<a id="id98" class="indexterm"/> makes use of a function expression to define a new, anonymous function inline. In general, this is referred to as a lambda expression (after lambda calculus in mathematics). This function is passed-in to the built in <code class="literal">filter</code> expression available on JavaScript arrays.</p><p>In C#, assignment and passing of behavior was originally only possible using delegates. Since C# 3.0, support for lambda expressions makes it much easier to use functions in this way. This<a id="id99" class="indexterm"/> allows a more functional style of programming, for example, using C#'s <span class="strong"><strong>Language-Integrated Query</strong></span> (<span class="strong"><strong>LINQ</strong></span>) features.</p><p>In Java, for a long time there was no native way for a function to exist independently. You would have to define a method on a (possibly anonymous) class and pass this around, adding a lot of boilerplate. Java 8 introduces support for lambda expressions in a similar way to C#.</p><p>While C# and Java may have taken a while to catch up, you might be thinking that JavaScript is now falling behind. The syntax for defining a new function in JavaScript is quite clumsy compared to the lambda syntax in C# and Java.</p><p>This is especially unfortunate since JavaScript uses a C-like syntax for familiarity with other languages like Java! This is resolved in ES2015 with <span class="strong"><strong>arrow functions</strong></span>, allowing us to rewrite the previous example as follows:</p><div class="informalexample"><pre class="programlisting">var numbers = [1,2,3,4,5,6,7,8];
<span class="strong"><strong>var filteredFunctionally = numbers.filter(x =&gt; x % 2 === 0);</strong></span>
console.log(filteredFunctionally); // Prints [2, 4, 6, 8]</pre></div><p>This is a simple arrow function with a single argument and a single expression. In this case, the expression is implicitly returned.</p><div class="note" title="Note"><h3 class="title"><a id="note05"/>Note</h3><p>It can be useful to read the <code class="literal">=&gt;</code> notation in arrow functions as <span class="emphasis"><em>goes to</em></span>.</p></div><p>Arrow functions may have multiple (or zero) arguments, in which case they must be surrounded by parentheses. If the function body is enclosed in braces, it may contain multiple statements, in which case there is no implicit return. These are exactly the same syntax rules as for lambda expressions in C#.</p><p>Here is a <a id="id100" class="indexterm"/>more complex arrow <a id="id101" class="indexterm"/>function expression that returns the maximum of its two arguments:</p><div class="informalexample"><pre class="programlisting">var max = (a, b) =&gt; {
    if (a &gt; b) {
        return a;
    } else {
        return b;
    }
};</pre></div></div><div class="section" title="Understanding scopes in JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Understanding scopes in JavaScript</h2></div></div></div><p>Traditionally, in<a id="id102" class="indexterm"/> JavaScript, there are only two possible variable <a id="id103" class="indexterm"/>scopes: global and functional. That is, an identifier (a variable name) is <a id="id104" class="indexterm"/>defined globally, or for an entire function. This can lead to<a id="id105" class="indexterm"/> some surprising behavior, for example:</p><div class="informalexample"><pre class="programlisting">function scopeDemo() {
    for (var i = 0; i &lt; 10; ++i) {
        var j = i * 2;
    }
    console.log(i, j);
}
scopeDemo();</pre></div><p>In most other languages, you would expect <code class="literal">i</code> to exist for the duration of the <code class="literal">for</code> loop, and <code class="literal">j</code> to exist for each loop iteration. You would therefore expect this function to log <code class="literal">undefined undefined</code>. In fact, it logs <code class="literal">10 18</code>. This is because the variables are not scoped to the block of the <code class="literal">for</code> loop, but to the entire function. So the preceding code is equivalent to the following:</p><div class="informalexample"><pre class="programlisting">function scopeDemo() {
    var i, j;
    for (i = 0; i &lt; 10; ++i) {
        j = i * 2;
    }
    console.log(i, j);
}
scopeDemo();</pre></div><p>JavaScript treats all variable declarations as if they were made at the top of the function. This is known <a id="id106" class="indexterm"/>as <span class="strong"><strong>variable hoisting</strong></span>. Although consistent, this can be confusing and lead to subtle bugs.</p><p>ES2015 introduces<a id="id107" class="indexterm"/> the <code class="literal">let</code> keyword for declaring variables. This works exactly the <a id="id108" class="indexterm"/>same as <code class="literal">var</code> except that variables are block-scoped. There is also the <code class="literal">const</code> keyword, which works the same as <code class="literal">let</code> except that it does not allow reassignment. It is recommended that you always use <code class="literal">let</code> rather than <code class="literal">var</code>, and use <code class="literal">const</code> wherever possible. Check the following code for example:</p><div class="informalexample"><pre class="programlisting">function scopeDemo() {
    "use strict";
    for (let i = 0; i &lt; 10; ++i) {
        let j = i * 2;
    }
    console.log(i, j); // Throws ReferenceError: i is not defined
}
scopeDemo();</pre></div><p>Note the <code class="literal">"use strict"</code> string in the preceding example. We'll discuss this in the next section.</p><div class="section" title="Strict mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Strict mode</h3></div></div></div><p>The <code class="literal">"use strict"</code> string is<a id="id109" class="indexterm"/> a hint to the JavaScript interpreter to<a id="id110" class="indexterm"/> enable <span class="strong"><strong>Strict Mode</strong></span>. This makes the language safer by treating certain usages of the language as errors. For example, mistyping a variable name without strict mode will define a new variable at the global level, rather than causing an error.</p><p>Strict mode is also now used by some browsers to enable features in the newest version of JavaScript, such<a id="id111" class="indexterm"/> as <a id="id112" class="indexterm"/>the <code class="literal">let </code>and <code class="literal">const</code> keywords previously shown. If you are running these examples in a browser, you may find that the preceding listing doesn't work without strict mode.</p><p>In any case, you should always enable strict mode in all of your production code. The <code class="literal">"use strict"</code> string affects all code in the current scope (that is, JavaScript's traditional functional or global scope), so should usually be placed at the top of a function (or the top of a module's script file in Node.js).</p></div></div><div class="section" title="Object-oriented programming in JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Object-oriented programming in JavaScript</h2></div></div></div><p>Anything that is not one of JavaScript's built-in primitives (strings, number, null, and so on) is an <a id="id113" class="indexterm"/>
<span class="strong"><strong>object</strong></span>. This includes functions, as we've seen in the previous <a id="id114" class="indexterm"/>section. Functions<a id="id115" class="indexterm"/> are just a special type of object that <a id="id116" class="indexterm"/>can be invoked with arguments. Arrays are a special type of object with list-like behavior. All objects (including these two special types) can have properties, which are just names with a value. You can think of JavaScript objects as a dictionary with string keys and object values.</p><p>Objects can be created with properties using the object literal notation, as in the following example:</p><div class="informalexample"><pre class="programlisting">var myObject = {
    myProperty: "myValue",
    myMethod: function() {
        return `myProperty has value "${this.myProperty}"`;
    }
};
console.log(myObject.myMethod());</pre></div><p>You might find this notation familiar even if you've never written any JavaScript, as it is the basis for JSON. Note that a method is just an object property that happens to have a function as its value. Also note that within methods, we can refer to the containing object using the <code class="literal">this</code> keyword.</p><p>Finally, note that we did not need to define a class for our object. JavaScript is unusual amongst object-oriented languages in that it doesn't really have classes.</p><div class="section" title="Programming without classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Programming without classes</h3></div></div></div><p>In most<a id="id117" class="indexterm"/> object-oriented languages, we can<a id="id118" class="indexterm"/> declare methods in a class for use by all of its object instances. We can also share behavior between classes through inheritance.</p><p>Let's say we have a graph with a very large number of points. These may be represented by objects that are created dynamically and have some common behavior. We could implement points like this:</p><div class="informalexample"><pre class="programlisting">function createPoint(x, y) {
    return {
        x: x,
        y: y,
        isAboveDiagonal: function() {
            return this.y &gt; this.x;
        }
    };
}

var myPoint = createPoint(1, 2);
console.log(myPoint.isAboveDiagonal()); // Prints "true"</pre></div><p>One problem with this approach is that the <code class="literal">isAboveDiagonal</code> method is redefined for each point <a id="id119" class="indexterm"/>on our graph, thus taking up <a id="id120" class="indexterm"/>more space in memory.</p><p>We can address this <a id="id121" class="indexterm"/>using <span class="strong"><strong>prototypal inheritance</strong></span>. Although JavaScript doesn't have classes, objects can inherit from other objects. Each object has a <a id="id122" class="indexterm"/>
<span class="strong"><strong>prototype</strong></span>. If we try to access a property on an object and that property doesn't exist, the interpreter will look for a property with the same name on the object's prototype instead. If it doesn't exist there, it will check the prototype's prototype, and so on. The prototype chain will end with the built-in <code class="literal">Object.prototype</code>.</p><p>We can implement this for our point objects as follows:</p><div class="informalexample"><pre class="programlisting">var pointPrototype = {
    isAboveDiagonal: function() {
        return this.y &gt; this.x;
    }
};

function createPoint(x, y) {
    var newPoint = Object.create(pointPrototype);
    newPoint.x = x;
    newPoint.y = y;
    return newPoint;
}

var myPoint = createPoint(1, 2); 
console.log(myPoint.isAboveDiagonal()); // Prints "true"</pre></div><p>The <code class="literal">isAboveDiagonal</code> method now only exists once in memory, on the <code class="literal">pointPrototype</code> object.</p><p>When we try to call <code class="literal">isAboveDiagonal</code> on an individual point object, it is not present, but it is found on the prototype instead.</p><p>Note that this tells us something important about the <code class="literal">this</code> keyword. It actually refers to the object that the current function was called on, rather than the object it was defined on.</p><div class="section" title="Creating objects with the new keyword"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec01"/>Creating objects with the new keyword</h4></div></div></div><p>We can<a id="id123" class="indexterm"/> rewrite the preceding code example in <a id="id124" class="indexterm"/>a slightly different form, as follows:</p><div class="informalexample"><pre class="programlisting">var pointPrototype = {
    isAboveDiagonal: function() {
        return this.y &gt; this.x;
    }
}

function Point(x, y) {
    this.x = x;
    this.y = y;
}

function createPoint(x, y) {
    var newPoint = Object.create(pointPrototype);
<span class="strong"><strong>    Point.apply(newPoint, arguments);</strong></span>
    return newPoint;
}

var myPoint = createPoint(1, 2);</pre></div><p>This makes <a id="id125" class="indexterm"/>use of the special <code class="literal">arguments</code> object, which contains an array of the arguments to the current function. It also uses the <code class="literal">apply</code> method (which is available on all functions) to call the <code class="literal">Point</code> function on the <code class="literal">newPoint</code> object with the same arguments.</p><p>At the moment, our <code class="literal">pointPrototype</code> object isn't particularly closely associated with the <code class="literal">Point</code> function. Let's resolve this by using the <code class="literal">Point</code> function's <code class="literal">prototype</code> property instead. This is a built-in property available on all functions by default. It just contains an empty object to which we can add additional properties:</p><div class="informalexample"><pre class="programlisting">function Point(x, y) {
    this.x = x;
    this.y = y;
}

<span class="strong"><strong>Point.prototype.isAboveDiagonal = function() {</strong></span>
    return this.y &gt; this.x;
}

function createPoint(x, y) {
<span class="strong"><strong>    var newPoint = Object.create(Point.prototype);</strong></span>
    Point.apply(newPoint, arguments);
    return newPoint;
}

var myPoint = createPoint(1, 2);</pre></div><p>This <a id="id126" class="indexterm"/>might seem like a needlessly complicated<a id="id127" class="indexterm"/> way of doing things. However, JavaScript has a<a id="id128" class="indexterm"/> special operator that allows us to greatly simplify the previous code, as follows:</p><div class="informalexample"><pre class="programlisting">function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype.isAboveDiagonal = function() {
    return this.y &gt; this.x;
}

var myPoint = new Point(1, 2);</pre></div><p>The behavior of the <code class="literal">new</code> operator is identical to our <code class="literal">createPoint</code> function in the previous example. There is one small exception: if the <code class="literal">Point</code> function actually returned a value, then this would be used instead of <code class="literal">newPoint</code>. It is conventional in JavaScript to start functions with a capital letter if they are intended to be used with the <code class="literal">new</code> operator.</p></div></div><div class="section" title="Programming with classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Programming with classes</h3></div></div></div><p>Although <a id="id129" class="indexterm"/>JavaScript doesn't really have<a id="id130" class="indexterm"/> classes, ES2015 introduces a new <code class="literal">class</code> keyword. This makes it possible to implement shared behavior and inheritance in a way that may be more familiar compared to other object-oriented languages.</p><p>The equivalent of our preceding code would look like the following:</p><div class="informalexample"><pre class="programlisting">class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    
    isAboveDiagonal() {
        return this.y &gt; this.x;
    }
}

var myPoint = new Point(1, 2);</pre></div><p>Note that this really is equivalent to our preceding code. The <code class="literal">class</code> keyword is just syntactic sugar for setting up the prototype-based inheritance already discussed.</p><div class="section" title="Class-based inheritance"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec02"/>Class-based inheritance</h4></div></div></div><p>As mentioned before, an object's prototype may in turn have another prototype, allowing a chain <a id="id131" class="indexterm"/>of inheritance. Setting up such a chain becomes quite<a id="id132" class="indexterm"/> complicated using the prototype-based approach from the previous section. It is much more intuitive using the class keyword, as in the following example (which might be used for plotting a graph with error bars):</p><div class="informalexample"><pre class="programlisting">class UncertainPoint extends Point {
    constructor(x, y, uncertainty) {
        super(x, y);
        this.uncertainty = uncertainty;
    }
    
    upperLimit() {
        return this.y + this.uncertainty;
    }
    
    lowerLimit() {
        return this.y - this.uncertainty;
    }
}

var myUncertainPoint = new Point(1, 2, 0.5);</pre></div></div></div></div></div>
<div class="section" title="Summary" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl2sec26"/>Summary</h1></div></div></div><p>In this chapter, we have introduced JavaScript's type system, understood functions as first-class objects in JavaScript, seen how JavaScript differs from other object-oriented languages, implemented inheritance using prototypes and classes, and learned the new features of ECMAScript 2015 (ES6) that make the language safer and more intuitive to use.</p><p>Now that you have a firm grounding in JavaScript, you can start writing Node.js applications with confidence. In the next chapter, we will expand on our Express project and see how the module system in Node.js allows us to structure our codebase.</p></div></body></html>