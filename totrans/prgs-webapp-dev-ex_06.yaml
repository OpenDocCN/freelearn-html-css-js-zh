- en: Mastering the Cache API - Managing Web Assets in a Podcast Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握Cache API - 在播客应用中管理Web资源
- en: The most important service worker superpower is the ability to use a local response
    cache, making the network optional. Service workers can do this because they can
    intercept network requests and check if a response has previously been cached
    before passing the request to the network. They can also be programmed to cache
    any network response for future use. This allows the website to possibly load
    instantly and regardless of the network state, which is another way of saying
    your web apps can work offline.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的服务工作者超级能力是使用本地响应缓存，使网络可选。服务工作者可以做到这一点，因为它们可以拦截网络请求并检查在将请求传递到网络之前是否有缓存过的响应。它们还可以被编程来缓存任何网络响应以供将来使用。这允许网站可能立即加载，无论网络状态如何，这也是说您的Web应用可以在离线状态下工作。
- en: This super power relies on two newer platform features, Fetch and the Cache
    APIs. Before adding caching to the Podstr application, we need to learn the details
    of the APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种超级能力依赖于两个较新的平台特性，Fetch和Cache API。在向Podstr应用程序添加缓存之前，我们需要了解API的详细信息。
- en: You first saw fetch in [Chapter 4,](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d)
    *Service Workers – Notification, Synchronization, and Our Podcast App*, but it
    was only a simple introduction. Before we dive into using the Cache API, we are
    going to take a deep dive into the Fetch API and its support objects. After learning
    the details of these APIs, we can start stacking our skills to build caching strategies
    and make our web applications robust, offline progressive web applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您第一次在[第4章](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d)，*服务工作者 – 通知、同步以及我们的播客应用*中看到fetch，但那只是一个简单的介绍。在我们深入使用Cache
    API之前，我们将深入探讨Fetch API及其支持对象。在了解这些API的详细信息后，我们可以开始积累技能，构建缓存策略，并使我们的Web应用更加健壮，成为离线渐进式Web应用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the Fetch API works
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch API的工作原理
- en: The `Request`, `Response`, `header` objects and other Fetch API features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Request`、`Response`、`header`对象以及其他Fetch API特性'
- en: How the Cache API works
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cache API的工作原理
- en: Using the Fetch API
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fetch API
- en: We have already seen the Fetch API being used in [Chapter 4](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d), *Service
    Workers – Notification, Synchronization, and Our Podcast App*, so let's do a quick
    review. Fetch is a modern replacement for `XMLHttpRequest`. It is asynchronous,
    relying on promises, and provides a more streamline interface to manage dynamic
    requests. You can customize requests by creating custom `Request` and `header`
    objects. Service workers rely on Fetch to make network requests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第4章](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d)中看到了Fetch API的使用，*服务工作者
    – 通知、同步以及我们的播客应用*，所以让我们快速回顾一下。Fetch是`XMLHttpRequest`的现代替代品。它是异步的，依赖于承诺，并提供了一个更流畅的接口来管理动态请求。您可以通过创建自定义的`Request`和`header`对象来自定义请求。服务工作者依赖于Fetch来发起网络请求。
- en: The `fetch()` method takes two parameters, the URL that you are requesting (or
    a `request` object) and an `options` object. This method returns a `promise` object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()`方法接受两个参数，即您请求的URL（或一个`request`对象）和一个`options`对象。此方法返回一个`promise`对象。'
- en: 'There are also some differences from how you may be accustomed to making AJAX
    requests. Fetch does not usually throw an exception on HTTPS status codes, only
    if there is a network problem making the request, which typically indicates a
    platform or hardware issue. Any response from the server, even if it is an error
    status code such as 404: Page Not Found or 500: Server Error is still considered
    a successful request.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与您可能习惯的AJAX请求方式相比，Fetch通常不会在HTTPS状态码上抛出异常，只有当请求出现网络问题时，这通常表明是平台或硬件问题，才会抛出异常。来自服务器的任何响应，即使它是错误状态码，如404：页面未找到或500：服务器错误，仍然被视为成功的请求。
- en: This is because the browser cannot judge the success of the request in the eyes
    of the application. You are responsible for validating the response, which you
    see being done in the first code example, demonstrating a basic fetch request
    with a check for a successful response. If the response status is anything but
    200 (good response), an error message is logged.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为浏览器无法从应用程序的角度判断请求的成功与否。您需要负责验证响应，这在第一个代码示例中已经展示，演示了一个基本的fetch请求并检查了成功的响应。如果响应状态不是200（良好响应），则会记录错误信息。
- en: Another difference is how cookies are managed. Fetch does not send cookies to
    or from the server. This means if you rely on cookie-based authentication tokens,
    you will need to use the credentials property in fetch's initial options.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是cookie的管理方式。Fetch不会向服务器发送cookie。这意味着如果你依赖于基于cookie的认证令牌，你将需要在`fetch`的初始选项中使用`credentials`属性。
- en: The `fetch` method accepts two parameters, a `request` object or URL and an
    optional `init` object. The first parameter is either a valid URL or a `request`
    object. If the URL is provided, fetch creates a default request to call the network.
    The `request` object is covered in the next section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`方法接受两个参数，一个`request`对象或URL和一个可选的`init`对象。第一个参数要么是一个有效的URL，要么是一个`request`对象。如果提供了URL，`fetch`会创建一个默认请求来调用网络。`request`对象将在下一节中介绍。'
- en: 'If the init parameter is not supplied or a property is not set, the default
    values are used. The `init` object can contain the following properties:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`init`参数或未设置属性，则使用默认值。`init`对象可以包含以下属性：
- en: '`method`: HTTP verb; GET, POST, PUT, DELETE, and so on.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: HTTP动词；GET、POST、PUT、DELETE等。'
- en: '`headers`: Custom HTTP headers are added to your request. They can be part
    of either a `header` object or an object `literal`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`: 向你的请求添加自定义HTTP头。它们可以是`header`对象或对象字面量的一部分。'
- en: '`body`: Any data passed to the server. It can be a `Blob`, `Buffer`, `FormData`,
    `QueryString,` or `String` object.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`: 传递给服务器的任何数据。它可以是一个`Blob`、`Buffer`、`FormData`、`QueryString`或`String`对象。'
- en: '`mode`: `cors`, `no-cors`, or `same-origin`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`: `cors`、`no-cors`或`same-origin`。'
- en: '`credentials`: `omit`, `same-origin`, or `include` (required). It indicates
    how authentication cookies are handled.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`credentials`: `omit`、`same-origin`或`include`（必需）。它表示如何处理认证cookie。'
- en: '`cache`: `default`, `no-store`, `reload`, `no-cache`, `force-cache`, or `only-if-cached`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`: `default`、`no-store`、`reload`、`no-cache`、`force-cache`或`only-if-cached`。'
- en: '`redirect`: `follow` or `manual`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect`: `follow`或`manual`。'
- en: '`referrer`: `no-referrer`, client (default), or a URL.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referrer`: `no-referrer`, 客户端（默认），或一个URL。'
- en: '`referrerPolicy`: `no-referrer`, `no-referrer-when-downgrade`, `origin`, `origin-when-cross-origin`,
    or `unsafe-url`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`referrerPolicy`: `no-referrer`、`no-referrer-when-downgrade`、`origin`、`origin-when-cross-origin`或`unsafe-url`。'
- en: '`keepalive`: Can improve performance by keeping the connection after the response
    is delivered.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keepalive`: 通过在响应交付后保持连接来提高性能。'
- en: When you supply just a URL or a URL and an init object, the `fetch` method creates
    a request from those parameters. When you supply your own `request` object, it
    contains those values. One of the cool things about the Fetch API is its ability
    to create a custom `request` object. This means you can intercept a request in
    your service worker and transform it into a different request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只提供一个URL或一个URL和一个`init`对象时，`fetch`方法会根据这些参数创建一个请求。当你提供一个自己的`request`对象时，它包含这些值。Fetch
    API的一个酷特性是它能够创建一个自定义的`request`对象。这意味着你可以在你的服务工作者中拦截一个请求并将其转换成不同的请求。
- en: Request object
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'The `Request` constructor has the same two parameters as the `fetch` method
    has, a URL and option initialization object. The following code modifies the fetch
    example to use a custom `request` object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request`构造函数与`fetch`方法具有相同的两个参数，一个URL和一个可选的初始化对象。以下代码修改了`fetch`示例以使用自定义的`request`对象：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can do much more than just create a `request` object from a URL. You can
    craft a request using various options. While most requests are simple GET requests,
    there are many times where you need to craft something custom. The `request` object
    gives you the flexibility to make these requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的不仅仅是根据URL创建一个`request`对象。你可以使用各种选项来构建请求。虽然大多数请求是简单的GET请求，但很多时候你需要构建一些自定义的内容。`request`对象为你提供了灵活性，以便进行这些请求。
- en: 'The following example shows how to manage a potential redirect situation where
    you have changed your primary image folder:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何管理一个潜在的跳转情况，其中你已更改了你的主图片文件夹：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, there are many other potential scenarios where you might need to
    modify a request before sending it to the network. Remember, if you make a custom
    request and cache the response, you will need to modify the request before checking
    the cache.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他可能需要修改请求在发送到网络之前的情况。记住，如果你创建了一个自定义请求并缓存了响应，你需要在检查缓存之前修改请求。
- en: Handling cross-origin requests
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理跨域请求
- en: You may also need to address a URL on a separate domain. Because of potential
    security holes, access to these URLs is often protected. You can access these
    URLs using **Cross****-Origin Resource Sharing** (**CORS**), an additional layer,
    which relies on headers to control access.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要处理来自不同域的URL。由于潜在的安全漏洞，对这些URL的访问通常受到保护。您可以使用**跨域资源共享**（**CORS**）来访问这些URL，这是一个额外的层，它依赖于头部来控制访问。
- en: It is up to the server to tell the browser if it is alright for the browser
    to access the resource. CORS is a protocol that enables these cross-origin requests.
    There are actually two requests required to complete a cross-origin request. The
    first is a pre-flight request ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests))
    where the server tells the browser that the request is approved. After that, the
    original request is made.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器负责告知浏览器是否允许浏览器访问资源。CORS是一种协议，它使得这些跨源请求成为可能。实际上，完成一个跨源请求需要两个请求。第一个是预检请求([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests))，服务器告诉浏览器请求已被批准。之后，再进行原始请求。
- en: Fetch will not make the pre-flight request unless the `mode` property is set
    to `cors`. The remaining part of the CORS request is handled in the `response`
    object. I will cover that in a later section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除非将`mode`属性设置为`cors`，否则Fetch不会进行预检请求。CORS请求的其余部分在`response`对象中处理。我将在后面的部分中介绍这一点。
- en: 'There are four different request modes: `cors`, `no-cors`, `same-origin`, and
    `navigate`. You won''t use navigate because it is only used to navigate between
    pages. Thus, it is created by the browser.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同的请求模式：`cors`、`no-cors`、`same-origin`和`navigate`。您不会使用`navigate`，因为它仅用于在页面之间导航。因此，它是由浏览器创建的。
- en: 'The default mode is `same-origin`, which limits requests to the `same-origin`.
    If a request to an external domain is made, an error is thrown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模式是`same-origin`，它限制了请求到`same-origin`。如果发起对外部域的请求，则会抛出错误：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A `no-cors` request limits the type of request methods to GET, HEAD, and POST.
    When using `no-cors`, the service worker is limited in how it can modify the request
    and what response properties it can access.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`no-cors`请求限制了请求方法的类型为GET、HEAD和POST。当使用`no-cors`时，服务工作者在修改请求和访问响应属性方面受到限制。'
- en: You can still request resources from a separate origin using no-cors, but the
    types of response types are limited. For example, you can fetch an image, but
    you are limited as to what you can do with the response. These are called **opaque
    requests**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用`no-cors`从不同的源请求资源，但响应类型有限。例如，您可以获取一张图片，但对响应的处理能力有限。这些被称为**不透明请求**。
- en: Managing request credentials
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理请求凭证
- en: By default, fetch does not append cookies to requests. This is good for both
    security and performance. In most scenarios, accessing an API does require cookie-based
    authentication. For these scenarios, you need to set the credentials property
    to either `same-origin` or include. The default value is `omit`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，fetch不会将cookies附加到请求中。这对安全和性能都有好处。在大多数场景中，访问API确实需要基于cookie的认证。对于这些场景，您需要将凭证属性设置为`same-origin`或`include`。默认值是`omit`。
- en: 'By setting the `credentials` option to include or `same-origin`, the request
    will include the authentication cookies. The include value triggers the `request`
    object to include the credentials for any target origin, and the `same-origin`
    limits the credentials to the `same-origin`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`credentials`选项设置为`include`或`same-origin`，请求将包含认证cookies。`include`值会触发`request`对象为任何目标源包含凭证，而`same-origin`将凭证限制在`same-origin`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Controlling how a response is cached
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制响应的缓存方式
- en: Another important request option is the cache property. This property controls
    how the browser uses its own cache. Since service workers provide a cache, you
    can programmatically control the browser cache, but it might seem a bit redundant
    and cause some unwanted responses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的请求选项是缓存属性。该属性控制浏览器如何使用其自身的缓存。由于服务工作者提供缓存，您可以编程方式控制浏览器缓存，但这可能显得有些冗余，并可能导致一些不期望的响应。
- en: The default cache value changes nothing; the browser checks its own cache before
    making a network call and the response is the best one based on the default caching
    rules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的缓存值不会改变任何东西；浏览器在发起网络调用之前会检查其自身的缓存，响应是基于默认缓存规则的最佳响应。
- en: 'However, by setting the request cache option to another value, you can force
    the browser to bypass or change the way it uses the browser cache. The options
    are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过将请求缓存选项设置为另一个值，您可以强制浏览器绕过或更改它使用浏览器缓存的方式。选项如下：
- en: '`default`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`'
- en: '`no-store`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-store`'
- en: '`reload`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reload`'
- en: '`no-cache`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-cache`'
- en: '`force-cache`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`force-cache`'
- en: '`only-if-cached`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only-if-cached`'
- en: 'Since the service worker cache provides a superior method to cache assets,
    I tend to use it, and may want to remove the browser''s cache from the pipeline.
    In this scenario, you would want to change the cache property to `no-store`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务工作者缓存提供了优于浏览器缓存的缓存资产方法，我倾向于使用它，并可能想要从管道中移除浏览器的缓存。在这种情况下，您希望将缓存属性更改为 `no-store`：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Headers object
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部对象
- en: Customizing request headers is important when crafting unique requests and responses
    between the client and server. The request headers property is a `Headers` object.
    `Header` objects are used by both `request` and `response` objects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建客户端和服务器之间的独特请求和响应时，自定义请求头部非常重要。请求头部属性是一个 `Headers` 对象。`Header` 对象被 `request`
    和 `response` 对象使用。
- en: '`Headers` are a way for the client and server to communicate extra information
    about the request and response. Think about them as meta data about the data being
    sent back and forth.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Headers` 是客户端和服务器之间通信关于请求和响应额外信息的一种方式。可以将它们视为正在发送和接收的数据的元数据。'
- en: For example, when a response includes gzip compressed data, the Content-Encoding
    header tells the browser so it can decompress the body. Before returning a compressed
    response, the server looks for a corresponding header, such as accept-encoding,
    telling it that the client can accept a compressed response.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当响应包含 gzip 压缩数据时，Content-Encoding 头部会通知浏览器，以便它可以解压缩主体。在返回压缩响应之前，服务器会查找相应的头部，例如
    accept-encoding，告诉它客户端可以接受压缩响应。
- en: The `Headers` object manages the headers list. Member methods provide the ability
    to manage headers associated with a request or response.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Headers` 对象管理头部列表。成员方法提供了管理与请求或响应相关联的头部的能力。'
- en: Adding Headers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加头部
- en: 'Headers can be added either in the constructor or via the `append` method.
    The following example uses the `Headers` constructor:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 头部可以在构造函数中添加，也可以通过 `append` 方法添加。以下示例使用 `Headers` 构造函数：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Headers can also be added using the `append` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 头部也可以使用 `append` 方法添加：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A final way to add headers is by using the `set` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 添加头部的另一种方式是使用 `set` 方法：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The difference between `append` and `set` is the latter one will overwrite any
    existing values. While the `append` method adds the header value to the list of
    headers, the `append` method should be used for headers that allow multiple values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 和 `set` 方法之间的区别在于后者会覆盖任何现有的值。当 `append` 方法将头部值添加到头部列表中时，应该使用 `append`
    方法来处理允许多个值的头部。'
- en: An example multiple-value header is Cache-Control. There are many combinations
    you may need to set to provide instructions to different clients and intermediaries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个多值头部示例是 Cache-Control。您可能需要设置许多组合来向不同的客户端和中间件提供指令。
- en: For example, the best way to manage cache on HTML assets with my CDN is to mark
    them as private, with a 3,600 seconds time to live. You may also include a value
    for CDN caching, maybe 300 seconds. This means my CDN will naturally invalidate
    after 300 seconds, reducing my need to force updates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用我的 CDN 管理HTML资产的缓存的最佳方式是将它们标记为私有，生存时间为3600秒。您还可以包括CDN缓存的值，可能是300秒。这意味着我的CDN将在300秒后自然失效，减少我强制更新的需求。
- en: 'Using the `append` method requires up to three calls:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `append` 方法可能需要最多三次调用：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `set` method writes the final value, overwriting any previous value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 方法写入最终值，覆盖任何之前的值：'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Headers are a complex topic, so I recommend finding more resources if you need
    to dig deeper into specific headers and their values. Wikipedia is a good place
    to start ([https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields))
    as its page provides a very thorough list with details and further links to specifications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 头部是一个复杂的话题，如果您需要深入了解特定的头部及其值，我建议寻找更多资源。维基百科是一个很好的起点（[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)），其页面提供了一个非常详尽的列表，包括详细信息以及到规范的进一步链接。
- en: There is a limit to the amount of headers you can manage. There are headers
    that are restricted to the browser and others that are restricted to the server,
    which means you are not allowed to change them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以管理的头部数量是有限的。有些头部仅限于浏览器，有些仅限于服务器，这意味着不允许更改它们。
- en: If you try to append or set an invalid header, an exception will be thrown.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加或设置一个无效的头部，将会抛出异常。
- en: Accessing Header values
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问头部值
- en: 'The `get` method returns a specific headers value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法返回一个特定的头部值：'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `entries` method returns an iterator you can use to loop through all the
    headers. Each entry is a simple array, with the first entry being the header key
    name and the second member being the value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries` 方法返回一个迭代器，你可以用它来遍历所有头部。每个条目都是一个简单的数组，第一个条目是头部键名，第二个成员是值：'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `keys` method also provides an iterator, but only returns a list of header
    names:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys` 方法也提供了一个迭代器，但只返回头部名称的列表：'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Conversely, you can get a list of values from the `values` method. The problem
    with this method is that the values are not directly correlated to their keys:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以从 `values` 方法获取值的列表。这个方法的问题在于值与它们的键没有直接关联：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can check if a header exists by calling the `has` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `has` 方法来检查头部是否存在：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A header can be removed using the `delete` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `delete` 方法删除头部：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Protected Headers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受保护的头部
- en: Headers have a guard property. This flag indicates if headers can be manipulated.
    If you try to manipulate a header whose guard is set to immutable, an exception
    is thrown.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 头部有一个守卫属性。这个标志指示头部是否可以被操作。如果你尝试操作一个守卫设置为不可变的头部，将会抛出异常。
- en: 'These are the possible guard states:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可能的守卫状态：
- en: '`none`: Default'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`: 默认'
- en: '`request`: Guard for a Headers object obtained from a Request (`Request.headers`)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`: 用于从请求中获取的头部对象的守卫（`Request.headers`）'
- en: '`request-no-cors`: Guard for a Headers object obtained from a Request that''s
    been created with mode `no-cors`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request-no-cors`: 用于从使用模式 `no-cors` 创建的请求中获取的头部对象的守卫'
- en: '`response`: Naturally, for Headers obtained from Response (`Response.headers`)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`: 自然地，对于从响应中获取的头部（`Response.headers`）'
- en: '`immutable`: Mostly used for ServiceWorkers; renders a `Headers` object'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`immutable`: 主要用于 ServiceWorkers；渲染一个 `Headers` 对象'
- en: The actual rules controlling how different headers can be manipulated is very
    detailed. If you want to know more about these details, I recommend reading the
    Fetch specification ([https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际控制如何操作不同头部的规则非常详细。如果你想了解更多关于这些细节的信息，我建议阅读 Fetch 规范（[https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/))。
- en: Body mixin
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 体混合
- en: The `Request` and `Response` objects both have a `body` property. This is actually
    a mixin or a class that implements the body interface. The body contains a data
    stream with methods to retrieve the contents according to the type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request` 和 `Response` 对象都有一个 `body` 属性。这实际上是一个混合函数或类，它实现了体接口。体包含一个数据流，具有根据类型检索内容的方法。'
- en: Each `body` method reads the stream and converts it into the desired format.
    The stream is completely read and a `promise` is returned, resolving to the formatted
    data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `body` 方法读取流并将其转换为所需的格式。流被完全读取，并返回一个 `promise`，解析为格式化数据。
- en: You have already seen how to use the `json()` method to read JSON formatted
    data. There is also the `text`, `blob`, `formData`, and `arrayBuffer` methods.
    Each one resolves the body to the corresponding format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用 `json()` 方法来读取 JSON 格式的数据。还有 `text`、`blob`、`formData` 和 `arrayBuffer`
    方法。每个方法都将体解析为相应的格式。
- en: 'To review how to use JSON formatted data, let''s see how to retrieve search
    results in the Podstr application:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要回顾如何使用 JSON 格式的数据，让我们看看如何在 Podstr 应用程序中检索搜索结果：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how the `json()` mixin is available as a method of the response. That's
    because each of the body mixins implements the Body interface and are added to
    the Response object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `json()` 混合函数是如何作为响应的方法提供的。这是因为每个体混合函数都实现了 Body 接口，并被添加到响应对象中。
- en: The mixin returns a promise, resolving the JSON object. Remember, you cannot
    directly use the return value of the body mixins because they return a promise.
    You need to process the formatted data in a promise handler, which is the `then`
    method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 混合函数返回一个承诺，解析为 JSON 对象。记住，你不能直接使用体混合函数的返回值，因为它们返回一个承诺。你需要在一个承诺处理程序中处理格式化的数据，这就是
    `then` 方法。
- en: JSON may be the most common format used by modern APIs, but there are times
    when you retrieve other formats – the simplest being plain text.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JSON可能是现代API使用最广泛的格式，但有时你会检索其他格式——最简单的是纯文本。
- en: 'Fetching plain text looks almost identical to fetching JSON. Instead of using
    the json mixin, use the `text` mixin:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 获取纯文本看起来几乎与获取JSON相同。而不是使用json mixin，使用`text` mixin：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following example shows how to fetch an audio file (`ogg` format) and buffer
    the data to an `AudioContext` object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何获取一个音频文件（`ogg`格式）并将数据缓冲到`AudioContext`对象中：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So far, we have seen how to use a response body, but you can also set the body
    in a request. A common scenario is posting form data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用响应主体，但你也可以在请求中设置主体。一个常见的场景是提交表单数据。
- en: This example shows how to POST the contact form as a JSON object. The method
    is set to `'post'` and custom headers are supplied. The custom headers tell the
    server you are sending a JSON formatted body with the `Content-Type` header. You
    are also telling the server (the `Accept` header) that you expect a JSON object
    back.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何将联系表单作为JSON对象进行POST。方法设置为`'post'`，并提供了自定义头。自定义头告诉服务器你正在发送一个带有`Content-Type`头的JSON格式主体。你也在告诉服务器（通过`Accept`头）你期望返回一个JSON对象。
- en: 'The form is serialized or converted to a JSON object in the `serializeForm`
    method (not shown):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表单在`serializeForm`方法中被序列化或转换为JSON对象（未显示）：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also post the raw form using the `FormData` object ([https://developer.mozilla.org/en-US/docs/Web/API/FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)).
    Make sure that the API you are posting to can handle the form data:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`FormData`对象（[https://developer.mozilla.org/en-US/docs/Web/API/FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)）提交原始表单。确保你提交到的API可以处理表单数据：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last aspect of the body you need to know about is the `bodyUsed` property.
    This can be checked to see if you can still use the body or not. A body can only
    be read once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的关于主体的最后一个方面是`bodyUsed`属性。这可以用来检查你是否还能使用主体。主体只能读取一次。
- en: The body is a stream, which is a forward only set of data. Attempting to read
    the body more than once results in an exception being thrown.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 主体是一个流，它是一组只能向前读取的数据。尝试多次读取主体会导致抛出异常。
- en: 'If you need to read or use a body more than once, you should clone the request
    or response. A common scenario is when a service worker fetches a URL and caches
    the response while returning the response to the client. You will see this in
    more detail in the next chapter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要多次读取或使用一个主体，你应该克隆请求或响应。一个常见的场景是当服务工作者获取一个URL并缓存响应的同时返回响应给客户端。你将在下一章中看到更详细的说明：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Response object
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应对象
- en: The `response` object is almost identical to the `request` object. It is created
    when a request receives an answer from the server. Response objects also have
    headers and a body, the same object types as `request` objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`response`对象几乎与`request`对象相同。它是在请求从服务器收到答案时创建的。响应对象也有头和主体，与`request`对象相同的对象类型。'
- en: Responses are normally created by the platform when a response is received from
    the server. However, you can create a new response. This is more common when you
    want to transform a response.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 响应通常由平台在从服务器收到响应时创建。然而，你可以创建一个新的响应。这更常见于你想要转换响应时。
- en: A scenario I have dealt with is accessing data from an older API that returned
    flat data. The flat data needed to be transformed into a multi-dimensional JSON
    object. Instead of repeating that CPU intensive process, I transformed the data
    and cached the transformed response.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我处理的一个场景是从一个返回扁平数据的旧API中获取数据。这些扁平数据需要被转换成多维度的JSON对象。为了避免重复进行这个计算密集型过程，我将数据转换并缓存了转换后的响应。
- en: The Response constructor has two parameters, a Body object and an initialization
    object. We have already gone over Body objects in [Chapter 4](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d),
    *Service Workers – Notification, Synchronization, and Our Podcast App*. The Response
    initialization object is slightly different than the `request` object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 响应构造函数有两个参数，一个Body对象和一个初始化对象。我们已经在[第4章](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d)中讨论了Body对象，*服务工作者
    – 通知、同步和我们的播客应用*。响应初始化对象与`request`对象略有不同。
- en: 'Response object properties that differ from the `request` object are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与`request`对象不同的响应对象属性如下：
- en: '`status`: The status code for the reponse, for example, `200`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：响应的状态码，例如，`200`'
- en: '`statusText`: The status message associated with the status code, for example, `OK`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusText`：与状态码相关联的状态消息，例如，`OK`'
- en: '`headers`: Any headers you want to add to your response, contained within a
    Headers object or object literal of `ByteString` key/value pairs (see HTTP headers
    for a reference)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：你想要添加到响应中的任何头信息，包含在Headers对象或`ByteString`键/值对的字面量对象中（参见HTTP头信息以获取参考）'
- en: There are only three properties, one being a Headers object. The other two properties
    indicate the HTTP status. There is a code, status, and a text value, statusText.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三个属性，一个是Headers对象。其他两个属性指示HTTP状态。有一个code、status和text值，statusText。
- en: Response properties
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应属性
- en: Most of the Response object properties are similar to a `request` object, most
    notably the Body and its mixins.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数响应对象属性与请求对象类似，最值得注意的是Body及其混合。
- en: The `isRedirected` property indicates if the response is the product of a redirected
    (HTTPS status code `301` or `302`) response.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`isRedirected`属性指示响应是否是重定向（HTTPS状态码`301`或`302`）响应的结果。'
- en: The type property is `readonly`, and tells us if the response had a network
    error (error), opaque (cross-origin with a no-cors request, cors, and basically
    inidicates a successful response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类型属性是只读的，告诉我们响应是否有网络错误（错误）、不透明（带有no-cors请求的跨源，cors，基本上表示成功的响应）。
- en: The `url` property is the final response URL, after any redirects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`属性是任何重定向后的最终响应URL。'
- en: Verifying a successful response
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证成功的响应
- en: As I mentioned earlier, fetch does not throw an exception or return an error
    if the response status is not 200\. Instead, as long as fetch receives a response,
    it does not fail. It is still up to you to interrogate the response status to
    determine how you want to process the response.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，如果响应状态不是200，fetch不会抛出异常或返回错误。相反，只要fetch收到响应，它就不会失败。仍然取决于你如何查询响应状态来确定你想要如何处理响应。
- en: The `ok` property is true if the status code is 200-299, and false otherwise.
    It can be a quick way to verify a request's success. Just be careful, as sometimes
    you can receive a 0 status code for cached, cross-origin responses.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码是200-299，则`ok`属性为true，否则为false。这可以是一个快速验证请求成功的方法。但请小心，有时你可以收到缓存、跨源响应的0状态码。
- en: In practice, many requests can have a range of successful status codes. HTTP
    status codes are grouped by 100s. 200-299 indicates a successful response, while
    300-399 indicates a redirect and is accompanied by a new address. `400` indicates
    that the URL is not accessible, `404` being the most well-known. Other reasons
    a resource is not accessible have to do with authorization or permission to access
    the resource. Finally, anything in the 500 range indicates that there is a server-side
    problem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，许多请求可以有一系列成功的状态码。HTTP状态码按100s分组。200-299表示成功的响应，而300-399表示重定向，并伴随新的地址。`400`表示URL不可访问，`404`是最著名的。其他资源不可访问的原因与授权或访问资源的权限有关。最后，500范围内的任何内容都表示存在服务器端问题。
- en: Having a strategy to handle different statuses is important for the success
    of your application. Checking the `response.ok` value may not give you the entire
    story. I found that Chrome returns a status equal to 0 for external origin resources
    stored in the cache. The response is still successful, but limiting your logic
    to check for `response.ok` would lead to excess network requests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 制定策略来处理不同的状态对于应用程序的成功至关重要。检查`response.ok`值可能不会给出完整的故事。我发现Chrome为存储在缓存中的外部源资源返回等于0的状态。响应仍然是成功的，但将你的逻辑限制为检查`response.ok`会导致过多的网络请求。
- en: Now that you know the details of the Fetch API, it's time to start learning
    how the Cache API works. The Cache API depends on the Fetch API because it caches
    request-response pairs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Fetch API的细节，是时候开始学习Cache API的工作原理了。Cache API依赖于Fetch API，因为它缓存请求-响应对。
- en: Caching responses
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存响应
- en: We have been able to store content, including data and site assets using web
    storage and IndexedDB for several years. Using either medium requires a library
    or custom logic to manage site assets, which is why the service worker specification
    includes a specialized Cache API.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够使用Web存储和IndexedDB存储内容，包括数据和网站资源好几年了。使用这两种方式中的任何一种都需要一个库或自定义逻辑来管理网站资源，这也是为什么服务工作者规范包括一个专门的缓存API。
- en: The Cache interface provides a managed storage mechanism for Request/Response
    object pairs. These objects are also referred to as network addressable resources,
    but you can think about them as just files or API responses.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存接口为请求/响应对象对提供了一个管理存储机制。这些对象也被称为可网络访问的资源，但你可以将它们视为仅仅是文件或API响应。
- en: The Cache API has a natural advantage over `IndexedDB` and `localStorage` because
    it is designed to abstract, persisting these assets by the `Request` and `Response`
    objects. This means that you can reference the assets using more than just a single
    key value, like `localStorage` provides.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `IndexedDB` 和 `localStorage` 相比，缓存API具有天然的优势，因为它被设计为通过 `Request` 和 `Response`
    对象来抽象、持久化这些资产。这意味着你可以使用比 `localStorage` 提供的不仅仅是单个键值来引用资产。
- en: Besides providing a managed interface to store assets, it also allows you to
    organize those assets into groups or caches. As we progress through the remaining
    chapters, you will see how to use this power to segregate the assets to make updating
    and invalidating easier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一个管理接口来存储资产外，它还允许你将这些资产组织成组或缓存。随着我们继续阅读剩余的章节，你将看到如何使用这种能力来隔离资产，以便更新和失效变得更容易。
- en: Caches, like other browser storage services, are managed by the browser by origin,
    or domain. This prevents third parties from accessing the content that's stored
    your site. Your overall storage quota is also tied to the origin and allocated
    across the various storage services.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他浏览器存储服务一样，缓存由浏览器按来源或域名管理。这阻止第三方访问存储在你网站上的内容。你的整体存储配额也与来源相关联，并在各种存储服务之间分配。
- en: The amount of space available varies by device and is proportional to the available
    disk space. Like income tax, the rule governing your quota allowance varies by
    the amount of available space.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可用空间的大小因设备而异，与可用磁盘空间成正比。就像所得税一样，管理你的配额允许的规则因可用空间的大小而异。
- en: 'Ali Alabbas shared the following slide at the Microsoft Edge Developer Summit,
    explaining the rules governing storage quotas:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Ali Alabbas 在微软边缘开发者峰会上分享了以下幻灯片，解释了管理存储配额的规则：
- en: '![](img/00070.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00070.jpeg)'
- en: If space becomes limited, the browser will arbitrarily purge stored data from
    the different storage providers. Unless you manage this process, you have no guarantee
    that your assets have remained cached.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果空间变得有限，浏览器将任意地从不同的存储提供者中清除存储的数据。除非你管理这个过程，否则你无法保证你的资产已经保留在缓存中。
- en: The Cache API is part of the service worker specification because it is the
    backbone to make your progressive web application work offline. Without the ability
    to save assets for immediate access, your site could not work offline.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存API是服务工作者规范的一部分，因为它是使你的渐进式Web应用离线工作的基础。如果没有保存资产以供即时访问的能力，你的网站将无法离线工作。
- en: Caches object
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存对象
- en: The `Caches` object represents a collection of named caches and members to interact
    with those caches. The interface provides methods to open, create, iterate, and
    remove individual caches. You can also match cached responses over all the named
    caches without interrogating each one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Caches` 对象代表一组命名缓存及其成员，用于与这些缓存交互。该接口提供了打开、创建、迭代和删除单个缓存的方法。你还可以在所有命名缓存中匹配缓存的响应，而无需查询每个缓存。'
- en: caches.open
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: caches.open
- en: 'The `caches.open` method returns a reference to a cache matching the name that''s
    supplied. This reference is a `Cache` object, which is detailed in later sections.
    If a cache matching the name does not exist, a new cache is provisioned. This
    returns a promise; resolving a cache object allows you to manage cached responses
    in that cache:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`caches.open` 方法返回一个与提供的名称匹配的缓存的引用。这个引用是一个 `Cache` 对象，在后面的章节中会详细介绍。如果不存在与名称匹配的缓存，则会创建一个新的缓存。这返回一个承诺；解决缓存对象允许你在该缓存中管理缓存的响应：'
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: caches.match
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: caches.match
- en: The `caches.match` method is a convivence method that works similarly to the
    `cache.match` method. It returns a promise that resolves to the first cached response
    matching the `Request` object passed to the method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`caches.match` 方法是一个便利方法，其工作方式与 `cache.match` 方法类似。它返回一个承诺，该承诺解析为与传递给方法的 `Request`
    对象匹配的第一个缓存的响应。'
- en: The nice thing about the `caches.match` method is how it handles interrogating
    all named caches for a match. It returns the first match it finds.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`caches.match` 方法的优点在于它处理查询所有命名缓存以找到匹配项的方式。它返回它找到的第一个匹配项。'
- en: 'This means that if matching responses are stored in different caches, you have
    no control over which response is found. To avoid a scenario where an invalid
    response is matched, you need to ensure that your logic invalidates outdated cached
    responses before caching an update:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果匹配的响应存储在不同的缓存中，你无法控制找到哪个响应。为了避免匹配到无效响应的场景，你需要确保在缓存更新之前，你的逻辑使过时的缓存响应无效：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: caches.has()
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: caches.has()
- en: 'If you need to check if a named cache exists, the `has` method returns a promise,
    resolving true:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要检查一个命名缓存是否存在，`has` 方法返回一个承诺，解析为 true：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: caches.delete()
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: caches.delete()
- en: 'The `delete` method searches for a cache matching the name supplied. If a matching
    cache is found, it is deleted. A promise is returned that resolves true if a matching
    cache was deleted or false if one was not deleted:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 方法搜索与提供的名称匹配的缓存。如果找到一个匹配的缓存，它将被删除。返回一个承诺，如果找到匹配的缓存则解析为 true，如果没有找到则解析为
    false：'
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You don't always need to add code to handle the response. Typically, you would
    log the activity. If no cache was deleted, it is most likely due to the cache
    not existing, which in that case you probably have nothing to worry about.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你不总是需要添加代码来处理响应。通常，你会记录活动。如果没有删除缓存，最可能的原因是缓存不存在，在这种情况下，你可能没有什么可担心的。
- en: You should also note that if you delete a cache, all of the cached items are
    deleted along with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意，如果你删除了一个缓存，所有缓存的项都会随之删除。
- en: caches.keys()
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: caches.keys()
- en: The `keys` method returns a promise with an array of names (strings) for each
    named cache. This list can be iterated over for processing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys` 方法返回一个承诺，包含每个命名缓存的名称（字符串）数组。这个列表可以迭代以进行处理。'
- en: 'The following example is placed within the service worker activate event handler.
    It removes caches that were crafted for a previous service worker version. This
    concept was covered in [Chapter 5](part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d),
    *The Service Worker Life Cycle*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例放置在服务工作者激活事件处理器中。它删除了为先前服务工作者版本制作的缓存。这个概念在[第 5 章](part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d)中有所介绍，*服务工作者生命周期*：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice the `delete` method does not have any processing after a cache is deleted.
    If you wanted to log any problems regarding deleting a cache, you could do that
    here.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `delete` 方法在删除缓存后没有进行任何处理。如果你想记录有关删除缓存的任何问题，可以在这里做。
- en: The Cache object
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cache 对象
- en: The Cache interface is a collection of methods and properties to manage stored
    responses. You cannot create a cache object; you must open a reference to a cache
    using the `Caches.open` method, which will be covered later. This reference is
    an instance of the Cache object, giving you access to the responses it manages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Cache 接口是一组用于管理存储响应的方法和属性。你不能创建缓存对象；你必须使用 `Caches.open` 方法打开对缓存的引用，这将在后面介绍。这个引用是
    Cache 对象的一个实例，它让你可以访问它管理的响应。
- en: cache.match()
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cache.match()
- en: The `match` method has two parameters, a `request` object and an optional options
    object. It returns a promise if a matching response is found to be resolved in
    the promise's return. If no response was found, the promise still resolves, but
    as undefined.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 方法有两个参数，一个 `request` 对象和一个可选的选项对象。如果找到一个匹配的响应，它将返回一个解析的承诺。如果没有找到响应，承诺仍然解析，但作为
    undefined。'
- en: If no match was found, you can then continue with the appropriate logic, like
    forwarding the request to the network or returning a fallback response.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项，你可以继续执行适当的逻辑，例如将请求转发到网络或返回一个回退响应。
- en: The `request` object parameter can be either a valid `request` object or a URL.
    If only a URL is provided, the method does an implicit conversion internally.
    Supplying a `request` object gives you more control because different responses
    could be cached by request variations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 对象参数可以是有效的 `request` 对象或 URL。如果只提供了一个 URL，方法会内部进行隐式转换。提供 `request`
    对象可以让你有更多的控制权，因为不同的响应可能会被请求变体缓存。'
- en: For example, the same URL might have a cached response for both `HEAD` and `GET`
    methods, each being unique. Differing `QueryStrings` is another common example
    where similar URLs have different responses cached.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，相同的 URL 可能对 `HEAD` 和 `GET` 方法都有缓存的响应，每个都是唯一的。不同的 `QueryStrings` 是另一个常见示例，其中相似的
    URL 有不同的响应被缓存。
- en: The optional `options` parameter allows you to provide more details to the `match`
    method about the specific request you want to match. You can think of it as a
    way of filtering potential matches.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`options`参数允许你向`match`方法提供更多关于你想要匹配的特定请求的详细信息。你可以将其视为一种筛选潜在匹配的方法。
- en: The `options` object has a set of potential properties you can provide a value
    to match or filter against.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`对象有一组潜在的属性，你可以提供值来匹配或筛选。'
- en: 'The potential options that are available are as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的潜在选项如下：
- en: '`ignoreSearch`: Indicates if you want to use the `QueryString` or not. The
    options are true or false.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreSearch`：表示你是否想使用`QueryString`。选项是true或false。'
- en: '`ignoreMethod`: Indicates if you want to filter by the `request` method, for
    example GET, POST, DELETE, and so on. By default, match does use the request method
    to match a response.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreMethod`：表示你是否想通过`request`方法进行筛选，例如GET、POST、DELETE等。默认情况下，匹配确实使用请求方法来匹配响应。'
- en: '`ignoreVary`: When set to true, headers are ignored when retrieving a match.
    The URL is used as the filter, which means cached responses for different header
    combinations could match.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreVary`：当设置为true时，在检索匹配项时忽略头信息。URL用作筛选器，这意味着不同头组合的缓存响应可以匹配。'
- en: '`cacheName`: This limits matching responses to a specific cache name. Multiple
    responses could be cached across different named caches, but this specifies which
    cache should be used.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheName`：这限制了匹配响应到特定的缓存名称。多个响应可以跨不同命名的缓存进行缓存，但指定了应该使用哪个缓存。'
- en: 'For most queries, you won''t use these options because they are highly specialized.
    `ignoreSearch` has the most potential to be used because `QueryString` parameters
    are very common. Servers typically return different responses based on how these
    values vary:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数查询，你不会使用这些选项，因为它们高度专业化。`ignoreSearch`最有可能是被使用的，因为`QueryString`参数非常常见。服务器通常根据这些值的差异返回不同的响应：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: cache.matchAll
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cache.matchAll
- en: Similar to the `match` method, the `matchAll()` method takes request and options
    (optional) parameters. The method returns a promise that resolves an array of
    matching responses. Unlike the same method on the Caches object, it only returns
    matches in the specifically named cache.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与`match`方法类似，`matchAll()`方法接受请求和选项（可选）参数。该方法返回一个承诺，解析出一个匹配响应的数组。与Caches对象上的相同方法不同，它只返回特定命名的缓存中的匹配项。
- en: The main difference between `matchAll` and match is that the `match` method
    returns the first response it matches.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchAll`和`match`之间的主要区别在于，`match`方法返回它匹配的第一个响应。'
- en: 'The `matchAll` method is useful when you need to match responses using a route,
    not just a specific URL. For example, if you want to get a list of all a podcast''s
    banner images, you could do something like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用路由而不是特定URL来匹配响应时，`matchAll`方法很有用。例如，如果你想获取所有播客的横幅图像列表，你可以这样做：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Cache add and addAll
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存添加和addAll
- en: 'If you want to retrieve an asset and immediately cache the response, the `add`
    and `addAll` methods manage this process. The `add` method is equivalent to the
    following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检索一个资产并立即缓存响应，`add`和`addAll`方法管理这个过程。`add`方法等同于以下代码：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Both the `add` and `addAll` methods have a single parameter: a `request` object.
    Like the `match` method, you can also supply a valid URL and the method will convert
    it into a `request` object.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`addAll`方法都有单个参数：一个`request`对象。像`match`方法一样，你也可以提供一个有效的URL，方法会将它转换为`request`对象。'
- en: Both methods return a promise, but do not resolve a value. As long as there
    were no exceptions making and caching the requests, you can use the resolution
    to continue the application workflow. If there was an exception, you can catch
    and handle it appropriately.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都返回一个承诺，但不会解析一个值。只要没有异常发生，请求被制作和缓存，你就可以使用解析来继续应用程序的工作流程。如果有异常，你可以适当地捕获和处理它。
- en: The add methods are useful in the install and activate life cycle events because
    you can provide a list of URLs to precache. You are not limited to these scenarios,
    as they can be called anytime.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装和激活生命周期事件中，`add`方法很有用，因为你可以提供要预缓存的URL列表。你不受这些场景的限制，因为它们可以在任何时候调用。
- en: They are not helpful during most caching strategies, which are initiated by
    the fetch event handler. We will go over many of these strategies in the following
    chapter. When handling real-time fetches, the network response is typically needed
    to render a page. These methods do not return access to the responses.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数由 fetch 事件处理器启动的缓存策略中，它们并不有用。我们将在下一章中介绍许多这些策略。在处理实时 fetch 时，通常需要网络响应来渲染页面。这些方法不返回对响应的访问权限。
- en: cache.put
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cache.put
- en: Despite what you might think, the `add` method do not let you cache a response
    directly. If you receive a network response from a fetch call, you would need
    to explicitly handle its caching. This is where the `put` method gives you the
    control needed to cache a response with the flexibility to use the response in
    parallel to the caching process.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能认为不是这样，`add` 方法并不允许你直接缓存响应。如果你从 fetch 调用中收到网络响应，你需要显式地处理其缓存。这就是 `put` 方法为你提供所需控制以缓存响应并允许在缓存过程中并行使用响应的灵活性所在。
- en: As you will learn in the next chapter, there are many different caching strategies
    where a network response is cached once the network request resolves.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一章中了解到的那样，有许多不同的缓存策略，在网络请求解析后，网络响应会被缓存。
- en: The `put` method has two parameters, `request` and `response`. These are the
    same `Request` and `Response` objects that were covered in the *Fetch* section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`put` 方法有两个参数，`request` 和 `response`。这些与在 *Fetch* 部分中提到的相同的 `Request` 和 `Response`
    对象。'
- en: The `put` method uses these two objects to catalog the assets in a key value
    fashion, sort of like localStorage, just specialized for caching page assets.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`put` 方法使用这两个对象以键值对的方式对页面资源进行目录化，有点像 localStorage，但专门用于缓存页面资源。'
- en: The `put` method returns a promise, but does not resolve a value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`put` 方法返回一个承诺，但不解析任何值。'
- en: If you need to use the response, you should clone it before caching. A response
    body can only be used once, but the `response` object has a `clone` method that
    creates a copy. I typically cache the copy and return the original, but it does
    not matter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用响应，你应该在缓存之前克隆它。响应体只能使用一次，但 `response` 对象有一个 `clone` 方法可以创建副本。我通常缓存副本并返回原始的，但这并不重要。
- en: 'The following code demonstrates how to fetch a resource, clone the response,
    cache the clone, and return the original response:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何获取资源，克隆响应，缓存克隆，并返回原始响应：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Deleting Cached items
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除缓存项
- en: You are also responsible for periodically purging cache entries. The browser
    will not invalidate cache for you. It might purge items if available space becomes
    limited. However, I would not worry about this scenario. Instead, you need a plan
    to delete cached assets so that you can control how long an item is cached for.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你还负责定期清除缓存条目。浏览器不会为你使缓存失效。如果可用空间变得有限，它可能会清除项目。然而，我并不担心这种场景。相反，你需要有一个计划来删除缓存资源，这样你就可以控制一个项目被缓存的时间长度。
- en: The best way to manage or invalidate cached assets is to apply a set of rules
    to control your cache. [Chapter 8](part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d), *Applying
    Advanced Service Worker Cache Strategies*, goes into more detail about invalidation
    strategies. Before you reach that level, it's important to know how to remove
    an asset or delete an entire cache.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 管理或使缓存资源失效的最佳方式是应用一组规则来控制你的缓存。[第 8 章](part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d)，*应用高级
    Service Worker 缓存策略*，更详细地介绍了失效策略。在你达到那个水平之前，了解如何删除资源或删除整个缓存是很重要的。
- en: 'The `delete` method returns a promise that resolves true if a matching response
    was found and deleted, otherwise it returns false:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 方法返回一个承诺，如果找到并删除了匹配的响应，则解析为 true，否则返回 false：'
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method has two parameters, a request and an optional options object. The
    options are the same ones that are used in the match method. This is because you
    can cache multiple responses to a URL if there are different request variations
    using those options.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有两个参数，一个请求和一个可选的选项对象。这些选项与在 match 方法中使用的是相同的。这是因为如果你使用这些选项有不同的请求变体，你可以缓存对
    URL 的多个响应。
- en: cache.keys
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cache.keys
- en: The cache object's `key` method returns a promise that resolves an array of
    requests that are stored in the cache. The method has two optional parameters,
    request and options. These are the same two types we have seen for the other methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存对象的 `key` 方法返回一个解析为存储在缓存中的请求数组的承诺。该方法有两个可选参数，请求和选项。这些与我们在其他方法中看到的相同类型。
- en: When supplying these parameters, the `keys` method works much like the match
    and `matchAll` methods.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供这些参数时，`keys`方法的工作方式与`match`和`matchAll`方法非常相似。
- en: 'The array of keys or requests can then be used to update your cache. For example,
    you could loop through and delete all matches or maybe do a silent background
    update:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用键或请求的数组来更新您的缓存。例如，您可以循环遍历并删除所有匹配项，或者可能进行静默的背景更新：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The keys are returned in insertion order. This can come in handy if you want
    to manage cache invalidation by removing the oldest pair(s) first. We'll review
    some cache invalidation strategies in the later chapters. You will see how this
    can be done along with some other strategies.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 键按插入顺序返回。如果您想通过首先删除最旧的配对来管理缓存失效，这可能会很有用。我们将在后面的章节中回顾一些缓存失效策略。您将看到如何实现这一点，以及一些其他策略。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how the Fetch and Cache APIs are critical for the service
    workers. To get the most out of service workers, you need to be able to intercept
    and manipulate requests and the server responses. Because service workers rely
    on asynchronous functions (Promises), you must use Fetch, as a new replacement
    for `XMLHttpRequest`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Fetch和Cache API对于服务工作者的重要性。为了充分利用服务工作者，您需要能够拦截和操作请求以及服务器响应。因为服务工作者依赖于异步函数（Promises），所以您必须使用Fetch，作为`XMLHttpRequest`的新替代品。
- en: The Cache API provides a new storage medium in the browser, which is highly
    specialized for request/response pairs. The API is a rich platform, providing
    the maximum amount of control over network resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Cache API为浏览器提供了一种新的存储介质，这种介质高度专门化，适用于请求/响应对。该API是一个丰富的平台，提供了对网络资源的最大控制量。
- en: Your goal is to use the best logic and platform resources to make your website
    load quickly and work offline. Now that you know how the Fetch and Cache APIs
    work, it's time to start crafting the best caching system you can.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目标是使用最佳的逻辑和平台资源来使您的网站快速加载并离线工作。现在您已经了解了Fetch和Cache API的工作原理，是时候开始构建您能构建的最好的缓存系统了。
- en: In the next chapter, we will review different caching patterns and start seeing
    how they can be applied so that you can determine what strategy you should employ
    in your applications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾不同的缓存模式，并开始了解它们如何应用，以便您可以确定在您的应用程序中应该采用哪种策略。
