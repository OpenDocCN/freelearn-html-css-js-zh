- en: Mastering the Cache API - Managing Web Assets in a Podcast Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important service worker superpower is the ability to use a local response
    cache, making the network optional. Service workers can do this because they can
    intercept network requests and check if a response has previously been cached
    before passing the request to the network. They can also be programmed to cache
    any network response for future use. This allows the website to possibly load
    instantly and regardless of the network state, which is another way of saying
    your web apps can work offline.
  prefs: []
  type: TYPE_NORMAL
- en: This super power relies on two newer platform features, Fetch and the Cache
    APIs. Before adding caching to the Podstr application, we need to learn the details
    of the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: You first saw fetch in [Chapter 4,](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d)
    *Service Workers – Notification, Synchronization, and Our Podcast App*, but it
    was only a simple introduction. Before we dive into using the Cache API, we are
    going to take a deep dive into the Fetch API and its support objects. After learning
    the details of these APIs, we can start stacking our skills to build caching strategies
    and make our web applications robust, offline progressive web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How the Fetch API works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Request`, `Response`, `header` objects and other Fetch API features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Cache API works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Fetch API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen the Fetch API being used in [Chapter 4](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d), *Service
    Workers – Notification, Synchronization, and Our Podcast App*, so let's do a quick
    review. Fetch is a modern replacement for `XMLHttpRequest`. It is asynchronous,
    relying on promises, and provides a more streamline interface to manage dynamic
    requests. You can customize requests by creating custom `Request` and `header`
    objects. Service workers rely on Fetch to make network requests.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch()` method takes two parameters, the URL that you are requesting (or
    a `request` object) and an `options` object. This method returns a `promise` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some differences from how you may be accustomed to making AJAX
    requests. Fetch does not usually throw an exception on HTTPS status codes, only
    if there is a network problem making the request, which typically indicates a
    platform or hardware issue. Any response from the server, even if it is an error
    status code such as 404: Page Not Found or 500: Server Error is still considered
    a successful request.'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the browser cannot judge the success of the request in the eyes
    of the application. You are responsible for validating the response, which you
    see being done in the first code example, demonstrating a basic fetch request
    with a check for a successful response. If the response status is anything but
    200 (good response), an error message is logged.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is how cookies are managed. Fetch does not send cookies to
    or from the server. This means if you rely on cookie-based authentication tokens,
    you will need to use the credentials property in fetch's initial options.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch` method accepts two parameters, a `request` object or URL and an
    optional `init` object. The first parameter is either a valid URL or a `request`
    object. If the URL is provided, fetch creates a default request to call the network.
    The `request` object is covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the init parameter is not supplied or a property is not set, the default
    values are used. The `init` object can contain the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`: HTTP verb; GET, POST, PUT, DELETE, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: Custom HTTP headers are added to your request. They can be part
    of either a `header` object or an object `literal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: Any data passed to the server. It can be a `Blob`, `Buffer`, `FormData`,
    `QueryString,` or `String` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: `cors`, `no-cors`, or `same-origin`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`credentials`: `omit`, `same-origin`, or `include` (required). It indicates
    how authentication cookies are handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`: `default`, `no-store`, `reload`, `no-cache`, `force-cache`, or `only-if-cached`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect`: `follow` or `manual`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`referrer`: `no-referrer`, client (default), or a URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`referrerPolicy`: `no-referrer`, `no-referrer-when-downgrade`, `origin`, `origin-when-cross-origin`,
    or `unsafe-url`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keepalive`: Can improve performance by keeping the connection after the response
    is delivered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you supply just a URL or a URL and an init object, the `fetch` method creates
    a request from those parameters. When you supply your own `request` object, it
    contains those values. One of the cool things about the Fetch API is its ability
    to create a custom `request` object. This means you can intercept a request in
    your service worker and transform it into a different request.
  prefs: []
  type: TYPE_NORMAL
- en: Request object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Request` constructor has the same two parameters as the `fetch` method
    has, a URL and option initialization object. The following code modifies the fetch
    example to use a custom `request` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can do much more than just create a `request` object from a URL. You can
    craft a request using various options. While most requests are simple GET requests,
    there are many times where you need to craft something custom. The `request` object
    gives you the flexibility to make these requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to manage a potential redirect situation where
    you have changed your primary image folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there are many other potential scenarios where you might need to
    modify a request before sending it to the network. Remember, if you make a custom
    request and cache the response, you will need to modify the request before checking
    the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Handling cross-origin requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may also need to address a URL on a separate domain. Because of potential
    security holes, access to these URLs is often protected. You can access these
    URLs using **Cross****-Origin Resource Sharing** (**CORS**), an additional layer,
    which relies on headers to control access.
  prefs: []
  type: TYPE_NORMAL
- en: It is up to the server to tell the browser if it is alright for the browser
    to access the resource. CORS is a protocol that enables these cross-origin requests.
    There are actually two requests required to complete a cross-origin request. The
    first is a pre-flight request ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests))
    where the server tells the browser that the request is approved. After that, the
    original request is made.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch will not make the pre-flight request unless the `mode` property is set
    to `cors`. The remaining part of the CORS request is handled in the `response`
    object. I will cover that in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different request modes: `cors`, `no-cors`, `same-origin`, and
    `navigate`. You won''t use navigate because it is only used to navigate between
    pages. Thus, it is created by the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default mode is `same-origin`, which limits requests to the `same-origin`.
    If a request to an external domain is made, an error is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A `no-cors` request limits the type of request methods to GET, HEAD, and POST.
    When using `no-cors`, the service worker is limited in how it can modify the request
    and what response properties it can access.
  prefs: []
  type: TYPE_NORMAL
- en: You can still request resources from a separate origin using no-cors, but the
    types of response types are limited. For example, you can fetch an image, but
    you are limited as to what you can do with the response. These are called **opaque
    requests**.
  prefs: []
  type: TYPE_NORMAL
- en: Managing request credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, fetch does not append cookies to requests. This is good for both
    security and performance. In most scenarios, accessing an API does require cookie-based
    authentication. For these scenarios, you need to set the credentials property
    to either `same-origin` or include. The default value is `omit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting the `credentials` option to include or `same-origin`, the request
    will include the authentication cookies. The include value triggers the `request`
    object to include the credentials for any target origin, and the `same-origin`
    limits the credentials to the `same-origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Controlling how a response is cached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important request option is the cache property. This property controls
    how the browser uses its own cache. Since service workers provide a cache, you
    can programmatically control the browser cache, but it might seem a bit redundant
    and cause some unwanted responses.
  prefs: []
  type: TYPE_NORMAL
- en: The default cache value changes nothing; the browser checks its own cache before
    making a network call and the response is the best one based on the default caching
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, by setting the request cache option to another value, you can force
    the browser to bypass or change the way it uses the browser cache. The options
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no-store`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reload`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no-cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`force-cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`only-if-cached`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the service worker cache provides a superior method to cache assets,
    I tend to use it, and may want to remove the browser''s cache from the pipeline.
    In this scenario, you would want to change the cache property to `no-store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Headers object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customizing request headers is important when crafting unique requests and responses
    between the client and server. The request headers property is a `Headers` object.
    `Header` objects are used by both `request` and `response` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`Headers` are a way for the client and server to communicate extra information
    about the request and response. Think about them as meta data about the data being
    sent back and forth.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a response includes gzip compressed data, the Content-Encoding
    header tells the browser so it can decompress the body. Before returning a compressed
    response, the server looks for a corresponding header, such as accept-encoding,
    telling it that the client can accept a compressed response.
  prefs: []
  type: TYPE_NORMAL
- en: The `Headers` object manages the headers list. Member methods provide the ability
    to manage headers associated with a request or response.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Headers can be added either in the constructor or via the `append` method.
    The following example uses the `Headers` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Headers can also be added using the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A final way to add headers is by using the `set` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The difference between `append` and `set` is the latter one will overwrite any
    existing values. While the `append` method adds the header value to the list of
    headers, the `append` method should be used for headers that allow multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: An example multiple-value header is Cache-Control. There are many combinations
    you may need to set to provide instructions to different clients and intermediaries.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the best way to manage cache on HTML assets with my CDN is to mark
    them as private, with a 3,600 seconds time to live. You may also include a value
    for CDN caching, maybe 300 seconds. This means my CDN will naturally invalidate
    after 300 seconds, reducing my need to force updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `append` method requires up to three calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set` method writes the final value, overwriting any previous value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Headers are a complex topic, so I recommend finding more resources if you need
    to dig deeper into specific headers and their values. Wikipedia is a good place
    to start ([https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields))
    as its page provides a very thorough list with details and further links to specifications.
  prefs: []
  type: TYPE_NORMAL
- en: There is a limit to the amount of headers you can manage. There are headers
    that are restricted to the browser and others that are restricted to the server,
    which means you are not allowed to change them.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to append or set an invalid header, an exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Header values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `get` method returns a specific headers value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entries` method returns an iterator you can use to loop through all the
    headers. Each entry is a simple array, with the first entry being the header key
    name and the second member being the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keys` method also provides an iterator, but only returns a list of header
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, you can get a list of values from the `values` method. The problem
    with this method is that the values are not directly correlated to their keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check if a header exists by calling the `has` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A header can be removed using the `delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Protected Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Headers have a guard property. This flag indicates if headers can be manipulated.
    If you try to manipulate a header whose guard is set to immutable, an exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the possible guard states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none`: Default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request`: Guard for a Headers object obtained from a Request (`Request.headers`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request-no-cors`: Guard for a Headers object obtained from a Request that''s
    been created with mode `no-cors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response`: Naturally, for Headers obtained from Response (`Response.headers`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`immutable`: Mostly used for ServiceWorkers; renders a `Headers` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual rules controlling how different headers can be manipulated is very
    detailed. If you want to know more about these details, I recommend reading the
    Fetch specification ([https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Body mixin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Request` and `Response` objects both have a `body` property. This is actually
    a mixin or a class that implements the body interface. The body contains a data
    stream with methods to retrieve the contents according to the type.
  prefs: []
  type: TYPE_NORMAL
- en: Each `body` method reads the stream and converts it into the desired format.
    The stream is completely read and a `promise` is returned, resolving to the formatted
    data.
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen how to use the `json()` method to read JSON formatted
    data. There is also the `text`, `blob`, `formData`, and `arrayBuffer` methods.
    Each one resolves the body to the corresponding format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To review how to use JSON formatted data, let''s see how to retrieve search
    results in the Podstr application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `json()` mixin is available as a method of the response. That's
    because each of the body mixins implements the Body interface and are added to
    the Response object.
  prefs: []
  type: TYPE_NORMAL
- en: The mixin returns a promise, resolving the JSON object. Remember, you cannot
    directly use the return value of the body mixins because they return a promise.
    You need to process the formatted data in a promise handler, which is the `then`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: JSON may be the most common format used by modern APIs, but there are times
    when you retrieve other formats – the simplest being plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetching plain text looks almost identical to fetching JSON. Instead of using
    the json mixin, use the `text` mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to fetch an audio file (`ogg` format) and buffer
    the data to an `AudioContext` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have seen how to use a response body, but you can also set the body
    in a request. A common scenario is posting form data.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how to POST the contact form as a JSON object. The method
    is set to `'post'` and custom headers are supplied. The custom headers tell the
    server you are sending a JSON formatted body with the `Content-Type` header. You
    are also telling the server (the `Accept` header) that you expect a JSON object
    back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form is serialized or converted to a JSON object in the `serializeForm`
    method (not shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also post the raw form using the `FormData` object ([https://developer.mozilla.org/en-US/docs/Web/API/FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)).
    Make sure that the API you are posting to can handle the form data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The last aspect of the body you need to know about is the `bodyUsed` property.
    This can be checked to see if you can still use the body or not. A body can only
    be read once.
  prefs: []
  type: TYPE_NORMAL
- en: The body is a stream, which is a forward only set of data. Attempting to read
    the body more than once results in an exception being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to read or use a body more than once, you should clone the request
    or response. A common scenario is when a service worker fetches a URL and caches
    the response while returning the response to the client. You will see this in
    more detail in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Response object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `response` object is almost identical to the `request` object. It is created
    when a request receives an answer from the server. Response objects also have
    headers and a body, the same object types as `request` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Responses are normally created by the platform when a response is received from
    the server. However, you can create a new response. This is more common when you
    want to transform a response.
  prefs: []
  type: TYPE_NORMAL
- en: A scenario I have dealt with is accessing data from an older API that returned
    flat data. The flat data needed to be transformed into a multi-dimensional JSON
    object. Instead of repeating that CPU intensive process, I transformed the data
    and cached the transformed response.
  prefs: []
  type: TYPE_NORMAL
- en: The Response constructor has two parameters, a Body object and an initialization
    object. We have already gone over Body objects in [Chapter 4](part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d),
    *Service Workers – Notification, Synchronization, and Our Podcast App*. The Response
    initialization object is slightly different than the `request` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Response object properties that differ from the `request` object are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`status`: The status code for the reponse, for example, `200`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statusText`: The status message associated with the status code, for example, `OK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: Any headers you want to add to your response, contained within a
    Headers object or object literal of `ByteString` key/value pairs (see HTTP headers
    for a reference)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are only three properties, one being a Headers object. The other two properties
    indicate the HTTP status. There is a code, status, and a text value, statusText.
  prefs: []
  type: TYPE_NORMAL
- en: Response properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the Response object properties are similar to a `request` object, most
    notably the Body and its mixins.
  prefs: []
  type: TYPE_NORMAL
- en: The `isRedirected` property indicates if the response is the product of a redirected
    (HTTPS status code `301` or `302`) response.
  prefs: []
  type: TYPE_NORMAL
- en: The type property is `readonly`, and tells us if the response had a network
    error (error), opaque (cross-origin with a no-cors request, cors, and basically
    inidicates a successful response.
  prefs: []
  type: TYPE_NORMAL
- en: The `url` property is the final response URL, after any redirects.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a successful response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, fetch does not throw an exception or return an error
    if the response status is not 200\. Instead, as long as fetch receives a response,
    it does not fail. It is still up to you to interrogate the response status to
    determine how you want to process the response.
  prefs: []
  type: TYPE_NORMAL
- en: The `ok` property is true if the status code is 200-299, and false otherwise.
    It can be a quick way to verify a request's success. Just be careful, as sometimes
    you can receive a 0 status code for cached, cross-origin responses.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, many requests can have a range of successful status codes. HTTP
    status codes are grouped by 100s. 200-299 indicates a successful response, while
    300-399 indicates a redirect and is accompanied by a new address. `400` indicates
    that the URL is not accessible, `404` being the most well-known. Other reasons
    a resource is not accessible have to do with authorization or permission to access
    the resource. Finally, anything in the 500 range indicates that there is a server-side
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Having a strategy to handle different statuses is important for the success
    of your application. Checking the `response.ok` value may not give you the entire
    story. I found that Chrome returns a status equal to 0 for external origin resources
    stored in the cache. The response is still successful, but limiting your logic
    to check for `response.ok` would lead to excess network requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the details of the Fetch API, it's time to start learning
    how the Cache API works. The Cache API depends on the Fetch API because it caches
    request-response pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Caching responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been able to store content, including data and site assets using web
    storage and IndexedDB for several years. Using either medium requires a library
    or custom logic to manage site assets, which is why the service worker specification
    includes a specialized Cache API.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache interface provides a managed storage mechanism for Request/Response
    object pairs. These objects are also referred to as network addressable resources,
    but you can think about them as just files or API responses.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache API has a natural advantage over `IndexedDB` and `localStorage` because
    it is designed to abstract, persisting these assets by the `Request` and `Response`
    objects. This means that you can reference the assets using more than just a single
    key value, like `localStorage` provides.
  prefs: []
  type: TYPE_NORMAL
- en: Besides providing a managed interface to store assets, it also allows you to
    organize those assets into groups or caches. As we progress through the remaining
    chapters, you will see how to use this power to segregate the assets to make updating
    and invalidating easier.
  prefs: []
  type: TYPE_NORMAL
- en: Caches, like other browser storage services, are managed by the browser by origin,
    or domain. This prevents third parties from accessing the content that's stored
    your site. Your overall storage quota is also tied to the origin and allocated
    across the various storage services.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of space available varies by device and is proportional to the available
    disk space. Like income tax, the rule governing your quota allowance varies by
    the amount of available space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ali Alabbas shared the following slide at the Microsoft Edge Developer Summit,
    explaining the rules governing storage quotas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If space becomes limited, the browser will arbitrarily purge stored data from
    the different storage providers. Unless you manage this process, you have no guarantee
    that your assets have remained cached.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache API is part of the service worker specification because it is the
    backbone to make your progressive web application work offline. Without the ability
    to save assets for immediate access, your site could not work offline.
  prefs: []
  type: TYPE_NORMAL
- en: Caches object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Caches` object represents a collection of named caches and members to interact
    with those caches. The interface provides methods to open, create, iterate, and
    remove individual caches. You can also match cached responses over all the named
    caches without interrogating each one.
  prefs: []
  type: TYPE_NORMAL
- en: caches.open
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `caches.open` method returns a reference to a cache matching the name that''s
    supplied. This reference is a `Cache` object, which is detailed in later sections.
    If a cache matching the name does not exist, a new cache is provisioned. This
    returns a promise; resolving a cache object allows you to manage cached responses
    in that cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: caches.match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `caches.match` method is a convivence method that works similarly to the
    `cache.match` method. It returns a promise that resolves to the first cached response
    matching the `Request` object passed to the method.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about the `caches.match` method is how it handles interrogating
    all named caches for a match. It returns the first match it finds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if matching responses are stored in different caches, you have
    no control over which response is found. To avoid a scenario where an invalid
    response is matched, you need to ensure that your logic invalidates outdated cached
    responses before caching an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: caches.has()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to check if a named cache exists, the `has` method returns a promise,
    resolving true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: caches.delete()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete` method searches for a cache matching the name supplied. If a matching
    cache is found, it is deleted. A promise is returned that resolves true if a matching
    cache was deleted or false if one was not deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You don't always need to add code to handle the response. Typically, you would
    log the activity. If no cache was deleted, it is most likely due to the cache
    not existing, which in that case you probably have nothing to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: You should also note that if you delete a cache, all of the cached items are
    deleted along with it.
  prefs: []
  type: TYPE_NORMAL
- en: caches.keys()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `keys` method returns a promise with an array of names (strings) for each
    named cache. This list can be iterated over for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is placed within the service worker activate event handler.
    It removes caches that were crafted for a previous service worker version. This
    concept was covered in [Chapter 5](part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d),
    *The Service Worker Life Cycle*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `delete` method does not have any processing after a cache is deleted.
    If you wanted to log any problems regarding deleting a cache, you could do that
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cache interface is a collection of methods and properties to manage stored
    responses. You cannot create a cache object; you must open a reference to a cache
    using the `Caches.open` method, which will be covered later. This reference is
    an instance of the Cache object, giving you access to the responses it manages.
  prefs: []
  type: TYPE_NORMAL
- en: cache.match()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `match` method has two parameters, a `request` object and an optional options
    object. It returns a promise if a matching response is found to be resolved in
    the promise's return. If no response was found, the promise still resolves, but
    as undefined.
  prefs: []
  type: TYPE_NORMAL
- en: If no match was found, you can then continue with the appropriate logic, like
    forwarding the request to the network or returning a fallback response.
  prefs: []
  type: TYPE_NORMAL
- en: The `request` object parameter can be either a valid `request` object or a URL.
    If only a URL is provided, the method does an implicit conversion internally.
    Supplying a `request` object gives you more control because different responses
    could be cached by request variations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the same URL might have a cached response for both `HEAD` and `GET`
    methods, each being unique. Differing `QueryStrings` is another common example
    where similar URLs have different responses cached.
  prefs: []
  type: TYPE_NORMAL
- en: The optional `options` parameter allows you to provide more details to the `match`
    method about the specific request you want to match. You can think of it as a
    way of filtering potential matches.
  prefs: []
  type: TYPE_NORMAL
- en: The `options` object has a set of potential properties you can provide a value
    to match or filter against.
  prefs: []
  type: TYPE_NORMAL
- en: 'The potential options that are available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ignoreSearch`: Indicates if you want to use the `QueryString` or not. The
    options are true or false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreMethod`: Indicates if you want to filter by the `request` method, for
    example GET, POST, DELETE, and so on. By default, match does use the request method
    to match a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreVary`: When set to true, headers are ignored when retrieving a match.
    The URL is used as the filter, which means cached responses for different header
    combinations could match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cacheName`: This limits matching responses to a specific cache name. Multiple
    responses could be cached across different named caches, but this specifies which
    cache should be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For most queries, you won''t use these options because they are highly specialized.
    `ignoreSearch` has the most potential to be used because `QueryString` parameters
    are very common. Servers typically return different responses based on how these
    values vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: cache.matchAll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `match` method, the `matchAll()` method takes request and options
    (optional) parameters. The method returns a promise that resolves an array of
    matching responses. Unlike the same method on the Caches object, it only returns
    matches in the specifically named cache.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between `matchAll` and match is that the `match` method
    returns the first response it matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matchAll` method is useful when you need to match responses using a route,
    not just a specific URL. For example, if you want to get a list of all a podcast''s
    banner images, you could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Cache add and addAll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to retrieve an asset and immediately cache the response, the `add`
    and `addAll` methods manage this process. The `add` method is equivalent to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `add` and `addAll` methods have a single parameter: a `request` object.
    Like the `match` method, you can also supply a valid URL and the method will convert
    it into a `request` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Both methods return a promise, but do not resolve a value. As long as there
    were no exceptions making and caching the requests, you can use the resolution
    to continue the application workflow. If there was an exception, you can catch
    and handle it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The add methods are useful in the install and activate life cycle events because
    you can provide a list of URLs to precache. You are not limited to these scenarios,
    as they can be called anytime.
  prefs: []
  type: TYPE_NORMAL
- en: They are not helpful during most caching strategies, which are initiated by
    the fetch event handler. We will go over many of these strategies in the following
    chapter. When handling real-time fetches, the network response is typically needed
    to render a page. These methods do not return access to the responses.
  prefs: []
  type: TYPE_NORMAL
- en: cache.put
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite what you might think, the `add` method do not let you cache a response
    directly. If you receive a network response from a fetch call, you would need
    to explicitly handle its caching. This is where the `put` method gives you the
    control needed to cache a response with the flexibility to use the response in
    parallel to the caching process.
  prefs: []
  type: TYPE_NORMAL
- en: As you will learn in the next chapter, there are many different caching strategies
    where a network response is cached once the network request resolves.
  prefs: []
  type: TYPE_NORMAL
- en: The `put` method has two parameters, `request` and `response`. These are the
    same `Request` and `Response` objects that were covered in the *Fetch* section.
  prefs: []
  type: TYPE_NORMAL
- en: The `put` method uses these two objects to catalog the assets in a key value
    fashion, sort of like localStorage, just specialized for caching page assets.
  prefs: []
  type: TYPE_NORMAL
- en: The `put` method returns a promise, but does not resolve a value.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use the response, you should clone it before caching. A response
    body can only be used once, but the `response` object has a `clone` method that
    creates a copy. I typically cache the copy and return the original, but it does
    not matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to fetch a resource, clone the response,
    cache the clone, and return the original response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Deleting Cached items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are also responsible for periodically purging cache entries. The browser
    will not invalidate cache for you. It might purge items if available space becomes
    limited. However, I would not worry about this scenario. Instead, you need a plan
    to delete cached assets so that you can control how long an item is cached for.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to manage or invalidate cached assets is to apply a set of rules
    to control your cache. [Chapter 8](part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d), *Applying
    Advanced Service Worker Cache Strategies*, goes into more detail about invalidation
    strategies. Before you reach that level, it's important to know how to remove
    an asset or delete an entire cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` method returns a promise that resolves true if a matching response
    was found and deleted, otherwise it returns false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method has two parameters, a request and an optional options object. The
    options are the same ones that are used in the match method. This is because you
    can cache multiple responses to a URL if there are different request variations
    using those options.
  prefs: []
  type: TYPE_NORMAL
- en: cache.keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cache object's `key` method returns a promise that resolves an array of
    requests that are stored in the cache. The method has two optional parameters,
    request and options. These are the same two types we have seen for the other methods.
  prefs: []
  type: TYPE_NORMAL
- en: When supplying these parameters, the `keys` method works much like the match
    and `matchAll` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array of keys or requests can then be used to update your cache. For example,
    you could loop through and delete all matches or maybe do a silent background
    update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The keys are returned in insertion order. This can come in handy if you want
    to manage cache invalidation by removing the oldest pair(s) first. We'll review
    some cache invalidation strategies in the later chapters. You will see how this
    can be done along with some other strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how the Fetch and Cache APIs are critical for the service
    workers. To get the most out of service workers, you need to be able to intercept
    and manipulate requests and the server responses. Because service workers rely
    on asynchronous functions (Promises), you must use Fetch, as a new replacement
    for `XMLHttpRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: The Cache API provides a new storage medium in the browser, which is highly
    specialized for request/response pairs. The API is a rich platform, providing
    the maximum amount of control over network resources.
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to use the best logic and platform resources to make your website
    load quickly and work offline. Now that you know how the Fetch and Cache APIs
    work, it's time to start crafting the best caching system you can.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review different caching patterns and start seeing
    how they can be applied so that you can determine what strategy you should employ
    in your applications.
  prefs: []
  type: TYPE_NORMAL
