- en: Chapter 8. Classes and Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore some of the most interesting features introduced
    in ES6\. JavaScript is a prototype-based language and supports prototypical inheritance.
    In the previous chapter, we discussed the prototype property of an object and
    how prototypical inheritance works in JavaScript. ES6 brings in classes. If you
    are coming from traditional object-oriented languages such as Java, you will immediately
    relate to the well-known concepts of classes. However, they are not the same in
    JavaScript. Classes in JavaScript are a syntactic sugar over the prototypical
    inheritance we discussed in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a detailed look at ES6 classes and modules - these
    are welcome changes to this edition of JavaScript and make **Object Oriented Programming**
    (**OOP**) and inheritance significantly easier.
  prefs: []
  type: TYPE_NORMAL
- en: If you are coming from a traditional object-oriented language, prototypical
    inheritance may feel a bit out of place for you. ES6 classes offer a more traditional
    syntax for you to get familiarized with prototypical inheritance in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Before we try and delve deeper into classes, let me show you why you should
    use the ES6 classes syntax over the prototypical inheritance syntax of ES5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this snippet, I am creating a class hierarchy of `Person`, `Employee`, and
    `Engineer`, pretty straightforward. First, we will see the ES5 prototypical inheritance,
    which is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at the equivalent code using the ES6 classes syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you observe the two preceding code snippets, it will be obvious to you that
    the second example is pretty neat. If you already know Java or C#, you will feel
    right at home. However, one important thing to remember is that classes do not
    introduce any new object-oriented inheritance model to the language, but bring
    in a much nicer way to create objects and handle inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the hood, classes are special functions. Just like you can define functions
    using function expressions and declarations, you can define classes as well. One
    way to define classes is using class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `class` keyword and the name of the class. This syntax is very
    similar to that of Java or C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To establish the fact that classes are a special function, if we get the `typeof`
    the `Car` class, we will get a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important distinction between classes and normal functions. While
    normal functions are hoisted, classes are not. A normal function is available
    immediately when you enter a scope in which it is declared; this is called **hoisting**,
    which means that a normal function can be declared anywhere in the scope, and
    it will be available. However, classes are not hoisted; they are available only
    after they are declared. For a normal function, you can say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you cannot use the class before declaring it, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The other way to define a class is to use a class expression. A class expression,
    like a function expression, may or may not have a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows an anonymous class expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you name the class expression, the name is local to the class''s body and
    not available outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, here, we will give a name to the `Car` class. This name is available
    within the body of the class, but when we try to access it outside the class,
    we get a reference error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot use commas while separating members of a class. Semicolons are valid
    though. This is funny as ES6 ignores semicolons and there is a raging debate about
    using semicolons in ES6\. Consider the following code snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once defined, we can use classes via a `new` keyword and not a function call;
    here''s the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the `constructor` function in the examples so far. A constructor
    is a special method used to create and initialize an object created with the class.
    You can have only one constructor in a class. Constructors are a bit different
    from the normal constructor functions. Unlike normal constructors, a class constructor
    can call its parent class constructor via `super()`. We will discuss this in detail
    when we look at inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prototype methods are prototype properties of the class, and they are inherited
    by instances of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype methods can also have `getter` and `setter` methods. The syntax of
    getters and setters is the same as ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, computed properties are also supported. You can define the name
    of the method using the expression. The expression needs to be put inside square
    brackets. We discussed this shorthand syntax in earlier chapters. The following
    are all equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static methods are associated with the class and not with an instance of that
    class (object). In other words, you can only reach a static method using the name
    of the class. Static methods are invoked without instantiating the class and they
    cannot be called on an instance of a class. Static methods are popular in creating
    utility or helper methods. Consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Static properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may ask-well, we have static methods, what about static properties? In the
    hurry of getting ES6 ready, they did not add static properties. They will be added
    in future iterations of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Generator methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed hugely useful generator functions a few chapters back. You can
    add generator functions as part of class, and they are called generator methods.
    A generator method is useful because you can define their key as `Symbol.iterator`.
    The following example shows how generator methods can be defined inside a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Subclassing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we discussed how to declare classes and the types of members classes
    can support. A major use of a class is to serve as a template to create other
    subclasses. When you create a child class from a class, you derive properties
    of the parent class and extend the parent class by adding more features of its
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following de facto example of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Animal` is the base class and the `Cat` class is derived from the class
    `Animal`. The extend clause allows you to create a subclass of an existing class.
    This example demonstrates the syntax of subclassing. Let''s enhance this example
    a bit more by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the `super` keyword to call functions from the parent class.
    The following are the three ways in which the `super` keyword can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `super (<params>)` as a function call to invoke the constructor
    of the parent class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `super.<parentClassMethod>` to access the parent class methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `super.<parentClassProp>` to access the parent class properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the derive class constructor, you must call the `super()` method before
    you can use,  `this` keyword; for example, the following piece of code will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can''t implicitly leave a derived constructor with a `super()` method as
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t provide a constructor for the base class, the following constructor
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For the derived classes, the default constructor is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript supports only single inheritance. At most, a class can have one superclass.
    This is limiting when you want to create class hierarchies but also want to inherit
    tool methods from different sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a scenario where we have a `Person` class, and we create
    a subclass, `Employee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to inherit functions from two utility classes, `BackgroundCheck`-this
    class does employee background checks-and `Onboard`-this class handles employee
    onboarding processes, such as printing badges and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both `BackgroundCheck` and `Onboard` classes are templates, and their functionality
    will be used multiple times. Such templates (abstract subclasses) are called mixins.
  prefs: []
  type: TYPE_NORMAL
- en: 'As multiple inheritance is not possible in JavaScript, we will employ a different
    technique to achieve this. A popular way of implementing mixins in ES6 is to write
    a function with a superclass as an input and a subclass extending that superclass
    as the output, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This essentially means that `Employee` is a subclass of `BackgroundCheck`, which
    in turn is a subclass of `Onboard`, which in turn is a subclass of `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript modules are not new. In fact, there were have been libraries that
    support modules for some time now. ES6, however, offers built-in modules. Traditionally,
    JavaScript's major use was on browsers, where most of the JavaScript code was
    either embedded or small enough to manage without much trouble. Things have changed.
    JavaScript projects are now on a massive scale. Without an efficient system of
    spreading the code into files and directories, managing code becomes a nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 modules are files. One module per file and one file per module. There is
    no module keyword. Whatever code you write in the module file is local to the
    module unless you export it. You may have a bunch of functions in a module, and
    you want to export only a few of them. You can export module functionality in
    a couple of ways.
  prefs: []
  type: TYPE_NORMAL
- en: The first way is to use the `export` keyword. You can export any top-level `function`,
    `class`, `var`, `let`, or `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a module inside `server.js` where we export a `function`,
    a `class`, and a `const`. We don''t export the `processConfig()` function, and
    any file importing this module won''t be able to access the unexported function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Any code that has access to `server.js` can import the exported functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, another JavaScript file is importing `Config` and `startServer`
    from the `server` module (with the corresponding JavaScript file `server.js`,
    we drop the file extension).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also import everything that was exported from the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have only one thing to export, you can use the default export syntax.
    Consider the following piece of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will keep the class anonymous as we can use the module name
    itself as the reference outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before ES6 modules, external libraries supported several approaches to modules.
    They established fairly good guidelines/styles for ES6 to follow. The following
    style is followed by ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules are singletons. A module is imported only once, even if you try to import
    it several times in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable, functions, and other type of declarations are local to the module.
    Only declarations marked with `export` are available outside the module for `import`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modules can import from other modules. The following are the three options
    for referring to other modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use relative paths `("../lib/server");` these paths are resolved relatively
    to the file importing the module. For example, if you are importing the module
    from `<project_path>/src/app.js`, and the module file is located at `<project_path>/lib/server.js`,
    you will need to provide a path relative to the `app.js` - `../lib/server` in
    this case.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute paths can also point to the module file directly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can drop the file `.js` extension while importing the module.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we go into more details of the ES6 module system, we need to understand
    how ES5 supported them via external libraries. ES5 has two non-compatible module
    systems, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CommonJS**: This is the dominant standard as Node.js adopted it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AMD** (**Asynchronous Module Definition**): This is slightly more complicated
    than CommonJS and designed for asynchronous module loading, and targeted toward
    browsers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES6 modules were aimed to be easy to use for engineers coming from any of these
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Export lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of tagging each exported function or class from your module with the
    `export` keyword, you can write a single list of all the things you want to export
    from the module, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the module is the list of exports. You can have multiple `export`
    lists in the module file and the list can appear anywhere in the file. You can
    also have a mix of `export` list and `export` declarations in the same module
    file, but you can `export` one name only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a large project, there are cases when you encounter name conflicts. Suppose
    you import two modules, and both of them export a function with the same name.
    In such cases, you can rename the imports as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, both the imported modules exported a name, `trunc`, and hence created
    a conflict of names. We can alias them to resolve this conflict.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do the renaming while exporting as well, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you are already using ES5 module systems, ES6 modules may look redundant.
    However, it was very important for the language to have support for such an important
    feature. ES6 module syntax is also standardized and more compact than the other
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on understanding ES6 classes. ES6 classes give formal
    support to the common JavaScript pattern of simulating class-like inheritance
    hierarchies using functions and prototypes. They are syntactic sugaring over prototype-based
    OO, offering a convenient declarative form for class patterns which encourage
    interoperability. ES6 classes offer a much nicer, cleaner, and clearer syntax
    for creating these objects and dealing with inheritance. ES6 classes provide support
    for constructors, instance and static methods, (prototype-based) inheritance,
    and super calls.
  prefs: []
  type: TYPE_NORMAL
- en: So far, JavaScript lacked one of the most basic features - modules. Before ES6,
    we wrote modules using either CommonJS or AMD. ES6 brings modules into JavaScript
    officially. In this chapter, we took a detailed look at how modules are used in
    ES6.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter focuses on another interesting addition to ES6 - proxies and
    promises.
  prefs: []
  type: TYPE_NORMAL
