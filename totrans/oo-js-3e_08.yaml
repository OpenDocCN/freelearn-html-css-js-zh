- en: Chapter 8. Classes and Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。类和模块
- en: In this chapter, we will explore some of the most interesting features introduced
    in ES6\. JavaScript is a prototype-based language and supports prototypical inheritance.
    In the previous chapter, we discussed the prototype property of an object and
    how prototypical inheritance works in JavaScript. ES6 brings in classes. If you
    are coming from traditional object-oriented languages such as Java, you will immediately
    relate to the well-known concepts of classes. However, they are not the same in
    JavaScript. Classes in JavaScript are a syntactic sugar over the prototypical
    inheritance we discussed in the last chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 ES6 中引入的一些最有趣的功能。JavaScript 是一种基于原型的语言，支持原型继承。在前一章中，我们讨论了对象的原型属性以及
    JavaScript 中的原型继承是如何工作的。ES6 引入了类。如果你来自传统的面向对象语言，如 Java，你会立即联想到类的一些众所周知的概念。然而，在
    JavaScript 中它们并不相同。JavaScript 中的类是我们在上一章讨论的原型继承之上的语法糖。
- en: In this chapter, we will take a detailed look at ES6 classes and modules - these
    are welcome changes to this edition of JavaScript and make **Object Oriented Programming**
    (**OOP**) and inheritance significantly easier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨 ES6 类和模块——这些是 JavaScript 版本中的受欢迎的改进，使得**面向对象编程**（**OOP**）和继承变得显著更容易。
- en: If you are coming from a traditional object-oriented language, prototypical
    inheritance may feel a bit out of place for you. ES6 classes offer a more traditional
    syntax for you to get familiarized with prototypical inheritance in JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自传统的面向对象语言，原型继承可能对你来说有点格格不入。ES6 类为你提供了一个更传统的语法，以便你熟悉 JavaScript 中的原型继承。
- en: Before we try and delve deeper into classes, let me show you why you should
    use the ES6 classes syntax over the prototypical inheritance syntax of ES5.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试深入探讨类之前，让我先展示一下为什么你应该使用 ES6 类语法而不是 ES5 的原型继承语法。
- en: 'In this snippet, I am creating a class hierarchy of `Person`, `Employee`, and
    `Engineer`, pretty straightforward. First, we will see the ES5 prototypical inheritance,
    which is written as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我正在创建一个 `Person`、`Employee` 和 `Engineer` 的类层次结构，相当直接。首先，我们将看到 ES5 原型继承，其写法如下：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s look at the equivalent code using the ES6 classes syntax:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用 ES6 类语法等效的代码：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you observe the two preceding code snippets, it will be obvious to you that
    the second example is pretty neat. If you already know Java or C#, you will feel
    right at home. However, one important thing to remember is that classes do not
    introduce any new object-oriented inheritance model to the language, but bring
    in a much nicer way to create objects and handle inheritance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察前两个代码片段，你会明显感觉到第二个例子相当整洁。如果你已经熟悉 Java 或 C#，你会感到非常自在。然而，有一件重要的事情需要记住，类并没有向语言引入任何新的面向对象继承模型，而是带来了一种创建对象和处理继承的更优雅的方式。
- en: Defining classes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: Under the hood, classes are special functions. Just like you can define functions
    using function expressions and declarations, you can define classes as well. One
    way to define classes is using class declaration.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，类是特殊的函数。就像你可以使用函数表达式和声明来定义函数一样，你也可以定义类。定义类的一种方法就是使用类声明。
- en: 'You can use the `class` keyword and the name of the class. This syntax is very
    similar to that of Java or C#:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `class` 关键字和类的名称。这种语法与 Java 或 C# 非常相似：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To establish the fact that classes are a special function, if we get the `typeof`
    the `Car` class, we will get a function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明类是特殊的函数，如果我们获取 `Car` 类的 `typeof`，我们会得到一个函数。
- en: 'There is an important distinction between classes and normal functions. While
    normal functions are hoisted, classes are not. A normal function is available
    immediately when you enter a scope in which it is declared; this is called **hoisting**,
    which means that a normal function can be declared anywhere in the scope, and
    it will be available. However, classes are not hoisted; they are available only
    after they are declared. For a normal function, you can say:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类和普通函数之间存在一个重要的区别。虽然普通函数是提升的，但类不是。一个普通函数在你进入其声明的范围时立即可用；这被称为**提升**，这意味着普通函数可以在作用域的任何位置声明，并且它将是可用的。然而，类不是提升的；它们只有在声明之后才可用。对于一个普通函数，你可以这样说：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, you cannot use the class before declaring it, for example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能在声明之前使用类，例如：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other way to define a class is to use a class expression. A class expression,
    like a function expression, may or may not have a name.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类的另一种方式是使用类表达式。类表达式，就像函数表达式一样，可以有名字也可以没有名字。
- en: 'The following example shows an anonymous class expression:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了匿名类表达式：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you name the class expression, the name is local to the class''s body and
    not available outside:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给类表达式命名，该名字是局部于类的主体，且在类外部不可用：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, here, we will give a name to the `Car` class. This name is available
    within the body of the class, but when we try to access it outside the class,
    we get a reference error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里我们将给 `Car` 类起一个名字。这个名字在类的主体内部是可用的，但当我们尝试在类外部访问它时，会得到一个引用错误。
- en: 'You cannot use commas while separating members of a class. Semicolons are valid
    though. This is funny as ES6 ignores semicolons and there is a raging debate about
    using semicolons in ES6\. Consider the following code snippet as an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在分隔类的成员时，你不能使用逗号。虽然分号是有效的。这很有趣，因为 ES6 忽略分号，并且关于在 ES6 中使用分号存在激烈的争论。以下代码片段可以作为示例：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once defined, we can use classes via a `new` keyword and not a function call;
    here''s the example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，我们可以通过 `new` 关键字使用类，而不是函数调用；以下是一个示例：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Constructor
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: We have used the `constructor` function in the examples so far. A constructor
    is a special method used to create and initialize an object created with the class.
    You can have only one constructor in a class. Constructors are a bit different
    from the normal constructor functions. Unlike normal constructors, a class constructor
    can call its parent class constructor via `super()`. We will discuss this in detail
    when we look at inheritance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在示例中使用了 `constructor` 函数。构造函数是一种特殊的方法，用于使用类创建和初始化对象。一个类中只能有一个构造函数。构造函数与普通的构造函数函数有点不同。与普通构造函数不同，类构造函数可以通过
    `super()` 调用其父类构造函数。我们将在讨论继承时详细讨论这一点。
- en: Prototype methods
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型方法
- en: Prototype methods are prototype properties of the class, and they are inherited
    by instances of the class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原型方法是类的原型属性，并且它们被类的实例继承。
- en: 'Prototype methods can also have `getter` and `setter` methods. The syntax of
    getters and setters is the same as ES5:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 原型方法也可以有 `getter` 和 `setter` 方法。getter 和 setter 的语法与 ES5 相同：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, computed properties are also supported. You can define the name
    of the method using the expression. The expression needs to be put inside square
    brackets. We discussed this shorthand syntax in earlier chapters. The following
    are all equivalent:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，计算属性也得到了支持。您可以使用表达式来定义方法的名字。表达式需要放在方括号内。我们已经在前面的章节中讨论了这种简写语法。以下都是等效的：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Static methods
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'Static methods are associated with the class and not with an instance of that
    class (object). In other words, you can only reach a static method using the name
    of the class. Static methods are invoked without instantiating the class and they
    cannot be called on an instance of a class. Static methods are popular in creating
    utility or helper methods. Consider the following piece of code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法与类相关联，而不是与该类的实例（对象）相关联。换句话说，你只能通过类的名字来访问静态方法。静态方法在实例化类之前被调用，并且不能在类的实例上调用。静态方法在创建实用或辅助方法时很受欢迎。以下是一段代码示例：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Static properties
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态属性
- en: You may ask-well, we have static methods, what about static properties? In the
    hurry of getting ES6 ready, they did not add static properties. They will be added
    in future iterations of the language.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问——我们已经有静态方法了，静态属性怎么办？在匆忙准备 ES6 的过程中，他们没有添加静态属性。它们将在语言的未来迭代中添加。
- en: Generator methods
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器方法
- en: 'We discussed hugely useful generator functions a few chapters back. You can
    add generator functions as part of class, and they are called generator methods.
    A generator method is useful because you can define their key as `Symbol.iterator`.
    The following example shows how generator methods can be defined inside a class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几章之前讨论了非常有用的生成器函数。您可以将生成器函数作为类的一部分添加，它们被称为生成器方法。生成器方法很有用，因为您可以将它们的键定义为 `Symbol.iterator`。以下示例展示了如何在类内部定义生成器方法：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Subclassing
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类化
- en: So far, we discussed how to declare classes and the types of members classes
    can support. A major use of a class is to serve as a template to create other
    subclasses. When you create a child class from a class, you derive properties
    of the parent class and extend the parent class by adding more features of its
    own.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何声明类以及类可以支持成员类型。类的主要用途是作为一个模板来创建其他子类。当你从一个类创建子类时，你继承了父类的属性，并通过添加更多自己的特性来扩展父类。
- en: 'Let''s look at the following de facto example of inheritance:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于继承的实际情况示例：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `Animal` is the base class and the `Cat` class is derived from the class
    `Animal`. The extend clause allows you to create a subclass of an existing class.
    This example demonstrates the syntax of subclassing. Let''s enhance this example
    a bit more by writing the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Animal` 是基类，`Cat` 类是从 `Animal` 类派生出来的。扩展子句允许你创建现有类的子类。以下示例演示了子类化的语法。让我们通过以下代码进一步扩展这个示例：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we are using the `super` keyword to call functions from the parent class.
    The following are the three ways in which the `super` keyword can be used:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `super` 关键字来调用父类的函数。以下是通过 `super` 关键字可以使用的三种方式：
- en: You can use `super (<params>)` as a function call to invoke the constructor
    of the parent class
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `super (<params>)` 作为函数调用来调用父类的构造函数
- en: You can use `super.<parentClassMethod>` to access the parent class methods
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `super.<parentClassMethod>` 来访问父类方法
- en: You can use `super.<parentClassProp>` to access the parent class properties
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `super.<parentClassProp>` 来访问父类的属性
- en: 'In the derive class constructor, you must call the `super()` method before
    you can use,  `this` keyword; for example, the following piece of code will fail:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类构造函数中，你必须在使用 `this` 关键字之前调用 `super()` 方法；例如，以下代码将失败：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can''t implicitly leave a derived constructor with a `super()` method as
    an error:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能隐式地从一个带有 `super()` 方法的派生构造函数中退出，否则会出错：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you don''t provide a constructor for the base class, the following constructor
    is used:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为基类提供构造函数，将使用以下构造函数：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the derived classes, the default constructor is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于派生类，默认构造函数如下：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Mixins
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混入
- en: JavaScript supports only single inheritance. At most, a class can have one superclass.
    This is limiting when you want to create class hierarchies but also want to inherit
    tool methods from different sources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 只支持单继承。一个类最多只能有一个超类。当你想要创建类层次结构并从不同来源继承工具方法时，这会有限制。
- en: 'Let''s say we have a scenario where we have a `Person` class, and we create
    a subclass, `Employee`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个场景，其中有一个 `Person` 类，我们创建一个子类 `Employee`：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also want to inherit functions from two utility classes, `BackgroundCheck`-this
    class does employee background checks-and `Onboard`-this class handles employee
    onboarding processes, such as printing badges and so on:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望从两个实用类中继承函数，`BackgroundCheck` - 这个类负责员工的背景调查 - 和 `Onboard` - 这个类处理员工的入职流程，例如打印胸牌等：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both `BackgroundCheck` and `Onboard` classes are templates, and their functionality
    will be used multiple times. Such templates (abstract subclasses) are called mixins.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundCheck` 和 `Onboard` 类都是模板，它们的功能将被多次使用。这样的模板（抽象子类）被称为混入。'
- en: 'As multiple inheritance is not possible in JavaScript, we will employ a different
    technique to achieve this. A popular way of implementing mixins in ES6 is to write
    a function with a superclass as an input and a subclass extending that superclass
    as the output, for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 中不支持多重继承，我们将采用不同的技术来实现这一点。在 ES6 中实现混入的一个流行方法是将一个函数作为输入，将一个扩展该超类的子类作为输出，例如：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This essentially means that `Employee` is a subclass of `BackgroundCheck`, which
    in turn is a subclass of `Onboard`, which in turn is a subclass of `Person`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着 `Employee` 是 `BackgroundCheck` 的子类，而 `BackgroundCheck` 又是 `Onboard`
    的子类，`Onboard` 又是 `Person` 的子类。
- en: Modules
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: JavaScript modules are not new. In fact, there were have been libraries that
    support modules for some time now. ES6, however, offers built-in modules. Traditionally,
    JavaScript's major use was on browsers, where most of the JavaScript code was
    either embedded or small enough to manage without much trouble. Things have changed.
    JavaScript projects are now on a massive scale. Without an efficient system of
    spreading the code into files and directories, managing code becomes a nightmare.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块并不新鲜。实际上，一些库已经支持模块一段时间了。然而，ES6 提供了内置的模块。传统上，JavaScript 的主要用途是在浏览器上，其中大部分
    JavaScript 代码要么是内嵌的，要么足够小，不需要太多麻烦就可以管理。但现在情况变了。JavaScript 项目现在规模庞大。如果没有一个有效的系统将代码分散到文件和目录中，管理代码就会变得非常困难。
- en: ES6 modules are files. One module per file and one file per module. There is
    no module keyword. Whatever code you write in the module file is local to the
    module unless you export it. You may have a bunch of functions in a module, and
    you want to export only a few of them. You can export module functionality in
    a couple of ways.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块是文件。每个文件一个模块，每个模块一个文件。没有模块关键字。你可以在模块文件中编写的任何代码都是模块本地的，除非你导出它。你可能在模块中有一系列函数，但只想导出其中几个。你可以通过几种方式导出模块功能。
- en: The first way is to use the `export` keyword. You can export any top-level `function`,
    `class`, `var`, `let`, or `const`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用 `export` 关键字。你可以导出任何顶层 `function`、`class`、`var`、`let` 或 `const`。
- en: 'The following example shows a module inside `server.js` where we export a `function`,
    a `class`, and a `const`. We don''t export the `processConfig()` function, and
    any file importing this module won''t be able to access the unexported function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `server.js` 内部的模块，其中我们导出了一个 `function`、一个 `class` 和一个 `const`。我们没有导出
    `processConfig()` 函数，因此任何导入此模块的文件都无法访问未导出的函数：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Any code that has access to `server.js` can import the exported functionality:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以访问 `server.js` 的代码都可以导入导出的功能：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, another JavaScript file is importing `Config` and `startServer`
    from the `server` module (with the corresponding JavaScript file `server.js`,
    we drop the file extension).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，另一个 JavaScript 文件正在从 `server` 模块（对应 JavaScript 文件 `server.js`，我们省略了文件扩展名）导入
    `Config` 和 `startServer`。
- en: 'You can also import everything that was exported from the module:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以导入模块导出的所有内容：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you have only one thing to export, you can use the default export syntax.
    Consider the following piece of code as an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有一个要导出的东西，你可以使用默认导出语法。以下代码片段作为示例：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we will keep the class anonymous as we can use the module name
    itself as the reference outside.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将保持类匿名，因为我们可以使用模块名本身作为外部的引用。
- en: 'Before ES6 modules, external libraries supported several approaches to modules.
    They established fairly good guidelines/styles for ES6 to follow. The following
    style is followed by ES6:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 模块之前，外部库支持了多种模块方法。它们为 ES6 建立了相当好的指南/风格。ES6 遵循以下风格：
- en: Modules are singletons. A module is imported only once, even if you try to import
    it several times in your code.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是单例的。模块只导入一次，即使你在代码中尝试多次导入它。
- en: Variable, functions, and other type of declarations are local to the module.
    Only declarations marked with `export` are available outside the module for `import`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量、函数和其他类型的声明是模块本地的。只有标记了 `export` 的声明才可以在模块外部通过 `import` 使用。
- en: 'Modules can import from other modules. The following are the three options
    for referring to other modules:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块可以从其他模块导入。以下是指向其他模块的三个选项：
- en: You can use relative paths `("../lib/server");` these paths are resolved relatively
    to the file importing the module. For example, if you are importing the module
    from `<project_path>/src/app.js`, and the module file is located at `<project_path>/lib/server.js`,
    you will need to provide a path relative to the `app.js` - `../lib/server` in
    this case.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用相对路径 `("../lib/server");` 这些路径相对于导入模块的文件进行解析。例如，如果你从 `<project_path>/src/app.js`
    导入模块，而模块文件位于 `<project_path>/lib/server.js`，你需要提供相对于 `app.js` 的路径 - 在这种情况下是 `../lib/server`。
- en: Absolute paths can also point to the module file directly.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对路径也可以直接指向模块文件。
- en: You can drop the file `.js` extension while importing the module.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入模块时，你可以省略文件 `.js` 扩展名。
- en: 'Before we go into more details of the ES6 module system, we need to understand
    how ES5 supported them via external libraries. ES5 has two non-compatible module
    systems, which are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解 ES6 模块系统之前，我们需要了解 ES5 是如何通过外部库支持它们的。ES5 有两个不兼容的模块系统，如下所示：
- en: '**CommonJS**: This is the dominant standard as Node.js adopted it'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CommonJS**：这是Node.js采用的主导标准'
- en: '**AMD** (**Asynchronous Module Definition**): This is slightly more complicated
    than CommonJS and designed for asynchronous module loading, and targeted toward
    browsers'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AMD**（**异步模块定义**）：这比CommonJS稍微复杂一些，旨在用于异步模块加载，并针对浏览器设计'
- en: ES6 modules were aimed to be easy to use for engineers coming from any of these
    systems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块旨在使来自任何这些系统的工程师都能轻松使用。
- en: Export lists
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出列表
- en: 'Instead of tagging each exported function or class from your module with the
    `export` keyword, you can write a single list of all the things you want to export
    from the module, which are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必为模块中的每个导出的函数或类加上`export`关键字，你可以写一个包含所有你想从模块中导出的内容的单个列表，如下所示：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line of the module is the list of exports. You can have multiple `export`
    lists in the module file and the list can appear anywhere in the file. You can
    also have a mix of `export` list and `export` declarations in the same module
    file, but you can `export` one name only once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的第一行是导出列表。你可以在模块文件中有多个`export`列表，并且列表可以出现在文件的任何位置。你还可以在同一个模块文件中混合`export`列表和`export`声明，但只能导出一个名称一次。
- en: 'In a large project, there are cases when you encounter name conflicts. Suppose
    you import two modules, and both of them export a function with the same name.
    In such cases, you can rename the imports as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大项目中，有时会遇到名称冲突的情况。假设你导入了两个模块，并且它们都导出了一个同名函数。在这种情况下，你可以按照以下方式重命名导入：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, both the imported modules exported a name, `trunc`, and hence created
    a conflict of names. We can alias them to resolve this conflict.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，导入的两个模块都导出了一个名为`trunc`的名称，因此产生了名称冲突。我们可以通过别名来解决这个问题。
- en: 'You can do the renaming while exporting as well, which is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在导出时进行重命名，如下所示：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you are already using ES5 module systems, ES6 modules may look redundant.
    However, it was very important for the language to have support for such an important
    feature. ES6 module syntax is also standardized and more compact than the other
    alternatives.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在使用ES5模块系统，ES6模块可能看起来是多余的。然而，对于语言来说，支持这样一个重要的特性是非常关键的。ES6模块语法也是标准化的，并且比其他替代方案更紧凑。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on understanding ES6 classes. ES6 classes give formal
    support to the common JavaScript pattern of simulating class-like inheritance
    hierarchies using functions and prototypes. They are syntactic sugaring over prototype-based
    OO, offering a convenient declarative form for class patterns which encourage
    interoperability. ES6 classes offer a much nicer, cleaner, and clearer syntax
    for creating these objects and dealing with inheritance. ES6 classes provide support
    for constructors, instance and static methods, (prototype-based) inheritance,
    and super calls.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于理解ES6类。ES6类为使用函数和原型模拟类继承层次结构的常见JavaScript模式提供了正式支持。它们是原型基于的面向对象编程的语法糖，提供了一种方便的声明性形式，鼓励互操作性。ES6类为创建这些对象和处理继承提供了更优雅、更清晰、更简洁的语法。ES6类提供了对构造函数、实例和静态方法、（基于原型的）继承和super调用的支持。
- en: So far, JavaScript lacked one of the most basic features - modules. Before ES6,
    we wrote modules using either CommonJS or AMD. ES6 brings modules into JavaScript
    officially. In this chapter, we took a detailed look at how modules are used in
    ES6.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，JavaScript缺少了一个最基本的功能——模块。在ES6之前，我们使用CommonJS或AMD来编写模块。ES6将模块正式引入JavaScript。在本章中，我们详细探讨了如何在ES6中使用模块。
- en: The next chapter focuses on another interesting addition to ES6 - proxies and
    promises.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍ES6的另一个有趣的新增功能——代理和承诺。
