- en: Chapter 7. Particles, Sprites, and the Point Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：粒子、精灵和点云
- en: 'In the previous chapters, we discussed the most important concepts, objects,
    and APIs that Three.js has to offer. In this chapter, we''ll look into the only
    concept we''ve skipped until now: particles. With particles (sometimes also called
    sprites), it is very easy to create many small objects that you can use to simulate
    rain, snow, smoke, and other interesting effects. For instance, you can render
    individual geometries as a set of particles and control these particles separately.
    In this chapter, we''ll explore the various particle features provided by Three.js.
    To be more specific, we''ll look at the following subjects in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了Three.js提供的重要概念、对象和API。在本章中，我们将探讨我们至今为止唯一跳过的概念：粒子。通过粒子（有时也称为精灵），可以非常容易地创建许多小对象，你可以使用它们来模拟雨、雪、烟雾和其他有趣的效果。例如，你可以将单个几何体渲染成一组粒子，并分别控制这些粒子。在本章中，我们将探索Three.js提供的各种粒子功能。更具体地说，本章将探讨以下主题：
- en: Creating and styling particles using `THREE.SpriteMaterial`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.SpriteMaterial`创建和样式化粒子
- en: Using a point cloud to create a grouped set of particles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点云创建一组分组的粒子
- en: Creating a point cloud from existing geometries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有几何体创建点云
- en: Animating particles and the particle system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子和粒子系统的动画
- en: Using a texture to style the particles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理样式化粒子
- en: Using the canvas to style a particle with `THREE.SpriteCanvasMaterial`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用canvas通过`THREE.SpriteCanvasMaterial`样式化粒子
- en: Let's start by exploring what a particle is and how you can create one. Before
    we get started, though, a quick note on some of the names used in this chapter.
    In recent versions of Three.js, the names of the objects related to particles
    have changed. `THREE.PointCloud`, which we use in this chapter, used to be called
    `THREE.ParticleSystem`, `THREE.Sprite` used to be called `THREE.Particle`, and
    also the materials have undergone some name changes. So, if you see online examples
    using these old names, remember that they are talking about the same concepts.
    In this chapter, we use the new naming convention introduced in the latest versions
    of Three.js.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探索一下什么是粒子以及如何创建一个。在我们开始之前，关于本章中使用的某些名称，有一个简短的说明。在Three.js的最近版本中，与粒子相关的对象名称已更改。我们本章使用的`THREE.PointCloud`曾经被称为`THREE.ParticleSystem`，`THREE.Sprite`曾经被称为`THREE.Particle`，材质也经历了一些名称变化。因此，如果你在网上看到使用这些旧名称的示例，请记住，它们讨论的是相同的概念。在本章中，我们使用的是Three.js最新版本中引入的新命名约定。
- en: Understanding particles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解粒子
- en: 'Like we do with most new concepts, we''ll start with an example. In the sources
    for this chapter, you''ll find an example with the name `01-particles.html`. Open
    this example and you''ll see a grid of very uninteresting-looking white cubes,
    as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对大多数新概念所做的那样，我们将从一个示例开始。在本章的源代码中，你可以找到一个名为`01-particles.html`的示例。打开这个示例，你会看到一个由非常无趣的白色立方体组成的网格，如下面的截图所示：
- en: '![Understanding particles](img/2215OS_07_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![理解粒子](img/2215OS_07_01.jpg)'
- en: 'What you see in this screenshot are 100 sprites. A sprite is a 2D plane that
    always faces the camera. If you create a sprite without any properties, they are
    rendered as small, white, two-dimensional squares. These sprites were created
    with the following lines of code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你在屏幕上看到的这个截图中有100个精灵。精灵是一个始终面向摄像机的二维平面。如果你创建一个没有任何属性的精灵，它们将被渲染成小型的白色二维正方形。这些精灵是通过以下代码行创建的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we create the sprites manually using the `THREE.Sprite(material)`
    constructor. The only item we pass in is a material. This has to be either `THREE.SpriteMaterial`
    or `THREE.SpriteCanvasMaterial`. We'll look at both of these materials in more
    depth in the rest of this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`THREE.Sprite(material)`构造函数手动创建精灵。我们传递的唯一项是一个材质。这必须是`THREE.SpriteMaterial`或`THREE.SpriteCanvasMaterial`之一。在本章的剩余部分，我们将更深入地探讨这两种材质。
- en: Before we move on to more interesting particles, let's look a bit closer at
    the `THREE.Sprite` object. A `THREE.Sprite` object extends from the `THREE.Object3D`
    object just as `THREE.Mesh` does. This means that most of the properties and functions
    you know from `THREE.Mesh` can be used on `THREE.Sprite`. You can set its position
    using the `position` attribute, scale it using the `scale` property, and move
    it relatively using the `translate` properties.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨更有趣的粒子之前，让我们更仔细地看看 `THREE.Sprite` 对象。一个 `THREE.Sprite` 对象就像 `THREE.Mesh`
    一样扩展自 `THREE.Object3D` 对象。这意味着你可以使用 `THREE.Mesh` 中大多数已知属性和函数在 `THREE.Sprite` 上。你可以使用
    `position` 属性设置其位置，使用 `scale` 属性缩放它，并使用 `translate` 属性进行相对移动。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that in older versions of Three.js, you were unable to use `THREE.Sprite`
    objects with `THREE.WebGLRenderer` and could use it only with `THREE.CanvasRenderer`.
    In the current version, `THREE.Sprite` objects can be used with both renderers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Three.js 的旧版本中，你无法使用 `THREE.Sprite` 对象与 `THREE.WebGLRenderer` 一起使用，而只能与
    `THREE.CanvasRenderer` 一起使用。在当前版本中，`THREE.Sprite` 对象可以与两种渲染器一起使用。
- en: With `THREE.Sprite`, you can very easily create a set of objects and move them
    around the scene. This works great when you're working with a small number of
    objects, but you'll quickly run into performance issues when you want to work
    with a high number of `THREE.Sprite` objects because each of the objects needs
    to be managed separately by Three.js. Three.js provides an alternative way of
    handling a large number of sprites (or particles) using `THREE.PointCloud`. With
    `THREE.PointCloud`, Three.js doesn't have to manage many individual `THREE.Sprite`
    objects, but only the `THREE.PointCloud` instance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.Sprite`，你可以非常容易地创建一组对象并在场景中移动它们。当你处理少量对象时，这工作得很好，但当你想要处理大量 `THREE.Sprite`
    对象时，你会迅速遇到性能问题，因为每个对象都需要由 Three.js 分别管理。Three.js 提供了一种使用 `THREE.PointCloud` 处理大量精灵（或粒子）的替代方法。使用
    `THREE.PointCloud`，Three.js 不需要管理许多单独的 `THREE.Sprite` 对象，而只需管理一个 `THREE.PointCloud`
    实例。
- en: 'To get the same result as the screenshot we saw earlier, but this time using
    `THREE.PointCloud`, we do the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到与之前看到的截图相同的结果，但这次使用 `THREE.PointCloud`，我们执行以下操作：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, for each particle (each point in the cloud), we need to create
    a vertex (represented by `THREE.Vector3`), add it to `THREE.Geometry`, use `THREE.Geometry`
    together with `THREE.PointCloudMaterial` to create `THREE.PointCloud`, and add
    cloud to the scene. An example of `THREE.PointCloud` in action (with colored squares)
    can be found in the `02-particles-webgl.html` example. The following screenshot
    shows this example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，对于每个粒子（云中的每个点），我们需要创建一个顶点（由 `THREE.Vector3` 表示），将其添加到 `THREE.Geometry`
    中，使用 `THREE.Geometry` 和 `THREE.PointCloudMaterial` 创建 `THREE.PointCloud`，并将云添加到场景中。`THREE.PointCloud`
    的一个动作示例（带有彩色方块）可以在 `02-particles-webgl.html` 示例中找到。以下截图显示了此示例：
- en: '![Understanding particles](img/2215OS_07_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![理解粒子](img/2215OS_07_02.jpg)'
- en: In the following sections, we'll explore `THREE.PointCloud` further.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将进一步探讨 `THREE.PointCloud`。
- en: Particles, THREE.PointCloud, and THREE.PointCloudMaterial
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子、THREE.PointCloud 和 THREE.PointCloudMaterial
- en: 'At the end of the previous section, we quickly introduced `THREE.PointCloud`.
    The constructor of `THREE.PointCloud` takes two properties: a geometry and a material.
    The material is used to color and texture the particles (as we''ll see later on),
    and the geometry defines where the individual particles are positioned. Each vertex
    and each point used to define the geometry is shown as a particle. When we create
    `THREE.PointCloud` based on `THREE.BoxGeometry`, we get 8 particles, one for each
    corner of the cube. Normally, though, you won''t create `THREE.PointCloud` from
    one of the standard Three.js geometries, but add the vertices manually to a geometry
    created from scratch (or use an externally loaded model) just like we did at the
    end of the previous section. In this section, we''ll dive a bit deeper into this
    approach and look at how you can use `THREE.PointCloudMaterial` to style the particles.
    We''ll explore this using the `03-basic-point-cloud.html` example. The following
    screenshot shows this example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的结尾，我们简要介绍了`THREE.PointCloud`。`THREE.PointCloud`的构造函数接受两个属性：一个几何体和一个材质。材质用于给粒子上色和贴图（正如我们稍后将要看到的），而几何体定义了单个粒子的位置。用于定义几何体的每个顶点和每个点都显示为一个粒子。当我们基于`THREE.BoxGeometry`创建`THREE.PointCloud`时，我们得到8个粒子，每个粒子对应立方体的一个角。然而，通常情况下，你不会从标准Three.js几何体中创建`THREE.PointCloud`，而是像上一节结尾那样手动将顶点添加到从头创建的几何体（或使用外部加载的模型）中。在本节中，我们将更深入地探讨这种方法，并查看如何使用`THREE.PointCloudMaterial`来样式化粒子。我们将使用`03-basic-point-cloud.html`示例来探索这一点。以下截图显示了此示例：
- en: '![Particles, THREE.PointCloud, and THREE.PointCloudMaterial](img/2215OS_07_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![粒子、THREE.PointCloud和THREE.PointCloudMaterial](img/2215OS_07_03.jpg)'
- en: 'In this example, we create `THREE.PointCloud`, which we fill with 15,000 particles.
    All the particles are styled with `THREE.PointCloudMaterial`. To create `THREE.PointCloud`,
    we used the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了`THREE.PointCloud`，并用15,000个粒子填充它。所有粒子都使用`THREE.PointCloudMaterial`进行样式化。为了创建`THREE.PointCloud`，我们使用了以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this listing, we first create `THREE.Geometry`. We'll add the particles,
    represented as `THREE.Vector3`, to this geometry. For this, we've created a simple
    loop that creates `THREE.Vector3` at a random position and adds it. In this same
    loop, we also specify the array of colors, `geom.colors`, that are used when we
    set the `vertexColors` property of `THREE.PointCloudMaterial` to `true`. The last
    thing to do is create `THREE.PointCloudMaterial` and add it to the scene.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，我们首先创建`THREE.Geometry`。我们将添加表示为`THREE.Vector3`的粒子到这个几何体中。为此，我们创建了一个简单的循环，在随机位置创建`THREE.Vector3`并将其添加。在这个相同的循环中，我们还指定了用于设置`THREE.PointCloudMaterial`的`vertexColors`属性为`true`时使用的颜色数组`geom.colors`。最后要做的事情是创建`THREE.PointCloudMaterial`并将其添加到场景中。
- en: 'The following table explains all the properties you can set on `THREE.PointCloudMaterial`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了你可以设置在`THREE.PointCloudMaterial`上的所有属性：
- en: '| Name | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of all the particles in `ParticleSystem`. Setting
    the `vertexColors` property to true and specifying the colors using the colors
    property of the geometry overrides this property (to be more precise, the color
    of a vertex will be multiplied with this value to determine the final color).
    The default value is `0xFFFFFF`. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是`ParticleSystem`中所有粒子的颜色。将`vertexColors`属性设置为true并使用几何体的颜色属性指定颜色将覆盖此属性（更准确地说，顶点的颜色将与该值相乘以确定最终颜色）。默认值是`0xFFFFFF`。
    |'
- en: '| map | With this property, you can apply a texture to the particles. You can,
    for instance, make them look like snowflakes. This property isn''t shown in this
    example but is explained later on in this chapter. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| map | 使用此属性，你可以将纹理应用到粒子上。例如，你可以使它们看起来像雪花。此属性在本示例中没有显示，但将在本章稍后进行解释。 |'
- en: '| size | This is the size of the particle. The default value is `1`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| size | 这是粒子的尺寸。默认值是`1`。 |'
- en: '| sizeAnnutation | If this is set to false, all the particles will have the
    same size regardless of how far from the camera they are positioned. If this is
    set to true, the size is based on the distance from the camera. The default value
    is `true`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| sizeAnnutation | 如果设置为false，所有粒子的大小将相同，无论它们距离相机有多远。如果设置为true，大小基于距离相机的距离。默认值是`true`。
    |'
- en: '| vertexColors | Normally, all the particles in `THREE.PointCloud` have the
    same color. If this property is set to `THREE.VertexColors` and the colors array
    in the geometry has been filled, the colors from that array will be used instead
    (also see the color entry in this table). The default value is `THREE.NoColors`.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 顶点颜色 | 通常，`THREE.PointCloud` 中的所有粒子具有相同的颜色。如果此属性设置为 `THREE.VertexColors`
    并且几何体的颜色数组已被填充，则将使用该数组的颜色（也请参阅此表中的颜色条目）。默认值为 `THREE.NoColors`。|'
- en: '| opacity | This, together with the transparent property, sets the opacity
    of the particle. The default value is `1` (no opacity). |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 透明度 | 与透明属性一起，此属性设置粒子的透明度。默认值为 `1`（无透明度）。|'
- en: '| transparent | If this is set to true, the particle will be rendered with
    the opacity set by the opacity property. The default value is `false`. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 透明 | 如果设置为 true，则粒子将以透明度属性设置的透明度进行渲染。默认值为 `false`。|'
- en: '| blending | This is the blend mode to use when rendering the particle. See
    [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, for more information on blend modes. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 混合模式 | 这是渲染粒子时要使用的混合模式。有关混合模式的更多信息，请参阅第 9 章，*动画和移动相机*。|'
- en: '| fog | This determines whether the particles are affected by fog added to
    the scene. This defaults to `true`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 雾效 | 这决定了粒子是否受场景中添加的雾的影响。默认为 `true`。|'
- en: The previous example provides a simple control menu that you can use to experiment
    with the properties specific to `THREE.ParticleCloudMaterial`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例提供了一个简单的控制菜单，您可以使用它来试验 `THREE.ParticleCloudMaterial` 特定的属性。
- en: 'So far, we''ve only rendered the particles as small cubes, which is the default
    behavior. There are, however, a few additional ways you can use to style the particles:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只将粒子渲染为小立方体，这是默认行为。然而，还有一些额外的样式化粒子方式可供您使用：
- en: We can apply `THREE.SpriteCanvasMaterial` (which only works for `THREE.CanvasRenderer`)
    to use the results from an HTML canvas element as a texture
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将 `THREE.SpriteCanvasMaterial`（仅适用于 `THREE.CanvasRenderer`）应用于使用 HTML 画布元素的输出作为纹理
- en: Use `THREE.SpriteMaterial` and a HTML5-based texture to use the output of an
    HTML canvas when working with `THREE.WebGLRenderer`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `THREE.SpriteMaterial` 和基于 HTML5 的纹理，在处理 `THREE.WebGLRenderer` 时使用 HTML 画布的输出
- en: Load an external image file (or use the HTML5 canvas) with the `map` property
    of `THREE.PointCloudMaterial` to style all particles of `THREE.ParticleCloud`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `THREE.PointCloudMaterial` 的 `map` 属性加载外部图像文件（或使用 HTML5 画布）以样式化 `THREE.ParticleCloud`
    的所有粒子
- en: In the next section, we look into how you can do this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何实现这一点。
- en: Styling particles with the HTML5 canvas
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTML5 画布样式化粒子
- en: Three.js offers three different ways you can use an HTML5 canvas to style your
    particles. If you use `THREE.CanvasRenderer`, you can directly reference an HTML5
    canvas from `THREE.SpriteCanvasMaterial`. When you use `THREE.WebGLRenderer`,
    you need to take a couple of extra steps to use an HTML5 canvas to style your
    particles. In the following two sections, we'll show you the different approaches.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了三种不同的方式，您可以使用 HTML5 画布来样式化您的粒子。如果您使用 `THREE.CanvasRenderer`，则可以直接从
    `THREE.SpriteCanvasMaterial` 引用 HTML5 画布。当您使用 `THREE.WebGLRenderer` 时，您需要采取一些额外步骤才能使用
    HTML5 画布来样式化您的粒子。在接下来的两个部分中，我们将向您展示不同的方法。
- en: Using HTML5 canvas with THREE.CanvasRenderer
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HTML5 画布与 THREE.CanvasRenderer
- en: 'With `THREE.SpriteCanvasMaterial`, you can use the output from an HTML5 canvas
    as a texture for your particles. This material is specifically created for `THREE.CanvasRenderer`
    and only works when you use this specific renderer. Before we look at how to use
    this material, let''s first look at the attributes you can set on this material:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.SpriteCanvasMaterial`，您可以将 HTML5 画布的输出用作粒子的纹理。这种材料专门为 `THREE.CanvasRenderer`
    创建，并且仅在您使用此特定渲染器时才有效。在我们探讨如何使用这种材料之前，让我们首先看看您可以在此材料上设置的属性：
- en: '| Name | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of the particle. Depending on the specified `blending`
    mode, this affects the color of the canvas image. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `颜色` | 这是粒子的颜色。根据指定的 `混合模式`，这会影响画布图像的颜色。|'
- en: '| `program` | This is a function that takes a canvas context as a parameter.
    This function is called when the particle is rendered. The output from the calls
    to this 2D drawing context is shown as the particle. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `程序` | 这是一个接受画布上下文作为参数的函数。当粒子被渲染时，将调用此函数。2D 绘图上下文的输出将显示为粒子。|'
- en: '| `opacity` | This determines the opacity of the particle. The default value
    is `1`, and there is no opacity. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `opacity` | 这决定了粒子的不透明度。默认值是 `1`，没有不透明度。|'
- en: '| `transparent` | This determines whether the particle is transparent or not.
    This works together with the `opacity` property. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `transparent` | 这决定了粒子是否透明。这和 `opacity` 属性一起工作。|'
- en: '| `blending` | This is the blend mode to be used. See [Chapter 9](ch09.html
    "Chapter 9. Animations and Moving the Camera"), *Animations and Moving the Camera*
    for more details. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `blending` | 这是将要使用的混合模式。有关更多详细信息，请参阅第 9 章 [Animations and Moving the Camera](ch09.html
    "第 9 章。动画和移动相机")。|'
- en: '| `rotation` | This property allows you to rotate the contents of the canvas.
    You''ll usually need to set this to PI to correctly align the contents of the
    canvas. Note that this property can''t be passed in to the constructor of the
    material, but needs to be set explicitly. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `rotation` | 这个属性允许你旋转画布的内容。你通常需要将其设置为 PI 以正确对齐画布的内容。请注意，这个属性不能传递给材料的构造函数，而需要显式设置。|'
- en: 'To see `THREE.SpriteCanvasMaterial` in action, you can open the `04-program-based-sprites.html`
    example. The following screenshot shows this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `THREE.SpriteCanvasMaterial` 的实际效果，你可以打开 `04-program-based-sprites.html`
    示例。以下截图显示了此示例：
- en: '![Using HTML5 canvas with THREE.CanvasRenderer](img/2215OS_07_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用 THREE.CanvasRenderer 与 HTML5 canvas](img/2215OS_07_04.jpg)'
- en: 'In this example, the particles are created in the `createSprites` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，粒子是在 `createSprites` 函数中创建的：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code looks a lot like the code we saw in the previous section. The main
    change is that because we''re working with `THREE.CanvasRenderer`, we create `THREE.Sprite`
    objects directly, instead of using `THREE.PointCloud`. In this code, we also define
    `THREE.SpriteCanvasMaterial` with a `program` attribute that points to the `draw`
    function. This `draw` function defines what a particle will look like (in our
    case, a ghost from *Pac-Man*):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们在上一节中看到的代码非常相似。主要的变化是因为我们正在使用 `THREE.CanvasRenderer`，我们直接创建 `THREE.Sprite`
    对象，而不是使用 `THREE.PointCloud`。在这段代码中，我们还定义了具有指向 `draw` 函数的 `program` 属性的 `THREE.SpriteCanvasMaterial`。这个
    `draw` 函数定义了粒子将看起来像什么（在我们的例子中，是一个来自 *Pac-Man* 的幽灵）：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We won't dive into the actual canvas code required to draw our shape. What's
    important here is that we define a function that accepts a 2D canvas context (`ctx`)
    as its parameter. Everything that is drawn onto that context is used as the shape
    for `THREE.Sprite`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入绘制我们形状所需的实际 canvas 代码。这里重要的是我们定义了一个接受 2D canvas 上下文（`ctx`）作为其参数的函数。在上下文中绘制的一切都用作
    `THREE.Sprite` 的形状。
- en: Using HTML5 canvas with WebGLRenderer
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WebGLRenderer 与 HTML5 canvas
- en: If we want to use an HTML5 canvas with `THREE.WebGLRenderer`, we can take two
    different approaches. We can use `THREE.PointCloudMaterial` and create `THREE.PointCloud`,
    or we can use `THREE.Sprite` and the `map` property of `THREE.SpriteMaterial`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 `THREE.WebGLRenderer` 中使用 HTML5 canvas，我们可以采取两种不同的方法。我们可以使用 `THREE.PointCloudMaterial`
    并创建 `THREE.PointCloud`，或者我们可以使用 `THREE.Sprite` 和 `THREE.SpriteMaterial` 的 `map`
    属性。
- en: 'Let''s start with the first approach and create `THREE.PointCloud`. In the
    attributes for `THREE.PointCloudMaterial`, we mentioned the `map` property. With
    the `map` property, we can load a texture for the particle. With Three.js, this
    texture can also be the output from an HTML5 canvas. An example showing this concept
    is `05a-program-based-point-cloud-webgl.html`. The following screenshot shows
    this example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一种方法开始，创建 `THREE.PointCloud`。在 `THREE.PointCloudMaterial` 的属性中，我们提到了 `map`
    属性。通过 `map` 属性，我们可以为粒子加载一个纹理。使用 Three.js，这个纹理也可以是 HTML5 canvas 的输出。展示这个概念的例子是
    `05a-program-based-point-cloud-webgl.html`。以下截图显示了此示例：
- en: '![Using HTML5 canvas with WebGLRenderer](img/2215OS_07_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用 WebGLRenderer 与 HTML5 canvas](img/2215OS_07_05.jpg)'
- en: 'Let''s look at the code we wrote to get this effect. Most of the code is the
    same as our previous WebGL example, so we won''t go into too much detail. The
    important code changes that were made to get this example are shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们编写的代码来实现这个效果。大部分代码与我们的上一个 WebGL 示例相同，所以我们将不会深入细节。为了得到这个示例所做的关键代码更改在此处显示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `getTexture`, the first of these two JavaScript functions, we create `THREE.Texture`
    based on an HTML5 canvas element. In the second function, `createPointCloud`,
    we assign this texture to the `map` property of `THREE.PointCloudMaterial`. In
    this function, you can also see that we set the `sortParticles` property of `THREE.PointCloud`
    to `true`. This property makes sure that before the particles are rendered, they
    are sorted according to their *z* position on screen. If you see partly overlapping
    particles or incorrect transparency, setting this property to `true` will (in
    most cases) fix that. You should note, though, that setting this property to `true`
    will affect the performance of your scene. When this is set to true, Three.js
    will have to determine the distance to the camera for each individual particle.
    For a `THREE.PointCloud` object that is very large, this can have a big impact
    on performance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getTexture`函数，这两个JavaScript函数中的第一个，我们根据HTML5画布元素创建`THREE.Texture`。在第二个函数`createPointCloud`中，我们将这个纹理分配给`THREE.PointCloudMaterial`的`map`属性。在这个函数中，你还可以看到我们将`THREE.PointCloud`的`sortParticles`属性设置为`true`。这个属性确保在粒子被渲染之前，它们根据屏幕上的*z*位置进行排序。如果你看到部分重叠的粒子或错误的透明度，将此属性设置为`true`（在大多数情况下）将修复这个问题。不过，你应该注意，将此属性设置为`true`会影响场景的性能。当设置为`true`时，Three.js将不得不确定每个单独粒子的距离。对于一个非常大的`THREE.PointCloud`对象，这可能会对性能产生重大影响。
- en: 'While we''re talking about the properties of `THREE.PointCloud`, there is one
    additional property you can set on `THREE.PointCloud: FrustumCulled`. If this
    property is set to true, it means that if particles fall outside the visible camera
    range, they aren''t rendered. This can be used to improve performance and frame
    rate if needed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论`THREE.PointCloud`的属性时，你还可以在`THREE.PointCloud`上设置一个额外的属性：`FrustumCulled`。如果这个属性设置为`true`，这意味着如果粒子落在可见相机范围之外，它们不会被渲染。如果需要，这可以用来提高性能和帧率。
- en: The result of this is that everything we draw to the canvas in the `getTexture()`
    method is used for the particles in `THREE.PointCloud`. In the following section,
    we'll look a bit deeper into how this works with textures we load from external
    files. Note that in this example, we only see a very small part of what is possible
    with textures. In [Chapter 10](ch10.html "Chapter 10. Loading and Working with
    Textures"), *Loading and Working with Textures*, we'll dive into the details of
    what can be done with textures.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们在`getTexture()`方法中绘制到画布上的所有内容都用于`THREE.PointCloud`中的粒子。在下一节中，我们将更深入地探讨这是如何与从外部文件加载的纹理一起工作的。请注意，在这个示例中，我们只看到了使用纹理所能实现的可能性的一个非常小的一部分。在[第10章](ch10.html
    "第10章。加载和使用纹理")，*加载和使用纹理*中，我们将深入了解可以使用纹理做什么。
- en: 'At the beginning of this section, we mentioned that we could also use `THREE.Sprite`
    together with the `map` property to create a canvas-based particle. For this,
    we use the same approach to create `THREE.Texture` as we saw in the previous example.
    This time, however, we assign it to `THREE.Sprite` like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我们提到我们也可以使用`THREE.Sprite`与`map`属性一起创建基于画布的粒子。为此，我们使用与之前示例中相同的方法来创建`THREE.Texture`。然而，这一次，我们将其分配给`THREE.Sprite`，如下所示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you can see that we use a standard `THREE.SpriteMaterial` object and assign
    the output of the canvas as `THREE.Texture` to the `map` property of the material.
    You can view an example of this by opening `05b-program-based-sprites-webgl.html`
    in your browser. Both of these approaches have their own advantages and disadvantages.
    With `THREE.Sprite`, you have more control over the individual particle, but it
    becomes less performant and more complex when you're working with a large number
    of particles. With `THREE.PointCloud`, you can easily manage a large number of
    particles, but have less control over each individual particle.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们使用了一个标准的`THREE.SpriteMaterial`对象，并将画布的输出作为`THREE.Texture`分配给材料的`map`属性。你可以在浏览器中打开`05b-program-based-sprites-webgl.html`来查看这个示例。这两种方法都有其自身的优缺点。使用`THREE.Sprite`，你可以对单个粒子有更多的控制，但当处理大量粒子时，性能会降低，且变得更加复杂。使用`THREE.PointCloud`，你可以轻松管理大量粒子，但对每个单独粒子的控制较少。
- en: Using textures to style particles
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理来样式化粒子
- en: In the previous example, we saw how you could style `THREE.PointCloud` and individual
    `THREE.Sprite` objects using an HTML5 canvas. Since you can draw anything you
    want and even load external images, you can use this approach to add all kinds
    of styles to the particle system. There is, however, a more direct way to use
    an image to style your particles. You can use the `THREE.ImageUtils.loadTexture()`
    function to load an image as `THREE.Texture`. `THREE.Texture` can then be assigned
    to the `map` property of a material.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们看到了如何使用HTML5 canvas来样式化`THREE.PointCloud`和单个`THREE.Sprite`对象。由于你可以绘制任何你想要的东西，甚至可以加载外部图像，因此你可以使用这种方法为粒子系统添加各种样式。然而，有一个更直接的方法来使用图像来样式化你的粒子。你可以使用`THREE.ImageUtils.loadTexture()`函数将图像加载为`THREE.Texture`。然后，`THREE.Texture`可以被分配给材质的`map`属性。
- en: 'In this section, we''ll show you two examples and explain how to create them.
    Both these examples use an image as a texture for your particles. In the first
    example, we create a simulation of rain, `06-rainy-scene.html`. The following
    screenshot shows this example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示两个示例并解释如何创建它们。这两个示例都使用图像作为粒子的纹理。在第一个示例中，我们创建了一个雨的模拟，`06-rainy-scene.html`。以下截图显示了此示例：
- en: '![Using textures to style particles](img/2215OS_07_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理来样式化粒子](img/2215OS_07_06.jpg)'
- en: 'The first thing we need to do is get a texture that will represent our raindrop.
    You can find a couple of examples in the `assets/textures/particles` folder. In
    [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, we will explain all the details and requirements for textures.
    For now, all you need to know is that the texture should be square and preferably
    a power of 2 (for example, 64 x 64, 128 x 128, 256 x 256). For this example, we''ll
    use this texture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是获取一个代表雨滴的纹理。你可以在`assets/textures/particles`文件夹中找到一些示例。在[第9章](ch09.html
    "第9章。动画和移动相机")《动画和移动相机》中，我们将解释纹理的所有细节和需求。现在，你需要知道的是，纹理应该是正方形的，最好是2的幂（例如，64 x 64，128
    x 128，256 x 256）。在这个例子中，我们将使用这个纹理：
- en: '![Using textures to style particles](img/2215OS_07_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理来样式化粒子](img/2215OS_07_07.jpg)'
- en: 'This image uses a black background (needed for correct blending) and shows
    the shape and color of a raindrop. Before we can use this texture in `THREE.PointCloudMaterial`,
    we first need to load it. This can be done with the following line of code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片使用黑色背景（用于正确混合）并显示了雨滴的形状和颜色。在我们能够将此纹理用于`THREE.PointCloudMaterial`之前，我们首先需要加载它。这可以通过以下代码行完成：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this line of code, Three.js will load the texture, and we can use it in
    our material. For this example, we defined the material like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将使Three.js加载纹理，我们可以在我们的材质中使用它。对于这个例子，我们定义了材质如下：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this chapter, we've discussed all of these properties. The main thing to
    understand here is that the `map` property points to the texture we loaded with
    the `THREE.ImageUtils.loadTexture()` function, and we specify `THREE.AdditiveBlending`
    as the `blending` mode. This `blending` mode means that when a new pixel is drawn,
    the color of the background pixel is added to the color of this new pixel. For
    our raindrop texture, this means that the black background won't be shown. A logical
    alternative would be to replace the black from our texture with a transparent
    background, but that doesn't work with particles and WebGL unfortunately.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了所有这些属性。这里要理解的主要是，`map`属性指向我们使用`THREE.ImageUtils.loadTexture()`函数加载的纹理，我们将`THREE.AdditiveBlending`指定为`blending`模式。这种`blending`模式意味着当绘制新像素时，背景像素的颜色会添加到新像素的颜色上。对于我们的雨滴纹理，这意味着黑色背景不会显示。一个合理的替代方案是将纹理中的黑色替换为透明背景，但不幸的是，这与粒子以及WebGL不兼容。
- en: 'That takes care of styling `THREE.PointCloud`. What you''ll also see when you
    open up this example is that the particles themselves are moving. In the previous
    examples, we moved the entire particle system; this time, we position the individual
    particles within `THREE.PointCloud`. Doing this is actually very simple. Each
    particle is represented as a vertex that makes up the geometry that was used to
    create `THREE.PointCloud`. Let''s look at how we add the particles for `THREE.PointCloud`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解决了`THREE.PointCloud`的样式问题。当你打开这个示例时，你还会看到粒子本身在移动。在先前的例子中，我们移动了整个粒子系统；这次，我们在`THREE.PointCloud`内部定位单个粒子。实际上，这样做非常简单。每个粒子都表示为一个顶点，它构成了用于创建`THREE.PointCloud`的几何形状。让我们看看我们是如何为`THREE.PointCloud`添加粒子的：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This isn''t that different from the previous examples we saw. Here, we added
    two additional properties to each particle (`THREE.Vector3`): `velocityX` and
    `velocityY`. The first one defines how a particle (a raindrop) moves horizontally,
    and the second one defines how fast the raindrop falls down. The horizontal velocity
    ranges from -0.16 to +0.16, and the vertical speed ranges from 0.1 to 0.3\. Now
    that each raindrop has its own speed, we can move the individual particles inside
    the render loop:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前我们看到的前几个例子没有太大区别。在这里，我们为每个粒子（雨滴）添加了两个额外的属性（`THREE.Vector3`）：`velocityX`和`velocityY`。第一个定义了粒子（雨滴）在水平方向上的移动方式，第二个定义了雨滴下落的速度。水平速度范围从-0.16到+0.16，垂直速度范围从0.1到0.3。现在每个雨滴都有自己的速度，我们可以在渲染循环中移动单个粒子：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this piece of code, we get all `vertices` (particles) from the geometry that
    was used to create `THREE.PointCloud`. For each of the particles, we take `velocityX`
    and `velocityY` and use them to change the current position of the particle. The
    last two lines make sure the particles stay within the range we've defined. If
    the `v.y` position drops below zero, we add the raindrop back to the top, and
    if the `v.x` position reaches any of the edges, we make it bounce back by inverting
    the horizontal velocity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们从用于创建`THREE.PointCloud`的几何体中获取所有`vertices`（粒子）。对于每个粒子，我们取`velocityX`和`velocityY`，并使用它们来改变粒子的当前位置。最后两行确保粒子保持在定义的范围内。如果`v.y`位置低于零，我们将雨滴重新添加到顶部，如果`v.x`位置达到任何边缘，我们将通过反转水平速度使其弹回。
- en: 'Let''s look at another example. This time, we won''t make rain, but we''ll
    make snow. Additionally, we won''t be using just a single texture, but we''ll
    use five separate images (taken from the Three.js examples). Let''s start by looking
    at the result again (see `07-snowy-scene.html`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。这次，我们不会制作雨，而是制作雪。此外，我们不会只使用一个纹理，而是使用五张单独的图像（来自Three.js示例）。让我们先再次查看结果（见`07-snowy-scene.html`）：
- en: '![Using textures to style particles](img/2215OS_07_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理来样式化粒子](img/2215OS_07_08.jpg)'
- en: 'In the preceding screenshot, you can see that instead of using just a single
    image as texture, we''ve used multiple images. You might wonder how we did this.
    As you probably remember, we can only have a single material for `THREE.PointCloud`.
    If we want to have multiple materials, we just have to make multiple particle
    systems, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到，我们不是只使用一张图像作为纹理，而是使用了多张图像。你可能想知道我们是如何做到的。正如你可能记得的，我们只能为`THREE.PointCloud`有一个材质。如果我们想有多个材质，我们只需要创建多个粒子系统，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, you can see that we load the textures separately and pass all the information
    on how to create `THREE.PointCloud` to the `createPointCloud` function. This function
    looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们分别加载纹理，并将如何创建`THREE.PointCloud`的所有信息传递给`createPointCloud`函数。这个函数看起来是这样的：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing we do in this function is define the color in which the particles
    for this specific texture should be rendered. This is done by randomly changing
    the *lightness* of the passed-in color. Next, the material is created in the same
    manner we did before. The only change here is that the `depthWrite` property is
    set to `false`. This property defines whether this object affects the WebGL depth
    buffer. By setting this to `false`, we make sure that the various point clouds
    don''t interfere with each other. If this property isn''t set to `false`, you''ll
    see that the black background from the texture is sometimes shown when a particle
    is in front of a particle from another `THREE.PointCloud` object. The last step
    taken in this piece of code is randomly placing the particles and adding a random
    speed to each particle. In the render loop, we can now update the position of
    all the particles from each `THREE.PointCloud` object like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先定义用于渲染特定纹理的粒子的颜色。这是通过随机改变传入颜色的**亮度**来实现的。接下来，以我们之前相同的方式创建材质。这里唯一的区别是，将`depthWrite`属性设置为`false`。这个属性定义了该对象是否影响WebGL深度缓冲区。通过将其设置为`false`，我们确保各种点云不会相互干扰。如果这个属性没有设置为`false`，你会看到当粒子位于另一个`THREE.PointCloud`对象的粒子前面时，纹理的黑色背景有时会显示出来。在这段代码的最后一步是随机放置粒子，并为每个粒子添加一个随机速度。在渲染循环中，我们现在可以像这样更新每个`THREE.PointCloud`对象中所有粒子的位置：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this approach, we can have particles that have different textures. This
    approach, however, is a bit limited. The more different textures we want, the
    more point clouds we'll have to create and manage. If you have a limited set of
    particles with different styles, you'd better use the `THREE.Sprite` object we
    showed at the beginning of this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们可以拥有具有不同纹理的粒子。然而，这种方法有点局限。我们想要的纹理越多，我们需要创建和管理的点云就越多。如果你有一组有限的不同样式的粒子，你最好使用本章开头我们展示的
    `THREE.Sprite` 对象。
- en: Working with sprite maps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理精灵贴图
- en: At the beginning of this chapter, we used a `THREE.Sprite` object to render
    single particles with `THREE.CanvasRenderer` and `THREE.WebGLRenderer`. These
    sprites were positioned somewhere in the 3D world, and their size was based on
    the distance from the camera (this is also sometimes called **billboarding**).
    In this section, we'll show an alternative use of the `THREE.Sprite` object. We'll
    show you how you can use `THREE.Sprite` to create a layer similar to **head-up
    display** (**HUD**) for your 3D content using an extra `THREE.OrthographicCamera`
    instance. We will also show you how to select the image for a `THREE.Sprite` object
    using a sprite map.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们使用 `THREE.Sprite` 对象和 `THREE.CanvasRenderer` 以及 `THREE.WebGLRenderer`
    来渲染单个粒子。这些精灵被放置在 3D 世界中的某个位置，它们的大小基于与摄像机的距离（这有时也被称为 **billboarding**）。在本节中，我们将展示
    `THREE.Sprite` 对象的另一种用途。我们将向您展示如何使用额外的 `THREE.OrthographicCamera` 实例使用 `THREE.Sprite`
    创建一个类似于 **抬头显示**（**HUD**）的层，用于您的 3D 内容。我们还将向您展示如何使用精灵贴图选择 `THREE.Sprite` 对象的图像。
- en: 'As an example, we''re going to create a simple `THREE.Sprite` object that moves
    from left to right over the screen. In the background, we''ll render a 3D scene
    with a moving camera to illustrate that `THREE.Sprite` moves independently of
    the camera. The following screenshot shows what we''ll be creating for the first
    example (`08-sprites.html`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将创建一个简单的 `THREE.Sprite` 对象，它在屏幕上从左到右移动。在背景中，我们将渲染一个带有移动摄像机的 3D 场景，以说明
    `THREE.Sprite` 是独立于摄像机移动的。以下截图显示了我们将为第一个示例（`08-sprites.html`）创建的内容：
- en: '![Working with sprite maps](img/2215OS_07_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![处理精灵贴图](img/2215OS_07_09.jpg)'
- en: 'If you open this example in your browser, you''ll see a Pac-Man ghost-like
    sprite moving across the screen and changing color and form whenever it hits the
    right edge. The first thing we''ll do is look at how we create `THREE.OrthographicCamera`
    and a separate scene to render `THREE.Sprite` in:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个例子中打开浏览器，你会看到一个类似 Pac-Man 幽灵的精灵在屏幕上移动，并且每当它碰到右边时，颜色和形状都会改变。我们首先将研究如何创建
    `THREE.OrthographicCamera` 和一个单独的场景来渲染 `THREE.Sprite`：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, let''s look at the construction of `THREE.Sprite` and how the various
    shapes the sprite can take are loaded:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `THREE.Sprite` 的构建以及精灵可以采取的各种形状是如何加载的：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `getTexture()` function, we load a texture. However, instead of loading
    five different images for each *ghost*, we load a single texture that contains
    all the sprites. The texture looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getTexture()` 函数中，我们加载一个纹理。然而，我们不是为每个 *幽灵* 加载五张不同的图片，而是加载一个包含所有精灵的单个纹理。纹理看起来像这样：
- en: '![Working with sprite maps](img/2215OS_07_10.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![处理精灵贴图](img/2215OS_07_10.jpg)'
- en: With the `map.offset` and the `map.repeat` properties, we select the correct
    sprite to show on screen. With the `map.offset` property, we determine the offset
    for the *x* axis (u) and the *y* axis (v) for the texture we loaded. The scale
    for these properties runs from 0 to 1\. In our example, if we want to select the
    third ghost, we set the u-offset (*x* axis) to 0.4, and, because we've only got
    one row, we don't need to change the v-offset (*y* axis). If we only set this
    property, the texture shows the third, fourth, and fifth ghosts compressed together
    on screen. To only show one ghost, we need to zoom in. We do this by setting the
    `map.repeat` property for the u-value to 1/5\. This means that we zoom in (only
    for the *x* axis) to only show 20 percent of the texture, which is exactly one
    ghost.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map.offset` 和 `map.repeat` 属性，我们可以选择屏幕上显示的正确精灵。通过 `map.offset` 属性，我们确定加载的纹理在
    *x* 轴（u）和 *y* 轴（v）上的偏移量。这些属性的缩放范围从 0 到 1。在我们的例子中，如果我们想选择第三个幽灵，我们将 u 偏移量（*x* 轴）设置为
    0.4，因为我们只有一行，所以我们不需要改变 v 偏移量（*y* 轴）。如果我们只设置这个属性，纹理会在屏幕上显示第三个、第四个和第五个幽灵压缩在一起。如果我们只想显示一个幽灵，我们需要放大。我们通过将
    `map.repeat` 属性的 u 值设置为 1/5 来实现这一点。这意味着我们只放大（仅针对 *x* 轴）以只显示纹理的 20%，这正好是一个幽灵。
- en: 'The final step we need to take is update the `render` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是更新 `render` 函数：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first render the scene with the normal camera and the moving sphere, and
    after that, we render the scene containing our sprite. Note that we need to set
    the `autoClear` property of the WebGLRenderer to `false`. If we don't do this,
    Three.js will clear the scene before it renders the sprite, and the sphere wouldn't
    show up.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用正常相机和移动的球体渲染场景，然后渲染包含我们的精灵的场景。请注意，我们需要将WebGLRenderer的`autoClear`属性设置为`false`。如果我们不这样做，Three.js将在渲染精灵之前清除场景，球体就不会显示出来。
- en: 'The following table shows an overview of all the properties of `THREE.SpriteMaterial`
    we used in the previous examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们在上一示例中使用的所有`THREE.SpriteMaterial`属性概述：
- en: '| Name | Description |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of the sprite. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是精灵的颜色。|'
- en: '| `map` | This is the texture to be used for this sprite. This can be a sprite
    sheet, as shown in the example in this section. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 这是用于此精灵的纹理。这可以是一个精灵图集，如本节中的示例所示。|'
- en: '| `sizeAnnutation` | If this is set to `false`, the size of the sprite won''t
    be affected by the distance it''s removed from the camera. The default value is
    `true`. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `sizeAnnutation` | 如果设置为`false`，则精灵的大小不会受到其与相机距离的影响。默认值是`true`。|'
- en: '| `opacity` | This sets the transparency of the sprite. The default value is
    `1` (no opacity). |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `opacity` | 这设置精灵的透明度。默认值是`1`（无透明度）。|'
- en: '| `blending` | This defines the blend mode to be used when rendering the sprite.
    See [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, for more information on blend modes. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `blending` | 这定义了渲染精灵时要使用的混合模式。有关混合模式的更多信息，请参阅[第9章](ch09.html "第9章。动画和移动相机")，*动画和移动相机*。'
- en: '| `fog` | This determines whether the sprite is affected by fog added to the
    scene. This defaults to `true`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 这确定精灵是否受场景中添加的雾的影响。默认为`true`。|'
- en: You can also set the `depthTest` and `depthWrite` properties on this material.
    For more information on these properties, see [Chapter 4](ch04.html "Chapter 4. Working
    with Three.js Materials"), *Working with Three.js Materials*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置这个材质上的`depthTest`和`depthWrite`属性。有关这些属性的更多信息，请参阅[第4章](ch04.html "第4章。使用Three.js材质")，*使用Three.js材质*。
- en: 'We can, of course, also use a sprite map when positioning `THREE.Sprites` in
    3D (as we did at the beginning of this chapter). An example (`09-sprites-3D.html`)
    of this is shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然也可以在3D中定位`THREE.Sprites`时使用精灵图（正如我们在本章开头所做的那样）。以下截图显示了这种示例（`09-sprites-3D.html`）：
- en: '![Working with sprite maps](img/2215OS_07_11.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用精灵图](img/2215OS_07_11.jpg)'
- en: 'With the properties we saw in the previous table, we can very easily create
    the effect we see in the preceding screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们在上一表中看到的属性，我们可以非常容易地创建我们在上一张截图中所看到的效果：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, we create 400 sprites based on the sprite sheet we showed
    earlier. You''ll probably know and understand most of the properties and concepts
    shown here. As we''ve added the separate sprites to a group, rotating them is
    very easy and can be done like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们根据我们之前展示的精灵图集创建了400个精灵。你可能已经知道并理解这里展示的大多数属性和概念。由于我们将单独的精灵添加到了一个组中，所以旋转它们非常容易，可以这样做：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this chapter, so far we've mainly looked at creating sprites and point clouds
    from scratch. An interesting option, though, is to create `THREE.PointCloud` from
    an existing geometry.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，到目前为止我们主要关注从头开始创建精灵和点云。然而，有一个有趣的选择，那就是从现有的几何体中创建`THREE.PointCloud`。
- en: Creating THREE.PointCloud from an advanced geometry
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从高级几何体创建THREE.PointCloud
- en: As you remember, `THREE.PointCloud` renders each particle based on the vertices
    from the supplied geometry. This means that if we provide a complex geometry (for
    example, a torus knot or a tube), we can create `THREE.PointCloud` based on the
    vertices from that specific geometry. For this last section of this chapter, we'll
    create a torus knot, like the one we saw in the previous chapter, and render it
    as `THREE.PointCloud`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，`THREE.PointCloud`根据提供的几何体的顶点渲染每个粒子。这意味着如果我们提供一个复杂的几何体（例如，一个环面结或一个管），我们可以根据该特定几何体的顶点创建`THREE.PointCloud`。在本章的最后部分，我们将创建一个环面结，就像我们在上一章中看到的那样，并将其渲染为`THREE.PointCloud`。
- en: 'We''ve already explained the torus knot in the previous chapter, so we won''t
    go into much detail here. We''re using the exact code from the previous chapter,
    and we''ve added a single menu option that you can use to transform the rendered
    mesh into `THREE.PointCloud`. You can find the example (`10-create-particle-system-from-model.html`)
    in the sources for this chapter. The following screenshot shows the example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中解释了环面结，所以这里不会过多详细说明。我们使用上一章的精确代码，并添加了一个单菜单选项，您可以使用它将渲染的网格转换为 `THREE.PointCloud`。您可以在本章的源代码中找到示例（`10-create-particle-system-from-model.html`）。以下截图显示了示例：
- en: '![Creating THREE.PointCloud from an advanced geometry](img/2215OS_07_12.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![从高级几何形状创建 THREE.PointCloud](img/2215OS_07_12.jpg)'
- en: 'As you can see in the preceding screenshot, every vertex used to generate the
    torus knot is used as a particle. In this example, we''ve added a nice-looking
    material, based on a HTML canvas, to create this glowing effect. We''ll only look
    at the code to the create the material and the particle system as we''ve already
    discussed the other properties in this chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，用于生成环面结的每个顶点都用作粒子。在本例中，我们添加了一个基于 HTML 画布的漂亮材质，以创建这种发光效果。我们将只查看创建材质和粒子系统的代码，因为我们已经在本章中讨论了其他属性：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code fragment, you can see two functions: `createPointCloud()` and
    `generateSprite()`. In the first function, we create a simple `THREE.PointCloud`
    object directly from the geometry provided (in this example, a torus knot) and
    set the texture (the `map` property) to a glowing dot (generated on an HTML5 canvas
    element) with the `generateSprite()` function, which looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，您可以看到两个函数：`createPointCloud()` 和 `generateSprite()`。在第一个函数中，我们直接从提供的几何形状（在本例中为环面结）创建了一个简单的
    `THREE.PointCloud` 对象，并使用 `generateSprite()` 函数将纹理（`map` 属性）设置为发光点（在 HTML5 画布元素上生成），该函数如下所示：
- en: '![Creating THREE.PointCloud from an advanced geometry](img/2215OS_07_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![从高级几何形状创建 THREE.PointCloud](img/2215OS_07_13.jpg)'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That's a wrap for this chapter. We've explained what particles, sprites, and
    particle systems are and how you can style these objects with the available materials.
    In this chapter, you saw how you can use `THREE.Sprite` directly with `THREE.CanvasRenderer`
    and `THREE.WebGLRenderer`. If you want to create a large number of particles,
    however, you should use `THREE.PointCloud`. With `THREE.PointCloud`, all the particles
    share the same material, and the only property you can change for an individual
    particle is their color by setting the `vertexColors` property of the material
    to `THREE.VertexColors` and providing a color value in the `colors` array of `THREE.Geometry`
    used to create `THREE.PointCloud`. We also showed how you can easily animate particles
    by changing their position. This works the same for an individual `THREE.Sprite`
    instance and the vertices from the geometry used to create `THREE.PointCloud`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容到此结束。我们解释了粒子、精灵和粒子系统是什么，以及如何使用可用的材料来样式化这些对象。在本章中，您看到了如何直接使用 `THREE.Sprite`
    与 `THREE.CanvasRenderer` 和 `THREE.WebGLRenderer` 一起使用。然而，如果您想创建大量粒子，则应使用 `THREE.PointCloud`。使用
    `THREE.PointCloud`，所有粒子共享相同的材质，您可以为单个粒子更改的唯一属性是通过将材质的 `vertexColors` 属性设置为 `THREE.VertexColors`
    并在用于创建 `THREE.PointCloud` 的 `THREE.Geometry` 的 `colors` 数组中提供一个颜色值来改变其颜色。我们还展示了如何通过改变它们的位置来轻松地动画化粒子。这对单个
    `THREE.Sprite` 实例和用于创建 `THREE.PointCloud` 的几何形状的顶点都适用。
- en: So far, we have created meshes based on geometries provided by Three.js. This
    works great for simple models such as spheres and cubes but isn't the best approach
    when you want to create complex 3D models. For those models, you'd usually use
    a 3D modeling application such as Blender or 3D Studio Max. In the next chapter,
    you'll learn how you can load and display models created by such 3D modeling applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了基于 Three.js 提供的几何形状的网格。这对于简单的模型（如球体和立方体）来说效果很好，但当你想要创建复杂的 3D 模型时，这不是最佳方法。对于这些模型，您通常会使用
    3D 建模应用程序，如 Blender 或 3D Studio Max。在下一章中，您将学习如何加载和显示由此类 3D 建模应用程序创建的模型。
