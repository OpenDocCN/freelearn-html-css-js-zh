- en: Chapter 7. Particles, Sprites, and the Point Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we discussed the most important concepts, objects,
    and APIs that Three.js has to offer. In this chapter, we''ll look into the only
    concept we''ve skipped until now: particles. With particles (sometimes also called
    sprites), it is very easy to create many small objects that you can use to simulate
    rain, snow, smoke, and other interesting effects. For instance, you can render
    individual geometries as a set of particles and control these particles separately.
    In this chapter, we''ll explore the various particle features provided by Three.js.
    To be more specific, we''ll look at the following subjects in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and styling particles using `THREE.SpriteMaterial`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a point cloud to create a grouped set of particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a point cloud from existing geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating particles and the particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a texture to style the particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the canvas to style a particle with `THREE.SpriteCanvasMaterial`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by exploring what a particle is and how you can create one. Before
    we get started, though, a quick note on some of the names used in this chapter.
    In recent versions of Three.js, the names of the objects related to particles
    have changed. `THREE.PointCloud`, which we use in this chapter, used to be called
    `THREE.ParticleSystem`, `THREE.Sprite` used to be called `THREE.Particle`, and
    also the materials have undergone some name changes. So, if you see online examples
    using these old names, remember that they are talking about the same concepts.
    In this chapter, we use the new naming convention introduced in the latest versions
    of Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like we do with most new concepts, we''ll start with an example. In the sources
    for this chapter, you''ll find an example with the name `01-particles.html`. Open
    this example and you''ll see a grid of very uninteresting-looking white cubes,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding particles](img/2215OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What you see in this screenshot are 100 sprites. A sprite is a 2D plane that
    always faces the camera. If you create a sprite without any properties, they are
    rendered as small, white, two-dimensional squares. These sprites were created
    with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create the sprites manually using the `THREE.Sprite(material)`
    constructor. The only item we pass in is a material. This has to be either `THREE.SpriteMaterial`
    or `THREE.SpriteCanvasMaterial`. We'll look at both of these materials in more
    depth in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to more interesting particles, let's look a bit closer at
    the `THREE.Sprite` object. A `THREE.Sprite` object extends from the `THREE.Object3D`
    object just as `THREE.Mesh` does. This means that most of the properties and functions
    you know from `THREE.Mesh` can be used on `THREE.Sprite`. You can set its position
    using the `position` attribute, scale it using the `scale` property, and move
    it relatively using the `translate` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in older versions of Three.js, you were unable to use `THREE.Sprite`
    objects with `THREE.WebGLRenderer` and could use it only with `THREE.CanvasRenderer`.
    In the current version, `THREE.Sprite` objects can be used with both renderers.
  prefs: []
  type: TYPE_NORMAL
- en: With `THREE.Sprite`, you can very easily create a set of objects and move them
    around the scene. This works great when you're working with a small number of
    objects, but you'll quickly run into performance issues when you want to work
    with a high number of `THREE.Sprite` objects because each of the objects needs
    to be managed separately by Three.js. Three.js provides an alternative way of
    handling a large number of sprites (or particles) using `THREE.PointCloud`. With
    `THREE.PointCloud`, Three.js doesn't have to manage many individual `THREE.Sprite`
    objects, but only the `THREE.PointCloud` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the same result as the screenshot we saw earlier, but this time using
    `THREE.PointCloud`, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, for each particle (each point in the cloud), we need to create
    a vertex (represented by `THREE.Vector3`), add it to `THREE.Geometry`, use `THREE.Geometry`
    together with `THREE.PointCloudMaterial` to create `THREE.PointCloud`, and add
    cloud to the scene. An example of `THREE.PointCloud` in action (with colored squares)
    can be found in the `02-particles-webgl.html` example. The following screenshot
    shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding particles](img/2215OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following sections, we'll explore `THREE.PointCloud` further.
  prefs: []
  type: TYPE_NORMAL
- en: Particles, THREE.PointCloud, and THREE.PointCloudMaterial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the end of the previous section, we quickly introduced `THREE.PointCloud`.
    The constructor of `THREE.PointCloud` takes two properties: a geometry and a material.
    The material is used to color and texture the particles (as we''ll see later on),
    and the geometry defines where the individual particles are positioned. Each vertex
    and each point used to define the geometry is shown as a particle. When we create
    `THREE.PointCloud` based on `THREE.BoxGeometry`, we get 8 particles, one for each
    corner of the cube. Normally, though, you won''t create `THREE.PointCloud` from
    one of the standard Three.js geometries, but add the vertices manually to a geometry
    created from scratch (or use an externally loaded model) just like we did at the
    end of the previous section. In this section, we''ll dive a bit deeper into this
    approach and look at how you can use `THREE.PointCloudMaterial` to style the particles.
    We''ll explore this using the `03-basic-point-cloud.html` example. The following
    screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Particles, THREE.PointCloud, and THREE.PointCloudMaterial](img/2215OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we create `THREE.PointCloud`, which we fill with 15,000 particles.
    All the particles are styled with `THREE.PointCloudMaterial`. To create `THREE.PointCloud`,
    we used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, we first create `THREE.Geometry`. We'll add the particles,
    represented as `THREE.Vector3`, to this geometry. For this, we've created a simple
    loop that creates `THREE.Vector3` at a random position and adds it. In this same
    loop, we also specify the array of colors, `geom.colors`, that are used when we
    set the `vertexColors` property of `THREE.PointCloudMaterial` to `true`. The last
    thing to do is create `THREE.PointCloudMaterial` and add it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains all the properties you can set on `THREE.PointCloudMaterial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This is the color of all the particles in `ParticleSystem`. Setting
    the `vertexColors` property to true and specifying the colors using the colors
    property of the geometry overrides this property (to be more precise, the color
    of a vertex will be multiplied with this value to determine the final color).
    The default value is `0xFFFFFF`. |'
  prefs: []
  type: TYPE_TB
- en: '| map | With this property, you can apply a texture to the particles. You can,
    for instance, make them look like snowflakes. This property isn''t shown in this
    example but is explained later on in this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| size | This is the size of the particle. The default value is `1`. |'
  prefs: []
  type: TYPE_TB
- en: '| sizeAnnutation | If this is set to false, all the particles will have the
    same size regardless of how far from the camera they are positioned. If this is
    set to true, the size is based on the distance from the camera. The default value
    is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| vertexColors | Normally, all the particles in `THREE.PointCloud` have the
    same color. If this property is set to `THREE.VertexColors` and the colors array
    in the geometry has been filled, the colors from that array will be used instead
    (also see the color entry in this table). The default value is `THREE.NoColors`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| opacity | This, together with the transparent property, sets the opacity
    of the particle. The default value is `1` (no opacity). |'
  prefs: []
  type: TYPE_TB
- en: '| transparent | If this is set to true, the particle will be rendered with
    the opacity set by the opacity property. The default value is `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| blending | This is the blend mode to use when rendering the particle. See
    [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, for more information on blend modes. |'
  prefs: []
  type: TYPE_TB
- en: '| fog | This determines whether the particles are affected by fog added to
    the scene. This defaults to `true`. |'
  prefs: []
  type: TYPE_TB
- en: The previous example provides a simple control menu that you can use to experiment
    with the properties specific to `THREE.ParticleCloudMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve only rendered the particles as small cubes, which is the default
    behavior. There are, however, a few additional ways you can use to style the particles:'
  prefs: []
  type: TYPE_NORMAL
- en: We can apply `THREE.SpriteCanvasMaterial` (which only works for `THREE.CanvasRenderer`)
    to use the results from an HTML canvas element as a texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `THREE.SpriteMaterial` and a HTML5-based texture to use the output of an
    HTML canvas when working with `THREE.WebGLRenderer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load an external image file (or use the HTML5 canvas) with the `map` property
    of `THREE.PointCloudMaterial` to style all particles of `THREE.ParticleCloud`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we look into how you can do this.
  prefs: []
  type: TYPE_NORMAL
- en: Styling particles with the HTML5 canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js offers three different ways you can use an HTML5 canvas to style your
    particles. If you use `THREE.CanvasRenderer`, you can directly reference an HTML5
    canvas from `THREE.SpriteCanvasMaterial`. When you use `THREE.WebGLRenderer`,
    you need to take a couple of extra steps to use an HTML5 canvas to style your
    particles. In the following two sections, we'll show you the different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML5 canvas with THREE.CanvasRenderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `THREE.SpriteCanvasMaterial`, you can use the output from an HTML5 canvas
    as a texture for your particles. This material is specifically created for `THREE.CanvasRenderer`
    and only works when you use this specific renderer. Before we look at how to use
    this material, let''s first look at the attributes you can set on this material:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This is the color of the particle. Depending on the specified `blending`
    mode, this affects the color of the canvas image. |'
  prefs: []
  type: TYPE_TB
- en: '| `program` | This is a function that takes a canvas context as a parameter.
    This function is called when the particle is rendered. The output from the calls
    to this 2D drawing context is shown as the particle. |'
  prefs: []
  type: TYPE_TB
- en: '| `opacity` | This determines the opacity of the particle. The default value
    is `1`, and there is no opacity. |'
  prefs: []
  type: TYPE_TB
- en: '| `transparent` | This determines whether the particle is transparent or not.
    This works together with the `opacity` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `blending` | This is the blend mode to be used. See [Chapter 9](ch09.html
    "Chapter 9. Animations and Moving the Camera"), *Animations and Moving the Camera*
    for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| `rotation` | This property allows you to rotate the contents of the canvas.
    You''ll usually need to set this to PI to correctly align the contents of the
    canvas. Note that this property can''t be passed in to the constructor of the
    material, but needs to be set explicitly. |'
  prefs: []
  type: TYPE_TB
- en: 'To see `THREE.SpriteCanvasMaterial` in action, you can open the `04-program-based-sprites.html`
    example. The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using HTML5 canvas with THREE.CanvasRenderer](img/2215OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, the particles are created in the `createSprites` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks a lot like the code we saw in the previous section. The main
    change is that because we''re working with `THREE.CanvasRenderer`, we create `THREE.Sprite`
    objects directly, instead of using `THREE.PointCloud`. In this code, we also define
    `THREE.SpriteCanvasMaterial` with a `program` attribute that points to the `draw`
    function. This `draw` function defines what a particle will look like (in our
    case, a ghost from *Pac-Man*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We won't dive into the actual canvas code required to draw our shape. What's
    important here is that we define a function that accepts a 2D canvas context (`ctx`)
    as its parameter. Everything that is drawn onto that context is used as the shape
    for `THREE.Sprite`.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML5 canvas with WebGLRenderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to use an HTML5 canvas with `THREE.WebGLRenderer`, we can take two
    different approaches. We can use `THREE.PointCloudMaterial` and create `THREE.PointCloud`,
    or we can use `THREE.Sprite` and the `map` property of `THREE.SpriteMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the first approach and create `THREE.PointCloud`. In the
    attributes for `THREE.PointCloudMaterial`, we mentioned the `map` property. With
    the `map` property, we can load a texture for the particle. With Three.js, this
    texture can also be the output from an HTML5 canvas. An example showing this concept
    is `05a-program-based-point-cloud-webgl.html`. The following screenshot shows
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using HTML5 canvas with WebGLRenderer](img/2215OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the code we wrote to get this effect. Most of the code is the
    same as our previous WebGL example, so we won''t go into too much detail. The
    important code changes that were made to get this example are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In `getTexture`, the first of these two JavaScript functions, we create `THREE.Texture`
    based on an HTML5 canvas element. In the second function, `createPointCloud`,
    we assign this texture to the `map` property of `THREE.PointCloudMaterial`. In
    this function, you can also see that we set the `sortParticles` property of `THREE.PointCloud`
    to `true`. This property makes sure that before the particles are rendered, they
    are sorted according to their *z* position on screen. If you see partly overlapping
    particles or incorrect transparency, setting this property to `true` will (in
    most cases) fix that. You should note, though, that setting this property to `true`
    will affect the performance of your scene. When this is set to true, Three.js
    will have to determine the distance to the camera for each individual particle.
    For a `THREE.PointCloud` object that is very large, this can have a big impact
    on performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re talking about the properties of `THREE.PointCloud`, there is one
    additional property you can set on `THREE.PointCloud: FrustumCulled`. If this
    property is set to true, it means that if particles fall outside the visible camera
    range, they aren''t rendered. This can be used to improve performance and frame
    rate if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: The result of this is that everything we draw to the canvas in the `getTexture()`
    method is used for the particles in `THREE.PointCloud`. In the following section,
    we'll look a bit deeper into how this works with textures we load from external
    files. Note that in this example, we only see a very small part of what is possible
    with textures. In [Chapter 10](ch10.html "Chapter 10. Loading and Working with
    Textures"), *Loading and Working with Textures*, we'll dive into the details of
    what can be done with textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this section, we mentioned that we could also use `THREE.Sprite`
    together with the `map` property to create a canvas-based particle. For this,
    we use the same approach to create `THREE.Texture` as we saw in the previous example.
    This time, however, we assign it to `THREE.Sprite` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we use a standard `THREE.SpriteMaterial` object and assign
    the output of the canvas as `THREE.Texture` to the `map` property of the material.
    You can view an example of this by opening `05b-program-based-sprites-webgl.html`
    in your browser. Both of these approaches have their own advantages and disadvantages.
    With `THREE.Sprite`, you have more control over the individual particle, but it
    becomes less performant and more complex when you're working with a large number
    of particles. With `THREE.PointCloud`, you can easily manage a large number of
    particles, but have less control over each individual particle.
  prefs: []
  type: TYPE_NORMAL
- en: Using textures to style particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we saw how you could style `THREE.PointCloud` and individual
    `THREE.Sprite` objects using an HTML5 canvas. Since you can draw anything you
    want and even load external images, you can use this approach to add all kinds
    of styles to the particle system. There is, however, a more direct way to use
    an image to style your particles. You can use the `THREE.ImageUtils.loadTexture()`
    function to load an image as `THREE.Texture`. `THREE.Texture` can then be assigned
    to the `map` property of a material.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll show you two examples and explain how to create them.
    Both these examples use an image as a texture for your particles. In the first
    example, we create a simulation of rain, `06-rainy-scene.html`. The following
    screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using textures to style particles](img/2215OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing we need to do is get a texture that will represent our raindrop.
    You can find a couple of examples in the `assets/textures/particles` folder. In
    [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, we will explain all the details and requirements for textures.
    For now, all you need to know is that the texture should be square and preferably
    a power of 2 (for example, 64 x 64, 128 x 128, 256 x 256). For this example, we''ll
    use this texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using textures to style particles](img/2215OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This image uses a black background (needed for correct blending) and shows
    the shape and color of a raindrop. Before we can use this texture in `THREE.PointCloudMaterial`,
    we first need to load it. This can be done with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this line of code, Three.js will load the texture, and we can use it in
    our material. For this example, we defined the material like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we've discussed all of these properties. The main thing to
    understand here is that the `map` property points to the texture we loaded with
    the `THREE.ImageUtils.loadTexture()` function, and we specify `THREE.AdditiveBlending`
    as the `blending` mode. This `blending` mode means that when a new pixel is drawn,
    the color of the background pixel is added to the color of this new pixel. For
    our raindrop texture, this means that the black background won't be shown. A logical
    alternative would be to replace the black from our texture with a transparent
    background, but that doesn't work with particles and WebGL unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of styling `THREE.PointCloud`. What you''ll also see when you
    open up this example is that the particles themselves are moving. In the previous
    examples, we moved the entire particle system; this time, we position the individual
    particles within `THREE.PointCloud`. Doing this is actually very simple. Each
    particle is represented as a vertex that makes up the geometry that was used to
    create `THREE.PointCloud`. Let''s look at how we add the particles for `THREE.PointCloud`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t that different from the previous examples we saw. Here, we added
    two additional properties to each particle (`THREE.Vector3`): `velocityX` and
    `velocityY`. The first one defines how a particle (a raindrop) moves horizontally,
    and the second one defines how fast the raindrop falls down. The horizontal velocity
    ranges from -0.16 to +0.16, and the vertical speed ranges from 0.1 to 0.3\. Now
    that each raindrop has its own speed, we can move the individual particles inside
    the render loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we get all `vertices` (particles) from the geometry that
    was used to create `THREE.PointCloud`. For each of the particles, we take `velocityX`
    and `velocityY` and use them to change the current position of the particle. The
    last two lines make sure the particles stay within the range we've defined. If
    the `v.y` position drops below zero, we add the raindrop back to the top, and
    if the `v.x` position reaches any of the edges, we make it bounce back by inverting
    the horizontal velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example. This time, we won''t make rain, but we''ll
    make snow. Additionally, we won''t be using just a single texture, but we''ll
    use five separate images (taken from the Three.js examples). Let''s start by looking
    at the result again (see `07-snowy-scene.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using textures to style particles](img/2215OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see that instead of using just a single
    image as texture, we''ve used multiple images. You might wonder how we did this.
    As you probably remember, we can only have a single material for `THREE.PointCloud`.
    If we want to have multiple materials, we just have to make multiple particle
    systems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that we load the textures separately and pass all the information
    on how to create `THREE.PointCloud` to the `createPointCloud` function. This function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do in this function is define the color in which the particles
    for this specific texture should be rendered. This is done by randomly changing
    the *lightness* of the passed-in color. Next, the material is created in the same
    manner we did before. The only change here is that the `depthWrite` property is
    set to `false`. This property defines whether this object affects the WebGL depth
    buffer. By setting this to `false`, we make sure that the various point clouds
    don''t interfere with each other. If this property isn''t set to `false`, you''ll
    see that the black background from the texture is sometimes shown when a particle
    is in front of a particle from another `THREE.PointCloud` object. The last step
    taken in this piece of code is randomly placing the particles and adding a random
    speed to each particle. In the render loop, we can now update the position of
    all the particles from each `THREE.PointCloud` object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, we can have particles that have different textures. This
    approach, however, is a bit limited. The more different textures we want, the
    more point clouds we'll have to create and manage. If you have a limited set of
    particles with different styles, you'd better use the `THREE.Sprite` object we
    showed at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with sprite maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we used a `THREE.Sprite` object to render
    single particles with `THREE.CanvasRenderer` and `THREE.WebGLRenderer`. These
    sprites were positioned somewhere in the 3D world, and their size was based on
    the distance from the camera (this is also sometimes called **billboarding**).
    In this section, we'll show an alternative use of the `THREE.Sprite` object. We'll
    show you how you can use `THREE.Sprite` to create a layer similar to **head-up
    display** (**HUD**) for your 3D content using an extra `THREE.OrthographicCamera`
    instance. We will also show you how to select the image for a `THREE.Sprite` object
    using a sprite map.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''re going to create a simple `THREE.Sprite` object that moves
    from left to right over the screen. In the background, we''ll render a 3D scene
    with a moving camera to illustrate that `THREE.Sprite` moves independently of
    the camera. The following screenshot shows what we''ll be creating for the first
    example (`08-sprites.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with sprite maps](img/2215OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you open this example in your browser, you''ll see a Pac-Man ghost-like
    sprite moving across the screen and changing color and form whenever it hits the
    right edge. The first thing we''ll do is look at how we create `THREE.OrthographicCamera`
    and a separate scene to render `THREE.Sprite` in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the construction of `THREE.Sprite` and how the various
    shapes the sprite can take are loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getTexture()` function, we load a texture. However, instead of loading
    five different images for each *ghost*, we load a single texture that contains
    all the sprites. The texture looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with sprite maps](img/2215OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the `map.offset` and the `map.repeat` properties, we select the correct
    sprite to show on screen. With the `map.offset` property, we determine the offset
    for the *x* axis (u) and the *y* axis (v) for the texture we loaded. The scale
    for these properties runs from 0 to 1\. In our example, if we want to select the
    third ghost, we set the u-offset (*x* axis) to 0.4, and, because we've only got
    one row, we don't need to change the v-offset (*y* axis). If we only set this
    property, the texture shows the third, fourth, and fifth ghosts compressed together
    on screen. To only show one ghost, we need to zoom in. We do this by setting the
    `map.repeat` property for the u-value to 1/5\. This means that we zoom in (only
    for the *x* axis) to only show 20 percent of the texture, which is exactly one
    ghost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step we need to take is update the `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We first render the scene with the normal camera and the moving sphere, and
    after that, we render the scene containing our sprite. Note that we need to set
    the `autoClear` property of the WebGLRenderer to `false`. If we don't do this,
    Three.js will clear the scene before it renders the sprite, and the sphere wouldn't
    show up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows an overview of all the properties of `THREE.SpriteMaterial`
    we used in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This is the color of the sprite. |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | This is the texture to be used for this sprite. This can be a sprite
    sheet, as shown in the example in this section. |'
  prefs: []
  type: TYPE_TB
- en: '| `sizeAnnutation` | If this is set to `false`, the size of the sprite won''t
    be affected by the distance it''s removed from the camera. The default value is
    `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `opacity` | This sets the transparency of the sprite. The default value is
    `1` (no opacity). |'
  prefs: []
  type: TYPE_TB
- en: '| `blending` | This defines the blend mode to be used when rendering the sprite.
    See [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, for more information on blend modes. |'
  prefs: []
  type: TYPE_TB
- en: '| `fog` | This determines whether the sprite is affected by fog added to the
    scene. This defaults to `true`. |'
  prefs: []
  type: TYPE_TB
- en: You can also set the `depthTest` and `depthWrite` properties on this material.
    For more information on these properties, see [Chapter 4](ch04.html "Chapter 4. Working
    with Three.js Materials"), *Working with Three.js Materials*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, also use a sprite map when positioning `THREE.Sprites` in
    3D (as we did at the beginning of this chapter). An example (`09-sprites-3D.html`)
    of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with sprite maps](img/2215OS_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the properties we saw in the previous table, we can very easily create
    the effect we see in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create 400 sprites based on the sprite sheet we showed
    earlier. You''ll probably know and understand most of the properties and concepts
    shown here. As we''ve added the separate sprites to a group, rotating them is
    very easy and can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, so far we've mainly looked at creating sprites and point clouds
    from scratch. An interesting option, though, is to create `THREE.PointCloud` from
    an existing geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Creating THREE.PointCloud from an advanced geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you remember, `THREE.PointCloud` renders each particle based on the vertices
    from the supplied geometry. This means that if we provide a complex geometry (for
    example, a torus knot or a tube), we can create `THREE.PointCloud` based on the
    vertices from that specific geometry. For this last section of this chapter, we'll
    create a torus knot, like the one we saw in the previous chapter, and render it
    as `THREE.PointCloud`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already explained the torus knot in the previous chapter, so we won''t
    go into much detail here. We''re using the exact code from the previous chapter,
    and we''ve added a single menu option that you can use to transform the rendered
    mesh into `THREE.PointCloud`. You can find the example (`10-create-particle-system-from-model.html`)
    in the sources for this chapter. The following screenshot shows the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating THREE.PointCloud from an advanced geometry](img/2215OS_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, every vertex used to generate the
    torus knot is used as a particle. In this example, we''ve added a nice-looking
    material, based on a HTML canvas, to create this glowing effect. We''ll only look
    at the code to the create the material and the particle system as we''ve already
    discussed the other properties in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code fragment, you can see two functions: `createPointCloud()` and
    `generateSprite()`. In the first function, we create a simple `THREE.PointCloud`
    object directly from the geometry provided (in this example, a torus knot) and
    set the texture (the `map` property) to a glowing dot (generated on an HTML5 canvas
    element) with the `generateSprite()` function, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating THREE.PointCloud from an advanced geometry](img/2215OS_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's a wrap for this chapter. We've explained what particles, sprites, and
    particle systems are and how you can style these objects with the available materials.
    In this chapter, you saw how you can use `THREE.Sprite` directly with `THREE.CanvasRenderer`
    and `THREE.WebGLRenderer`. If you want to create a large number of particles,
    however, you should use `THREE.PointCloud`. With `THREE.PointCloud`, all the particles
    share the same material, and the only property you can change for an individual
    particle is their color by setting the `vertexColors` property of the material
    to `THREE.VertexColors` and providing a color value in the `colors` array of `THREE.Geometry`
    used to create `THREE.PointCloud`. We also showed how you can easily animate particles
    by changing their position. This works the same for an individual `THREE.Sprite`
    instance and the vertices from the geometry used to create `THREE.PointCloud`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created meshes based on geometries provided by Three.js. This
    works great for simple models such as spheres and cubes but isn't the best approach
    when you want to create complex 3D models. For those models, you'd usually use
    a 3D modeling application such as Blender or 3D Studio Max. In the next chapter,
    you'll learn how you can load and display models created by such 3D modeling applications.
  prefs: []
  type: TYPE_NORMAL
