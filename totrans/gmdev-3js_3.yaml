- en: Chapter 3. Exploring and Interacting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how users can interact with our games. We'll also cover
    some physics and use what we've learned to create a basic first-person shooter
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard movement and mouse looking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to move our camera around, we''re going to encapsulate some state,
    so let''s define a `KeyboardControls` class in a new JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we added listeners for the `keydown` event and the `keyup`
    event so that when a key is pressed, we can keep track of the direction in which
    we should move. (In JavaScript, pressed keys are identified by numeric key codes.)
    In our `update` method, we just move in the specified direction. This is accomplished
    by checking flags that we set during key events so that we can poll the keyboard
    state during each frame. We can then use the controller by declaring it with `new`
    `KeyboardControls(camera)` and make it affect the camera in every frame by calling
    `controls.update(delta)` in our animation loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever written event-driven JavaScript before, most of this should look
    pretty familiar, and it's not hard to see how this could be extended in different
    ways to support different control mechanisms. Luckily, most applications are controlled
    pretty similarly, so Three.js provides a number of default control handlers that
    take care of most of this for you. These controllers are located in `examples/js/controls`
    and not in the main library, so you need to make sure to include them separately
    in your HTML file if you want to use them. Feel free to copy and extend an existing
    controller if you want a slightly different behavior, rather than writing your
    own controller from scratch every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The available controllers are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constructor | Important properties | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FirstPersonControls` | `movementSpeed = 1.0``lookSpeed = 0.005``constrainVertical
    = false``freeze = false` | Keyboard movement (*WASD* or arrow keys for forward/back/strafe;
    up/down with *R* or *F*) and look around by following the mouse. |'
  prefs: []
  type: TYPE_TB
- en: '| `FlyControls` | `movementSpeed = 1.0``rollSpeed = 0.005` | Press keys to
    move (*WASD*), tilt (*QE*), and look around (up/down/left/right). |'
  prefs: []
  type: TYPE_TB
- en: '| `OculusControls` | `freeze = false` | Use the Oculus Rift virtual reality
    headset. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrbitControls` | `enabled = true``target = new THREE.Vector3()``zoomSpeed
    = 1.0``minDistance = 0``maxDistance = Infinity``rotateSpeed = 1.0``keyPanSpeed
    = 7.0``autoRotateSpeed = 2.0` | Rotate, pan, and zoom with mouse or touch controls,
    maintaining the *up* direction along the positive y axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `PathControls` | `duration = 10000``waypoints = []``lookSpeed = 0.005``lookVertical
    = true``lookHorizontal = true` | Move along a predefined route and look around
    by following the mouse. |'
  prefs: []
  type: TYPE_TB
- en: '| `PointerLockControls` |   | Keyboard movement (*WASD* or arrow keys for forward/back/strafe/jump)
    and look around by locking to the mouse. Requires that the canvas is in pointer
    lock mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `TrackballControls` | `enabled = true``rotateSpeed = 1.0``zoomSpeed = 1.2``panSpeed
    = 0.3``minDistance = 0``maxDistance = Infinity` | Rotate, pan, zoom, and tilt
    with mouse or touch controls. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransformControls` | `size = 1` | Creates a widget around an object that
    allows users to rotate, scale, and translate it. Mainly used in an editor. |'
  prefs: []
  type: TYPE_TB
- en: All the `controller` constructors take `camera` as their first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `FirstPersonControls` controller to our city example from the
    last chapter and try flying around to see the city from the streets. First, we
    need to add the JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll add some globals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll instantiate the `controls` variable and the `clock` variable in
    `setupThreeJS()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A `clock` is a timer. We'll use it in this case to keep track of the amount
    of time that passes between each frame we draw. Also note that we changed the
    speed at which the camera moves and looks; otherwise, it feels very sluggish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll change our animation loop in the `setup()` function to update
    our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Updating the controls allows the camera to move when each frame is rendered.
    The clock's `getDelta` method returns the amount of time in seconds since the
    last time the `getDelta` method was called, so in this case it returns the number
    of seconds since the last frame was rendered. Internally, the controls use that
    delta to make sure that the animation is smooth over time. Now we can fly around
    our city!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the following screenshot what the city might look like from
    the ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Keyboard movement and mouse looking](img/8539OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flying around the city
  prefs: []
  type: TYPE_NORMAL
- en: Clicking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clicking on the screen in order to select or interact with something is a common
    requirement, but it's somewhat harder than it sounds because of the need to project
    the location of the click in the 2D plane of your screen into the 3D world of
    Three.js. To do this, we draw an imaginary line, called a ray, from the camera
    toward the position where the mouse might be in 3D space and see if it intersects
    with anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to project, we first need a projector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to register a listener on the click event for the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous code assumes that you are using the `PerspectiveCamera` class.
    If you are using the `OrthographicCamera` class, projectors have a utility method
    that returns an appropriate raycaster, and you do not have to un-project the vector
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous code listens to the `mousedown` event on the renderer's canvas.
    Then, it creates a new `Vector3` instance with the mouse's coordinates on the
    screen relative to the center of the canvas as a percent of the canvas width.
    That vector is then un-projected (from 2D into 3D space) relative to the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the point in 3D space representing the mouse's location, we draw
    a line to it using the `Raycaster`. The two arguments that it receives are the
    starting point and the direction to the ending point. We determine the direction
    by subtracting the mouse and camera positions and then normalizing the result,
    which divides each dimension by the length of the vector to scale it so that no
    dimension has a value greater than `1`. Finally, we use the ray to check which
    objects are located in the given direction (that is, under the mouse) with the
    `intersectObjects` method. `OBJECTS` is an array of objects (generally meshes)
    to check; be sure to change it appropriately for your code. An array of objects
    that are behind the mouse are returned and sorted by distance, so the first result
    is the object that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Each object in the `intersects` array has an `object`, `point`, `face`, and
    `distance` property. Respectively, the values of these properties are the clicked
    object (generally a `Mesh`), a `Vector3` instance representing the clicked location
    in space, the `Face3` instance at the clicked location, and the distance from
    the camera to the clicked point.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to go in reverse (3D to 2D) by projecting instead of un-projecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After this code runs, `vector.x` and `vector.y` will hold the horizontal and
    vertical coordinates of the specified point relative to the upper-left corner
    of the canvas. (Make sure you actually specify the point you want, instead of
    using `mesh.position.clone()`, and that you've instantiated your `projector`.)
    Note that the resulting coordinates might not be over the canvas if the original
    3D point is not on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing you want when your player is clicking madly to shoot at enemies
    is for the whole screen to suddenly turn blue because the browser thinks the user
    is trying to select something. To avoid this, you can either cancel the `select`
    event in JavaScript with `document.onselectstart = function() { return false;
    }` or disable it in CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start building more realistic examples, you'll notice delta parameters
    being passed around to functions that affect physics. Those deltas represent an
    amount of time since the last time physics was calculated, and they're used to
    smooth out movement over time.
  prefs: []
  type: TYPE_NORMAL
- en: The naive way to move objects in code is to simply change the object's position.
    For example, to move an object across the canvas, you might write `obj.x += 10`
    inside your animation loop to move it 10 units every frame. This approach suffers
    from the issue that it is dependent on the frame rate. In other words, if your
    game is running slowly (that is, fewer frames per second), your object will also
    appear to move slowly, whereas if your game is running quickly (that is, more
    frames per second), your object will appear to move quickly.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to multiply the speed by the amount of time that has passed
    between rendering frames. For example, if you want your object to move 600 units
    per second, you might write `obj.x += 600 * delta`. In this way, your object will
    move a constant distance over time. However, at low frame rates and high speeds,
    your object will be moving large distances every frame, which can cause it to
    do strange things such as move through walls. At high frame rates, computing your
    physics might take longer than the amount of time between frames, which will cause
    your application to freeze and crash (this is called a *spiral of death*). Additionally,
    we would like to achieve perfect reproducibility. That is, every time we run the
    application with the same input, we would like exactly the same output. If we
    have variable frame deltas, our output will diverge the longer the program runs
    due to accumulated rounding errors, even at normal frame rates.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to separate physics update time-steps from frame refresh
    time-steps. The physics engine should receive fixed-size time deltas, while the
    rendering engine should determine how many physics updates should occur per frame.
    The fixed-size deltas avoid an inconsistent rounding error and ensure that there
    are no giant leaps between frames. The following code shows how to divide the
    amount of time between frames into discrete chunks to use for physics calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare `INV_MAX_FPS`, the multiplicative inverse of the maximum frames
    per second that we want to render (`60` in this case). This is the time-step we
    will feed to our physics engine via the `update` function, and you may need to
    adjust it depending on how slowly your simulation runs (keep in mind that most
    monitors can't refresh faster than 60 frames per second, and above 30 is usually
    considered acceptable). Then, we start tracking our `frameDelta`, the accumulated
    amount of time since the last physics update. Our clock will be used to keep track
    of the time between rendering frames.
  prefs: []
  type: TYPE_NORMAL
- en: In the animation loop, we first add the amount of time since the last render
    to `frameDelta`, then perform as many fixed-size physics updates as we need. We
    might end up with some time left over in `frameDelta`, but it will be used up
    during the next frame.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, "physics updates" means both moving objects in our world and
    moving the player's camera.
  prefs: []
  type: TYPE_NORMAL
- en: First-person shooter project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a real game! This project will be bigger than any others we''ve
    done, so let''s start by specifying exactly what to accomplish. We''re going to
    build an arena-based first-person shooter game with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A world based on a voxel map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A player that can look, run, and jump around in the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer lock and full-screen, so that the player is fully immersed as in a desktop
    or console game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player should be able to shoot at enemies that wander around, and the enemies
    should shoot back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player's and enemies' health should deteriorate when shot, and players should
    respawn when they run out of health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player's screen should flash red when shot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be a **HUD** (**heads-up display**) with crosshairs and a health
    indicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not care much about lighting or texturing, except that the player must
    be able to see and perceive distances in depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete code is too long to include here, but you can download it online
    from your account at [http://www.packtpub.com](http://www.packtpub.com) or have
    the files e-mailed to you at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    The rest of this section covers interesting excerpts from the code.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to write the HTML code. In the previous examples, we've written
    all of our code in a single HTML file, but this is a bigger project so we should
    split the code into separate files and reference them from our `index.html` file.
    We'll also want to add some user-interface elements to the basic HTML document,
    notably including a `start` screen that the user must click in order to enter
    the game and a `hurt` div, which is just a translucent red overlay that we'll
    flash briefly on the screen as a helpful warning when the player gets hit by an
    enemy bullet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We'll also break up the `main.js` file into a few different files when we start
    writing classes. For simplicity we've put everything in the same folder. In [Chapter
    5](ch05.html "Chapter 5. Design and Development"), *Design and Development*, we
    take a closer look at better organizational structures for large projects.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a place to put some code, we need an interesting world to
    look at. Let''s design a map to use. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our map is represented as a string where `X` indicates a wall and `S` indicates
    a location where players can spawn into the world. We split the string into an
    array for easier access, then decide how big each voxel should be (in this case,
    100 * 100 * 100 as indicated by the `HORIZONTAL_UNIT` and `VERTICAL_UNIT` variables)
    and track how big the map is overall using `XSIZE` and `ZSIZE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to use our map to generate the 3D world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty straightforward—iterating over the map and adding something
    into the world at the specified row and column. Our `addVoxel` method looks similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In order to see our world, we'll also need to add lighting (the easiest approach
    is one or two `DirectionalLights` similar to what we used in the city project)
    and you may also want to add fog to help with depth perception. You can manually
    adjust the camera's `position` and `rotation` to see what you've just constructed,
    or temporarily add `FirstPersonControls` similar to what we used in the city project.
    Since we are only using our map to add walls, you should add a floor as we did
    in the city project as well, using a single large plane.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a world, let''s create a player that can move around in it.
    We''ll need a `Player` class to keep track of each player''s state, so let''s
    extend `THREE.Mesh` in a new file, which we''ll call `player.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We implemented `Player` as a child of the `THREE.Mesh` class by calling the
    `Mesh` constructor from inside the `Player` constructor and copying over the `prototype`.
    This means that players automatically have geometry, materials, position, rotation,
    and scaling, and additionally we can implement our own features (such as velocity
    and acceleration). Note that the player functions similar to a controller because
    it contains code to move and look around, with the difference that the input event
    handlers are bound outside the class in order to make it reusable.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that may look strange here is changing the `rotation.order`. Rotation
    is tracked using a Euler representation, which consists of angles in radians around
    each axis in addition to the order in which the axial rotation should be applied.
    The default order is `'XYZ'`, which rotates up and down first (x), then left to
    right (y). In this configuration, the world will appear to tilt if the player
    looks horizontally after looking vertically. To visualize this, imagine tilting
    a donut so that the side away from you is up and the side near you is down; that
    is x rotation, or **pitch**. If you then move your finger around the donut from
    the front to the left, that is y rotation, or **yaw**. (Tilting the donut to the
    right would be z rotation, or **roll** **.**) Notice that if you were looking
    out from the middle of the donut towards your finger, your head would be tilted
    relative to the world. As a result, we have to change the Euler order to `'YXZ'`
    to make the camera rotate relative to the world instead of to itself. With this
    change, we move our finger first, then tilt the donut so our finger goes up or
    down instead of the front of the donut, and we end up with a level head.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually implement this looking around, we''ll lock the mouse and track
    its movement. We''ll use libraries to make this easier since the APIs are a little
    wordy. You can get `PointerLock.js` at [https://github.com/IceCreamYou/PointerLock.js](https://github.com/IceCreamYou/PointerLock.js)
    and BigScreen from *Brad Dougherty* at [https://github.com/bdougherty/BigScreen](https://github.com/bdougherty/BigScreen).
    Once we have included these libraries, starting the game looks similar to the
    following code, which requests the browser to enter full screen and pointer lock
    mode before starting animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Pointer Lock and Full Screen APIs can only be engaged when users take an
    action (clicking or hitting the keyboard) as a security precaution to prevent
    attackers from hijacking your screen, so we''re waiting for a click in this case.
    Once we''re in full screen, we can listen to the `mousemove` event to rotate the
    player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `event.movementX` property and the `event.movementY` property are normalized
    across browsers here by the `PointerLock.js` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rotate()` method simply changes the player''s `_aggregateRotation` vector.
    We''re assuming here that the player has been instantiated, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yes, we just added the `camera` to the `player`. It turns out that any object
    that is a descendant of `THREE.Object3D` can have other objects added to it. Those
    child objects are accessible through the parent's `children` array, and they will
    be grouped together with the parent so that movement, rotation, and scaling are
    composed. (In other words, if a child's local position is `(0, 0, 5)` and the
    parent's position is `(0, 0, 10)`, then the child's position in the world will
    be `(0, 0, 15)`. Rotation and scale work similarly.) In this case, we use this
    composition to cause our camera to follow our player around.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because child objects' position, rotation, and scaling are relative to the parent's
    position, rotation, and scaling, you could create a third-person camera by positioning
    the camera on the positive z axis (and probably a little higher on the y axis)
    and giving the `player` object a geometry and material (remember, `Player` inherits
    from `Mesh`, so you can instantiate a player with `new Player(geometry, material)`).
  prefs: []
  type: TYPE_NORMAL
- en: Player movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll finish off the code to look around in a moment, but because it's closely
    related to the player's movement, let's address that first.
  prefs: []
  type: TYPE_NORMAL
- en: Physical movement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting movement right is a complex topic. Although simply adding a constant
    velocity to an object''s position can work for some simulations, more advanced
    games will want to have acceleration at play (for example, for gravity) and potentially
    other forces as well. The most straightforward approach to linear forces is to
    keep track of acceleration and velocity vectors and add them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called **Euler** integration (pronounced oiler, not yew-ler). A simple
    modification gives us **Midpoint** integration, which yields a reasonable improvement
    in accuracy. All we need to do is apply the acceleration in halves before and
    after applying velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how this works, consider the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physical movement](img/8539OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Euler versus Midpoint integration
  prefs: []
  type: TYPE_NORMAL
- en: The goal of our integration formula is to stay as close to the true position
    as possible. In the graph, the vertical jumps are at our time-steps, where physics
    updates are calculated. The midpoint curve is just a shift of the Euler curve
    so that the area between the midpoint and true positions cancel out. More error
    is introduced when acceleration, jerk, and nonlinear forces are applied, but for
    our purposes (and in the space we have) the midpoint formula is a reasonable trade-off
    between simplicity and accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: The **fourth-order Runge-Kutta** method (also known as **RK4**) is another commonly
    used method for computing motion over time. RK4 extrapolates several intermediate
    states between frames, resulting in a more accurate final approximation for the
    state in the next frame. The trade-off for increased accuracy is increased complexity
    and decreased speed. Because of its complexity, we won't cover it here, but usually
    if you need something as sophisticated as this, you will want to delegate physics
    handling to one of the libraries addressed in the next section on collision.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the player's movement and rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s listen for the movement keys so that we know when to move the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We'll check these flags in every frame to see how much thrust to apply. We also
    need a `keyup` listener, which looks almost identical to the `keydown` listener
    except that it should set our directions back to `false` when the relevant keys
    are released.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, finally, we can implement the player''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot going on here. The first thing to notice is that our definition
    of the method immediately invokes an anonymous function that returns our actual
    method definition. We do this to create some helper objects for efficiency. Most
    Three.js math happens in place (as opposed to returning a new object with the
    result of each operation), which means that to perform calculations with existing
    math objects such as the `acceleration` vector, we either need to clone them or
    copy values to a `helper` object that we can manipulate without side effects.
    Cloning creates too much garbage-collection churn, meaning that the browser will
    lag if it has to process all the objects we would be rapidly creating and then
    discarding. Instead, we define the `halfAccel` vector, for example, in a closure
    (so that it doesn't pollute the global namespace) and do our vector math with
    that. This pattern is used frequently in the Three.js library itself.
  prefs: []
  type: TYPE_NORMAL
- en: Almost everything else in the `update` method is addition and multiplication.
    To look around, we aggregate how far the mouse has moved between each frame, then
    add the corresponding amount of rotation when the player is updating. Also, the
    acceleration and velocity part should look familiar—it's the same midpoint strategy
    we just covered in the *Physical movement* section. We have to be sensitive to
    a few issues though. First, we restrict `r.x` in order to constrain how far the
    player can look up and down so that they don't get confused which way is up. Second,
    we want the concept of *forward* to be relative to the world instead of where
    the camera is looking, so that we can look up and walk forward without flying
    into the air in the direction we're looking. To do this, we reset the pitch (making
    the player look straight ahead instead of up or down) before adding the velocity
    to the position. Finally, we add friction, which allows the player to slow down
    and stop after moving in a given direction. In your actual game, you will probably
    want to use different levels of friction depending on whether your player is in
    the air or not.
  prefs: []
  type: TYPE_NORMAL
- en: Player collision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several different approaches to detecting collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Voxels**: As discussed in [Chapter 2](ch02.html "Chapter 2. Building a World"),
    *Building a World*, one common way to design worlds is to use a string or image
    to represent repeatable building blocks, such as LEGOs. When using this method,
    the fastest way to check for collision between an actor and the world is to simply
    check if the actor''s coordinates are inside the zone that the map designates
    for use by a building block. This avoids the complexity of comparing 3D shapes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rays**: Just like we used the `Raycaster` class earlier to detect clicked
    objects, we can also use it to detect collision between multiple objects with
    the `intersectObjects()` method. To do this, we can cast rays in multiple directions
    from the object that needs to check for collision, such as the player; for example,
    we could cast a ray from the player''s position toward each of the player''s vertices.
    If an intersection occurs at a distance smaller than the distance from the player''s
    position to the vertex, a collision has occurred. There are several problems with
    this method. First, it''s inefficient for large numbers of vertices or dynamic
    objects. Second, objects can escape detection if they are not exactly in the direction
    of a ray. Lastly, rays check for intersection using an approximation of objects''
    shapes, so irregularly-shaped objects can be incorrectly selected. However, this
    is the simplest general-purpose approach that can work without additional libraries
    or knowledge about the world''s layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intersection**: We can manually compare objects'' geometries and positions
    to see if they overlap. Since detecting collision between complex 3D shapes is
    mathematically difficult, most games use simplified approximations instead of
    the actual geometry to make calculations easier. Even so, 3D collision detection
    algorithms are complex and slow unless we use very simple shapes such as boxes
    or spheres that don''t do a great job of approximating our objects. It''s also
    computationally expensive without some complex optimizations such as using a data
    structure called an **Octree** to make sure only nearby objects need to check
    for collision. If you want to try implementing your own collision, Three.js includes
    an Octree implementation in the `examples/js` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Libraries**: Luckily, we don''t have to do complex collision detection manually,
    as there are several libraries that can take care of the complications for us.
    They also handle collision response and associated physics. The leading contenders
    are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ammo.js** is a large but complete library compiled to JavaScript from C++.
    It is available at [https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cannon.js** is a smaller library written from scratch in JavaScript and inspired
    in part by concepts from Three.js. It is available at [https://github.com/schteppe/cannon.js](https://github.com/schteppe/cannon.js).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physi.js** is a bridge between Ammo or Cannon and Three.js that also runs
    the physics simulation in a separate thread to avoid blocking the rendering. It
    is available at [https://github.com/chandlerprall/Physijs](https://github.com/chandlerprall/Physijs).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For our shooter game, we'll use voxel collision and a little bit of manual intersection.
    Unfortunately, all the physics libraries are large, so we don't have space to
    cover their APIs here. However, Cannon.js and Physi.js have examples specifically
    for use with Three.js available from their project pages.
  prefs: []
  type: TYPE_NORMAL
- en: Voxel collision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we try to walk around our world now, we''ll just fall through the floor.
    Let''s create a function to check for collision between the player and the voxel
    world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `collideFloor` method keeps the player above the floor''s y position. Then,
    the `mapCellFromPosition` method looks up the map cell from the player''s position
    to determine whether the player is in a wall or open space. If the player is colliding
    with a wall, the `moveOutside()` method moves the player outside of it by shifting
    the player toward the closest cell. The cell-from-position lookup is just the
    reverse of what we used to place each voxel originally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Bots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve got the player working, it''s time to add enemy bots. Enemies
    can be `Player`s just as the user is, so apart from initializing them, the main
    thing we need to add is autonomous behavior. We don''t have the space here to
    go in depth on artificial intelligence strategies, so we''ll just set each bot''s
    `moveDirection` flags randomly every once in awhile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Bullets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s add shooting so we can pulverize those enemies! First, we''ll
    create a new `Bullet` class in `bullet.js` similar to what we did for the `Player`
    class. Bullets are just meshes with a `direction` vector and a `speed` scalar,
    so their `update` method can be pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll set bullets'' directions when they''re shot. Bullets can either be shot
    in the camera''s direction or from an enemy bot toward another player. To get
    the relevant direction, our `shoot` function will look similar to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We get the direction from one player to another by subtracting their positions.
    If the user is shooting then we aren't necessarily aiming at anything, so we just
    want the direction in which the camera is looking. We retrieve this direction
    from the player's rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the game loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bringing it all together, we should end up with a function like this, which
    executes all of our game''s behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function calculates all physics (including movement and collision checking),
    triggers autonomous behavior such as the bots shooting at targets, and implements
    game logic (such as players dying when their health is too low). It is called
    in every frame from the animation loop. The delta parameter is the physics time-step,
    so it should always be the same value as discussed in the *Timing* section of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was a lot of code to write! We''re rewarded, though, with an awesome arena-based
    first-person shooter game that you can put online and send to all your friends.
    You can see how all that work might look in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the game loop](img/8539OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the finished game
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement user interaction and game physics.
    We also built a full-fledged first-person shooter game. In the next chapter, we'll
    add detail to our worlds with imported models, particle systems, sound, and post-processing
    effects.
  prefs: []
  type: TYPE_NORMAL
