- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Managing Static Assets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理静态资源
- en: When it comes to managing static assets, SvelteKit has little to do with the
    process. In fact, the entire process is handed over to the bundling tool Vite.
    By leveraging Vite for the management of static assets, we as developers don’t
    have to learn yet another framework-specific strategy. Instead, we can lean on
    Vite’s highly performant bundling and build processes. Because Vite automatically
    manages imported assets, we don’t have to worry about hashing files for caches.
    In this chapter, we’ll look at how we can leverage Vite to manage static assets
    such as images, fonts, audio, video, and CSS files. Once we examine *how* this
    is done, we’ll discuss some of the finer points surrounding static assets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到管理静态资源时，SvelteKit与这个过程几乎没有关系。实际上，整个过程都交给了打包工具Vite。通过利用Vite来管理静态资源，我们作为开发者无需再学习另一个框架特定的策略。相反，我们可以依赖Vite的高效打包和构建过程。因为Vite自动管理导入的资源，我们无需担心为缓存文件进行哈希处理。在本章中，我们将探讨如何利用Vite来管理静态资源，如图片、字体、音频、视频和CSS文件。一旦我们考察了*如何*实现这一点，我们还将讨论一些与静态资源相关的细节。
- en: 'This chapter will be divided into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为以下部分：
- en: Importing Assets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入资源
- en: Additional Information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他信息
- en: By the time we’re done, we’ll have a firm grasp of the best practices to use
    when including files that can be served *as is* within SvelteKit applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到我们完成时，我们将对在SvelteKit应用程序中包含可以“原样”提供的服务文件的最佳实践有一个牢固的掌握。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter10](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter10).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter10](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter10)。
- en: Importing Assets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入资源
- en: If you have worked in web development for the past decade, then you’ll remember
    a time when styles were written either inline or in a **Cascading Style Sheet**
    (**CSS**). These **CSS** files are helpful for creating a consistent look and
    feel for an application. Of course, their centralized nature comes with its own
    drawbacks. They often become large and difficult to navigate, which can lead to
    the inclusion of unused style rules. When precious milliseconds can mean the difference
    between converting a user or losing a sale, it’s important not to ship unused
    assets to clients. Besides, if we’re building a web application with SvelteKit,
    we really should use the Svelte approach and keep styles isolated within each
    component. But there are times when it’s useful to keep a style sheet that applies
    some global styles. For instance, imagine having to apply a specific style to
    each and every paragraph element. Incorporating the same simple style rule into
    every component across the application could lead to repetitive code. There may
    even be instances where we forget to include a rule, leading to inconsistent styles
    across the app. And while projects such as **Tailwind CSS** or **Bootstrap** are
    wonderful, they may not be appropriate for every project, which is why we’re going
    to cover how to include a global style sheet in our SvelteKit application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你过去十年从事过Web开发，那么你可能会记得一个时期，那时样式要么是内联编写的，要么是在**层叠样式表**（**CSS**）中编写的。这些**CSS**文件对于创建应用程序的一致外观和感觉非常有帮助。当然，它们的集中化性质也带来了自己的缺点。它们通常变得很大且难以导航，这可能导致包含未使用的样式规则。当宝贵的毫秒可以决定用户转化或失去销售的时候，不向客户发送未使用的资源是非常重要的。此外，如果我们用SvelteKit构建Web应用程序，我们真的应该使用Svelte方法，并将样式隔离在每个组件中。但有时保留一个应用全局样式的样式表是有用的。例如，想象一下需要将特定样式应用到每个段落元素上。将相同的简单样式规则应用到应用程序中的每个组件可能会导致代码重复。甚至可能存在我们忘记包含规则的情况，导致应用程序中样式不一致。虽然像**Tailwind
    CSS**或**Bootstrap**这样的项目很棒，但它们可能并不适合每个项目，这就是为什么我们将介绍如何在SvelteKit应用程序中包含全局样式表。
- en: 'To begin, we’ll need some styles. Keep in mind that these styles will apply
    to the entirety of the application. Normally, when creating styles within Svelte
    components, those styles are isolated to that specific component, meaning they
    are not applied to parent or child components. Many modern browsers apply their
    own default styles to HTML elements, and so, to unify the experience of an application,
    it’s common practice to create a `reset.css` file. This file ensures the experience
    is consistent across different browsers by resetting the styles applied by browsers
    of common elements to something predictable. For our example, we’ll use a slightly
    modified version of the concise yet thorough **Custom CSS Reset** by *Josh W.
    Comeau*. See the resources at the end of this chapter for links to the article
    explaining exactly how it works:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些样式。请注意，这些样式将应用于整个应用程序。通常，在 Svelte 组件内创建样式时，这些样式会被隔离到特定的组件中，这意味着它们不会应用于父组件或子组件。许多现代浏览器会为
    HTML 元素应用它们自己的默认样式，因此，为了统一应用程序的体验，通常的做法是创建一个 `reset.css` 文件。此文件通过将浏览器为常见元素应用的样式重置为可预测的样式，确保在不同浏览器之间的一致性体验。在我们的例子中，我们将使用由
    *Josh W. Comeau* 编写的简洁而全面的 **自定义 CSS 重置** 的略微修改版本。请参阅本章末尾的资源，以获取解释其工作原理的文章链接：
- en: src/reset.css
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: src/reset.css
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In essence, the rules of this CSS file are setting more sane and predictable
    default styles for various HTML elements. For instance, `box-sizing` is set to
    `border-box`, which applies to all elements, as well as the `::before` and `::after`
    pseudo-elements. This rule means that the padding of elements will be included
    when calculating that element’s width. These CSS rules allow a consistent and
    reliable experience across browsers. Of course, we’re free to make any additions
    to this CSS. To make our changes slightly more noticeable, we’ve also set `font-family:
    sans-serif;` on both the `html` and `body` elements.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '从本质上讲，此 CSS 文件的规则是为各种 HTML 元素设置更合理和可预测的默认样式。例如，`box-sizing` 被设置为 `border-box`，这适用于所有元素以及
    `::before` 和 `::after` 伪元素。这条规则意味着元素的填充将在计算该元素宽度时被包含。这些 CSS 规则允许在浏览器之间提供一致和可靠的体验。当然，我们可以自由地向此
    CSS 添加任何内容。为了使我们的更改更加明显，我们还对 `html` 和 `body` 元素设置了 `font-family: sans-serif;`。'
- en: To include this CSS in our application, we’ll open `src/routes/+layout.svelte`
    and import it just as we would a JS module. If you remember back to [*Chapter
    2*](B19024_02_Final_AM.xhtml#_idTextAnchor032), we used the same method to import
    an image path!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此 CSS 包含到我们的应用程序中，我们需要打开 `src/routes/+layout.svelte` 并像导入 JS 模块一样导入它。如果你还记得[*第
    2 章*](B19024_02_Final_AM.xhtml#_idTextAnchor032)，我们曾使用相同的方法导入图像路径！
- en: src/routes/+layout.svelte
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/+layout.svelte
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Noticeably, the only change we need to make in this file is the very first line
    where we import `reset.css`. The remaining code has been omitted from the file
    for the sake of brevity. After importing the CSS file, notice that our styles
    are immediately applied. We don’t need to create `<link>` or `<style>` tags as
    Vite recognizes the style sheet for what it is and automatically applies it for
    us. Conveniently, the file import path can be relative or absolute as Vite makes
    no distinction between the two.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们在此文件中需要做的唯一更改是第一行，其中我们导入 `reset.css`。为了简洁起见，文件中的其余代码已被省略。导入 CSS 文件后，请注意我们的样式立即被应用。我们不需要创建
    `<link>` 或 `<style>` 标签，因为 Vite 识别样式表并将其自动为我们应用。方便的是，文件导入路径可以是相对的或绝对的，因为 Vite
    不会区分这两者。
- en: 'To highlight the benefits of importing a stylesheet with this method, let’s
    compare it with another method for including global style sheets. This method
    was applied to pre-1.0 releases of SvelteKit and worked by manually adding a `<link>`
    tag to the `<head>` section of `src/app.html`. It then referenced a file within
    the `static/` directory using the `%sveltekit.assets%` placeholder. This method
    is ill-advised but let’s analyze it to consider its faults:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出使用此方法导入样式表的好处，让我们将其与另一种包含全局样式表的方法进行比较。这种方法应用于 SvelteKit 的 1.0 版本之前的预发布版本，它通过手动将
    `<link>` 标签添加到 `src/app.html` 的 `<head>` 部分来实现。然后，它使用 `%sveltekit.assets%` 占位符引用
    `static/` 目录中的文件。这种方法并不可取，但让我们分析它以考虑其缺陷：
- en: src/app.html
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: src/app.html
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, this method includes the `static/global.css` file inside the
    head tag of `src/app.html`, the application entry point. The `app.html` file works
    as scaffolding for the rest of the application to build off of, so it stands to
    reason that we could include any extraneous scripts or external assets here, just
    as the favicon is included. This method relies on the `%sveltekit.assets%` placeholder
    to include the CSS file from the `static/` directory. However, this method fails
    to consider Vite’s HMR features. Whenever changes are made to `static/global.css`,
    the entire development server will need to be restarted to reflect those changes
    as Vite does not process any of the files included in the static assets. Also
    consider the common scenario of applying minification to `.css` and preprocessing
    to `.scss`, `.sass`, or `.less` files. In each of these instances, we would need
    Vite to take a more hands-on approach than it does for files included from SvelteKit’s
    `static/` directory. And because Vite can manage cached files by appending hashes
    to the filenames of static assets, it is clear that importing files just as we
    would import a JS module is in our best interest.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这种方法将`static/global.css`文件包含在`src/app.html`的head标签中，这是应用程序的入口点。`app.html`文件作为整个应用程序构建的基础框架，因此我们可以合理地认为，我们可以在这里包含任何额外的脚本或外部资产，就像favicon一样。这种方法依赖于`%sveltekit.assets%`占位符来包含`static/`目录中的CSS文件。然而，这种方法没有考虑到Vite的HMR功能。每当对`static/global.css`进行更改时，整个开发服务器都需要重新启动以反映这些更改，因为Vite不会处理任何包含在静态资产中的文件。同时考虑一下常见的场景，即对`.css`文件进行压缩，对`.scss`、`.sass`或`.less`文件进行预处理。在这些情况下，我们需要Vite比从SvelteKit的`static/`目录中包含的文件采取更积极的做法。而且由于Vite可以通过在静态资产的文件名后附加哈希来管理缓存文件，很明显，像导入JS模块一样导入文件符合我们的最佳利益。
- en: In [*Chapter 2*](B19024_02_Final_AM.xhtml#_idTextAnchor032), we saw how we could
    import an image URL. We’ve now also seen how Vite allows us to import a global
    CSS file directly into our Svelte components. Now that we’ve shown how to best
    utilize static assets dynamically with our applications, let’s discuss some more
    of the details surrounding this process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B19024_02_Final_AM.xhtml#_idTextAnchor032)中，我们看到了如何导入一个图片URL。现在我们也看到了Vite如何允许我们直接将全局CSS文件导入到我们的Svelte组件中。既然我们已经展示了如何动态地最佳利用静态资产，让我们讨论一下这个过程中的一些细节。
- en: Additional Information
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他信息
- en: 'We now know *how* we can import static files, but there are a few details to
    keep in mind when doing so. Here’s a breakdown of the various items we still need
    to cover:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道*如何*导入静态文件，但在这样做时，还有一些细节需要注意。以下是我们需要覆盖的各个项目的分解：
- en: Images versus Styles
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片与样式
- en: Customizing Imports
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义导入
- en: File Paths
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件路径
- en: SvelteKit Configuration Options
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SvelteKit配置选项
- en: Vite Configuration Options
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vite配置选项
- en: Now let’s go over some important information about what went on behind the scenes
    with each of our imports.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下关于我们每个导入背后发生的一些重要信息。
- en: Images versus Styles
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片与样式
- en: When we imported an image in [*Chapter 2*](B19024_02_Final_AM.xhtml#_idTextAnchor032),
    we received the URL, which we then referenced in the `src` attribute of an `<img>`
    tag. When we imported the CSS file, we only needed to import it to apply the styles.
    This is because Vite is pre-configured to automatically inject the styles from
    CSS files into the component performing the import. Hence why the import was performed
    in the root `+layout.svelte` file. Vite also supports CSS `@import` and `url()`
    statements as well as CSS modules. CSS modules can be useful for importing style
    rules as objects within code whereas `@import` and `url()` allow developers to
    build a central CSS file that can reference smaller CSS files located elsewhere.
    When importing a CSS file, no other action needs to be taken other than the import.
    When importing other media such as fonts, audio, or video files, we’ll need to
    set the imported asset URL as the `src` attribute on the appropriate HTML element.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第二章*](B19024_02_Final_AM.xhtml#_idTextAnchor032)中导入图片时，我们收到了URL，然后我们在`<img>`标签的`src`属性中引用它。当我们导入CSS文件时，我们只需要导入它以应用样式。这是因为Vite预先配置为自动将CSS文件中的样式注入到执行导入的组件中。这就是为什么导入是在根`+layout.svelte`文件中执行的原因。Vite还支持CSS
    `@import`和`url()`语句以及CSS模块。CSS模块可以在代码中将样式规则作为对象导入时很有用，而`@import`和`url()`允许开发者构建一个中心CSS文件，该文件可以引用位于其他地方的较小的CSS文件。当导入CSS文件时，除了导入之外不需要采取任何其他操作。当导入其他媒体，如字体、音频或视频文件时，我们需要将导入的资产URL设置为相应HTML元素的`src`属性。
- en: Customizing Imports
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义导入
- en: When importing static assets from Vite, we can customize how they are imported
    by appending the appropriate suffix to the file import names. For instance, to
    import a file as a string, we can append `?raw` to the filename. As expected,
    this will give us the raw content of the imported file. For the `reset.css` example
    shown earlier, it could be included via `import reset from '/src/reset.css?raw';`
    where the reset variable contains the content from `reset.css`. We would then
    need to find a way to include that content inside of `<style>` tags. In a similar
    fashion, if we want to import a file as a URL that is not found in the standard
    media types, we can append `?url` to the file import statement. This can be helpful
    for including files served from a `?worker` to the filename!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当从Vite导入静态资源时，我们可以通过在文件导入名称后附加适当的后缀来自定义它们的导入方式。例如，要将文件作为字符串导入，我们可以在文件名后附加`?raw`。正如预期的那样，这将给我们导入文件的原始内容。对于前面显示的`reset.css`示例，它可以通过`import
    reset from '/src/reset.css?raw';`来包含，其中reset变量包含`reset.css`的内容。然后我们需要找到一种方法将此内容包含在`<style>`标签内。以类似的方式，如果我们想将文件作为不在标准媒体类型中找到的URL导入，我们可以在文件导入语句后附加`?url`。这有助于将来自`?worker`的文件包含到文件名中！
- en: File Paths
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件路径
- en: When running Vite’s development server, we can observe the network requests
    in our browser’s developer tools and notice that imported files are served from
    their location within the project source code. For example, the image from [*Chapter
    2*](B19024_02_Final_AM.xhtml#_idTextAnchor032) is located at `src/lib/images/demo.svg`
    and is also served from that very same location. However, when we run `npm run
    build` followed by `npm run preview`, we’ll observe that the path has changed.
    It is given the path `_app/immutable/assets/demo.dd76856a.svg`. This path is specific
    to the built SvelteKit application and, normally, we won’t edit it after the application
    has been built. But take a moment to notice that a hash has been included in the
    filename. Should the file contents change, we’ll notice the built asset will include
    a different hash appended to the file’s name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行Vite的开发服务器时，我们可以在浏览器开发者工具中观察网络请求，并注意到导入的文件是从项目源代码中的位置提供的。例如，来自[*第2章*](B19024_02_Final_AM.xhtml#_idTextAnchor032)的图片位于`src/lib/images/demo.svg`，并且也是从该位置提供的。然而，当我们运行`npm
    run build`然后运行`npm run preview`时，我们会观察到路径已更改。它被赋予的路径是`_app/immutable/assets/demo.dd76856a.svg`。此路径是构建的SvelteKit应用程序特有的，通常在应用程序构建后我们不会编辑它。但请花点时间注意，文件名中包含了一个哈希值。如果文件内容发生变化，我们会注意到构建的资产将包括附加到文件名上的不同哈希值。
- en: We can also take this moment to observe the included favicon file. We’ll see
    that in both `dev` and `build`/`preview`, it is served from the domain root directory
    `/`. This is because it was located in the `static/` directory and Vite serves
    and builds the application so that any files located there will be served from
    the root level of the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以利用这个时刻来观察包含的favicon文件。我们会看到在`dev`和`build`/`preview`中，它都是从域名根目录`/`提供的。这是因为它位于`static/`目录中，Vite提供和构建应用程序，使得任何位于那里的文件都将从应用程序的根级别提供。
- en: SvelteKit Configuration Options
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SvelteKit配置选项
- en: 'These options can be customized in `svelte.config.js`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以在`svelte.config.js`中进行自定义：
- en: '`files.assets` – This option specifies the directory for which static assets
    will be stored. SvelteKit automatically sets this option to `static` and overrides
    the Vite sibling setting specified as `publicDir` (which defaults to `public`).
    Files that normally fit here are `robots.txt` or `favicon.ico` as they rarely
    change. To reference files located here in the source code, simply prefix the
    filename with `/`. For instance, we can show the default favicon by adding `<img
    src=''/favicon.png'' />` to any component.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files.assets` – 此选项指定了静态资源将被存储的目录。SvelteKit会自动将此选项设置为`static`，并覆盖由`publicDir`指定的Vite同级设置（默认为`public`）。通常适合这里的文件有`robots.txt`或`favicon.ico`，因为它们很少改变。要在源代码中引用此处定位的文件，只需在文件名前加上`/`即可。例如，我们可以在任何组件中通过添加`<img
    src=''/favicon.png'' />`来显示默认的favicon图标。'
- en: '`paths.assets` – This option takes a string that specifies the absolute path
    from where application files are served. It defaults to an empty string.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths.assets` – 此选项接受一个字符串，指定从哪里提供应用程序文件的绝对路径。它默认为空字符串。'
- en: '`paths.base` – This option also defaults to an empty string. If your application
    is being served from a sub-directory, you can specify the root-relative path here.
    Then, you may use the `base` module imported from `$app/paths` to modify hardcoded
    paths appropriately.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths.base` – 此选项也默认为空字符串。如果你的应用程序是从子目录中提供的，你可以在这里指定根相对路径。然后，你可以使用从 `$app/paths`
    导入的 `base` 模块来适当地修改硬编码的路径。'
- en: '`paths.relative` – This option accepts a Boolean value. When `true`, the values
    provided by `base` and `assets` from the `$app/paths` module will be relative
    to built assets. When `false`, those same values with be root-relative.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths.relative` – 此选项接受一个布尔值。当 `true` 时，`$app/paths` 模块中提供的 `base` 和 `assets`
    的值将相对于构建的资产。当 `false` 时，这些相同的值将是根相对的。'
- en: Vite Configuration Options
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vite 配置选项
- en: 'This option can be customized in a project’s `vite.config.js`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项可以在项目的 `vite.config.js` 中进行自定义：
- en: '`assetsInclude` – Many common media types are automatically handled by Vite
    but this option can be useful if a project needs to extend the default list to
    treat uncommon file types as assets. This option allows for the customization
    of allowable static asset file types. It can be a string, regular expression,
    or **picomatch** pattern.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assetsInclude` – 许多常见的媒体类型都由 Vite 自动处理，但如果项目需要扩展默认列表以将不常见的文件类型视为资产，则此选项可能很有用。此选项允许自定义允许的静态资产文件类型。它可以是字符串、正则表达式或
    **picomatch** 模式。'
- en: We’ve just seen how we can customize the importing of static assets. If we need
    to force an asset to be imported as a URL, we know that we append `?url` to the
    end of the imported file. We’ve also learned how CSS files are automatically injected
    into the component they are imported to. Along with a few configuration options,
    these details provide insight into how we can make the management of static assets
    stress-free in our SvelteKit applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何自定义静态资产的导入。如果我们需要强制将资产导入为 URL，我们知道我们会在导入文件的末尾追加 `?url`。我们还了解到 CSS 文件会自动注入到导入到其中的组件中。结合一些配置选项，这些细节提供了关于如何在
    SvelteKit 应用程序中使静态资产的管理无压力的见解。
- en: Summary
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When including images, CSS files, or other media types in SvelteKit applications,
    it is clear that we should leverage Vite to import the asset just as we would
    import a JS module. Doing so comes with the advantage of being simple but also
    allowing for optimized caches. It keeps our development experience smooth as Vite’s
    HMR will automatically show changes in the browser. It’s also flexible in that
    it allows for various media types to be imported either by URL or raw content.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 SvelteKit 应用程序中包含图像、CSS 文件或其他媒体类型时，很明显我们应该利用 Vite 来导入资产，就像我们导入 JS 模块一样。这样做的好处是简单，同时也允许优化缓存。它使我们的开发体验保持流畅，因为
    Vite 的 HMR 会自动在浏览器中显示更改。它也非常灵活，允许通过 URL 或原始内容导入各种媒体类型。
- en: Now that we know how to manage static assets, we should circle back to how we
    manage secrets. If you recall the previous chapter, we added a personal access
    token to the `.env` file, which allowed us to authenticate with the GitHub API.
    In the next chapter, we’ll explore this further and cover the various modules
    that make managing secrets a breeze.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何管理静态资产，我们应该回到如何管理秘密的话题。如果你还记得上一章，我们在 `.env` 文件中添加了一个个人访问令牌，这使得我们可以使用
    GitHub API 进行身份验证。在下一章中，我们将进一步探讨这一点，并介绍使管理秘密变得轻松的各种模块。
- en: Resources
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: Tailwind CSS – [https://tailwindcss.com/](https://tailwindcss.com/)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tailwind CSS – [https://tailwindcss.com/](https://tailwindcss.com/)
- en: Bootstrap – [https://getbootstrap.com/](https://getbootstrap.com/)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap – [https://getbootstrap.com/](https://getbootstrap.com/)
- en: Josh W. Comeau’s Custom CSS Reset – [https://www.joshwcomeau.com/css/custom-css-reset/](https://www.joshwcomeau.com/css/custom-css-reset/)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Josh W. Comeau 的自定义 CSS 重置 – [https://www.joshwcomeau.com/css/custom-css-reset/](https://www.joshwcomeau.com/css/custom-css-reset/)
- en: Vite Configuration Options – [https://vitejs.dev/config/](https://vitejs.dev/config/)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vite 配置选项 – [https://vitejs.dev/config/](https://vitejs.dev/config/)
- en: CSS Modules – [https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 模块 – [https://github.com/css-modules/css-modules](https://github.com/css-modules/css-modules)
- en: picomatch – [https://github.com/micromatch/picomatch](https://github.com/micromatch/picomatch)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: picomatch – [https://github.com/micromatch/picomatch](https://github.com/micromatch/picomatch)
