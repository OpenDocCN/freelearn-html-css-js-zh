<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Why CoffeeScript?</h1></div></div></div><p>CoffeeScript<a id="id0" class="indexterm"/> compiles to JavaScript and follows its idioms closely. It's quite possible to rewrite any CoffeeScript code in Javascript and it won't look drastically different. So why would you want to use CoffeeScript?</p><p>As an experienced JavaScript programmer, you might think that learning a completely new language is simply not worth the time and effort.</p><p>But ultimately, code is for programmers. The compiler doesn't care how the code looks or how clear its meaning is; either it will run or it won't. We aim to write expressive code as programmers so that we can read, reference, understand, modify, and rewrite it.</p><p>If the code is too complex or filled with needless ceremony, it will be harder to understand and maintain.<a id="id1" class="indexterm"/> CoffeeScript gives us an advantage to clarify our ideas and write more readable code.</p><p>It's a misconception to think that CoffeeScript is very different from JavaScript. There might be some drastic syntax differences here and there, but in essence, CoffeeScript was designed to polish the rough edges of JavaScript to reveal the beautiful language hidden beneath. It steers programmers towards JavaScript's so-called "good parts" and holds strong opinions of what constitutes good JavaScript.</p><p>One of the mantras of the CoffeeScript community is: "It's just JavaScript", and I have also found that the best way to truly comprehend the language is to look at how it generates its output, which is actually quite readable and understandable code.</p><p>Throughout this chapter, we'll highlight some of the differences between the two languages, often focusing on the things in JavaScript that CoffeeScript tries to improve.</p><p>In this way, I would not only like to give you an overview of the major features of the language, but also prepare you to be able to debug your CoffeeScript from its generated code once you start using it more often, as well as being able to convert existing JavaScript.</p><p>Let's start with some of the things CoffeeScript fixes in JavaScript.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>CoffeeScript syntax</h1></div></div></div><p>One of the great <a id="id2" class="indexterm"/>things about CoffeeScript is that you tend to write much shorter and more succinct programs than you normally would in JavaScript. Some of this is because of the powerful features added to the language, but it also makes a few tweaks to the general syntax of JavaScript to transform it to something quite elegant. It does away with all the semicolons, braces, and other cruft that usually contributes to a lot of the "line noise" in JavaScript.</p><p>To illustrate this, let's look at an example. On the left-hand side of the following table is CoffeeScript; on the right-hand side is the generated JavaScript:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">fibonacci = (n) -&gt;
 return 0 if n == 0
 return 1 if n == 1
 (fibonacci n-1) + (fibonacci n-2)

alert fibonacci 10</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var fibonacci;

fibonacci = function(n) {
  if (n === 0) {
    return 0;
  }
  if (n === 1) {
    return 1;
  }
  return (fibonacci(n - 1)) + (fibonacci(n - 2));
}; 

alert(fibonacci(10));</pre></div>
</td></tr></tbody></table></div><p>To run the code examples in this chapter, you can use the great <strong>Try CoffeeScript</strong> online tool, at <a class="ulink" href="http://coffeescript.org">http://coffeescript.org</a>. It allows you to type in CoffeeScript code, which will then display the equivalent JavaScript in a side pane. You can also run the code right from the browser (by clicking the <strong>Run</strong> button in the upper-left corner). If you prefer to get CoffeeScript running on your computer to run the samples first, skip to the next chapter and then come back once you have CoffeeScript installed. This tool is shown in the following screenshot:</p><div><img src="img/9588OS_01_01.jpg" alt="CoffeeScript syntax"/></div><p>At first, the two languages might appear to be quite drastically different, but hopefully as we go through the<a id="id3" class="indexterm"/> differences, you'll see that it's all still JavaScript with some small tweaks and a lot of nice syntactical sugar.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Semicolons and braces</h2></div></div></div><p>As you <a id="id4" class="indexterm"/>might have noticed, CoffeeScript does away with all the trailing semicolons at the end of a line. You can still use a semicolon<a id="id5" class="indexterm"/> if you want to put two expressions on a single line. <a id="id6" class="indexterm"/>It also does away with enclosing<a id="id7" class="indexterm"/> braces (also known as curly brackets) for code blocks such as <code class="literal">if</code> statements, <code class="literal">switch</code>, and the <code class="literal">try..catch</code> block.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Whitespace</h2></div></div></div><p>You might be <a id="id8" class="indexterm"/>wondering how the parser figures out where your code <a id="id9" class="indexterm"/>blocks start and end. The CoffeeScript compiler does this by using syntactical whitespace. This means that indentation is used for delimited code blocks instead of braces.</p><p>This is perhaps one of the most controversial features of the language. If you think about it, in almost all languages, programmers tend to already use indentation of code blocks to improve readability, so why not make it part of the syntax? This is not a new concept, and was mostly borrowed from Python. If you have any experience with significant whitespace language, you will not have any trouble with CoffeeScript indentation.</p><p>If you don't, it <a id="id10" class="indexterm"/>might take some getting used to, but it makes for code that is wonderfully readable and easy to scan, while shaving off quite a few keystrokes. I'm willing to bet that if you do take the time to get over some initial reservations you might have, you might just grow to love block indentation.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Blocks can be indented with tabs or spaces, but be careful about being consistent using one or the other, or CoffeeScript will not be able to parse your code correctly.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Parenthesis</h2></div></div></div><p>You'll <a id="id11" class="indexterm"/>see that the clause of the <code class="literal">if</code> statement does not need be enclosed within parentheses. The same goes for the <code class="literal">alert</code> function; you'll see that the <a id="id12" class="indexterm"/>single string parameter follows the function call without parentheses as well. In CoffeeScript, parentheses are optional in function calls with parameters, clauses for <code class="literal">if..else</code> statements, as well as <code class="literal">while</code> loops.</p><p>Although functions with arguments do not need parentheses, it is still a good idea to use them in cases where ambiguity might exist. The CoffeeScript community has come up with a nice idiom: wrapping the whole function call in parenthesis. The use of the <code class="literal">alert</code> function in CoffeeScript is shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">alert square 2 * 2.5 + 1

alert (square 2 * 2.5) + 1</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">alert(square(2 * 2.5 + 1));

alert((square(2 * 2.5)) + 1);</pre></div>
</td></tr></tbody></table></div><p>Functions are first class objects in JavaScript. This means that when you refer to a function without parentheses, it will return the function itself, as a value. Thus, in CoffeeScript you still need to add parentheses when calling a function with no arguments.</p><p>By making these few tweaks to the syntax of JavaScript, CoffeeScript arguably already improves the readability and succinctness of your code by a big factor, and also saves you quite a lot of keystrokes.</p><p>But it has a few other tricks up its sleeve. Most programmers who have written a fair amount of JavaScript would probably agree that one of the phrases that gets typed the most frequently would have to be the function definition <code class="literal">function(){}</code>. Functions are really at the heart of JavaScript, yet not without its many warts.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>CoffeeScript has great function syntax</h1></div></div></div><p>The fact that you can treat<a id="id13" class="indexterm"/> functions as first class objects as well as being <a id="id14" class="indexterm"/>able to create anonymous functions is one of JavaScript's most powerful features. However, the syntax can be very awkward and make the code hard to read (especially if you start nesting functions). But CoffeeScript has a fix for this. Have a look at the following snippets:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">-&gt; alert 'hi there!'
square = (n) -&gt; n * n</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var square;
(function() {
  return alert('hi there!');
});
square = function(n) {
  return n * n;
};</pre></div>
</td></tr></tbody></table></div><p>Here, we are creating two anonymous functions, the first just displays a dialog and the second will return the square of its argument. You've probably noticed the funny <code class="literal">-&gt;</code> symbol and might have figured out what it does. Yep, that is how you define a function in CoffeeScript. I have come across a couple of different names for the symbol but the most accepted term seems to be a thin arrow or just an arrow. This is as opposed to the fat arrow, which we'll discuss later.</p><p>Notice that the first function definition has no arguments and thus we can drop the parenthesis. The second function does have a single argument, which is enclosed in parenthesis, which goes in front of the <code class="literal">-&gt;</code> symbol. With what we now know, we can formulate a few simple substitution rules to convert JavaScript function declarations to CoffeeScript. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Replace the <code class="literal">function</code> keyword with <code class="literal">-&gt;</code></li><li class="listitem" style="list-style-type: disc">If the function has no arguments, drop the parenthesis</li><li class="listitem" style="list-style-type: disc">If it has arguments, move the whole argument list with parenthesis in front of the <code class="literal">-&gt;</code> symbol</li><li class="listitem" style="list-style-type: disc">Make sure that the function body is properly indented and then drop the enclosing braces</li></ul></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Return isn't required</h2></div></div></div><p>You might have noted that in both the functions, we left out the <code class="literal">return</code> keyword<a id="id15" class="indexterm"/>. By default, CoffeeScript will return the last expression in your function. It will try to do this in all the paths of execution. CoffeeScript will try turning any statement (fragment of code that returns nothing) into an expression that returns a value. CoffeeScript programmers will often refer to this feature of the language by saying that everything is an expression.</p><p>This means you don't need to type <code class="literal">return</code> anymore, but keep in mind that this can, in many cases, alter your code subtly, because of the fact that you will always return something. If you need to return a value from a function before the last statement, you can still use <code class="literal">return</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Function arguments</h2></div></div></div><p>Function arguments<a id="id16" class="indexterm"/> can <a id="id17" class="indexterm"/>also take an optional default value. In the following code snippet you'll see that the optional value specified is assigned in the body of the generated Javascript:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">square = (n=1) -&gt;
  alert(n * n)</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var square;

square = function(n) {
  if (n == null) {
    n = 1;
  }
  return alert(n * n);
};</pre></div>
</td></tr></tbody></table></div><p>In JavaScript, each function has an array-like structure called <code class="literal">arguments</code>
<a id="id18" class="indexterm"/> with an indexed property for each argument that was passed to the function. You can use <code class="literal">arguments</code> to pass in a variable number of parameters to a function. Each parameter will be an element in arguments and thus you don't have to refer to parameters by name.</p><p>Although the <code class="literal">arguments</code> object acts somewhat like an array, it is in not in fact a "real" array and lacks most of the standard array methods. Often, you'll find that <code class="literal">arguments</code> doesn't provide the functionality needed to inspect and manipulate its elements like they are used with an array.</p><p>This has <a id="id19" class="indexterm"/>forced <a id="id20" class="indexterm"/>many programmers to use a hack by making <code class="literal">Array.prototype.slice</code> copy the <code class="literal">argument</code> object elements, or to use the <code class="literal">jQuery.makeArray</code> method to create a standard array, which can then be used like normal.</p><p>CoffeeScript borrows this pattern of creating an array from arguments that are represented by <strong>splats</strong>
<a id="id21" class="indexterm"/>, denoted with three dots (<code class="literal">...</code>). These are shown in the following code snippet:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">gpaScoreAverage = (scores...) -&gt;
   total = scores.reduce (a, b) -&gt; a + b
   total / scores.length

alert gpaScoreAverage(65,78,81)
scores = [78, 75, 79]
alert gpaScoreAverage(scores...)</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var gpaScoreAverage, scores,
  __slice = [].slice;

gpaScoreAverage = function() {
  var scores, total;
  scores = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
  total = scores.reduce(function(a, b) {
    return a + b;
  });
  return total / scores.length;
};

alert(gpaScoreAverage(65, 78, 81));
scores = [78, 75, 79];
alert(gpaScoreAverage.apply(null, scores));</pre></div><p>Notice that in the function definition, the parameter is followed by <code class="literal">...</code>. This tells CoffeeScript to allow for variable arguments. The function can then be invoked using either a list of parameters or an array followed by <code class="literal">...</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Where did the var keyword go?</h2></div></div></div><p>In JavaScript, you create local variables by prefixing their declarations with a <code class="literal">var</code> keyword. If you omit it, the variable will be created in the global scope.</p><p>You'll see throughout these examples that that we didn't need to use the <code class="literal">var</code> keyword<a id="id22" class="indexterm"/>, and that CoffeeScript created the actual variable declarations at the top of the function in the generated JavaScript.</p><p>If you're an experienced JavaScripter, you might be wondering how you would then go about creating global variables. The simple answer is you can't.</p><p>Many people (probably including the authors of CoffeeScript) would argue that this is a good thing, because in most cases global variables should be avoided. Don't fret though, as there are ways to create top-level objects that we'll get to in a moment. But this does lead us neatly onto another benefit of CoffeeScript.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>CoffeeScript handles scope better</h1></div></div></div><p>Take a look at the <a id="id23" class="indexterm"/>
<a id="id24" class="indexterm"/>following snippet of JavaScript. Notice that a variable called <a id="id25" class="indexterm"/><code class="literal">salutation</code> gets defined in two places, inside the function, as well as after the function gets called the first time:</p><div><table border="1"><colgroup><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">var greet = function(){ 
    if(typeof salutation === 'undefined') 
        salutation = 'Hi!'; 
    console.log(salutation); 
}
greet();
salutation = "Bye!";
greet();</pre></div>
</td></tr></tbody></table></div><p>In JavaScript, when you omit the <code class="literal">var</code> keyword<a id="id26" class="indexterm"/> while declaring a variable, it immediately becomes a global variable. Global variables are available in all scopes, and thus can be overwritten from anywhere, which often ends up as being a mess.</p><p>In the previous example, the <code class="literal">greet</code> function<a id="id27" class="indexterm"/> first checks if the <code class="literal">salutation</code> variable is defined (by checking if <code class="literal">typeof</code> equals <code class="literal">undefined</code>, a common workaround to see if a variable is defined in JavaScript). If it has not been defined previously, it creates it without a <code class="literal">var</code> keyword. This will immediately promote the variable to the global scope. We can see the consequences of this in the rest of the snippet.</p><p>The first time the <code class="literal">greet</code> function is called, the string <strong>Hi!</strong> will be logged. After the salutation has been changed and the function is called again, the console will instead log <strong>Bye!</strong>. Because the variable was leaked to be a global variable, its value was overwritten outside of the function scope.</p><p>This odd "feature" of the language has been the cause of many a headache for some weary programmer who forgot to include a <code class="literal">var</code> keyword somewhere. Even if you mean to declare a global variable, it is generally considered to be a bad design choice, which is why CoffeeScript disallows it.</p><p>CoffeeScript will always add the <code class="literal">var</code> keyword to any variable declaration to make sure that it doesn't inadvertently end up as a global declaration. In fact, you should never type <code class="literal">var</code> yourself, and the compiler will complain if you do.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Top level var keywords</h2></div></div></div><p>When you declare a <code class="literal">var</code> normally at the top level of your script in JavaScript, it will still be available globally. This <a id="id28" class="indexterm"/>can also cause havoc when you include a bunch of different JavaScript files, since you might overwrite variables declared in earlier scripts.</p><p>In JavaScript and subsequently CoffeeScript, functions act as closures, meaning that they create their own variable scope as well as having their enclosing scope variables available to them.</p><p>Throughout the years, a common pattern started to emerge where library authors wrap their entire script in an anonymous closure function that they assign to a single variable.</p><p>The CoffeeScript compiler does something similar, and will wrap scripts in an anonymous function to avoid leaking its scope. In the following sample, the JavaScript is the output of running the CoffeeScript compiler:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">greet = -&gt; salutation = 'Hi!'</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">(var greet;
greet = function() {
  var salutation;
  return salutation = 'Hi!';
}).call(this);</pre></div>
</td></tr></tbody></table></div><p>Here you can see how CoffeeScript has wrapped the function definition in its own scope.</p><p>There are, however, certain cases where you would want a variable to be available throughout your application. <a id="id29" class="indexterm"/>Usually attaching a property to an existing global object can do this. When you're in the browser, you can just create a property on the global <code class="literal">window</code> object<a id="id30" class="indexterm"/>.</p><p>In browser-side JavaScript, the <code class="literal">window</code> object represents an open window. It's globally available to all other objects and thus can be used as a global namespace or container for other objects.</p><p>While we are on the subject of objects, let's talk about another part of JavaScript that CoffeeScript makes much better: defining and using objects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>CoffeeScript has better object syntax</h1></div></div></div><p>The JavaScript language<a id="id31" class="indexterm"/> has a wonderful and unique object model, but the syntax and semantics<a id="id32" class="indexterm"/> for creating objects and inheriting from them has always been a bit cumbersome and widely misunderstood.</p><p>CoffeeScript cleans this up in a simple and elegant syntax that does not stray too far from idiomatic JavaScript. The following code demonstrates how CoffeeScript compiles its class syntax into JavaScript:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">class Vehicle
  constructor: -&gt;   
  drive: (km) -&gt; 
    alert "Drove #{km} kilometres"

bus = new Vehicle()
bus.drive 5</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var Vehicle, bus;
Vehicle = (function() {
  function Vehicle() {}
  Vehicle.prototype.drive = function(km) {
    return alert("Drove " + km + " kilometres");
  };
  return Vehicle;
})();
bus = new Vehicle();
bus.drive(5);</pre></div><p>In CoffeeScript, you use the <code class="literal">class</code> keyword to define object structures. Under the hood, this creates a function object with function methods added to its prototype. The <code class="literal">constructor: operator</code> will create a constructor function that will be called when your object gets initialized with the <code class="literal">new</code> keyword. </p><p>All the other function methods<a id="id33" class="indexterm"/> are declared using the <code class="literal">methodName: () -&gt;</code> syntax. These are created on the prototype of the object.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Did you notice the <code class="literal">#{km}</code> in our alert string? This is the string interpolation syntax, which was borrowed from Ruby. We'll talk about this later in the chapter.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Inheritance</h2></div></div></div><p>What about<a id="id34" class="indexterm"/> object inheritance? Although it's possible, normally this is such a pain in JavaScript that most programmers don't even bother, or use a third-party library with non-standard semantics.</p><p>In this example you can see how CoffeeScript makes object inheritance elegant:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">class Car extends Vehicle
  constructor: -&gt; 
    @odometer = 0
  drive: (km) -&gt;
    @odometer += km
    super km
car = new Car
car.drive 5
car.drive 8

alert "Odometer is at #{car.odometer}"</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">Car = (function(_super) {
  __extends(Car, _super);
  function Car() {
    this.odometer = 0;
  }
  Car.prototype.drive = function(km) {
    this.odometer += km;
    return Car.__super__.drive.call(this, km);
  };
  return Car;
})(Vehicle);

car = new Car;
car.drive(5);
car.drive(8);
alert("Odometer is at " + car.odometer);</pre></div><p>This example does not contain all the JavaScript code that will be generated by the compiler, but has enough to highlight the interesting parts. The <code class="literal">extends</code> operator<a id="id35" class="indexterm"/> is used to set up the inheritance chain between two objects and their constructors. Notice how much simpler the call to <a id="id36" class="indexterm"/>the parent class becomes with <code class="literal">super</code>.</p><p>As you can see, <code class="literal">@odometer</code>
<a id="id37" class="indexterm"/> was translated to <code class="literal">this.odometer</code>. The <code class="literal">@</code> symbol is just a shortcut for <code class="literal">this</code>. We'll talk about it further on in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Overwhelmed?</h2></div></div></div><p>The <code class="literal">class</code> syntax<a id="id38" class="indexterm"/> is, in my opinion, where you'll find the greatest difference between CoffeeScript and its compiled JavaScript. However, most of the time it just works and once you understand it you'll rarely have to worry about the details.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Extending prototypes</h2></div></div></div><p>If you're an <a id="id39" class="indexterm"/>experienced JavaScript programmer who still likes to do all of this yourself, you don't need to use <code class="literal">class</code>. CoffeeScript still provides the helpful shortcut to get at prototypes through the <code class="literal">::</code> symbol, which will be replaced by <code class="literal">.prototype</code> in the generated JavaScript, as shown in the following code snippet:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">Vehicle::stop=-&gt;  alert'Stopped'</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">Vehicle.prototype.stop(function() {
  return alert('Stopped');
});</pre></div>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>A few other things CoffeeScript fixes</h1></div></div></div><p>JavaScript has lots of other small annoyances that CoffeeScript makes nicer. Let's have a look at some of these.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Reserved words and object syntax</h2></div></div></div><p>Often in JavaScript, <a id="id40" class="indexterm"/>you will need to make use of a reserved word, or a keyword that is used by JavaScript. This often happens with keys for literal objects as data in JavaScript, like <code class="literal">class</code> or <code class="literal">for</code>, which you then need to enclose in quotes. CoffeeScript will automatically quote reserved words for you, and generally you don't even need to worry about it.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">tag = 
  type: 'label' 
  name: 'nameLabel'
  for: 'name'
  class: 'label'</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var tag;

tag = {
  type: 'label',
  name: 'nameLabel',
  "for": 'name',
  "class": 'label'
};</pre></div>
</td></tr></tbody></table></div><p>Notice that we don't need the braces to create object literals and can use indentation here as well. While <a id="id41" class="indexterm"/>using this style, as long as there is only one property per line, we can drop the trailing commas too.</p><p>We can also write array literals in this way:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">dwarfs = [
  "Sneezy"
  "Sleepy"
  "Dopey"
  "Doc"
  "Happy"
  "Bashful"
  "Grumpy"
]</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var dwarfs;

dwarfs = ["Sneezy", "Sleepy", "Dopey", "Doc", "Happy", "Bashful", "Grumpy"];</pre></div>
</td></tr></tbody></table></div><p>These features combined make writing JSON a breeze. Compare the following samples to see the difference:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">"firstName": "John"
"lastName": "Smith"
"age": 25
"address": 
  "streetAddress": "21 2nd Street"
  "city": "New York"
  "state": "NY"
  "postalCode": "10021"
"phoneNumber": [
  {"type": "home", "number": "212 555-1234"}
  {"type": "fax", "number": "646 555-4567"}
]</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">({
  "firstName": "John",
  "lastName": "Smith",
  "age": 25,
  "address": {
    "streetAddress": "21 2nd Street",
    "city": "New York",
    "state": "NY",
    "postalCode": "10021"
  },
  "phoneNumber": [
    {
      "type": "home",
      "number": "212 555-1234"
    }, {
      "type": "fax",
      "number": "646 555-4567"
    }
  ]
});</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>String concatenation</h2></div></div></div><p>For a language <a id="id42" class="indexterm"/>that deals with a lot of strings, <a id="id43" class="indexterm"/>JavaScript has always been pretty bad at building strings up from parts. Variables and expression values are often meant to be inserted inside a string somewhere, and this is usually done by concatenation using the <code class="literal">+</code> operator. If you've ever tried concatenating a couple of variables in a string, you'll know this soon becomes burdensome and hard to read.</p><p>CoffeeScript has a built-in string interpolation syntax, which is similar to many other scripting languages, but was specifically borrowed from Ruby. This is shown in the following code snippet:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">greet = (name, time) -&gt; 
  "Good #{time} #{name}!"

alert (greet 'Pete', 'morning')</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var greet;

greet = function(name, time) {
  return "Good " + time + " " + name + "!";
};

alert(greet('Pete', 'morning'));</pre></div>
</td></tr></tbody></table></div><p>You can write any expression within <code class="literal">#{}</code> and its string value will be concatenated. Note that you can only <a id="id44" class="indexterm"/>use string interpolation in double-quoted strings, <code class="literal">""</code>. Single-quoted strings are literal and will be represented exactly how they are.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Equality</h2></div></div></div><p>The <a id="id45" class="indexterm"/>equality operator <a id="id46" class="indexterm"/><code class="literal">==</code> (and its inverse <code class="literal">!=</code>) in JavaScript is fraught with dangers, and a lot of times doesn't do what you would expect. This is because it will first try to coerce objects of a different type to be the same before comparing them.</p><p>It's also not transitive, meaning it might return different values of <code class="literal">true</code> or <code class="literal">false</code> depending on if a type is on the left or right of the operator. Please refer to the following code snippet:</p><div><pre class="programlisting">'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true</pre></div><p>Because of its inconsistent and strange behavior, respected members in the JavaScript community advise avoiding it altogether and to rather use the identity operator, <code class="literal">===</code> in its place. This operator will always return <code class="literal">false</code> if two objects are of a different type, which is consistent to how <code class="literal">==</code> works in many other languages.</p><p>CoffeeScript will always convert <code class="literal">==</code> to <code class="literal">===</code> and <code class="literal">!=</code> to <code class="literal">!===</code>, as shown in the following implementation:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">'' == '0'
0 == ''  
0 == '0' 
false == 'false'
false == '0'    
false == undefined
false == null     
null == undefined </pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">'' === '0';
0 === '';
0 === '0';
false === 'false';
false === '0';
false === void 0;
false === null;
null === void 0;</pre></div>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>The existential operator</h2></div></div></div><p>When you're <a id="id47" class="indexterm"/>trying to check if a variable<a id="id48" class="indexterm"/> exists and has a value (is not <code class="literal">null</code> or <code class="literal">undefined</code>) in JavaScript, you need to use this quirky idiom:</p><div><pre class="programlisting">typeof a !== "undefined" &amp;&amp; a !== null </pre></div><p>CoffeeScript has a nice shortcut for this, the existential operator <code class="literal">?</code>, which will return <code class="literal">false</code> unless a variable is <code class="literal">undefined</code> or <code class="literal">null</code>.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">broccoli = true;
if carrots? &amp;&amp; broccoli?
  alert 'this is healthy'</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var broccoli;

broccoli = true;

if ((typeof carrots !== "undefined" &amp;&amp; carrots !== null) &amp;&amp; (broccoli != null)) {
  alert('this is healthy');
}</pre></div>
</td></tr></tbody></table></div><p>In this example, since the compiler already knows that broccoli is defined, the <code class="literal">?</code> operator will only check if it has a <code class="literal">null</code> value, while it will check if <code class="literal">carrots</code> is <code class="literal">undefined</code> as well as <code class="literal">null</code>.</p><p>The existential operator has a method call variant: <code class="literal">?.</code> or just the "soak", which will allow you to swallow the method calls on <code class="literal">null</code> objects in a method chain, as shown here:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">street = person?.getAddress()?.street</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var street, _ref;

street = typeof person !== "undefined" &amp;&amp; person !== null ? (_ref = person.getAddress()) != null ? _ref.street : void 0 : void 0;</pre></div>
</td></tr></tbody></table></div><p>If all of the values in the chain exist, you should get the expected result. If any of them should be <code class="literal">null</code> or <code class="literal">undefined</code>, <a id="id49" class="indexterm"/>you will get an undefined value, instead of <code class="literal">TypeError</code> being thrown.</p><p>Although this is a powerful technique, it can also be easily abused and make the code hard to reason with. If you have long method chains it may become hard to know just exactly where the null or undefined value came from.</p><p>The <strong>Law of Demeter</strong>
<a id="id50" class="indexterm"/>, a well-known object orientation design principle, can be used to minimize this kind of complexity and improve decoupling in your code. It can be summarized as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Your method can call other methods in its class directly</li><li class="listitem" style="list-style-type: disc">Your method can call methods on its own fields directly (but not on the fields' fields)</li><li class="listitem" style="list-style-type: disc">When your method takes parameters, your method can call methods on those parameters directly</li><li class="listitem" style="list-style-type: disc">When your method creates local objects, that method can call methods on the local objects</li></ul></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Although, this is not a "strict law" in the sense that it should never be broken, it is more analogous to the law of nature, such that the code that tends to follow it also tends to be much simpler and more loosely coupled.</p></div></div><p>Now that we have spent some time going over some of the inadequacies and annoyances of JavaScript that CoffeeScript fixes, let's dwell on some of the other powerful features that CoffeeScript adds; some borrowed from other scripting languages and some that are unique to the language.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>List comprehensions</h1></div></div></div><p>In CoffeeScript, looping through collections works quite differently from JavaScript's imperative approach. CoffeeScript takes ideas from functional programming languages and uses list comprehensions<a id="id51" class="indexterm"/> to transform lists instead of looping through elements iteratively.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>The while loop </h2></div></div></div><p>The <a id="id52" class="indexterm"/>
<code class="literal">while</code> loop<a id="id53" class="indexterm"/> is still present and works more or less the same, except that it can be used as an expression, meaning it will return an array of values:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">multiplesOf = (n, times) -&gt; 
  times++
  (n * times while times -= 1 &gt; 0).reverse()

alert (multiplesOf 5, 10)</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var multiplesOf;

multiplesOf = function(n, times) {
  times++;
  return ((function() {
    var _results;
    _results = [];
    while (times -= 1 &gt; 0) {
      _results.push(n * times);
    }
    return _results;
  })()).reverse();
};

alert(multiplesOf(5, 10));</pre></div><p>Notice that in the previous code, the <code class="literal">while</code> body goes in front of the condition. This is a common idiom in CoffeeScript if the body is of only one line. You can do the same thing with <code class="literal">if</code> statements and list comprehensions.</p><p>We can improve the readability of the previous code slightly by using the <code class="literal">until</code> keyword<a id="id54" class="indexterm"/>, which is basically the negation of <code class="literal">while</code>, as shown here:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">multiplesOf = (n, times) -&gt; 
  times++
  (n * times until --times == 0).reverse()

alert (multiplesOf 5, 10)</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var multiplesOf;

multiplesOf = function(n, times) {
  times++;
  return ((function() {
    var _results;
    _results = [];
    while (--times !== 0) {
      _results.push(n * times);
    }
    return _results;
  })()).reverse();
};

alert(multiplesOf(5, 10));</pre></div><p>The <code class="literal">for</code> statement<a id="id55" class="indexterm"/>
<a id="id56" class="indexterm"/> doesn't work like it does in JavaScript. CoffeeScript replaces it with list comprehensions, which were mostly borrowed from the Python language and also very similar to constructs that you'll find in functional languages such as Haskell. Comprehensions provide a more declarative way of filtering, transforming, and aggregating collections or performing an action for each element. The best way to illustrate them would be through some examples:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">flavors = ['chocolate', 'strawberry', 'vanilla']
alert flavor for flavor in flavors

favorites = ("#{flavor}!" for flavor in flavors when flavor != 'vanilla')</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var favorites, flavor, flavors, _i, _len;

flavors = ['chocolate', 'strawberry', 'vanilla'];

for (_i = 0, _len = flavors.length; _i &lt; _len; _i++) {
  flavor = flavors[_i];
  alert(flavor);
}

favorites = (function() {
  var _j, _len1, _results;
  _results = [];
  for (_j = 0, _len1 = flavors.length; _j &lt; _len1; _j++) {
    flavor = flavors[_j];
    if (flavor !== 'vanilla') {
      _results.push("" + flavor + "!");
    }
  }
  return _results;
})();</pre></div><p>Although they are quite simple, comprehensions have a very condensed form and do a lot in very little code. Let's break it down to its separate parts:</p><div><pre class="programlisting">[action or mapping] for [selector] in [collection] when [condition] by [step]</pre></div><p>Comprehensions<a id="id57" class="indexterm"/> are best read from right to left, starting from the <code class="literal">in</code> collection. The <code class="literal">selector</code> name is a temporary name that is given to each element as we iterate through the collection. The clause in front of the <code class="literal">for</code> keyword describes what you want to do with the <code class="literal">selector</code> name, by either calling a method with it as an argument, selecting a property or method on it, or assigning a value.</p><p>The <code class="literal">when</code> and <code class="literal">by</code> guard clauses are optional. They describe how the iteration should be filtered (elements will only be returned when their subsequent <code class="literal">when</code> condition is <code class="literal">true</code>), or which parts of the collection to select using <code class="literal">by</code> followed by a number. For example, <code class="literal">by 2</code> will return every evenly numbered element.</p><p>We can rewrite our <code class="literal">multiplesOf</code> function<a id="id58" class="indexterm"/> by using <code class="literal">by</code> and <code class="literal">when</code>:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">multiplesOf = (n, times) -&gt; 
  multiples = (m for m in [0..n*times] by n)
  multiples.shift()
  multiples

alert (multiplesOf 5, 10)</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var multiplesOf;

multiplesOf = function(n, times) {
  var m, multiples;
  multiples = (function() {
    var _i, _ref, _results;
    _results = [];
    for (m = _i = 0, _ref = n * times; 0 &lt;= _ref ? _i &lt;= _ref : _i &gt;= _ref; m = _i += n) {
      _results.push(m);
    }
    return _results;
  })();
  multiples.shift();
  return multiples;
};

alert(multiplesOf(5, 10));</pre></div><p>The <code class="literal">[0..n*times]</code> syntax is CoffeeScripts's range syntax, which was borrowed from Ruby. It will create an array with all the elements between the first and last number. When the range has two dots it will be inclusive, meaning the range will contain the specified start and end element. If it has three dots (<code class="literal">…</code>), it will only contain the numbers in between.</p><p>List comprehensions<a id="id59" class="indexterm"/> were one of the biggest new concepts to grasp when I started learning CoffeeScript. They are an extremely powerful feature, but it does take some time to get used to and think in comprehensions. Whenever you feel tempted to write a looping construct using the lower level <code class="literal">while</code>, consider using a comprehension instead. They provide just about everything you could possibly need when working with collections, and they are extremely fast compared to built-in ECMAScript array methods, such as <code class="literal">.map()</code> and <code class="literal">.select()</code>.</p><p>You can use<a id="id60" class="indexterm"/> comprehensions to loop through key-value pairs in an object, using the <code class="literal">of</code> keyword, as shown in the following code:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">ages = 
  john: 25
  peter: 26
  joan: 23

alert "#{name} is #{age} years old" for name, age of ages</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var age, ages, name;

ages = {
  john: 25,
  peter: 26,
  joan: 23
};

for (name in ages) {
  age = ages[name];
  alert("" + name + " is " + age + " years old");
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Conditional clauses and logical aliases</h1></div></div></div><p>CoffeeScript<a id="id61" class="indexterm"/> introduces some very nice logic and conditional features, <a id="id62" class="indexterm"/>some also borrowed from other scripting languages. The <code class="literal">unless</code> keyword is the inverse of the <code class="literal">if</code> keyword; <code class="literal">if</code> and <code class="literal">unless</code> can take the postfix form, meaning statements can go at the end of the line.</p><p>CoffeeScript also provides plain <a id="id63" class="indexterm"/>
<a id="id64" class="indexterm"/>English aliases for some of the logical operators. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">is</code> for <code class="literal">==</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isnt</code> for <code class="literal">!=</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">not</code> for <code class="literal">!</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">and</code> for <code class="literal">&amp;&amp;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">or</code> for <code class="literal">||</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">true</code> can also be <code class="literal">yes</code>, or <code class="literal">on</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">false</code> can be <code class="literal">no</code> or <code class="literal">off</code></li></ul></div><p>Putting all this together, let's look at some code to demonstrate it:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">car.switchOff() if car.ignition is on
service(car) unless car.lastService() &gt; 15000
wash(car) if car.isDirty()
chargeFee(car.owner) if car.make isnt "Toyota"</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">if (car.ignition === true) {
  car.switchOff();
}

if (!(car.lastService() &gt; 15000)) {
  service(car);
}

if (car.isDirty()) {
  wash(car);
}

if (car.make !== "Toyota") {
  chargeFee(car.owner);
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Array slicing and splicing</h1></div></div></div><p>CoffeeScript <a id="id65" class="indexterm"/>allows<a id="id66" class="indexterm"/> you to easily <a id="id67" class="indexterm"/>extract parts of an array using the <code class="literal">..</code> and <code class="literal">...</code> notation. <code class="literal">[n..m]</code> will<a id="id68" class="indexterm"/> select all the elements including <code class="literal">n</code> and <code class="literal">m</code>, whereas <code class="literal">[n…m]</code> will select only the elements between <code class="literal">n</code> and <code class="literal">m</code>.</p><p>Both <code class="literal">[..]</code> and <code class="literal">[…]</code> will select the whole array. These are used in the following code:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

alert numbers[0..3]

alert numbers[4...7]

alert numbers[7..]

alert numbers[..]</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var numbers;

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

alert(numbers.slice(0, 4));

alert(numbers.slice(4, 7));

alert(numbers.slice(7));

alert(numbers.slice(0));</pre></div>
</td></tr></tbody></table></div><p>CoffeeScript sure loves its ellipses. They are used by splats, ranges, and array slices. Here are some quick tips on how to identify them: If the <code class="literal">…</code> is next to the last argument in a function definition or a function call, it's a splat. If it's enclosed in square brackets that are not indexing an array, it's a range. If it is indexing an array, it's a slice.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Destructuring or pattern matching</h1></div></div></div><p><strong>Destructuring</strong>
<a id="id69" class="indexterm"/> is a powerful concept that you'll find in many functional programming languages. In essence, it allows you to pull single values from complex objects. It can simply allow you<a id="id70" class="indexterm"/> to assign multiple values at once, or deal with functions that return multiple values; as shown here:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">getLocation = -&gt;
  [
   'Chigaco' 
   'Illinois' 
   'USA'
  ]

[city, state, country] = getLocation()</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var city, country, getLocation, state, _ref;

getLocation = function() {
  return ['Chigaco', 'Illinois', 'USA'];
};

_ref = getLocation(), city = _ref[0], state = _ref[1], country = _ref[2];</pre></div><p>When you run this, you get three variables, <code class="literal">city</code>, <code class="literal">state</code>, and <code class="literal">country</code> with values that were assigned from the corresponding element in the array returned by the <code class="literal">getLocation</code> function<a id="id71" class="indexterm"/>.</p><p>You can use destructuring to<a id="id72" class="indexterm"/> pull out values from objects and hashes as well. There are no limits to how deeply data in the object can be nested. Here is an example of that:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">getAddress = -&gt;
   address:
     country: 'USA'
     state: 'Illinois'
     city: 'Chicago'
     street: 'Rush Street'
     

{address: {street: myStreet}} = getAddress()
alert myStreet</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var getAddress, myStreet;

getAddress = function() {
  return {
    address: {
      country: 'USA',
      state: 'Illinois',
      city: 'Chicago',
      street: 'Rush Street'
    }
  };
};

myStreet = getAddress().address.street;

alert(myStreet);</pre></div><p>In this example, the <code class="literal">{address: {street: ---}}</code> part describes your pattern, basically where to find the information you need. When we put the <code class="literal">myStreet</code> variable inside our pattern, we tell CoffeeScript to assign the value in that place to <code class="literal">myStreet</code>. While we can use nested objects, we can also mix and match destructuring objects and arrays, as shown in the following code:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">getAddress = -&gt;
   address:
     country: 'USA'
     addressLines: [
       '1 Rush Street'
       'Chicago'
       'Illinois'
     ]

{address: 
  {addressLines: 
    [street, city, state]
  }
} = getAddress()
alert street</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var city, getAddress, state, street, _ref;

getAddress = function() {
  return {
    address: {
      country: 'USA',
      addressLines: ['1 Rush Street', 'Chicago', 'Illinois']
    }
  };
};

_ref = getAddress().address.addressLines, street = _ref[0], city = _ref[1], state = _ref[2];

alert(street);</pre></div><p>Here, in the previous code, <a id="id73" class="indexterm"/>we are pulling elements from the array value that we get from <code class="literal">addressLines</code> and give them names.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>=&gt; and @</h1></div></div></div><p>In JavaScript, the value of <a id="id74" class="indexterm"/>
<code class="literal">this</code> refers to the owner of the currently executing function, or the object that the function is <a id="id75" class="indexterm"/>a method of. Unlike in other object-oriented languages, JavaScript also has the notion that functions are not tightly bound to objects, meaning that the value of this can be changed at will (or accidently). This is a very powerful feature of the language but can also lead to confusion if used incorrectly.</p><p>In CoffeeScript, the <code class="literal">@</code> symbol <a id="id76" class="indexterm"/>is a shortcut for <code class="literal">this</code>. Whenever the compiler sees something like <code class="literal">@foo</code>, it will replace it with <code class="literal">this.foo</code>.</p><p>Although it's still possible to use this in CoffeeScript, it's generally frowned upon and more idiomatic to use <code class="literal">@</code> instead.</p><p>In any JavaScript function, the value of <code class="literal">this</code> is the object that the function is attached to. However, when you pass functions to other functions or reattach a function to another object, the value of <code class="literal">this</code> will change. Sometimes this is what you want, but often you would like to keep the original value of <code class="literal">this</code>.</p><p>For this purpose, CoffeeScript provides the <code class="literal">=&gt;</code>, or fat arrow, which will define a function but at the same time capture the value of <code class="literal">this</code>, so that the function can be safely called in any context. This is especially useful when using callbacks, for instance in a jQuery event handler.</p><p>The following example will illustrate the idea:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">class Birthday
  prepare: (action) -&gt;
    @action = action

  celebrate: () -&gt;
   @action()

class Person
  constructor: (name) -&gt;
    @name = name
    @birthday = new Birthday()
    @birthday.prepare () =&gt; "It's #{@name}'s birthday!"

michael = new Person "Michael"
alert michael.birthday.celebrate() </pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var Birthday, Person, michael;

Birthday = (function() {

  function Birthday() {}

  Birthday.prototype.prepare = function(action) {
    return this.action = action;
  };

  Birthday.prototype.celebrate = function() {
    return this.action();
  };

  return Birthday;

})();

Person = (function() {

  function Person(name) {
    var _this = this;
    this.name = name;
    this.birthday = new Birthday();
    this.birthday.prepare(function() {
      return "It's " + _this.name + "'s birthday!";
    });
  }

  return Person;

})();

michael = new Person("Michael");

alert(michael.birthday.celebrate());</pre></div><p>Notice that the <code class="literal">prepare</code> function<a id="id77" class="indexterm"/> on the <code class="literal">birthday</code> class<a id="id78" class="indexterm"/> takes an <code class="literal">action</code> function<a id="id79" class="indexterm"/> as an argument, to be called when the birthday occurs. Because we're passing this function using the fat arrow, it will have its scope fixed to the <code class="literal">Person</code> object<a id="id80" class="indexterm"/>. This means we can still refer to the <code class="literal">@name</code> instance variable<a id="id81" class="indexterm"/> even though it doesn't exist on the <code class="literal">Birthday</code> object that runs the function.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Switch statements</h1></div></div></div><p>In CoffeeScript, <a id="id82" class="indexterm"/>
<code class="literal">switch</code> statements take a different form,<a id="id83" class="indexterm"/> and look a lot less like JavaScript's Java-inspired syntax, and a lot more like Ruby's <code class="literal">case</code> statement. You don't need to call <code class="literal">break</code> to avoid falling through to the next <code class="literal">case</code> condition.</p><p>They have the following form:</p><div><pre class="programlisting">switch condition 
  when … then …
   ….
else …</pre></div><p>Here, <code class="literal">else</code> is the default case.</p><p>Like everything else in CoffeeScript, they are expressions, and this can be assigned to a value.</p><p>Let's look at an example:</p><p><strong>CoffeeScript:</strong></p><div><pre class="programlisting">languages = switch country
  when 'france' then 'french'
  when 'england', 'usa' then 'english'
  when 'belgium' then ['french', 'dutch']
  else 'swahili'</pre></div><p><strong>JavaScript:</strong></p><div><pre class="programlisting">var languages;

languages = (function() {
  switch (country) {
    case 'france':
      return 'french';
    case 'england':
    case 'usa':
      return 'english';
    case 'belgium':
      return ['french', 'dutch'];
    default:
      return 'swahili';
  }
})();</pre></div><p>CoffeeScript doesn't force you to add a default <code class="literal">else</code> clause, although it is a good programming practice to always add one, just in case.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Chained comparisons</h1></div></div></div><p>CoffeeScript borrowed <a id="id84" class="indexterm"/>chained comparisons<a id="id85" class="indexterm"/> from Python. These basically allow you to write greater than or less than comparisons like you would in mathematics, as shown here:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>CoffeeScript</p>
</th><th style="text-align: left" valign="bottom">
<p>JavaScript</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div><pre class="programlisting">age = 41

alert 'middle age' if 61 &gt; age &gt; 39</pre></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">var age;

age = 41;

if ((61 &gt; age &amp;&amp; age &gt; 39)) {
  alert('middle age');
}</pre></div>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Block strings, block comments, and strings</h1></div></div></div><p>Most <a id="id86" class="indexterm"/>programming <a id="id87" class="indexterm"/>books start with comments, and I thought I would end with them. In CoffeeScript, single line comments start with <code class="literal">#</code>. The comments do not end up in your generated output. Multiline comments start and end with <code class="literal">###</code>, and they are<a id="id88" class="indexterm"/> included in the generated JavaScript.</p><p>You can span a string over multiple lines using the <code class="literal">"""</code> triple quote to enclose it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we started looking at CoffeeScript from JavaScript's perspective. We saw how it can help you write shorter, cleaner, and more elegant code than you normally would in JavaScript and avoid many of its pitfalls.</p><p>We came to realize that even though CoffeeScripts' syntax seems to be quite different from JavaScript, it actually maps pretty closely to its generated output.</p><p>Later on, we delved into some of CoffeeScripts' unique and wonderful additions, like list comprehensions, destructuring assignment, and its class syntax, as well as many more convenient and powerful features such as string interpolation, ranges, splats, and array slicing.</p><p>My goal in this chapter was to convince you that CoffeeScript is a superior alternative to JavaScript, and I have tried to do so by showing the differences between them. Although I have previously said "it's just JavaScript", I hope that you'll appreciate that CoffeeScript is a wonderful and modern language in its own right, with brilliant influences from other great scripting languages.</p><p>I can still write a great deal about the beauty of the language, but I feel that we have reached the point where we can dive into some real world CoffeeScript and get to appreciate it "in the wild", so to speak.</p><p>So, are you ready? Let's get started then and get CoffeeScript installed.</p></div></body></html>