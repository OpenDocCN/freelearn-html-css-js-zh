- en: Chapter 5. Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed how templates in Ember.js are used to
    present data to users. We also covered how user interactions, in our applications,
    are easily made possible through these templates. We noted that templates serve
    their purpose by communicating with controllers. This chapter will expound on
    this, and will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing models and objects in controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object and array controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying controller dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering action handlers in controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State transitions in controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like route handlers, a controller can be defined by extending the `Ember.Controller`
    class, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A defined controller can further be extended to create yet another new controller
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These controller classes can then be instantiated with the `create` method,
    as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like objects, if we need to use mixins when instantiating controllers,
    we need to use the `createWithMixins` method instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We rarely instantiate application controllers ourselves because Ember.js does
    it for us when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Providing controllers with models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we proceed, let''s recap and see how data is loaded and stored in controllers.
    Most of the applications we''ll build will communicate with REST endpoints, and
    therefore, Ember.js comes with features that make the creation of such applications
    trivial. In [Chapter 3](part0029_split_000.html#page "Chapter 3. Routing and State
    Management"), *Routing and State Management*, we learned that data can be loaded
    from the server in an asynchronous fashion via a route handler''s `model` hook.
    For example, let''s define a blog post route that loads a particular blog post
    from our server. First, we''ll define our application''s router as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We just defined a post resource that will handle requests to a post''s detail
    page, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user visits a post''s path, say `/post/100`, Ember.js expects that the
    post route handler will define a `model` hook that will load the matching post
    from the server. Here''s an example that illustrates this using jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the handler''s `model` hook took an `options` object
    that contained the post''s ID. This ID was then used to load the matching post
    from the server using jQuery''s `getJSON()` method that returned a promise with
    which our application resolved on load. Once resolved, Ember.js expected this
    route to define a `setupController` hook that stored the resolved post into the
    corresponding controller. This is the default behavior that is implemented as
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setupController` hook receives two arguments: an instance of the corresponding
    controller and the resolved model. This model is stored inside the controller''s
    `model` property. Note that this is just the default implementation; we can store
    the model in any other desired property or controller.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering dynamic data from controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After loading data from the server, the controller''s purpose is to make this
    model available to the corresponding template for display. These templates will
    then register bindings to the properties of the provided model and send updates
    of changes made to these properties using form controls. Since controllers are
    an extension of `Ember.Object`, they realize better management of the evented
    nature of browser environments using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates can display properties of bound controllers using expressions. For
    example, the post template in the previous example will display the loaded post
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the post loads, the rendered post template will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the post''s title changes at a later point in time, the title portion of
    the template will be rerendered to display the new title, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Templates can also push updates back to controllers. This is typically done
    using HTML-form elements. Ember provides Handlebars expressions that abstract
    the use of these controls to create two-way bindings, as we discussed in the previous
    chapter. To illustrate this, let''s add a new route in our blog application, which
    will enable the blog''s admin to add a new post entry, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The admin will of course create the new post on the `/posts/new` page. Ember.js
    will expect a `posts/new` template for this route, which will resemble the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PostsNewRoute` handler will also need to provide the model for the template
    that will serve as its context. As you might have guessed, its `model` hook will
    return a new post object to be updated, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `model` hook returns an Ember.js object that will serve as the post to be
    created by the admin. Since this is common practice, we'll learn how to use `ember-data`,
    a higher level library that helps in the definition and creation of such models
    in a later chapter. Any update to both text controls will update the new post,
    thanks to the two-way bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computed properties are functions that evaluate to properties and depend on
    other properties. We can use computed properties to create states and properties
    that depend on other properties. This is especially helpful when we want to obtain
    states through aggregation or any form of map reduce. Here''s a use case example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the template is able to display the user''s `fullName` based
    on their first and last names. We already mentioned that such an implementation
    is impossible to accomplish in the template layer alone, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is that instances of objects are never set on a class definition
    unless they''re meant to be static. For example, if the template is a form that
    updates the values of the model, we might be tempted to provide the default model
    of the controller as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation can lead to updates not being isolated as intended.
    Here''s another example of a search feature that can be added in our blog application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This example contains some features that we already discussed. If a user visits
    the search page at `say/search`, they will be presented with a search input that
    automatically updates the search controller's `queryTerm` property on input. As
    you might notice, this controller's `results` property will be recalculated because
    it depends on the controller's `queryTerm` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'One feature that we introduced is the ability of the controller to reference
    other controllers. We will discuss this in a later section, but the important
    thing to note is that we are able to generate results by filtering the model of
    the `posts` controller. The search template automatically redisplays results as
    the user types along. This example demonstrates how trivial it is to add such
    seemingly difficult features in single-page applications. Here are a few other
    features that you can try adding into the application:'
  prefs: []
  type: TYPE_NORMAL
- en: A spinner that shows up new posts every time are being loaded from the server.
    Now is a good time to revisit the loading-and-error action hooks we discussed
    in [Chapter 3](part0029_split_000.html#page "Chapter 3. Routing and State Management"),
    *Routing and State Management*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `humanizedDate` computed property for each of the loaded posts. Let
    this property return the post's date in a readable format such as `Mon, 15th`.
    Moment.js ([http://momentjs.com](http://momentjs.com)) can come in handy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to computed properties, we also learned how to use observables.
    These are functions that react to changes made on other properties. For example,
    let''s make the search functionality previously mentioned more user friendly.
    Most users expect the search request to kick off after a second or two, after
    they''ve stopped typing the query term. We, therefore, need a way to *debounce*
    this search. Ember.js provides a function that serves this purpose and can be
    referenced as `Ember.run.debounce`. Here''s a possible implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The controller defines an observer, `queryTermDidChange`, which invokes the
    search function after only a second of typing. As illustrated, the `debounce`
    function ([http://emberjs.com/api/classes/Ember.run.html#method_debounce](http://emberjs.com/api/classes/Ember.run.html#method_debounce))
    takes three arguments—a context, a function to invoke within the specified context,
    and the time to wait for invocation if no other calls are made.
  prefs: []
  type: TYPE_NORMAL
- en: Object and array controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ember.js ships with the following controllers that are meant to easily represent
    objects and enumerable data, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: Object controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These controllers are a bit different from the other controllers in the sense
    that the data being represented is usually set as the `model` property of the
    controller, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An object controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An object controller is used to proxy properties of the object being represented.
    This means that if a controller property is accessed, Ember.js will look for the
    property first in the controller, and then the model. For example, let''s create
    a post model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new post from this model as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This post''s properties can obviously be accessed using the object''s getter
    and setter methods as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When this post is set as the model of an `ObjectController` instance, as shown,
    access to the controller properties translates to access to the post, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that using a normal controller will not yield the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Object properties are useful when we wish to create computed properties on
    the controller whose dependent properties are those of the model. For example,
    let''s pass the preceding defined post as a route''s model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to compute a `tags` property based on the given array
    of IDs, we will implement this in the corresponding controller as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With the computed property defined, we can go ahead and use it in the post
    template as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will yield something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that we do not have to prefix the variables with `model.`, as we did in
    the preceding sections, because the template's context, the controller, forwarded
    these requests to the model. This type of controller uses the `Ember.ObjectProxy`
    ([http://emberjs.com/api/classes/Ember.ObjectProxy.html](http://emberjs.com/api/classes/Ember.ObjectProxy.html))
    mixin, which enables a proxy (in this case, the controller) to forward all requests
    to the properties that it has not defined, and to its model, as we already discussed.
  prefs: []
  type: TYPE_NORMAL
- en: An array controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Likewise, array controllers are used to represent enumerable data. An example
    of enumerable data is the JavaScript `Array` primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the corresponding template will list the items as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we also did not need to reference the model, as shown in the following
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since array controllers represent enumerable data, they provide the following
    useful methods that can be used to manipulate their models.
  prefs: []
  type: TYPE_NORMAL
- en: addObject(object)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `addObject(object)` method adds the given object to the end of the controller
    model if the latter does not contain the former, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If the model already contains the object, this method call fails silently.
  prefs: []
  type: TYPE_NORMAL
- en: pushObject(object)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pushObject(object)` method always adds the object, regardless of whether
    the model contains it or not, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: removeObject(object)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `removeObject(object)` method is used to remove the given object from the
    controller''s model, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method also does nothing if the model doesn't contain the object.
  prefs: []
  type: TYPE_NORMAL
- en: addObjects(objects), pushObjects(objects), and removeObjects(objects)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three methods mentioned previously are used to perform the three methods
    we just discussed using multiple objects, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: contains(object)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check if a model contains an object, we can use the `contains(object)` method
    that returns a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: compact()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `compact()` method returns a copy of the underlying model, with undefined
    and null items removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: every(callback)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `every(callback)` method is used to check if each of the items contained
    in the model satisfies a given condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: filter(object)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filter works in the same as way as the native JavaScript array object, `Array.filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: filterBy(property)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we want to compact a model, but only if the items contained define
    the given property. We can use the preceding `filter` method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use a shorter version, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: find(callback)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, we can use the `filter` method to return the first
    occurrence of a primary color, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is inefficient because we always loop through all the model items. The
    `find` method can be used to achieve this need as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As soon as a match is found, the check iteration is aborted.
  prefs: []
  type: TYPE_NORMAL
- en: findBy(key, value)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as in the `filter` versus `filterBy` case, we can reimplement the preceding
    example using the `findBy` method instead of `find`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: insertAt(index, object), objectAt(index), and removeAt(index, length)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `insertAt(index, object)`, `objectAt(index)`, and `removeAt(index, length)`
    methods are used to perform operations using item indices. The first method is
    used to add an object at the given index. An error is thrown if the index is out
    of bounds. The second method is used to retrieve an object at the specified index.
    Again, if the index is out of bounds, an undefined value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we cannot use negative indices for lookups, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method removes objects matching the given index by an optional range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: map(callback)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A map works in the same way as `Array.map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: mapBy(property)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the result generated in the preceding example, we can use the `mapBy`
    method to get back the original array as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated, this method returns a new array containing the values evaluated
    on the model items.
  prefs: []
  type: TYPE_NORMAL
- en: forEach(function)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a commonly used method that invokes the given function on each of the
    items contained in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: uniq()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, the `uniq()` method returns a new array devoid of duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: sortProperties and sortAscending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sortProperties` and `sortAscending` methods are used to sort the represented
    data. For example, we might have a music catalog that we want to sort by album
    name, and later by song name, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Album name | Song name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Folie a deux | Tiffany Blews |'
  prefs: []
  type: TYPE_TB
- en: '| Folie a deux | W.A.M.S |'
  prefs: []
  type: TYPE_TB
- en: '| Infinity on high | Thriller |'
  prefs: []
  type: TYPE_TB
- en: 'To accomplish this, we need to define the following properties in the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sortProperties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortAscending`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first property specifies the properties to use when ordering the items,
    while the second property specifies the sort direction. In our cases, we will
    sort the music catalog as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To sort the songs in the reverse order, we need to set the `sortAscending` property
    as `False`.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few of the common methods that are provided by the `Ember.ArrayProxy`
    ([http://emberjs.com/api/classes/Ember.ArrayProxy.html](http://emberjs.com/api/classes/Ember.ArrayProxy.html))
    mixin, which `Ember.ArrayController` uses.
  prefs: []
  type: TYPE_NORMAL
- en: Handling event actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how user actions can easily be delegated
    to controllers and routes from templates. Let''s have a recap with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we defined two actions that will be handled by the corresponding
    controller as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We already learned that all action handlers are defined in the `actions` property
    of the target controller or route. In this case, when the user submits the form
    either by clicking on the **submit** button or by hitting the *Enter* key, the
    `save` hook in the controller is called with the post context as the only argument.
    Likewise, clicking on the **cancel** button calls the corresponding `cancel` hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical widget consisting of tabs can be implemented in the same way, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling event actions](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the widget template might look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This template contains the `tabs` element group generated from the `tabs` context
    property. If any of the tabs are clicked on, they will need to acquire a `selected`
    class. Here''s suitable styling that will achieve this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `selected` action handler for the controls will then be implemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that these actions don't have to be caught in the context controller as
    we discussed in the previous chapter. When an action is triggered, typically from
    a template element, Ember.js checks to see if the appropriate action handler is
    defined inside the actions property of the immediate controller. If this is not
    the case, Ember.js proceeds to search for the action handler in the corresponding
    route. If this route still doesn't implement the handler, Ember.js will continue
    searching for the action handler in higher routes. One thing to note is that if
    an action handler returns `True`, Ember.js will still continue to search for this
    handler, constituting **action bubbling**.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying controller dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Controller dependencies enable controllers to associate. Therefore, whenever
    a controller needs to access the properties of another controller, it should first
    declare the controller as a dependency in order for it to be able to do so. These
    dependencies are defined in the `needs` property of the affected controller. For
    example, let''s say we decided to add a commenting system to our blog application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In a typical blog, comments are usually displayed on a separate page, and in
    our case, at a page with a path such as `/post/100/comments`. We will need to
    define a `comments` template that lists the loaded comments as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have noticed, the template needs to display the title of the comments''
    post. To do this, it needs to be able to access a loaded post in the `post` controller.
    By specifying a dependency to the post controller, the comments controller will
    be able to access the post controller in its `controllers` object property. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `comments` template will be updated to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering whether this can lead to an infinite dependency loop.
    Well, controllers can depend on each other without suffering from this fate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This association serves as the correct channel of communication between the
    different components of the application.
  prefs: []
  type: TYPE_NORMAL
- en: State transitions in controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](part0029_split_000.html#page "Chapter 3. Routing and State Management"),
    *Routing and State Management*, we learned that routes can transition the state
    of an application into other routes by invoking their `transitionTo` method, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, controllers also have this capability through the use of the provided
    `transitionToRoute` method. For example, we can change states in a controller''s
    action handler as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been an exciting chapter that helped us understand the primary purpose
    of controllers, which is data representation. We learned how controllers are defined
    based on the defined application routes. We also learned how to use object and
    array controllers to represent models. Lastly, we learned how to set up dependencies
    between controllers, which might handle different concerns of the application.
    At this point of the book, we really should be ready to start thinking of ways
    to architect Ember.js applications. The next chapter will cover the view layer,
    for which a good amount of knowledge in the use of controllers will be required.
  prefs: []
  type: TYPE_NORMAL
