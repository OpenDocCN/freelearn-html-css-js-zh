- en: Chapter 4. Designing Simple Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to focus on applying the concepts that we have
    learned in the previous chapters to design some simple modules for our application.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by analyzing our application's functionality as a whole and then
    we will break it down into smaller functional pieces. Once we have decided on
    our application's functional pieces, we will start creating simple modules to
    implement the required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to demonstrate the possible steps in the beginning of
    our application's life cycle, based on our requirements. The goal is to see how
    using modules can help us design a better architecture and get a feel for the
    practical advantages of a modular design.
  prefs: []
  type: TYPE_NORMAL
- en: The simple modules that we create in this chapter will provide the foundation
    for our final application in this book, which will be a working client-side single
    page application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting the overall application requirements in our design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the application's main pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating specialized modules for our application's main pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration among modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object definitions to describe page fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically generating pages and page fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start any coding at all, we need to have a good understanding of what
    our application is all about, what the requirements are, and what possible functional
    pieces are needed to satisfy our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: While in the beginning of an application's design phase, we try to answer as
    many questions as possible regarding our application's requirements, we should
    always try not to get too tied down by the details.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to get the big picture right, understand what it is that we want
    to deliver, the timelines involved, and the resources available. Based on such
    analyses, we can start creating a scalable, flexible, and extensible architectural
    design for our application.
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to draw your attention to a very important word that I used here, **extensible**.
    The ability of an application to be easily extended is very important in a proper
    design. Keep in mind that no matter how much we try to finalize all of the requirements
    for an application ahead of time, we won't be able to foresee them all in the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements change over time, new requirements are added, and old requirements
    get modified or even removed altogether from the final draft of the application.
    The key is to design our application in a way that can accommodate all such changes
    without a big impact on the overall architecture. This is where the advantages
    of a modular architecture shine and help to mitigate the adverse effects that
    such changes might have on the application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: As we keep these points in mind, let's talk about the application that we are
    going to build together in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Our application requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application is a simple yet fully functional image gallery application.
    The goal is to present the users with a catalog of beautiful images on our site.
    Our site visitors can click each of the images to see a full view of the image
    and add the images to their favorite list of images, if they wish to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The application will have a header, a navigation bar at the top, a main content
    area in the middle, a footer, and of course a logo.
  prefs: []
  type: TYPE_NORMAL
- en: As you can tell, there are not many complicated pieces at play here, but I assure
    you that under the hood there are many modules that can be easily ported from
    this application to many other more complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating an overall layout (wireframe) of our application and
    see what the big picture looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Our application requirements](img/B04910_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I have identified the main pieces of our index page in this mock-up. We are
    going to create modules to build and update this page, its related pieces, and
    the rest of the application for us.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned that our JavaScript modules are going to build this page for us,
    and I need to explain this a little further.
  prefs: []
  type: TYPE_NORMAL
- en: While we are going to create modules to take care of the functional pieces of
    the application, we are going to take that a step further. We are also going to
    create modules that will specialize in building our pages (views) dynamically
    on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: In this design, we only receive the skeleton of the page from the server. The
    page will be populated by our view-generating modules based on the object definitions
    for each page section (fragment) that is sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The overall architecture of our application is based on **Single Page Application**
    (**SPA**) design concepts. If you are not familiar with this term, the idea is
    that as we navigate through our application pages (views), we won't need to load
    or build the parts of the page that don't change from one view to the next. We
    simply update the changed pieces of the view dynamically on the client while keeping
    the rest of the view untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Since we only do targeted changes in our application's view, the rendering of
    our views will be more robust and optimized.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that after the application's initial load, the client will only
    be requesting the changed parts of the application from the server. Therefore,
    we will only be transferring the page fragments over the bandwidth as opposed
    to the full page. Generally speaking, this can be a great advantage when we design
    applications that need to operate in limited bandwidth scenarios, such as mobile
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: For our application in this book, our page fragments are transferred as object
    definitions to the client side and our view-generating specialized modules will
    render the required views based on such object definitions.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how we can achieve this in the near future as we move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our SPA main pieces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually when designing SPA applications, I create a core application code base
    which is loaded in the browser at the application's initial load phase. This code
    base provides application-level functionality that is independent of the application's
    views. The application core consists of many modules that are loaded together.
    If you are familiar with **Model-View-Controller** (**MVC**) or **Model-View-Wildcard**
    (**MV***) application design patterns, this core is essentially the controller
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**MVC and MV* design patterns**'
  prefs: []
  type: TYPE_NORMAL
- en: These design patterns create a good degree of specialization and separation
    of concerns in the code. Understanding these patterns is important in creating
    a good application architecture. While I will be referring to these patterns from
    time to time, covering them in depth is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend the following resources for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/mastering-javascript-design-patterns/](https://www.packtpub.com/application-development/mastering-javascript-design-patterns/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/](https://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/)'
  prefs: []
  type: TYPE_NORMAL
- en: The model and views of the application also have their own specialized modules,
    some of which are loaded at the initial application load time and some as needed,
    dynamically, at a later time. This type of approach enables the application to
    have a small footprint in the browser and load only what it needs, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: I also usually try to have every page of my application as a separate module
    (component) both on the server and the client side. This provides the capability
    to create, modify, or remove pages (components) and their related code without
    affecting other pieces of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I'm using the term "module" here as a general term and it does not
    necessarily mean modules that are built using the module pattern. My intent is
    to convey the idea that each page is a separate piece in the application, within
    which one or many JavaScript modules can be used to do the work related to that
    page and that page only. If you are not sure exactly what this means, rest assured
    it will all become more clear to you shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure depicts the main pieces of our application for this book,
    categorized by their special functionality and design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing our SPA main pieces](img/B04910_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the figure shows, our overall design is based on three main pieces: **Controller**,
    **View**, and **Model**. In the rest of this chapter, we will talk about each
    piece and will start building them based on our modular architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Application controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The controller is the piece that contains the main functionality of the application.
    Essentially, the controller module is the brain of the application. It will consist
    of application-level modules that provide application-level functionality. This
    piece will also be responsible for initializing all the other modules and components
    in the application as well as gluing them together using a loose coupling approach.
  prefs: []
  type: TYPE_NORMAL
- en: Application controller modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Considering the role of the controller in our application as mentioned, we are
    going to design this piece based on specialized modules. These modules together
    create what we will be referring to as the **core** module.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that since we are using specialized modules for our core, each
    module can easily be modified or replaced without affecting the other parts of
    the application, that is, with the exception of the functionality that is related
    to that module and that module only.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can also add more modules to the core, if we decide that additional
    functionality is needed at some point in the future.
  prefs: []
  type: TYPE_NORMAL
- en: It is the collective functionality of the controller modules that provides the
    core functionality of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our application''s requirements, I anticipate that we will be needing
    the following modules in our application''s controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Page updater module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage handler module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication handler module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message handler module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging handler module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that we are making our best guess as to what modules are required.
    The list can change over time as we proceed further in our implementation. The
    idea is to design and implement the modules that we think we will be needing at
    this time, to have a starting baseline. However, the list of the modules, their
    functionality as well as the names that we choose for them can change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by exploring what the functionality of each module in our application's
    core will be.
  prefs: []
  type: TYPE_NORMAL
- en: Page updater module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This module is responsible for building HTML pieces in our application. It does
    this task by injecting a string passed to it into a container. This string corresponds
    to the HTML elements that need to be rendered into the predefined container.
  prefs: []
  type: TYPE_NORMAL
- en: We will be building various pieces of our application pages and updating them
    dynamically as required, using this module.
  prefs: []
  type: TYPE_NORMAL
- en: Storage handler module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This module has the specific responsibility of storing application-related data.
    This data can be either stored in cookies or in other storage facilities provided
    by the browser, such as HTML 5 local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Communication handler module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All application-related communication is done through this module. This module
    is mainly designed to use AJAX calls to communicate with the back-end server.
    However, the method of communication that this module uses might not be limited
    to AJAX calls at some point in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This module is responsible for providing utility type functionality to the application.
    For instance, it can do string manipulation, object cloning, or page resize calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Message handler module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As events take place in the application, we need a way to communicate such events
    with the users and display messages on the application's pages. This module specializes
    in this task.
  prefs: []
  type: TYPE_NORMAL
- en: Logging handler module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This module provides all the functionality related to the logging mechanism
    of the application. The logging can take place on the client side, the server
    side, or both.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first core module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have put together the list of possible required modules for the
    core, let's create the first module of our application's controller, the `PageUpdater`
    module. This module should be designed in such a way that it can dynamically update
    a fragment of the page. This fragment can be as small as a text on the page, or
    as large as the entire displayed page itself. The update to the page fragment
    can be as trivial as changing the font size or the background color or as complex
    as completely re-structuring and re-rendering of the page fragment altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of our first module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements a simple module which enables us to do an update
    on a page fragment. Let's examine the code and see how it is structured.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined a JavaScript module, using the module pattern. An IIFE is used
    to execute the code in our anonymous function, which creates a namespace. What
    gets returned from this function is an object that is assigned to our global variable
    `PageUpdater`.
  prefs: []
  type: TYPE_NORMAL
- en: In our IIFE, we have defined `insertHTMLTxt` and `applyElementCSS` method properties,
    using function expressions. These two methods are kept within the internal private
    scope of our main container function, and as such no external code can access
    them. Thus, we are protecting them from accidental and unintended modifications.
  prefs: []
  type: TYPE_NORMAL
- en: We do provide controlled and indirect access to these methods through the module's
    interface, which is the anonymous object that is returned when our container function
    is executed. A reference to this returned object (our module's interface) is assigned
    to the `PageUpdater` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in fact what is really referenced in this variable (`PageUpdater`) is the
    following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is just a normal JavaScript object, we can call its methods from the
    external code as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `updateElement` method of the `PageUpdater` object in turn calls `insertHTMLTxt(elemID,htmlTxt)`,
    which is the method inside our container function that does the real work behind
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method receives two parameters: the id of the container element (`containerID`),
    which we intend to update its contents, and a string (`newStructure`), which is
    the string representation of the HTML elements that will be rendered inside this
    container element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are wondering how `PageUpdater` object can call the method inside of
    our container function and how the link is established between the two, you need
    to think of one word: closure!'
  prefs: []
  type: TYPE_NORMAL
- en: We did talk about closures in [Chapter 2](ch02.html "Chapter 2. Review of Important
    JavaScript OOP Concepts"), *Review of Important JavaScript OOP Concepts*. If you
    recall, because the anonymous object returned from our IIFE was defined inside
    the container function, it has access to the internal private scope of our container
    function. This means `PageUpdater` has access to all the private variables and
    methods defined inside of that scope. That is why the methods that are returned
    as part of the interface from the module are called, **privileged methods**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Having problems understanding the module pattern?**'
  prefs: []
  type: TYPE_NORMAL
- en: I took some time here to explain our first simple module in depth. Moving forward,
    I will not be explaining the pattern used in creating our modules (module pattern)
    in as much detail. It is important for you to have a good understanding of this
    pattern, as our other modules in the application follow a similar structure.
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding of the module pattern, I recommend doing two things.
    First, review [Chapter 2](ch02.html "Chapter 2. Review of Important JavaScript
    OOP Concepts"), *Review of Important JavaScript OOP Concepts* and [Chapter 3](ch03.html
    "Chapter 3. Module Design Pattern"), *Module Design Pattern* again. Second, spend
    some time analyzing the previous code and read my explanations a couple more times.
    I'm sure you will get a good grasp of this pattern very soon.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `PageUpdater` module is currently capable of doing two things.
    It can update the `innerHTML` of a container element as well as being able to
    update the **CSS** class of an element on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Using our first module's functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an example of how we can leverage the module''s functionality
    by making calls to its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the preceding code populates the footer section of our application,
    based on a predefined object definition, which we will talk about a little later
    in this chapter. The second line of code changes the CSS class of the footer container
    to apply a different background color to this page fragment. The code accompanying
    this chapter has the CSS class definition for this operation.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we let the module take care of the mechanics of how page fragments
    are updated, and all we have to do is to make simple calls to it through the interface
    that has been provided for this module.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping our module's methods to its interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one important point that we need to note regarding our module's interface,
    which can easily be missed.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, in [Chapter 3](ch03.html "Chapter 3. Module Design Pattern"),
    *Module Design Pattern*, I mentioned that a module is free to implement how it
    accomplishes its tasks and this implementation can change over time. However,
    a module should keep its interface consistent to the outside world. Of course,
    this is because the interface of a module is the module's contact and that's how
    the other pieces of the application can interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we have defined the following interface for our `PageUpdater` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to the outside world, when a CSS class needs to be applied to
    an element, the `updateElementClass` method should be called on the module. This
    module in turn calls a method with a different name in the module's definition,
    which is `applyElementCSS`.
  prefs: []
  type: TYPE_NORMAL
- en: This type of mapping allows us to change the name of the internal method of
    the module without affecting the module's interface for the external code. The
    mapping provides a layer of abstraction between the module's internals and its
    public interface.
  prefs: []
  type: TYPE_NORMAL
- en: Our module is currently a simple module that does relatively simple things for
    our application, but it does not have to be limited to what we have defined here.
  prefs: []
  type: TYPE_NORMAL
- en: As we move along in this book, we will be augmenting this module (and others)
    to do more things. Nonetheless, we should always keep in mind that this module
    is specialized to only do tasks that are related to updating of our application
    pages and nothing beyond that. After all, one of the main ideas behind modular
    design is that each module only does one type of work and nothing more so we can
    stay true to the concept of separation of responsibilities and concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Running the accompanying application''s code**'
  prefs: []
  type: TYPE_NORMAL
- en: You'll be able to run the application's code by loading the `index.html` page
    in the browser using any IDE that has a built in web server.
  prefs: []
  type: TYPE_NORMAL
- en: Please have a look at the code that accompanies this chapter and use this module
    to update different fragments of the page as you wish. All the modules discussed
    in this chapter can be found in the `js`/`Modules.js` file in the accompanying
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Application view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another main piece of our application is the **view** piece. As the name implies,
    this piece deals with the view of all the pages and page fragments of the application.
    The view is what the user actually sees in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Since our application is based on a MV* type architecture (in conjunction with
    modular architecture), our views interact with the controller as well as the model
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: However, the way we will build our application's views is a little different
    than traditional MV* applications. Our application views will be designed as modules
    and because these modules specialize in creating views, we will be calling them
    **components**. This is to make the distinction between modules that have views
    and those that only provide functionality but have no direct relations to our
    application's views.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to keep in mind about components is that they can implement
    their own MV* architecture. This type of implementation might not be very clear
    to you at this time, but I assure you that it will all make more sense in the
    following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will only focus on how `index.html` is built and how it
    is populated using a few object definitions and the controller methods that we
    saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: To create our `index.html` page, we will start by building a skeleton for this
    page and then we will dynamically modify this skeleton to produce its main fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the index.html page skeleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The page skeleton of our application is designed to be as minimalist as possible
    at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the page structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we render this HTML markup in the browser, we will have the following
    skeleton of our `index.html` page displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the index.html page skeleton](img/B04910_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that we have created three main containers: `headerContainer` (the top
    section of the page), `mainPageContainer` (the middle section of the page), and
    `footerContainer` (the bottom section of the page), which are the three main fragments
    of the page.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be populating each one of these page fragments with the HTML elements
    that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object definition for the header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you recall, I mentioned that we will be using object definitions to define
    our page fragments in the application.
  prefs: []
  type: TYPE_NORMAL
- en: As these object definitions are very similar to each other, we will only examine
    one of them in this section , which is related to the header fragment of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the object definition for the header section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have defined an object literal which at this time only contains
    one property, `sectionHTML`.
  prefs: []
  type: TYPE_NORMAL
- en: This property holds a string that is the string representation of the HTML elements
    for the header fragment of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, as implemented, we currently have a global variable called
    `headerContainerDef` for our object definition. As you know, we should try to
    avoid using global variables in our code. We will be fixing this issue soon, but
    at this time it is done so on purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our first object definition, it is time to create the
    first view of our application for the Header fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Header fragment dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you saw previously, our application's controller has a module that specializes
    in generating page fragments on the page and it is called `PageUpdater`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used our application's `PageUpdater` module and have
    passed the id of the Header fragment as the first parameter to its `updateElement`
    method. The second parameter to this method is the object definition for the Header
    fragment. This implementation allows us to leverage the functionality of our application's
    controller to render the Header fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can use the same approach to create other parts (fragments) of
    our page, such as the footer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the `index.html` page for our application
    is displayed when the page fragments have been rendered on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating the Header fragment dynamically](img/B04910_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main content area of the page (colored red in the middle of the page), is
    the area that will be updated as the user navigates through the pages in our application.
    The header and footer of the page will not be re-rendered for any of the application's
    pages, as our application is built on SPA principles.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I have used some interesting background colors to depict each
    fragment of the page. I like to call this color-coding of the page fragments.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this coloring schema is to easily distinguish each specific region
    of the page in our visual design. When we are finished with our application implementation,
    this page will look a lot better, but for now, this is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you are reading this book in a black and white medium, you only
    see light and dark shades in the preceding image.
  prefs: []
  type: TYPE_NORMAL
- en: Generating client application's view dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the techniques that I use in my applications is what I call **Dynamic
    Page Generation** (**DPG**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that each main fragment of the page is associated with an object
    definition, and in this object definition the characteristics of the page fragment
    are defined. For instance, in our design for this application, I have considered
    three distinct fragments on the page: the header fragment, the content fragment,
    and the footer fragment.'
  prefs: []
  type: TYPE_NORMAL
- en: Each main fragment, in turn, could further be divided into sub-fragments and
    each sub-fragment may or may not have its own distinct object definition.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we could have only one object definition for the entire page,
    which would be used to dynamically generate the page as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the decision on how to associate an object definition to
    a page fragment or a sub-fragment is in the hands of the user interface developer.
    The developer makes these decisions by considering factors such as the frequency
    at which a fragment or sub-fragment needs to be updated, or whether a page fragment
    needs to be updated independently of other fragments of the page. Of course, performance
    also plays a major role in such decisions.
  prefs: []
  type: TYPE_NORMAL
- en: There are also instances when building certain page fragments on the server
    side is more robust than building them on the client.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we are building all the page fragments on the client dynamically.
    This is so we can explore the full functionality of our modules and components
    on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The look and feel of our application**'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the aim of this application is to help you understand the concepts
    of modular design as it relates to JavaScript applications, and as such the focus
    has not been on the look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: While we will improve the appearance of the application as we move forward,
    I'm sure you can improve its appearance quite a bit further on your own. Our application
    is somewhat responsive based on the browser's view-port but can certainly use
    more CSS polishing to make it fully responsive.
  prefs: []
  type: TYPE_NORMAL
- en: However, I do consider this application as a **Minimum Viable Product** (**MVP**)
    for our purposes. Please feel free to download the code from the site that accompanies
    this book and improve it as you desire. Also, I have only tested this application
    in Chrome 46.0, but a production-quality application needs to be tested in a variety
    of different browser types and versions.
  prefs: []
  type: TYPE_NORMAL
- en: Application model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last main piece of our MV* implantation is the model. The main role of this
    piece is to store application-level data. In a client application, such data can
    be stored in cache, in cookies, or in local or session storage.
  prefs: []
  type: TYPE_NORMAL
- en: In the main application for this book, we will be using most of such mechanisms
    to store our application's data. Also, as a general point, depending on the implementation
    of the MV* architecture, changes in the model's data can trigger changes in the
    application's view.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to shield application-level data from accidental overwrites
    and modifications. In our implementation, we are going to use the module pattern
    once again to create a module which will act as our application's model and will
    provide a good level of protection for the stored data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a module for our application's model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have created a `GlobalData` module to keep our application-level
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure you are pretty familiar with how the mechanism works by now. We have
    created an IIFE to return an object as an interface to our private namespace(module).
    This object provides two methods: `getHeaderHTMLTxt` and `getFooterHTMLTxt`.'
  prefs: []
  type: TYPE_NORMAL
- en: These methods return the property values of two private variables `headerContainerDef`
    and `footerContainerDef` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have not provided any methods to set the values for these variables,
    and since they are private variables in our module, we have created a degree of
    encapsulation. Thus, shielding our data from outside influence.
  prefs: []
  type: TYPE_NORMAL
- en: The property value of `headerContainerDef` is a string representation of the
    HTML elements in the header fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This string is used to populate the Header fragment of our application''s view,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just the same, the property value of `footerContainerDef` is a string representation
    of the HTML elements in the Footer fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This string is used to populate the footer fragment of our application''s view,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that when we rendered our header and footer fragments previously, we used
    global variables (such as `headerContainerDef`) to get the required strings for
    the page fragments.
  prefs: []
  type: TYPE_NORMAL
- en: However, in our new implementation, we access these strings using the `GlobalData`
    interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to keep in mind here is that we have implemented two independent
    modules (`PageUpdater` and `GlobalData`) that work together to create the building
    blocks of our application. We will leverage the collaboration among our application
    modules further as we advance through the next chapters, and will implement the
    full functionality of our application on such basis.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that our `GlobalData` module is only tasked with providing data
    to other pieces of the application, and `PageUpdater` is only responsible for
    updating fragments of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Another subtle point to consider is the fact that we can change the internals
    of both modules as we desire. But as long as the interfaces of the modules don't
    change, they can still continue working together without the internal changes
    of one module having any effect on the functionality of the other.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a logging module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a further exercise, we are going to create one more module in this chapter.
    This module will look after all the necessary work related to logging messages
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, which main application piece does this module belong to?
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, we need to do a simple analysis. First, since this
    module does not have any views associated with it, we need to consider it as a
    functional module and not a component.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this module does not store any application data for us. Therefore, this
    module should belong to the controller piece of our application. As mentioned
    before, since we consider the controller piece of our application to be the same
    as the core module, the logging module should belong to the core module.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the core module consists of many smaller modules (sub-modules)
    that build the core together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our simple logger module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This module definition structure is pretty much the same as other module definitions
    that we have seen so far, but with minor differences.
  prefs: []
  type: TYPE_NORMAL
- en: We have used a different technique here and have returned a named object instead
    of an anonymous object from our IIFE. We have named this object `theInterface`.
    Initially, this object is an empty object but then we augment this empty object
    with two method properties. One of them logs information messages and the other
    logs error messages to the console.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that no information message is passed to `theInterface.logInfo`
    method, a default message is logged to greet the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we call the methods on the interface of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is the same way that we call interface methods when we return an anonymous
    object from a module.
  prefs: []
  type: TYPE_NORMAL
- en: I have used this technique of returning a named object from a module here to
    show you we don't always have to return an anonymous object from an IIFE to create
    a module interface, and that there are different ways of implementing the module
    pattern. We will explore these techniques further in future chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Practical usage of our modules**'
  prefs: []
  type: TYPE_NORMAL
- en: As I like to present the concepts along with their practical aspects, I recommend
    that you download the accompanying code for this chapter. Have a look at the simple
    modules in action, and play around with the code as much as you can. This will
    help you become more familiar with the concepts and solidify them in your mind.
    My recommendation applies to this chapter as well as all the other chapters of
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we moved from the conceptual design of modules to the practical
    aspects of implementing them. We started by looking at the high-level requirements
    of our intended application, and then considered the kind of modules that we might
    possibly need to fulfill those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly discussed the MV* design pattern and structured our application to
    follow this pattern. Then, based on the functionality and the role that our modules
    play in our design, we categorized them to be part of the controller, view or
    model pieces of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The view for our application was generated by first creating an `index.html`
    page skeleton and then populating its main fragments based on object definitions,
    using a core module.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a safe global data repository for our application to act as
    the model piece of our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: An example of how modules can collaborate together to complete tasks and provide
    application level functionality was also presented.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will extend our application modules and work further
    on the building blocks of our application in a modular design approach.
  prefs: []
  type: TYPE_NORMAL
