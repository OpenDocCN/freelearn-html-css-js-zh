<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started</h1>
                
            
            
                
<p>There was a time when most of the web comprised pages with static content—the only graphics were embedded images. Over time, however, application requirements became more ambitious and began running into limitations. As highly interactive applications became an increasingly important part of the user experience, there was, eventually, enough demand for a fully programmable graphics <strong>Application Programming Interface</strong> (<strong>API</strong>) to address these requirements. In 2006, Vladimir Vukicevic, an American-Serbian software engineer, began working on an OpenGL prototype for a then-upcoming HTML <kbd>&lt;canvas&gt;</kbd> element that he called Canvas 3D. In March 2011, his work would lead to the Kronos Group, the nonprofit organization behind OpenGL, to create <strong>WebGL</strong>, a specification to grant internet browsers access to <strong>Graphics Processing Units</strong> (<strong>GPUs</strong>).</p>
<p>All of the browser engines collaborated to create WebGL, the standard for rendering 3D graphics on the web. It was based on OpenGL <strong>Embedded Systems</strong> (<strong>ES</strong>), a cross-platform API for graphics targeted at embedded systems. This was the right starting place, because it made it possible to easily implement the same API in all browsers, especially since most browser engines were running on systems that had support for OpenGL. </p>
<p>WebGL was originally based on OpenGL ES 2.0, the OpenGL specification version for devices such as Apple's iPhone and iPad. But, as the specification evolved, it became independent with the goal of providing portability across various operating systems and devices. The idea of web-based, real-time rendering opened a new world of possibilities for web-based 3D environments. Due to the pervasiveness of web browsers, these and other kinds of 3D applications could now be rendered on desktop and mobile devices such as smartphones and tablets. According to the Khronos Group, the ability for Web developers to directly access OpenGL-class graphics directly from JavaScript, and freely mix 3D with other HTML content, will enable a new wave of innovation in Web gaming, educational and training applications.</p>
<p>Even though WebGL was vastly adopted for many years after it matured into a stable release—shipping inside Firefox, Chrome, Opera, IE11, and Android's mobile web browsers—Apple still lacked official WebGL support. Neither OS X Safari nor Safari Mobile supported WebGL. In fact, it wasn't until 2014, at June's <strong>Worldwide Developers Conference</strong> (<strong>WWDC</strong>), that Apple announced that both OS X Yosemite and iOS 8 would ship with WebGL support. This became a turning point for 3D graphics on the web. With official support from all major browsers, the entire range of 3D graphics—at native speeds—could be delivered to billions of desktop and mobile devices. WebGL unleashed the power of graphics processors to developers on an open platform, allowing console-quality application to be built for the web.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Understand the necessary system requirements to run WebGL.</li>
<li>Cover the common high-level components of a WebGL application.</li>
<li>Set up a drawing area (<kbd>canvas</kbd>).</li>
<li>Test your browser's WebGL capabilities.</li>
<li>Understand that WebGL acts as a state machine.</li>
<li>Modify WebGL variables that affect your scene.</li>
<li>Load and examine a fully-functional scene.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">System Requirements</h1>
                
            
            
                
<p>WebGL is a web-based 3D Graphics API. As such, there is <em>no</em> installation needed. While WebGL 1 is based on the OpenGL ES 2.0 specification, WebGL 2 is based on OpenGL ES 3.0, which guarantees the availability of many WebGL 1 extensions along with new features. </p>
<p>WebGL 2 Versus WebGL 1<br/>
<br/>
Given this book covers WebGL 2, all WebGL and WebGL 2 terms reference the WebGL 2 (OpenGL ES 3.0) specification. Any references to WebGL 1 (OpenGL ES 2.0) will be done so explicitly.</p>
<p>As of January 27, 2016, WebGL 2 is available by default in Firefox and Chrome. You will automatically have access to WebGL 2, provided you have one of the following web browsers:</p>
<ul>
<li>Firefox 51 or above</li>
<li>Google Chrome 56 or above</li>
<li>Chrome for Android 64 or above</li>
</ul>
<p>For an updated list of the web browsers that support WebGL, please visit the Khronos Group web page: <a href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation</a>.</p>
<p>Or visit the well-known <strong>CanIUse.com</strong> resource: <a href="https://caniuse.com/#search=webgl2">https://caniuse.com/#search=WebGL 2</a>.</p>
<p>Modern Standards<br/>
<br/>
Since we will be using modern browsers to run WebGL 2, we will also leverage HTML5, CSS3, and JavaScript ES6 throughout this book. For more information on these modern standards, please refer to the following link: <a href="https://developer.mozilla.org/en-US/docs/Web">https://developer.mozilla.org/en-US/docs/Web</a>.</p>
<p>At the time of this book's publication, WebGL 2 remains a specification that's in flux. Some parts of the specification are considered stable and have been implemented in modern browsers; other parts should be considered experimental and have been partially implemented to varying degrees. Therefore, you should be familiar with how the standardization process works and the levels of implementation for each new property. That being said, WebGL 2 is nearly 100% backward compatible with WebGL 1. All exceptions to backward compatibility are recorded in the following link: <a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY">https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY</a>.</p>
<p>Migrating to WebGL 2<br/>
<br/>
If you have prior experience with WebGL 1 or are curious about migration strategies to WebGL 2, you can refer to <a href="9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml" target="_blank">Chapter 11</a>, <em>WebGL 2 Highlights</em>, where key differences between WebGL 1 and WebGL 2 are highlighted.</p>
<p>Lastly, you will need to make sure that your computer has an approved graphics card. To quickly validate your current configuration for WebGL 2, please visit the following link: <a href="https://get.webgl.org/webgl2/">https://get.webgl.org/WebGL 2/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WebGL Rendering</h1>
                
            
            
                
<p>WebGL is a 3D graphics library that enables modern web browsers to render 3D scenes in a standard and efficient manner. According to Wikipedia, <strong>rendering</strong> is the process of generating an image from a model by means of computer programs. Since this is a process executed by a computer, there are different ways to produce such images. There are three main distinctions to make when discussing rendering: software-based and hardware-based rendering, server-based and client-based rendering, and retained-mode and immediate-mode rendering. As we will see, WebGL offers a unique approach to hardware and client based rendering with an immediate-mode API on the web.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Software and Hardware Based Rendering</h1>
                
            
            
                
<p>The first distinction we should make is whether we are using any special graphics hardware. On one hand, we can talk about <strong>software-based rendering</strong> for cases where all required calculations to render 3D scenes are performed using the computer's <strong>Central Processing Unit</strong> (<strong>CPU</strong>). On the other hand, as is the case with WebGL, we use the term <strong>hardware-based rendering</strong> for scenarios where there is a GPU performing 3D graphics computations. From a technical standpoint, hardware-based rendering is much more efficient than software-based rendering, because the former involves dedicated hardware handling the necessary operations. In contrast, a software-based rendering solution can be more common due to the lack of hardware dependencies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Server and Client Based Rendering</h1>
                
            
            
                
<p>The second distinction to make is whether the rendering process is happening locally or remotely. When the image that needs to be rendered is too complex, the render will most likely occur remotely. This is the case for 3D animated movies where dedicated servers with lots of hardware resources render intricate scenes. We call this <strong>server-based rendering</strong>. The opposite of this approach takes place when rendering occurs locally. We call this <strong>client-based rendering</strong>. WebGL offers a client-based rendering approach: the elements that are a part of the 3D scene are usually downloaded from a server. However, the processing required to obtain an image is all performed locally using the client's graphics hardware. Although this is not a unique solution, compared to other technologies (such as Java 3D, Flash, and the Unity Web Player Plugin), WebGL presents several advantages:</p>
<ul>
<li><strong>JavaScript programming</strong>: JavaScript is a language that is natural to both web developers and browsers. Working with JavaScript allows you to access all parts of the DOM and easily integrate WebGL applications with other JavaScript libraries such as jQuery, React, and Angular.</li>
<li><strong>Automatic memory management</strong>: WebGL—unlike other technologies, such as OpenGL, where memory allocation and deallocation are handled manually—follows the rules for JavaScript variable scoping and automatic memory management. This simplifies programming tremendously while reducing the code footprint. Ultimately, this simplification makes it easier to understand the application logic.</li>
<li><strong>Pervasiveness</strong>: Web browsers with JavaScript capabilities are installed in smartphones and tablet devices by default. This means you can leverage WebGL across a vast ecosystem of desktop and mobile devices.</li>
<li><strong>Performance</strong>: Performance of WebGL applications is comparable to equivalent standalone applications (with some exceptions). This is possible due to WebGL's ability to access the local graphics hardware. Until recently, many 3D web rendering technologies used software-based rendering.</li>
<li><strong>Zero compilation</strong>: WebGL is written in JavaScript; therefore, there is no need to compile your code before executing it on the web browser. This empowers you to make changes in real-time and see how those changes affect your 3D web application. Nevertheless, when we cover shader programs, we will understand that some compilation is needed. However, this occurs in your graphics hardware and not in your browser.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Retained and Immediate Mode Rendering</h1>
                
            
            
                
<p>The third distinction to make is that WebGL is an immediate mode 3D rendering API designed for the web. Graphics APIs can be divided into retained-mode APIs and immediate-mode APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Retained-Mode Rendering</h1>
                
            
            
                
<p>A <strong>retained-mode</strong> API is declarative. The application builds a scene from primitives, such as shapes and lines, and then the graphics library maintains a scene model in memory. To change what is rendered, the application issues a command to update the scene, which could include, for example, adding or removing a shape; the library is then responsible for managing and redrawing the scene:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/20cc3540-9e72-4351-a72e-eb99abfa4bd6.png" style="width:41.42em;height:22.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Immediate-Mode Rendering</h1>
                
            
            
                
<p>An <strong>immediate-mode</strong> API is procedural. Immediate mode rendering requires the application to directly manage rendering. In this case, the graphics library does not maintain a scene model. Each time a new frame is drawn, the application issues all drawing commands required to describe the entire scene, regardless of actual changes. This method provides the maximum amount of control and flexibility to the application program:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6445c540-8cec-4e28-826d-b4fe1b0e11c5.png" style="width:43.58em;height:23.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Retained Versus Immediate Mode Rendering</h1>
                
            
            
                
<p>Retained-mode rendering can be simpler to use, because the API does more of the work for you, such as initialization, state maintenance, and cleanup. However, it is often less flexible since the API forces its own particular scene model; it can also have higher memory prerequisites because it needs to provide a general-purpose scene model. Immediate-mode rendering, on the other hand, as offered with WebGL, is much more flexible and can implement targeted optimizations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Elements in a WebGL Application</h1>
                
            
            
                
<p>WebGL, like other 3D graphics libraries, comprises many common 3D elements. These fundamental elements will be covered, chapter-by-chapter, throughout this book.</p>
<p>Some of these common elements include the following:</p>
<ul>
<li><kbd>canvas</kbd>: It is the placeholder where our scene is rendered. It is a standard HTML5 element and as such, can be accessed using the <strong>Document Object Model</strong> (<strong>DOM</strong>).</li>
<li><strong>Objects</strong>: These are the 3D entities that make up the scene. These entities are composed of triangles. In the following chapters, we will see how WebGL handles and renders geometries using <strong>buffers</strong>.</li>
<li><strong>Lights</strong>: Nothing in a 3D world can be seen without lights. In later chapters, we will learn that WebGL uses <strong>shaders </strong>to model lights in the scene. We will see how 3D objects reflect or absorb light according to the laws of physics. We will also discuss different light models to visualize our objects.</li>
<li><strong>Camera</strong>: <kbd>canvas</kbd> acts as the viewport to the 3D world. We see and explore a 3D scene through it. In the following chapters, we will understand the different matrix operations that are required to produce a view perspective. We will understand how these operations can be modeled as a camera.</li>
</ul>
<p>This chapter will cover the first element of our list: <kbd>canvas</kbd>. The following sections will help us understand how to create a <kbd>canvas</kbd> element and how to set up a WebGL context.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for Action: Creating an HTML5 Canvas Element</h1>
                
            
            
                
<p>A <kbd>canvas</kbd> is a rectangular element in your web page where your 3D scene will be rendered. Let's create a web page and add a HTML5 <kbd>canvas</kbd> element:</p>
<ol>
<li>Using your favorite editor, create a web page with the following code:</li>
</ol>
<div><pre style="padding-left: 60px">&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Real-Time 3D Graphics with WebGL2&lt;/title&gt;<br/>  &lt;link rel="shortcut icon" type="image/png" <br/>   href="/common/images/favicon.png" /&gt;<br/><br/>  &lt;style type="text/css"&gt;<br/>    canvas {<br/>      border: 5px dotted blue;<br/>    }<br/>  &lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/><br/>  &lt;canvas id="webgl-canvas" width="800" height="600"&gt;<br/>    Your browser does not support the HTML5 canvas element.<br/>  &lt;/canvas&gt;<br/><br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre></div>
<ol start="2">
<li>Save the file as <kbd>ch01_01_canvas.html</kbd>.</li>
<li>Open it with a supported browser.</li>
<li>You should see something similar to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5b67f2ff-df20-4e1d-b7ed-56d1b62cc618.png" style="width:30.50em;height:23.25em;"/></p>
<p class="mce-root"><em><strong>What just happened? </strong></em></p>
<p class="mce-root">We created a simple web page containing a <kbd>canvas</kbd> element. This <kbd>canvas</kbd> will contain our 3D application. Let's go very quickly over some relevant elements presented in this example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining a CSS Style</h1>
                
            
            
                
<p>This is the piece of code that determines the <kbd>canvas</kbd> style:</p>
<div><pre>&lt;style type="text/css"&gt;<br/>  canvas {<br/>    border: 5px dotted blue;<br/>  }<br/>&lt;/style&gt;</pre></div>
<p>This code is not fundamental to build a WebGL application. Given that the <kbd>canvas</kbd> element is initially empty, a blue-dotted border is a simple way to verify the location of the <kbd>canvas</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Canvas Attributes</h1>
                
            
            
                
<p>There are three attributes in our previous example:</p>
<ul>
<li><kbd>id</kbd>: This is the <kbd>canvas</kbd> identifier in the DOM.</li>
<li><kbd>width</kbd> and <kbd>height</kbd>: These two attributes determine the size of our <kbd>canvas</kbd> element. When these two attributes are missing, Firefox, Chrome, and WebKit will default to using <kbd>300px</kbd> by <kbd>150px</kbd>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What If Canvas Is Not Supported?</h1>
                
            
            
                
<p>If you see the following message on your screen, Your browser does not support the HTML5 canvas element (which is the message between the <kbd>&lt;canvas&gt;</kbd> tags), you need to make sure that you're using one of the supported web browsers described earlier.</p>
<p>If you're using Firefox and you still see this message, you may want to check whether WebGL is enabled (it is by <em>default</em>). To do so, go to Firefox and type <kbd>about:config</kbd> in the address bar. Then, look for the <kbd>webgl.disabled</kbd> property. If it is set to <kbd>true</kbd>, change it to <kbd>false</kbd>. When you restart Firefox and load <kbd>ch01_01_canvas.html</kbd>, you should be able to see the dotted border of the <kbd>canvas</kbd> element.</p>
<p>In the remote case that you still do not see <kbd>canvas</kbd>, it could be because your browser has blacklisted your GPU. If this is the case, please use a system with the appropriate hardware.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for Action: Accessing the WebGL Context</h1>
                
            
            
                
<p>A WebGL context is a handle (more strictly a JavaScript object) through which we can access WebGL functions and attributes. These available features constitute the WebGL API.</p>
<p>We are going to create a JavaScript function that will check whether a WebGL context can be obtained. Unlike other technologies that need to be downloaded into your project, WebGL is <em>already in your browser</em>. In other words, if you are using one of the supported browsers, you don't need to install or include any library.</p>
<p>Let's modify the previous example to add a JavaScript function to check the WebGL availability in your browser. This function is going to be called when the page has loaded. For this, we will use the standard DOM <kbd>onload</kbd> event:</p>
<ol>
<li>Open the <kbd>ch01_01_canvas.html</kbd> file in your favorite text editor.</li>
<li>Add the following code right below the closing <kbd>&lt;style&gt;</kbd> tag:</li>
</ol>
<div><pre style="padding-left: 60px">&lt;script type="text/javascript"&gt;<br/>  'use strict';<br/>  <br/>  function init() {<br/>    const canvas = document.getElementById('webgl-canvas');<br/><br/>    // Ensure we have a canvas<br/>    if (!canvas) {<br/>      console.error('Sorry! No HTML5 Canvas was found on <br/>       this page');<br/>      return;<br/>    }<br/><br/>    const gl = canvas.getContext('webgl2');<br/><br/>    // Ensure we have a context<br/>    const message = gl<br/>      ? 'Hooray! You got a WebGL2 context'<br/>      : 'Sorry! WebGL is not available';<br/><br/>    alert(message);<br/>  }<br/><br/>  // Call init once the document has loaded<br/>  window.onload = init;<br/>&lt;/script&gt;</pre></div>
<ol start="3">
<li>Save the file as <kbd>ch01_02_context.html</kbd>.</li>
<li>Open the <kbd>ch01_02_context.html</kbd> file using one of the WebGL 2 supported browsers.</li>
<li>If you can run WebGL 2, you will see a dialog similar to the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/507c43b1-14d5-4db6-b33a-2b3b5459ad76.png"/></p>
<p>Strict Mode<br/>
<br/>
The Strict Mode, declared by <kbd>'use strict';</kbd>, is a feature that allows you to place a program, or a function, in a "strict" operating context. This strict context prevents certain actions from being taken and throws more exceptions. For more information, please visit the following link: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode</a>.</p>
<p><em><strong>What just happened? </strong></em></p>
<p>Assigning a JavaScript variable (<kbd>gl</kbd>), we obtained a reference to a WebGL context. Let's go back and check the code that allows accessing WebGL:</p>
<div><pre>const gl = canvas.getContext('webgl2');</pre></div>
<p>The <kbd>canvas.getContext</kbd> method gives us access to WebGL. <kbd>getContext</kbd> also provides access to the HTML5 2D graphics library when using <kbd>2D</kbd> as the context name. The HTML5 2D graphics API is completely independent from WebGL and is beyond the scope of this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">State Machine</h1>
                
            
            
                
<p>A WebGL context can be understood as a state machine: once you modify attributes, the modifications persist until later modifications. At any point, you can query the state of these attributes to determine the current state of your WebGL context. Let's analyze this behavior with an example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for Action: Setting up WebGL Context Attributes</h1>
                
            
            
                
<p>In this example, we are going to learn to modify the color we use to clear the <kbd>canvas</kbd> element:</p>
<ol>
<li>Using your favorite text editor, open the <kbd>ch01_03_attributes.html</kbd> file:</li>
</ol>
<div><pre style="padding-left: 60px">&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Real-Time 3D Graphics with WebGL2&lt;/title&gt;<br/>  &lt;link rel="shortcut icon" type="image/png" <br/>   href="/common/images/favicon.png" /&gt;<br/><br/>  &lt;style&gt;<br/>    canvas {<br/>      border: 5px dotted blue;<br/>    }<br/>  &lt;/style&gt;<br/><br/>  &lt;script type="text/javascript"&gt;<br/>    'use strict';<br/><br/>    let gl;<br/><br/>    function updateClearColor(...color) {<br/>      // The ES6 spread operator (...) allows for us to<br/>      // use elements of an array as arguments to a function<br/>      gl.clearColor(...color);<br/>      gl.clear(gl.COLOR_BUFFER_BIT);<br/>      gl.viewport(0, 0, 0, 0);<br/>    }<br/><br/>    function checkKey(event) {<br/>      switch (event.keyCode) {<br/>        // number 1 =&gt; green<br/>        case 49: {<br/>          updateClearColor(0.2, 0.8, 0.2, 1.0);<br/>          break;<br/>        }<br/>        // number 2 =&gt; blue<br/>        case 50: {<br/>          updateClearColor(0.2, 0.2, 0.8, 1.0);<br/>          break;<br/>        }<br/>        // number 3 =&gt; random color<br/>        case 51: {<br/>          updateClearColor(Math.random(), Math.random(), <br/>           Math.random(), 1.0);<br/>          break;<br/>        }<br/>        // number 4 =&gt; get color<br/>        case 52: {<br/>          const color = gl.getParameter(gl.COLOR_CLEAR_VALUE);<br/>          // Don't let the following line confuse you.<br/>          // It basically rounds up the numbers to one<br/>          // decimal cipher for visualization purposes.<br/><br/>          // TIP: Given that WebGL's color space ranges<br/>          // from 0 to 1 you can multiply these values by 255<br/>          // to display in their RGB values.<br/>          alert(`clearColor = (<br/>            ${color[0].toFixed(1)},<br/>            ${color[1].toFixed(1)},<br/>            ${color[2].toFixed(1)}<br/>          )`);<br/>          window.focus();<br/>          break;<br/>        }<br/>      }<br/>    }<br/><br/>    function init() {<br/>      const canvas = document.getElementById('webgl-canvas');<br/><br/>      if (!canvas) {<br/>        console.error('Sorry! No HTML5 Canvas was found on this page');<br/>        return;<br/>      }<br/><br/>      gl = canvas.getContext('webgl2');<br/><br/>      const message = gl<br/>        ? 'Hooray! You got a WebGL2 context'<br/>        : 'Sorry! WebGL is not available';<br/><br/>      alert(message);<br/><br/>      // Call checkKey whenever a key is pressed<br/>      window.onkeydown = checkKey;<br/>    }<br/><br/>    window.onload = init;<br/>  &lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/><br/>  &lt;canvas id="webgl-canvas" width="800" height="600"&gt;<br/>    Your browser does not support the HTML5 canvas element.<br/>  &lt;/canvas&gt;<br/><br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre></div>
<ol start="2">
<li>You will see that this file is similar to our previous example. However, there are new code constructs that we will explain briefly. This file contains three JavaScript functions:</li>
</ol>
<table border="1" style="border-collapse: collapse;width: 100%;border-color: #000000">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign"><strong>Function</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>updateClearColor</kbd></td>
<td>Updates <kbd>clearColor</kbd> and then sets the <kbd>canvas</kbd> element clear color, which is one of the WebGL context attributes. As previously mentioned, WebGL works as a state machine. Therefore, it will maintain this color until it's changed using the <kbd>gl.clearColor</kbd> WebGL function (see the <kbd>checkKey</kbd> source code).</td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>checkKey</kbd></td>
<td>This is an auxiliary function that has been attached to the window <kbd>onkeydown</kbd> event. It captures the keyboard input and executes code depending on the key entered.</td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>init</kbd></td>
<td>This function gets called on the document <kbd>onload</kbd> event. It obtains a WebGL context and sets it to the global <kbd>gl</kbd> variable.</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>Open the <kbd>ch01_03_attributes.html</kbd> file in your browser.</li>
</ol>
<ol start="4">
<li>Press <em>1</em>. You will see how the <kbd>canvas</kbd> changes its color to green. If you want to query the exact color used, press <em>4</em>.</li>
<li>The <kbd>canvas</kbd> element will maintain the green color until we change it by calling <kbd>gl.clearColor</kbd>. Let's change it by pressing 2. If you look at the source code, this will change the <kbd>canvas</kbd> clear color to blue. If you want to know the exact color, press 4.</li>
<li>You can press <em>3</em><strong> </strong>to set the clear color to a random color. As before, you can get the color by pressing <em>4</em><em>:</em></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1dccfec1-da9e-4bda-bf30-ee51d860a267.png"/></p>
<p><em><strong>What just happened?</strong></em></p>
<p>In this example, we saw that we can change the color that WebGL uses to clear the <kbd>canvas</kbd> element by calling the <kbd>clearColor</kbd> function. Correspondingly, we used <kbd>getParameter(gl.COLOR_CLEAR_VALUE)</kbd> to obtain the current value of the <kbd>canvas</kbd> clear color.</p>
<p>Throughout this book, we will encounter similar constructs where specific functions establish attributes of the WebGL context while the <kbd>getParameter</kbd> function retrieves the current values for such attributes whenever the respective argument (in our example, <kbd>COLOR_CLEAR_VALUE</kbd>) is used.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Context to Access the WebGL API</h1>
                
            
            
                
<p>It is essential to note that all of the WebGL functions are accessed through the WebGL context. In our examples, the context is being held by the <kbd>gl</kbd> variable. Therefore, any call to the WebGL API will be performed using this variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading a 3D Scene</h1>
                
            
            
                
<p>So far, we have seen how to set up a <kbd>canvas</kbd> element and how to obtain a WebGL context; the next step is to discuss objects, lights, and cameras. But why wait to see what WebGL can do? In this section, we will take a quick peek at a simplified version of the final WebGL application that we'll be building in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Virtual Car Showroom</h1>
                
            
            
                
<p>Through this book, we will develop a virtual car showroom application using WebGL. At this point, we will load one simple scene into the <kbd>canvas</kbd> element. This scene will contain a car, some lights, and a camera.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for Action: Visualizing a 3D Showroom</h1>
                
            
            
                
<p>Once you finish reading this book, you will be able to create compelling 3D scenes such as the one we are going to play with next. This scene showcases one of the cars from this book's virtual car showroom:</p>
<ol start="1">
<li>Open the <kbd>ch01_04_showroom.html</kbd> file in your browser.</li>
</ol>
<ol start="2">
<li>You will see a WebGL scene with a car in it, as shown in the following screenshot. In the following chapters, we will cover geometry rendering and will see how to load and render various 3D models:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c3ee1235-04f7-45e7-be3d-02a71bf74ef7.png"/></p>
<ol start="3">
<li>Use the sliders to interactively update the four light sources that have been defined for this scene. Each light source has two elements: diffuse and specular elements. We have <a href="0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml">Chapter 3</a>, <em>Lights</em>, dedicated entirely to lights in a 3D scene.</li>
<li>Click and drag on <kbd>canvas</kbd> to rotate the car and visualize it from different perspectives. You can zoom by pressing the <em>Alt</em><strong> </strong>key while dragging the mouse on the <kbd>canvas</kbd>. You can also use the <em>arrow </em>keys to rotate the camera around the car. Make sure that <kbd>canvas</kbd> is in focus by clicking on it before using the <em>arrow</em> keys. In <a href="62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml">Chapter 4</a>, <em>Cameras</em>, we will discuss how to create and operate our own custom cameras in WebGL.</li>
<li>Use the color selector widget to change the color of the car. The use of colors in the scene will be discussed in detail later in this book.</li>
</ol>
<p><em><strong>What just happened?</strong></em></p>
<p>We have loaded a simple scene in a browser using WebGL. This scene consists of the following:</p>
<ul>
<li>A <kbd>canvas</kbd><strong> </strong>element<strong> </strong>through which we see the scene.</li>
<li>A series of polygonal meshes (<strong>objects</strong>) that constitute the car: roof, windows, headlights, fenders, doors, wheels, spoiler, bumpers, and so on.</li>
<li><strong>Light </strong>sources, otherwise everything would appear black.</li>
<li>A <strong>camera </strong>that determines where our viewpoint is in the 3D world. This camera is interactive where the viewpoint can change, depending on user input. For example, we used various keys and the mouse to move the camera around the car.</li>
</ul>
<p>There are many other elements in this scene such as textures, colors, and special light effects (specularity). Do not panic! We will explain each element throughout this book. The point here is to identify that the four basic elements we discussed previously are present in the scene. That said, feel free to examine the source code to get a sense of what's to come.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architecture Updates</h1>
                
            
            
                
<p>As we progress through chapters, we will encounter common functionality (for example, design patterns, utility functions, helpers, and data structures) that we can build upon. Not only this will serve us in writing <strong>DRY</strong> code, but it will also provide a useful architecture to support an advanced 3D WebGL application by the end of this book.</p>
<p>DRY<strong><br/>
<br/></strong> <strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>) is a software development principle, the main aim of which is to reduce repetition of code. <strong>Write Everything Twice</strong> (<strong>WET</strong>) is a cheeky abbreviation to mean the opposite— code that doesn't adhere to the DRY principle.<strong><br/></strong></p>
<p>Let's cover some changes that we will use in future chapters:</p>
<ol>
<li>Open <kbd>common/js/utils.js</kbd> in your editor to see the following code.</li>
<li>We will use <kbd>utils</kbd> to include many of the utility functions to serve us in building our 3D application. The two methods, <kbd>getCanvas</kbd> and <kbd>getGLContent</kbd>, inside of <kbd>utils</kbd> are similar to the code we've implemented earlier in this chapter:</li>
</ol>
<pre style="padding-left: 60px">'use strict';<br/><br/>// A set of utility functions for /common operations across our <br/>// application<br/>const utils = {<br/><br/>  // Find and return a DOM element given an ID<br/>  getCanvas(id) {<br/>    const canvas = document.getElementById(id);<br/><br/>    if (!canvas) {<br/>      console.error(`There is no canvas with id ${id} on this <br/>       page.`);<br/>      return null;<br/>    }<br/><br/>    return canvas;<br/>  },<br/><br/>  // Given a canvas element, return the WebGL2 context<br/>  getGLContext(canvas) {<br/>    return canvas.getContext('webgl2') || console.error('WebGL2 is <br/>     not available in your browser.');<br/>  }<br/><br/>};</pre>
<ol start="3">
<li><kbd>getCanvas</kbd> returns the <kbd>canvas</kbd> element with the provided <kbd>id</kbd> as the argument.</li>
<li><kbd>getGLContext</kbd> returns a WebGL 2 context for a given <kbd>canvas</kbd> element.</li>
<li>Open up <kbd>ch01_05_attributes-final.html</kbd> in your editor to see the following changes.</li>
<li>We've included <kbd>&lt;link rel="stylesheet" href="/common/lib/normalize.css"&gt;</kbd> in the <kbd>&lt;head&gt;</kbd> of our document that resets many of the inconsistencies across browsers. This is an external library to help us normalize CSS styling across browsers.</li>
<li>We've included <kbd>&lt;script type="text/javascript" src="img/utils.js"&gt;&lt;/script&gt;</kbd>.</li>
</ol>
<ol start="8">
<li>Scroll to the <kbd>init</kbd> function where the necessary changes were made to use the <kbd>utils.getCanvas</kbd> and <kbd>utils.getGLContext</kbd> functions:</li>
</ol>
<pre style="padding-left: 60px">function init() {<br/>  const canvas = utils.getCanvas('webgl-canvas');<br/>  gl = utils.getGLContext(canvas);<br/>  window.onkeydown = checkKey;<br/>}</pre>
<ol start="9">
<li>Open up <kbd>ch01_05_attributes-final.html</kbd> in a browser to see these changes in action.</li>
</ol>
<div><strong>Example Code Structure<br/>
<br/></strong> All example code has been structured so that common functionality is at the root of the directory ( <kbd>common/</kbd>), while examples for each chapter are categorized under chapter directories (for example, <kbd>ch01/</kbd>, <kbd>ch02/</kbd>, and <kbd>ch03/</kbd>). That being said, to view these examples in your browser, you will need to start a server at the root of the directory to load all required assets for each example. Please refer to the <a href="0761b7b6-811c-41b8-8345-601dfb43747e.xhtml"/><a href="0761b7b6-811c-41b8-8345-601dfb43747e.xhtml">Preface</a> of this book for more details.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<div><div><div><p>Let's summarize what we've learned in this chapter:</p>
</div>
</div>
</div>
<ul>
<li>We covered the history of WebGL and how it came to fruition.</li>
<li>We learned about common elements—<kbd>canvas</kbd>, objects, lights, and camera—that are, generally, present in WebGL applications.</li>
<li>We learned how to add a HTML5 <kbd>canvas</kbd> element to our web page and how to set its <kbd>id</kbd>, <kbd>width</kbd>, and <kbd>height</kbd>.</li>
<li>We implemented the code to obtain a WebGL context.</li>
<li>We covered how WebGL works as a state machine and, as such, we can query any of its variables using the <kbd>getParameter</kbd> function.</li>
<li>We got a glimpse of the interactive 3D application that we'll build by the end of this book.</li>
</ul>
<p>In the next chapter, we will learn how to define, load, and render objects into a WebGL scene.</p>


            

            
        
    </body></html>