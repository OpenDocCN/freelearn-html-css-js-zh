- en: Chapter 6. Changing Flux Store State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about the continuing evolution of our Flux stores, as the application
    features we implement drive architectural improvements. In fact, this is something
    Flux architectures excel at—adapting to changes influenced by the application
    as they happen. This chapter dives into changing the design of stores and hammers
    home the idea that stores will change often. Higher-level changes to our stores
    might be necessary, such as introducing generic stores that are shared by several
    other stores that target specific features. As stores evolve, so do the dependencies
    between them; we'll look at how to manage inter-store dependencies using the dispatcher.
    We'll close the chapter with a discussion on keeping store complexity at bay.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting to changing information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the book, I mentioned that stores aren't models from MV* architectures.
    They're different from a number of perspectives, including their ability to cope
    with changing schemas in other architectural areas, such as the API and changing
    feature requirements. In this section, we'll look at the Flux store's ability
    to adapt to changing APIs. We'll also address the opposite direction of change,
    when views that consume store data have changing requirements. Finally, we'll
    talk about other components that might change as the direct result of a store's
    ongoing evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Changing API data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: API data changes, especially during the early stages of development. Even though
    we tell ourselves that a given API is going to stabilize over time, this rarely
    works out in practice. Or if an API does become stable and unchanging, we end
    up having to use a different API. The safe assumption is that this data is going
    to change, and our stores will need to adapt to such changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beautiful part of Flux stores is the fact that they''re feature driven
    more than they''re API driven. This means that changes in API data have less of
    an impact on stores because their job is to transform the API data into information
    required by the feature. Here is a visualization of this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing API data](img/B05419_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike models, we're not trying to represent the API data in stores as is. Stores
    hold on to state that serves as information consumed by the features our customers
    use. This means that when changes happen in the API data that a given store depends
    on, we just have to revisit the transformation functions that create the feature
    information. On the other hand, models that are used by many different views in
    many different features of the application have a much harder time coping with
    API data changes such as these. It's because these components have dependencies
    with the schema of the API data, and not with the actual state that's relevant
    for the UI elements we need to render.
  prefs: []
  type: TYPE_NORMAL
- en: Can we always recreate the feature information that is used in our architecture
    after an API change has taken place? Not always. And this requires that we revisit
    how our views interact with the store. For example, if properties are removed
    entirely from a given API schema, this will likely require more than a simple
    transform update in our store. But this is a rare case; the most common case is
    that Flux stores can easily adapt to changing API data.
  prefs: []
  type: TYPE_NORMAL
- en: Changing feature functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stores change and evolve through changing API data. This can impact the information
    that''s available to the features that rely on the store. As our application grows,
    stores can feel pressure in the opposite direction—changing feature functionality
    often requires new information. This concept is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing feature functionality](img/B05419_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instead of the API data alone dictating what happens in the `transform()` function,
    it's the other way around. The feature and the information that drives it serve
    as input to the design of the store transformation. This can actually be more
    difficult than adapting to changing API data. There are two main reasons for this.
  prefs: []
  type: TYPE_NORMAL
- en: First, there's the information itself. The store can transform resources into
    whatever the feature needs. But stores aren't magical—the API data needs to provide
    at least the basic necessities in terms of data; otherwise, we're at a dead end.
    Second, there are the UI elements themselves, some of which have state that needs
    to be captured by the store. Combining these two factors can make for a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: It's good to get these difficult feature-related questions about information
    answered sooner rather than later. Being able to work in this direction means
    that we're letting the information that users care about drive the design, rather
    than letting the available API dictate what's possible.
  prefs: []
  type: TYPE_NORMAL
- en: Impacted components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw earlier in this section, stores transform their data sources into
    information that's consumable by user features. This is a great architectural
    characteristic of Flux, because it means that the views that listen to these stores
    aren't constantly having to change as a result of changes made to the API. We
    do, however, need to stay conscious of the impact to other components when stores
    evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about actions for a moment. When the API data changes, is this likely
    to result in new actions that we need to dispatch? No, because we're likely dealing
    with existing entry points into the system—these actions already exist. What about
    feature functionality—does this result in new actions? This is likely, because
    we could see new user interactivity introduced into a feature or new data and
    APIs. Existing action payloads can evolve as well, in response to changing UI
    elements, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Something else to consider is the effect a changing store has on other stores
    that depend on it. Will it still be able to get the information it needs after
    the change? Views aren't the only Flux components that have store dependencies.
    We'll look at inter-store dependencies in more depth later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing duplicate store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stores help us separate the state found in our architectures into features.
    This works out well because we can have drastically different data structures
    from one feature to the next. Alternatively, we could find that, as new features
    are introduced, a lot of the same data starts to appear in different stores. Nobody
    wants to repeat themselves—it's inefficient, and we can do better.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll introduce the notion of **generic stores**. These types
    of stores aren't necessarily used by views, but by other stores as a sort of repository
    for common data. We'll then walk through the basic setup of a generic store and
    how we can put generic stores to use in our more specialized stores.
  prefs: []
  type: TYPE_NORMAL
- en: Generic store data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generic stores are similar to parent classes in a class hierarchy. A parent
    class has the common behavior and properties found in several children. However,
    unlike class hierarchies, we don''t have several levels of structure. The aim
    of generic stores in Flux architectures is pretty simple—remove duplication where
    possible. Here is an illustration of a generic store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generic store data](img/B05419_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This allows for the state and transformations that are common to stores that
    serve specific features to share state that's also common. Otherwise, every update
    round will have to perform the same update on a different store. It's better to
    keep the update in one place to let stores query the generic store to compute
    their own state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to point out that specific stores don't actually inherit anything
    from generic stores in the way that a child class would inherit properties from
    its parent. Think of generic stores as instances, just like any other store. Also
    just like any other store, generic stores receive actions from the dispatcher
    to compute state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Registering generic stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With data dependencies, such as those we'll eventually find with the stores
    in our Flux architectures, order matters. For example, if a specific store is
    processed before a store that it depends on in an update round, we could end up
    with unexpected results. The generic store always needs to process actions first
    so that it has an opportunity to perform any transformations and set its state
    before any dependent stores access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. First, we''ll implement a generic store that takes
    a collection of document objects and maps it to a collection of document names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll implement a specific store that depends on this generic `Docs`
    store. It will be a specific document, which is used by a page that displays the
    name of the document. This store will have to locate the name based on the `id`
    property, in the generic store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's stop for a moment and think about what we've done here and why we're doing
    it. This generic `Docs` store implements a transformation that maps a collection
    of document data to an array of names. We're doing this because we have several
    other stores that need to look up a document name by `id`. If it were just the
    `Doc` store that needed this data, this would hardly be worth implementing. The
    idea is to reduce duplication, not to introduce indirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s take a look at an action creator function that both
    of these stores will listen to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this function takes a document `id` as a parameter and makes
    an asynchronous call to load all the documents. Once they''re loaded, the `LOAD_DOC`
    action is dispatched and the two stores can set their state. The challenge then
    becomes—how do we ensure that the generic store is updated before any stores that
    depend on it? Let''s take a look at the `main.js` module and see this action creator,
    along with the two stores, put to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When `loadDoc(2)` is called, the specific store gets its state set as we expect.
    This only works because of the order in which we're importing the two stores into
    `main.js`. In fact, if we were to swap the order, and import `docStore` before
    `docsStore`, then we wouldn't see the results we expect. The reason is simple—the
    order in which the stores are registered with the dispatcher determines the order
    in which they process actions. Later in the chapter, we'll look at a less cumbersome
    approach to handling store dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Combining generic and specific data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What''s nice about generic stores is that they can be used directly by views.
    That is, they''re not some abstract concept. These same stores can also be used
    by more specific stores to extend their data and transform their state into something
    that''s required by other views. Let''s look at an example where a specific store
    combines the state of a more general store with its own state. We''ll start by
    looking at a generic group''s store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There isn''t much going on here in the way of state transformation—the store
    just sets the payload as its state. Now, we''ll look at the more specific users
    store, which depends on the groups store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The state transformation that happens in this store is a little more involved.
    The `LOAD_USERS` payload is an array of user objects, each with a `group` property.
    However, the views that observe this store have a specific need for the name of
    the group, not the `id`. So, it is here that we perform the mapping that creates
    a new array of user objects, this one with the `groupName` property required by
    our views. Here''s a look at the `loadUsers()` action creator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s how we load the generic group''s data, followed by the users data
    which depends on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Generic store data like this is especially useful if it's used by plenty of
    other specific stores, and if its state doesn't change often. For example, loading
    this generic store data could be part of the application initialization activities,
    and it doesn't need to be touched after that.
  prefs: []
  type: TYPE_NORMAL
- en: Handling store dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we've treated our Flux store dependencies implicitly. The
    order in which we imported the store modules determined the order in which actions
    were handled, which has implications if something we depend on hasn't been updated
    yet. It's time to start treating our store dependencies with a little more rigor.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll introduce the `waitFor()` mechanism of the Flux dispatcher
    to manage store dependencies. Then, we'll talk about two types of store dependencies
    we might have. The first type of dependency is strictly related to application
    data. The second type of dependency is related to UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dispatcher has a built-in mechanism that allows us to explicitly resolve
    store dependencies. What''s more, dependencies are declared right in the callback
    function, where the dependency is actually used. Let''s look at an example that
    highlights the improved code for dealing with store dependencies. First, we have
    a basic store that doesn''t do much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice something about this store looks slightly different. We''re
    assigning the return value of `dispatcher.register()` to the `id` property of
    the store. This value is used to identify the callback function that we''ve just
    registered within the dispatcher. Now, let''s define a store that depends on this
    one so that we can see why this `id` property is relevant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `id` property is used by the call to `dispatcher.waitFor()`. This method
    of the dispatcher forces actions to be dispatched to the stores that we depend
    on before we continue with making state transformations. This ensures that we''re
    always working with the most up-to-date data in the stores that we depend on.
    Let''s see the `myAction()` function in use, and whether the dependency management
    between our two stores is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It no longer matters which order things happen in `main.js`, or anywhere else
    in the architecture for that matter. The dependency is declared where it matters,
    close to the code that's using the dependent data. This is enforced by the dispatcher
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `waitFor()` method accepts an array of IDs. This means that in
    more complex scenarios where we depend on the state of more than one store, we
    can pass in each store ID that we depend on. However, the more common case is
    to depend on the state of one store. If there are multi-store dependencies all
    over the architecture, it's a sign of too much complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Data dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two types of dependencies worth thinking about in Flux stores. The
    most common are data dependencies. This is the type of dependency in place when
    a specific store depends on a generic store—it has some generic data that several
    stores need to access. This application data usually comes from an API and is
    ultimately rendered by a view. However, we're not restricted to generic stores
    when we're talking about data dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say that we have a user interface and the main layout is
    separated by tabs. The stores in our Flux architecture are, unsurprisingly, aligned
    with these tabs. If one of these stores makes an API call, then performs some
    data transformations to set its state, can another store depend on this store
    to use this data? It would make sense to share data like this, otherwise, we'd
    have to repeat the same API request, data transforms, and so on—this gets repetitive
    and we'd like to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when stores that explicitly model top-level features such as tabs,
    we start to notice other dependencies that aren''t strictly data-related. These
    are UI dependencies, and it''s perfectly feasible to have these. For example,
    what the user sees in one tab could depend on the state of a checkbox in another
    tab. Here''s an illustration of the two types of store dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data dependencies](img/B05419_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: UI dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In typical frontend architectures, the state of UI elements is probably the
    single most error-prone aspect of state modeling. The main problem with UI elements
    is that when we don't explicitly model their states, we have a hard time grasping
    cause and effect when those states change. This gets particularly troublesome
    when the state of one UI element depends on the state of another UI element. We
    end up with code that implicitly ties these items together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux stores are better at dealing with this type of dependency because in a
    store, a UI dependency is the same as a data dependency—it''s all just state.
    It''s a good thing that we''re easily able to do this in Flux architectures, because
    these types of dependencies tend to grow complex rather quickly. To illustrate
    how Flux deals with UI dependencies, let''s look at an example. We''ll create
    two stores for different sections of the UI: one for checkboxes and one for labels.
    The idea is that the labels depend on the state of the checkboxes, because their
    style changes as the checkboxes change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the store representing the checkbox elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two checkbox elements modeled by this store—`first` and `second`.
    The state is Boolean, `true` when checked, `false` when unchecked. By default,
    both checkboxes are checked, and when either the `FIRST` or the `SECOND` actions
    are dispatched, the state of the respective checkbox is updated to reflect the
    payload. Now let''s look at the `Labels` store, which depends on the state of
    the `Checkboxes` store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that even the initial state of this store is dependent on the
    state of the `Checkboxes` store. The value of the `first` or `second` state properties
    in this store are actually CSS values. It's important that we model these values
    here, because this is state, after all—all state goes into a store. This means
    that later on something else can depend on these values. When everything is explicit,
    we know why the way things are the way they are, which translates to stable software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the views that use these stores to render the UI elements
    and to respond to user input. First, the `Checkboxes` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two checkbox elements used here, and the first thing that''s done
    in the view''s constructor is to set up the `change` event handlers for the checkboxes.
    These handlers will dispatch the appropriate action—`FIRST` or `SECOND`—depending
    on the checkbox and its checked state. The `render()` function actually updates
    the DOM based on the state. Now. let''s look at the `Labels` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This view works similarly to the `Checkboxes` view. The main differences are
    that there's no user interactivity here, and that the changes made to the UI elements
    are style property values that were set in the `Labels` store. These ultimately
    depend on the state of the `Checkboxes` store, so as the user changes the state
    of checkbox, they'll see the corresponding label change its style.
  prefs: []
  type: TYPE_NORMAL
- en: If this feels like a lot of code to accomplish something simple, that's because
    it is. Remember, we've actually accomplished a lot more here than a simple checkbox
    toggle and label style update. We've established explicit UI state dependencies
    between two different sections of the UI. This is a victory for our architecture,
    because the first moment a given architecture struggles to scale is when we can't
    figure out why something happens. Throughout the lifetime of a Flux architecture,
    we actively take steps to make sure this doesn't happen, as we've just demonstrated
    here.
  prefs: []
  type: TYPE_NORMAL
- en: View update order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's nice to be able to explicitly control the dependencies of our stores
    using `waitFor()`, views don't have such luxuries. In this section, we'll look
    at the order in which our views render UI elements. First, we'll look at the role
    stores have to play in the order of view updates. Then, we'll go over the cases
    where view order actually affects the user experience versus those where the ordering
    doesn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: Store registration order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The order in which actions are dispatched to stores matters. When a store transforms
    its state, it also notifies any views listening to the store. This means that
    if one view is listening to a store that was registered with the dispatcher first,
    this view will be rendered before any other views. The idea is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Store registration order](img/B05419_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the order of the store callback functions within the dispatcher
    clearly impacts the rendering order of views. Store dependencies can also impact
    the order of view rendering. For example, if store A depends on store B, then
    any views listening to store B will be rendered first. It could be that none of
    this matters or there could be some interesting side effects. We'll look at both
    outcomes next.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritizing view rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that the stores that form the core of our Flux architecture can also determine
    the render order of our views, we have to take care to prioritize according to
    user experience. For example, we could have a store that represents the top header
    area of the page and another store that's for the main content area. Now, if the
    main content area renders first, leaving a noticeable gap near the top of the
    page, we'll want to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing as how users will start at the top of the page and work their way down,
    we would have to make sure that the store for the header content is registered
    first. How do we do this? Once again, we're back to where we were when dealing
    with store dependencies. We have to take care to import our views in the correct
    order—an order that reflects the rendering order. As we saw with stores, this
    isn't an ideal situation to be in.
  prefs: []
  type: TYPE_NORMAL
- en: One answer is to introduce a store dependency. Even though the content store
    doesn't actually use any data from the header store, it could still depend on
    it for render ordering purposes. By using the `waitFor()` method, we'd know that
    any views that listen to the header store will be rendered first, eliminating
    the possibility of usability issues related to render order. The risk here, of
    course, is the same as any store dependency—complexity. When we reach the point
    where there are too many store dependencies to easily comprehend, it's time to
    rethink our store design.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with store complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The leading culprit of Flux store complexity is dependency management. Despite
    having the dispatcher as a tool to manage these dependencies, something is lost
    when there's too many of them. In this final section of the chapter, we'll discuss
    the consequences of having too many stores in our architecture and what can be
    done to remedy the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Too many stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The top-level features of our application do a decent job of providing a boundary
    for our stores and the state that they encapsulate. The challenge with stores
    is when there are too many of them. For example, as our applications grow over
    time, more features will be built which translates to more stores being tossed
    into the architecture. Additionally, the stores that already exist are apt to
    grow more complex as well, as they have to find ways to get along with all the
    other changing features of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This makes for a complex scenario—growing complexity in stores and more stores
    overall. This almost certainly will lead to an explosion in dependencies, as we
    tease out all the edge cases of our user interface. Generic stores that are shared
    by many other specific stores can also be a source of trouble. For example, we
    could end up with way too many generic stores, eventually getting to the point
    where all our state data is indirect.
  prefs: []
  type: TYPE_NORMAL
- en: When we've reached the point where the sheer number of stores in our architecture
    is untenable, it's time to start rethinking what constitutes a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Rethinking feature domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having top-level features map to our stores generally works well enough, until
    we have a lot of top-level features. At this point, it''s time to re-evaluate
    the policy that a feature maps to a store. For example, if we have a lot of top-level
    features, odds are that there''s a lot of similar data that could be folded into
    a single store that drives many features. Another potential effect of reducing
    the number of stores that power our features is the removal of generic stores.
    Generic stores are only good if we have too much duplicate data, which tends to
    be less of a problem when the number of stores shrinks. Here is a diagram that
    shows how a store could be the driver of more than one feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rethinking feature domains](img/B05419_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We might find ourselves in the opposite situation as well, whereby a store's
    complexity is simply too great, and we need to reduce its responsibilities by
    refactoring it into multiple stores. To fix this, we have to think about how one
    large feature can be turned into two smaller features. If we can't think of a
    good way to divide the feature, then maybe the complexity of the store is the
    best we can do, and it should be left alone.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a detailed look at stores in Flux architectures, starting
    with the aspects that are most likely to change once we've moved on from the skeleton
    architecture phase. We then introduced the notion of generic stores, the idea
    being to reduce the amount of state that individual stores have to keep. The awkward
    part of generic stores are the dependencies that they introduce, and to deal with
    them, you learned how to use the dispatcher's `waitFor()` mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies between stores come in two varieties, data dependencies and UI
    dependencies, and you learned that UI dependencies are a critical part of any
    Flux architecture. Finally, we discussed some of the ways that stores can grow
    out of hand in terms of complexity, and what can be done about it. In the following
    chapter, we'll look at view components in Flux architectures.
  prefs: []
  type: TYPE_NORMAL
