- en: Chapter 6. Changing Flux Store State
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。改变Flux存储状态
- en: This chapter is about the continuing evolution of our Flux stores, as the application
    features we implement drive architectural improvements. In fact, this is something
    Flux architectures excel at—adapting to changes influenced by the application
    as they happen. This chapter dives into changing the design of stores and hammers
    home the idea that stores will change often. Higher-level changes to our stores
    might be necessary, such as introducing generic stores that are shared by several
    other stores that target specific features. As stores evolve, so do the dependencies
    between them; we'll look at how to manage inter-store dependencies using the dispatcher.
    We'll close the chapter with a discussion on keeping store complexity at bay.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲述了我们Flux存储的持续进化，因为我们所实现的应用功能推动了架构的改进。事实上，这正是Flux架构擅长的——随着应用的变化而适应变化。本章深入探讨了存储设计的改变，并强调了存储将经常发生变化的观点。对我们存储的更高层次改变可能是必要的，例如引入由多个其他存储共享的通用存储，这些存储针对特定的功能。随着存储的进化，它们之间的依赖关系也会发生变化；我们将探讨如何使用分发器来管理存储间的依赖关系。我们将以讨论如何控制存储复杂性来结束本章。
- en: Adapting to changing information
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应变化的信息
- en: Earlier in the book, I mentioned that stores aren't models from MV* architectures.
    They're different from a number of perspectives, including their ability to cope
    with changing schemas in other architectural areas, such as the API and changing
    feature requirements. In this section, we'll look at the Flux store's ability
    to adapt to changing APIs. We'll also address the opposite direction of change,
    when views that consume store data have changing requirements. Finally, we'll
    talk about other components that might change as the direct result of a store's
    ongoing evolution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我提到存储不是MV*架构中的模型。它们在多个方面都不同，包括它们处理其他架构领域（如API和变化的功能需求）中变化模式的能力。在本节中，我们将探讨Flux存储适应变化API的能力。我们还将讨论变化的相反方向，即当消耗存储数据的视图有变化需求时。最后，我们将讨论其他可能作为存储持续进化的直接结果的组件发生变化。
- en: Changing API data
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变API数据
- en: API data changes, especially during the early stages of development. Even though
    we tell ourselves that a given API is going to stabilize over time, this rarely
    works out in practice. Or if an API does become stable and unchanging, we end
    up having to use a different API. The safe assumption is that this data is going
    to change, and our stores will need to adapt to such changes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: API数据的变化，尤其是在开发的早期阶段。尽管我们告诉自己，某个API将随着时间的推移而稳定下来，但在实践中这很少奏效。或者，如果API确实变得稳定且不变，我们最终不得不使用不同的API。安全的假设是，这些数据将会变化，我们的存储将需要适应这些变化。
- en: 'The beautiful part of Flux stores is the fact that they''re feature driven
    more than they''re API driven. This means that changes in API data have less of
    an impact on stores because their job is to transform the API data into information
    required by the feature. Here is a visualization of this idea:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Flux存储的美丽之处在于它们更多地由功能驱动，而不是由API驱动。这意味着API数据的变化对存储的影响较小，因为它们的任务是转换API数据为功能所需的信息。以下是这个想法的可视化：
- en: '![Changing API data](img/B05419_06_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![改变API数据](img/B05419_06_01.jpg)'
- en: Unlike models, we're not trying to represent the API data in stores as is. Stores
    hold on to state that serves as information consumed by the features our customers
    use. This means that when changes happen in the API data that a given store depends
    on, we just have to revisit the transformation functions that create the feature
    information. On the other hand, models that are used by many different views in
    many different features of the application have a much harder time coping with
    API data changes such as these. It's because these components have dependencies
    with the schema of the API data, and not with the actual state that's relevant
    for the UI elements we need to render.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与模型不同，我们并不是试图将API数据原封不动地表示在存储中。存储保留着状态，这些状态是客户使用的功能所消耗的信息。这意味着当特定存储所依赖的API数据发生变化时，我们只需重新审视创建特征信息的转换函数。另一方面，被应用中许多不同视图和许多不同功能使用的模型在应对这些API数据变化时则更加困难。这是因为这些组件与API数据的模式有关，而不是与我们需要渲染的UI元素相关的实际状态。
- en: Can we always recreate the feature information that is used in our architecture
    after an API change has taken place? Not always. And this requires that we revisit
    how our views interact with the store. For example, if properties are removed
    entirely from a given API schema, this will likely require more than a simple
    transform update in our store. But this is a rare case; the most common case is
    that Flux stores can easily adapt to changing API data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在API更改发生后，我们是否总能重新创建我们在架构中使用的功能信息？不一定。这需要我们重新审视我们的视图如何与存储交互。例如，如果某个API模式中完全删除了属性，这很可能会要求我们在存储中进行比简单转换更新更复杂的更新。但这是一种罕见的情况；最常见的情况是，Flux存储可以轻松适应变化的API数据。
- en: Changing feature functionality
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变功能功能
- en: 'Stores change and evolve through changing API data. This can impact the information
    that''s available to the features that rely on the store. As our application grows,
    stores can feel pressure in the opposite direction—changing feature functionality
    often requires new information. This concept is illustrated in the following diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 存储通过变化的API数据发生变化和演变。这可能会影响依赖于存储的功能可用的信息。随着我们的应用程序的增长，存储可能会面临相反方向的压力——改变功能功能通常需要新的信息。这个概念在以下图中得到了说明：
- en: '![Changing feature functionality](img/B05419_06_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![改变功能功能](img/B05419_06_02.jpg)'
- en: Instead of the API data alone dictating what happens in the `transform()` function,
    it's the other way around. The feature and the information that drives it serve
    as input to the design of the store transformation. This can actually be more
    difficult than adapting to changing API data. There are two main reasons for this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不是API数据单独决定`transform()`函数中发生什么，而是相反。功能和驱动它的信息作为存储转换设计的设计输入。这实际上可能比适应变化的API数据更困难。有两个主要原因。
- en: First, there's the information itself. The store can transform resources into
    whatever the feature needs. But stores aren't magical—the API data needs to provide
    at least the basic necessities in terms of data; otherwise, we're at a dead end.
    Second, there are the UI elements themselves, some of which have state that needs
    to be captured by the store. Combining these two factors can make for a challenge.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是信息本身。存储可以将资源转换为功能所需的内容。但存储并不是神奇的——API数据需要在数据方面提供至少基本需求；否则，我们就会陷入死胡同。其次，还有UI元素本身，其中一些需要存储来捕获状态。结合这两个因素可能会带来挑战。
- en: It's good to get these difficult feature-related questions about information
    answered sooner rather than later. Being able to work in this direction means
    that we're letting the information that users care about drive the design, rather
    than letting the available API dictate what's possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最好尽早而不是晚些时候回答这些关于信息的困难功能相关问题。能够朝这个方向工作意味着我们正在让用户关心的信息驱动设计，而不是让可用的API决定可能发生的事情。
- en: Impacted components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受影响的组件
- en: As we saw earlier in this section, stores transform their data sources into
    information that's consumable by user features. This is a great architectural
    characteristic of Flux, because it means that the views that listen to these stores
    aren't constantly having to change as a result of changes made to the API. We
    do, however, need to stay conscious of the impact to other components when stores
    evolve.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节前面所看到的，存储将它们的数据源转换为用户功能可消费的信息。这是Flux的一个很好的架构特性，因为它意味着监听这些存储的视图不需要不断改变，以适应对API所做的更改。然而，当存储演变时，我们需要保持对其他组件影响的警觉。
- en: Let's think about actions for a moment. When the API data changes, is this likely
    to result in new actions that we need to dispatch? No, because we're likely dealing
    with existing entry points into the system—these actions already exist. What about
    feature functionality—does this result in new actions? This is likely, because
    we could see new user interactivity introduced into a feature or new data and
    APIs. Existing action payloads can evolve as well, in response to changing UI
    elements, for example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时思考一下动作。当API数据发生变化时，这很可能会产生我们需要分派的新动作吗？不，因为我们很可能会处理现有的系统入口点——这些动作已经存在。关于功能功能，这会导致新的动作吗？这是可能的，因为我们可能会看到新的用户交互被引入到功能中，或者新的数据和API。现有的动作有效载荷也可以随着响应变化的UI元素而演变，例如。
- en: Something else to consider is the effect a changing store has on other stores
    that depend on it. Will it still be able to get the information it needs after
    the change? Views aren't the only Flux components that have store dependencies.
    We'll look at inter-store dependencies in more depth later in the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的是，存储变化对依赖于它的其他存储的影响。变化后，它是否还能获取所需的信息？视图并不是唯一具有存储依赖的Flux组件。我们将在本章后面更深入地探讨存储间的依赖关系。
- en: Reducing duplicate store data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少重复存储数据
- en: Stores help us separate the state found in our architectures into features.
    This works out well because we can have drastically different data structures
    from one feature to the next. Alternatively, we could find that, as new features
    are introduced, a lot of the same data starts to appear in different stores. Nobody
    wants to repeat themselves—it's inefficient, and we can do better.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 存储帮助我们将架构中找到的状态分离成特性。这很好，因为我们可以在不同的特性之间有截然不同的数据结构。或者，我们可能会发现，随着新特性的引入，大量相同的数据开始出现在不同的存储中。没有人愿意重复自己——这是低效的，我们可以做得更好。
- en: In this section, we'll introduce the notion of **generic stores**. These types
    of stores aren't necessarily used by views, but by other stores as a sort of repository
    for common data. We'll then walk through the basic setup of a generic store and
    how we can put generic stores to use in our more specialized stores.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍**通用存储**的概念。这类存储不一定被视图使用，而是由其他存储作为公共数据的一种存储库。然后我们将介绍通用存储的基本设置以及如何在我们的更专业化的存储中使用通用存储。
- en: Generic store data
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用存储数据
- en: 'Generic stores are similar to parent classes in a class hierarchy. A parent
    class has the common behavior and properties found in several children. However,
    unlike class hierarchies, we don''t have several levels of structure. The aim
    of generic stores in Flux architectures is pretty simple—remove duplication where
    possible. Here is an illustration of a generic store:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通用存储类似于类层次结构中的父类。父类具有在多个子类中找到的常见行为和属性。然而，与类层次结构不同，我们没有多个结构层级。通用存储在Flux架构中的目标相当简单——尽可能减少重复。以下是一个通用存储的示例：
- en: '![Generic store data](img/B05419_06_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![通用存储数据](img/B05419_06_03.jpg)'
- en: This allows for the state and transformations that are common to stores that
    serve specific features to share state that's also common. Otherwise, every update
    round will have to perform the same update on a different store. It's better to
    keep the update in one place to let stores query the generic store to compute
    their own state.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许具有特定功能的服务存储共享也通用的状态。否则，每个更新轮次都不得不在不同的存储上执行相同的更新。最好将更新保留在一个地方，让存储查询通用存储以计算它们自己的状态。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to point out that specific stores don't actually inherit anything
    from generic stores in the way that a child class would inherit properties from
    its parent. Think of generic stores as instances, just like any other store. Also
    just like any other store, generic stores receive actions from the dispatcher
    to compute state changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，特定存储实际上并没有从通用存储那里继承任何东西，就像子类从其父类继承属性一样。将通用存储视为实例，就像任何其他存储一样。同样，就像任何其他存储一样，通用存储会从分发器接收动作来计算状态变化。
- en: Registering generic stores
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册通用存储
- en: With data dependencies, such as those we'll eventually find with the stores
    in our Flux architectures, order matters. For example, if a specific store is
    processed before a store that it depends on in an update round, we could end up
    with unexpected results. The generic store always needs to process actions first
    so that it has an opportunity to perform any transformations and set its state
    before any dependent stores access it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据依赖方面，例如我们最终将在我们的Flux架构中的存储中找到的依赖，顺序很重要。例如，如果一个特定存储在更新轮次中先于它所依赖的存储被处理，我们可能会得到意外的结果。通用存储始终需要首先处理动作，以便它有机会在任何依赖存储访问它之前执行任何转换并设置其状态。
- en: 'Let''s look at an example. First, we''ll implement a generic store that takes
    a collection of document objects and maps it to a collection of document names:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。首先，我们将实现一个通用存储，它接受一组文档对象并将其映射到一组文档名称：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll implement a specific store that depends on this generic `Docs`
    store. It will be a specific document, which is used by a page that displays the
    name of the document. This store will have to locate the name based on the `id`
    property, in the generic store:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个依赖于这个通用`Docs`存储库的特定存储库。它将是一个特定的文档，用于显示文档名称的页面。这个存储库将必须根据通用存储库中的`id`属性定位名称：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's stop for a moment and think about what we've done here and why we're doing
    it. This generic `Docs` store implements a transformation that maps a collection
    of document data to an array of names. We're doing this because we have several
    other stores that need to look up a document name by `id`. If it were just the
    `Doc` store that needed this data, this would hardly be worth implementing. The
    idea is to reduce duplication, not to introduce indirection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停下来思考一下我们在这里做了什么，以及我们为什么要这样做。这个通用的`Docs`存储库实现了一个转换，将文档数据集合映射到名称数组。我们之所以这样做，是因为我们还有几个其他存储库需要通过`id`查找文档名称。如果只有`Doc`存储库需要这些数据，那么这几乎不值得实现。我们的想法是减少重复，而不是引入间接性。
- en: 'With that said, let''s take a look at an action creator function that both
    of these stores will listen to:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们看看这两个存储库都会监听的动作创建函数：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, this function takes a document `id` as a parameter and makes
    an asynchronous call to load all the documents. Once they''re loaded, the `LOAD_DOC`
    action is dispatched and the two stores can set their state. The challenge then
    becomes—how do we ensure that the generic store is updated before any stores that
    depend on it? Let''s take a look at the `main.js` module and see this action creator,
    along with the two stores, put to work:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数接受一个文档`id`作为参数，并异步调用以加载所有文档。一旦加载完成，就会分发`LOAD_DOC`动作，两个存储库可以设置它们的状态。那么挑战就变成了——我们如何确保在依赖于它的任何存储库之前更新通用存储库？让我们看看`main.js`模块，看看这个动作创建函数以及两个存储库是如何被投入使用的：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When `loadDoc(2)` is called, the specific store gets its state set as we expect.
    This only works because of the order in which we're importing the two stores into
    `main.js`. In fact, if we were to swap the order, and import `docStore` before
    `docsStore`, then we wouldn't see the results we expect. The reason is simple—the
    order in which the stores are registered with the dispatcher determines the order
    in which they process actions. Later in the chapter, we'll look at a less cumbersome
    approach to handling store dependencies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`loadDoc(2)`时，特定存储库的状态设置正如我们所期望的那样。这仅仅是因为我们将两个存储库导入`main.js`的顺序。实际上，如果我们交换顺序，在导入`docStore`之前导入`docsStore`，那么我们就不会看到我们期望的结果。原因是简单的——存储库注册到调度器的顺序决定了它们处理动作的顺序。在本章的后面，我们将探讨一种处理存储库依赖关系不那么繁琐的方法。
- en: Combining generic and specific data
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合通用和特定数据
- en: 'What''s nice about generic stores is that they can be used directly by views.
    That is, they''re not some abstract concept. These same stores can also be used
    by more specific stores to extend their data and transform their state into something
    that''s required by other views. Let''s look at an example where a specific store
    combines the state of a more general store with its own state. We''ll start by
    looking at a generic group''s store:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通用存储库的优点是它们可以直接由视图使用。也就是说，它们不是某种抽象概念。这些相同的存储库也可以由更具体的存储库使用，以扩展它们的数据并将它们的州转换成其他视图所需的东西。让我们看看一个特定存储库如何将更通用存储库的状态与其自己的状态结合的例子。我们将首先查看一个通用组存储库：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There isn''t much going on here in the way of state transformation—the store
    just sets the payload as its state. Now, we''ll look at the more specific users
    store, which depends on the groups store:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态转换方面，这里并没有太多的事情发生——存储库只是将有效载荷设置为它的状态。现在，我们将看看更具体的用户存储库，它依赖于组存储库：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The state transformation that happens in this store is a little more involved.
    The `LOAD_USERS` payload is an array of user objects, each with a `group` property.
    However, the views that observe this store have a specific need for the name of
    the group, not the `id`. So, it is here that we perform the mapping that creates
    a new array of user objects, this one with the `groupName` property required by
    our views. Here''s a look at the `loadUsers()` action creator function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个存储库中发生的状态转换要复杂一些。`LOAD_USERS`有效载荷是一个用户对象的数组，每个对象都有一个`group`属性。然而，观察这个存储库的视图需要的是组名，而不是`id`。因此，在这里我们执行映射，创建一个新的用户对象数组，这个数组包含视图所需的`groupName`属性。下面是`loadUsers()`动作创建函数的示例：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here''s how we load the generic group''s data, followed by the users data
    which depends on it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是如何加载通用组的数据，然后是依赖于它的用户数据的：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Generic store data like this is especially useful if it's used by plenty of
    other specific stores, and if its state doesn't change often. For example, loading
    this generic store data could be part of the application initialization activities,
    and it doesn't need to be touched after that.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的通用存储数据如果被许多其他特定存储使用，并且其状态不经常改变，特别有用。例如，加载这个通用存储数据可能是应用程序初始化活动的一部分，之后就不需要再接触它了。
- en: Handling store dependencies
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理存储依赖
- en: So far in this book, we've treated our Flux store dependencies implicitly. The
    order in which we imported the store modules determined the order in which actions
    were handled, which has implications if something we depend on hasn't been updated
    yet. It's time to start treating our store dependencies with a little more rigor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们隐式地处理了我们的 Flux 存储依赖。我们导入存储模块的顺序决定了处理动作的顺序，如果我们所依赖的东西还没有更新，这会有影响。是时候开始用更多的严谨性来处理我们的存储依赖了。
- en: In this section, we'll introduce the `waitFor()` mechanism of the Flux dispatcher
    to manage store dependencies. Then, we'll talk about two types of store dependencies
    we might have. The first type of dependency is strictly related to application
    data. The second type of dependency is related to UI elements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Flux 调度器的 `waitFor()` 机制来管理存储依赖。然后，我们将讨论我们可能遇到的两种存储依赖类型。第一种依赖严格相关于应用程序数据。第二种依赖与
    UI 元素相关。
- en: Waiting for stores
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待存储
- en: 'The dispatcher has a built-in mechanism that allows us to explicitly resolve
    store dependencies. What''s more, dependencies are declared right in the callback
    function, where the dependency is actually used. Let''s look at an example that
    highlights the improved code for dealing with store dependencies. First, we have
    a basic store that doesn''t do much:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器有一个内置机制，允许我们显式解决存储依赖。更重要的是，依赖在回调函数中声明，即依赖实际被使用的地方。让我们看看一个突出显示处理存储依赖改进代码的例子。首先，我们有一个基本的存储，它没有做太多：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You''ll notice something about this store looks slightly different. We''re
    assigning the return value of `dispatcher.register()` to the `id` property of
    the store. This value is used to identify the callback function that we''ve just
    registered within the dispatcher. Now, let''s define a store that depends on this
    one so that we can see why this `id` property is relevant:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个存储看起来略有不同。我们将 `dispatcher.register()` 的返回值分配给存储的 `id` 属性。这个值用于识别我们在调度器中刚刚注册的回调函数。现在，让我们定义一个依赖于这个存储的存储，这样我们就可以看到为什么这个
    `id` 属性是相关的：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `id` property is used by the call to `dispatcher.waitFor()`. This method
    of the dispatcher forces actions to be dispatched to the stores that we depend
    on before we continue with making state transformations. This ensures that we''re
    always working with the most up-to-date data in the stores that we depend on.
    Let''s see the `myAction()` function in use, and whether the dependency management
    between our two stores is working as expected:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 属性被 `dispatcher.waitFor()` 调用所使用。这个调度器的这个方法强制在继续进行状态转换之前，将动作分发给我们所依赖的存储。这确保了我们始终在依赖的存储中使用最新数据。让我们看看
    `myAction()` 函数的使用情况，以及我们两个存储之间的依赖管理是否按预期工作：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It no longer matters which order things happen in `main.js`, or anywhere else
    in the architecture for that matter. The dependency is declared where it matters,
    close to the code that's using the dependent data. This is enforced by the dispatcher
    component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.js` 中，或者架构中的任何其他地方，事情发生的顺序不再重要。依赖在它重要的地方声明，靠近使用依赖数据的代码。这是由调度器组件强制执行的。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `waitFor()` method accepts an array of IDs. This means that in
    more complex scenarios where we depend on the state of more than one store, we
    can pass in each store ID that we depend on. However, the more common case is
    to depend on the state of one store. If there are multi-store dependencies all
    over the architecture, it's a sign of too much complexity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`waitFor()` 方法接受一个 ID 数组。这意味着在更复杂的场景中，如果我们依赖于多个存储的状态，我们可以传递我们依赖的每个存储 ID。然而，更常见的情况是依赖于一个存储的状态。如果架构中到处都是多存储依赖，这可能意味着复杂性过高。
- en: Data dependencies
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据依赖
- en: There are two types of dependencies worth thinking about in Flux stores. The
    most common are data dependencies. This is the type of dependency in place when
    a specific store depends on a generic store—it has some generic data that several
    stores need to access. This application data usually comes from an API and is
    ultimately rendered by a view. However, we're not restricted to generic stores
    when we're talking about data dependencies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flux 存储中，有两种值得思考的依赖类型。最常见的是数据依赖。当特定存储依赖于通用存储时，就存在这种依赖关系——它有一些通用数据，多个存储需要访问。这种应用程序数据通常来自
    API，并最终由视图渲染。然而，当我们谈论数据依赖时，并不局限于通用存储。
- en: For example, let's say that we have a user interface and the main layout is
    separated by tabs. The stores in our Flux architecture are, unsurprisingly, aligned
    with these tabs. If one of these stores makes an API call, then performs some
    data transformations to set its state, can another store depend on this store
    to use this data? It would make sense to share data like this, otherwise, we'd
    have to repeat the same API request, data transforms, and so on—this gets repetitive
    and we'd like to avoid it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个用户界面，主布局通过标签页进行分隔。在我们的 Flux 架构中，存储与这些标签页一致。如果一个存储执行 API 调用，然后进行一些数据转换以设置其状态，另一个存储可以依赖这个存储来使用这些数据吗？共享此类数据是有意义的，否则，我们不得不重复相同的
    API 请求、数据转换等等——这会变得重复且我们希望避免这种情况。
- en: 'However, when stores that explicitly model top-level features such as tabs,
    we start to notice other dependencies that aren''t strictly data-related. These
    are UI dependencies, and it''s perfectly feasible to have these. For example,
    what the user sees in one tab could depend on the state of a checkbox in another
    tab. Here''s an illustration of the two types of store dependencies:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当存储明确建模顶级功能，如标签页时，我们开始注意到一些并非严格与数据相关的其他依赖。这些是 UI 依赖，并且完全可能存在。例如，用户在一个标签页中看到的内容可能依赖于另一个标签页中复选框的状态。以下是两种存储依赖类型的说明：
- en: '![Data dependencies](img/B05419_06_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![数据依赖](img/B05419_06_04.jpg)'
- en: UI dependencies
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI 依赖
- en: In typical frontend architectures, the state of UI elements is probably the
    single most error-prone aspect of state modeling. The main problem with UI elements
    is that when we don't explicitly model their states, we have a hard time grasping
    cause and effect when those states change. This gets particularly troublesome
    when the state of one UI element depends on the state of another UI element. We
    end up with code that implicitly ties these items together.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的前端架构中，UI 元素的状态可能是状态建模中最容易出错的部分。UI 元素的主要问题是，当我们没有明确建模它们的状态时，当这些状态发生变化时，我们很难理解因果关系。当一个
    UI 元素的状态依赖于另一个 UI 元素的状态时，这尤其麻烦。我们最终得到的是将这些项目隐式关联在一起的代码。
- en: 'Flux stores are better at dealing with this type of dependency because in a
    store, a UI dependency is the same as a data dependency—it''s all just state.
    It''s a good thing that we''re easily able to do this in Flux architectures, because
    these types of dependencies tend to grow complex rather quickly. To illustrate
    how Flux deals with UI dependencies, let''s look at an example. We''ll create
    two stores for different sections of the UI: one for checkboxes and one for labels.
    The idea is that the labels depend on the state of the checkboxes, because their
    style changes as the checkboxes change.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 存储在处理此类依赖关系方面更胜一筹，因为在存储中，UI 依赖与数据依赖相同——它们都是状态。我们能够轻松地在 Flux 架构中做到这一点是个好事，因为这些类型的依赖关系往往会迅速变得复杂。为了说明
    Flux 如何处理 UI 依赖，让我们来看一个例子。我们将为 UI 的不同部分创建两个存储：一个用于复选框，一个用于标签。其理念是标签依赖于复选框的状态，因为当复选框改变时，它们的样式也会改变。
- en: 'First, we have the store representing the checkbox elements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有代表复选框元素的存储：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are two checkbox elements modeled by this store—`first` and `second`.
    The state is Boolean, `true` when checked, `false` when unchecked. By default,
    both checkboxes are checked, and when either the `FIRST` or the `SECOND` actions
    are dispatched, the state of the respective checkbox is updated to reflect the
    payload. Now let''s look at the `Labels` store, which depends on the state of
    the `Checkboxes` store:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该存储通过两个复选框元素进行建模——`first` 和 `second`。状态是布尔值，选中时为 `true`，未选中时为 `false`。默认情况下，两个复选框都被选中，当
    `FIRST` 或 `SECOND` 动作被分发时，相应复选框的状态会更新以反映有效载荷。现在让我们看看依赖于 `Checkboxes` 存储状态的 `Labels`
    存储：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see here that even the initial state of this store is dependent on the
    state of the `Checkboxes` store. The value of the `first` or `second` state properties
    in this store are actually CSS values. It's important that we model these values
    here, because this is state, after all—all state goes into a store. This means
    that later on something else can depend on these values. When everything is explicit,
    we know why the way things are the way they are, which translates to stable software.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个存储的初始状态实际上也依赖于`Checkboxes`存储的状态。这个存储中`first`或`second`状态属性的值实际上是CSS值。在这里对这些值进行建模很重要，因为毕竟，这些都是状态——所有状态都进入存储。这意味着以后其他东西可以依赖于这些值。当一切都很明确时，我们知道事情为什么会是这样，这转化为稳定的软件。
- en: 'Now, let''s look at the views that use these stores to render the UI elements
    and to respond to user input. First, the `Checkboxes` view:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用这些存储来渲染UI元素和响应用户输入的视图。首先，是`Checkboxes`视图：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are two checkbox elements used here, and the first thing that''s done
    in the view''s constructor is to set up the `change` event handlers for the checkboxes.
    These handlers will dispatch the appropriate action—`FIRST` or `SECOND`—depending
    on the checkbox and its checked state. The `render()` function actually updates
    the DOM based on the state. Now. let''s look at the `Labels` view:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了两个复选框元素，在视图的构造函数中做的第一件事是为复选框设置`change`事件处理器。这些处理器将根据复选框及其选中状态分派适当的操作——`FIRST`或`SECOND`。`render()`函数实际上根据状态更新DOM。现在，让我们看看`Labels`视图：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This view works similarly to the `Checkboxes` view. The main differences are
    that there's no user interactivity here, and that the changes made to the UI elements
    are style property values that were set in the `Labels` store. These ultimately
    depend on the state of the `Checkboxes` store, so as the user changes the state
    of checkbox, they'll see the corresponding label change its style.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的工作方式与`Checkboxes`视图类似。主要区别在于这里没有用户交互，并且对UI元素所做的更改是`Labels`存储中设置的样式属性值。这些最终取决于`Checkboxes`存储的状态，因此当用户更改复选框的状态时，他们会看到相应的标签样式发生变化。
- en: If this feels like a lot of code to accomplish something simple, that's because
    it is. Remember, we've actually accomplished a lot more here than a simple checkbox
    toggle and label style update. We've established explicit UI state dependencies
    between two different sections of the UI. This is a victory for our architecture,
    because the first moment a given architecture struggles to scale is when we can't
    figure out why something happens. Throughout the lifetime of a Flux architecture,
    we actively take steps to make sure this doesn't happen, as we've just demonstrated
    here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这感觉像是一大堆代码来完成一个简单的任务，那是因为确实如此。记住，我们在这里实际上完成的事情远不止简单的复选框切换和标签样式更新。我们已经在UI的两个不同部分之间建立了明确的UI状态依赖关系。这对我们的架构来说是一个胜利，因为当给定的架构在扩展时遇到困难时，我们无法弄清楚为什么会发生这种情况。在整个Flux架构的生命周期中，我们积极采取措施确保这种情况不会发生，就像我们刚才在这里所展示的那样。
- en: View update order
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看更新顺序
- en: While it's nice to be able to explicitly control the dependencies of our stores
    using `waitFor()`, views don't have such luxuries. In this section, we'll look
    at the order in which our views render UI elements. First, we'll look at the role
    stores have to play in the order of view updates. Then, we'll go over the cases
    where view order actually affects the user experience versus those where the ordering
    doesn't matter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够使用`waitFor()`显式控制存储的依赖性很方便，但视图没有这样的奢侈。在本节中，我们将查看我们的视图渲染UI元素的顺序。首先，我们将查看存储在视图更新顺序中扮演的角色。然后，我们将讨论视图顺序实际上影响用户体验的情况，以及那些顺序并不重要的情况。
- en: Store registration order
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储注册顺序
- en: 'The order in which actions are dispatched to stores matters. When a store transforms
    its state, it also notifies any views listening to the store. This means that
    if one view is listening to a store that was registered with the dispatcher first,
    this view will be rendered before any other views. The idea is illustrated here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将操作分派给存储的顺序很重要。当存储转换其状态时，它也会通知任何监听存储的视图。这意味着如果某个视图正在监听首先注册到调度器的存储，那么这个视图将在任何其他视图之前渲染。这个想法在这里得到了说明：
- en: '![Store registration order](img/B05419_06_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![存储注册顺序](img/B05419_06_05.jpg)'
- en: As you can see, the order of the store callback functions within the dispatcher
    clearly impacts the rendering order of views. Store dependencies can also impact
    the order of view rendering. For example, if store A depends on store B, then
    any views listening to store B will be rendered first. It could be that none of
    this matters or there could be some interesting side effects. We'll look at both
    outcomes next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调度器内存储回调函数的顺序明显影响了视图的渲染顺序。存储依赖也可以影响视图渲染的顺序。例如，如果存储A依赖于存储B，那么任何监听存储B的视图将会首先渲染。这可能是无关紧要的，或者可能会有一些有趣的副作用。我们将在下一节中查看这两种结果。
- en: Prioritizing view rendering
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先渲染视图
- en: Given that the stores that form the core of our Flux architecture can also determine
    the render order of our views, we have to take care to prioritize according to
    user experience. For example, we could have a store that represents the top header
    area of the page and another store that's for the main content area. Now, if the
    main content area renders first, leaving a noticeable gap near the top of the
    page, we'll want to fix that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构成我们Flux架构核心的存储也可以确定我们视图的渲染顺序，我们必须注意根据用户体验来优先处理。例如，我们可能有一个表示页面顶部区域头部存储的存储，另一个存储用于主要内容区域。现在，如果主要内容区域首先渲染，在页面顶部留下一个明显的空白，我们将想要修复这个问题。
- en: Seeing as how users will start at the top of the page and work their way down,
    we would have to make sure that the store for the header content is registered
    first. How do we do this? Once again, we're back to where we were when dealing
    with store dependencies. We have to take care to import our views in the correct
    order—an order that reflects the rendering order. As we saw with stores, this
    isn't an ideal situation to be in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户将从页面顶部开始并向下工作，我们必须确保首先注册头部内容的存储。我们如何做到这一点？再一次，我们又回到了处理存储依赖时的那个地方。我们必须注意以正确的顺序导入我们的视图——一个反映渲染顺序的顺序。正如我们所看到的，这并不是一个理想的情况。
- en: One answer is to introduce a store dependency. Even though the content store
    doesn't actually use any data from the header store, it could still depend on
    it for render ordering purposes. By using the `waitFor()` method, we'd know that
    any views that listen to the header store will be rendered first, eliminating
    the possibility of usability issues related to render order. The risk here, of
    course, is the same as any store dependency—complexity. When we reach the point
    where there are too many store dependencies to easily comprehend, it's time to
    rethink our store design.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是引入存储依赖。即使内容存储实际上并没有使用来自头部存储的任何数据，它仍然可以为了渲染顺序的目的而依赖它。通过使用`waitFor()`方法，我们会知道任何监听头部存储的视图将会首先渲染，从而消除与渲染顺序相关的可用性问题。当然，这里的风险与任何存储依赖相同——复杂性。当我们达到有太多存储依赖难以理解的程度时，就是时候重新思考我们的存储设计了。
- en: Dealing with store complexity
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理存储复杂性
- en: The leading culprit of Flux store complexity is dependency management. Despite
    having the dispatcher as a tool to manage these dependencies, something is lost
    when there's too many of them. In this final section of the chapter, we'll discuss
    the consequences of having too many stores in our architecture and what can be
    done to remedy the situation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Flux存储复杂性的主要原因是依赖管理。尽管有调度器作为管理这些依赖的工具，但当依赖太多时，总会有些东西会丢失。在本章的最后部分，我们将讨论在架构中拥有太多存储的后果以及可以采取哪些措施来解决这个问题。
- en: Too many stores
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储过多
- en: The top-level features of our application do a decent job of providing a boundary
    for our stores and the state that they encapsulate. The challenge with stores
    is when there are too many of them. For example, as our applications grow over
    time, more features will be built which translates to more stores being tossed
    into the architecture. Additionally, the stores that already exist are apt to
    grow more complex as well, as they have to find ways to get along with all the
    other changing features of the application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的最高级特性在为我们的存储和它们封装的状态提供边界方面做得相当不错。存储的挑战在于当它们太多时。例如，随着我们的应用程序随着时间的推移而增长，将会有更多特性被构建，这转化为更多存储被投入到架构中。此外，现有的存储也可能会变得更加复杂，因为它们必须找到与其他应用程序中所有变化特性相协调的方法。
- en: This makes for a complex scenario—growing complexity in stores and more stores
    overall. This almost certainly will lead to an explosion in dependencies, as we
    tease out all the edge cases of our user interface. Generic stores that are shared
    by many other specific stores can also be a source of trouble. For example, we
    could end up with way too many generic stores, eventually getting to the point
    where all our state data is indirect.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个复杂的情况——商店的复杂性不断增长，总体上商店数量也在增加。这几乎肯定会导致依赖关系的爆炸性增长，因为我们会挖掘出用户界面的所有边缘情况。由许多特定商店共享的通用商店也可能成为问题的来源。例如，我们可能会拥有过多的通用商店，最终导致所有状态数据都是间接的。
- en: When we've reached the point where the sheer number of stores in our architecture
    is untenable, it's time to start rethinking what constitutes a feature.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们达到架构中商店数量无法承受的程度时，是时候开始重新思考构成功能的内容了。
- en: Rethinking feature domains
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新思考功能域
- en: 'Having top-level features map to our stores generally works well enough, until
    we have a lot of top-level features. At this point, it''s time to re-evaluate
    the policy that a feature maps to a store. For example, if we have a lot of top-level
    features, odds are that there''s a lot of similar data that could be folded into
    a single store that drives many features. Another potential effect of reducing
    the number of stores that power our features is the removal of generic stores.
    Generic stores are only good if we have too much duplicate data, which tends to
    be less of a problem when the number of stores shrinks. Here is a diagram that
    shows how a store could be the driver of more than one feature:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶层功能映射到我们的商店通常足够好，直到我们有很多顶层功能。在这个时候，是时候重新评估功能映射到商店的策略了。例如，如果我们有很多顶层功能，那么很可能有很多可以合并到单个商店中的相似数据，这个商店可以驱动许多功能。减少驱动我们功能的商店数量的另一个潜在影响是移除通用商店。通用商店只有在我们有太多重复数据时才有效，而当商店数量减少时，这通常不是一个问题。以下是一个展示商店如何成为多个功能驱动者的图表：
- en: '![Rethinking feature domains](img/B05419_06_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![重新思考功能域](img/B05419_06_06.jpg)'
- en: We might find ourselves in the opposite situation as well, whereby a store's
    complexity is simply too great, and we need to reduce its responsibilities by
    refactoring it into multiple stores. To fix this, we have to think about how one
    large feature can be turned into two smaller features. If we can't think of a
    good way to divide the feature, then maybe the complexity of the store is the
    best we can do, and it should be left alone.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能发现自己处于相反的情况，即商店的复杂性过于巨大，我们需要通过重构将其分解成多个商店来减少其责任。为了解决这个问题，我们必须考虑如何将一个大功能分解成两个更小的功能。如果我们想不出一个好的方法来划分功能，那么商店的复杂性可能就是我们能做的最好的，它应该保持原样。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a detailed look at stores in Flux architectures, starting
    with the aspects that are most likely to change once we've moved on from the skeleton
    architecture phase. We then introduced the notion of generic stores, the idea
    being to reduce the amount of state that individual stores have to keep. The awkward
    part of generic stores are the dependencies that they introduce, and to deal with
    them, you learned how to use the dispatcher's `waitFor()` mechanism.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了Flux架构中的商店，从我们离开骨架架构阶段后最有可能发生变化的角度开始。然后我们介绍了通用商店的概念，其目的是减少单个商店需要保持的状态量。通用商店的尴尬之处在于它们引入的依赖关系，为了处理这些依赖关系，你学习了如何使用派发器的`waitFor()`机制。
- en: Dependencies between stores come in two varieties, data dependencies and UI
    dependencies, and you learned that UI dependencies are a critical part of any
    Flux architecture. Finally, we discussed some of the ways that stores can grow
    out of hand in terms of complexity, and what can be done about it. In the following
    chapter, we'll look at view components in Flux architectures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 商店之间的依赖关系有两种类型，数据依赖和UI依赖，你了解到UI依赖是任何Flux架构的关键部分。最后，我们讨论了商店在复杂性方面可能失控的一些方式，以及如何应对这种情况。在下一章中，我们将探讨Flux架构中的视图组件。
