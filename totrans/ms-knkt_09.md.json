["```js\nko.computedContext = ko.dependencyDetection = (function () {\n  var outerFrames = [],\n  currentFrame,\n  lastId = 0;\n\n  function getId() {\n    return ++lastId;\n  }\n\n  function begin(options) {\n    outerFrames.push(currentFrame);\n    currentFrame = options;\n  }\n\n  function end() {\n    currentFrame = outerFrames.pop();\n  }\n\n  return {\n    begin: begin,\n    end: end,\n    registerDependency: function (subscribable) {\n      if (currentFrame) {\n        if (!ko.isSubscribable(subscribable))\n        throw new Error(\"Only subscribable things can act as dependencies\");\n        currentFrame.callback(subscribable, subscribable._id || (subscribable._id = getId()));\n      }\n    },\n    ignore: function (callback, callbackTarget, callbackArgs) {\n      try {\n        begin();\n        return callback.apply(callbackTarget, callbackArgs || []);\n      } finally {\n        end();\n      }\n    },\n    getDependenciesCount: function () {\n      if (currentFrame)\n      return currentFrame.computed.getDependenciesCount();\n    },\n    isInitial: function() {\n      if (currentFrame)\n      return currentFrame.isInitial;\n    }\n  };\n})();\n```", "```js\nfunction observable() {\n  if (arguments.length > 0) {\n    /* write new value */\n  }\n  else {\n    // Read\n    ko.dependencyDetection.registerDependency(observable); \n    return _latestValue;\n  }\n}\n```", "```js\nfunction dependentObservable() {\n  if (arguments.length > 0) {\n    /* write new value */\n  } else {\n    ko.dependencyDetection.registerDependency(dependentObservable);\n    if (_needsEvaluation) //suppressChangeNotification\n    evaluateImmediate(true);\n    return _latestValue;\n  }\n}\n```", "```js\n_subscriptions: {\n  change: [sub1, sub2],\n  beforeChange: [sub3, sub4]\n};\n```", "```js\nfunction observable() {\n  if (arguments.length > 0) {\n    // Ignore writes if the value hasn't changed\n    if (observable.isDifferent(_latestValue, arguments[0])) {\n      observable.valueWillMutate();\n      _latestValue = arguments[0];\n      observable.valueHasMutated();\n    }\n    return this; // Permits chained assignments\n  }\n  else {\n    // Read code\n  }\n}\n//...\nobservable.valueHasMutated = function () {\n  observable[\"notifySubscribers\"](_latestValue);\n}\nobservable.valueWillMutate = function () {\n  observable[\"notifySubscribers\"](_latestValue, \"beforeChange\");\n}\n```", "```js\nnotifySubscribers: function (valueToNotify, event) {\n  event = event || defaultEvent;\n  if (this.hasSubscriptionsForEvent(event)) {\n    try {\n      // Begin suppressing dependency detection\n      ko.dependencyDetection.begin();\n      for (var a = this._subscriptions[event].slice(0), \n      i = 0, subscription; \n      subscription = a[i]; ++i) {\n        if (!subscription.isDisposed)\n        subscription.callback(valueToNotify);\n      }\n    } finally {\n      // End suppressing dependency detection\n      ko.dependencyDetection.end(); \n   }\n }\n}\n```", "```js\nko.utils.arrayForEach([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (methodName) {\n  ko.observableArray['fn'][methodName] = function () {\n    var underlyingArray = this.peek();\n    this.valueWillMutate();\n    this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);\n    var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n    this.valueHasMutated();\n    return methodCallResult;\n  };\n});\n```", "```js\nko.utils.arrayForEach([\"slice\"], function (methodName) {\n  ko.observableArray['fn'][methodName] = function () {\n    var underlyingArray = this();\n    return underlyingArray[methodName].apply(underlyingArray, arguments);\n  };\n});\n```", "```js\nremove: function (valueOrPredicate) {\n  var underlyingArray = this.peek();\n  var removedValues = [];\n  var predicate = typeof valueOrPredicate == \"function\" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n  for (var i = 0; i < underlyingArray.length; i++) {\n    var value = underlyingArray[i];\n    if (predicate(value)) {\n      //Remove element, add to removedValues\n    }\n  }\n  if (removedValues.length) {\n    this.valueHasMutated();\n  }\n  return removedValues;\n}\n```", "```js\nremoveAll: function (arrayOfValues) {\n  // If you passed zero args, we remove everything\n  if (arrayOfValues === undefined) {\n    //remove all elements\n  }\n  return this['remove'](function (value) {\n    return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n  });\n}\n```", "```js\nvar ko_subscribable_fn = {\n  subscribe: function (callback, target, event) { /* logic */ },\n  notifySubscribers: function (value, event) { /* logic */ },\n  limit: function(limitFunction) { /* logic */ },\n  hasSubscriptionsForEvent: function(event) { /* logic */ },\n  getSubscriptionsCount: function () { /* logic */ },\n  isDifferent: function(oldValue, newValue) { /* logic */ },\n  extend: applyExtenders\n};\nko.subscribable['fn'] = ko_subscribable_fn;\n```", "```js\nko.subscribable = function () {\n  ko.utils.setPrototypeOfOrExtend(this, ko.subscribable['fn']);\n  this._subscriptions = {};\n}\n```", "```js\nko.observable = function (initialValue) {\n  var _latestValue = initialValue;\n\n  function observable() {\n    //build observable\n  }\n  ko.subscribable.call(observable);\n  ko.utils.setPrototypeOfOrExtend(observable, ko.observable['fn']);\n\n  observable.peek = function() { return _latestValue };\n  observable.valueHasMutated = function () { \n    observable[\"notifySubscribers\"](_latestValue); \n  }\n  observable.valueWillMutate = function () { \n    observable[\"notifySubscribers\"](_latestValue, \"beforeChange\"); \n  }\n\n  return observable;\n}\n```", "```js\nvar protoProperty = ko.observable.protoProperty = \"__ko_proto__\";\nko.observable['fn'][protoProperty] = ko.observable;\n\nko.hasPrototype = function(instance, prototype) {\n  if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;\n  if (instance[protoProperty] === prototype) return true;\n  return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain\n};\n\nko.isObservable = function (instance) {\n  return ko.hasPrototype(instance, ko.observable);\n}\n```", "```js\ndata-bind=\"value: name, visible: showName\"\n```", "```js\n{\n  value: function() { return name; },\n  visible: function() { return showName; }\n}\n```", "```js\nfunction processKeyValue(key, val) {\n  var writableVal;\n  function callPreprocessHook(obj) {\n    return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;\n  }\n  if (!bindingParams) {\n    if (!callPreprocessHook(ko['getBindingHandler'](key)))\n    return;\n\n    if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {\n      //provide a write method in case the value\n      // isn't a writable observable.\n      propertyAccessorResultStrings.push(\"'\" + key + \"':function(_z){\" + writableVal + \"=_z}\");\n    }\n  }\n  if (makeValueAccessors) {\n    val = 'function(){return ' + val + ' }';\n  }\n  resultStrings.push(\"'\" + key + \"':\" + val);\n}\n```", "```js\nif (propertyAccessorResultStrings.length)\n  processKeyValue('_ko_property_writers', \"{\" + propertyAccessorResultStrings.join(\",\") + \" }\");\n```", "```js\nreturn resultStrings.join(\",\");\n```", "```js\n'value': function() { return name; }, 'visible': function() { return showName; '_ko_property_writers':function(){return {'value':function(_z){ name =_z} } } }\n```", "```js\nvar rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),\n  functionBody = \"with($context){with($data||{}){return{\" + rewrittenBindings + \"}}}\";\n  return new Function(\"$context\", \"$element\", functionBody);\n```", "```js\n{\n  value: function() { return name; },\n  visible: function() { return showName; },\n  _ko_property_writers: function (){\n    return {'value':function(_z){query=_z} } \n  }\n}\n```", "```js\nwriteValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {\n  if (!property || !ko.isObservable(property)) {\n    var propWriters = allBindings.get('_ko_property_writers');\n    if (propWriters && propWriters[key])\n    propWriters[key](value);\n  } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {\n    property(value);\n  }\n}\n```", "```js\nfunction topologicalSortBindings(bindings) {\n  // Depth-first sort\n  var result = [],                // The list of key/handler pairs that we will return\n  bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'\n  cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it\n  ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {\n    if (!bindingsConsidered[bindingKey]) {\n      var binding = ko['getBindingHandler'](bindingKey);\n      if (binding) {\n        // First add dependencies (if any) of the current binding\n        if (binding['after']) {\n          cyclicDependencyStack.push(bindingKey);\n          ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {\n            if (bindings[bindingDependencyKey]) {\n              if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {\n                throw Error(\"Cannot combine the following bindings, because they have a cyclic dependency: \" + cyclicDependencyStack.join(\", \"));\n              } else {\n                pushBinding(bindingDependencyKey);\n              }\n            }\n          });\n          cyclicDependencyStack.length--;\n        }\n        // Next add the current binding\n        result.push({ key: bindingKey, handler: binding });\n      }\n      bindingsConsidered[bindingKey] = true;\n    }\n  });\n\n  return result;\n}\n```", "```js\n// Run init, ignoring any dependencies\nvar handlerInitFn = bindingKeyAndHandler.handler[\"init\"];\nif (typeof handlerInitFn == \"function\") {\n  ko.dependencyDetection.ignore(function() {\n    var initResult = handlerInitFn(node, \n    getValueAccessor(bindingKey),\n    allBindings,\n    bindingContext['$data'],\n    bindingContext);\n\n    // If this binding handler claims to control descendant bindings, make a note of this\n    if (initResult && initResult['controlsDescendantBindings']) {\n      if (bindingHandlerThatControlsDescendantBindings !== undefined)\n      throw new Error(\"Multiple bindings (\" + bindingHandlerThatControlsDescendantBindings + \" and \" + bindingKey + \") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");\n      bindingHandlerThatControlsDescendantBindings = bindingKey;\n    }\n  });\n}\n```", "```js\n// Run update in its own computed wrapper\nvar handlerUpdateFn = bindingKeyAndHandler.handler[\"update\"];\nif (typeof handlerUpdateFn == \"function\") {\n  ko.dependentObservable(\n    function() {\n      handlerUpdateFn(node, \n      getValueAccessor(bindingKey), \n      allBindings, \n      bindingContext['$data'], \n      bindingContext);\n    },\n    null,\n    { disposeWhenNodeIsRemoved: node }\n  );\n}\n```", "```js\nreturn {\n  'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined\n};\n```", "```js\n'init': function(element, valueAccessor) {\n  // Support anonymous templates\n  var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n  if (typeof bindingValue == \"string\" || bindingValue['name']) {\n    // It's a named template - clear the element\n    ko.virtualElements.emptyNode(element);\n  } else {\n    var templateNodes = ko.virtualElements.childNodes(element),\n    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes);\n    new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n  }\n  return { 'controlsDescendantBindings': true };\n}\n```", "```js\nfunction (templateSource, bindingContext, options) {\n  // IE<9 cloneNode doesn't work properly\n  var useNodesIfAvailable = !(ko.utils.ieVersion < 9),\n  templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,\n  templateNodes = templateNodesFunc ? templateSource['nodes']() : null;\n\n  if (templateNodes) {\n    return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);\n  } else {\n    var templateText = templateSource['text']();\n    return ko.utils.parseHtmlFragment(templateText);\n  }\n};\n```"]