<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-154"><a id="_idTextAnchor154"/>12</h1>
<h1 id="_idParaDest-155"><a id="_idTextAnchor155"/>Enhancing Accessibility and Optimizing SEO</h1>
<p>When it comes to building web applications, we cannot disregard how important it is to ensure the applications are accessible to all users. By empowering those who rely on assistive technologies such as screen readers, we can further the impact our applications have. Not only does making an application available to a wider audience bring in more users, but it can <a id="_idIndexMarker263"/>also affect <strong class="bold">Search Engine Optimization</strong> (<strong class="bold">SEO</strong>). Therefore, it would be negligent to disregard how SvelteKit can help us make our applications accessible from the start.</p>
<p>To understand how we can best empower our users and how doing so can help boost our SEO, we should examine a few concepts. Firstly, we’ll see how the built-in compile-time checks can improve the accessibility of our application with little configuration on our end. We’ll also see how to best announce route changes, which can benefit tools such as screen readers. We’ll then briefly cover a few more tips that can benefit accessibility and wrap up with some simple tips for improving SEO. We’ll break it all apart into the following sections:</p>
<ul>
<li>Compile-time checks</li>
<li>Announcing routes</li>
<li>Accessibility enhancements</li>
<li>SEO tips</li>
</ul>
<p>Upon completing this chapter, we’ll have covered the essentials for ensuring your SvelteKit applications are accessible to a wide audience. Following the best practices outlined here will have the added benefit of improving SEO rankings.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor156"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter12">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter12</a></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor157"/>Compile-Time Checks</h1>
<p>When we installed our SvelteKit project, it came with a few opinionated enhancements out of the box. Of those <a id="_idIndexMarker264"/>enhancements, the compile-time checks can be of particular use to warn us of elements that have been poorly formed or are missing attributes. Upon making the suggested changes, we’ll notice that these warnings go away.</p>
<p>If you’ve paid attention to the recommendations from <code>eslint</code> or the output from builds, you may have noticed some warnings referring to <code>A11y</code>. This is the abbreviated term used for <em class="italic">Accessibility</em>. It refers to the <em class="italic">A</em>, the following 11 characters, and the <em class="italic">y</em>. In recognizing the importance of making applications accessible, the Svelte developers have opted to include sane behaviors by default as it contributes to a more open web. Before becoming frustrated with regular warnings, consider the convenience of having the application checked for a11y errors while not having to seek out our own solutions. Not only does building with a11y in mind help users but it also helps developers become better by recognizing which patterns are accessible and which are not.</p>
<p>If you’ve yet to see any of these issues, we can go back to one of our earliest examples and remove an <code>alt</code> attribute from an <code>&lt;</code><code>img&gt;</code> element:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import db from 'db';
  import url from 'img/demo.svg';
  let status = db.connection;
  let name = 'World';
&lt;/script&gt;
&lt;form&gt;
  &lt;label for="name" &gt;What is your name?&lt;/label&gt;
  &lt;input type="text" class='name' bind:value={name} /&gt;
&lt;/form&gt;
&lt;h1&gt;Hello, {name}!&lt;/h1&gt;
&lt;p&gt;{status}&lt;/p&gt;
&lt;img src={url}&gt;
// A11y: &lt;img&gt; element should have an alt attribute</pre>
<p>In this example, the only change made is the removal of the <code>alt</code> attribute from the <code>&lt;img&gt;</code> tag at the very end. Most modern editors should alert you directly in the file, but if you’re not seeing this warning, you can view it directly in the output from the build by running <code>npm run build</code> in your terminal. Upon observing the <code>build</code> output, we will be able to discern the exact location of the problem and view a recommended fix.</p>
<p>These warnings don’t only apply to missing attributes on HTML elements either. We’ll also be alerted if form labels are <a id="_idIndexMarker265"/>associated with a control, if certain media types have captions, if attributes are given improper values, and more warnings than can be reasonably listed here. For a full list, see the resources at the end of this chapter. As we can see, the compile-time a11y checks can be incredibly useful in helping developers deliver accessible applications to as many users as possible.</p>
<p>Following the advice of compile-time check warnings is not the only way that we can improve a11y in our applications. We can also inform users of navigation events by updating the title of each page. By announcing route changes in the following way, we have the benefit of alerting users of screen readers while maintaining client-side navigation.</p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor158"/>Announcing routes</h1>
<p>Another strategy for<a id="_idIndexMarker266"/> ensuring a11y of our applications includes announcing our routes. This effectively means that all of our pages include a title so that screen readers can announce the new page to their users. With typical SSR applications, navigation consists of each new page being loaded when navigated to. With SvelteKit, navigation is handled by the client and so full-page reloads are not always necessary. This presents a dilemma for screen readers as they rely on a new title element to be present with each link clicked so that the page may be announced to users.</p>
<p>To play better with screen readers, we can insert a title into each new page we create using the <code>&lt;</code><code>svelte:head&gt;</code> directive:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import db from 'db';
  import url from 'img/demo.svg';
  let status = db.connection;
  let name = 'World';
&lt;/script&gt;
&lt;svelte:head&gt;
  &lt;title&gt;Home&lt;/title&gt;
&lt;/svelte:head&gt;
&lt;form&gt;
  &lt;label for="name" &gt;What is your name?&lt;/label&gt;
  &lt;input type="text" class='name' bind:value={name} /&gt;
&lt;/form&gt;
&lt;h1&gt;Hello, {name}!&lt;/h1&gt;
&lt;p&gt;{status}&lt;/p&gt;
&lt;img src={url} alt='demo'&gt;</pre>
<p>On our application landing page, we’ve re-added the <code>alt</code> attribute to our <code>&lt;img&gt;</code> tag, but more importantly, we’ve set<a id="_idIndexMarker267"/> the page title to <code>&lt;svelte:head&gt;</code> tag. Let’s make a similar change in another file so we can observe how this affects the browsing experience:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(site)/about/+page.svelte</p>
<pre class="source-code">
&lt;svelte:head&gt;
  &lt;title&gt;About&lt;/title&gt;
&lt;/svelte:head&gt;
&lt;div class='wrapper'&gt;
  &lt;h1&gt;About&lt;/h1&gt;
  &lt;p&gt;
    Lorem ipsum dolor ...
  &lt;/p&gt;
&lt;/div&gt;</pre>
<p>In our application’s <code>&lt;title&gt;</code> element with the appropriate text and surrounding it with <code>&lt;svelte:head&gt;</code> tags. These tags place the content within the document head. To see how this can affect the browsing experience, open the development version of the application and take note of the page title shown in your browser<a id="_idIndexMarker268"/> on the home page. Then, click <strong class="bold">About</strong> and observe how the title shown in the browser tab changes.</p>
<p>For screen reader applications, this small change allows them to alert users that they have navigated to a new route. Even for users who are not utilizing a screen reader, this is a noticeable improvement over the previous text showing only the site name. If a user were to bookmark a page on this site, the default text would now more accurately reflect the page in question. Not only is this helpful addition for all human users but it can also be a big boost to our application’s SEO, as many search engines will take into account page titles when indexing posts.</p>
<p>By announcing routes, we can greatly improve the experience of our application for its users. Next, let’s take a look at some other small adjustments that can make big improvements.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor159"/>Accessibility enhancements</h1>
<p>Not all developers nor all of those who utilize screen readers speak English as their primary language. As such, we should be <a id="_idIndexMarker269"/>able to adjust our application accordingly. Doing so is fairly straightforward and we can vastly improve the experience for users of assistive technology around the world by making a small note about the language our content is served in. By default, SvelteKit sets the language to English but we can quickly adjust it by changing the <code>lang</code> attribute on the <code>&lt;html&gt;</code> element in <code>src/app.html</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/app.html</p>
<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;link rel="icon" href="%sveltekit.assets%/favicon.png" /&gt;
        &lt;meta name="viewport" content="width=device-width" /&gt;
        %sveltekit.head%
    &lt;/head&gt;
    &lt;body data-sveltekit-preload-data="hover"&gt;
         &lt;div style="display: contents"&gt;%sveltekit.body%&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
<p>Note the <code>&lt;html&gt;</code> element at the top of the file with the <code>lang</code> attribute set. Setting the <code>lang</code> attribute to the appropriate language, such as <code>fr</code> for French or <code>ar</code> for Arabic, ensures that screen readers can correctly pronounce or translate the content.</p>
<p>One final a11y improvement <a id="_idIndexMarker270"/>we can make in our applications is allowing SvelteKit to manipulate the focus on HTML elements. Normally, when an application is rendered on the server, each new navigation event resets the focus. But in client-side rendered applications, the browser may not detect that a navigation event has occurred and therefore, focus will persist on whatever the currently focused element happens to be. To manage this with a11y in mind, SvelteKit resets focus to the <code>&lt;body&gt;</code> element – that is, unless an element has the <code>autofocus</code> attribute set, at which point that element will be given focus. Letting SvelteKit’s behavior take control of focus comes with the benefit of letting users of screen readers know that a navigation event has occurred.</p>
<p>When it comes to making our applications more accessible to a wider audience, it doesn’t take much effort on our part. Doing so improves the user experience, and all of the aforementioned improvements can also boost<a id="_idIndexMarker271"/> SEO rankings.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor160"/>SEO Tips</h1>
<p>Aside from making some small a11y<a id="_idIndexMarker272"/> improvements in our application, we can keep some other suggestions in mind. Firstly, we should make use of SvelteKit’s <strong class="bold">Server-Side Rendering</strong> (<strong class="bold">SSR</strong>) whenever possible. Doing so ensures the quick delivery of the <a id="_idIndexMarker273"/>application as well as makes content easier for search engines to parse. Of course, many search engines now have the capabilities to index client-side rendered content, but the speed and reliability of SSR cannot be discounted. We should only disable SSR if we have a valid reason to.</p>
<p>Another useful tip to consider is the performance of our application. For the most part, we can rely on Vite to tree-shake unused code out of our builds. Smaller bundle sizes mean fewer lines of code to deliver to the client and many search engines rank results based on asset delivery times. See the <em class="italic">Resources</em> section at the end of this chapter for tools that can deliver insights into your page speeds.</p>
<p>The final useful tip for improving SEO is to leave trailing slashes off route names. Having extra slashes can negatively impact page ranks, so unless you have a valid reason to, consider leaving the page option <code>trailingSlash</code> property alone. By following these few tips, we can be sure our SvelteKit application will rank highly in search engine results.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor161"/>Summary</h1>
<p>When it comes to building a successful web application, we must strive to make it accessible to all. The reasons for doing so may be purely selfish by attempting to capture as much of the market as possible, or egalitarian by trying to include users from all walks of the web. It could be that you simply want to be highly ranked in search engine results. Whatever the reasons may be, it’s a fairly straightforward process with SvelteKit. We’ve seen the warnings provided at compile time and we’ve learned about the benefits of both SEO and a11y when it comes to creating unique page titles. With a few SEO tips to keep in mind, it’s easy for our accessible apps to become known to the world.</p>
<p>Having wrapped up this chapter, we’ve covered nearly everything there is to discuss about SvelteKit. However, technology moves quickly so we can never truly be finished learning. By the time this book is published, there will likely have been more improvements and changes introduced into SvelteKit. To ensure you have the latest information, the next chapter will provide more resources, communities, and examples that are well worth your time to explore.</p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor162"/>Resources</h1>
<ul>
<li><em class="italic">The A11y Project</em> – <a href="https://www.a11yproject.com/">https://www.a11yproject.com/</a></li>
<li><em class="italic">MDN Web Docs: Accessibility</em> – <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility">https://developer.mozilla.org/en-US/docs/Web/Accessibility</a></li>
<li><em class="italic">Svelte Accessibility Warnings</em> – <a href="https://svelte.dev/docs#accessibility-warnings">https://svelte.dev/docs#accessibility-warnings</a></li>
<li><em class="italic">PageSpeed Insights</em> – <a href="https://pagespeed.web.dev/">https://pagespeed.web.dev/</a></li>
</ul>
</div>


<div><h1 id="_idParaDest-164"><a id="_idTextAnchor164"/>Appendix: Examples and Support</h1>
<p>Because learning is a never-ending process and technology moves quickly, this final chapter aims to provide you with the resources you’ll need to continue your journey with SvelteKit. In the world of web development, it’s rare to see a project that doesn’t integrate multiple tools and technologies, so we’ll address how we can easily integrate SvelteKit with other frontend tooling. We’ll also see some official and community-based resources that are invaluable when it comes to troubleshooting, advancing our knowledge, or discovering new components. After that, we’ll wrap things up with a thank-you from the author. Let’s finish this book with the following sections:</p>
<ul>
<li>Integrations</li>
<li>More Reading and Resources</li>
<li>Wrapping up</li>
</ul>
<p>Afterward, you’ll have all the tools and knowledge necessary to go forth and build cool SvelteKit projects.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor165"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/tailwind">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/tailwind</a>.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor166"/>Integrations</h1>
<p>When<a id="_idIndexMarker274"/> it comes to building modern web applications, it’s not uncommon to use a plethora of technologies. Each tool has its place, and it may be the case that a developer is more comfortable with a particular frontend framework than they are with standard CSS. This is fine, as it can speed up development so long as the tools integrate nicely with others. Fortunately for us, SvelteKit works quite well with others.</p>
<p>At the time of writing, Tailwind CSS has become incredibly popular. Tailwind CSS aims to reduce the amount of shipped CSS by only extracting that which is used. This is great to reduce the amount of assets delivered to clients and speed up load times. To showcase how simple it is to integrate a tool such as Tailwind CSS in our existing SvelteKit project, let’s <a id="_idIndexMarker275"/>work through it. These steps can also be found in the official Tailwind CSS documentation. It’s recommended to create a new branch in your repository before starting this process, as it will break some of our existing styles. If you’re following along with this book’s repository, these examples are available on the <code>tailwind</code> branch. To begin, we can install Tailwind along with a couple of other dependencies using the following commands:</p>
<pre class="source-code">
npm install -D tailwindcss postcss autoprefixer</pre>
<p>Of course, <code>tailwindcss</code> will include the necessary tooling to use Tailwind CSS within our project. The <code>postcss</code> dependency will allow us to manipulate CSS files, and <code>autoprefixer</code> is a <code>postcss</code> plugin that will automatically inject the appropriate vendor prefixes into our generated CSS. Once we have added the dependencies to our development environment, we can use the following command to initialize our Tailwind project. It will create the necessary <code>tailwind.config.js</code> and <code>postcss.config.js</code> files:</p>
<pre class="source-code">
npx tailwindcss init -p</pre>
<p>After initializing <code>tailwindcss</code>, we can open <code>svelte.config.js</code> and import the <code>vitePreprocess</code> module. This will enable us to process <code>&lt;style&gt;</code> tags throughout our Svelte components:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">svelte.config.js</p>
<pre class="source-code">
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/kit/vite';
const config = {
    kit: {
        adapter: adapter(),
        alias: {
            db: '/src/db.js',
            img: '/src/lib/images'
        }
    },
    preprocess: vitePreprocess()
};
export default config;</pre>
<p>Now that <a id="_idIndexMarker276"/>we have imported <code>vitePreprocess</code>, we can ensure that Tailwind CSS knows about the paths to our components. We can do this by updating <code>tailwind.config.js</code>, like so:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">tailwind.config.js</p>
<pre class="source-code">
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.{html,js,svelte,ts}'],
  theme: {
    extend: {},
  },
  plugins: [],
}</pre>
<p>Noticeably, we only need to change the paths available in the <code>content</code> array property to point to our <code>src/</code> directory and ensure that the <code>.svelte</code> file type is recognized, along with other standard file types.</p>
<p>We can then create a singular <code>app.css</code> file, where we can import all of Tailwind’s functionality using the <code>@</code><code>tailwind</code> directive:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/app.css</p>
<pre class="source-code">
@tailwind base;
@tailwind components;
@tailwind utilities;</pre>
<p>If you’ve been paying attention, the <a id="_idIndexMarker277"/>next step should be straightforward. We then import <code>src/app.css</code> into our root layout component:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+layout.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import '/src/reset.css';
  import '/src/app.css';
  import Nav from '$lib/Nav.svelte';
  import Notify from '$lib/Notify.svelte';
  export let data;
&lt;/script&gt;
&lt;div class='wrapper'&gt;
  &lt;div class='nav'&gt;
    &lt;div class='menu'&gt;
      &lt;Nav /&gt;
    &lt;/div&gt;
    &lt;div class='notifications'&gt;
      &lt;Notify count={data.notifications.count}/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class='content bg-orange-300'&gt;
    &lt;slot /&gt;
  &lt;/div&gt;
  &lt;div class='footer'&gt;
    This is my footer
  &lt;/div&gt;
&lt;/div&gt;
&lt;!-- &lt;style&gt; omitted for brevity --&gt;</pre>
<p>Of course, we’ve <a id="_idIndexMarker278"/>already imported <code>reset.css</code>, so there will be conflicts with the existing CSS throughout our project. Ensure your development environment is running with <code>npm run dev</code>. To prevent completely breaking our project, we’ve only set the background on the <code>.content</code> element to a light orange color provided by Tailwind CSS, but we’ll definitely notice other changes applied throughout the project. Now would be an excellent time to explore the practice of utility-first CSS if you have not yet done so.</p>
<p>We saw the manual way of integrating another tool such as Tailwind CSS, but we’re talking about SvelteKit, where things just work. If these steps are too much to remember, there is a simpler way. Try creating yet another branch based off of <code>main</code> in your project repository and use the following command to do essentially the same thing we just did. Again, if you’re following along with the book repository, this code can be found in the <code>tailwind-add</code> branch:</p>
<pre class="source-code">
npx svelte-add@latest tailwindcss</pre>
<p>We can follow along with the prompts, and once we’ve installed the dependencies with <code>npm install</code>, our project will have Tailwind CSS integrated! By using the community-maintained <code>svelte-add</code> project, we can quickly and easily import templates that integrate various technologies with our SvelteKit project. For instance, if you prefer to use SCSS/Sass flavors when writing CSS, you can use the <code>scss</code> custom adder, like so:</p>
<pre class="source-code">
npx svelte-add@latest scss</pre>
<p>As we can see, it’s not difficult to incorporate different technologies with SvelteKit. While we can incorporate these other toolchains manually, it’s also easily done with community-provided resources. Let’s take a look at more community resources to see what else is out there!</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor167"/>More Reading and Resources</h1>
<p>As previously <a id="_idIndexMarker279"/>demonstrated, the community resources surrounding SvelteKit can be excellent to save us time and mental overhead, allowing us to focus on building our applications. This book would not have been possible without the community around SvelteKit. If you’re looking to expand on your SvelteKit knowledge, assist others, or create your own SvelteKit extensions, consider the various resources listed next!</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>SvelteKit Documentation</h2>
<p>The <a id="_idIndexMarker280"/>documentation provided on the official SvelteKit website will likely be the best resource you’ll find for information about the framework. It’s incredibly thorough and constantly updated to reflect changes within the framework. Be sure to <a id="_idIndexMarker281"/>start here for any questions you may have about SvelteKit:</p>
<p><a href="https://kit.svelte.dev">https://kit.svelte.dev</a></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor169"/>SvelteKit Tutorial</h2>
<p>To <a id="_idIndexMarker282"/>thoroughly test<a id="_idIndexMarker283"/> your SvelteKit knowledge and learn more than this book could cover, check out the official SvelteKit tutorial:</p>
<p><a href="https://learn.svelte.dev/tutorial">https://learn.svelte.dev/tutorial</a></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor170"/>Svelte and SvelteKit chat</h2>
<p>Have a <a id="_idIndexMarker284"/>question or just want to chat with others that are using SvelteKit? The official Discord server is the place to go:</p>
<p><a href="https://svelte.dev/chat">https://svelte.dev/chat</a></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor171"/>Independent Creators</h2>
<p>There are<a id="_idIndexMarker285"/> too many great writers and creators working with SvelteKit to list here, but a couple of this author’s favorites are Rodney Johnson and Josh Collinsworth. Collinsworth provides the excellent SvelteKit static blog starter template we saw in <a href="B19024_08_Final_AM.xhtml#_idTextAnchor106"><em class="italic">Chapter 8</em></a>, and Johnson creates informative tutorial videos and articles:</p>
<ul>
<li>Rodney Johnson: https://rodneylab.com/</li>
<li>Josh Collinsworth: <a href="https://joshcollinsworth.com/">https://joshcollinsworth.com/</a></li>
</ul>
<h2 id="_idParaDest-172"><a id="_idTextAnchor172"/>Svelte Society</h2>
<p>When<a id="_idIndexMarker286"/> it comes to finding Svelte and SvelteKit community resources, Svelte Society has you covered, whether you’re looking for templates, components, adders, or more. They even organize Svelte events, so if you’re looking to meet other Svelte developers in your area, you <a id="_idIndexMarker287"/>should start here:</p>
<p><a href="https://sveltesociety.dev/">https://sveltesociety.dev/</a></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor173"/>SvelteKit Repository</h2>
<p>As with <a id="_idIndexMarker288"/>many open source projects, the code behind SvelteKit is freely available to view on GitHub. If you believe you’ve found a bug specific to the framework, consider searching the issues here, and if you don’t see your problem listed, contribute by submitting it! SvelteKit developers constantly accept pull requests and <a id="_idIndexMarker289"/>appreciate any help they can get: </p>
<p><a href="https://github.com/sveltejs/kit">https://github.com/sveltejs/kit</a></p>
<p>As with many open source projects, the community and documentation can make or break a project. Because of the excellent support behind SvelteKit, it’s hard to imagine a future where people don’t constantly evangelize about SvelteKit and Svelte.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor174"/>Wrapping up</h1>
<p>If you’ve made it this far, then thank you for staying with me. I hope the material and knowledge provided here can be of assistance with your SvelteKit projects. If you’ve enjoyed this book, then do share it with friends, colleagues, and acquaintances who are interested in learning a new JS framework. As this is my first book, it’s certainly been a journey for me, and I’ve learned much about the writing process. If you’re interested in finding more technical texts by me, I write at https://www.closingtags.com about web development and web-adjacent technologies. If you build something cool with SvelteKit, I’d love to hear about it. I can be reached via the contact form on my website. Thanks again, and I look forward to seeing what you build.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor175"/>Summary</h1>
<p>That’s it, you’ve finished the book! If you still have questions about the various workings of SvelteKit, look into the previously provided community resources. You’ll find everything necessary to expand your SvelteKit knowledge and see what others in the community are doing. Because SvelteKit integrates so well with many other tools, it should be a breeze to incorporate it with your existing workflows. I look forward to seeing what you build with it. Thanks again!</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor176"/>Resources</h1>
<ul>
<li>Tailwind CSS: <a href="https://tailwindcss.com">https://tailwindcss.com</a></li>
<li>Svelte Add: <a href="https://github.com/svelte-add/svelte-add">https://github.com/svelte-add/svelte-add</a></li>
</ul>
</div>
</body></html>