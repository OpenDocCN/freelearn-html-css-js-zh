["```js\n// curryByHand.ts\nconst make3 = (a: string, b: number, c: string): string =>\n  `${a}:${b}:${c}`;\n```", "```js\n// continued...\nconst make3curried =\n  (a: string) => (b: number) => (c: string) =>\n    `${a}:${b}:${c}`;\n```", "```js\n// continued...\nconst make3curried2 = function (a: string) {\n  return function (b: number) {\n    return function (c: string) {\n      return `${a}:${b}:${c}`;\n    };\n  };\n};\n```", "```js\n// continued...\nconst addVAT = (rate: number, amount: number): number =>\n  amount * (1 + rate / 100);\naddVAT(20, 500); // 600 -- that is, 500 + 20%\naddVAT(15, 200); // 230 -- 200 +15%\n```", "```js\n// continued...\nconst addVATcurried =\n  (rate: number) =>\n  (amount: number): number =>\n    amount * (1 + rate / 100);\nconst addNationalVAT = addVATcurried(6);\naddNationalVAT(1500); // 1590 -- 1500 + 6%\n```", "```js\n// continued...\nfunction myLog(severity: string, logText?: string) {\n  // display logText in an appropriate way,\n  // according to its severity\n  // (\"NORMAL\", \"WARNING\", or \"ERROR\")\n}\n```", "```js\n// continued...\nmyLog = curry(myLog);\nconst myNormalLog = myLog(\"NORMAL\");\nconst myWarningLog = myLog(\"WARNING\");\nconst myErrorLog = myLog(\"ERROR\");\n```", "```js\n// continued...\nconst myNormalLog2 = curry(myLog)(\"NORMAL\");\nconst myWarningLog2 = curry(myLog)(\"WARNING\");\nconst myErrorLog2 = curry(myLog)(\"ERROR\");\n```", "```js\nsum(3, 5); // 8; did you expect otherwise?\nconst add3 = sum(3);\nadd3(5);   // 8\nsum(3)(5); // 8\n```", "```js\n// continued...\nconst sum = (x, y) => {\n  if (x !== undefined && y !== undefined) {\n    return x + y;\n  } else if (x !== undefined && y == undefined) {\n    return (z) => sum(x, z);\n  } else {  // x,y both undefined\n    return sum;\n  }\n};\n```", "```js\n// curry.js\nfunction curry(fn) {\n  return fn.length === 0\n    ? fn()\n    : (x) => curryByBind(fn.bind(null, x));\n}\n```", "```js\n// continued...\nconst make3 = (a, b, c) => `${a}:${b}:${c}`;\n// f1 is the curried version of make3\nconst f1 = curry(make3);\n// f2 is a function that will fix make3's 1st parameter\nconst f2 = f1(\"A\");\n// f3 is a function that will fix make3's 2nd parameter\nconst f3 = f2(2);\n// \"A2Z\" will be now calculated, since we are providing\n// the 3rd (last) make3's parameter\nconst f4 = f3(\"Z\");\nconsole.log(f4);\n```", "```js\n// continued...\nconst f2b = f1(\"TEA\")(4);\nconst f3b = f2b(\"TWO\");\n// \"TEA:4:TWO\"\nconst f1c = f1(\"IN\")(10)(\"TION\");\n// \"IN\":10:\"TION\"\n```", "```js\n// continued…\nconst step1 = make3.bind(null, \"A\");\nconst step2 = step1.bind(null, 2);\nconst step3 = step2.bind(null, \"Z\");\nconsole.log(step3()); // \"A:2:Z\"\n```", "```js\n// curry.ts\ntype Curry<P, R> = P extends [infer H]\n  ? (arg: H) => R // only 1 arg\n  : P extends [infer H, ...infer T] // 2 or more args\n  ? (arg: H) => Curry<[...T], R>\n  : never;\n```", "```js\n// continued…\nfunction curry<A extends any[], R>(\n  fn: (...args: A) => R\n): Curry<A, R>;\nfunction curry(fn: (...args: any) => any) {\n  return fn.length === 0\n    ? fn()\n    : (x: any) => curry(fn.bind(null, x));\n}\n```", "```js\nconst f1 = curry(make3);\n// (arg: string) => (arg: number) => (arg: string) => string\nconst f2 = f1(\"A\");\n// (arg: number) => (arg: string) => string\nconst f3 = f2(2);\n// (arg: string) => string\nconst f4 = f3(\"Z\");\n// string\n```", "```js\n// curry.test.js\ndescribe(\"with curry\", function () {\n  it(\"you fix arguments one by one\", () => {\n    const make3a = curry(make3);\n    const make3b = make3a(\"A\")(2);\n    const make3c = make3b(\"Z\");\n    expect(make3c).toBe(make3(\"A\", 2, \"Z\"));\n  });\n});\n```", "```js\nconst myFetch = partial(fetch, undefined, myParameters);\n// undefined means the first argument for fetch\n// is not yet defined; the second argument for\n// fetch() is set to myParameters\nmyFetch(\"a/first/url\")\n  .then(/* do something */)\n  .catch(/* on error */);\nmyFetch(\"a/second/url\")\n  .then(/* do something else */)\n  .catch(/* on error */);\n```", "```js\nconst nonsense = (a, b, c, d, e) =>\n  `${a}/${b}/${c}/${d}/${e}`;\nconst fix2and5 = (a, c, d) => nonsense(a, 22, c, d, 1960);\n```", "```js\nconst fixLast = (a, c) => fix2and5(a, c, 9);\n```", "```js\nconst fix2and5 = _.partial(nonsense)(_, 22, _, _, 1960);\n```", "```js\nconst nonsense = (a, b, c, d, e) =>\n  `${a}/${b}/${c}/${d}/${e}`;\nconst fix2and5 = partial(nonsense)(\n  undefined,\n  22,\n  undefined,\n  undefined,\n  1960\n);\n// fix2and5 would become\n//     (X0, X2, X3) => nonsense(X0, 22, X2, X3, 1960);\n```", "```js\n// partial.js\nfunction partial(fn) {\n  const partialize =\n    (...args1) =>\n    (...args2) => {\n      for (\n        let i = 0;\n        i < args1.length && args2.length;\n        i++\n      ) {\n        if (args1[i] === undefined) {\n          args1[i] = args2.shift();\n        }\n      }\n      const allParams = [...args1, ...args2];\n      return allParams.includes(undefined) ||\n        allParams.length < fn.length\n        ? partialize(...allParams)\n        : fn(...allParams);\n    };\n  return partialize();\n}\n```", "```js\nconst make3 = (a: string, b: number, c: string): string =>\n  `${a}:${b}:${c}`;\nconst f0 = partial(make3);\nconst f1 = f0(undefined, 2);\n```", "```js\nconst f2 = f1(\"A\");\n```", "```js\nconst f3 = f2(\"Z\");\n```", "```js\n// partial.ts\ntype Partialize<\n  P extends any[],\n  A extends any[]\n> = 0 extends P[\"length\"]\n  ? []\n  : 0 extends A[\"length\"]\n  ? P\n  : [P, A] extends [\n      [infer PH, ...infer PT],\n      [infer AH, ...infer AT]\n    ]\n  ? AH extends undefined\n    ? [PH, ...Partialize<PT, AT>]\n    : [...Partialize<PT, AT>]\n  : never;\n```", "```js\n// continued...\ntype p00 = Partialize<\n  [boolean, number, string],\n  [undefined, undefined, undefined]\n>; // [boolean, number, string]\ntype p01 = Partialize<\n  [boolean, number, string],\n  [boolean, undefined, undefined]\n>; // [number, string]\ntype p02 = Partialize<\n  [boolean, number, string],\n  [undefined, string, undefined]\n>; // [boolean, string]\ntype p03 = Partialize<\n  [boolean, number, string],\n  [undefined, undefined, string]\n>; // [boolean, number]\ntype p04 = Partialize<\n  [boolean, number, string],\n  [boolean, undefined, string]\n>; // [number]\ntype p05 = Partialize<[boolean, number, string], [boolean]>;\n// [number, string]\ntype p06 = Partialize<[boolean, number, string], []>;\n// [boolean, number, string]\n```", "```js\ntype p04 = Partialize<\n  [boolean, number, string],\n  [string, undefined, number]\n>; // [number]\n```", "```js\n// continued...\ntype TypesMatch<\n  P extends any[],\n  A extends any[]\n> = 0 extends P[\"length\"]\n  ? boolean\n  : 0 extends A[\"length\"]\n  ? boolean\n  : [P, A] extends [\n      [infer PH, ...infer PT],\n      [infer AH, ...infer AT]?\n    ]\n  ? AH extends undefined\n    ? TypesMatch<PT, AT>\n    : PH extends AH\n    ? TypesMatch<PT, AT>\n    : never\n  : never;\n```", "```js\n// continued...\ntype Partial<P extends any[], R> = <A extends any[]>(\n  ...x: A\n) => TypesMatch<P, A> extends never\n  ? never\n  : P extends any[]\n  ? 0 extends Partialize<P, A>[\"length\"]\n    ? (...x: [...P]) => R\n    : Partial<Partialize<P, A>, R>\n  : never;\n```", "```js\n// continued...\nfunction partial<P extends any[], R>(\n  fn: (...a: P) => R\n): Partial<P, R>;\nfunction partial(fn: (...a: any) => any) {\n  const partialize =\n    (...args1: any[]) =>\n    (...args2: any[]) => {\n      for (\n        let i = 0;\n        i < args1.length && args2.length;\n        i++\n      ) {\n        if (args1[i] === undefined) {\n          args1[i] = args2.shift();\n        }\n      }\n      const allParams = [...args1, ...args2];\n      return allParams.includes(undefined) ||\n        allParams.length < fn.length\n        ? partialize(...allParams)\n        : fn(...allParams);\n    };\n  return partialize();\n}\n```", "```js\n// partial.test.ts\nfunction nonsense(\n  a: number,\n  b: number,\n  c: number,\n  d: number,\n  e: number\n) {\n  return `${a}/${b}/${c}/${d}/${e}`;\n}\ndescribe(\"with partial()\", function () {\n  it(\"you could fix no arguments\", () => {\n    const nonsensePC0 = partial(nonsense);\n    expect(nonsensePC0(0, 1, 2, 3, 4)).toBe(\n      nonsense(0, 1, 2, 3, 4)\n    );\n  });\n  it(\"you could fix only some initial arguments\", () => {\n    const nonsensePC1 = partial(nonsense)(1, 2, 3);\n    expect(nonsensePC1(4, 5)).toBe(nonsense(1, 2, 3, 4,\n      5));\n  });\n  it(\"you could skip some arguments\", () => {\n    const nonsensePC2 = partial(nonsense)(\n      undefined,\n      22,\n      undefined,\n      44\n    );\n    expect(nonsensePC2(11, 33, 55)).toBe(\n      nonsense(11, 22, 33, 44, 55)\n    );\n  });\n  it(\"you could fix only some last arguments\", () => {\n    const nonsensePC3 = partial(nonsense)(\n      undefined,\n      undefined,\n      undefined,\n      444,\n      555\n    );\n    expect(nonsensePC3(111, 222, 333)).toBe(\n      nonsense(111, 222, 333, 444, 555)\n    );\n  });\n  it(\"you could fix ALL the arguments\", () => {\n    const nonsensePC4 = partial(nonsense)(6, 7, 8, 9, 0);\n    expect(nonsensePC4).toBe(nonsense(6, 7, 8, 9, 0));\n  });\n  it(\"you could work in steps - (a)\", () => {\n    const nonsensePC5 = partial(nonsense);\n    const nn = nonsensePC5(undefined, 2, 3);\n    const oo = nn(undefined, undefined, 5);\n    const pp = oo(1, undefined);\n    const qq = pp(4);\n    expect(qq).toBe(nonsense(1, 2, 3, 4, 5));\n  });\n  it(\"you could work in steps - (b)\", () => {\n    const nonsensePC6 = partial(nonsense)(undefined, 2, 3)(\n      undefined,\n      undefined,\n      5\n    )(\n      1,\n      undefined\n    )(4);\n    expect(nonsensePC6).toBe(nonsense(1, 2, 3, 4, 5));\n  });\n});\n```", "```js\nconst nonsense = (a, b, c, d, e) =>\n  `${a}/${b}/${c}/${d}/${e}`;\nconst pcNonsense = partialCurry(nonsense);\nconst fix1And2 = pcNonsense(9, 22);\n// fix1And2 is now a ternary function\nconst fix3 = fix1And2(60);\n// fix3 is a binary function\nconst fix4and5 = fix3(12, 4);\n// fix4and5 === nonsense(9,22,60,12,4), \"9/22/60/12/4\"\n```", "```js\n// partialCurry.js\nfunction partialCurry(fn) {\n  return fn.length === 0\n    ? fn()\n    : (...x) => partialCurry(fn.bind(null, ...x));\n}\n```", "```js\nfunction curry(fn) {\n  return fn.length === 0\n    ? fn()\n    : (x) => curry(fn.bind(null, x));\n}\n```", "```js\n// partialCurry.ts\ntype Minus<X, Y> = [X, Y] extends [\n  [any, ...infer XT],\n  [any, ...infer YT]\n]\n  ? Minus<XT, YT>\n  : X;\n```", "```js\n// partialCurry.ts\ntype PartialCurry<P extends any[], R> = <A extends any[]>(\n  ...x: A\n) => TypesMatch<P, A> extends never\n  ? never\n  : P extends any[]\n  ? A[\"length\"] extends P[\"length\"]\n    ? R\n    : PartialCurry<Minus<P, A>, R>\n  : never;\n```", "```js\nconst h1 = partialCurryByBind(make3);\nconst h2 = h1(\"A\");\nconst h3 = h2(2, \"Z\");\nconsole.log(h3); // A:2:Z\nconst h5 = h1(\"BE\", 4);\nconst h6 = h5(\"YOU\");\nconsole.log(h6); // BE:4:YOU\nconst h7 = h5()()()(\"ME\");\nconsole.log(h7); // B:4:ME\n```", "```js\nconst h8 = partialCurryByBind(make3)(\"I\",8);\nconst h9 = h8(\"SOME\");\nconsole.log(h9); // I:8:SOME\n```", "```js\n// partialCurry.test.ts\ndescribe(\"with partialCurryByBind\", function () {\n  it(\"you could fix arguments in several steps\", () => {\n    const make3a = partialCurryByBind(make3);\n    const make3b = make3a(\"MAKE\", 1);\n    const make3c = make3b(\"TRY\");\n    expect(make3c).toBe(make3(\"MAKE\", 1, \"TRY\"));\n  });\n  it(\"you could fix arguments in a single step\", () => {\n    const make3a = partialCurryByBind(make3);\n    const make3b = make3a(\"SET\", 2, \"IT\");\n    expect(make3b).toBe(make3(\"SET\", 2, \"IT\"));\n  });\n  it(\"you could fix ALL the arguments\", () => {\n    const make3all = partialCurryByBind(make3);\n    expect(make3all(\"SOME\", 1, \"KNOWS\")).toBe(\n      make3(\"SOME\", 1, \"KNOWS\")\n    );\n  });\n  it(\"you could fix one argument at a time\", () => {\n    const make3one =\n      partialCurryByBind(make3)(\"READY\")(2)(\"GO\");\n    expect(make3one).toBe(make3(\"READY\", 2, \"GO\"));\n  });\n});\n```", "```js\n// partialCurry.js\nconst partialCurryByClosure = (fn) => {\n  const curryize =\n    (...args1) =>\n    (...args2) => {\n      const allParams = [...args1, ...args2];\n      return allParams.length < fn.length\n        ? curryize(...allParams)\n        : fn(...allParams);\n    };\n  return curryize();\n};\n```", "```js\n// partialCurry.ts\nfunction partialByClosure<P extends any[], R>(\n  fn: (...a: P) => R\n): PartialCurry<P, R>;\nfunction partialByClosure(fn: (...a: any) => any) {\n  const curryize =\n    (...args1: any[]) =>\n    (...args2: any[]) => {\n      const allParams = [...args1, ...args2];\n      return allParams.length < fn.length\n        ? curryize(...allParams)\n        : fn(...allParams);\n    };\n  return curryize();\n}\n```", "```js\nconst sumAll = (...args: number[]): number =>\n  args.reduce((x, y) => x + y, 0);\n```", "```js\nconst curry = (fn, len = fn.length) =>\n  len === 0\n    ? fn()\n    : (p) => curry(fn.bind(null, p), len - 1);\n```", "```js\nconst flip2 = fn => (p1, p2) => fn(p2, p1);\n```", "```js\nconst myMap = curry(flip2(demethodize(map)));\nconst makeString = (v) => String(v);\nconst stringify = myMap(makeString);\nlet x = stringify(anArray);\nlet y = stringify(anotherArray);\nlet z = stringify(yetAnotherArray);\n```", "```js\nconst flip3 = (fn) => (p1, p2, p3) => fn(p2, p3, p1);\nconst myReduce = partialCurry(\n  flip3(demethodize(Array.prototype.reduce))\n);\nconst sum = (x, y) => x + y;\nconst sumAll = myReduce(sum, 0);\nsumAll(anArray);\nsumAll(anotherArray);\n```", "```js\nconst myFunction = (a, b, c) => { ... };\nconst myCurriedFn = curry(myFunction)(fix1st);\n// and later in the code...\nmyCurriedFn(set2nd)(set3rd);\n```", "```js\nconst myFunction = (a, b, c) => { ... };\nconst myFixedFirst = (b, c) => myFn(fix1st, b, c);\n// and later...\nmyFixedFirst(set2nd, set3rd);\n```", "```js\nconst _plainMap = demethodize(Array.prototype.map);\nconst myMap = curry(binary(_plainMap));\nconst myMapX = curry(flipTwo(_plainMap));\nconst _plainReduce = demethodize(Array.prototype.reduce);\nconst myReduce = curry(ternary(_plainReduce));\nconst myReduceX = curry(flip3(_plainReduce));\nconst _plainFilter = demethodize(Array.prototype.filter);\nconst myFilter = curry(binary(_plainFilter));\nconst myFilterX = curry(flipTwo(_plainFilter));\n// ...and more functions in the same vein\n```", "```js\nlet result = sumMany(9)(2)(3)(1)(4)(3)();\n// 22\n```", "```js\nconst make3 = (a: string, b: number, c: string): string =>\n  `${a}:${b}:${c}`;\n```", "```js\nconst make3curried = x1 => x2 => x3 => make3(x1, x2, x3);\n```", "```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\nconst make3c = curry(make3);\nconsole.log(make3c(1)(2)(3)); // 123\nconst remake3 = uncurry(make3c, 3);\nconsole.log(remake3(1, 2, 3)); // 123\n```", "```js\nFunction.prototype.curry = function () {\n  // ...your code goes here...\n};\nconst sum3 = (a, b, c) => 100 * a + 10 * b + c;\nsum3.curry()(1)(2)(4); // 124\nconst sum3C = sum3.curry()(2)(2);\nsum3C(9); // 229\n```", "```js\ntype Curry<P, R> = P extends [infer H]\n  ? (arg: H) => R // only 1 arg\n  : P extends [infer H, ...infer T] // 2 or more args\n  ? (arg: H) => Curry<[...T], R>\n  : never;\n```", "```js\nconst makeBold = applyStyle(\"b\");\ndocument.getElementById(\"myCity\").innerHTML =\n  makeBold(\"Montevideo\");\n// <b>Montevideo</b>, to produce Montevideo\nconst makeUnderline = applyStyle(\"u\");\ndocument.getElementById(\"myCountry\").innerHTML =\n  makeUnderline(\"Uruguay\");\n// <u>Uruguay</u>, to produce Uruguay\n```", "```js\nconst what = (who) => (...why) => who.length <= why.length\n  ? who(...why) : (...when) => what(who)(...why, ...when);\n```", "```js\nconst curryN =\n  (fn) =>\n  (...args) =>\n    args.length >= fn.length\n      ? fn(...args)\n      : curryN(fn.bind(null, ...args));\n```"]