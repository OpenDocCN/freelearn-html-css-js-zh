<html><head></head><body>
		<div>
			<div id="_idContainer154" class="Content">
			</div>
		</div>
		<div id="_idContainer155" class="Content">
			<h1 id="_idParaDest-269">13. <a id="_idTextAnchor318"/>Async/Await in TypeScript</h1>
		</div>
		<div id="_idContainer161" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">The <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords give developers a more concise way to write asynchronous, non-blocking programs. In this chapter, we'll learn all about this syntactic sugar, a term for more concise and expressive syntax, for promises and how it drives modern software development. We will look at common uses of <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> and discuss the landscape of asynchronous programming in TypeScript. By the end of this chapter, you will be able to implement async/await keywords in TypeScript and use them to write asynchronous programs.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor319"/>Introduction</h1>
			<p>The previous chapter got you started on promises in TypeScript. While promises improved our ability to write asynchronous code without the ugliness of nested callbacks, developers still wanted a better way to write asynchronous code. The promise syntax is sometimes challenging for programmers with a background in the C family of languages, and so the "syntactic sugar" of <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> was proposed to be added to the ECMAScript specification.</p>
			<p>In this chapter, we'll learn about the introduction of new asynchronous programming paradigms to the ECMAScript standard, examine the syntax, and look at their use in TypeScript. We'll also cover the new (as of the time of writing) top-level <strong class="source-inline">await</strong> feature, which allows asynchronous programming outside of an <strong class="source-inline">async</strong> function. We will again look at error handling in asynchronous programming and examine the pros and cons of using <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax versus promises.</p>
			<p>Readers who have been through the prior chapter will see that there is still some nesting involved in promises. While the flow is much easier to manage through multiple promises than it is with nested callbacks, we still have no mechanism by which we can return control to the top level.</p>
			<p>For example, consider a <strong class="source-inline">getData</strong> function that returns a promise. The code that invokes this function will look something like this:</p>
			<p class="source-code">getData().then(data =&gt; {</p>
			<p class="source-code">  // do something with the data</p>
			<p class="source-code">});</p>
			<p>We don't have any means to propagate the <strong class="source-inline">data</strong> value to the outer scope. We couldn't deal with that value in a subsequent scope. Some programmers may attempt to write code that looks like this:</p>
			<p class="source-code">let myData;</p>
			<p class="source-code">getData().then(data =&gt; {</p>
			<p class="source-code">  myData = data</p>
			<p class="source-code">});</p>
			<p class="source-code">console.log(myData);</p>
			<p>This code will always log out <strong class="source-inline">undefined</strong>. It seems like it should work, but it won't because the promise callback won't be invoked until the promise returns. Asynchronous programming like this can be confusing and lead to lots of bugs. <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> solve this problem by allowing us to pause the execution of code pending the resolution of a promise. We can rewrite the preceding code using <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax:</p>
			<p class="source-code">const myData = await getData();</p>
			<p class="source-code">console.log(myData);</p>
			<p>We've gone from five lines of code to two. The synchronous operation of <strong class="source-inline">console.log</strong> will wait for the promise to resolve. The code is much more understandable, and we can store our variable at the top scope without nesting.</p>
			<p>Because TypeScript is transpiled to JavaScript in most cases, we need to make sure that we select the correct target environment in order for our code to run. This topic will be dealt with in greater detail later in the chapter.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor320"/>Evolution and Motivation</h1>
			<p>Although promises moved the needle considerably when it came to asynchronous programming paradigms, there remained a desire for a lighter syntax that relied less on explicitly declaring promise objects. Adding the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords to the ECMAScript specification would allow developers to reduce boilerplate and work with promises. The concept comes from the C# programming language, which in turn borrowed the concept of asynchronous workflows from F#.</p>
			<p>An asynchronous function allows a program to continue normal operation even though that function call has yet to return. The program does not wait for that asynchronous function call to complete until the <strong class="source-inline">await</strong> keyword is found. More significantly, using <strong class="source-inline">await</strong> will not block the event loop. Even if we have paused part of a program to await the result of an asynchronous function call, other operations can still complete. The event loop is not blocked. For more on the event loop, return to <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>.</p>
			<p>The great thing about these keywords is that they are immediately compatible with promises. We can await any promise, thereby avoiding having to use the <strong class="source-inline">then()</strong> API. This capability means that along with the concept of promisification (see <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>), we can use the latest syntax even when integrating with older libraries or modules. To demonstrate this, let's return to an example from the preceding chapter:</p>
			<p class="source-code">import { promises } from "fs";</p>
			<p class="source-code">promises.readFile('text.txt').then(file =&gt; console.log(file.toString()));</p>
			<p>This example uses the <strong class="source-inline">promises</strong> API from the <strong class="source-inline">fs</strong> (filesystem) module from Node.js. The code reads a file from the local filesystem and logs the contents to the console. We can use await syntax with this code: </p>
			<p class="source-code">import { promises } from "fs";</p>
			<p class="source-code">const text = (await promises.readFile('text.txt')).toString();</p>
			<p class="source-code">console.log(text);</p>
			<p>Note that in order to run this code, you must be able to use top-level <strong class="source-inline">await</strong>, which, at the time of this writing, requires a bit of extra setup. Refer to the section later in this chapter. The takeaway from this example is that we are still able to use the <strong class="source-inline">promises</strong> API from the <strong class="source-inline">fs</strong> module, even if we prefer <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor321"/>async/await in TypeScript</h1>
			<p>The maintainers of TypeScript begin work on supporting ECMAScript features when they are in stages 1 and 2 of the review process, but only formally release them when they reach stage 3.</p>
			<p>TypeScript began offering experimental support for <strong class="source-inline">async</strong> functions in version 1.6, released in September 2015, and offered full support in version 1.7, released in November 2015. TypeScript programmers could work with this syntax a full year ahead of official browser and Node.js support.</p>
			<p>Use of the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords in TypeScript does not vary much from JavaScript, but we do have an advantage in the ability to be more explicit about which functions should return promises and which should return a resolved value or throw an error.</p>
			<p>One thing to be cognizant of when writing modern syntax in TypeScript is that most TypeScript code is transpiled to JavaScript for execution in a runtime, such as a web browser or Node.js. We need to understand the difference between transpilation and a polyfill. <strong class="bold">Transpilation</strong> will convert code from one syntax into another. In this case, we can write <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> code and transpile to an environment that only supports promise syntax. A <strong class="bold">polyfill</strong> adds missing language features. If our target environment doesn't even support promises, then transpiling async/await into promises won't do the trick. We will require a polyfill as well. </p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor322"/>Exercise 13.01: Transpilation Targets</h2>
			<p>In this exercise, we will use a contrived "Hello World!" example to demonstrate how TypeScript handles the transpilation of the <strong class="source-inline">async</strong> /<strong class="source-inline">await</strong> keywords:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/NS8gY">https://packt.link/NS8gY</a>.</p>
			<ol>
				<li>Navigate to the <strong class="source-inline">Exercise01</strong> folder and install dependencies with <strong class="source-inline">npm install</strong>:<p class="source-code">npm install</p></li>
				<li>That will install TypeScript and the TS Node execution environment. Now, execute the program included by typing <strong class="source-inline">npx ts-node target.ts</strong>. The result will be as follows:<p class="source-code">World!</p><p class="source-code">Hello</p><p><strong class="source-inline">World!</strong> printed before <strong class="source-inline">Hello</strong>. </p></li>
				<li>Open up <strong class="source-inline">target.ts</strong> and inspect the reason for this. This program creates a <strong class="source-inline">sayHello</strong> function, which internally creates a promise that resolves after one millisecond. You may notice that the program does exactly the same thing even if we remove the <strong class="source-inline">await</strong> keyword. That's OK. It's the different transpilation targets here that are interesting. When we run this program using TS Node, this will target the current Node.js version we're running. Assuming that's a recent version, <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> will be supported. Instead of doing that, let's try transpiling the code into JavaScript using TypeScript to see what happens. </li>
				<li>Now, open the <strong class="source-inline">tsconfig.json</strong> file and look at it:<p class="source-code">{</p><p class="source-code">  "compilerOptions": {</p><p class="source-code">    "target": "es5",</p><p class="source-code">    "module": "commonjs",</p><p class="source-code">    "strict": true,</p><p class="source-code">    "esModuleInterop": true,</p><p class="source-code">    "skipLibCheck": true,</p><p class="source-code">    "forceConsistentCasingInFileNames": true</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">target</strong> option being set to <strong class="source-inline">es5</strong> means that TypeScript will attempt to produce code that conforms to the ECMAScript5 specification. So let's give that a try:<p class="source-code">npx tsc</p><p>No output means that it executed successfully. </p></li>
				<li>Check out the <strong class="source-inline">target.js</strong> file that was produced by TypeScript. The size of this file may vary depending on your TypeScript version, but the transpiled code module may be more than 50 lines:<p class="source-code">"use strict";</p><p class="source-code">var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {</p><p class="source-code">    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }</p><p class="source-code">    return new (P || (P = Promise))(function (resolve, reject) {</p><p class="source-code">//….</p><p class="source-code">sayHello();</p><p class="source-code">console.log('World!');</p><p class="callout-heading">Note</p><p class="callout">The complete code can be found here: <a href="https://packt.link/HSmyX">https://packt.link/HSmyX</a>.</p><p>We can execute the transpiled code by typing <strong class="source-inline">node target.js</strong> at the command prompt and we'll see that we get the same output as before.</p><p>Promises are not part of the ECMAScript5 specification, so to generate code that will work in an ECMAScript5 environment, the transpiler had to create <strong class="source-inline">__awaiter</strong> and <strong class="source-inline">__generator</strong> functions to support promise-like functionality.</p></li>
				<li>Let's switch our target to es6. Open <strong class="source-inline">tsconfig.json</strong> and change the target property to <strong class="source-inline">es6</strong>:<p class="source-code">{</p><p class="source-code">  "compilerOptions": {</p><p class="source-code">    "target": "es6",</p><p class="source-code">    "module": "commonjs",</p><p class="source-code">    "strict": true,</p><p class="source-code">    "esModuleInterop": true,</p><p class="source-code">    "skipLibCheck": true,</p><p class="source-code">    "forceConsistentCasingInFileNames": true</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Invoking the function with <strong class="source-inline">node target.js</strong>, we get exactly the same output as before. Now let's see what TypeScript did when it transpiled our source:<p class="source-code">"use strict";</p><p class="source-code">var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {</p><p class="source-code">    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }</p><p class="source-code">    return new (P || (P = Promise))(function (resolve, reject) {</p><p class="source-code">        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }</p><p class="source-code">        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }</p><p class="source-code">        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }</p><p class="source-code">        step((generator = generator.apply(thisArg, _arguments || [])).next());</p><p class="source-code">    });</p><p class="source-code">};</p><p class="source-code">const sayHello = () =&gt; __awaiter(void 0, void 0, void 0, function* () {</p><p class="source-code">    yield new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(console.log('Hello')), 1));</p><p class="source-code">});</p><p class="source-code">sayHello();</p><p class="source-code">console.log('World!');</p><p>The transpiled code is now 15 lines instead of over 50 because ECMAScript6 is much closer to supporting all the functionality we need than es5 is. The <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords are not supported in ECMAScript6, but promises are, so TypeScript is leveraging promises to make the outputted code more concise.</p></li>
				<li>Now, let's change the target to <strong class="source-inline">esnext</strong>, run <strong class="source-inline">npx tsc</strong> one more time, and see what that output looks like:<p class="source-code">"use strict";</p><p class="source-code">const sayHello = async () =&gt; {</p><p class="source-code">    await new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(console.log('Hello')), 1));</p><p class="source-code">};</p><p class="source-code">sayHello();</p><p class="source-code">console.log('World!');</p><p>That's very similar to our source code! Since <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> are supported in the latest ECMAScript specification, there's no need to transform.</p></li>
				<li>Older versions of TypeScript did not fully polyfill promises and async/await. Downgrade your TypeScript version with <strong class="source-inline">npm i -D typescript@2</strong>, set your compilation target back to es5, and then try transpiling:<p class="source-code">npx tsc</p><p class="source-code">target.ts:1:18 - error TS2705: An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.</p><p class="source-code">1 const sayHello = async () =&gt; {</p><p class="source-code">                   ~~~~~~~~~~~~~</p><p class="source-code">target.ts:2:13 - error TS2693: 'Promise' only refers to a type, but is being used as a value here.</p><p class="source-code">2   await new Promise((resolve) =&gt;</p><p class="source-code">              ~~~~~~~</p><p class="source-code">target.ts:2:22 - error TS7006: Parameter 'resolve' implicitly has an 'any' type.</p><p class="source-code">2   await new Promise((resolve) =&gt;</p><p>It doesn't work.</p></li>
				<li>If you bump up to <strong class="source-inline">es6</strong>, it will still fail:<p class="source-code">% npx tsc</p><p class="source-code">target.ts:3:30 - error TS2345: Argument of type 'void' is not assignable to parameter of type '{} | PromiseLike&lt;{}&gt; | undefined'.</p><p class="source-code">3     setTimeout(() =&gt; resolve(console.log('Hello')))</p></li>
				<li>Install the latest version of TypeScript with <strong class="source-inline">npm i -D typescript@latest</strong> and then everything should work as before.</li>
			</ol>
			<p>This aspect of TypeScript can be confusing for newcomers. TypeScript will not provide a polyfill for missing promises, but it will provide transformations to syntax that is functionally equivalent.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor323"/>Choosing a Target</h2>
			<p>So how do we choose a compilation target? It's generally safe to use ES2017 or above unless you need to support outdated browsers, such as Internet Explorer, or deprecated Node.js versions. Sometimes, we have no choice but to support outdated browsers due to customer needs, but if we have any control over a Node.js runtime environment, it's advisable to update to a current, supported version. Doing this should allow us to use the latest TypeScript features.</p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor324"/>Syntax</h1>
			<p>The two new keywords, <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>, are often found together, but not always. Let's look at the syntax for each of them individually.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor325"/>async</h2>
			<p>The <strong class="source-inline">async</strong> keyword modifies a function. If a function declaration or function expression is used, it is placed before the <strong class="source-inline">function</strong> keyword. If an arrow function is used, the <strong class="source-inline">async</strong> keyword is placed before the argument list. Adding the <strong class="source-inline">async</strong> keyword to a function will cause the function to return a promise.</p>
			<p>For example:</p>
			<p class="source-code">function addAsync(num1: number, num2: number) {</p>
			<p class="source-code">  return num1 + num2;</p>
			<p class="source-code">}</p>
			<p>Just adding the <strong class="source-inline">async</strong> keyword to this simple function will make this function return a promise, which is now awaitable and thenable. Since there's nothing asynchronous in the function, the promise will resolve immediately.</p>
			<p>The arrow function version of this could be written as follows:</p>
			<p class="source-code">const addAsync = async (num1: number, num2: number) =&gt; num1 + num2;</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor326"/>Exercise 13.02: The async Keyword</h2>
			<p>This exercise illustrates how adding the <strong class="source-inline">async</strong> keyword to a function makes it return a promise:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/BgujE">https://packt.link/BgujE</a>.</p>
			<ol>
				<li value="1">Examine the <strong class="source-inline">async.ts</strong> file:<p class="source-code">export const fn = async () =&gt; {</p><p class="source-code">  return 'A Promise';</p><p class="source-code">};</p><p class="source-code">const result = fn();</p><p class="source-code">console.log(result);</p><p>You might expect this program to log out <strong class="source-inline">A Promise</strong>, but let's see what actually happens when we run it:</p><p class="source-code">npx ts-node async.ts</p><p class="source-code">Promise { 'A Promise' }</p></li>
				<li>The <strong class="source-inline">async</strong> keyword wrapped the response in a promise. We can confirm that by removing the keyword and running the program again:<p class="source-code">npx ts-node async.ts</p><p class="source-code">A Promise</p></li>
				<li>Modifying our function with <strong class="source-inline">async</strong> is exactly equivalent to wrapping it in a promise. If we wanted to use promise syntax, we could write the program like this:<p class="source-code">export const fn = () =&gt; {</p><p class="source-code">  return Promise.resolve('A Promise');</p><p class="source-code">};</p><p class="source-code">const result = fn();</p><p class="source-code">console.log(result);</p></li>
				<li>Again, running the program written this way will log out the unresolved promise:<p class="source-code">npx ts-node async.ts</p><p class="source-code">Promise { 'A Promise' }</p></li>
			</ol>
			<p>Since we're using TypeScript and return types can be inferred, modifying a function with <strong class="source-inline">async</strong> guarantees that TypeScript will always see the function as returning a promise.</p>
			<p>The <strong class="source-inline">async</strong> keyword causes the function it modifies to be wrapped in a promise. Whether you choose to do that explicitly by declaring a promise or by using the <strong class="source-inline">async</strong> keyword is often a matter of taste and style. </p>
			<p>How can we resolve an <strong class="source-inline">async</strong> function? We'll come to <strong class="source-inline">await</strong> in a moment, but what about using <strong class="source-inline">then</strong> and the promise chaining we learned about in <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>. Yes, that is also possible.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor327"/>Exercise 13.03: Resolving an async Function with then</h2>
			<p>This exercise will teach you how to resolve an <strong class="source-inline">async</strong> function using <strong class="source-inline">then</strong>:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/4Bo4c">https://packt.link/4Bo4c</a>.</p>
			<ol>
				<li value="1">Create a new file called <strong class="source-inline">resolve.async.ts</strong> and enter the following code:<p class="source-code">export const fn = async () =&gt; {</p><p class="source-code">  return 'A Promise';</p><p class="source-code">};</p><p class="source-code">const result = fn();</p><p class="source-code">result.then((message) =&gt; console.log(message));</p></li>
				<li>Execute this code by entering <strong class="source-inline">npx ts-node resolve.async.ts</strong> into your console and you'll see the expected text message logged, not an unresolved promise:<p class="source-code">A Promise</p></li>
			</ol>
			<p>Even though we never explicitly declared a promise object, the use of <strong class="source-inline">async</strong> has ensured that our function will always return a promise.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor328"/>await</h2>
			<p>The second half of this combo perhaps has greater value. The <strong class="source-inline">await</strong> keyword will attempt to resolve any promise before continuing. This will get us out of <strong class="source-inline">then</strong> chaining and allow us to write code that appears to be synchronous. One great benefit of using <strong class="source-inline">await</strong> is if we want to assign the result of an asynchronous call to some value and then do something with the value. Let's look at how that's done in a promise:</p>
			<p class="source-code">asyncFunc().then(result =&gt; {</p>
			<p class="source-code">  // do something with the result</p>
			<p class="source-code">});</p>
			<p>That can work fine and, in fact, this kind of syntax is used widely, but it breaks down a little if we need to do something tricky with chaining:</p>
			<p class="source-code">asyncFuncOne().then(resultOne =&gt; {</p>
			<p class="source-code">  asyncFuncTwo(resultOne).then(resultTwo =&gt; {</p>
			<p class="source-code">    asyncFuncThree(resultTwo).then(resultThree =&gt; {</p>
			<p class="source-code">      // do something with resultThree</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>But wait a minute. I thought promises were supposed to get rid of callback hell?! It's actually not that ideal for this kind of chaining. Let's try using <strong class="source-inline">await</strong> instead:</p>
			<p class="source-code">const resultOne = await asyncFuncOne();</p>
			<p class="source-code">const resultTwo = await asyncFuncTwo(resultOne);</p>
			<p class="source-code">const resultThree = await asyncFuncThree(resultTwo);</p>
			<p class="source-code">// do something with resultThree</p>
			<p>Most programmers would agree that this syntax is much cleaner and, in fact, this is one of the primary reasons why <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> were added to the language.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor329"/>Exercise 13.04: The await Keyword</h2>
			<p>This exercise will show you how to resolve a promise using <strong class="source-inline">await</strong>: </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/mUzGI">https://packt.link/mUzGI</a>.</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">await.ts</strong> and enter the following code:<p class="source-code">export const fn = async () =&gt; {</p><p class="source-code">  return 'A Promise';</p><p class="source-code">};</p><p class="source-code">const resolveIt = async () =&gt; {</p><p class="source-code">  const result = await fn();</p><p class="source-code">  console.log(result);</p><p class="source-code">};</p><p class="source-code">resolveIt();</p><p>Here we declare two <strong class="source-inline">async</strong> functions. One of them calls the other using <strong class="source-inline">await</strong> to resolve the promise and it should print out the string, rather than an unresolved promise. </p></li>
				<li>Run the file using <strong class="source-inline">npx</strong> <strong class="source-inline">ts-node</strong> <strong class="source-inline">await.ts</strong> and you should see the following output:<p class="source-code">A Promise</p></li>
			</ol>
			<p>Why did we need to wrap <strong class="source-inline">await</strong> in a second function? That is because normally, <strong class="source-inline">await</strong> cannot be used outside of an <strong class="source-inline">async</strong> function. We'll discuss the top-level <strong class="source-inline">await</strong> feature later in this chapter, which is an exception to this rule. What about mixing <strong class="source-inline">await</strong> with promises? This can certainly be done. </p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor330"/>Exercise 13.05: Awaiting a Promise</h2>
			<p>This exercise teaches you how you can use <strong class="source-inline">await</strong> with promises:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/mMDiw">https://packt.link/mMDiw</a>.</p>
			<ol>
				<li value="1">Create a new file called <strong class="source-inline">await-promise.ts</strong> and enter the following code:<p class="source-code">export const resolveIt = async () =&gt; {</p><p class="source-code">  const result = await Promise.resolve('A Promise');</p><p class="source-code">  console.log(result);</p><p class="source-code">};</p><p class="source-code">resolveIt();</p></li>
				<li>Execute the code by entering <strong class="source-inline">npx ts-node await-promise.ts</strong> and you'll see the text output:<p class="source-code">A Promise</p></li>
				<li>A longer way to write this same code with a more explicit promise declaration would be:<p class="source-code">export const resolveIt = async () =&gt; {</p><p class="source-code">  const p = new Promise((resolve) =&gt; resolve('A Promise'));</p><p class="source-code">  const result = await p;</p><p class="source-code">  console.log(result);</p><p class="source-code">};</p><p class="source-code">resolveIt();</p><p>This code functions exactly the same:</p></li>
				<li>Enter <strong class="source-inline">npx ts-node src/await-promise.ts</strong> to verify that you get the following output:<p class="source-code">A Promise</p></li>
			</ol>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor331"/>Syntactic Sugar</h2>
			<p>The preceding exercises on <strong class="source-inline">async</strong> functions and promises are simply two different ways of expressing the exact same operation in TypeScript. Likewise, using <strong class="source-inline">await</strong> and resolving a promise with <strong class="source-inline">then</strong> are equivalent. The <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords are what's known as "syntactic sugar," or code structures that enable more expressive syntax without changing the behavior of the program.</p>
			<p>This means it is possible and, at times, even advisable to mix <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax with promises. A very common reason for doing this would be because you are working with a library that was written to use promises, but you prefer <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax. Another reason for mixing the two would be to handle exceptions more explicitly. We'll deal with exception handling in detail later in this chapter.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor332"/>Exception Handling</h1>
			<p>We've been over how to turn <strong class="source-inline">then</strong> chaining into <strong class="source-inline">await</strong>, but what about <strong class="source-inline">catch</strong>? If a promise is rejected, the error will bubble up and must be caught in some way. Failing to catch an exception in the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> world is just as damaging as failing to catch a promise rejection. In fact, it's exactly the same and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> is just syntactic sugar on top of promises.</p>
			<p>Failing to handle a rejected promise can lead to system failure where a program running in a web browser crashes, resulting in blank pages or broken functionality, thereby driving users away from your site. A failure to handle a rejected promise on the server side may cause a Node.js process to exit and a server to crash. Even if you have a self-healing system that attempts to bring your server back online, whatever job you were attempting to complete will have failed and frequently repeated restarts will make your infrastructure more expensive to run.</p>
			<p>The most straightforward way to handle these errors is with <strong class="source-inline">try</strong> and <strong class="source-inline">catch</strong> blocks. This syntax is not unique to <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> and has been part of the ECMAScript specification since ECMAScript3. It is very simple and straightforward to use:</p>
			<p class="source-code">try {</p>
			<p class="source-code">  await someAsync();</p>
			<p class="source-code">} catch (e) {</p>
			<p class="source-code">  console.error(e);</p>
			<p class="source-code">}</p>
			<p>Just as you can catch an error thrown from any of several chained promises, you can implement a similar pattern here:</p>
			<p class="source-code">try {</p>
			<p class="source-code">  await someAsync();</p>
			<p class="source-code">  await anotherAsync();</p>
			<p class="source-code">  await oneMoreAsync();</p>
			<p class="source-code">} catch (e) {</p>
			<p class="source-code">  console.error(e);</p>
			<p class="source-code">}</p>
			<p>There may be cases where finer-grained exception handling is required. It is possible to nest these structures:</p>
			<p class="source-code">try {</p>
			<p class="source-code">  await someAsync();</p>
			<p class="source-code">  try {</p>
			<p class="source-code">    await anotherAsync();</p>
			<p class="source-code">  } catch (e) {</p>
			<p class="source-code">    // specific handling of this error</p>
			<p class="source-code">  }</p>
			<p class="source-code">  await oneMoreAsync();</p>
			<p class="source-code">} catch (e) {</p>
			<p class="source-code">  console.error(e);</p>
			<p class="source-code">}</p>
			<p>However, writing code such as this negates most of the benefits of the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax. A better solution would be to throw specific error messages and test for them:</p>
			<p class="source-code">try {</p>
			<p class="source-code">  await someAsync();</p>
			<p class="source-code">  await anotherAsync();</p>
			<p class="source-code">  await oneMoreAsync();</p>
			<p class="source-code">} catch (e) {</p>
			<p class="source-code">  if(e instanceOf MyCustomError) {</p>
			<p class="source-code">    // some custom handling</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    console.error(e);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>With this technique, we can handle everything in the same block and avoid nesting and messy-looking code structures.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor333"/>Exercise 13.06: Exception Handling</h2>
			<p>Let's see how we can implement error handling in a simple example. In this exercise, we will intentionally and explicitly throw an error from an <strong class="source-inline">async</strong> function and see how that implements the operation of our program:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/wbA8E">https://packt.link/wbA8E</a>.</p>
			<ol>
				<li value="1">Start by creating a new file called <strong class="source-inline">error.ts</strong> and entering the following code:<p class="source-code">export const errorFn = async () =&gt; {</p><p class="source-code">  throw new Error('An error has occurred!');</p><p class="source-code">};</p><p class="source-code">const asyncFn = async () =&gt; {</p><p class="source-code">  await errorFn();</p><p class="source-code">};</p><p class="source-code">asyncFn();</p></li>
				<li>This program will, of course, always throw an error. When we execute it by entering <strong class="source-inline">npx ts-node error.ts</strong> into the console, we can see quite clearly that the error is not being handled properly:<p class="source-code">(node:29053) UnhandledPromiseRejectionWarning: Error: An error has occurred!</p><p class="source-code">    at Object.exports.errorFn (/workshop/async-chapter/src/error.ts:2:9)</p><p class="source-code">    at asyncFn (/workshop/async-chapter/src/error.ts:6:9)</p><p class="source-code">    at Object.&lt;anonymous&gt; (/workshop/async-chapter/src/error.ts:9:1)</p><p class="source-code">    at Module._compile (internal/modules/cjs/loader.js:1138:30)</p><p class="source-code">    at Module.m._compile (/workshop/async-chapter/node_modules/ts-node/src/index.ts:858:23)</p><p class="source-code">    at Module._extensions..js (internal/modules/cjs/loader.js:1158:10)</p><p class="source-code">    at Object.require.extensions.&lt;computed&gt; [as .ts] (/workshop/async-chapter/node_modules/ts-node/src/index.ts:861:12)</p><p class="source-code">    at Module.load (internal/modules/cjs/loader.js:986:32)</p><p class="source-code">    at Function.Module._load (internal/modules/cjs/loader.js:879:14)</p><p class="source-code">    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12)</p><p class="source-code">(node:29053) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 2)</p><p class="source-code">(node:29053) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</p><p>Notice the deprecation warning. Not only is this an ugly stack trace, at some point in the future, exceptions such as this one will cause the Node.js process to exit. We clearly need to handle this exception!</p></li>
				<li>Fortunately, we can do so by simply surrounding the call with <strong class="source-inline">try</strong> and <strong class="source-inline">catch</strong>:<p class="source-code">export const errorFn = async () =&gt; {</p><p class="source-code">  throw new Error('An error has occurred!');</p><p class="source-code">};</p><p class="source-code">const asyncFn = async () =&gt; {</p><p class="source-code">  try {</p><p class="source-code">    await errorFn();</p><p class="source-code">  } catch (e) {</p><p class="source-code">    console.error(e);</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">asyncFn();</p></li>
				<li>Now, when we execute the program, we get a more orderly exception and stack trace logged:<p class="source-code">Error: An error has occurred!</p><p class="source-code">    at Object.exports.errorFn (/workshop/async-chapter/src/error.ts:2:9)</p><p class="source-code">    at asyncFn (/workshop/async-chapter/src/error.ts:7:11)</p><p class="source-code">    at Object.&lt;anonymous&gt; (/workshop/async-chapter/src/error.ts:13:1)</p><p class="source-code">    at Module._compile (internal/modules/cjs/loader.js:1138:30)</p><p class="source-code">    at Module.m._compile (/workshop/node_modules/ts-node/src/index.ts:858:23)</p><p class="source-code">    at Module._extensions..js (internal/modules/cjs/loader.js:1158:10)</p><p class="source-code">    at Object.require.extensions.&lt;computed&gt; [as .ts] (/workshop/node_modules/ts-node/src/index.ts:861:12)</p><p class="source-code">    at Module.load (internal/modules/cjs/loader.js:986:32)</p><p class="source-code">    at Function.Module._load (internal/modules/cjs/loader.js:879:14)</p><p class="source-code">    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12)</p><p>Of course, that message only appears because we explicitly logged it out. We could instead choose to throw a default value or perform some other operation instead of logging the error. </p></li>
				<li>It's always a good idea to log an error if the system isn't behaving correctly, but depending on your system requirements, you might instead write something like this:<p class="source-code">const primaryFn = async () =&gt; {</p><p class="source-code">  throw new Error('Primary System Offline!');</p><p class="source-code">};</p><p class="source-code">const secondaryFn = async () =&gt; {</p><p class="source-code">  console.log('Aye aye!');</p><p class="source-code">};</p><p class="source-code">const asyncFn = async () =&gt; {</p><p class="source-code">  try {</p><p class="source-code">    await primaryFn();</p><p class="source-code">  } catch (e) {</p><p class="source-code">    console.warn(e);</p><p class="source-code">    secondaryFn();</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">asyncFn();</p><p>In this case, we just throw a warning and fall back to the secondary system because this program was designed to be fault-tolerant. It's still a good idea to log the warning so that we can trace how our system is behaving. One more variation of this for now. </p></li>
				<li>Let's put our <strong class="source-inline">try</strong> and <strong class="source-inline">catch</strong> blocks at the top level and rewrite our program like this:<p class="source-code">export const errorFN = async () =&gt; {</p><p class="source-code">  throw new Error('An error has occurred!');</p><p class="source-code">};</p><p class="source-code">const asyncFn = async () =&gt; {</p><p class="source-code">  await errorFN();</p><p class="source-code">};</p><p class="source-code">try {</p><p class="source-code">  asyncFn();</p><p class="source-code">} catch (e) {</p><p class="source-code">  console.error(e);</p><p class="source-code">}</p></li>
				<li>This is the output that you get:<p class="source-code">Error: Primary System Offline!</p><p class="source-code">    at primaryFn (C:\Users\Mahesh\Documents\Chapter13_TypeScript\Exercise13.06\error-secondary.ts:2:9)</p><p class="source-code">    at asyncFn (C:\Users\Mahesh\Documents\Chapter13_TypeScript\Exercise13.06\error-secondary.ts:11:11)</p><p class="source-code">    at Object.&lt;anonymous&gt; (C:\Users\Mahesh\Documents\Chapter13_TypeScript\Exercise13.06\error-secondary.ts:18:1)</p><p class="source-code">    at Module._compile (internal/modules/cjs/loader.js:1063:30)</p><p class="source-code">    at Module.m._compile (C:\Users\Mahesh\AppData\Roaming\npm-cache\_npx\13000\node_modules\ts-node\src\index.ts:1056:23)       </p><p class="source-code">    at Module._extensions..js (internal/modules/cjs/loader.js:1092:10)</p><p class="source-code">    at Object.require.extensions.&lt;computed&gt; [as .ts] (C:\Users\Mahesh\AppData\Roaming\npm-cache\_npx\13000\node_modules\ts-node\src\index.ts:1059:12)</p><p class="source-code">    at Module.load (internal/modules/cjs/loader.js:928:32)</p><p class="source-code">    at Function.Module._load (internal/modules/cjs/loader.js:769:14)</p><p class="source-code">    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)</p><p class="source-code">Aye aye!</p><p>You may assume that the program might work the same as putting <strong class="source-inline">try</strong> and <strong class="source-inline">catch</strong> inside <strong class="source-inline">asyncFn</strong>, but actually, it will behave the same as no error handling at all. That's because we aren't awaiting the function inside the <strong class="source-inline">try</strong> block. </p></li>
			</ol>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor334"/>Top-Level await</h1>
			<p>Top-level <strong class="source-inline">await</strong> is a feature that allows the use of the <strong class="source-inline">await</strong> keyword at the module level, outside of any function. This allows a number of interesting patterns, such as waiting for a dependency to fully load by calling an asynchronous function before attempting to use it. Someday, top-level <strong class="source-inline">await</strong> may support some very exciting functional programming paradigms, but at the time of writing, it is still technically in preview mode, and so is not ready for widespread use. You may be reading this book at a time when top-level <strong class="source-inline">await</strong> is widely available and supported, and if so, you should definitely give it a look!</p>
			<p>Writing code with top-level <strong class="source-inline">await</strong> is very straightforward. Here is a very short program that attempts to make use of it:</p>
			<p class="source-code">export const fn = async () =&gt; {</p>
			<p class="source-code">  return 'awaited!';</p>
			<p class="source-code">};</p>
			<p class="source-code">console.log(await fn());</p>
			<p>This looks fine. Now let's see what happens when we try to execute it:</p>
			<p class="source-code">⨯ Unable to compile TypeScript:</p>
			<p class="source-code">src/top-level-await.ts:5:13 - error TS1378: Top-level 'await' expressions are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.</p>
			<p class="source-code">5 console.log(await fn());</p>
			<p class="source-code">              ~~~~~</p>
			<p>It's not supported, but it gives me some pointers. How can we make this work?</p>
			<p>Top-level <strong class="source-inline">await</strong> requires NodeJS 14.8 or greater. This version of NodeJS entered LTS (long-term service) in October of 2020 and so is still new at the time of this writing. You can check your NodeJS version on the command line with <strong class="source-inline">node -v</strong>. If you aren't running version 14.8 or greater, there are some good utilities like <strong class="source-inline">nvm</strong> and <strong class="source-inline">n</strong> that will allow you to switch your version easily.</p>
			<p>That, however, doesn't fix the problem. It seems that I will need to change my <strong class="source-inline">tsconfig.json</strong> <strong class="source-inline">target</strong> property to <strong class="source-inline">es2017</strong> or higher and set the <strong class="source-inline">module</strong> property to <strong class="source-inline">esnext</strong>. Adding the <strong class="source-inline">module</strong> property means that I want to use ES modules, which is a relatively new way to handle modules and is beyond the scope of this book. To enable ES modules, I need to set the <strong class="source-inline">type</strong> property in my <strong class="source-inline">package.json</strong> file to <strong class="source-inline">module</strong>.</p>
			<p>Now I've updated a couple of JSON files and am ready to try again:</p>
			<p class="source-code">TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension ".ts" for /workshop/async-chapter/src/top-level-await.ts</p>
			<p class="source-code">    at Loader.defaultGetFormat [as _getFormat] (internal/modules/esm/get_format.js:65:15)</p>
			<p class="source-code">    at Loader.getFormat (internal/modules/esm/loader.js:113:42)</p>
			<p class="source-code">    at Loader.getModuleJob (internal/modules/esm/loader.js:243:31)</p>
			<p class="source-code">    at Loader.import (internal/modules/esm/loader.js:177:17)</p>
			<p>It still isn't working. I'll need to do one more thing to make this work, and that is to enable the experimental feature in Node.js and instruct TS Node to allow <strong class="bold">ES modules</strong> (<strong class="bold">esm</strong>). This requires a longer command:</p>
			<p class="source-code">node --loader ts-node/esm.mjs top.ts</p>
			<p class="source-code">(node:91445) ExperimentalWarning: --experimental-loader is an experimental feature. This feature could change at any time</p>
			<p class="source-code">(Use `node --trace-warnings ...` to show where the warning was created)</p>
			<p class="source-code">awaited! </p>
			<p>But it works. Top-level <strong class="source-inline">await</strong> will likely become much easier and more intuitive to work with in the months and years ahead, so make sure to check the latest documentation for your runtime.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor335"/>Promise Methods</h1>
			<p>In addition to the standard <strong class="source-inline">next</strong> and <strong class="source-inline">catch</strong> methods exposed by promises, there are a number of other convenience methods, such as <strong class="source-inline">all</strong>, <strong class="source-inline">allSettled</strong>, <strong class="source-inline">any</strong>, and <strong class="source-inline">race</strong>, that make working with promises nicer. How can they be used in the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> world? They can actually work together quite nicely. For example, here is a use of <strong class="source-inline">Promise.all</strong> that employs <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong>. Given three promises, <strong class="source-inline">p1</strong>, <strong class="source-inline">p2</strong>, and <strong class="source-inline">p3</strong>:</p>
			<p class="source-code">Promise.all([p1, p2, p3])</p>
			<p class="source-code">  .then(values =&gt; console.log(values))</p>
			<p class="source-code">  .catch(e =&gt; console.error(e));</p>
			<p>There isn't any kind of <strong class="source-inline">awaitAll</strong> operator, so if we want to execute our promises in parallel, we're still going to need to use <strong class="source-inline">Promise.all</strong>, but we can avoid chaining <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong> if we choose to:</p>
			<p class="source-code">try {</p>
			<p class="source-code">  const values = await Promise.all([p1, p2, p3]);</p>
			<p class="source-code">  console.log(values);</p>
			<p class="source-code">} catch (e) {</p>
			<p class="source-code">  console.error(e);</p>
			<p class="source-code">}</p>
			<p>In this case, we might feel like the code isn't improved by the addition of <strong class="source-inline">await</strong>, since we've actually expanded it from three lines to six. Some may find this form more readable. As always, it's a matter of personal or team preference.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor336"/>Exercise 13.07: async/await in Express.js</h2>
			<p>In this exercise, we will build a small web application using the popular Express framework. Although Express was written for the JavaScript language, typings have been published for it and it is fully usable with TypeScript. Express is an unopinionated, minimalist framework for building web applications. It's one of the oldest and most popular frameworks in use today.</p>
			<p>For our simple application, we'll start a web server on port <strong class="source-inline">8888</strong> and accept <strong class="source-inline">GET</strong> requests. If that request has a <strong class="source-inline">name</strong> parameter in the query string, we will log the name in a file called <strong class="source-inline">names.txt</strong>. Then we'll greet the user. If there's no name in the query string, we log nothing and print out <strong class="source-inline">Hello World!</strong>:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/cG4r8">https://packt.link/cG4r8</a>.</p>
			<p>Let's get started by installing the Express framework and typings. </p>
			<ol>
				<li value="1">Enter <strong class="source-inline">npm i express</strong> to install Express as a dependency and <strong class="source-inline">npm i -D @types/express @types/node</strong> to install the typings that we'll need to support TypeScript. <p>Remember the <strong class="source-inline">-D</strong> flag means that it's a <strong class="source-inline">devDependency</strong> that can be managed differently from a production dependency, although its use is optional.</p></li>
				<li>With our dependencies installed, let's create a file called <strong class="source-inline">express.ts</strong>. The first thing to do is import <strong class="source-inline">express</strong>, create the app, add a simple handler, and listen on port <strong class="source-inline">8888</strong>:<p class="source-code">import express, { Request, Response } from 'express';</p><p class="source-code">const app = express();</p><p class="source-code">app.get('/', (req: Request, res: Response) =&gt; {</p><p class="source-code">  res.send('OK');</p><p class="source-code">});</p><p class="source-code">app.listen(8888);</p><p>This looks very much like your standard starter Express app, other than we're giving types to the <strong class="source-inline">Request</strong> and <strong class="source-inline">Response</strong> objects. This is already enormously useful as we'll be able to use IntelliSense and ascertain what methods we can call on those objects without having to look them up.</p><p>Our requirements say that we need to listen for a <strong class="source-inline">name</strong> parameter in the query string. We might see a request that looks like <strong class="source-inline">http://localhost:8888/?name=Matt</strong>, to which we should respond <strong class="source-inline">Hello Matt!</strong>.</p><p>The query string is in the <strong class="source-inline">Request</strong> object. If we delve into the typings, it is typed as follows:</p><p class="source-code">interface ParsedQs { [key: string]: undefined | string | string[] | ParsedQs | ParsedQs[] }</p><p>This basically means that it is a hash of key/value pairs and nested key/value pairs. In our case, we would expect to see a query object that looks like <strong class="source-inline">{ name: 'Matt' }</strong>. Thus, we can get the <strong class="source-inline">name</strong> attribute by using <strong class="source-inline">const { name } = req.query;</strong>. Then we can respond to the request with something like <strong class="source-inline">res.send(`Hello ${name ?? 'World'}!`);</strong>. In this case, we're using the nullish coalesce operator (<strong class="source-inline">??</strong>) to say that we'll fall back to the <strong class="source-inline">World</strong> string if the <strong class="source-inline">name</strong> variable has a nullish (null or undefined) value. We could also use the fallback or logical OR operator, <strong class="source-inline">||</strong>.</p></li>
				<li>The updated code now looks like this:<p class="source-code">import express, { Request, Response } from 'express';</p><p class="source-code">const app = express();</p><p class="source-code">app.get('/', (req: Request, res: Response) =&gt; {</p><p class="source-code">  const { name } = req.query;</p><p class="source-code">  res.send(`Hello ${name ?? 'World'}!`);</p><p class="source-code">});</p><p class="source-code">app.listen(8888);</p></li>
				<li>One requirement is still missing. We need to log the name to a file if it exists. To do that, we'll need to use the <strong class="source-inline">fs</strong> library from Node.js. We'll also use the <strong class="source-inline">path</strong> library to resolve a path to the file we want to write to. First, add the new imports:<p class="source-code">import { promises } from 'fs';</p><p class="source-code">import { resolve } from 'path';</p></li>
				<li>Now we'll use the <strong class="source-inline">promises</strong> API from <strong class="source-inline">fs</strong> to asynchronously write to our log file. Since this is a log, we want to append to it, not overwrite it on each request. We'll use <strong class="source-inline">appendFile</strong> and write the name along with a newline character. We want this operation to repeat before returning:<p class="source-code">  if (name) {</p><p class="source-code">    await promises.appendFile(resolve(__dirname, 'names.txt'), `${name}\n`);</p><p class="source-code">  }</p><p>That's almost it, but we should have a warning by now that our handler function isn't properly async. All we need to do is add the <strong class="source-inline">async</strong> keyword to it. </p></li>
				<li>The completed code looks like this:<p class="source-code">import express, { Request, Response } from 'express';</p><p class="source-code">import { promises } from 'fs';</p><p class="source-code">import { resolve } from 'path';</p><p class="source-code">const app = express();</p><p class="source-code">app.get('/', async (req: Request, res: Response) =&gt; {</p><p class="source-code">  const { name } = req.query;</p><p class="source-code">  if (name) {</p><p class="source-code">    await promises.appendFile(resolve(__dirname, 'names.txt'), `${name}\n`);</p><p class="source-code">  }</p><p class="source-code">  res.send(`Hello ${name ?? 'World'}!`);</p><p class="source-code">});</p><p class="source-code">app.listen(8888);</p></li>
				<li>Run the program with <strong class="source-inline">npx ts-node express.ts</strong> and try hitting the URL at <strong class="source-inline">http://localhost:8888?name=your_name</strong> a few times. Try hitting that URL with different names and watch your log file increment. Here are a few examples.</li>
				<li>The following is the browser output for your_name:<div id="_idContainer156" class="IMG---Figure"><img src="image/B14508_13_01.jpg" alt="Figure 13.1: Browser message for name = your_name&#13;&#10;"/></div><p class="figure-caption">Figure 13.1: Browser message for name = your_name</p></li>
				<li>The following is the browser output for Matt:<div id="_idContainer157" class="IMG---Figure"><img src="image/B14508_13_02.jpg" alt="Figure 13.2: Browser message for name = Matt&#13;&#10;"/></div><p class="figure-caption">Figure 13.2: Browser message for name = Matt</p></li>
				<li>The following is the browser output for Albert Einstein:</li>
			</ol>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B14508_13_03.jpg" alt="Figure 13.3: Browser message for name = Albert Einstein&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3: Browser message for name = Albert Einstein</p>
			<p>The <strong class="source-inline">names.txt</strong> file will increment as follows:</p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B14508_13_04.jpg" alt="Figure 13.4: Log file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Log file</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor337"/>Exercise 13.08: NestJS</h2>
			<p>In contrast to Express, NestJS is a highly opinionated and fully featured framework for building TypeScript applications. NestJS can be used to quickly bootstrap an application. It provides out-of-the-box support for middleware, GraphQL, and Websockets. It ships with ESLint, a dependency injection framework, a test framework, and many other useful things. Some developers really enjoy working with such a full-featured framework and others find all the boilerplate oppressive and prefer to work with something more bare-bones, such as Express:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/blRq3">https://packt.link/blRq3</a>.</p>
			<p>Let's bootstrap a new NestJS application and give it a closer look.</p>
			<ol>
				<li value="1">NestJS applications can be generated by a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) that can be installed via <strong class="source-inline">npm</strong>. Install that package globally:<p class="source-code">npm i -g @nestjs/cli</p></li>
				<li>When we use the CLI, it will generate a project by creating a new directory inside the directory we entered the command into, so you may want to change the directory to where you store your projects. Then, generate the project:<p class="source-code">nest new async-nest</p><p>Here the project is named <strong class="source-inline">async-nest</strong>. You can name it differently. NestJS will automatically install all dependencies and bootstrap a bare-bones application. </p></li>
				<li>Change directory into your new application and start looking at the code. If you pop open <strong class="source-inline">main.ts</strong>, you'll see <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> already in use. That module will look something like this:<p class="source-code">import { NestFactory } from '@nestjs/core';</p><p class="source-code">import { AppModule } from './app.module';</p><p class="source-code">async function bootstrap() {</p><p class="source-code">  const app = await NestFactory.create(AppModule);</p><p class="source-code">  await app.listen(3000);</p><p class="source-code">}</p><p class="source-code">bootstrap();</p><p>NestJS is built on top of Express. This code will create a new Express application. The internals of Express are not exposed to you as you write NestJS code, but you always have the option to drop down to them if you need something not supported by NestJS.</p><p>Let's go over a few useful commands that you can start using immediately. If you type <strong class="source-inline">npm test</strong> (or <strong class="source-inline">npm t</strong>), you'll launch a test run by the Jest framework. This test launches an instance of your application, invokes it, and then shuts it down after verifying the expected response was received. NestJS ships with fixtures that allow a light version of your app to be tested.</p><p>It's a great idea to continue adding unit and integration tests to your app as you work on it. TypeScript can help you ensure code correctness, but only tests will guarantee that your app is behaving as it should.</p><p>Another useful command is <strong class="source-inline">npm run lint</strong>. This will check your code style and notify you of any issues with it by using the popular ESLint library.</p></li>
				<li>Finally, you can type <strong class="source-inline">npm run start:dev</strong> to run the development server in watch mode, which means the server will restart whenever you change a file. </li>
				<li>Try running that now and navigate to <strong class="source-inline">http://localhost:3000</strong> and you'll see the <strong class="source-inline">Hello World</strong> message. If you open the file called <strong class="source-inline">app.service.ts</strong> and change the message returned there, you can just refresh your browser and you should see the message change.<p>Now that we've seen this simple Hello World app done in two very different frameworks, let's add the same greeting and logging functionality that we did in <em class="italic">Exercise 13.07: async/await in Express.js</em>.</p></li>
				<li>To add the custom greeting based on the query param, let's open two files, <strong class="source-inline">app.controller.ts</strong> and <strong class="source-inline">app.service.ts</strong>. Notice that <strong class="source-inline">app.service.ts</strong> implements a <strong class="source-inline">getHello</strong> function that returns the string "Hello World!". We will need to change this function to accept a <strong class="source-inline">name</strong> argument.</li>
				<li>Add the <strong class="source-inline">name</strong> argument with the <strong class="source-inline">string</strong> type to the function's argument list, and then change the return to a string template and say Hello. You'll have something like this:<p class="source-code">export class AppService {</p><p class="source-code">  getHello(name: string): string {</p><p class="source-code">    return `Hello ${name}!`;</p><p class="source-code">  }</p><p class="source-code">}</p><p>This is a simple refactor. If we check <strong class="source-inline">app.controller.ts</strong>, we'll see that our IDE is now telling us that <strong class="source-inline">getHello</strong> needs an argument and we're not done yet.</p><p>In the Express application, we found our query parameter on the built-in <strong class="source-inline">Request</strong> object. You could do the same thing in NestJS, but it's more common and preferable to use a decorator. Decorators are special functions that wrap other functions. They are sometimes called higher-order functions and are similar to aspects of languages such as Java.</p><p>The decorator we want to use is <strong class="source-inline">@Query</strong>, which takes an argument of the name of the query parameter and then binds that parameter to one of our function arguments. </p></li>
				<li>We can import that decorator from <strong class="source-inline">@nestjs/common</strong>. Then we add the function argument to <strong class="source-inline">getHello</strong> and pass it through to the service call. One more thing that's a good idea is to set a default so that we maintain backward compatibility and don't print out <strong class="source-inline">Hello undefined</strong> if we fail to give an argument. Adding the default may prompt a hint that you no longer need the type annotation as it is trivially inferred from the default type. Go ahead and remove it if you like:<p class="source-code">import { Controller, Get, Query } from '@nestjs/common';</p><p class="source-code">import { AppService } from './app.service';</p><p class="source-code">@Controller()</p><p class="source-code">export class AppController {</p><p class="source-code">  constructor(private readonly appService: AppService) {}</p><p class="source-code">  @Get()</p><p class="source-code">  getHello(@Query('name') name: string = 'World'): string {</p><p class="source-code">    return this.appService.getHello(name);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>The dev server should restart and now, if we browse to <strong class="source-inline">http://localhost:3000/?name=Matt</strong>, we'll see <strong class="source-inline">Hello Matt!</strong>:<div id="_idContainer160" class="IMG---Figure"><img src="image/B14508_13_05.jpg" alt="Figure 13.5: Browser message for name = Matt&#13;&#10;"/></div><p class="figure-caption">Figure 13.5: Browser message for name = Matt</p></li>
				<li>Now let's add the same logging functionality that we implemented in Express.<p>In a full-scale application, we'd probably want to build a separate logging service class. For our purposes, we can implement that as a separate <strong class="source-inline">async</strong> method. Add the method to <strong class="source-inline">app.service.ts</strong> and call it with <strong class="source-inline">await</strong> from <strong class="source-inline">getHello</strong>. Test it to be sure that it's working correctly. </p><p>There are a few gotchas here. One is that NestJS is automatically transpiling and serving your code from a folder called <strong class="source-inline">dist</strong>, so you'll find your <strong class="source-inline">names.txt</strong> file in there once you start logging names. But the bigger trick here is that in order to await the logging, we need to make <strong class="source-inline">getHello</strong> in <strong class="source-inline">app.service.ts</strong> into an <strong class="source-inline">async</strong> method. This, in turn, will mean that <strong class="source-inline">getHello</strong> in <strong class="source-inline">app.controller.ts</strong> must also be <strong class="source-inline">async</strong>. What will changing these methods to <strong class="source-inline">async</strong> do to our app? Nothing! NestJS already knows how to resolve the promises before returning the request.</p></li>
				<li>One more thing to check out in this exercise is the unit test. Since we've set a default value for the <strong class="source-inline">name</strong> attribute, the test should still work, right? Well actually, it doesn't. Try running <strong class="source-inline">npm test</strong> and you'll see the problem. The issue is that the test isn't expecting <strong class="source-inline">getHello</strong> to be async. That's OK. We can fix it by making the test callback <strong class="source-inline">async</strong> to look like this:<p class="source-code">  describe('root', () =&gt; {</p><p class="source-code">    it('should return "Hello World!"', async () =&gt; {</p><p class="source-code">      expect(await appController.getHello()).toBe('Hello World!');</p><p class="source-code">    });</p><p class="source-code">  });</p><p>The test should now pass. Try adding another test with an argument.</p></li>
			</ol>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor338"/>Exercise 13.09: TypeORM</h2>
			<p>TypeORM is an object relational mapper written in, and for, TypeScript. TypeORM supports many popular databases, such as MySQL, Postgres, SQL Server, SQLite, and even MongoDB and Oracle. TypeORM is often used in NestJS applications, so in this exercise we will add a local in-memory SQLite database to work with our NestJS application.</p>
			<p>In this exercise, you will build another REST service to help us keep track of the promises we make. Since <strong class="source-inline">Promise</strong> is the name of a built-in object in TypeScript, let's use the term "pledge" so we can differentiate domain concepts from language abstractions:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/ZywYh">https://packt.link/ZywYh</a>.</p>
			<ol>
				<li value="1">To get started, let's bootstrap a new NestJS project:<p class="source-code">nest new typeorm-nest</p></li>
				<li>NestJS has a powerful module system that lets us build out different functional areas of our application in cohesive chunks. Let's create a new module for pledges:<p class="source-code">nest g module pledge</p><p>This command will generate a new module under the <strong class="source-inline">/pledge</strong> subdirectory. </p></li>
				<li>We're also going to need a controller and a service for the pledge API, so let's generate those using the NestJS CLI:<p class="source-code">nest g controller pledge</p><p class="source-code">nest g service pledge</p></li>
				<li>Finally, we need to install the <strong class="source-inline">typeorm</strong> library, SQLite3, and NestJS integration:<p class="source-code">npm i @nestjs/typeorm sqlite3 typeorm</p><p>TypeORM maps database tables to TypeScript entities by means of decorators on plain objects. </p></li>
				<li>Let's create <strong class="source-inline">pledge.entity.ts</strong> under <strong class="source-inline">/pledge</strong> and create our first entity:<p class="source-code">import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';</p><p class="source-code">@Entity()</p><p class="source-code">export class Pledge {</p><p class="source-code">  @PrimaryGeneratedColumn()</p><p class="source-code">  id: number;</p><p class="source-code">  @Column()</p><p class="source-code">  desc: string;</p><p class="source-code">  @Column()</p><p class="source-code">  kept: boolean;</p><p class="source-code">}</p><p>For this entity, we're using a few specialized decorators, such as <strong class="source-inline">PrimaryGeneratedColumn</strong>. These decorators can be very powerful but often rely on underlying database functionality. Because SQLite can generate an ID for our table, TypeORM is able to expose that in a declarative way with a decorator, but if it couldn't, this wouldn't work. It's always good to check the documentation before proceeding with a new implementation.</p><p>Now that we have an entity, we need to provide configuration to TypeORM about what our database is and where to find it, as well as what entities we want to map. For databases such as MySQL and Postgres, this might include a URI as well as database credentials. Since SQLite is a file-based database, we will just provide the name of the file we want to write.</p><p>Note that production database credentials should always be handled safely, and the best practices for doing so are beyond the scope of this book, but suffice to say that they shouldn't be checked into your version control.</p></li>
				<li>Let's configure our application to use SQLite. We want to configure TypeORM at the root of our application, so let's import the module into <strong class="source-inline">app.module.ts</strong>:<p class="source-code">    TypeOrmModule.forRoot({</p><p class="source-code">      type: 'sqlite',</p><p class="source-code">      database: 'db',</p><p class="source-code">      entities: [Pledge],</p><p class="source-code">      synchronize: true,</p><p class="source-code">    }),</p></li>
				<li>Doing this will require a couple of more imports at the top of the module:<p class="source-code">import { TypeOrmModule } from '@nestjs/typeorm';</p><p class="source-code">import { Pledge } from './pledge/pledge.entity';</p><p>We're letting NestJS know that our application will use a SQLite database and will manage the <strong class="source-inline">Pledge</strong> entity. By setting <strong class="source-inline">synchronize: true</strong>, we are telling TypeORM to automatically create any entities that don't already exist in the database when the application starts. This setting should NOT be used in production as it may cause data loss. TypeORM supports migrations for managing databases in production environments, another topic beyond the scope of this book.</p></li>
				<li>If we start our application now with <strong class="source-inline">npm run start:dev</strong>, it will start up and we'll get a new binary file (the SQLite database) called <strong class="source-inline">db</strong>.</li>
				<li>Before we can use the <strong class="source-inline">Pledge</strong> entity in our new module, we need to do a little more boilerplate. Open up <strong class="source-inline">pledge.module.ts</strong> and add an import so that the module looks like this:<p class="source-code">import { Module } from '@nestjs/common';</p><p class="source-code">import { TypeOrmModule } from '@nestjs/typeorm';</p><p class="source-code">import { PledgeController } from './pledge.controller';</p><p class="source-code">import { Pledge } from './pledge.entity';</p><p class="source-code">import { PledgeService } from './pledge.service';</p><p class="source-code">@Module({</p><p class="source-code">  controllers: [PledgeController],</p><p class="source-code">  imports: [TypeOrmModule.forFeature([Pledge])],</p><p class="source-code">  providers: [PledgeService],</p><p class="source-code">})</p><p class="source-code">export class PledgeModule {}</p><p>This will allow the <strong class="source-inline">Pledge</strong> entity to be used by <strong class="source-inline">pledge.service.ts</strong>. Again, NestJS has quite a lot of boilerplate, which may be jarring to developers who are used to unopinionated ExpressJS workflows. This module system can help us to isolate our application into functional areas. It's a good idea to understand the benefits of a structured application before deciding whether a framework such as NestJS is right for your application or team.</p><p>We can now start to build out our <strong class="source-inline">Pledge</strong> service. TypeORM supports both Active Record, where an entity itself has methods for reading and updating, and Data Mapper, where such functionality is delegated to a <strong class="source-inline">Repository</strong> object. We will follow the Data Mapper pattern in this exercise.</p></li>
				<li>To start, we will add a constructor to the <strong class="source-inline">Pledge</strong> service and inject the repository to expose it as a private member of the class. Once we've done that, we can start to access some of the repository methods:<p class="source-code">import { Injectable } from '@nestjs/common';</p><p class="source-code">import { Pledge } from './pledge.entity';</p><p class="source-code">import { InjectRepository } from '@nestjs/typeorm';</p><p class="source-code">import { Repository } from 'typeorm';</p><p class="source-code">@Injectable()</p><p class="source-code">export class PledgeService {</p><p class="source-code">  constructor(</p><p class="source-code">    @InjectRepository(Pledge)</p><p class="source-code">    private pledgeRepository: Repository&lt;Pledge&gt;,</p><p class="source-code">  ) {}</p><p class="source-code">  findAll(): Promise&lt;Pledge[]&gt; {</p><p class="source-code">    return this.pledgeRepository.find();</p><p class="source-code">  }</p><p class="source-code">}</p><p>We've now exposed a <strong class="source-inline">findAll</strong> method, which will query the database for all the <strong class="source-inline">Pledge</strong> entities and return them in an array.</p></li>
				<li>In a production application, it can often be a good idea to implement pagination, but this will do for our purposes. Let's implement some other methods:<p class="source-code">import { Injectable } from '@nestjs/common';</p><p class="source-code">import { InjectRepository } from '@nestjs/typeorm';</p><p class="source-code">import { DeleteResult, Repository } from 'typeorm';</p><p class="source-code">import { Pledge } from './pledge.entity';</p><p class="source-code">@Injectable()</p><p class="source-code">export class PledgeService {</p><p class="source-code">  constructor(</p><p class="source-code">    @InjectRepository(Pledge)</p><p class="source-code">    private pledgeRepository: Repository&lt;Pledge&gt;,</p><p class="source-code">  ) {}</p><p class="source-code">  delete(id: number): Promise&lt;DeleteResult&gt; {</p><p class="source-code">    return this.pledgeRepository.delete(id);</p><p class="source-code">  }</p><p class="source-code">  findAll(): Promise&lt;Pledge[]&gt; {</p><p class="source-code">    return this.pledgeRepository.find();</p><p class="source-code">  }</p><p class="source-code">  findOne(id: number): Promise&lt;Pledge&gt; {</p><p class="source-code">    return this.pledgeRepository.findOne(id);</p><p class="source-code">  }</p><p class="source-code">  save(pledge: Pledge): Promise&lt;Pledge&gt; {</p><p class="source-code">    return this.pledgeRepository.save(pledge);</p><p class="source-code">  }</p><p class="source-code">}</p><p>We can get pretty far using just repository methods, which will generate SQL queries for us, but it's also possible to use SQL or a query builder with TypeORM.</p></li>
				<li>Implementing these methods in a service won't expose them to our API, so we need to add matching controller methods in <strong class="source-inline">pledge.controller.ts</strong>. Each controller method will delegate to a service method and NestJS will take care of gluing all the pieces together:<p class="source-code">import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';</p><p class="source-code">import { DeleteResult } from 'typeorm';</p><p class="source-code">import { Pledge } from './pledge.entity';</p><p class="source-code">import { PledgeService } from './pledge.service';</p><p class="source-code">@Controller('pledge')</p><p class="source-code">export class PledgeController {</p><p class="source-code">  constructor(private readonly pledgeService: PledgeService) {}</p><p class="source-code">  @Delete(':id')</p><p class="source-code">  deletePledge(@Param('id') id: number): Promise&lt;DeleteResult&gt; {</p><p class="source-code">    return this.pledgeService.delete(id);</p><p class="source-code">  }</p><p class="source-code">  @Get()</p><p class="source-code">  getPledges(): Promise&lt;Pledge[]&gt; {</p><p class="source-code">    return this.pledgeService.findAll();</p><p class="source-code">  }</p><p class="source-code">  @Get(':id')</p><p class="source-code">  getPledge(@Param('id') id: number): Promise&lt;Pledge&gt; {</p><p class="source-code">    return this.pledgeService.findOne(id);</p><p class="source-code">  }</p><p class="source-code">  @Post()</p><p class="source-code">  savePledge(@Body() pledge: Pledge): Promise&lt;Pledge&gt; {</p><p class="source-code">    return this.pledgeService.save(pledge);</p><p class="source-code">  }</p><p class="source-code">}</p><p>This controller will automatically inject the service and can then easily map service methods to API endpoints using decorators and dependency injection.</p></li>
				<li>Since we ran our application with <strong class="source-inline">npm run start:dev</strong>, it should hot reload through all these changes. </li>
				<li>Check the console and make sure there are no errors. If our code is correct, we can use a REST client such as Postman to start sending requests to our service. If we send a <strong class="source-inline">POST</strong> request with a payload such as <strong class="source-inline">{"desc":"Always lint your code", "kept": true}</strong> to <strong class="source-inline">http://localhost:3000/pledge</strong>, we'll get back a <strong class="source-inline">201 Created</strong> HTTP response. Then we can issue <strong class="source-inline">GET</strong> requests to <strong class="source-inline">http://localhost:3000/pledge</strong> and <strong class="source-inline">http://localhost:3000/pledge/1</strong> to see our record that was stored in SQLite.</li>
			</ol>
			<p>In this exercise, we used NestJS and TypeORM to build a real web API that can create and retrieve records from a SQLite database. Doing this isn't very different from using a real production-grade database such as MySQL or PostgreSQL.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor339"/>Activity 13.01: Refactoring Chained Promises to Use await</h2>
			<p>In this activity, we will refactor a function that chains promises together to use <strong class="source-inline">await</strong>. You are supplied with a starter program that is meant to simulate the creation of DOM elements for a website and render them one after another. In reality, most sites will want to render in parallel, but it's possible that information from one component might inform the rendering of another. It is good enough for example purposes in any case: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this activity can be found here: <a href="https://packt.link/L5r76">https://packt.link/L5r76</a>.</p>
			<ol>
				<li value="1">Start by running the program as-is with <strong class="source-inline">npx ts-node src/refactor.ts</strong>. You'll get each message in sequence.</li>
				<li>Now, refactor the <strong class="source-inline">renderAll</strong> function to use <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>. You shouldn't have to touch any other parts of the code to make this work. When your refactoring is complete, run the program again and verify that the output hasn't changed.</li>
			</ol>
			<p> The code for the starter program (<strong class="source-inline">refactor.ts</strong>) is as follows:</p>
			<p class="source-code">export class El {</p>
			<p class="source-code">  constructor(private name: string) {}</p>
			<p class="source-code">  render = () =&gt; {</p>
			<p class="source-code">    return new Promise((resolve) =&gt;</p>
			<p class="source-code">      setTimeout(</p>
			<p class="source-code">        () =&gt; resolve(`${this.name} is resolved`),</p>
			<p class="source-code">        Math.random() * 1000</p>
			<p class="source-code">      )</p>
			<p class="source-code">    );</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p class="source-code">const e1 = new El('header');</p>
			<p class="source-code">const e2 = new El('body');</p>
			<p class="source-code">const e3 = new El('footer');</p>
			<p class="source-code">const renderAll = () =&gt; {</p>
			<p class="source-code">  e1.render().then((msg1) =&gt; {</p>
			<p class="source-code">    console.log(msg1);</p>
			<p class="source-code">    e2.render().then((msg2) =&gt; {</p>
			<p class="source-code">      console.log(msg2);</p>
			<p class="source-code">      e3.render().then((msg3) =&gt; {</p>
			<p class="source-code">        console.log(msg3);</p>
			<p class="source-code">      });</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">};</p>
			<p class="source-code">renderAll();</p>
			<p>Once you run the program, you should get the following output:</p>
			<p class="source-code">header is resolved</p>
			<p class="source-code">body is resolved</p>
			<p class="source-code">footer is resolved</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor444">this link</a>.</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor340"/>Summary</h1>
			<p>Asynchronous programming has come a long way in the past 10 years and the introduction of <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> has continued to move it forward. Although not perfect for every use case, this syntactic sugar has proven very popular with the TypeScript community and has gained widespread acceptance in popular libraries and frameworks.</p>
			<p>In this chapter, we went over <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax, how it came to be part of the language, and how the use of this syntax is actually complimentary to promises. We then toured several popular frameworks in use by TypeScript developers to see how application developers use promises and asynchronous programming to develop powerful web applications.</p>
			<p>This concludes this book's study of language features. The next chapter will look at React for building user interfaces using TypeScript.</p>
		</div>
		<div>
			<div id="_idContainer162" class="Content">
			</div>
		</div>
	</body></html>