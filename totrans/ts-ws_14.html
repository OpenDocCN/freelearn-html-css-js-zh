<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-269">13. <a id="_idTextAnchor318"/>Async/Await in TypeScript</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">The <code>async</code>/<code>await</code> keywords give developers a more concise way to write asynchronous, non-blocking programs. In this chapter, we'll learn all about this syntactic sugar, a term for more concise and expressive syntax, for promises and how it drives modern software development. We will look at common uses of <code>async</code>/<code>await</code> and discuss the landscape of asynchronous programming in TypeScript. By the end of this chapter, you will be able to implement async/await keywords in TypeScript and use them to write asynchronous programs.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor319"/>Introduction</h1>
			<p>The previous chapter got you started on promises in TypeScript. While promises improved our ability to write asynchronous code without the ugliness of nested callbacks, developers still wanted a better way to write asynchronous code. The promise syntax is sometimes challenging for programmers with a background in the C family of languages, and so the "syntactic sugar" of <code>async</code>/<code>await</code> was proposed to be added to the ECMAScript specification.</p>
			<p>In this chapter, we'll learn about the introduction of new asynchronous programming paradigms to the ECMAScript standard, examine the syntax, and look at their use in TypeScript. We'll also cover the new (as of the time of writing) top-level <code>await</code> feature, which allows asynchronous programming outside of an <code>async</code> function. We will again look at error handling in asynchronous programming and examine the pros and cons of using <code>async</code>/<code>await</code> syntax versus promises.</p>
			<p>Readers who have been through the prior chapter will see that there is still some nesting involved in promises. While the flow is much easier to manage through multiple promises than it is with nested callbacks, we still have no mechanism by which we can return control to the top level.</p>
			<p>For example, consider a <code>getData</code> function that returns a promise. The code that invokes this function will look something like this:</p>
			<pre>getData().then(data =&gt; {
  // do something with the data
});</pre>
			<p>We don't have any means to propagate the <code>data</code> value to the outer scope. We couldn't deal with that value in a subsequent scope. Some programmers may attempt to write code that looks like this:</p>
			<pre>let myData;
getData().then(data =&gt; {
  myData = data
});
console.log(myData);</pre>
			<p>This code will always log out <code>undefined</code>. It seems like it should work, but it won't because the promise callback won't be invoked until the promise returns. Asynchronous programming like this can be confusing and lead to lots of bugs. <code>async</code>/<code>await</code> solve this problem by allowing us to pause the execution of code pending the resolution of a promise. We can rewrite the preceding code using <code>async</code>/<code>await</code> syntax:</p>
			<pre>const myData = await getData();
console.log(myData);</pre>
			<p>We've gone from five lines of code to two. The synchronous operation of <code>console.log</code> will wait for the promise to resolve. The code is much more understandable, and we can store our variable at the top scope without nesting.</p>
			<p>Because TypeScript is transpiled to JavaScript in most cases, we need to make sure that we select the correct target environment in order for our code to run. This topic will be dealt with in greater detail later in the chapter.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor320"/>Evolution and Motivation</h1>
			<p>Although promises moved the needle considerably when it came to asynchronous programming paradigms, there remained a desire for a lighter syntax that relied less on explicitly declaring promise objects. Adding the <code>async</code>/<code>await</code> keywords to the ECMAScript specification would allow developers to reduce boilerplate and work with promises. The concept comes from the C# programming language, which in turn borrowed the concept of asynchronous workflows from F#.</p>
			<p>An asynchronous function allows a program to continue normal operation even though that function call has yet to return. The program does not wait for that asynchronous function call to complete until the <code>await</code> keyword is found. More significantly, using <code>await</code> will not block the event loop. Even if we have paused part of a program to await the result of an asynchronous function call, other operations can still complete. The event loop is not blocked. For more on the event loop, return to <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>.</p>
			<p>The great thing about these keywords is that they are immediately compatible with promises. We can await any promise, thereby avoiding having to use the <code>then()</code> API. This capability means that along with the concept of promisification (see <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>), we can use the latest syntax even when integrating with older libraries or modules. To demonstrate this, let's return to an example from the preceding chapter:</p>
			<pre>import { promises } from "fs";
promises.readFile('text.txt').then(file =&gt; console.log(file.toString()));</pre>
			<p>This example uses the <code>promises</code> API from the <code>fs</code> (filesystem) module from Node.js. The code reads a file from the local filesystem and logs the contents to the console. We can use await syntax with this code: </p>
			<pre>import { promises } from "fs";
const text = (await promises.readFile('text.txt')).toString();
console.log(text);</pre>
			<p>Note that in order to run this code, you must be able to use top-level <code>await</code>, which, at the time of this writing, requires a bit of extra setup. Refer to the section later in this chapter. The takeaway from this example is that we are still able to use the <code>promises</code> API from the <code>fs</code> module, even if we prefer <code>async</code>/<code>await</code>.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor321"/>async/await in TypeScript</h1>
			<p>The maintainers of TypeScript begin work on supporting ECMAScript features when they are in stages 1 and 2 of the review process, but only formally release them when they reach stage 3.</p>
			<p>TypeScript began offering experimental support for <code>async</code> functions in version 1.6, released in September 2015, and offered full support in version 1.7, released in November 2015. TypeScript programmers could work with this syntax a full year ahead of official browser and Node.js support.</p>
			<p>Use of the <code>async</code>/<code>await</code> keywords in TypeScript does not vary much from JavaScript, but we do have an advantage in the ability to be more explicit about which functions should return promises and which should return a resolved value or throw an error.</p>
			<p>One thing to be cognizant of when writing modern syntax in TypeScript is that most TypeScript code is transpiled to JavaScript for execution in a runtime, such as a web browser or Node.js. We need to understand the difference between transpilation and a polyfill. <code>async</code>/<code>await</code> code and transpile to an environment that only supports promise syntax. A <strong class="bold">polyfill</strong> adds missing language features. If our target environment doesn't even support promises, then transpiling async/await into promises won't do the trick. We will require a polyfill as well. </p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor322"/>Exercise 13.01: Transpilation Targets</h2>
			<p>In this exercise, we will use a contrived "Hello World!" example to demonstrate how TypeScript handles the transpilation of the <code>async</code> /<code>await</code> keywords:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/NS8gY">https://packt.link/NS8gY</a>.</p>
			<ol>
				<li>Navigate to the <code>Exercise01</code> folder and install dependencies with <code>npm install</code>:<pre>npm install</pre></li>
				<li>That will install TypeScript and the TS Node execution environment. Now, execute the program included by typing <code>npx ts-node target.ts</code>. The result will be as follows:<pre>World!
Hello</pre><p><code>World!</code> printed before <code>Hello</code>. </p></li>
				<li>Open up <code>target.ts</code> and inspect the reason for this. This program creates a <code>sayHello</code> function, which internally creates a promise that resolves after one millisecond. You may notice that the program does exactly the same thing even if we remove the <code>await</code> keyword. That's OK. It's the different transpilation targets here that are interesting. When we run this program using TS Node, this will target the current Node.js version we're running. Assuming that's a recent version, <code>async</code>/<code>await</code> will be supported. Instead of doing that, let's try transpiling the code into JavaScript using TypeScript to see what happens. </li>
				<li>Now, open the <code>tsconfig.json</code> file and look at it:<pre>{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}</pre></li>
				<li>The <code>target</code> option being set to <code>es5</code> means that TypeScript will attempt to produce code that conforms to the ECMAScript5 specification. So let's give that a try:<pre>npx tsc</pre><p>No output means that it executed successfully. </p></li>
				<li>Check out the <code>target.js</code> file that was produced by TypeScript. The size of this file may vary depending on your TypeScript version, but the transpiled code module may be more than 50 lines:<pre>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
//….
sayHello();
console.log('World!');</pre><p class="callout-heading">Note</p><p class="callout">The complete code can be found here: <a href="https://packt.link/HSmyX">https://packt.link/HSmyX</a>.</p><p>We can execute the transpiled code by typing <code>node target.js</code> at the command prompt and we'll see that we get the same output as before.</p><p>Promises are not part of the ECMAScript5 specification, so to generate code that will work in an ECMAScript5 environment, the transpiler had to create <code>__awaiter</code> and <code>__generator</code> functions to support promise-like functionality.</p></li>
				<li>Let's switch our target to es6. Open <code>tsconfig.json</code> and change the target property to <code>es6</code>:<pre>{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}</pre></li>
				<li>Invoking the function with <code>node target.js</code>, we get exactly the same output as before. Now let's see what TypeScript did when it transpiled our source:<pre>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const sayHello = () =&gt; __awaiter(void 0, void 0, void 0, function* () {
    yield new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(console.log('Hello')), 1));
});
sayHello();
console.log('World!');</pre><p>The transpiled code is now 15 lines instead of over 50 because ECMAScript6 is much closer to supporting all the functionality we need than es5 is. The <code>async</code>/<code>await</code> keywords are not supported in ECMAScript6, but promises are, so TypeScript is leveraging promises to make the outputted code more concise.</p></li>
				<li>Now, let's change the target to <code>esnext</code>, run <code>npx tsc</code> one more time, and see what that output looks like:<pre>"use strict";
const sayHello = async () =&gt; {
    await new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(console.log('Hello')), 1));
};
sayHello();
console.log('World!');</pre><p>That's very similar to our source code! Since <code>async</code>/<code>await</code> are supported in the latest ECMAScript specification, there's no need to transform.</p></li>
				<li>Older versions of TypeScript did not fully polyfill promises and async/await. Downgrade your TypeScript version with <code>npm i -D typescript@2</code>, set your compilation target back to es5, and then try transpiling:<pre>npx tsc
target.ts:1:18 - error TS2705: An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.
1 const sayHello = async () =&gt; {
                   ~~~~~~~~~~~~~
target.ts:2:13 - error TS2693: 'Promise' only refers to a type, but is being used as a value here.
2   await new Promise((resolve) =&gt;
              ~~~~~~~
target.ts:2:22 - error TS7006: Parameter 'resolve' implicitly has an 'any' type.
2   await new Promise((resolve) =&gt;</pre><p>It doesn't work.</p></li>
				<li>If you bump up to <code>es6</code>, it will still fail:<pre>% npx tsc
target.ts:3:30 - error TS2345: Argument of type 'void' is not assignable to parameter of type '{} | PromiseLike&lt;{}&gt; | undefined'.
3     setTimeout(() =&gt; resolve(console.log('Hello')))</pre></li>
				<li>Install the latest version of TypeScript with <code>npm i -D typescript@latest</code> and then everything should work as before.</li>
			</ol>
			<p>This aspect of TypeScript can be confusing for newcomers. TypeScript will not provide a polyfill for missing promises, but it will provide transformations to syntax that is functionally equivalent.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor323"/>Choosing a Target</h2>
			<p>So how do we choose a compilation target? It's generally safe to use ES2017 or above unless you need to support outdated browsers, such as Internet Explorer, or deprecated Node.js versions. Sometimes, we have no choice but to support outdated browsers due to customer needs, but if we have any control over a Node.js runtime environment, it's advisable to update to a current, supported version. Doing this should allow us to use the latest TypeScript features.</p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor324"/>Syntax</h1>
			<p>The two new keywords, <code>async</code>/<code>await</code>, are often found together, but not always. Let's look at the syntax for each of them individually.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor325"/>async</h2>
			<p>The <code>async</code> keyword modifies a function. If a function declaration or function expression is used, it is placed before the <code>function</code> keyword. If an arrow function is used, the <code>async</code> keyword is placed before the argument list. Adding the <code>async</code> keyword to a function will cause the function to return a promise.</p>
			<p>For example:</p>
			<pre>function addAsync(num1: number, num2: number) {
  return num1 + num2;
}</pre>
			<p>Just adding the <code>async</code> keyword to this simple function will make this function return a promise, which is now awaitable and thenable. Since there's nothing asynchronous in the function, the promise will resolve immediately.</p>
			<p>The arrow function version of this could be written as follows:</p>
			<pre>const addAsync = async (num1: number, num2: number) =&gt; num1 + num2;</pre>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor326"/>Exercise 13.02: The async Keyword</h2>
			<p>This exercise illustrates how adding the <code>async</code> keyword to a function makes it return a promise:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/BgujE">https://packt.link/BgujE</a>.</p>
			<ol>
				<li value="1">Examine the <code>async.ts</code> file:<pre>export const fn = async () =&gt; {
  return 'A Promise';
};
const result = fn();
console.log(result);</pre><p>You might expect this program to log out <code>A Promise</code>, but let's see what actually happens when we run it:</p><pre>npx ts-node async.ts
Promise { 'A Promise' }</pre></li>
				<li>The <code>async</code> keyword wrapped the response in a promise. We can confirm that by removing the keyword and running the program again:<pre>npx ts-node async.ts
A Promise</pre></li>
				<li>Modifying our function with <code>async</code> is exactly equivalent to wrapping it in a promise. If we wanted to use promise syntax, we could write the program like this:<pre>export const fn = () =&gt; {
  return Promise.resolve('A Promise');
};
const result = fn();
console.log(result);</pre></li>
				<li>Again, running the program written this way will log out the unresolved promise:<pre>npx ts-node async.ts
Promise { 'A Promise' }</pre></li>
			</ol>
			<p>Since we're using TypeScript and return types can be inferred, modifying a function with <code>async</code> guarantees that TypeScript will always see the function as returning a promise.</p>
			<p>The <code>async</code> keyword causes the function it modifies to be wrapped in a promise. Whether you choose to do that explicitly by declaring a promise or by using the <code>async</code> keyword is often a matter of taste and style. </p>
			<p>How can we resolve an <code>async</code> function? We'll come to <code>await</code> in a moment, but what about using <code>then</code> and the promise chaining we learned about in <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>. Yes, that is also possible.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor327"/>Exercise 13.03: Resolving an async Function with then</h2>
			<p>This exercise will teach you how to resolve an <code>async</code> function using <code>then</code>:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/4Bo4c">https://packt.link/4Bo4c</a>.</p>
			<ol>
				<li value="1">Create a new file called <code>resolve.async.ts</code> and enter the following code:<pre>export const fn = async () =&gt; {
  return 'A Promise';
};
const result = fn();
result.then((message) =&gt; console.log(message));</pre></li>
				<li>Execute this code by entering <code>npx ts-node resolve.async.ts</code> into your console and you'll see the expected text message logged, not an unresolved promise:<pre>A Promise</pre></li>
			</ol>
			<p>Even though we never explicitly declared a promise object, the use of <code>async</code> has ensured that our function will always return a promise.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor328"/>await</h2>
			<p>The second half of this combo perhaps has greater value. The <code>await</code> keyword will attempt to resolve any promise before continuing. This will get us out of <code>then</code> chaining and allow us to write code that appears to be synchronous. One great benefit of using <code>await</code> is if we want to assign the result of an asynchronous call to some value and then do something with the value. Let's look at how that's done in a promise:</p>
			<pre>asyncFunc().then(result =&gt; {
  // do something with the result
});</pre>
			<p>That can work fine and, in fact, this kind of syntax is used widely, but it breaks down a little if we need to do something tricky with chaining:</p>
			<pre>asyncFuncOne().then(resultOne =&gt; {
  asyncFuncTwo(resultOne).then(resultTwo =&gt; {
    asyncFuncThree(resultTwo).then(resultThree =&gt; {
      // do something with resultThree
    });
  });
});</pre>
			<p>But wait a minute. I thought promises were supposed to get rid of callback hell?! It's actually not that ideal for this kind of chaining. Let's try using <code>await</code> instead:</p>
			<pre>const resultOne = await asyncFuncOne();
const resultTwo = await asyncFuncTwo(resultOne);
const resultThree = await asyncFuncThree(resultTwo);
// do something with resultThree</pre>
			<p>Most programmers would agree that this syntax is much cleaner and, in fact, this is one of the primary reasons why <code>async</code>/<code>await</code> were added to the language.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor329"/>Exercise 13.04: The await Keyword</h2>
			<p>This exercise will show you how to resolve a promise using <code>await</code>: </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/mUzGI">https://packt.link/mUzGI</a>.</p>
			<ol>
				<li value="1">Create a file called <code>await.ts</code> and enter the following code:<pre>export const fn = async () =&gt; {
  return 'A Promise';
};
const resolveIt = async () =&gt; {
  const result = await fn();
  console.log(result);
};
resolveIt();</pre><p>Here we declare two <code>async</code> functions. One of them calls the other using <code>await</code> to resolve the promise and it should print out the string, rather than an unresolved promise. </p></li>
				<li>Run the file using <code>npx</code> <code>ts-node</code> <code>await.ts</code> and you should see the following output:<pre>A Promise</pre></li>
			</ol>
			<p>Why did we need to wrap <code>await</code> in a second function? That is because normally, <code>await</code> cannot be used outside of an <code>async</code> function. We'll discuss the top-level <code>await</code> feature later in this chapter, which is an exception to this rule. What about mixing <code>await</code> with promises? This can certainly be done. </p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor330"/>Exercise 13.05: Awaiting a Promise</h2>
			<p>This exercise teaches you how you can use <code>await</code> with promises:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/mMDiw">https://packt.link/mMDiw</a>.</p>
			<ol>
				<li value="1">Create a new file called <code>await-promise.ts</code> and enter the following code:<pre>export const resolveIt = async () =&gt; {
  const result = await Promise.resolve('A Promise');
  console.log(result);
};
resolveIt();</pre></li>
				<li>Execute the code by entering <code>npx ts-node await-promise.ts</code> and you'll see the text output:<pre>A Promise</pre></li>
				<li>A longer way to write this same code with a more explicit promise declaration would be:<pre>export const resolveIt = async () =&gt; {
  const p = new Promise((resolve) =&gt; resolve('A Promise'));
  const result = await p;
  console.log(result);
};
resolveIt();</pre><p>This code functions exactly the same:</p></li>
				<li>Enter <code>npx ts-node src/await-promise.ts</code> to verify that you get the following output:<pre>A Promise</pre></li>
			</ol>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor331"/>Syntactic Sugar</h2>
			<p>The preceding exercises on <code>async</code> functions and promises are simply two different ways of expressing the exact same operation in TypeScript. Likewise, using <code>await</code> and resolving a promise with <code>then</code> are equivalent. The <code>async</code>/<code>await</code> keywords are what's known as "syntactic sugar," or code structures that enable more expressive syntax without changing the behavior of the program.</p>
			<p>This means it is possible and, at times, even advisable to mix <code>async</code>/<code>await</code> syntax with promises. A very common reason for doing this would be because you are working with a library that was written to use promises, but you prefer <code>async</code>/<code>await</code> syntax. Another reason for mixing the two would be to handle exceptions more explicitly. We'll deal with exception handling in detail later in this chapter.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor332"/>Exception Handling</h1>
			<p>We've been over how to turn <code>then</code> chaining into <code>await</code>, but what about <code>catch</code>? If a promise is rejected, the error will bubble up and must be caught in some way. Failing to catch an exception in the <code>async</code>/<code>await</code> world is just as damaging as failing to catch a promise rejection. In fact, it's exactly the same and <code>async</code>/<code>await</code> is just syntactic sugar on top of promises.</p>
			<p>Failing to handle a rejected promise can lead to system failure where a program running in a web browser crashes, resulting in blank pages or broken functionality, thereby driving users away from your site. A failure to handle a rejected promise on the server side may cause a Node.js process to exit and a server to crash. Even if you have a self-healing system that attempts to bring your server back online, whatever job you were attempting to complete will have failed and frequently repeated restarts will make your infrastructure more expensive to run.</p>
			<p>The most straightforward way to handle these errors is with <code>try</code> and <code>catch</code> blocks. This syntax is not unique to <code>async</code>/<code>await</code> and has been part of the ECMAScript specification since ECMAScript3. It is very simple and straightforward to use:</p>
			<pre>try {
  await someAsync();
} catch (e) {
  console.error(e);
}</pre>
			<p>Just as you can catch an error thrown from any of several chained promises, you can implement a similar pattern here:</p>
			<pre>try {
  await someAsync();
  await anotherAsync();
  await oneMoreAsync();
} catch (e) {
  console.error(e);
}</pre>
			<p>There may be cases where finer-grained exception handling is required. It is possible to nest these structures:</p>
			<pre>try {
  await someAsync();
  try {
    await anotherAsync();
  } catch (e) {
    // specific handling of this error
  }
  await oneMoreAsync();
} catch (e) {
  console.error(e);
}</pre>
			<p>However, writing code such as this negates most of the benefits of the <code>async</code>/<code>await</code> syntax. A better solution would be to throw specific error messages and test for them:</p>
			<pre>try {
  await someAsync();
  await anotherAsync();
  await oneMoreAsync();
} catch (e) {
  if(e instanceOf MyCustomError) {
    // some custom handling
  } else {
    console.error(e);
  }
}</pre>
			<p>With this technique, we can handle everything in the same block and avoid nesting and messy-looking code structures.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor333"/>Exercise 13.06: Exception Handling</h2>
			<p>Let's see how we can implement error handling in a simple example. In this exercise, we will intentionally and explicitly throw an error from an <code>async</code> function and see how that implements the operation of our program:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/wbA8E">https://packt.link/wbA8E</a>.</p>
			<ol>
				<li value="1">Start by creating a new file called <code>error.ts</code> and entering the following code:<pre>export const errorFn = async () =&gt; {
  throw new Error('An error has occurred!');
};
const asyncFn = async () =&gt; {
  await errorFn();
};
asyncFn();</pre></li>
				<li>This program will, of course, always throw an error. When we execute it by entering <code>npx ts-node error.ts</code> into the console, we can see quite clearly that the error is not being handled properly:<pre>(node:29053) UnhandledPromiseRejectionWarning: Error: An error has occurred!
    at Object.exports.errorFn (/workshop/async-chapter/src/error.ts:2:9)
    at asyncFn (/workshop/async-chapter/src/error.ts:6:9)
    at Object.&lt;anonymous&gt; (/workshop/async-chapter/src/error.ts:9:1)
    at Module._compile (internal/modules/cjs/loader.js:1138:30)
    at Module.m._compile (/workshop/async-chapter/node_modules/ts-node/src/index.ts:858:23)
    at Module._extensions..js (internal/modules/cjs/loader.js:1158:10)
    at Object.require.extensions.&lt;computed&gt; [as .ts] (/workshop/async-chapter/node_modules/ts-node/src/index.ts:861:12)
    at Module.load (internal/modules/cjs/loader.js:986:32)
    at Function.Module._load (internal/modules/cjs/loader.js:879:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12)
(node:29053) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 2)
(node:29053) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</pre><p>Notice the deprecation warning. Not only is this an ugly stack trace, at some point in the future, exceptions such as this one will cause the Node.js process to exit. We clearly need to handle this exception!</p></li>
				<li>Fortunately, we can do so by simply surrounding the call with <code>try</code> and <code>catch</code>:<pre>export const errorFn = async () =&gt; {
  throw new Error('An error has occurred!');
};
const asyncFn = async () =&gt; {
  try {
    await errorFn();
  } catch (e) {
    console.error(e);
  }
};
asyncFn();</pre></li>
				<li>Now, when we execute the program, we get a more orderly exception and stack trace logged:<pre>Error: An error has occurred!
    at Object.exports.errorFn (/workshop/async-chapter/src/error.ts:2:9)
    at asyncFn (/workshop/async-chapter/src/error.ts:7:11)
    at Object.&lt;anonymous&gt; (/workshop/async-chapter/src/error.ts:13:1)
    at Module._compile (internal/modules/cjs/loader.js:1138:30)
    at Module.m._compile (/workshop/node_modules/ts-node/src/index.ts:858:23)
    at Module._extensions..js (internal/modules/cjs/loader.js:1158:10)
    at Object.require.extensions.&lt;computed&gt; [as .ts] (/workshop/node_modules/ts-node/src/index.ts:861:12)
    at Module.load (internal/modules/cjs/loader.js:986:32)
    at Function.Module._load (internal/modules/cjs/loader.js:879:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12)</pre><p>Of course, that message only appears because we explicitly logged it out. We could instead choose to throw a default value or perform some other operation instead of logging the error. </p></li>
				<li>It's always a good idea to log an error if the system isn't behaving correctly, but depending on your system requirements, you might instead write something like this:<pre>const primaryFn = async () =&gt; {
  throw new Error('Primary System Offline!');
};
const secondaryFn = async () =&gt; {
  console.log('Aye aye!');
};
const asyncFn = async () =&gt; {
  try {
    await primaryFn();
  } catch (e) {
    console.warn(e);
    secondaryFn();
  }
};
asyncFn();</pre><p>In this case, we just throw a warning and fall back to the secondary system because this program was designed to be fault-tolerant. It's still a good idea to log the warning so that we can trace how our system is behaving. One more variation of this for now. </p></li>
				<li>Let's put our <code>try</code> and <code>catch</code> blocks at the top level and rewrite our program like this:<pre>export const errorFN = async () =&gt; {
  throw new Error('An error has occurred!');
};
const asyncFn = async () =&gt; {
  await errorFN();
};
try {
  asyncFn();
} catch (e) {
  console.error(e);
}</pre></li>
				<li>This is the output that you get:<pre>Error: Primary System Offline!
    at primaryFn (C:\Users\Mahesh\Documents\Chapter13_TypeScript\Exercise13.06\error-secondary.ts:2:9)
    at asyncFn (C:\Users\Mahesh\Documents\Chapter13_TypeScript\Exercise13.06\error-secondary.ts:11:11)
    at Object.&lt;anonymous&gt; (C:\Users\Mahesh\Documents\Chapter13_TypeScript\Exercise13.06\error-secondary.ts:18:1)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Module.m._compile (C:\Users\Mahesh\AppData\Roaming\npm-cache\_npx\13000\node_modules\ts-node\src\index.ts:1056:23)       
    at Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
    at Object.require.extensions.&lt;computed&gt; [as .ts] (C:\Users\Mahesh\AppData\Roaming\npm-cache\_npx\13000\node_modules\ts-node\src\index.ts:1059:12)
    at Module.load (internal/modules/cjs/loader.js:928:32)
    at Function.Module._load (internal/modules/cjs/loader.js:769:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)
Aye aye!</pre><p>You may assume that the program might work the same as putting <code>try</code> and <code>catch</code> inside <code>asyncFn</code>, but actually, it will behave the same as no error handling at all. That's because we aren't awaiting the function inside the <code>try</code> block. </p></li>
			</ol>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor334"/>Top-Level await</h1>
			<p>Top-level <code>await</code> is a feature that allows the use of the <code>await</code> keyword at the module level, outside of any function. This allows a number of interesting patterns, such as waiting for a dependency to fully load by calling an asynchronous function before attempting to use it. Someday, top-level <code>await</code> may support some very exciting functional programming paradigms, but at the time of writing, it is still technically in preview mode, and so is not ready for widespread use. You may be reading this book at a time when top-level <code>await</code> is widely available and supported, and if so, you should definitely give it a look!</p>
			<p>Writing code with top-level <code>await</code> is very straightforward. Here is a very short program that attempts to make use of it:</p>
			<pre>export const fn = async () =&gt; {
  return 'awaited!';
};
console.log(await fn());</pre>
			<p>This looks fine. Now let's see what happens when we try to execute it:</p>
			<pre>⨯ Unable to compile TypeScript:
src/top-level-await.ts:5:13 - error TS1378: Top-level 'await' expressions are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.
5 console.log(await fn());
              ~~~~~</pre>
			<p>It's not supported, but it gives me some pointers. How can we make this work?</p>
			<p>Top-level <code>await</code> requires NodeJS 14.8 or greater. This version of NodeJS entered LTS (long-term service) in October of 2020 and so is still new at the time of this writing. You can check your NodeJS version on the command line with <code>node -v</code>. If you aren't running version 14.8 or greater, there are some good utilities like <code>nvm</code> and <code>n</code> that will allow you to switch your version easily.</p>
			<p>That, however, doesn't fix the problem. It seems that I will need to change my <code>tsconfig.json</code> <code>target</code> property to <code>es2017</code> or higher and set the <code>module</code> property to <code>esnext</code>. Adding the <code>module</code> property means that I want to use ES modules, which is a relatively new way to handle modules and is beyond the scope of this book. To enable ES modules, I need to set the <code>type</code> property in my <code>package.json</code> file to <code>module</code>.</p>
			<p>Now I've updated a couple of JSON files and am ready to try again:</p>
			<pre>TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension ".ts" for /workshop/async-chapter/src/top-level-await.ts
    at Loader.defaultGetFormat [as _getFormat] (internal/modules/esm/get_format.js:65:15)
    at Loader.getFormat (internal/modules/esm/loader.js:113:42)
    at Loader.getModuleJob (internal/modules/esm/loader.js:243:31)
    at Loader.import (internal/modules/esm/loader.js:177:17)</pre>
			<p>It still isn't working. I'll need to do one more thing to make this work, and that is to enable the experimental feature in Node.js and instruct TS Node to allow <strong class="bold">ES modules</strong> (<strong class="bold">esm</strong>). This requires a longer command:</p>
			<pre>node --loader ts-node/esm.mjs top.ts
(node:91445) ExperimentalWarning: --experimental-loader is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
awaited! </pre>
			<p>But it works. Top-level <code>await</code> will likely become much easier and more intuitive to work with in the months and years ahead, so make sure to check the latest documentation for your runtime.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor335"/>Promise Methods</h1>
			<p>In addition to the standard <code>next</code> and <code>catch</code> methods exposed by promises, there are a number of other convenience methods, such as <code>all</code>, <code>allSettled</code>, <code>any</code>, and <code>race</code>, that make working with promises nicer. How can they be used in the <code>async</code>/<code>await</code> world? They can actually work together quite nicely. For example, here is a use of <code>Promise.all</code> that employs <code>then</code> and <code>catch</code>. Given three promises, <code>p1</code>, <code>p2</code>, and <code>p3</code>:</p>
			<pre>Promise.all([p1, p2, p3])
  .then(values =&gt; console.log(values))
  .catch(e =&gt; console.error(e));</pre>
			<p>There isn't any kind of <code>awaitAll</code> operator, so if we want to execute our promises in parallel, we're still going to need to use <code>Promise.all</code>, but we can avoid chaining <code>then</code> and <code>catch</code> if we choose to:</p>
			<pre>try {
  const values = await Promise.all([p1, p2, p3]);
  console.log(values);
} catch (e) {
  console.error(e);
}</pre>
			<p>In this case, we might feel like the code isn't improved by the addition of <code>await</code>, since we've actually expanded it from three lines to six. Some may find this form more readable. As always, it's a matter of personal or team preference.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor336"/>Exercise 13.07: async/await in Express.js</h2>
			<p>In this exercise, we will build a small web application using the popular Express framework. Although Express was written for the JavaScript language, typings have been published for it and it is fully usable with TypeScript. Express is an unopinionated, minimalist framework for building web applications. It's one of the oldest and most popular frameworks in use today.</p>
			<p>For our simple application, we'll start a web server on port <code>8888</code> and accept <code>GET</code> requests. If that request has a <code>name</code> parameter in the query string, we will log the name in a file called <code>names.txt</code>. Then we'll greet the user. If there's no name in the query string, we log nothing and print out <code>Hello World!</code>:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/cG4r8">https://packt.link/cG4r8</a>.</p>
			<p>Let's get started by installing the Express framework and typings. </p>
			<ol>
				<li value="1">Enter <code>npm i express</code> to install Express as a dependency and <code>npm i -D @types/express @types/node</code> to install the typings that we'll need to support TypeScript. <p>Remember the <code>-D</code> flag means that it's a <code>devDependency</code> that can be managed differently from a production dependency, although its use is optional.</p></li>
				<li>With our dependencies installed, let's create a file called <code>express.ts</code>. The first thing to do is import <code>express</code>, create the app, add a simple handler, and listen on port <code>8888</code>:<pre>import express, { Request, Response } from 'express';
const app = express();
app.get('/', (req: Request, res: Response) =&gt; {
  res.send('OK');
});
app.listen(8888);</pre><p>This looks very much like your standard starter Express app, other than we're giving types to the <code>Request</code> and <code>Response</code> objects. This is already enormously useful as we'll be able to use IntelliSense and ascertain what methods we can call on those objects without having to look them up.</p><p>Our requirements say that we need to listen for a <code>name</code> parameter in the query string. We might see a request that looks like <code>http://localhost:8888/?name=Matt</code>, to which we should respond <code>Hello Matt!</code>.</p><p>The query string is in the <code>Request</code> object. If we delve into the typings, it is typed as follows:</p><pre>interface ParsedQs { [key: string]: undefined | string | string[] | ParsedQs | ParsedQs[] }</pre><p>This basically means that it is a hash of key/value pairs and nested key/value pairs. In our case, we would expect to see a query object that looks like <code>{ name: 'Matt' }</code>. Thus, we can get the <code>name</code> attribute by using <code>const { name } = req.query;</code>. Then we can respond to the request with something like <code>res.send(`Hello ${name ?? 'World'}!`);</code>. In this case, we're using the nullish coalesce operator (<code>??</code>) to say that we'll fall back to the <code>World</code> string if the <code>name</code> variable has a nullish (null or undefined) value. We could also use the fallback or logical OR operator, <code>||</code>.</p></li>
				<li>The updated code now looks like this:<pre>import express, { Request, Response } from 'express';
const app = express();
app.get('/', (req: Request, res: Response) =&gt; {
  const { name } = req.query;
  res.send(`Hello ${name ?? 'World'}!`);
});
app.listen(8888);</pre></li>
				<li>One requirement is still missing. We need to log the name to a file if it exists. To do that, we'll need to use the <code>fs</code> library from Node.js. We'll also use the <code>path</code> library to resolve a path to the file we want to write to. First, add the new imports:<pre>import { promises } from 'fs';
import { resolve } from 'path';</pre></li>
				<li>Now we'll use the <code>promises</code> API from <code>fs</code> to asynchronously write to our log file. Since this is a log, we want to append to it, not overwrite it on each request. We'll use <code>appendFile</code> and write the name along with a newline character. We want this operation to repeat before returning:<pre>  if (name) {
    await promises.appendFile(resolve(__dirname, 'names.txt'), `${name}\n`);
  }</pre><p>That's almost it, but we should have a warning by now that our handler function isn't properly async. All we need to do is add the <code>async</code> keyword to it. </p></li>
				<li>The completed code looks like this:<pre>import express, { Request, Response } from 'express';
import { promises } from 'fs';
import { resolve } from 'path';
const app = express();
app.get('/', async (req: Request, res: Response) =&gt; {
  const { name } = req.query;
  if (name) {
    await promises.appendFile(resolve(__dirname, 'names.txt'), `${name}\n`);
  }
  res.send(`Hello ${name ?? 'World'}!`);
});
app.listen(8888);</pre></li>
				<li>Run the program with <code>npx ts-node express.ts</code> and try hitting the URL at <code>http://localhost:8888?name=your_name</code> a few times. Try hitting that URL with different names and watch your log file increment. Here are a few examples.</li>
				<li>The following is the browser output for your_name:<div><img src="img/B14508_13_01.jpg" alt="Figure 13.1: Browser message for name = your_name&#13;&#10;"/></div><p class="figure-caption">Figure 13.1: Browser message for name = your_name</p></li>
				<li>The following is the browser output for Matt:<div><img src="img/B14508_13_02.jpg" alt="Figure 13.2: Browser message for name = Matt&#13;&#10;"/></div><p class="figure-caption">Figure 13.2: Browser message for name = Matt</p></li>
				<li>The following is the browser output for Albert Einstein:</li>
			</ol>
			<div><div><img src="img/B14508_13_03.jpg" alt="Figure 13.3: Browser message for name = Albert Einstein&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3: Browser message for name = Albert Einstein</p>
			<p>The <code>names.txt</code> file will increment as follows:</p>
			<div><div><img src="img/B14508_13_04.jpg" alt="Figure 13.4: Log file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Log file</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor337"/>Exercise 13.08: NestJS</h2>
			<p>In contrast to Express, NestJS is a highly opinionated and fully featured framework for building TypeScript applications. NestJS can be used to quickly bootstrap an application. It provides out-of-the-box support for middleware, GraphQL, and Websockets. It ships with ESLint, a dependency injection framework, a test framework, and many other useful things. Some developers really enjoy working with such a full-featured framework and others find all the boilerplate oppressive and prefer to work with something more bare-bones, such as Express:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/blRq3">https://packt.link/blRq3</a>.</p>
			<p>Let's bootstrap a new NestJS application and give it a closer look.</p>
			<ol>
				<li value="1">NestJS applications can be generated by a <code>npm</code>. Install that package globally:<pre>npm i -g @nestjs/cli</pre></li>
				<li>When we use the CLI, it will generate a project by creating a new directory inside the directory we entered the command into, so you may want to change the directory to where you store your projects. Then, generate the project:<pre>nest new async-nest</pre><p>Here the project is named <code>async-nest</code>. You can name it differently. NestJS will automatically install all dependencies and bootstrap a bare-bones application. </p></li>
				<li>Change directory into your new application and start looking at the code. If you pop open <code>main.ts</code>, you'll see <code>async</code>/<code>await</code> already in use. That module will look something like this:<pre>import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();</pre><p>NestJS is built on top of Express. This code will create a new Express application. The internals of Express are not exposed to you as you write NestJS code, but you always have the option to drop down to them if you need something not supported by NestJS.</p><p>Let's go over a few useful commands that you can start using immediately. If you type <code>npm test</code> (or <code>npm t</code>), you'll launch a test run by the Jest framework. This test launches an instance of your application, invokes it, and then shuts it down after verifying the expected response was received. NestJS ships with fixtures that allow a light version of your app to be tested.</p><p>It's a great idea to continue adding unit and integration tests to your app as you work on it. TypeScript can help you ensure code correctness, but only tests will guarantee that your app is behaving as it should.</p><p>Another useful command is <code>npm run lint</code>. This will check your code style and notify you of any issues with it by using the popular ESLint library.</p></li>
				<li>Finally, you can type <code>npm run start:dev</code> to run the development server in watch mode, which means the server will restart whenever you change a file. </li>
				<li>Try running that now and navigate to <code>http://localhost:3000</code> and you'll see the <code>Hello World</code> message. If you open the file called <code>app.service.ts</code> and change the message returned there, you can just refresh your browser and you should see the message change.<p>Now that we've seen this simple Hello World app done in two very different frameworks, let's add the same greeting and logging functionality that we did in <em class="italic">Exercise 13.07: async/await in Express.js</em>.</p></li>
				<li>To add the custom greeting based on the query param, let's open two files, <code>app.controller.ts</code> and <code>app.service.ts</code>. Notice that <code>app.service.ts</code> implements a <code>getHello</code> function that returns the string "Hello World!". We will need to change this function to accept a <code>name</code> argument.</li>
				<li>Add the <code>name</code> argument with the <code>string</code> type to the function's argument list, and then change the return to a string template and say Hello. You'll have something like this:<pre>export class AppService {
  getHello(name: string): string {
    return `Hello ${name}!`;
  }
}</pre><p>This is a simple refactor. If we check <code>app.controller.ts</code>, we'll see that our IDE is now telling us that <code>getHello</code> needs an argument and we're not done yet.</p><p>In the Express application, we found our query parameter on the built-in <code>Request</code> object. You could do the same thing in NestJS, but it's more common and preferable to use a decorator. Decorators are special functions that wrap other functions. They are sometimes called higher-order functions and are similar to aspects of languages such as Java.</p><p>The decorator we want to use is <code>@Query</code>, which takes an argument of the name of the query parameter and then binds that parameter to one of our function arguments. </p></li>
				<li>We can import that decorator from <code>@nestjs/common</code>. Then we add the function argument to <code>getHello</code> and pass it through to the service call. One more thing that's a good idea is to set a default so that we maintain backward compatibility and don't print out <code>Hello undefined</code> if we fail to give an argument. Adding the default may prompt a hint that you no longer need the type annotation as it is trivially inferred from the default type. Go ahead and remove it if you like:<pre>import { Controller, Get, Query } from '@nestjs/common';
import { AppService } from './app.service';
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
  @Get()
  getHello(@Query('name') name: string = 'World'): string {
    return this.appService.getHello(name);
  }
}</pre></li>
				<li>The dev server should restart and now, if we browse to <code>http://localhost:3000/?name=Matt</code>, we'll see <code>Hello Matt!</code>:<div><img src="img/B14508_13_05.jpg" alt="Figure 13.5: Browser message for name = Matt&#13;&#10;"/></div><p class="figure-caption">Figure 13.5: Browser message for name = Matt</p></li>
				<li>Now let's add the same logging functionality that we implemented in Express.<p>In a full-scale application, we'd probably want to build a separate logging service class. For our purposes, we can implement that as a separate <code>async</code> method. Add the method to <code>app.service.ts</code> and call it with <code>await</code> from <code>getHello</code>. Test it to be sure that it's working correctly. </p><p>There are a few gotchas here. One is that NestJS is automatically transpiling and serving your code from a folder called <code>dist</code>, so you'll find your <code>names.txt</code> file in there once you start logging names. But the bigger trick here is that in order to await the logging, we need to make <code>getHello</code> in <code>app.service.ts</code> into an <code>async</code> method. This, in turn, will mean that <code>getHello</code> in <code>app.controller.ts</code> must also be <code>async</code>. What will changing these methods to <code>async</code> do to our app? Nothing! NestJS already knows how to resolve the promises before returning the request.</p></li>
				<li>One more thing to check out in this exercise is the unit test. Since we've set a default value for the <code>name</code> attribute, the test should still work, right? Well actually, it doesn't. Try running <code>npm test</code> and you'll see the problem. The issue is that the test isn't expecting <code>getHello</code> to be async. That's OK. We can fix it by making the test callback <code>async</code> to look like this:<pre>  describe('root', () =&gt; {
    it('should return "Hello World!"', async () =&gt; {
      expect(await appController.getHello()).toBe('Hello World!');
    });
  });</pre><p>The test should now pass. Try adding another test with an argument.</p></li>
			</ol>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor338"/>Exercise 13.09: TypeORM</h2>
			<p>TypeORM is an object relational mapper written in, and for, TypeScript. TypeORM supports many popular databases, such as MySQL, Postgres, SQL Server, SQLite, and even MongoDB and Oracle. TypeORM is often used in NestJS applications, so in this exercise we will add a local in-memory SQLite database to work with our NestJS application.</p>
			<p>In this exercise, you will build another REST service to help us keep track of the promises we make. Since <code>Promise</code> is the name of a built-in object in TypeScript, let's use the term "pledge" so we can differentiate domain concepts from language abstractions:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/ZywYh">https://packt.link/ZywYh</a>.</p>
			<ol>
				<li value="1">To get started, let's bootstrap a new NestJS project:<pre>nest new typeorm-nest</pre></li>
				<li>NestJS has a powerful module system that lets us build out different functional areas of our application in cohesive chunks. Let's create a new module for pledges:<pre>nest g module pledge</pre><p>This command will generate a new module under the <code>/pledge</code> subdirectory. </p></li>
				<li>We're also going to need a controller and a service for the pledge API, so let's generate those using the NestJS CLI:<pre>nest g controller pledge
nest g service pledge</pre></li>
				<li>Finally, we need to install the <code>typeorm</code> library, SQLite3, and NestJS integration:<pre>npm i @nestjs/typeorm sqlite3 typeorm</pre><p>TypeORM maps database tables to TypeScript entities by means of decorators on plain objects. </p></li>
				<li>Let's create <code>pledge.entity.ts</code> under <code>/pledge</code> and create our first entity:<pre>import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';
@Entity()
export class Pledge {
  @PrimaryGeneratedColumn()
  id: number;
  @Column()
  desc: string;
  @Column()
  kept: boolean;
}</pre><p>For this entity, we're using a few specialized decorators, such as <code>PrimaryGeneratedColumn</code>. These decorators can be very powerful but often rely on underlying database functionality. Because SQLite can generate an ID for our table, TypeORM is able to expose that in a declarative way with a decorator, but if it couldn't, this wouldn't work. It's always good to check the documentation before proceeding with a new implementation.</p><p>Now that we have an entity, we need to provide configuration to TypeORM about what our database is and where to find it, as well as what entities we want to map. For databases such as MySQL and Postgres, this might include a URI as well as database credentials. Since SQLite is a file-based database, we will just provide the name of the file we want to write.</p><p>Note that production database credentials should always be handled safely, and the best practices for doing so are beyond the scope of this book, but suffice to say that they shouldn't be checked into your version control.</p></li>
				<li>Let's configure our application to use SQLite. We want to configure TypeORM at the root of our application, so let's import the module into <code>app.module.ts</code>:<pre>    TypeOrmModule.forRoot({
      type: 'sqlite',
      database: 'db',
      entities: [Pledge],
      synchronize: true,
    }),</pre></li>
				<li>Doing this will require a couple of more imports at the top of the module:<pre>import { TypeOrmModule } from '@nestjs/typeorm';
import { Pledge } from './pledge/pledge.entity';</pre><p>We're letting NestJS know that our application will use a SQLite database and will manage the <code>Pledge</code> entity. By setting <code>synchronize: true</code>, we are telling TypeORM to automatically create any entities that don't already exist in the database when the application starts. This setting should NOT be used in production as it may cause data loss. TypeORM supports migrations for managing databases in production environments, another topic beyond the scope of this book.</p></li>
				<li>If we start our application now with <code>npm run start:dev</code>, it will start up and we'll get a new binary file (the SQLite database) called <code>db</code>.</li>
				<li>Before we can use the <code>Pledge</code> entity in our new module, we need to do a little more boilerplate. Open up <code>pledge.module.ts</code> and add an import so that the module looks like this:<pre>import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PledgeController } from './pledge.controller';
import { Pledge } from './pledge.entity';
import { PledgeService } from './pledge.service';
@Module({
  controllers: [PledgeController],
  imports: [TypeOrmModule.forFeature([Pledge])],
  providers: [PledgeService],
})
export class PledgeModule {}</pre><p>This will allow the <code>Pledge</code> entity to be used by <code>pledge.service.ts</code>. Again, NestJS has quite a lot of boilerplate, which may be jarring to developers who are used to unopinionated ExpressJS workflows. This module system can help us to isolate our application into functional areas. It's a good idea to understand the benefits of a structured application before deciding whether a framework such as NestJS is right for your application or team.</p><p>We can now start to build out our <code>Pledge</code> service. TypeORM supports both Active Record, where an entity itself has methods for reading and updating, and Data Mapper, where such functionality is delegated to a <code>Repository</code> object. We will follow the Data Mapper pattern in this exercise.</p></li>
				<li>To start, we will add a constructor to the <code>Pledge</code> service and inject the repository to expose it as a private member of the class. Once we've done that, we can start to access some of the repository methods:<pre>import { Injectable } from '@nestjs/common';
import { Pledge } from './pledge.entity';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
@Injectable()
export class PledgeService {
  constructor(
    @InjectRepository(Pledge)
    private pledgeRepository: Repository&lt;Pledge&gt;,
  ) {}
  findAll(): Promise&lt;Pledge[]&gt; {
    return this.pledgeRepository.find();
  }
}</pre><p>We've now exposed a <code>findAll</code> method, which will query the database for all the <code>Pledge</code> entities and return them in an array.</p></li>
				<li>In a production application, it can often be a good idea to implement pagination, but this will do for our purposes. Let's implement some other methods:<pre>import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DeleteResult, Repository } from 'typeorm';
import { Pledge } from './pledge.entity';
@Injectable()
export class PledgeService {
  constructor(
    @InjectRepository(Pledge)
    private pledgeRepository: Repository&lt;Pledge&gt;,
  ) {}
  delete(id: number): Promise&lt;DeleteResult&gt; {
    return this.pledgeRepository.delete(id);
  }
  findAll(): Promise&lt;Pledge[]&gt; {
    return this.pledgeRepository.find();
  }
  findOne(id: number): Promise&lt;Pledge&gt; {
    return this.pledgeRepository.findOne(id);
  }
  save(pledge: Pledge): Promise&lt;Pledge&gt; {
    return this.pledgeRepository.save(pledge);
  }
}</pre><p>We can get pretty far using just repository methods, which will generate SQL queries for us, but it's also possible to use SQL or a query builder with TypeORM.</p></li>
				<li>Implementing these methods in a service won't expose them to our API, so we need to add matching controller methods in <code>pledge.controller.ts</code>. Each controller method will delegate to a service method and NestJS will take care of gluing all the pieces together:<pre>import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { DeleteResult } from 'typeorm';
import { Pledge } from './pledge.entity';
import { PledgeService } from './pledge.service';
@Controller('pledge')
export class PledgeController {
  constructor(private readonly pledgeService: PledgeService) {}
  @Delete(':id')
  deletePledge(@Param('id') id: number): Promise&lt;DeleteResult&gt; {
    return this.pledgeService.delete(id);
  }
  @Get()
  getPledges(): Promise&lt;Pledge[]&gt; {
    return this.pledgeService.findAll();
  }
  @Get(':id')
  getPledge(@Param('id') id: number): Promise&lt;Pledge&gt; {
    return this.pledgeService.findOne(id);
  }
  @Post()
  savePledge(@Body() pledge: Pledge): Promise&lt;Pledge&gt; {
    return this.pledgeService.save(pledge);
  }
}</pre><p>This controller will automatically inject the service and can then easily map service methods to API endpoints using decorators and dependency injection.</p></li>
				<li>Since we ran our application with <code>npm run start:dev</code>, it should hot reload through all these changes. </li>
				<li>Check the console and make sure there are no errors. If our code is correct, we can use a REST client such as Postman to start sending requests to our service. If we send a <code>POST</code> request with a payload such as <code>{"desc":"Always lint your code", "kept": true}</code> to <code>http://localhost:3000/pledge</code>, we'll get back a <code>201 Created</code> HTTP response. Then we can issue <code>GET</code> requests to <code>http://localhost:3000/pledge</code> and <code>http://localhost:3000/pledge/1</code> to see our record that was stored in SQLite.</li>
			</ol>
			<p>In this exercise, we used NestJS and TypeORM to build a real web API that can create and retrieve records from a SQLite database. Doing this isn't very different from using a real production-grade database such as MySQL or PostgreSQL.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor339"/>Activity 13.01: Refactoring Chained Promises to Use await</h2>
			<p>In this activity, we will refactor a function that chains promises together to use <code>await</code>. You are supplied with a starter program that is meant to simulate the creation of DOM elements for a website and render them one after another. In reality, most sites will want to render in parallel, but it's possible that information from one component might inform the rendering of another. It is good enough for example purposes in any case: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this activity can be found here: <a href="https://packt.link/L5r76">https://packt.link/L5r76</a>.</p>
			<ol>
				<li value="1">Start by running the program as-is with <code>npx ts-node src/refactor.ts</code>. You'll get each message in sequence.</li>
				<li>Now, refactor the <code>renderAll</code> function to use <code>async</code>/<code>await</code>. You shouldn't have to touch any other parts of the code to make this work. When your refactoring is complete, run the program again and verify that the output hasn't changed.</li>
			</ol>
			<p> The code for the starter program (<code>refactor.ts</code>) is as follows:</p>
			<pre>export class El {
  constructor(private name: string) {}
  render = () =&gt; {
    return new Promise((resolve) =&gt;
      setTimeout(
        () =&gt; resolve(`${this.name} is resolved`),
        Math.random() * 1000
      )
    );
  };
}
const e1 = new El('header');
const e2 = new El('body');
const e3 = new El('footer');
const renderAll = () =&gt; {
  e1.render().then((msg1) =&gt; {
    console.log(msg1);
    e2.render().then((msg2) =&gt; {
      console.log(msg2);
      e3.render().then((msg3) =&gt; {
        console.log(msg3);
      });
    });
  });
};
renderAll();</pre>
			<p>Once you run the program, you should get the following output:</p>
			<pre>header is resolved
body is resolved
footer is resolved</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor444">this link</a>.</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor340"/>Summary</h1>
			<p>Asynchronous programming has come a long way in the past 10 years and the introduction of <code>async</code>/<code>await</code> has continued to move it forward. Although not perfect for every use case, this syntactic sugar has proven very popular with the TypeScript community and has gained widespread acceptance in popular libraries and frameworks.</p>
			<p>In this chapter, we went over <code>async</code>/<code>await</code> syntax, how it came to be part of the language, and how the use of this syntax is actually complimentary to promises. We then toured several popular frameworks in use by TypeScript developers to see how application developers use promises and asynchronous programming to develop powerful web applications.</p>
			<p>This concludes this book's study of language features. The next chapter will look at React for building user interfaces using TypeScript.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>