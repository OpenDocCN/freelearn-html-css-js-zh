<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-93"><a id="_idTextAnchor093"/>7</h1>
<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Advanced Routing Techniques</h1>
<p>With everything we’ve covered so far, you could set this book down now and go build a simple website using SvelteKit. But if you wanted to build more advanced functionality into your application, you might find yourself struggling to come up with the proper hierarchies for routes. That’s because when it comes to dynamic routing, we’ve only scratched the surface. In <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, we discussed creating dynamic pages with parameters passed to our routes. In that example, we loaded articles by using the provided slug and matching it with those found in our demonstration database. We had no way of knowing what the slug would be ahead of time and it would have been needlessly complicated to create a new route for each article. Instead, we looked at the slug parameter that was received based on the URL being accessed.</p>
<p>This was only a brief introduction to dynamic routing. In this chapter, we’ll look at some more advanced techniques that can help you supercharge your routing logic. We’ll examine routing with optional parameters, parameters of unknown lengths, how to match parameters with regular expressions, which routes will take precedence in instances of routing logic collisions, and more advanced layout techniques, including methodologies for breaking out of them.</p>
<p>This chapter will be broken into the following topics:</p>
<ul>
<li>Using optional parameters</li>
<li>Rest parameters</li>
<li>Matching, sorting, and encoding – oh, my!</li>
<li>Advanced layouts</li>
</ul>
<p>By the end of this chapter, you will have a mastery of the various routing techniques available to you in SvelteKit. No matter your next SvelteKit project’s requirements, you will have the knowledge required for solving and tackling any complex routing dilemmas.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07</a></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Using optional parameters</h1>
<p>Since we teased<a id="_idIndexMarker150"/> optional parameters in the <em class="italic">Creating Dynamic Pages</em> section of <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, let’s start there. When creating optional parameters in a route, there are some things to keep in mind. For instance, they cannot exist alongside another route as this would cause a collision in the routing rules. When creating an optional route, it works best for instances where the final portion of the route can have a default option. Many applications will change the URL based on a language selected by the user. For our example, we’ll illustrate how to create an optional parameter by selecting a country in North America that our demonstration store operates in. We won’t actually build an entire store but rather use it to illustrate the advanced routing concepts in this chapter.</p>
<p>To begin, let’s create a new route in our navigation just like we have for previous examples:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/Nav.svelte</p>
<pre class="source-code">
&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href='/'&gt;Home&lt;/a&gt;&lt;/li&gt;
    ...
    &lt;li&gt;&lt;a href='/login'&gt;Login&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/store'&gt;Store&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</pre>
<p>All we need to do is add another list item with a link to our new route in the navigation menu. After<a id="_idIndexMarker151"/> doing that, we can create the <code>store</code> directory, which is where all of the examples for this chapter will exist:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/store/+layout.svelte</p>
<pre class="source-code">
&lt;h2&gt;Store&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="/store/locations/"&gt;Locations&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/products/"&gt;Products&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;slot /&gt;</pre>
<p>This simple layout will allow us to navigate the various concepts covered in this chapter. After adding links, we use the Svelte <code>&lt;slot&gt;</code> element referenced in earlier chapters. Take a moment to go and create all of the necessary directories. Next, we’ll also create a simple landing page for the <code>/</code><code>store</code> route:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/store/+page.svelte</p>
<pre class="source-code">
&lt;h3&gt;Welcome to the Store!&lt;/h3&gt;</pre>
<p>Having created the files necessary for the <code>/store</code> route as well as the <code>locations</code> directory, we’ll now create yet another directory. The major difference with this one will be that it uses double square brackets (<code>[[country]]</code>) in the name. This is how SvelteKit differentiates optional routes from those that are not. Because we’re creating a page with an optional parameter, we don’t need to create a <code>+page.svelte</code> inside of the <code>locations</code> directory. Rather, we’ll add that inside of the <code>[[country]]</code> directory. To proceed, we’ll create the appropriate <code>+page.svelte</code> and <code>+</code><code>page.js</code> files:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/store/locations/[[country]]/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;h2&gt;You're viewing the {data.country.toUpperCase()} store.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="/store/locations"&gt;North America&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/locations/ca"&gt;Canada&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/locations/me"&gt;Mexico&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/locations/us"&gt;United States&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</pre>
<p>By now, this<a id="_idIndexMarker152"/> should look all too familiar. We use <code>export let data;</code> so that we may access the information provided by <code>load()</code> in the next file. We use that data to inform the user which country’s store locations they are viewing and display the abbreviation in uppercase. We then create an unordered list populated with links to the various allowed routes we will provide in the next file.</p>
<p>In <code>[[country]]/+page.js</code>, we need to check the provided parameters of the route against the list of countries our store operates in. We can do so with the following code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/store/locations/[[country]]/+page.js</p>
<pre class="source-code">
export function load({ params }) {
  const codes = [
    'na',
    'ca',
    'me',
    'us'
  ];
  const found = codes.filter(country_code =&gt; country_code === params.country);
  return {country: found[0] ?? 'na'};
}</pre>
<p>Exporting <code>load()</code> functions should also feel familiar to you at this point. In this particular function, we only need access to <code>params</code> and so we destructure the <code>RequestEvent</code> object passed to <code>load()</code>. We’ve then declared a <code>codes</code> array that works as a list of approved routes. On the next line, we check if the provided route is in the array of approved routes by running <code>filter()</code> on <code>codes</code>. Then <code>filter()</code> returns an array containing all of the matches and assigns it to the <code>found</code> constant. We can then return an object containing the <code>country</code> property, which is assigned the first value inside of <code>found</code>. If the first value of <code>found</code> is empty, we’ll default to the value that shows all of North America. In this case, <code>na</code>.</p>
<p>Once we’ve <a id="_idIndexMarker153"/>done all of this, we can open our application, click <code>load()</code>. When selecting any of the other options, the abbreviation is updated accordingly. As mentioned previously, optional parameters work best when the final section of the route can have a default option. If the optional parameter were to be included somewhere in the middle of the route, then any subsequent portions of the route would be understood by the routing mechanism as the optional parameter.</p>
<p>In this example, we created a new route using double square brackets <code>[[ ]]</code>. While this example has a long way to go before functioning as a complete store, it should illuminate how to use optional parameters in routes. Now that you understand optional parameters, let’s see how we can wrangle routes of unknown lengths.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Rest parameters</h1>
<p>Just as<a id="_idIndexMarker154"/> JavaScript functions can accept rest parameters using the rest operator (<code>…</code>), so too can our routes. By using a rest operator inside of single square brackets, we can allow a variable length on the specified route. This feature comes in handy when creating something like a file browser where the URL should match a path that then makes the page content shareable via the URL.</p>
<p>To see this concept in action, let’s create a <code>products</code> route in our store. Start by adding <code>src/routes/store/products/+layout.svelte</code> so that we may navigate products easily:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/store/products/+layout.svelte</p>
<pre class="source-code">
&lt;h3&gt;Products&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="/store/products/shirts"&gt;Shirts&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/products/shirts/mens"&gt;Mens Shirts&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/products/shirts/mens/tshirts"&gt;Men's T-shirts
    &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/products/shirts/mens/tshirts/cotton"&gt;Men's 
    Cotton T-shirts&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/store/products/shirts/mens/tshirts/cotton/
    graphic"&gt;Men's Graphic Cotton T-shirts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;slot /&gt;</pre>
<p>This <a id="_idIndexMarker155"/>Svelte component is rather simple. It consists of a title, an unordered list, list items, and links to various products. Again, we’ve used the Svelte <code>&lt;slot /&gt;</code> element to keep the navigation on our page as we click around. Next, let’s create an endpoint that can handle the varying lengths of products we’ve just provided. To do so, we’ll create a folder using square brackets and prefix the directory name with the rest operator. For this example, we’ll use <code>[...details]</code> as the directory name. Let’s look at the <code>+page.js</code> and <code>+page.svelte</code> files now:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/store/products/[...details]/+page.js</p>
<pre class="source-code">
export function load({ params }) {
  return params;
}</pre>
<p>Since we’re not building out an entire store, we can keep this one incredibly simple. As we’re attempting to showcase how rest parameters work within SvelteKit’s routing mechanism, we’ll simply return <code>params</code> from <code>load()</code>. A more robust and practical example might take the value from <code>params</code> and use it to filter a list of products retrieved from the database. That data could then be returned from <code>load()</code> for each product to be rendered in the next file.</p>
<p>Now, to <a id="_idIndexMarker156"/>show how the rest parameter value changes, we’ll add the following <code>+page.svelte</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/store/products/[...details]/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  export let data;
&lt;/script&gt;
&lt;h4&gt;Product page&lt;/h4&gt;
{#if data.details}
  &lt;p class='red'&gt;{data.details}&lt;/p&gt;
{:else}
  &lt;p&gt;No product selected! Try clicking one or adding your own URL.
{/if}
&lt;style&gt;
  .red {
    color: red;
    font-weight: bold;
  }
&lt;/style&gt;</pre>
<p>Again, we’re keeping things simple. Instead of showing all of the products that could be available in <code>data</code>, we’re simply using the Svelte <code>{#if}</code> and <code>{:else}</code> directives to demonstrate how the <code>details</code> parameter changes. If <code>data.details</code> is empty, we show a default message. If it has a value, we show it in bold red text. Had we given the directory a different name, that name would be how we accessed the parameter. Try clicking some of the links to the various products and notice how the URL changes in the browser but so too does the value in red. What happens if you add your own values to the URL after <code>/store/products/</code>?</p>
<p>With these <a id="_idIndexMarker157"/>advanced routing techniques, we have to consider some implications. For instance, just as optional parameters work best when at the end section of the URL, rest parameters cannot be followed by an optional parameter. If we attempt to provide optional routing sections after the rest parameter, they will be consumed by the rest parameter. To see the error thrown by the Vite development server, try creating an optional directory inside of <code>/[...details]/</code>. You won’t have to worry about accidentally doing this since Vite will be watching out for you, but it’s still good to know about it when planning routes for your application.</p>
<p>If you find yourself building routes of an unknown length into your application, consider creating them using SvelteKit’s rest parameters. Not only do they handle those indeterminate lengths, but the logic is easily incorporated into the existing flow of SvelteKit apps.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Matching, sorting, and encoding – oh, my!</h1>
<p>If you’re unfamiliar with the ins and outs of SvelteKit’s more advanced routing techniques, it can quickly become unwieldy. To get ahead of the unexpected, we’re going to look at a few more strategies you can use to ensure your application’s routing works as you intend it to. In this section, we will cover how you can ensure that parameters are of the type you’re expecting them to be. We’ll then examine how SvelteKit handles URLs that can resolve to multiple routes. We’ll wrap it up with a bit of information about encoding URLs. You can expect to see the following sub-sections:</p>
<ul>
<li>Matching</li>
<li>Sorting</li>
<li>Encoding</li>
</ul>
<p>Once finished, you’ll be one step closer to mastering the routing of SvelteKit apps.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Matching</h2>
<p>We’ve <a id="_idIndexMarker158"/>looked at how we can use optional and rest parameters in our routes. But think back to the example we created in <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a> dealing with dynamic routes. In the news section, we only checked whether the provided <code>[slug]</code> parameter existed in our database. If we wanted to ensure that the value being passed to our database was in fact a slug, we could create a custom matcher to do just that.</p>
<p>To create a<a id="_idIndexMarker159"/> matcher with SvelteKit, we add a JS file with a descriptive name to <code>src/params/</code>. If the directory doesn’t exist yet, don’t fret! You can simply go ahead and create it now. The files here export a single function: <code>match()</code>. That function accepts one string parameter and returns a boolean value. Because the value passed to the function is a string, we’ll <a id="_idIndexMarker160"/>use <strong class="bold">regular expressions</strong> (<strong class="bold">regex</strong>) to ensure the parameter passed in is of the type we want enforced on our route. Regex may seem daunting at first but there exist plenty of tools online to assist in the creation and learning of regex rules. See the end of this chapter for more resources. Now let’s create a matcher for our news articles to ensure they are being passed a proper slug before we perform our database lookup:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/params/slug.js</p>
<pre class="source-code">
export function match(str) {
  return /^[a-z0-9]+(?:-[a-z0-9]+)*$/gim.test(str);
}</pre>
<p>As is clear, matchers need not be overly complicated. It simply needs to export the <code>match()</code> function, which accepts a string parameter. This matcher then tests that string against a regex literal, returning true for a match and false for a mismatch. This regex tests for one or more string or number characters followed by a <code>–</code> character, which must be followed by one or more string or number characters. A string ending with a <code>–</code> character is considered invalid.</p>
<p class="callout-heading">Applying matchers</p>
<p class="callout">When <a id="_idIndexMarker161"/>applying a matcher to a specific route, the value following the <code>=</code> character is the name of the given matcher. Another example may include creating a matcher that tests for integers. That rule could be enforced on a dynamic route by setting the parameter like so: <code>[param=integer]</code> where <code>params/integer.js</code> is the name of the matcher file.</p>
<p>To apply the matcher we just created to our news articles, we need to rename <code>src/routes/news/[slug]</code> to <code>src/routes/news/[slug=slug]</code>. Once we have adjusted the parameter in our route accordingly, we can go back and view our news articles just as we did before. Of course, the existing articles will match just fine as they contain valid slugs. To test that this matcher is being applied before we run our database lookup, we can create a new article in <code>src/lib/articles.json</code>. The content and <a id="_idIndexMarker162"/>title of the new article object are irrelevant but by creating an article with an invalid slug, we can confirm the matcher is working. Once you have created an article with a bad slug, attempt to view it. You should receive a <strong class="bold">404 Not Found</strong> error even though the article exists. This is because the dynamic parameter passed in did not match our provided regular expression.</p>
<p>While regular expressions can be intimidating to work with, it’s comforting to know that SvelteKit empowers developers to harness the power behind them. Being able to do so ensures our applications work as we intend them to. However, there may still be instances where SvelteKit routes to an endpoint in an unexpected way. To avoid these situations, let’s take a look at which routing rules take precedence over others.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Sorting</h2>
<p>Since it is<a id="_idIndexMarker163"/> entirely possible for a URL to match multiple routes, it’s important to understand which routing rules will be executed in which order. Similar to how CSS rules are given different weights, so too are the rules in SvelteKit’s routing. So which routing rules will be executed when and how do we avoid collisions?</p>
<ol>
<li>More specific routes will always take precedence over less specific routes. A route without a parameter is considered the highest level. For example, <code>src/routes/about/+page.svelte</code> will be executed before <code>src/routes/[param]/+page.svelte</code>.</li>
<li>Applying a matcher to a dynamic parameter will give it a higher priority than those without a matcher. Calling <code>src/routes/news/[slug=slug]/+page.svelte</code> will be given priority over <code>src/routes/news/[slug]/+page.svelte</code>.</li>
<li>Optional and rest parameters are given the least preference. If they are not the final section of the route, they are ignored. For instance, <code>src/routes/[x]/+page.svelte</code> will execute before <code>src/routes/[...rest]/+page.svelte</code>.</li>
<li>Tiebreakers are determined by alphabetical order of the parameters. That is, <code>src/routes/[x]/+page.svelte</code> will execute before <code>src/routes/[z]/+page.svelte</code>.</li>
</ol>
<p>If you’re<a id="_idIndexMarker164"/> planning to leverage the more advanced routing features of SvelteKit, then understanding these rules is an absolute must. Try customizing the routes created in your project and adjusting them to create collisions. See if you can resolve the collisions yourself or predict which pages will be called before others. Next, we’ll look at how to manage special characters in URLs via encoding.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Encoding</h2>
<p>At some<a id="_idIndexMarker165"/> point in their career, every developer has encountered issues with encoding, yet no one ever takes the time to fully understand them. Since you’re a busy developer, eager to get started building, and you probably didn’t pick up this book to get lectured about encoding, we’ll keep this short. To prevent serious frustration when building routes that make use of special characters, SvelteKit lets us encode the routes so they may be used in URLs. Of course, some characters such as <strong class="bold">[</strong> <strong class="bold">]</strong> <strong class="bold">(</strong> <strong class="bold">)</strong> <strong class="bold">#</strong> and <strong class="bold">%</strong> have special meanings either in SvelteKit or the browser and so they are mostly off limits. However, they can still be used when properly encoded in the routing mechanism and URL encoded for the browser.</p>
<p>When creating routes with special characters in SvelteKit, the special characters are written inside of square brackets <code>[ ]</code> similar to how dynamic parameters are. However, they are then prefixed by <code>x+</code> and followed by the hexadecimal value of the character. An example of this is when creating a route to the <code>/.well-known/</code> directory, which could be represented like so: <code>src/routes/[x+2e]well-known/+page.svelte</code>. In most cases, there should be no issues with this route and encoding won’t be necessary, but we’re using it for demonstration purposes. Go ahead and create it in your project. In the browser, navigate to the development site and append the <code>/.well-known/</code> route to confirm it works. Now try to create the route <code>/?-help/</code>. Because <code>src/routes/[x+3f]-help/+page.svelte</code>. But we won’t be able to access the web page at <code>/?-help/</code>. Instead, we’ll need to access that particular route at <code>/%3f%-help/</code>. Whenever using a special character in routes, consider encoding it with the hexadecimal values beforehand.</p>
<p>To obtain<a id="_idIndexMarker166"/> the hexadecimal value of a character, you can use the following JS snippet: <code>':'.charCodeAt(0).toString(16);</code> where <code>:</code> is the special character you’d like to retrieve the hexadecimal value for. We’re not limited to only using hexadecimal values for simple text either. SvelteKit’s routing<a id="_idIndexMarker167"/> also supports <code>[u+xxxx]</code> where <code>xxxx</code> is the Unicode code point.</p>
<p>To ensure our application behaves as expected, it’s essential to know how to properly encode special characters. We also looked at how we can apply matchers to routes so that we can ensure dynamic parameters are of the type we’re expecting them to be. And with our cursory glance at how routes are given precedence over others, you should feel comfortable exploring even more advanced techniques in your application’s routing.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Advanced layouts</h1>
<p>The more<a id="_idIndexMarker168"/> complex the application, the more complex the structure becomes. To keep application logic organized we can utilize more advanced routing mechanisms such as layout groups and breakouts. By using layout groups, we can organize various layout components without cluttering the application URL. And by inserting simple syntax into pages and templates, we can break a layout or page out from its hierarchy while keeping the structure of our application intact.</p>
<p>Since we organize our application components into logical groupings, it makes sense to organize application functionality into logical groupings as well. To demonstrate using a real-world example, consider interface components that are available to logged-in users but not available to anonymous users. When logged in, users can interact with other users through comments, change their profile information, or view their own notifications. A user of the site that is not logged in should not see any of these components. With what we’ve learned so far about layouts, creating different layouts for each type of user could potentially run us into the issue of affecting our application’s clean URL. This is where we can harness SvelteKit’s layout groups.</p>
<p>When creating a layout group, use parenthesis <code>( )</code> to surround the directory name. All content inside of that layout group will then be included in the group and slotted in the <code>+layout.svelte</code> file found there. To demonstrate layout groups, we’ll create two groups: <code>(app)</code> and <code>(site)</code>. Inside of <code>(app)</code>, we’ll move logic related to the application features, and inside of <code>(site)</code>, we’ll move logic commonly found in basic websites. Our<a id="_idIndexMarker169"/> new <code>routes</code> directory structure should look similar to this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/</p>
<pre class="source-code">
src/
|_routes/
   |_(app)/
   |  |_comment/
   |  |_login/
   |  |_notifications/
   |  |_store/
   |
   |_(site)/
   |  |_about/
   |  |_fetch/
   |  |_news/
   |
   |_api/
   |_+layout.server.js
   |_+layout.svelte
   |_+page.svelte</pre>
<p>After shuffling our folders around, we can create a layout for each of our new layout groups:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(app)/+layout.svelte</p>
<pre class="source-code">
&lt;div class='app_layout'&gt;
  &lt;slot /&gt;
&lt;/div&gt;
&lt;style&gt;
  .app_layout {
    background: #cac4c4;
    padding: 1rem;
  }
&lt;/style&gt;</pre>
<p>In this layout file, we’re<a id="_idIndexMarker170"/> wrapping all of the content that will be rendered in the Svelte <code>&lt;slot /&gt;</code> directive with another <code>&lt;div&gt;</code> element that will apply a background color. For simplicity’s sake, we’re only attempting to demonstrate how different layout groups work. The next file does exactly the same thing but applies a different color:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(site)/+layout.svelte</p>
<pre class="source-code">
&lt;div class='site_layout'&gt;
  &lt;slot /&gt;
&lt;/div&gt;
&lt;style&gt;
  .site_layout {
    background: #83a8ee;
    padding: 1rem;
  }
&lt;/style&gt;</pre>
<p>After saving these layouts, you’ll notice the application shows different background colors when navigating the browser to <code>comment/</code>, <code>login/</code>, <code>notifications/</code>, and <code>store/</code> than it does for <code>about/</code>, <code>fetch/</code>, and <code>news/</code>. However, our URLs remain exactly the same!</p>
<p>For cases where <a id="_idIndexMarker171"/>want to break a particular layout or page out of the existing hierarchy, we can append the <code>@</code> character to the filename. For example, <code>+page@</code> or <code>+layout@</code>. We can then follow it up with the name of the directory we would like it to inherit directly from. If no name is provided after the <code>@</code> character, then the root layout will be utilized. We can see this in action by renaming <code>src/routes/(app)/store/products/[...details]/+page.svelte</code> to <code>src/routes/(app)/store/products/[...details]/+page@(app).svelte</code>. Doing so moves the product page out of the product and store layouts. Try renaming it to <code>+page@store.svelte</code> to keep the store layout or <code>+page@.svelte</code> to take it all the way back to the root layout. Of course, our product links are no longer visible as the markup to show them was included in <code>src/routes/(app)/store/products/+layout.svelte</code>, but we’re only trying to demonstrate how you can break a page out of its immediate layouts. This functionality can be useful for separating your application logic into administrative or authenticated sections while keeping the URL unaffected.</p>
<p>We’ve just seen how we can break out of layouts using <code>@</code> symbols in the Svelte component naming conventions. When we include <code>@</code> followed by the name of our desired layout, the file will inherit directly from the named layout instead of all layouts between. We’ve also seen how we can create layout groups to keep our project structured without disrupting the application URL. With everything we’ve covered, you should be capable of meeting even the most complex routing requirements for any SvelteKit project.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Summary</h1>
<p>In the chapters leading up to this, we covered core routing concepts. In this chapter, we looked at the more advanced techniques available in SvelteKit. These techniques can help us further customize our application and address edge cases. When it comes to routing, we now have an understanding of how we can create optional parameters with default values. We’ve also seen how rest parameters can be used to create a shareable URL of unknown lengths. Matching was shown to be useful for ensuring our application is receiving parameters of the expected types. We also saw how SvelteKit prioritizes certain routing rules over others, which is helpful for understanding the order of execution when a URL matches multiple routes. After covering how to encode special characters in routes, we looked at how we can create layout groups and even break out of the layout hierarchies while keeping application logic intact. If you’ve finished this chapter and feel comfortable with everything learned, you’ll be able to handle even the strangest of edge cases encountered while building the routing of your SvelteKit application.</p>
<p>In the next chapter, we’ll take a short break from routing to analyze various SvelteKit adapters and the environments they are used in. We’ll also take a closer look at page options and attempt to build our application for a production environment for the first time.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Resources</h1>
<ul>
<li>RegExr – a great site for practicing and learning regex: <a href="https://regexr.com/">https://regexr.com/</a></li>
<li>Unicode standards: <a href="https://www.unicode.org/standard/standard.html">https://www.unicode.org/standard/standard.html</a></li>
<li>Programming with Unicode: <a href="https://unicodebook.readthedocs.io/index.html">https://unicodebook.readthedocs.io/index.html</a></li>
</ul>
</div>


<div><h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Part 3 – Supplemental Concepts</h1>
<p>This part aims to cover the additional requisite concepts of SvelteKit. It begins by showing you how to produce a build for a production environment with resources showing how easily it can be done using SvelteKit’s adapter system. It then covers how hooks can be used to manipulate data flowing in and out of a SvelteKit application. From there, it addresses how to best import static assets by leveraging Vite. Then, it explains the various modules available in SvelteKit that make the entire framework possible. The section then covers how to ensure that a SvelteKit application can be made available to as many users as possible while boosting search engine rankings. Finally, it wraps up with various resources that will prove invaluable to any developer attempting to power their next project with SvelteKit.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19024_08_Final_AM.xhtml#_idTextAnchor106"><em class="italic">Chapter 8</em></a>, <em class="italic">Builds and Adapters</em></li>
<li><a href="B19024_09_Final_AM.xhtml#_idTextAnchor116"><em class="italic">Chapter 9</em></a>, <em class="italic">Hooks and Error Handling</em></li>
<li><a href="B19024_10_Final_MA.xhtml#_idTextAnchor125"><em class="italic">Chapter 10</em></a>, <em class="italic">Managing Static Assets</em></li>
<li><a href="B19024_11_Final_AM.xhtml#_idTextAnchor137"><em class="italic">Chapter 11</em></a>, <em class="italic">Modules and Secrets</em></li>
<li><a href="B19024_12_Final_AM.xhtml#_idTextAnchor154"><em class="italic">Chapter 12</em></a>, <em class="italic">Enhancing Accessibility and Optimizing SEO</em></li>
<li><a href="B19024_13_Final_AM.xhtml#_idTextAnchor163"><em class="italic">Appendix</em></a> <em class="italic">Examples and Support</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>