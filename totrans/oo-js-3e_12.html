<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Testing and Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Testing and Debugging</h1></div></div></div><p>As you write JavaScript applications, you will soon realize that having a sound testing strategy is indispensable. In fact, not writing enough tests is almost always a bad idea. It is essential to cover all nontrivial functionality of your code to make sure of the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Existing code behaves as per the specifications</li><li class="listitem" style="list-style-type: disc">Any new code does not break the behavior defined by the specifications</li></ul></div><p>Both these points are very important. Many engineers consider only the first point as the sole reason to cover your code with enough tests. The most obvious advantage of test coverage is to really make sure that the code being pushed to production system is mostly error free. Writing test cases to smartly cover maximum functional areas of the code, generally gives good indication around the overall quality of the code. There should be no arguments or compromises around this point. Although, it is unfortunate that many production systems are still bereft of adequate code coverage. It is very important to build an engineering culture where developers think about writing tests as much as they think about writing code.</p><p>The second point is even more important. Legacy systems are usually very difficult to manage. When you are working on code, either written by someone else or written by a large distributed team, it is fairly easy to introduce bugs and break things. Even the best engineers make mistakes. When you are working on a large code base you are unfamiliar with, if there is no sound test coverage to help you, you will introduce bugs. As you won't have the confidence in the changes you are making, because there are no test cases to confirm your changes, your code releases will be shaky, slow, and obviously full of hidden bugs. </p><p>You will refrain from refactoring or optimizing your code, because you won't be really sure what changes to the code base would potentially break something (again, because there are no test case to confirm your changes); all this is a vicious circle. It's like a civil engineer saying-although I have constructed this bridge, I have no confidence on the quality of the construction. It may collapse immediately or never. Although this may sound like an exaggeration, I have seen a lot of high impact production code being pushed with no test coverage. This is risky and should be avoided. When you are writing enough test cases to cover majority of your functional code, when you make change to those pieces, you will immediately realize if there is a problem with this new change. If your changes make the test case fail, you will realize the problem. If your refactor breaks the test scenario, you will realize the problem; all of this happens much before the code is pushed to production.</p><p>In recent years, ideas like test-driven development and self-testing code are gaining prominence, especially in agile methodology. These are fundamentally sound ideas and will help you write robust code - the code you are confident of. We will discuss all these ideas in this chapter. We will understand how to write good test cases in modern JavaScript. We will also look at several tools and methods to debug your code. JavaScript was traditionally a bit difficult to test and debug, primarily due to lack of tools, but modern tools make both of these easy and natural.</p><div class="section" title="Unit testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec88"/>Unit testing</h1></div></div></div><p>When we talk about test cases, we mostly mean unit tests. It is incorrect to assume that the unit we want to test is always a function. The unit, or unit of work, is a logical unit that constitutes single behavior. This unit should be able to be invoked via a public interface and should be testable independently.</p><p>Thus, a unit test can perform the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It tests a single logical function</li><li class="listitem" style="list-style-type: disc">It can run without a specific order of execution</li><li class="listitem" style="list-style-type: disc">It takes care of its own dependencies and mock data</li><li class="listitem" style="list-style-type: disc">It always returns the same result for the same input</li><li class="listitem" style="list-style-type: disc">It should be self-explanatory, maintainable, and readable</li></ul></div><p>Martin Fowler advocates the <span class="emphasis"><em>Test Pyramid</em></span> (<a class="ulink" href="http://martinfowler.com/bliki/TestPyramid.html">http://martinfowler.com/bliki/TestPyramid.html</a>) strategy to make sure we have a high number of unit tests to ensure maximum code coverage. There are two important testing strategies that we will discuss in this chapter.</p><div class="section" title="Test Driven Development"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec162"/>Test Driven Development</h2></div></div></div><p>
<span class="strong"><strong>Test driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>) has gained a lot of prominence in the last few years. The concept was first proposed as part of the extreme programming methodology. The idea is to have short repetitive development cycles where the focus is on writing the test cases first. The cycle looks like the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a test case as per the specifications for the specific unit of code.</li><li class="listitem">Run existing suite of test cases to see if the new test case you wrote fails; it should, because there is no code for that unit yet. This step ensures that the current test harness works well.</li><li class="listitem">Write the code that mainly serves to confirm to the test case. This code is not optimized, refactored, or even entirely correct. However, this is fine at this moment.</li><li class="listitem">Rerun tests and see if all the test cases pass. After this step, you are confident that the new code is not breaking anything.</li><li class="listitem">Refactor code to make sure you are optimizing the unit and handling all corner cases</li></ol></div><p>These steps are repeated for any new code you add. This is an elegant strategy that works really well for agile methodology. TDD will be successful only if the testable units of code are small and confirms only to the test case.</p></div><div class="section" title="Behavior Driven Development"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec163"/>Behavior Driven Development</h2></div></div></div><p>A very common problem while trying to follow TDD is vocabulary and the definition of correctness. BDD tries to introduce a ubiquitous language while writing the test cases when you are following TDD. This language makes sure that both the business and the engineering are talking about the same thing.</p><p>We will use Jasmine as the primary BDD framework and explore various testing strategies.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>You can install Jasmine by downloading the standalone package from <a class="ulink" href="https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip">https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip</a>.</p></div></div><p>When you unzip this package, you will see the following directory structure:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_001.jpg" alt="Behavior Driven Development"/></div><p>
</p><p>The <code class="literal">lib</code> directory contains the JavaScript files that you need in your project to start writing Jasmine test cases. If you open <code class="literal">SpecRunner.html</code>, you will find the following JavaScript files included in it:</p><pre class="programlisting">    &lt;script src="lib/jasmine-2.3.4/jasmine.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="lib/jasmine-2.3.4/jasmine-html.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="lib/jasmine-2.3.4/boot.js"&gt;&lt;/script&gt;     &#13;
 &#13;
    &lt;!-- include source files here... --&gt;    &#13;
    &lt;script src="src/Player.js"&gt;&lt;/script&gt;    &#13;
    &lt;script src="src/Song.js"&gt;&lt;/script&gt;     &#13;
    &lt;!-- include spec files here... --&gt;    &#13;
    &lt;script src="spec/SpecHelper.js"&gt;&lt;/script&gt;    &#13;
    &lt;script src="spec/PlayerSpec.js"&gt;&lt;/script&gt; &#13;
</pre><p>The first three are Jasmine's own framework files. The next section includes the source files we want to test and the actual test specifications.</p><p>Let's experiment with Jasmine via a very ordinary example. Create a <code class="literal">bigfatjavascriptcode.js</code> file and place it in the <code class="literal">src/</code> directory. The function we will test is as follows:</p><pre class="programlisting">    function capitalizeName(name){ &#13;
      return name.toUpperCase(); &#13;
    } &#13;
</pre><p>This is a simple function that does one single thing. It receives a string and returns a capitalized string. We will test various scenarios around this function. This is the unit of code, which we discussed earlier.</p><p>Next, create the test specifications. Create one JavaScript file, <code class="literal">test.spec.js</code>, and place it in the <code class="literal">spec/</code> directory. You will need to add the following two lines into your <code class="literal">SpecRunner.html</code>: The file should contain the following:</p><pre class="programlisting">    &lt;script src="src/bigfatjavascriptcode.js"&gt;&lt;/script&gt;     &#13;
    &lt;script src="spec/test.spec.js"&gt;&lt;/script&gt;    &#13;
</pre><p>The order of this inclusion does not matter. When we run <code class="literal">SpecRunner.html</code>, you will see something like the following image:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_002.jpg" alt="Behavior Driven Development"/></div><p>
</p><p>This is the Jasmine report that shows details about the number of tests that were executed and the count of failures and successes. Now, let's make the test case fail. We want to test a case where an <code class="literal">undefined</code> variable is passed to the function. Let's add one more test case, as follows:</p><pre class="programlisting">    it("can handle undefined", function() { &#13;
        var str= undefined; &#13;
        expect(capitalizeName(str)).toEqual(undefined); &#13;
    }); &#13;
</pre><p>Now, when you run <code class="literal">SpecRunner</code>, you will see the following result:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_003.jpg" alt="Behavior Driven Development"/></div><p>
</p><p>As you can see, the failure is displayed for this test case in a detailed error stack. Now, we will go about fixing this. In your original JS code, handle undefined as follows:</p><pre class="programlisting">    function capitalizeName(name){ &#13;
      if(name){ &#13;
        return name.toUpperCase(); &#13;
      }   &#13;
    } &#13;
</pre><p>With this change, your test case will pass, and you will see the following result in the Jasmine report:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_004.jpg" alt="Behavior Driven Development"/></div><p>
</p><p>This is very similar to what a test-driven development would look like. You write test cases and then fill the necessary code to confirm to the specifications and rerun the test suite. Let's understand the structure of the Jasmine tests.</p><p>Our test specification looks like the following piece of code:</p><pre class="programlisting">    describe("TestStringUtilities", function() { &#13;
          it("converts to capital", function() { &#13;
              var str = "albert"; &#13;
              expect(capitalizeName(str)).toEqual("ALBERT"); &#13;
          }); &#13;
          it("can handle undefined", function() { &#13;
              var str= undefined; &#13;
              expect(capitalizeName(str)).toEqual(undefined); &#13;
          }); &#13;
    }); &#13;
</pre><p>The <code class="literal">describe("TestStringUtilities"</code> is what a test suite is. The name of the test suite should describe the unit-of-code we are testing; this can be a function or a group of related functionality. Inside the specs, you will call the global Jasmine function,<code class="literal">it</code>, to which you will pass the title of the spec and the function that validates the condition of the testcase This function is the actual test case. You can catch one or more assertions or the general expectations using the <code class="literal">expect</code> function. When all expectations are <code class="literal">true</code>, your spec is passed. You can write any valid JavaScript code inside <code class="literal">describe</code> and <code class="literal">it</code> functions. The values you verify as part of the expectations are matched using a matcher. In our example, <code class="literal">toEqual</code> is the matcher that matches two values for equality. Jasmine contains a rich set of matches to suit most of the common use cases. Some common matchers supported by Jasmine are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">toBe</code>: This matcher checks if two objects being compared are equal. This is same as the <code class="literal">===</code> comparison. For example, check out the following code snippet:<pre class="programlisting">        var a = { value: 1}; &#13;
        var b = { value: 1 }; &#13;
 &#13;
        expect(a).toEqual(b);  // success, same as == comparison &#13;
        expect(b).toBe(b);     // failure, same as === comparison &#13;
        expect(a).toBe(a);     // success, same as === comparison &#13;
</pre></li><li class="listitem" style="list-style-type: disc"><code class="literal">not</code>: You can negate a matcher with a not prefix. For example, <code class="literal">expect(1).not.toEqual(2);</code> will negate the match made by <code class="literal">toEqual()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">toContain</code>: This checks if an element is part of an array. It is not an exact object match as <code class="literal">toBe</code>. For example, take a look at the following lines of code:<pre class="programlisting">        expect([1, 2, 3]).toContain(3); &#13;
        expect("astronomy is a science").toContain("science"); &#13;
</pre></li><li class="listitem" style="list-style-type: disc"><code class="literal">toBeDefined</code> and <code class="literal">toBeUndefined</code>: These two matches are handy to check whether a variable is <code class="literal">undefined</code> or not.</li><li class="listitem" style="list-style-type: disc"><code class="literal">toBeNull</code>: This checks if a variable's value is <code class="literal">null</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">toBeGreaterThan</code> and <code class="literal">toBeLessThan</code>: These matcher performs numeric comparison (works on strings too). For example, consider the following piece of code:<pre class="programlisting">        expect(2).toBeGreaterThan(1); &#13;
        expect(1).toBeLessThan(2); &#13;
        expect("a").toBeLessThan("b"); &#13;
</pre></li></ul></div><p>An interesting feature of Jasmine is the spies. When you are writing a large system, it is not possible to make sure that all systems are always available and correct. At the same time, you don't want your unit tests to fail due to a dependency that may be broken or unavailable. To simulate a situation where all dependencies are available for a unit of code we want to test, we will mock this dependency to always give the response we expect. Mocking is an important aspect of testing, and most testing frameworks provide support for mocking. Jasmine allows mocking using a feature called a <span class="strong"><strong>Spy</strong></span>. Jasmine spies essentially stubs the functions we may not have ready at the time of writing the test case, but as part of the functionality, we will need to track that we are executing those dependencies and not ignoring them. Consider the following example:</p><pre class="programlisting">    describe("mocking configurator", function() { &#13;
      var cofigurator = null; &#13;
      var responseJSON = {}; &#13;
 &#13;
      beforeEach(function() { &#13;
        configurator = { &#13;
          submitPOSTRequest: function(payload) { &#13;
            //This is a mock service that will eventually be replaced  &#13;
            //by a real service &#13;
            console.log(payload); &#13;
            return {"status": "200"}; &#13;
          } &#13;
        }; &#13;
        spyOn(configurator, 'submitPOSTRequest').and.returnValue&#13;
         ({"status": "200"}); &#13;
       configurator.submitPOSTRequest({ &#13;
          "port":"8000", &#13;
          "client-encoding":"UTF-8" &#13;
        }); &#13;
      }); &#13;
 &#13;
      it("the spy was called", function() { &#13;
        expect(configurator.submitPOSTRequest).toHaveBeenCalled(); &#13;
      }); &#13;
 &#13;
      it("the arguments of the spy's call are tracked", function() { &#13;
        expect(configurator.submitPOSTRequest).toHaveBeenCalledWith(&#13;
          {"port":"8000", "client-encoding":"UTF-8"}); &#13;
      }); &#13;
    }); &#13;
</pre><p>In this example, while we are writing this test case, we either don't have the real implementation of the dependency, <code class="literal">configurator.submitPOSTRequest()</code>, or someone is fixing this particular dependency; in any case, we don't have it available. For our test to work, we will need to mock it. Jasmine spies allow us to replace a function with its mock and allows us to track its execution.</p><p>In this case, we will need to ensure that we called the dependency. When the actual dependency is ready, we will revisit this test case to make sure it fits the specifications; however, at this time, all we need to ensure that the dependency is called. Jasmine function <code class="literal">tohaveBeenCalled()</code> lets us track the execution of a function that may be a mock. We can use <code class="literal">toHaveBeenCalledWith()</code>, which allows us to determine if the stub function was called with correct parameters. There are several other interesting scenarios you can create using Jasmine spies. The scope of this chapter won't permit us to cover them all, but I would encourage you to discover those areas on your own.</p></div><div class="section" title="Mocha, Chai and Sinon"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec164"/>Mocha, Chai and Sinon</h2></div></div></div><p>Though Jasmine is the most prominent JavaScript testing framework, mocha and chai are gaining prominence in the <code class="literal">Node.js</code> environment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mocha is the testing framework used to describe and run test cases</li><li class="listitem" style="list-style-type: disc">Chai is the assertion library supported by Mocha</li><li class="listitem" style="list-style-type: disc">Sinon comes in handy while creating mocks and stubs for your tests</li></ul></div><p>We won't discuss these frameworks in this book; however, experience on Jasmine will be handy if you want to experiment with these frameworks.</p></div></div></div>
<div class="section" title="JavaScript debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec89"/>JavaScript debugging</h1></div></div></div><p>If you are not a completely new programmer, I am sure you must have spent some amount of time debugging your or someone else's code. Debugging is almost like an art form. Every language has different methods and challenges around the debugging. JavaScript is traditionally a difficult language to debug. I have spent days and nights in misery, trying to debug badly written JavaScript code using <code class="literal">alert()</code> functions. Fortunately, modern browsers, such as Mozilla, Firefox, and Google Chrome, have excellent <span class="strong"><strong>Developer Tools</strong></span> to help debug JavaScript in the browser. There are IDEs like IntelliJ IDEA and WebStorm with great debugging support for JavaScript and Node.js. In this chapter, we will focus primarily on Google Chrome's built-in developer tool. Firefox also supports Firebug extension and has excellent built-in developer tools, but as they behave more or less the same as Google Chrome's <span class="strong"><strong>Developer Tools</strong></span>, we will discuss common debugging approaches that work in both of these tools.</p><p>Before we talk about the specific debugging techniques, let's understand the type of errors we would be interested in while we try to debug our code.</p><div class="section" title="Syntax errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec165"/>Syntax errors</h2></div></div></div><p>When your code has something that does not confirm to the JavaScript language grammar, the interpreter rejects that piece of code. These are easy to catch if your IDE is helping you with syntax checking. Most modern IDEs help with these errors. Earlier, we discussed the usefulness of tools, such as JSLint and JSHint, around catching syntax issues with your code. They analyze the code and flag errors in the syntax. The JSHint output can be very illuminating. For example, the following output shows up so many things we can change in the code. The following code snippet is from one of my existing projects:</p><pre class="programlisting">    temp git:(dev_branch) X jshint test.js &#13;
    test.js: line 1, col 1, Use the function form of "use strict". &#13;
    test.js: line 4, col 1, 'destructuring expression' &#13;
      is available in ES6 (use esnext option) or &#13;
      Mozilla JS extensions (use moz). &#13;
    test.js: line 44, col 70, 'arrow function syntax (=&gt;)' &#13;
      is only available in ES6 (use esnext option). &#13;
    test.js: line 61, col 33, 'arrow function syntax (=&gt;)'&#13;
      is only available in ES6 (use esnext option). &#13;
    test.js: line 200, col 29, Expected ')' to match '(' from&#13;
      line 200 and instead saw ':'. &#13;
    test.js: line 200, col 29, 'function closure expressions' &#13;
      is only available in Mozilla JavaScript extensions (use moz option). &#13;
    test.js: line 200, col 37, Expected '}' to match '{' from &#13;
      line 36 and instead saw ')'. &#13;
    test.js: line 200, col 39, Expected ')' and instead saw '{'. &#13;
    test.js: line 200, col 40, Missing semicolon. &#13;
</pre><div class="section" title="Using strict"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec85"/>Using strict</h3></div></div></div><p>We briefly discussed the strict mode in earlier chapters. When you enable strict mode, JavaScript stops being accepting of syntactical errors in your code. Rather than silently failing, strict mode makes these failure throw errors instead. It also helps you convert mistakes into actual errors. There are two ways of enforcing strict mode. If you want the strict mode for the entire script, you can just add the <code class="literal">use strict</code> statement (with the quotes) as the first line of your JavaScript program. If you want a specific function to confirm to strict mode, you can add the directive as the first line of a function. For example, take a look at the following code snippet:</p><pre class="programlisting">    function strictFn(){    &#13;
      // This line makes EVERYTHING under this scrict mode &#13;
      'use strict';    &#13;
      ... &#13;
      function nestedStrictFn() {  &#13;
        //Everything in this function is also nested &#13;
        ... &#13;
      }    &#13;
    } &#13;
</pre></div></div><div class="section" title="Runtime exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec166"/>Runtime exceptions</h2></div></div></div><p>These errors appear when you execute the code, try to refer to an <code class="literal">undefined</code> variable, or try to process a <code class="literal">null</code>. When a runtime exception occurs, any code after that particular line, which caused the exception, does not get executed. It is essential to correctly handle such exceptional scenarios in the code. While exception handling can help prevent crashes, they also aid in debugging. You can wrap the code that may encounter a runtime exception into a <code class="literal">try{ }</code> block. When any code inside this block generates a runtime exception, a corresponding handler captures it. The handler is defined by a <code class="literal">catch(exception){}</code> block. Let's clarify this using the following example:</p><pre class="programlisting">    try { &#13;
      var a = doesnotexist; // throws a runtime exception &#13;
    } catch(e) {  &#13;
      console.log(e.message);  //handle the exception &#13;
      //prints - "doesnotexist is not defined" &#13;
    } &#13;
</pre><p>In this example, the <code class="literal">var a = doesnotexist</code> line tries to assign an <code class="literal">undefined</code> variable, <code class="literal">doesnotexist</code>, to another variable <code class="literal">a</code>. This causes a runtime exception. When we wrap this problematic code into <code class="literal">try{}catch(){}</code> block or when the exception occurs (or is thrown), the execution stops in the <code class="literal">try{}</code> block and goes directly to the <code class="literal">catch() {}</code> handler. The catch handler is responsible for handling the exceptional scenario. In this case, we are displaying the error message on the console for debugging purposes. You can explicitly throw an exception to trigger an unhandled scenario in the code. Consider the following example:</p><pre class="programlisting">    function engageGear(gear){ &#13;
      if(gear==="R"){ console.log ("Reversing");} &#13;
      if(gear==="D"){ console.log ("Driving");} &#13;
      if(gear==="N"){ console.log ("Neutral/Parking");} &#13;
      throw new Error("Invalid Gear State"); &#13;
    } &#13;
    try &#13;
    { &#13;
      engageGear("R");  //Reversing &#13;
      engageGear("P");  //Invalid Gear State &#13;
    } &#13;
    catch(e){ &#13;
      console.log(e.message); &#13;
    } &#13;
</pre><p>In this example, we are handling valid states of a gear shift: <code class="literal">R</code>, <code class="literal">N</code>, and <code class="literal">D</code>; however, when we receive an invalid state, we are explicitly throwing an exception clearly stating the reason. When we call the function which we think may throw an exception, we will wrap the code in the <code class="literal">try{}</code> block and attach a <code class="literal">catch(){}</code> handler with it. When the exception is caught by the <code class="literal">catch()</code> block, we will handle the exceptional condition appropriately.</p><div class="section" title="Console.log and asserts"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec86"/>Console.log and asserts</h3></div></div></div><p>Displaying the state of execution on console can be very useful while debugging. Although, modern developer tools allow you to put breakpoints and halt execution to inspect a particular value during runtime. You can quickly detect small issues by logging some variable state on the console.</p><p>With these concepts with us, let's see how we can use Chrome <span class="strong"><strong>Developer Tools</strong></span> to debug JavaScript code.</p></div><div class="section" title="Chrome Developer Tools"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec87"/>Chrome Developer Tools</h3></div></div></div><p>You can start Chrome <span class="strong"><strong>Developer Tools</strong></span> by clicking <span class="strong"><strong>menu</strong></span> | <span class="strong"><strong>More tools</strong></span> | <span class="strong"><strong>Developer Tools</strong></span>. Take a look at the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_005.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>Chrome developer tool opens up on the lower pane of your browser and has a bunch of very useful sections. Consider the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_006.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>The <span class="strong"><strong>Elements</strong></span> panel helps you inspect and monitor the DOM tree and associated style sheet for each of these components.</p><p>The <span class="strong"><strong>Network</strong></span> panel is useful to understand network activity. For example, you can monitor the resources being downloaded over the network in real time.</p><p>The most important pane for us is the <span class="strong"><strong>Sources</strong></span> pane. This pane is where the JavaScript and the debugger are displayed. Let's create a sample HTML with the following content:</p><pre class="programlisting">    &lt;!DOCTYPE html&gt; &#13;
    &lt;html&gt; &#13;
    &lt;head&gt; &#13;
      &lt;meta charset="utf-8"&gt; &#13;
      &lt;title&gt;This test&lt;/title&gt; &#13;
      &lt;script type="text/javascript"&gt; &#13;
      function engageGear(gear){ &#13;
        if(gear==="R"){ console.log ("Reversing");} &#13;
        if(gear==="D"){ console.log ("Driving");} &#13;
        if(gear==="N"){ console.log ("Neutral/Parking");} &#13;
        throw new Error("Invalid Gear State"); &#13;
      } &#13;
      try &#13;
      { &#13;
        engageGear("R");  //Reversing &#13;
        engageGear("P");  //Invalid Gear State &#13;
      } &#13;
      catch(e){ &#13;
        console.log(e.message); &#13;
      } &#13;
      &lt;/script&gt; &#13;
    &lt;/head&gt; &#13;
    &lt;body&gt; &#13;
    &lt;/body&gt; &#13;
    &lt;/html&gt; &#13;
</pre><p>Save this HTML file and open it in Google Chrome. Open <span class="strong"><strong>Developer Tools</strong></span> in the browser, and you will see the following screen:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_007.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>This is the view of the <span class="strong"><strong>Sources</strong></span> panel. You can see the HTML and embedded JavaScript source in this panel. You can see the <span class="strong"><strong>Console</strong></span> window as well, and you can see that the file is executed and the output is displayed on console.</p><p>On the right side, you will see the debugger window, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_008.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>In the <span class="strong"><strong>Sources</strong></span> panel, click on the line numbers <span class="strong"><strong>8</strong></span> and <span class="strong"><strong>15</strong></span> to add a breakpoint. The breakpoints allow you to stop execution of the script at the specified point. Consider the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/5239_12.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>In the debug pane, you can see all existing breakpoints. Take a look at the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_010.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>Now, when you rerun the same page, you will see that the execution stops at the debug point. Consider the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_011.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>This window now has all the action. You can see that the execution is paused on line <span class="strong"><strong>15</strong></span>. In the debug window, you can see which breakpoint is being triggered. You can also see the <span class="strong"><strong>Call Stack</strong></span> and resume execution in several ways. The debug command window has a bunch of actions. Take a look at the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_012.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>You can resume execution, which will execute until the next breakpoint, by clicking on the following button:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_013.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>When you do that, the execution continues until the next breakpoint is encountered. In our case, we will halt at line <span class="strong"><strong>8</strong></span>. Consider the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_12_014.jpg" alt="Chrome Developer Tools"/></div><p>
</p><p>You can observe that the <span class="strong"><strong>Call Stack</strong></span> window shows how we arrived at line <span class="strong"><strong>8</strong></span>. The <span class="strong"><strong>Scope</strong></span> panel shows the <span class="strong"><strong>Local</strong></span> scope where you can see the variables in the scope when the breakpoint was arrived at. You can also Step-Into or Step-over the next function.</p><p>There are other very useful mechanisms to debug and profile your code using Chrome <span class="strong"><strong>Developer Tools</strong></span>. I would suggest you to experiment with the tool and make it a part of your regular development flow.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec90"/>Summary</h1></div></div></div><p>Both testing and debugging phases are essential to developing robust JavaScript code. TDD and BDD are approaches closely associated with the agile methodology and is widely embraced by the JavaScript developer community. In this chapter, we reviewed best practices around TDD and the usage of Jasmine as the testing framework. Additionally, we saw various methods of debugging JavaScript using Chrome <span class="strong"><strong>Developer Tools</strong></span>.</p><p>In the next chapter, we will explore the new and exciting world of ES6, DOM Manipulation and cross-browser strategies.</p></div></body></html>