<html><head></head><body>
		<div><h1 id="_idParaDest-148" class="chapter-number"><a id="_idTextAnchor148"/>8</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Connecting Functions – Pipelining, Composition, and More</h1>
			<p>In <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>, we looked at ways to build new functions by applying higher-order functions. In this chapter, we will go to the core of FP and learn how to create sequences of function calls and how to combine them to produce a more complex result out of several simpler components. To do this, we will cover the following topics:</p>
			<ul>
				<li><strong class="bold">Pipelining</strong>: A way to <a id="_idIndexMarker585"/>join functions, similar to Unix/Linux pipes</li>
				<li><strong class="bold">Chaining</strong>: A variant of<a id="_idIndexMarker586"/> pipelining, but restricted to objects</li>
				<li><strong class="bold">Composing</strong>: A classic<a id="_idIndexMarker587"/> operation with its origins in basic computer theory</li>
				<li><code>map</code>, <code>filter</code>, or <code>reduce</code> operations</li>
			</ul>
			<p>Along the way, we will be touching on related concepts, such as the following:</p>
			<ul>
				<li><strong class="bold">Pointfree style</strong>, which is often <a id="_idIndexMarker589"/>used with pipelining and composition</li>
				<li><strong class="bold">Debugging</strong> of composed or piped functions, for which we’ll whip up some auxiliary tools</li>
				<li><strong class="bold">Testing</strong> for these functions, which won’t prove to be of high complexity</li>
			</ul>
			<p>Armed with these techniques, you’ll be able to combine small functions to create larger ones, which is a characteristic of FP and will help you develop better code.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Pipelining</h1>
			<p>Pipelining and <a id="_idIndexMarker590"/>composition are techniques that are used to set up functions to work in sequence so that the output of a function becomes the input for the following function. There are two ways of looking at this: from a computer point of view, and from a mathematical point of view. We’ll look at both in this section. Most FP texts start with the latter, but since I assume that most of you will prefer computers over math, let’s start with<a id="_idIndexMarker591"/> the former instead.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor151"/>Piping in Unix/Linux</h2>
			<p>In Unix/Linux, executing a command and passing its output as input to a second command, whose output will yield the input of a third command, and so on, is called a pipeline. This is quite a common <a id="_idIndexMarker592"/>application of the philosophy of Unix, as explained in a Bell Laboratories article written by the creator of the pipelining concept<a id="_idIndexMarker593"/> himself, Doug McIlroy:</p>
			<ul>
				<li>Make each program do one thing well. To do a new job, build afresh rather than complicating old programs by adding new features.</li>
				<li>Expect the output of every program to become the input to another, so far unknown program.</li>
			</ul>
			<p class="callout-heading">A bit of history</p>
			<p class="callout">Given the historical importance of Unix, I’d recommend reading some of the seminal articles describing the (then new) operating system in the Bell System Technical Journal, July 1978, at <a href="http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf">emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf</a>. The two quoted rules are in the <em class="italic">Style</em> section of the <em class="italic">Foreword</em> article.</p>
			<p>Let’s consider a simple example to get started. Suppose I want to know how many LibreOffice text documents there are in a directory. There are many ways to do this, but the following example will do. We will execute three commands, piping (that’s the meaning of the <code>|</code> character) each command’s output as input to the next one. Suppose we have <code>cd /home/fkereki/Documents</code> and then do the following (please ignore the dollar sign, which is just the console prompt):</p>
			<pre class="console">
$ ls -1 | grep "odt$" | wc -l
<strong class="bold">4</strong></pre>
			<p>What does this mean? How does it work? We have to analyze this process step by step:</p>
			<ul>
				<li>The first part of the pipeline, <code>ls -1</code>, lists all the files in the current directory (<code>/home/fkereki/Documents</code>, as per our <code>cd</code> command) in a single column, with one filename per line</li>
				<li>The output from the first command is provided as input to <code>grep "odt$"</code>, which filters (only lets pass) lines that finish with <code>"odt"</code>, the standard file extension for LibreOffice Writer</li>
				<li>The filtered output is provided to the counting command, <code>wc -l</code>, which counts how many<a id="_idIndexMarker594"/> lines there are in its input</li>
			</ul>
			<p class="callout-heading">More on pipelining</p>
			<p class="callout">You can find out more about pipelines in <em class="italic">Section 6.2</em>, <em class="italic">Filters</em>, of <em class="italic">The UNIX Time-Sharing System</em> by Dennis Ritchie<a id="_idIndexMarker595"/> and Ken Thompson, also in the issue of the Bell Laboratories journal that I mentioned previously.</p>
			<p>From the point of view of FP, this is a key concept. We want to build more complex operations out of simple, single-purpose, shorter functions. Pipelining is what the Unix shell uses to apply that concept. It does this by simplifying the job of executing a command, taking its output, and providing it as input to yet another command. We will apply similar<a id="_idIndexMarker596"/> concepts in our own functional style in JavaScript later:</p>
			<div><div><img src="img/Figure_8.1_B19301.jpg" alt="Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines. The output of each function becomes the input for the next"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines. The output of each function becomes the input for the next</p>
			<p>By the way (and no—rest assured, this isn’t turning into a shell tutorial!), you can make pipelines accept parameters. For example, if I happened to want to count how many files I had with this or that extension, I could create a function such as <code>cfe</code>, standing for <em class="italic">count </em><em class="italic">for extension</em>:</p>
			<pre class="console">
$ function cfe() {
ls -1 | grep "$1\$"| wc -l
}</pre>
			<p>Then, I could use <code>cfe</code> as a command, giving it the desired extension as an argument:</p>
			<pre class="console">
$ cfe odt
<strong class="bold">4</strong>
$ cfe pdf
<strong class="bold">6</strong></pre>
			<p><code>cfe</code> executes my pipeline and tells me I have four <code>odt</code> files (LibreOffice) and six <code>pdf</code> files; nice! We will also<a id="_idIndexMarker597"/> want to write similar parametric pipelines: we are not constrained to fixed functions in <a id="_idIndexMarker598"/>our flow; we have full liberty regarding what we want to include. Having worked in Linux, we can now go back to coding. Let’s see how.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor152"/>Revisiting an example</h2>
			<p>We can start tying <a id="_idIndexMarker599"/>ends together by revisiting a problem from a previous chapter. Remember when we had to calculate the average latitude and longitude for some geographic data that we looked at in the <em class="italic">Extracting data from objects</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a><em class="italic">, Programming Declaratively</em>? Basically, we started with some data such as the following, and the problem was to calculate the average latitude and longitude of the given points:</p>
			<pre class="source-code">
const markers = [
  { name: "AR", lat: -34.6, lon: -58.4 },
  { name: "BO", lat: -16.5, lon: -68.1 },
  { name: "BR", lat: -15.8, lon: -47.9 },
  { name: "CL", lat: -33.4, lon: -70.7 },
  { name: "CO", lat:   4.6, lon: -74.0 },
  { name: "EC", lat:  -0.3, lon: -78.6 },
  { name: "PE", lat: -12.0, lon: -77.0 },
  { name: "PY", lat: -25.2, lon: -57.5 },
  { name: "UY", lat: -34.9, lon: -56.2 },
  { name: "VE", lat:  10.5, lon: -66.9 },
];</pre>
			<p>With what we know, we can write a solution in terms of the following:</p>
			<ul>
				<li>Being able to extract the latitude (and afterward, the longitude) from each point</li>
				<li>Using that function to create an array of latitudes</li>
				<li>Pipelining the resulting array to the average function we wrote in the <em class="italic">Calculating an average</em> section of the aforementioned chapter</li>
			</ul>
			<p>To do the first task, we can use the <code>myMap()</code> function from the <em class="italic">Parameter order</em> section of <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a><em class="italic">, Transforming Functions</em>. For the second task, we can make do with the <code>getField()</code> function from the <em class="italic">Getting a property from an object</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, Producing Functions</em>. Finally, for the third task, we’ll <a id="_idIndexMarker600"/>use the (yet unwritten) <code>pipeline()</code> function we’ll develop soon! In full, our solution could look like this:</p>
			<pre class="source-code">
const sum = (x: number, y: number): number =&gt; x + y;
const average = (arr: number[]) =&gt;
  arr.reduce(sum, 0) / arr.length;
const myMap = curry(
  flip2(demethodize(Array.prototype.map))
);
const getAllLats = myMap(getField("lat")) as (
  arg: any
) =&gt; number[];
const averageLat = <strong class="bold">pipeline</strong>(getAllLats, average)(markers);
// and similar code to average longitudes</pre>
			<p>We had to add some casting to <code>getAllLats</code> so that TypeScript would know to what we would apply that function.</p>
			<p>Of course, you can always yield to the temptation of going for one-liners, but would it be much clearer or better?</p>
			<pre class="source-code">
const averageLat2 = pipeline(
  curry(flip2(demethodize(Array.prototype.map)))(
    getField("lat")
  ) as (arg: any) =&gt; number[],
  average
)(markers);</pre>
			<p>Whether this makes sense to you will depend on your experience with FP. In any case, no matter which solution you take, the fact remains that adding pipelining (and later on, composition) to your set of tools can help you write tighter, declarative, simpler-to-understand code.</p>
			<p>Now, let’s learn <a id="_idIndexMarker601"/>how to pipeline functions in the right way.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor153"/>Creating pipelines</h2>
			<p>We want to be able to generate a pipeline of several functions. We can do this in two ways: by building the pipeline by hand, in a problem-specific way, or by using more generic constructs that can <a id="_idIndexMarker602"/>be applied with generality. Let’s look at both.</p>
			<p class="callout-heading">Potential pipeline proposal</p>
			<p class="callout">A new operator, <code>|&gt;</code>, is being considered for JavaScript, but it’s currently only at stage 2, which means it may be a while before it’s accepted and available. You may read more about the proposal and its varied history at <a href="http://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md">github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md</a>.</p>
			<h3>Building pipelines by hand</h3>
			<p>Let’s go with a <a id="_idIndexMarker603"/>Node.js example, similar to the command-line pipeline we built earlier in this chapter. Here, we’ll build the pipeline we need by hand. We need a function to read all the files in a directory. We can do that (although this isn’t recommended because of the synchronous call, which is normally not good in a server environment) with something like this:</p>
			<pre class="source-code">
// pipeline.ts
function getDir(path) {
  const fs = require("fs");
  const files = fs.readdirSync(path);
  return files;
}</pre>
			<p>Selecting only <code>odt</code> files is quite simple. We start with the following function:</p>
			<pre class="source-code">
// continued...
const filterByText = (
  text: string,
  arr: string[]
): string[] =&gt; arr.filter(<strong class="bold">(v) =&gt; v.endsWith(text)</strong>);</pre>
			<p>This function takes an array of strings and filters out elements that do not end with the given text, so we can <a id="_idIndexMarker604"/>now write the following:</p>
			<pre class="source-code">
// continued...
const filterOdt = (arr: string[]): string[] =&gt;
  <strong class="bold">filterByText(".odt", arr)</strong>;</pre>
			<p>Better still, we can apply currying and go for pointfree style, as shown in the <em class="italic">An unnecessary mistake</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, and write this, instead:</p>
			<pre class="source-code">
// continued...
const filterOdt = <strong class="bold">curry(filterByText)</strong>(".odt");</pre>
			<p>Both versions of the filtering function are equivalent; which one you use comes down to your tastes. Finally, we can write the following to count elements in an array. Since <code>length</code> is not a function, we cannot apply our demethodizing trick:</p>
			<pre class="source-code">
// continued...
const count = &lt;T&gt;(arr: T[]): number =&gt; <strong class="bold">arr.length</strong>;</pre>
			<p>With these functions, we could write something like this:</p>
			<pre class="source-code">
// continued...
const countOdtFiles = (path: string): number =&gt; {
  const files = getDir(path);
  const filteredFiles = filterOdt(files);
  const countOfFiles = count(filteredFiles);
  return countOfFiles;
};
<strong class="bold">countOdtFiles("/home/fkereki/Documents")</strong>;
// 4, as with the command line solution</pre>
			<p>We are essentially doing the same process as in Linux: getting the files, keeping only the <code>odt</code> ones, and counting how many files result from this. If you wanted to get rid of all the intermediate variables, you could also go for a one-liner definition that does precisely the same job in the very same way, albeit with fewer lines:</p>
			<pre class="source-code">
const countOdtFiles2 = (path: string): number =&gt;
  <strong class="bold">count(filterOdt(getDir(path)))</strong>;
const c2 = countOdtFiles2("/home/fkereki/Documents");
// 4, again</pre>
			<p>This gets to the <a id="_idIndexMarker605"/>crux of the matter: both implementations of our file-counting function have disadvantages. The first definition uses several intermediate variables to hold the results and makes a multiline function out of what was a single line of code in the Linux shell. On the other hand, the second, much shorter definition is harder to understand, insofar as we are writing the steps of the computation in seemingly reverse order! Our pipeline has to read files first, then filter them, and finally count them, but those functions appear <em class="italic">the other way around</em> in our definition!</p>
			<p>We can undoubtedly implement pipelining by hand, as we have seen, but it would be better if we went for a more declarative style.</p>
			<p>Let’s move on and try to build a better pipeline more clearly and more understandably by applying some of the concepts we’ve already seen.</p>
			<h3>Using other constructs</h3>
			<p>If we think in functional terms, what<a id="_idIndexMarker606"/> we have is a list of functions and we want to apply them sequentially, starting with the first, then applying the second to whatever the first function produced as its result, and then applying the third to the second function’s results, and so on. If we were fixing a pipeline of two functions, we could use the following code:</p>
			<pre class="source-code">
// continued...
const pipeTwo =
  &lt;AF extends any[], RF, RG&gt;(
    f: (...args: AF[]) =&gt; RF,
    g: (arg: RF) =&gt; RG
  ) =&gt;
  (...args: any[]) =&gt; g(f(...args));</pre>
			<p>This is the basic definition we provided earlier in this chapter: we evaluate the first function, and its output becomes the input for the second function; relatively straightforward! Typing is simple: the first function to apply (<code>f()</code>) may have any number of parameters, but the second function (<code>g()</code>) must have a single one, the same type that <code>f()</code> returns. The return type of the pipeline is the return type of <code>g()</code>.</p>
			<p>You may object, though, that this pipeline of only two functions is a bit too limited! This is not as useless as it may seem because we can compose longer pipelines—though I’ll admit that it requires<a id="_idIndexMarker607"/> too much writing! Suppose we wanted to write our three-function pipeline (from the previous section); we could do so in two different, equivalent ways:</p>
			<pre class="source-code">
// continued...
const countOdtFiles3 = (path: string): number =&gt;
  <strong class="bold">pipeTwo(pipeTwo(getDir, filterOdt), count)</strong>(path);
const countOdtFiles4 = (path: string): number =&gt;
  <strong class="bold">pipeTwo(getDir, pipeTwo(filterOdt, count))</strong>(path);</pre>
			<p class="callout-heading">A touch of math</p>
			<p class="callout">We are taking advantage of the fact that piping is an associative operation. In mathematics, the associative property is the one that says that we can compute 1+2+3 either by adding 1+2 first and then adding that result to 3 or by adding 1 to the result of first adding 2+3: in other terms, 1+2+3 is the same as (1+2)+3 or 1+(2+3).</p>
			<p>How do they work? How is it that they are equivalent? Following the execution of a given call will be useful; it’s quite easy to get confused with so many calls! The first implementation can be followed step by step until the final result, which matches what we already know:</p>
			<pre class="source-code">
countOdtFiles3(path) ===
  pipeTwo(pipeTwo(getDir, filterOdt), count)
  pipeTwo(filterOdt(getDir(path)), count)(path)
  pipeTwo(count(filterOdt(getDir(path))))</pre>
			<p>The second implementation also comes to the same final result:</p>
			<pre class="source-code">
countOdtFiles4(path) ===
  pipeTwo(getDir, pipeTwo(filterOdt, count))(path)
  pipeTwo(getDir(path), pipeTwo(filterOdt, count))
  pipeTwo(filterOdt, count)(getDir(path))
  pipeTwo(count(filterOdt(getDir(path))))</pre>
			<p>Both derivations arrived at the same final expression—the same we had written by hand earlier, in fact—so <a id="_idIndexMarker608"/>we now know that we can make do just with a basic <em class="italic">pipe of two</em> higher-order functions, but we’d really like to be able to work in a shorter, more compact way. A first implementation could be along the lines of the following, and let’s look at typing later:</p>
			<pre class="source-code">
function pipeline(...fns) {
  return (...args) =&gt; {
    let result = fns[0](...args);
    for (let i = 1; i &lt; fns.length; i++) {
      result = fns[i](result);
    }
    return result;
  };
}
<strong class="bold">pipeline(</strong>
<strong class="bold">  getDir,</strong>
<strong class="bold">  filterOdt,</strong>
<strong class="bold">  count</strong>
<strong class="bold">)</strong>("/home/fkereki/Documents"); // still 4</pre>
			<p>This does work—and specifying our file-counting pipeline is much clearer since the functions are given in their proper order. However, the implementation of the <code>pipeline()</code> function is not very functional and goes back to old, imperative, loop-by-hand methods. We can do better using <code>reduce()</code>, as in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>.</p>
			<p>The idea is to start the evaluation with the first function, pass the result to the second, then that result to the third, and so on. By doing this, we can pipeline with shorter code, and again we’ll leave typing for later:</p>
			<pre class="source-code">
// continued...
function pipeline2(...fns) {
  return fns.reduce(
    (result, f) =&gt;
      (...args) =&gt;
        f(result(...args))
  );
}</pre>
			<p>This code is more declarative. However, you could have gone one better by writing it using our <code>pipeTwo()</code> function, which does the same thing but more concisely:</p>
			<pre class="source-code">
// continued...
function pipeline3(...fns) {
  return fns.reduce(pipeTwo);
}</pre>
			<p>(Using an arrow<a id="_idIndexMarker609"/> function would make for even shorter code.) You can understand this code by realizing that it uses the associative property we mentioned previously and pipes the first function to the second; then, it pipes this result to the third function, and so on.</p>
			<p>Which version is better? I would say that the version that refers to the <code>pipeTwo()</code> function is clearer: if you know how <code>reduce()</code> works, you can readily understand that our pipeline goes through the functions two at a time, starting from the first—and that matches what you know about how pipes work. The other versions we wrote are more or less declarative, but not as simple to understand.</p>
			<p>We didn’t look at typing for all our pipelining functions, so let’s do that now.</p>
			<h3>Typing</h3>
			<p>When we pipeline several<a id="_idIndexMarker610"/> functions, a function’s output type should be the same as the following function’s parameter type. Let’s have an auxiliary <code>FnsMatchPipe&lt;&gt;</code> type to check whether two types satisfy this condition:</p>
			<pre class="source-code">
// continued…
type FN = (...args: any[]) =&gt; any;
type FnsMatchPipe&lt;FNS extends FN[]&gt; =
  1 extends FNS["length"]
    ? boolean
    : FNS extends [
        infer FN1st extends FN,
        infer FN2nd extends FN,
        ...infer FNRest extends FN[]
      ]
    ? Parameters&lt;FN2nd&gt; extends [ReturnType&lt;FN1st&gt;]
      ? FnsMatchPipe&lt;[FN2nd, ...FNRest]&gt;
      : never
    : never;</pre>
			<p>This works recursively. If we have a single function in the pipeline (the length of <code>FNS</code> is <code>1</code>), then we return <code>boolean</code> to signify success. If we have more than one function, we take the first and second functions, check that the parameter of the latter is the same type as the return type<a id="_idIndexMarker611"/> of the former, and apply recursion to check types from the second function onward. If there’s no match in types, we return <code>never</code> to mark a failure.</p>
			<p>Now, what’s the type of the pipeline? The type of its arguments will match the first function’s argument type, and the type of the result will match the last function’s result type:</p>
			<pre class="source-code">
// continued...
type Pipeline&lt;FNS extends FN[]&gt; =
  boolean extends FnsMatchPipe&lt;FNS&gt;
    ? 1 extends FNS["length"]
      ? FNS[0]
      : FNS extends [
          infer FNFIRST extends FN,
          ...FN[],
          infer FNLAST extends FN
        ]
      ? (...args: Parameters&lt;FNFIRST&gt;) =&gt; ReturnType&lt;FNLAST&gt;
      : never
    : never;</pre>
			<p>We first verify that the function’s types are correct, using <code>FnsMatchPipe&lt;&gt;</code>. If the types match, the type of the whole pipeline is that of a function that gets arguments of the same type as the first function in the pipeline and returns a value of the same type as the last pipelined function.</p>
			<p>Now, our pipelines can be properly written – and we’ll have to use the same “overloading” as in the previous chapter to help TypeScript work out types:</p>
			<pre class="source-code">
// continued...
function pipeline<strong class="bold">&lt;FNS extends FN[]&gt;(</strong>
<strong class="bold">  ...fns: FNS</strong>
<strong class="bold">): Pipeline&lt;FNS&gt;</strong>;
function pipeline&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return (...args: Parameters&lt;FNS[0]&gt;) =&gt; {
    let result = fns[0](...args);
    for (let i = 1; i &lt; fns.length; i++) {
      result = fns[i](result);
    }
    return result;
  };
}
function pipeline2<strong class="bold">&lt;FNS extends FN[]&gt;(</strong>
<strong class="bold">  ...fns: FNS</strong>
<strong class="bold">): Pipeline&lt;FNS&gt;</strong>;
function pipeline2&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return fns.reduce(
    (result, f) =&gt;
      (...args) =&gt;
        f(result(...args))
  );
}
function pipeline3<strong class="bold">&lt;FNS extends FN[]&gt;(</strong>
<strong class="bold">  ...fns: FNS</strong>
<strong class="bold">): Pipeline&lt;FNS&gt;</strong>;
function pipeline3&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): (...fns: FNS) =&gt; FN {
  return fns.reduce(pipeTwo);
}</pre>
			<p>Before we look at <a id="_idIndexMarker612"/>other ways to connect functions, let’s consider how we would debug our pipelines.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor154"/>Debugging pipelines</h2>
			<p>Now, let’s turn to a practical question: how do you debug your code? With pipelining, you can’t see what’s<a id="_idIndexMarker613"/> passed on from function to function, so how do you do it? We have two answers for that: one (also) comes from the Unix/Linux world, and the other (the most <a id="_idIndexMarker614"/>appropriate for this book) uses wrappers to provide some logs.</p>
			<h3>Using tee</h3>
			<p>The first solution we’ll use implies adding a function<a id="_idIndexMarker615"/> to the pipeline, which will just log its input. We want to implement something similar to the <code>tee</code> Linux command, which can intercept the standard data flow in a pipeline and send a copy to an alternate file or device. Remembering that <code>/dev/tty</code> is the usual console, we could<a id="_idIndexMarker616"/> execute something similar to the following and get an onscreen copy of everything that passes using the <code>tee</code> command:</p>
			<pre class="console">
$ ls -1 | grep "odt$" | tee /dev/tty | wc -l
...the list of files with names ending in odt...
4</pre>
			<p>We could write a similar function with ease:</p>
			<pre class="source-code">
// pipeline_debug.ts
const tee = &lt;A&gt;(arg: A) =&gt; {
  console.log(arg);
  return arg;
};</pre>
			<p class="callout-heading">Comma power!</p>
			<p class="callout">If you are aware of the uses of the comma operator, you can be more concise and write <code>const tee2 = &lt;A&gt;(arg: A) =&gt; (console.log(arg), arg)</code>—do you see why? Check out <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator</a> for the answer!</p>
			<p>Our logging function is <a id="_idIndexMarker617"/>short and to the point: it will receive a single argument, list it, and pass it on to the<a id="_idIndexMarker618"/> following function in the pipe. We can see it working in the following code:</p>
			<pre class="source-code">
// continued...
console.log(
  pipeline3(
    getDir,
<strong class="bold">    tee,</strong>
    filterOdt,
<strong class="bold">    tee,</strong>
    count
  )("/home/fkereki/Documents")
);
<strong class="bold">...the list of all the files in the directory...</strong>
<strong class="bold">...the list of files with names ending in odt...</strong>
<strong class="bold">4</strong></pre>
			<p>It would be even better if our <code>tee()</code> function could receive a logger function as a parameter, as in the <em class="italic">Logging in a functional way</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, Producing Functions</em>; it’s just a matter of making the same kind of change we managed there. The same good design concepts are applied again!</p>
			<pre class="source-code">
// continued...
const tee2 = &lt;A&gt;(arg: A, <strong class="bold">logger = console.log</strong>) =&gt; {
  logger(arg);
  return arg;
};</pre>
			<p>This function works exactly in the same way as the previous <code>tee()</code>, although it will allow us to be more flexible when it comes to applying and testing. However, in our case, this would just be an extra enhancement to an already easily-testable function.</p>
			<p>Let’s consider an even more generic tapping function, with more possibilities than just doing a bit of logging.</p>
			<h3>Tapping into a flow</h3>
			<p>If you wish, you could write an enhanced <code>tee()</code> function to produce more debugging information, send the reported data to a file or remote service, and so on—there are many possibilities you can <a id="_idIndexMarker619"/>explore. You could also explore a more general solution, of which <code>tee()</code> would be a particular case and allow us to create personalized tapping functions. This can be seen in the following diagram:</p>
			<div><div><img src="img/Figure_8.2_B19301.jpg" alt="Figure 8.2 – Tapping allows you to apply a function so that you can inspect data as it ﬂows through the pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Tapping allows you to apply a function so that you can inspect data as it ﬂows through the pipeline</p>
			<p>When working with pipelines, you may want to put a logging function in the middle of them, or you might want some other kind of <em class="italic">snooping</em> function—possibly for storing data somewhere, calling a service, or some other kind of side effect. We could have a generic <code>tap()</code> function to allow us to inspect data as it moves along our pipeline, which would behave in the following way:</p>
			<pre class="source-code">
// continued...
const tap = curry(&lt;A&gt;(fn: FN, x: A) =&gt; (fn(x), x));</pre>
			<p>This is a candidate for the <em class="italic">trickiest-looking code-in-the-book</em> award, so let’s explain it. We want to produce a function that, given a function, <code>fn()</code>, and an argument, <code>x</code>, will evaluate <code>fn(x)</code> (to produce whatever sort of side effect we may be interested in) but return <code>x</code> (so the pipeline<a id="_idIndexMarker620"/> goes on without interference). The comma operator has exactly that behavior: if you write something similar to <code>(a, b, c)</code>, JavaScript will evaluate the three expressions in order and use the last value as the expression’s value.</p>
			<p>Here, we can use currying to produce several different tapping functions. The one we wrote in the previous section, <code>tee()</code>, could also be written in the following fashion:</p>
			<pre class="source-code">
// continued...
const tee3 = tap(console.log);</pre>
			<p>By the way, you could have also written <code>tap()</code> without currying, but you’ll have to admit it loses some of its mystery! This is demonstrated here:</p>
			<pre class="source-code">
// continued...
const tap2 = (fn: FN) =&gt; &lt;A&gt;(x: A) =&gt; (fn(x), x);</pre>
			<p>This does exactly the<a id="_idIndexMarker621"/> same job, and you’ll recognize this way of currying from the <em class="italic">Currying by hand</em> section of <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a><em class="italic">, Transforming Functions</em>. Now that we have learned how to tap into a pipeline, let’s move on to a different way of logging by revisiting some concepts we looked at in previous chapters.</p>
			<h3>Using a logging wrapper</h3>
			<p>The second idea we <a id="_idIndexMarker622"/>mentioned is based on the <code>addLogging()</code> function we wrote in the <em class="italic">Logging</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, Producing Functions</em>. The idea was to wrap a function with some logging functionality so that, on <a id="_idIndexMarker623"/>entry, the arguments would be printed and, on exit, the result of the function would be shown:</p>
			<pre class="source-code">
pipeline2(
  addLogging(getDir),
  addLogging(filterOdt),
  addLogging(count)
)("/home/fkereki/Documents");
entering getDir(/home/fkereki/Documents)
exiting  getDir=&gt; ...list of files...
entering filterOdt(...list of files, again...)
exiting  =&gt; ...list of .odt files...
entering count(...list of .odt files ...)
exiting  count=&gt;4</pre>
			<p>We can trivially verify that the <code>pipeline()</code> function is doing its thing correctly—whatever a function produces as a result is given as input to the next function in the line, and we can also understand what’s happening with each call. Of course, you don’t need to add logging to every function in the pipeline: you would probably do so in places where you suspected an error was occurring.</p>
			<p>Now that we’ve looked at how to join functions, let’s look at a common way of defining functions in FP, <em class="italic">pointfree style</em>, which you may encounter.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor155"/>Pointfree style</h2>
			<p>When you join functions together, either in a pipeline or with composition, as we’ll see later in this chapter, you don’t need any intermediate variables to hold the results that will become arguments to the following function in line: they are implicit. Similarly, you can write functions without <a id="_idIndexMarker624"/>mentioning their parameters; this is called the <em class="italic">pointfree style</em>.</p>
			<p>(By the way, pointfree style is also called <em class="italic">tacit</em> programming and <em class="italic">pointless</em> programming by detractors! The term point itself means a function parameter, while pointfree refers to not naming those parameters.)</p>
			<h3>Defining pointfree functions</h3>
			<p>You can easily recognize a pointfree function <a id="_idIndexMarker625"/>definition because it doesn’t need the <code>function</code> keyword or the <code>=&gt;</code> arrow. Let’s revisit some of the previous functions we wrote in this chapter and check them out. For example, the definition of our original file-counting functions is as follows:</p>
			<pre class="source-code">
const countOdtFiles3 = (path: string): number =&gt;
  pipeTwo(pipeTwo(getDir, filterOdt), count)(path);
const countOdtFiles4 = (path: string): number =&gt;
  pipeTwo(getDir, pipeTwo(filterOdt, count))(path);</pre>
			<p>The preceding code could be rewritten as follows:</p>
			<pre class="source-code">
// pointfree.ts
const countOdtFiles3b = pipeTwo(
  pipeTwo(getDir, filterOdt),
  count
);
const countOdtFiles4b = pipeTwo(
  getDir,
  pipeTwo(filterOdt, count)
);</pre>
			<p>The new definitions don’t reference the parameter for the newly defined functions.</p>
			<p>You can deduce this by examining the first function in the pipeline (<code>getDir()</code>, in this case) and seeing what it receives as arguments. (Using type signatures, as we’ll see in <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>, is of great help in terms of documentation, and complements TypeScript types.) In our <em class="italic">Revisiting an example</em> section, we could have written a <code>getLat()</code> function to get the <code>lat</code> field out of an object in a pointfree fashion:</p>
			<pre class="source-code">
const getLat = curry(getField)("lat");</pre>
			<p>What should the equivalent full-style definition be? You’d have to examine the <code>getField()</code> function (we looked at this in the <em class="italic">Revisiting an example</em> section) to decide that it expects <a id="_idIndexMarker626"/>an object as an argument. However, making that need explicit by writing the following wouldn’t make much sense:</p>
			<pre class="source-code">
const getLat = (obj) =&gt; curry(getField)("lat")(obj);</pre>
			<p>If you were willing to write all this, you might wish to stick with the following:</p>
			<pre class="source-code">
const getLat = (obj) =&gt; obj.lat;</pre>
			<p>Then, you simply wouldn’t need to worry about currying!</p>
			<h3>Converting to pointfree style</h3>
			<p>On the other hand, you had <a id="_idIndexMarker627"/>better pause for a minute and try not to write everything in pointfree code, at any cost. For example, consider the <code>isNegativeBalance()</code> function we wrote back in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>:</p>
			<pre class="source-code">
const isNegativeBalance = v =&gt; v.balance &lt; 0;</pre>
			<p>Can we write this in a pointfree style? Yes, we can, and we’ll see how—but I’m not sure we’d want to code this way! We can consider building a pipeline of two functions: one will extract the balance from the given object, while the other will check whether it’s negative. Due to this, we will write our alternative version of the balance-checking function like so:</p>
			<pre class="source-code">
const isNegativeBalance2 = pipeline(getBalance,
  isNegative);</pre>
			<p>To extract the <code>balance</code> attribute from a given object, we can use <code>getField()</code> and a bit of currying, and write the following:</p>
			<pre class="source-code">
const getBalance = curry(getField)("balance");</pre>
			<p>For the second function, we could write the following code:</p>
			<pre class="source-code">
const isNegative = (x: number): boolean =&gt; x &lt; 0;</pre>
			<p>There goes our pointfree goal! Instead, we can use the <code>binaryOp()</code> function, also from the same chapter we mentioned earlier, plus some more currying, to write the following:</p>
			<pre class="source-code">
const isNegative = curry(binaryOp("&gt;"))(0);</pre>
			<p>I wrote the test the other way around (<code>0&gt;x</code> instead of <code>x&lt;0</code>) just for ease. An alternative would have been to use<a id="_idIndexMarker628"/> the enhanced functions I mentioned in the <em class="italic">A handier implementation</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, which is a bit less complex, as follows:</p>
			<pre class="source-code">
const isNegative = binaryOpRight("&lt;", 0);</pre>
			<p>So, finally, we could write the following:</p>
			<pre class="source-code">
const isNegativeBalance2 = <strong class="bold">pipeline</strong>(
  curry(getField)("balance"),
  curry(binaryOp("&gt;"))(0)
);</pre>
			<p>Alternatively, we could write the following:</p>
			<pre class="source-code">
const isNegativeBalance3 = <strong class="bold">pipeline</strong>(
  curry(getField)("balance"),
  binaryOpRight("&lt;", 0)
);</pre>
			<p>Is that an improvement? Our new versions of <code>isNegativeBalance()</code> don’t make a reference to their argument and are fully pointfree, but the idea of using pointfree style should be to help improve the clarity and readability of your code and not to produce obfuscation and opaqueness! I doubt anybody would look at our new versions of the function and consider them to be an advantage over the original.</p>
			<p>If you find that your code is becoming harder to understand due to using pointfree programming, stop and roll back your changes. Remember our doctrine for this book: we want to do FP, but we don’t want to go overboard with it—and using the pointfree style is not a requirement!</p>
			<p>In this section, we’ve learned<a id="_idIndexMarker629"/> how to build pipelines of functions—this is a powerful technique. For objects and arrays, however, we have another special technique that you may have used already: <em class="italic">chaining</em>. Let’s take a look at this now.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor156"/>Chaining and fluent interfaces</h1>
			<p>When you work with objects or arrays, there is another way of linking the execution of several calls together: by applying <em class="italic">chaining</em>. For example, when you work with arrays, if you apply a <code>map()</code> or <code>filter()</code> method, the<a id="_idIndexMarker630"/> result is a new array, to which you can then apply another <code>map()</code> or <code>filter()</code> function, and so forth. We used these methods when we defined the <code>range()</code> function back in the <em class="italic">Working with ranges</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a><em class="italic">, </em><em class="italic">Programming Declaratively</em>:</p>
			<pre class="source-code">
const range = (start: number, stop: number): number[] =&gt;
  new Array(stop - start).fill(0).map((v, i) =&gt; start + i);</pre>
			<p>First, we created a new array; then, we applied the <code>fill()</code> method to it, which updated the array in place (side effect) and returned the updated array, to which we finally applied a <code>map()</code> method. The latter method generated a new array, to which we could have applied further mapping, filtering, or any other available method.</p>
			<p>Let’s take a look at a common example of fluent APIs, which work by chaining, and then consider how we can do this on our own.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor157"/>An example of fluent APIs</h2>
			<p>This style of<a id="_idIndexMarker631"/> continuous chained operations is also used in fluent APIs or interfaces. To give just one example, the graphic <code>D3.js</code> library (see <a href="http://d3js.org">d3js.org</a> for more on it) frequently uses this style. The following example, taken from <a href="http://bl.ocks.org/mbostock/4063269">bl.ocks.org/mbostock/4063269</a>, shows it in action:</p>
			<pre class="source-code">
var node = svg
  .selectAll(".node")
  .data(pack(root).leaves())
  .enter()
  .append("g")
  .attr("class", "node")
  .attr("transform", function (d) {
    return "translate(" + d.x + "," + d.y + ")";
  });
node
  .append("circle")
  .attr("id", function (d) {
    return d.id;
  })
  .attr("r", function (d) {
    return d.r;
  })
  .style("fill", function (d) {
    return color(d.package);
  });</pre>
			<p>Each method works on the previous object and provides access to a new object to which future method calls will be applied (such as the <code>selectAll()</code> or <code>append()</code> methods) or updates <a id="_idIndexMarker632"/>the current one (as the <code>attr()</code> attribute setting calls do). This style is not unique, and several other well-known libraries (jQuery comes to mind) also apply it.</p>
			<p>Can we automate this? In this case, the answer is “possibly, but I’d rather not.” I think using <code>pipeline()</code> or <code>compose()</code> works just as well and achieves the same thing. With object chaining, you are limited to returning new objects or arrays or something that methods can be applied to. (Remember, if you are working with standard types, such as strings or numbers, you can’t add methods to them unless you mess with their prototype, which isn’t recommended!). With composition, however, you can return any value; the only restriction is that the next function in line must expect the data type you provide.</p>
			<p>On the other hand, if you are writing your own API, you can provide a fluent interface by just having each method return <code>this</code>—unless it needs to return something else! If you were working with someone else’s API, you could also do some trickery by using a proxy. However, be aware that there may be cases in which your proxied code might fail: maybe another proxy is being used, or there are some getters or setters that somehow cause problems, and so on.</p>
			<p class="callout-heading">On proxies</p>
			<p class="callout">You may want to read up on proxy objects at <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a> – they are very powerful and <a id="_idIndexMarker633"/>allow for interesting metaprogramming functionalities. Still, they can trap you with technicalities and will cause an (albeit slight) slowdown in your proxied code.</p>
			<p>Let’s now look at how to chain calls so we can do this with any class.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor158"/>Chaining method calls</h2>
			<p>Let’s go for a basic<a id="_idIndexMarker634"/> example. We have a <code>City</code> class with <code>name</code>, latitude (<code>lat</code>), and longitude (<code>long</code>) attributes:</p>
			<pre class="source-code">
// chaining.ts
class City {
  name: string;
  lat: number;
  long: number;
  constructor(name: string, lat: number, long: number) {
    this.name = name;
    this.lat = lat;
    this.long = long;
  }
  getName() {
    return this.name;
  }
  setName(newName: string) {
    this.name = newName;
  }
  setLat(newLat: number) {
    this.lat = newLat;
  }
  setLong(newLong: number) {
    this.long = newLong;
  }
  getCoords() {
    return [this.lat, this.long];
  }
}</pre>
			<p>This is a common class with a few methods; everything’s quite normal. We could use this class as follows and provide details about my native city, Montevideo, Uruguay:</p>
			<pre class="source-code">
const myCity = new City(
  "Montevideo, Uruguay",
  -34.9011,
  -56.1645
);
console.log(myCity.getCoords(), myCity.getName());
<strong class="bold">// [ -34.9011, -56.1645 ] 'Montevideo, Uruguay'</strong></pre>
			<p>If we wanted the setters to be handled in a fluent manner, we could set up a proxy to detect these calls and provide the missing <code>return this</code>. How can we do that? If the original method doesn’t return anything, JavaScript will include a <code>return undefined</code> statement by default so that we can detect whether that’s what the method returns and substitute <code>return this</code> instead. Of course, this is a problem: what would we do if we had a method that could legally return <code>undefined</code> because of its semantics? We could<a id="_idIndexMarker635"/> have some kind of exceptions list to tell our proxy not to add anything in those cases, but let’s not get into that.</p>
			<p>The code for our handler is as follows. Whenever the method of an object is invoked, a <code>get()</code> is implicitly called, and we catch it. If we get a function, we wrap it with some code of our own that will call the original method and then decide whether to return its value or a reference to the proxied object instead. If we didn’t get a function, we would return the requested property’s value. Our <code>chainify()</code> function will take care of assigning the handler to an object and creating the needed proxy:</p>
			<pre class="source-code">
// chainify.ts
const chainify = &lt;OBJ extends { [key: string]: any }&gt;(
  obj: OBJ
): Chainify&lt;OBJ&gt; =&gt;
  new Proxy(obj, {
    get(target, property, receiver) {
      if (typeof property === "string") {
        if (typeof target[property] === "function") {
          // requesting a method? return a wrapped version
          return (...args: any[]) =&gt; {
            const result = target[property](...args);
            return result === undefined ? receiver :
              result;
          };
        } else {
          // an attribute was requested - just return it
          return target[property];
        }
      } else {
        return Reflect.get(target, property, receiver);
      }
    },
  });</pre>
			<p>We must check whether the invoked <code>get()</code> was for a function or an attribute. In the first case, we wrap the <a id="_idIndexMarker636"/>method with extra code so that it will execute it and then return its results (if any) or a reference to the object itself. In the second case, we return the attribute, which is the expected behavior. (For the use of <code>Reflect.get()</code>, check out <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get</a>.)</p>
			<p>What’s the type of a “chainified” object? Any property that isn’t a function is the same. A property that is a function that returns some non-<code>void</code> value is also still the same. However, if a function returns <code>void</code>, we wrap it, so it returns the object itself. The <code>Chainify&lt;&gt;</code> type definition does that:</p>
			<pre class="source-code">
// continued...
type Chainify&lt;A extends { [key: string]: any }&gt; = {
  [key in keyof A]: A[key] extends (...args: any[]) =&gt; any
    ? void extends ReturnType&lt;A[key]&gt;
      ? (...args: Parameters&lt;A[key]&gt;) =&gt; Chainify&lt;A&gt;
      : (...args: Parameters&lt;A[key]&gt;) =&gt; ReturnType&lt;A[key]&gt;
    : A[key];
};</pre>
			<p>With this, we can chainify any object so that we can inspect any called method. As I’m writing this, I’m currently living in Pune, India, so let’s reflect that change:</p>
			<pre class="source-code">
const myCity2 = chainify(myCity);
console.log(
  myCity2
    .setName("Pune, India")
    .setLat(18.5626)
    .setLong(73.8087)
    .getCoords(),
  myCity.getName()
);
// [ 18.5626, 73.8087 ] 'Pune, India'</pre>
			<p>Notice the following:</p>
			<ul>
				<li>The type of <code>myCity2</code> (which is chainified) is different from the type of <code>myCity</code>. For instance, <code>myCity2.setLong()</code> is now of the <code>setLong(newLong: number): Chainify&lt;City&gt;</code> type instead of <code>setLong(newLong: number): void</code> as before. (See <em class="italic">Question 8.8</em>.)</li>
				<li>We call several setters in a fluent manner, and they are working fine since our proxy is taking care of providing the value for the following call.</li>
				<li>The calls to <code>getCoords()</code> and <code>getName()</code> are intercepted, but nothing special is done because they already return a value.</li>
			</ul>
			<p>Is working in a<a id="_idIndexMarker637"/> chained way worth it? That’s up to you—but remember that there may be cases in which this approach fails, so be wary! Now, let’s move on to composing, the other most common way of joining functions.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor159"/>Composing</h1>
			<p><em class="italic">Composing</em> is quite similar to<a id="_idIndexMarker638"/> pipelining, but has its roots in mathematical theory. The concept of composition is a sequence of function calls in which the output of one function is the input for the next one—but in the opposite order to when pipelining. So, if you have a series of functions, from left to right, when pipelining, the first function of the series to be applied is the leftmost one, but when you use composition, you start with the rightmost one.</p>
			<p>Let’s investigate this a bit more. When you define the composition of, say, three functions as (<code>f</code>∘<code>g</code>∘<code>h</code>) and apply this composition to <code>x</code>, this is equivalent to writing <code>f(g(h(x)))</code>.</p>
			<p>It’s important to note that, as with pipelining, the arity of the first function to be applied (actually the last one in the list) can be anything, but all the other functions must be unary. Also, besides the difference in the sequence of function evaluation, composing is an important tool in FP: it abstracts the implementation details (putting your focus on what you need to accomplish rather than on the specific details for achieving that), thereby letting you<a id="_idIndexMarker639"/> work in a more declarative fashion.</p>
			<p class="callout-heading">Tip for reading</p>
			<p class="callout">If it helps, you can read (<em class="italic">f</em>∘<em class="italic">g</em>∘<em class="italic">h</em>) as “<em class="italic">f</em> after <em class="italic">g</em> after <em class="italic">h</em>” so that it becomes clear that <em class="italic">h</em> is the first function to be applied, while <em class="italic">f</em> is the last.</p>
			<p>Given its similarity to pipelining, it will be no surprise that implementing composition isn’t very hard. However, there are still some important and interesting details. Let’s see some examples of composition before moving on to using higher-order functions and finishing with some considerations about testing composed functions.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor160"/>Some examples of composition</h2>
			<p>It may not be a surprise to<a id="_idIndexMarker640"/> you, but we have already seen several examples of composition—or, at the very least, cases in which the solutions we achieved were functionally equivalent to using composition. Let’s review some of these and work with some new examples too.</p>
			<h3>Unary operators</h3>
			<p>In the <em class="italic">Logically negating a function</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, we wrote a <code>not()</code> function that, given another function, would logically invert its result. We used that function to negate a check <a id="_idIndexMarker641"/>for negative balances; the sample code for this (and I’m going with plain JavaScript here, for clarity) could be as follows:</p>
			<pre class="source-code">
const not = (fn) =&gt; (...args) =&gt; !fn(...args);
const positiveBalance = not(isNegativeBalance);</pre>
			<p>In another section (<em class="italic">Turning operations into functions</em>) of that chapter, I left you with the challenge of writing a <code>unaryOp()</code> function that would provide unary functions equivalent to common JavaScript operators. If you met that challenge, you should be able to write <a id="_idIndexMarker642"/>something such as the following:</p>
			<pre class="source-code">
const logicalNot = unaryOp("!");</pre>
			<p>Assuming the existence of a <code>compose()</code> function, you could have also written the following:</p>
			<pre class="source-code">
const positiveBalance = <strong class="bold">compose(</strong>
<strong class="bold">  logicalNot,</strong>
<strong class="bold">  isNegativeBalance</strong>
<strong class="bold">)</strong>;</pre>
			<p>Which one do you prefer? It’s a matter of taste—but I think the second version clarifies what we are trying to do better. With the <code>not()</code> function, you must check what it does to understand the general code. With composition, you still need to know what <code>logicalNot()</code> is, but the global construct is open to see.</p>
			<p>To look at just one more example in the same vein, you could have achieved the same results that we got in the <em class="italic">Inverting the results</em> section in the same chapter. Recall that we had a function that could compare strings according to the rules of Spanish, but we wanted to invert the result of the comparison so that it was sorted in descending order:</p>
			<pre class="source-code">
const changeSign = unaryOp("-");
palabras.sort(<strong class="bold">compose(changeSign, spanishComparison)</strong>);</pre>
			<p>This code produces the same result that our previous sorting problem did, but the logic is expressed more clearly and with less code: a typical FP result! Let’s look at some more examples of composing functions by reviewing another task we discussed earlier.</p>
			<h3>Counting files</h3>
			<p>We can also go back to our <a id="_idIndexMarker643"/>pipeline. We wrote a single-line function to count the <code>odt</code> files in a given path:</p>
			<pre class="source-code">
const countOdtFiles2 = (path: string): number =&gt;
  <strong class="bold">count(filterOdt(getDir(path)))</strong>;</pre>
			<p>Disregarding (at least for the moment) the observation that this code is not as clear as the pipeline version that we developed later, we could have also written this function with composition:</p>
			<pre class="source-code">
const countOdtFiles2b = (path: string): number =&gt;
  <strong class="bold">compose(count, filterOdt, getDir)(path)</strong>;
countOdtFiles2b("/home/fkereki/Documents");
// 4, no change here</pre>
			<p>We may also see this written in a one-liner fashion:</p>
			<pre class="source-code">
compose(count, filterOdt, getDir)("/home/fkereki/Documents");</pre>
			<p>Even if it’s not as clear as the pipeline version (and that’s just my opinion, which may be biased due to my liking of Linux!), this declarative implementation makes it clear that we depend on combining three distinct functions to get our result—this is easy to see and applies the idea <a id="_idIndexMarker644"/>of building large solutions out of simpler pieces of code.</p>
			<p>Let’s take a look at another example that’s designed to compose as many functions as possible.</p>
			<h3>Finding unique words</h3>
			<p>Finally, let’s go for another<a id="_idIndexMarker645"/> example, which, I agree, could have also been used for pipelining. Suppose you have some text and want to extract all the unique words from it: how would you go about doing so? If you think about it in steps (instead of trying to create a full solution in one go), you would probably come up with a solution similar to this:</p>
			<ol>
				<li>Ignore all non-alphabetic characters.</li>
				<li>Put everything in uppercase.</li>
				<li>Split the text into words.</li>
				<li>Create a set of words.</li>
			</ol>
			<p>(Why a set? Because it <a id="_idIndexMarker646"/>automatically discards repeated values; check out <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set</a> for more on this. By the way, we will use the <code>Array.from()</code> method to produce an array out of our set; see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from</a> for more on this.)</p>
			<p>Now, using FP, let’s solve each problem:</p>
			<pre class="source-code">
const removeNonAlpha = (str: string): string =&gt;
  str.replace(/[^a-z]/gi, " ");
const toUpperCase = demethodize(
  String.prototype.toUpperCase
);
const splitInWords = (str: string): string[] =&gt;
  str.trim().split(/\s+/);
const arrayToSet = (arr: string[]): Set&lt;string&gt; =&gt;
  new Set(arr);
const setToList = (set: Set&lt;string&gt;): string[] =&gt;
  Array.from(set).sort();</pre>
			<p>With these functions, the result <a id="_idIndexMarker647"/>can be written as follows:</p>
			<pre class="source-code">
const getUniqueWords = <strong class="bold">compose</strong>(
  setToList,
  arrayToSet,
  splitInWords,
  toUpperCase,
  removeNonAlpha
);</pre>
			<p>Since you don’t get to see the arguments of any of the composed functions, you don’t need to show the parameter for <code>getUniqueWords()</code> either, so the pointfree style is natural in this case.</p>
			<p>Now, let’s test our function. To do this, let’s apply this function to the first two sentences of <a id="_idIndexMarker648"/>Abraham Lincoln’s address at Gettysburg (which we already used in an example back in the <em class="italic">Mapping and flattening – flatMap</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a><em class="italic">, Programming Declaratively</em>) and print out the 43 different words (trust me, I counted them!) in it:</p>
			<pre class="source-code">
const GETTYSBURG_1_2 = `Four score and seven years ago
our fathers brought forth on this continent, a new nation, conceived in liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long
endure.`;
console.log(getUniqueWords(GETTYSBURG_1_2));
// Output: 43 words, namely
  'A',           'AGO',       'ALL',
  'AND',         'ANY',       'ARE',
  'BROUGHT',     'CAN',       'CIVIL',
  'CONCEIVED',   'CONTINENT', 'CREATED',
  'DEDICATED',   'ENDURE',    'ENGAGED',
  'EQUAL',       'FATHERS',   'FORTH',
  'FOUR',        'GREAT',     'IN',
  'LIBERTY',     'LONG',      'MEN',
  'NATION',      'NEW',       'NOW',
  'ON',          'OR',        'OUR',
  'PROPOSITION', 'SCORE',     'SEVEN',
  'SO',          'TESTING',   'THAT',
  'THE',         'THIS',      'TO',
  'WAR',         'WE',        'WHETHER',
  'YEARS'</pre>
			<p>Of course, you could have written <code>getUniqueWords()</code> more succinctly, but the point I’m making is that by composing your solution out of several shorter steps, your code is clearer and easier to grasp. However, if you wish to say that a pipelined solution seems better, it’s just a matter of opinion!</p>
			<p>We have looked at<a id="_idIndexMarker649"/> many examples of function composition at this point, but there’s another way to manage this—by using higher-order functions.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor161"/>Composing with higher-order functions</h2>
			<p>Evidently, composing by<a id="_idIndexMarker650"/> hand can be done similarly to pipelining. For example, the unique word-counting function that we wrote previously could be written in simple JavaScript style:</p>
			<pre class="source-code">
const getUniqueWords1 = (str: string): string[] =&gt; {
  const str1 = removeNonAlpha(str);
  const str2 = toUpperCase(str1);
  const arr1 = splitInWords(str2);
  const set1 = arrayToSet(arr1);
  const arr2 = setToList(set1);
  return arr2;
};
console.log(getUniqueWords1(GETTYSBURG_1_2));
// Output: the same 43 words</pre>
			<p>Alternatively, it could be<a id="_idIndexMarker651"/> written more concisely (but more obscurely!) in a one-liner style:</p>
			<pre class="source-code">
const getUniqueWords2 = (str: string): string[] =&gt;
  setToList(
    arrayToSet(
      splitInWords(toUpperCase(removeNonAlpha(str)))
    )
  );
console.log(getUniqueWords2(GETTYSBURG_1_2));
// Output: the same 43 words</pre>
			<p>This works fine, but as when we studied pipelining, let’s look for a more general solution that won’t require writing a new particular function every time we want to compose some other functions.</p>
			<p>Composing two functions is relatively easy and requires making a small change to our <code>pipeTwo()</code> function, which we looked at earlier in this chapter. We just have to exchange <code>f</code> and <code>g</code> to get the new definition!</p>
			<pre class="source-code">
// compose.ts
const pipeTwo =
  &lt;F extends FN, G extends FN&gt;(f: F, g: G) =&gt;
  <strong class="bold">(...args: Parameters&lt;F&gt;): ReturnType&lt;G&gt; =&gt;</strong>
    <strong class="bold">g(f(...args))</strong>;
const composeTwo =
  &lt;F extends FN, G extends FN&gt;(f: F, g: G) =&gt;
  <strong class="bold">(...args: Parameters&lt;G&gt;): ReturnType&lt;F&gt; =&gt;</strong>
    <strong class="bold">f(g(...args))</strong>;</pre>
			<p>The only difference is that, with piping, you apply the leftmost function first, while with composing, you start with the rightmost function first. This variation suggests that we could have used the <code>flipTwo()</code> higher-order function from the <em class="italic">Parameter order</em> section of <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a><em class="italic">, Transforming Functions</em>. Is it clearer? Here is the code:</p>
			<pre class="source-code">
// continued...
const composeTwoByFlipping = flipTwo(pipeTwo);</pre>
			<p>In any case, if we <a id="_idIndexMarker652"/>want to compose more than two functions, we can take advantage of the associative property and write something like the following:</p>
			<pre class="source-code">
const getUniqueWords3 = composeTwo(
  setToList,
  <strong class="bold">composeTwo</strong>(
    arrayToSet,
    <strong class="bold">composeTwo</strong>(
      splitInWords,
      <strong class="bold">composeTwo</strong>(toUpperCase, removeNonAlpha)
    )
  )
);</pre>
			<p>Even though this works, let’s go for a better solution—we can provide several. We could use a loop like when we wrote our first pipelining function:</p>
			<pre class="source-code">
// continued...
function compose(...fns) {
  return (...args) =&gt; {
    let result = fns[fns.length - 1](...args);
    for (let i = fns.length - 2; i &gt;= 0; i--) {
      result = fns[i](result);
    }
    return result;
  };
}
console.log(
  <strong class="bold">compose(</strong>
    setToList,
    arrayToSet,
    splitInWords,
    toUpperCase,
    removeNonAlpha
  <strong class="bold">)(GETTYSBURG_1_2)</strong>
);
// same output as earlier</pre>
			<p>We could also note that pipelining and composing work in opposite directions. We apply functions from left to right when pipelining, and from right to left when composing. Thus, we can achieve the same result we achieved with composition by reversing the order of the functions and doing pipelining instead; a very functional solution, which I really like! This is as follows:</p>
			<pre class="source-code">
// continued...
function compose1(...fns) {
  return pipeline(...fns.reverse());
}</pre>
			<p>The only tricky part is<a id="_idIndexMarker653"/> the usage of the spread operator before calling <code>pipeline()</code>. After reversing the <code>fns</code> array, we must spread its elements to call <code>pipeline()</code> correctly.</p>
			<p>Yet another solution, less declarative, is to use <code>reduceRight()</code> so that instead of reversing the list of functions, we reverse the order of processing them:</p>
			<pre class="source-code">
// continued...
function compose2(...fns) {
  return fns.reduceRight(
    <strong class="bold">(f, g) =&gt; (...args) =&gt; g(f(...args))</strong>
  );
}
console.log(
  <strong class="bold">compose2(</strong>
    setToList,
    arrayToSet,
    splitInWords,
    toUpperCase,
    removeNonAlpha
  <strong class="bold">)(GETTYSBURG_1_2)</strong>
);
// still same output</pre>
			<p>Why and how <a id="_idIndexMarker654"/>does this work? Let’s look at the inner workings of this call:</p>
			<ul>
				<li>Since no initial value is provided, <code>f()</code> is <code>removeNonAlpha()</code> and <code>g()</code> is <code>toUpperCase()</code>, so the first intermediate result is a function, <code>(...args) =&gt; toUpperCase(removeNonAlpha(...args))</code>; let’s call it <code>step1()</code>.</li>
				<li>The second time, <code>f()</code> is <code>step1()</code> from the previous step, while <code>g()</code> is <code>splitInWords()</code>, so the new result is a function, <code>(...args) =&gt; splitInWords(step1(...args)))</code>, which we can call <code>step2()</code>.</li>
				<li>The third time around, in the same fashion, we get <code>(...args) =&gt; arrayToSet(step2(...args))))</code>, which we call <code>step3()</code>.</li>
				<li>Finally, the result is <code>(...args) =&gt; setToList(step3(...args))</code>, a function; let’s call it <code>step4()</code>.</li>
			</ul>
			<p>The final result turns out to be a function that receives <code>(...args)</code> and starts by applying <code>removeNonAlpha()</code> to it, then <code>toUpperCase()</code>, and so on, before finishing by applying <code>setToList()</code>.</p>
			<p>It may come as a surprise that we can also make this work with <code>reduce()</code>—can you see why? The reasoning is similar to what we did previously, so we’ll leave this as an exercise for you:</p>
			<pre class="source-code">
// continued...
function compose3(...fns) {
  return <strong class="bold">fns.reduceRight(pipeTwo)</strong>;
}</pre>
			<p class="callout-heading">A symmetric challenge!</p>
			<p class="callout">After working out how <code>compose3()</code> works, you might want to write a version of <code>pipeline()</code> that uses <code>reduceRight()</code>, just for symmetry, to round things out!</p>
			<h3>Data typing for composition</h3>
			<p>Given what we did for pipelining, data<a id="_idIndexMarker655"/> typing for composition is very much the same, and we’ll follow what we did in parallel. First, we’ll have an auxiliary type to check whether our functions’ types can be composed correctly:</p>
			<pre class="source-code">
// compose.ts
type FnsMatchComp&lt;FNS extends FN[]&gt; =
  1 extends FNS["length"]
    ? boolean
    : FNS extends [
        ...infer FNInit extends FN[],
        infer FNPrev extends FN,
        infer FNLast extends FN
      ]
    ? Parameters&lt;FNPrev&gt; extends [ReturnType&lt;FNLast&gt;]
      ? FnsMatchComp&lt;[...FNInit, FNPrev]&gt;
      : never
    : never;</pre>
			<p>This is essentially the same as what we wrote for pipelining, except that we process functions from right to left. With this done, we can now write our <code>Compose&lt;&gt;</code> type:</p>
			<pre class="source-code">
// continued...
type Compose&lt;FNS extends FN[]&gt; =
  boolean extends FnsMatchComp&lt;FNS&gt;
    ? 1 extends FNS["length"]
      ? FNS[0]
      : FNS extends [
          infer FNFIRST extends FN,
          ...FN[],
          infer FNLAST extends FN
        ]
      ? <strong class="bold">(...args: Parameters&lt;FNLAST&gt;) =&gt;</strong>
<strong class="bold">        ReturnType&lt;FNFIRST&gt;</strong>
      : never
    : never;</pre>
			<p>This is also what we had for pipelining, except for the type of the result, which is symmetrical. Finally, we can <a id="_idIndexMarker656"/>apply types to our composing functions; let’s see just one example, because (logically!) typing is the same for all the versions of our code!</p>
			<pre class="source-code">
function compose<strong class="bold">&lt;FNS extends FN[]&gt;</strong>(
  ...fns<strong class="bold">: FNS</strong>
)<strong class="bold">: Compose&lt;FNS&gt;</strong>;
function compose&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return (...args: Parameters&lt;FNS[0]&gt;) =&gt; {
    let result = fns[fns.length - 1](...args);
    for (let i = fns.length - 2; i &gt;= 0; i--) {
      result = fns[i](result);
    }
    return result;
  };
}</pre>
			<p>So far, we have looked at the important methods we can use to connect functions using pipelining, chaining, and composition. All this works very well, but we’ll see that there’s a particular case in which the performance of your code can be affected and that will require a new way to handle composition: <em class="italic">transducing</em>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor162"/>Transducing</h1>
			<p>Let’s consider a performance problem in JavaScript that happens when we’re dealing with large arrays and applying several <code>map()</code>, <code>filter()</code>, or <code>reduce()</code> operations. If you start with an array and <a id="_idIndexMarker657"/>apply these operations (via chaining, as we saw earlier in this chapter), you get the desired result. However, many intermediate arrays are created, processed, and discarded—and that causes delays. If you are dealing with small arrays, the extra time won’t make an impact, but with larger arrays (as in a big data process, maybe in Node.js, where you’re working with the results of a large database query), then you will probably have to need some optimization. We’ll do this by learning about a new tool for composing functions: <em class="italic">transducing</em>.</p>
			<p>First, let’s create some functions and data. We’ll make do with a nonsensical example since we aren’t focusing on the actual operations but on the general process. We’ll start with some filtering<a id="_idIndexMarker658"/> functions and some mapping:</p>
			<pre class="source-code">
// transducing.ts
const testOdd = (x: number): boolean =&gt; x % 2 === 1;
const testUnderFifty = (x: number): boolean =&gt; x &lt; 50;
const duplicate = (x: number): number =&gt; x + x;
const addThree = (x: number): number =&gt; x + 3;</pre>
			<p>Now, let’s apply those maps and filters to an array. First, we drop the even numbers, duplicate the odd numbers, drop results over 50, and end by adding 3 to all the results:</p>
			<pre class="source-code">
// continued...
const myArray = [22, 9, 60, 24, 11, 63];
const a0 = myArray
  .filter(testOdd)
  .map(duplicate)
  .filter(testUnderFifty)
  .map(addThree);
console.log(a0);
<strong class="bold">// Output: [ 21, 25 ]</strong></pre>
			<p>The following diagram shows how this sequence of operations works:</p>
			<div><div><img src="img/Figure_8.3_B19301.jpg" alt="Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays to be created and later discarded"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays to be created and later discarded</p>
			<p>Here, we can see that chaining together several <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> operations causes intermediate arrays (three, in this case) to be created and later discarded—and for large arrays, that can become cumbersome.</p>
			<p>How can we optimize this? The problem here is that processing applies the first transformation to<a id="_idIndexMarker659"/> the input array; then, the second transformation is applied to the resulting array; then the third, and so on. An alternative solution would be to take the first element of the input array and apply all the transformations in sequence to it. Then, you would need to take the second element of the input array and apply all the transformations to it, then take the third, and so on. In pseudocode, the difference is between this:</p>
			<pre class="source-code">
for each transformation to be applied:
    for each element in the input list:
        apply the transformation to the element</pre>
			<p>And then this approach:</p>
			<pre class="source-code">
for each element in the input list:
    for each transformation to be applied:
        apply the transformation to the element</pre>
			<p>With the first logic, we go transformation by transformation, applying it to each list and generating a new one. This requires several intermediate lists to be produced. With the second logic, we go element by element and apply all the transformations to each one in sequence to arrive at the final output list without any intermediate lists being created.</p>
			<p>Now, the problem is being able to transpose the transformations; how can we do this? We saw this key concept in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, and we can define <code>map()</code> and <code>filter()</code> in terms of <code>reduce()</code>. Using those definitions, instead of a sequence of different functions, we will apply the same operation (<code>reduce()</code>) at each<a id="_idIndexMarker660"/> step, and here is the secret! As shown in the following diagram, we change the order of evaluation by composing all the transformations so that they can be applied in a single pass with no intermediate arrays whatsoever:</p>
			<div><div><img src="img/Figure_8.4_B19301.jpg" alt="Figure 8.4 – By applying transducers, we will change the order of evaluation but get the same result"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – By applying transducers, we will change the order of evaluation but get the same result</p>
			<p>Instead of applying a first <code>reduce()</code> operation, passing its result to a second, its result to a third, and so on, we will compose all the reducing functions into a single one! Let’s analyze this.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/>Composing reducers</h2>
			<p>Essentially, what we want is to transform each function (<code>testOdd()</code>, <code>duplicate()</code>, and so on) into a reducing <a id="_idIndexMarker661"/>operation that will call the following reducer. A couple of higher-order functions will help; one for mapping functions and another for filtering ones. With this idea, the result of an operation will be passed to the next one, avoiding intermediate arrays:</p>
			<pre class="source-code">
// continued...
const mapTR =
  &lt;V, W&gt;(fn: (x: V) =&gt; W) =&gt;
  &lt;A&gt;(reducer: (am: A, wm: W) =&gt; A) =&gt;
  (accum: A, value: V): A =&gt;
    reducer(accum, fn(value));
const filterTR =
  &lt;V&gt;(fn: (x: V) =&gt; boolean) =&gt;
  &lt;A&gt;(reducer: (af: A, wf: V) =&gt; A) =&gt;
  (accum: A, value: V): A =&gt;
    fn(value) ? reducer(accum, value) : accum;</pre>
			<p>These two transforming functions are <em class="italic">transducers</em>: functions that accept a reducing function and return a new reducing function. (Some trivia: the word <em class="italic">transduce</em> comes from Latin, meaning transform, transport, convert, change over, and is applied in many different fields, including biology, psychology, machine learning, physics, electronics, and more.)</p>
			<p>Typing is not too hard. For mapping, we assume a mapping function that gets a value of type <code>V</code> and produces a result of type <code>W</code>. The generic reducer takes an accumulator of type <code>A</code> and a value of type <code>W</code> and produces a new accumulator, also of type <code>A</code>. For filtering, the filtering function gets a value of type <code>V</code> and produces a <code>Boolean</code> value, and the reducer gets an accumulator of type <code>A</code> and a value of type <code>V</code>, returning a type <code>A</code> result.</p>
			<p>How do we use these transducers? We can write code such as the following, although we’ll want a more abstract, generic version later:</p>
			<pre class="source-code">
// continued...
const testOddR = filterTR(testOdd);
const testUnderFiftyR = filterTR(testUnderFifty);
const duplicateR = mapTR(duplicate);
const addThreeR = mapTR(addThree);</pre>
			<p>Each of our original four functions is transformed, so they will calculate their result and call a reducer to deal with this further. As an example, <code>addThreeR()</code> will add three to its input and pass the<a id="_idIndexMarker662"/> incremented value to the next reducer, which in this case is <code>addToArray()</code>.</p>
			<p>This will build up the final resulting array. Now, we can write our whole transformation in a single step:</p>
			<pre class="source-code">
// continued...
const addToArray = (a: any[], v: any): any[] =&gt; {
  a.push(v);
  return a;
};
const a1 = myArray.reduce(
<strong class="bold">  testOddR(</strong>
<strong class="bold">    duplicateR(testUnderFiftyR(addThreeR(addToArray)))</strong>
<strong class="bold">  )</strong>,
  []
);
console.log(a1);
<strong class="bold">// Output: [ 21, 25 ], again</strong></pre>
			<p>This is quite a mouthful, but it works! However, we can simplify our code by using the <code>compose()</code> function:</p>
			<pre class="source-code">
// continued...
const transduce = &lt;A&gt;(arr: A[], fns: FN[]) =&gt;
  <strong class="bold">arr.reduce(compose(...fns)(addToArray), [])</strong>;
console.log(
  transduce(myArray, [
    testOddR,
    duplicateR,
    testUnderFiftyR,
    addThreeR,
  ])
);
<strong class="bold">// Output: [ 21, 25 ], yet again</strong></pre>
			<p>The code is the same, but pay particular attention to the <code>compose(...fns)(addToArray)</code> expression: we compose all the mapping and filtering functions—with the last one being <code>addToArray</code>—to build up the output. However, this is not <a id="_idIndexMarker663"/>as general as we may want it to be: why do we have to create an array? Why can’t we have a different final reducing function? We can go one better by generalizing a bit more.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor164"/>Generalizing for all reducers</h2>
			<p>To be able to work with<a id="_idIndexMarker664"/> all kinds of reducers and produce whatever kind of result they build, we’ll need to make a small change. The idea is simple: let’s modify our <code>transduce()</code> function so that it will accept a final reducer and a starting value for the accumulator:</p>
			<pre class="source-code">
// continued...
const transduce2 = &lt;A&gt;(
  arr: A[],
  fns: FN[],
<strong class="bold">  reducer: FN = addToArray,</strong>
<strong class="bold">  initial: any = []</strong>
) =&gt; arr.reduce(compose(...fns)(<strong class="bold">reducer</strong>), <strong class="bold">initial</strong>);
console.log(
  transduce2(myArray, [
    testOddR,
    duplicateR,
    testUnderFiftyR,
    addThreeR,
  ])
);
<strong class="bold">// Output: [ 21, 25 ], always</strong></pre>
			<p>To make this function more usable, we specified our array-building function (and an empty array as a starting accumulator value) so that if you skip those two parameters, you’ll get a reducer that produces an array. Now, let’s look at the other option: instead of an array, let’s<a id="_idIndexMarker665"/> calculate the sum of the resulting numbers after all the mapping and filtering:</p>
			<pre class="source-code">
// continued...
console.log(
  transduce2(
    myArray,
    [testOddR, duplicateR, testUnderFiftyR, addThreeR],
   <strong class="bold"> (acc, value) =&gt; acc + value</strong>,
   <strong class="bold"> 0</strong>
  )
);
<strong class="bold">// 46</strong></pre>
			<p>By using transducers, we have been able to optimize a sequence of <code>map</code>, <code>filter</code>, and <code>reduce</code> operations so that the input array is processed once and directly produces the output result (whether an array or a single value) without creating any intermediate arrays; a good gain!</p>
			<p>We’ve seen several ways of connecting functions; to round this off, let’s see how to write unit tests for connected functions.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor165"/>Testing connected functions</h1>
			<p>Let’s finish by considering testing for functions connected in all the ways we’ve seen in this chapter. Given that the<a id="_idIndexMarker666"/> mechanisms for pipelining and composition are similar, we will look at examples of both. They won’t differ, other than their logical differences due to the left-to-right or right-to-left order of function evaluation.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor166"/>Testing pipelined functions</h2>
			<p>When it comes to <a id="_idIndexMarker667"/>pipelining, we can start by looking at how to test the <code>pipeTwo()</code> function since the setup will be similar to <code>pipeline()</code>. We need to create some mocks and check whether they were called the correct number of times and whether they received the correct arguments each time. We will set them to provide a known answer to a call.</p>
			<p>By doing this, we can check whether the output of a function becomes the input of the next function in the pipeline:</p>
			<pre class="source-code">
// pipetwo.test.ts
describe("pipeTwo", function () {
  it("works with single arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(1);
    const fn2 = jest.fn().mockReturnValue(2);
    const pipe = pipeTwo(fn1, fn2);
    const result = pipe(22);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(22);
    expect(fn2).toHaveBeenCalledWith(1);
    expect(result).toBe(2);
  });
  it("works with multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(11);
    const fn2 = jest.fn().mockReturnValue(22);
    const pipe = pipeTwo(fn1, fn2);
    const result = pipe(12, 4, 56);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(12, 4, 56);
    expect(fn2).toHaveBeenCalledWith(11);
    expect(result).toBe(22);
  });
});</pre>
			<p>There is little to test given that our function always receives two functions as parameters. The only<a id="_idIndexMarker668"/> difference between the tests is that one shows a pipeline applied to a single argument, while the other shows it applied to several arguments.</p>
			<p>Moving on to <code>pipeline()</code>, the tests would be quite similar. However, we can add a test for a single-function pipeline (a border case!) and another with four functions:</p>
			<pre class="source-code">
// pipeline.test.ts
describe("pipeline", function () {
  it("works with a single function", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(11);
    const pipe = pipeline(fn1);
    const result = pipe(60);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(60);
    expect(result).toBe(11);
  });
  it("works with single arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(1);
    const fn2 = jest.fn().mockReturnValue(2);
    const pipe = pipeline(fn1, fn2);
    const result = pipe(22);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(22);
    expect(fn2).toHaveBeenCalledWith(1);
    expect(result).toBe(2);
  });
  it("works with multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(11);
    const fn2 = jest.fn().mockReturnValue(22);
    const pipe = pipeline(fn1, fn2);
    const result = pipe(12, 4, 56);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(12, 4, 56);
    expect(fn2).toHaveBeenCalledWith(11);
    expect(result).toBe(22);
  });
  it("works with 4 functions, multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(111);
    const fn2 = jest.fn().mockReturnValue(222);
    const fn3 = jest.fn().mockReturnValue(333);
    const fn4 = jest.fn().mockReturnValue(444);
    const pipe = pipeline(fn1, fn2, fn3, fn4);
    const result = pipe(24, 11, 63);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn3).toHaveBeenCalledTimes(1);
    expect(fn4).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(24, 11, 63);
    expect(fn2).toHaveBeenCalledWith(111);
    expect(fn3).toHaveBeenCalledWith(222);
    expect(fn4).toHaveBeenCalledWith(333);
    expect(result).toBe(444);
  });
});</pre>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor167"/>Testing composed functions</h2>
			<p>For composition, the style is the same (except that the order of function evaluation is reversed), so let’s take a<a id="_idIndexMarker669"/> look at a single test—here, I simply changed the order of the functions in the preceding test:</p>
			<pre class="source-code">
// compose.test.ts
describe("compose", function () {
  // other tests, omitted here
  it("works with 4 functions, multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(111);
    const fn2 = jest.fn().mockReturnValue(222);
    const fn3 = jest.fn().mockReturnValue(333);
    const fn4 = jest.fn().mockReturnValue(444);
    const comp = <strong class="bold">compose(fn4, fn3, fn2, fn1)</strong>;
    const result = comp(24, 11, 63);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn3).toHaveBeenCalledTimes(1);
    expect(fn4).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(24, 11, 63);
    expect(fn2).toHaveBeenCalledWith(111);
    expect(fn3).toHaveBeenCalledWith(222);
    expect(fn4).toHaveBeenCalledWith(333);
    expect(result).toBe(444);
  });
});</pre>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>Testing chained functions</h2>
			<p>To test the <code>chainify()</code> function, I opted to use the preceding <code>City</code> object I created—I didn’t want to mess with<a id="_idIndexMarker670"/> mocks, stubs, spies, and the like; I wanted to ensure that the code worked under normal conditions:</p>
			<pre class="source-code">
// chaining.test.ts
class City {
// as above
}
let myCity: City;
let myCity2: Chainify&lt;City&gt;;
describe("chainify", function () {
  beforeEach(() =&gt; {
    myCity = new City(
      "Montevideo, Uruguay",
      -34.9011,
      -56.1645
    );
    myCity2 = chainify(myCity);
  });
  it("doesn't affect get functions", () =&gt; {
    expect(myCity2.getName()).toBe("Montevideo, Uruguay");
    expect(myCity2.getCoords()[0]).toBe(-34.9011);
    expect(myCity2.getCoords()[1]).toBe(-56.1645);
  });
  it("doesn't affect getting attributes", () =&gt; {
    expect(myCity2.name).toBe("Montevideo, Uruguay");
    expect(myCity2.lat).toBe(-34.9011);
    expect(myCity2.long).toBe(-56.1645);
  });
  it("returns itself from setting functions", () =&gt; {
    //    expect(myCity2.setName("Other
      name")).toBe(myCity2);
    expect(myCity2.setLat(11)).toBe(myCity2);
    expect(myCity2.setLong(22)).toBe(myCity2);
  });
  it("allows chaining", () =&gt; {
    const newCoords = myCity2
      .setName("Pune, India")
      .setLat(18.5626)
      .setLong(73.8087)
      .getCoords();
    expect(myCity2.name).toBe("Pune, India");
    expect(newCoords[0]).toBe(18.5626);
    expect(newCoords[1]).toBe(73.8087);
  });
});</pre>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor169"/>Testing transduced functions</h2>
			<p>We tried several examples <a id="_idIndexMarker671"/>earlier in the chapter, and it’s easy to turn them into tests. We’ll also add new tests for border cases (for instance, just one function, only mapping functions, etc.) for more generality. For simplicity, I kept using the same data array and mapping and filtering functions I used before:</p>
			<pre class="source-code">
// transducing.test.ts
describe("transducing", () =&gt; {
  it("works with several functions", () =&gt; {
    expect(
      transduce(myArray, [
        testOddR,
        duplicateR,
        testUnderFiftyR,
        addThreeR,
      ])
    ).toEqual([21, 25]);
  });
  it("works with just one function at all", () =&gt; {
    expect(transduce(myArray, [testOddR])).toEqual([
      9, 11, 63,
    ]);
    expect(transduce(myArray, [addThreeR])).toEqual([
      25, 12, 63, 27, 14, 66,
    ]);
  });
  it("works with just mapping", () =&gt; {
    expect(
      transduce(myArray, [addThreeR, duplicateR])
    ).toEqual([50, 24, 126, 54, 28, 132]);
  });
  it("works with just filtering", () =&gt; {
    expect(
      transduce(myArray, [testOddR, testUnderFiftyR])
    ).toEqual([9, 11]);
  });
  it("works with special reducer", () =&gt; {
    expect(
      transduce2(
        myArray,
        [testOddR, duplicateR, testUnderFiftyR, addThreeR],
        (acc, value) =&gt; acc + value,
        0
      )
    ).toBe(46);
  });
});</pre>
			<p>The final result of all of these tests can be seen in the following screenshot:</p>
			<div><div><img src="img/Figure_8.5_B19301.jpg" alt="Figure 8.5 – A successful run of testing for connected functions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – A successful run of testing for connected functions</p>
			<p>As we can see, all our<a id="_idIndexMarker672"/> tests passed successfully; good!</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we learned how to create new functions by joining several other functions in different ways using pipelining and composition. We also looked at fluent interfaces, which apply chaining, and transducing, a way to compose reducers to get higher-speed sequences of transformations. With these methods, you’ll be able to create new functions out of existing ones and keep programming in the declarative way we favor.</p>
			<p>In <a href="B19301_09.xhtml#_idTextAnchor172"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Functions</em>, we will move on to function design and study the usage of recursion, which is a basic tool in FP and allows for very clean algorithm designs.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor171"/>Questions</h1>
			<p>8.1 <code>headline(sentence)</code> function that will receive a string as an argument and return an appropriately capitalized version. Spaces separate words. Build this function by connecting smaller functions:</p>
			<pre class="source-code">
console.log(headline("Alice's ADVENTURES in WoNdErLaNd"));
// Alice's Adventures In Wonderland</pre>
			<p>8.2 <code>done===true</code>) or pending (<code>done===false</code>). Your goal is to produce an array with the IDs of the pending tasks for a given person, identified by name, which should match the responsible field. Solve this by using composition or pipelining:</p>
			<pre class="source-code">
const allTasks = {
  date: "2017-09-22",
  byPerson: [
    {
      responsible: "EG",
      tasks: [
        { id: 111, desc: "task 111", done: false },
        { id: 222, desc: "task 222", done: false },
      ],
    },
    {
      responsible: "FK",
      tasks: [
        { id: 555, desc: "task 555", done: false },
        { id: 777, desc: "task 777", done: true },
        { id: 999, desc: "task 999", done: false },
      ],
    },
    {
      responsible: "ST",
      tasks: [{ id: 444, desc: "task 444", done: true }],
    },
  ],
};</pre>
			<p>Ensure your code doesn’t throw an exception if, for example, the person you are looking for doesn’t appear in the web service result!</p>
			<p>8.3 <strong class="bold">Thinking in abstract terms</strong>: Suppose you are looking through somewhat old code and find a function that looks like the following one. (I’m keeping the names vague and abstract so that you can focus on the structure and not on the actual functionality). Can you transform this into pointfree style?</p>
			<pre class="source-code">
function getSomeResults(things) {
  return sort(group(filter(select(things))));
}</pre>
			<p>8.4 <code>Compose&lt;&gt;</code> type using the <code>Pipeline&lt;&gt;</code> type plus a new <code>Reverse&lt;&gt;</code> type. What should that new type be?</p>
			<p>8.5 <strong class="bold">Empty pipeline?</strong> Do our pipelining functions work with an empty array of functions? Can you fix that?</p>
			<p>8.6 <code>addToArray()</code> function we wrote is actually impure? (Check out the <em class="italic">Argument mutation</em> section of <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a><em class="italic">, Behaving Properly,</em> if you aren’t convinced!) Would it be better if we wrote it as follows? Should we go for it?</p>
			<pre class="source-code">
const addToArray = (a, v) =&gt; [...a, v];</pre>
			<p>8.7 <code>map()</code> operations? What if you only had <code>filter()</code> operations?</p>
			<p>8.8 <code>myCity2</code> object was not the same as the type of the original <code>myCity</code> one. What is its type exactly?</p>
		</div>
	</body></html>