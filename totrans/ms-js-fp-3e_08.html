<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-148" class="chapter-number"><a id="_idTextAnchor148"/>8</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Connecting Functions – Pipelining, Composition, and More</h1>
			<p>In <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>, we looked at ways to build new functions by applying higher-order functions. In this chapter, we will go to the core of FP and learn how to create sequences of function calls and how to combine them to produce a more complex result out of several simpler components. To do this, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><strong class="bold">Pipelining</strong>: A way to <a id="_idIndexMarker585"/>join functions, similar to <span class="No-Break">Unix/Linux pipes</span></li>
				<li><strong class="bold">Chaining</strong>: A variant of<a id="_idIndexMarker586"/> pipelining, but restricted <span class="No-Break">to objects</span></li>
				<li><strong class="bold">Composing</strong>: A classic<a id="_idIndexMarker587"/> operation with its origins in basic <span class="No-Break">computer theory</span></li>
				<li><strong class="bold">Transducing</strong>: An optimized<a id="_idIndexMarker588"/> way to compose <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, or <span class="No-Break"><strong class="source-inline">reduce</strong></span><span class="No-Break"> operations</span></li>
			</ul>
			<p>Along the way, we will be touching on related concepts, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Pointfree style</strong>, which is often <a id="_idIndexMarker589"/>used with pipelining <span class="No-Break">and composition</span></li>
				<li><strong class="bold">Debugging</strong> of composed or piped functions, for which we’ll whip up some <span class="No-Break">auxiliary tools</span></li>
				<li><strong class="bold">Testing</strong> for these functions, which won’t prove to be of <span class="No-Break">high complexity</span></li>
			</ul>
			<p>Armed with these techniques, you’ll be able to combine small functions to create larger ones, which is a characteristic of FP and will help you develop <span class="No-Break">better code.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Pipelining</h1>
			<p>Pipelining and <a id="_idIndexMarker590"/>composition are techniques that are used to set up functions to work in sequence so that the output of a function becomes the input for the following function. There are two ways of looking at this: from a computer point of view, and from a mathematical point of view. We’ll look at both in this section. Most FP texts start with the latter, but since I assume that most of you will prefer computers over math, let’s start with<a id="_idIndexMarker591"/> the <span class="No-Break">former instead.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor151"/>Piping in Unix/Linux</h2>
			<p>In Unix/Linux, executing a command and passing its output as input to a second command, whose output will yield the input of a third command, and so on, is called a pipeline. This is quite a common <a id="_idIndexMarker592"/>application of the philosophy of Unix, as explained in a Bell Laboratories article written by the creator of the pipelining concept<a id="_idIndexMarker593"/> himself, <span class="No-Break">Doug McIlroy:</span></p>
			<ul>
				<li>Make each program do one thing well. To do a new job, build afresh rather than complicating old programs by adding <span class="No-Break">new features.</span></li>
				<li>Expect the output of every program to become the input to another, so far <span class="No-Break">unknown program.</span></li>
			</ul>
			<p class="callout-heading">A bit of history</p>
			<p class="callout">Given the historical importance of Unix, I’d recommend reading some of the seminal articles describing the (then new) operating system in the Bell System Technical Journal, July 1978, at <a href="http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf">emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf</a>. The two quoted rules are in the <em class="italic">Style</em> section of the <span class="No-Break"><em class="italic">Foreword</em></span><span class="No-Break"> article.</span></p>
			<p>Let’s consider a simple example to get started. Suppose I want to know how many LibreOffice text documents there are in a directory. There are many ways to do this, but the following example will do. We will execute three commands, piping (that’s the meaning of the <strong class="source-inline">|</strong> character) each command’s output as input to the next one. Suppose we have <strong class="source-inline">cd /home/fkereki/Documents</strong> and then do the following (please ignore the dollar sign, which is just the <span class="No-Break">console prompt):</span></p>
			<pre class="console">
$ ls -1 | grep "odt$" | wc -l
<strong class="bold">4</strong></pre>
			<p>What does this mean? How does it work? We have to analyze this process step <span class="No-Break">by step:</span></p>
			<ul>
				<li>The first part of the pipeline, <strong class="source-inline">ls -1</strong>, lists all the files in the current directory (<strong class="source-inline">/home/fkereki/Documents</strong>, as per our <strong class="source-inline">cd</strong> command) in a single column, with one filename <span class="No-Break">per line</span></li>
				<li>The output from the first command is provided as input to <strong class="source-inline">grep "odt$"</strong>, which filters (only lets pass) lines that finish with <strong class="source-inline">"odt"</strong>, the standard file extension for <span class="No-Break">LibreOffice Writer</span></li>
				<li>The filtered output is provided to the counting command, <strong class="source-inline">wc -l</strong>, which counts how many<a id="_idIndexMarker594"/> lines there are in <span class="No-Break">its input</span></li>
			</ul>
			<p class="callout-heading">More on pipelining</p>
			<p class="callout">You can find out more about pipelines in <em class="italic">Section 6.2</em>, <em class="italic">Filters</em>, of <em class="italic">The UNIX Time-Sharing System</em> by Dennis Ritchie<a id="_idIndexMarker595"/> and Ken Thompson, also in the issue of the Bell Laboratories journal that I <span class="No-Break">mentioned previously.</span></p>
			<p>From the point of view of FP, this is a key concept. We want to build more complex operations out of simple, single-purpose, shorter functions. Pipelining is what the Unix shell uses to apply that concept. It does this by simplifying the job of executing a command, taking its output, and providing it as input to yet another command. We will apply similar<a id="_idIndexMarker596"/> concepts in our own functional style in <span class="No-Break">JavaScript later:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_8.1_B19301.jpg" alt="Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines. The output of each function becomes the input for the next"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines. The output of each function becomes the input for the next</p>
			<p>By the way (and no—rest assured, this isn’t turning into a shell tutorial!), you can make pipelines accept parameters. For example, if I happened to want to count how many files I had with this or that extension, I could create a function such as <strong class="source-inline">cfe</strong>, standing for <em class="italic">count </em><span class="No-Break"><em class="italic">for extension</em></span><span class="No-Break">:</span></p>
			<pre class="console">
$ function cfe() {
ls -1 | grep "$1\$"| wc -l
}</pre>
			<p>Then, I could use <strong class="source-inline">cfe</strong> as a command, giving it the desired extension as <span class="No-Break">an argument:</span></p>
			<pre class="console">
$ cfe odt
<strong class="bold">4</strong>
$ cfe pdf
<strong class="bold">6</strong></pre>
			<p><strong class="source-inline">cfe</strong> executes my pipeline and tells me I have four <strong class="source-inline">odt</strong> files (LibreOffice) and six <strong class="source-inline">pdf</strong> files; nice! We will also<a id="_idIndexMarker597"/> want to write similar parametric pipelines: we are not constrained to fixed functions in <a id="_idIndexMarker598"/>our flow; we have full liberty regarding what we want to include. Having worked in Linux, we can now go back to coding. Let’s <span class="No-Break">see how.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor152"/>Revisiting an example</h2>
			<p>We can start tying <a id="_idIndexMarker599"/>ends together by revisiting a problem from a previous chapter. Remember when we had to calculate the average latitude and longitude for some geographic data that we looked at in the <em class="italic">Extracting data from objects</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Programming Declaratively</em>? Basically, we started with some data such as the following, and the problem was to calculate the average latitude and longitude of the <span class="No-Break">given points:</span></p>
			<pre class="source-code">
const markers = [
  { name: "AR", lat: -34.6, lon: -58.4 },
  { name: "BO", lat: -16.5, lon: -68.1 },
  { name: "BR", lat: -15.8, lon: -47.9 },
  { name: "CL", lat: -33.4, lon: -70.7 },
  { name: "CO", lat:   4.6, lon: -74.0 },
  { name: "EC", lat:  -0.3, lon: -78.6 },
  { name: "PE", lat: -12.0, lon: -77.0 },
  { name: "PY", lat: -25.2, lon: -57.5 },
  { name: "UY", lat: -34.9, lon: -56.2 },
  { name: "VE", lat:  10.5, lon: -66.9 },
];</pre>
			<p>With what we know, we can write a solution in terms of <span class="No-Break">the following:</span></p>
			<ul>
				<li>Being able to extract the latitude (and afterward, the longitude) from <span class="No-Break">each point</span></li>
				<li>Using that function to create an array <span class="No-Break">of latitudes</span></li>
				<li>Pipelining the resulting array to the average function we wrote in the <em class="italic">Calculating an average</em> section of the <span class="No-Break">aforementioned chapter</span></li>
			</ul>
			<p>To do the first task, we can use the <strong class="source-inline">myMap()</strong> function from the <em class="italic">Parameter order</em> section of <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><em class="italic">, Transforming Functions</em>. For the second task, we can make do with the <strong class="source-inline">getField()</strong> function from the <em class="italic">Getting a property from an object</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Producing Functions</em>. Finally, for the third task, we’ll <a id="_idIndexMarker600"/>use the (yet unwritten) <strong class="source-inline">pipeline()</strong> function we’ll develop soon! In full, our solution could look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const sum = (x: number, y: number): number =&gt; x + y;
const average = (arr: number[]) =&gt;
  arr.reduce(sum, 0) / arr.length;
const myMap = curry(
  flip2(demethodize(Array.prototype.map))
);
const getAllLats = myMap(getField("lat")) as (
  arg: any
) =&gt; number[];
const averageLat = <strong class="bold">pipeline</strong>(getAllLats, average)(markers);
// and similar code to average longitudes</pre>
			<p>We had to add some casting to <strong class="source-inline">getAllLats</strong> so that TypeScript would know to what we would apply <span class="No-Break">that function.</span></p>
			<p>Of course, you can always yield to the temptation of going for one-liners, but would it be much clearer <span class="No-Break">or better?</span></p>
			<pre class="source-code">
const averageLat2 = pipeline(
  curry(flip2(demethodize(Array.prototype.map)))(
    getField("lat")
  ) as (arg: any) =&gt; number[],
  average
)(markers);</pre>
			<p>Whether this makes sense to you will depend on your experience with FP. In any case, no matter which solution you take, the fact remains that adding pipelining (and later on, composition) to your set of tools can help you write tighter, declarative, <span class="No-Break">simpler-to-understand code.</span></p>
			<p>Now, let’s learn <a id="_idIndexMarker601"/>how to pipeline functions in the <span class="No-Break">right way.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor153"/>Creating pipelines</h2>
			<p>We want to be able to generate a pipeline of several functions. We can do this in two ways: by building the pipeline by hand, in a problem-specific way, or by using more generic constructs that can <a id="_idIndexMarker602"/>be applied with generality. Let’s look <span class="No-Break">at both.</span></p>
			<p class="callout-heading">Potential pipeline proposal</p>
			<p class="callout">A new operator, <strong class="source-inline">|&gt;</strong>, is being considered for JavaScript, but it’s currently only at stage 2, which means it may be a while before it’s accepted and available. You may read more about the proposal and its varied history <span class="No-Break">at </span><a href="http://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md"><span class="No-Break">github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md</span></a><span class="No-Break">.</span></p>
			<h3>Building pipelines by hand</h3>
			<p>Let’s go with a <a id="_idIndexMarker603"/>Node.js example, similar to the command-line pipeline we built earlier in this chapter. Here, we’ll build the pipeline we need by hand. We need a function to read all the files in a directory. We can do that (although this isn’t recommended because of the synchronous call, which is normally not good in a server environment) with something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
// pipeline.ts
function getDir(path) {
  const fs = require("fs");
  const files = fs.readdirSync(path);
  return files;
}</pre>
			<p>Selecting only <strong class="source-inline">odt</strong> files is quite simple. We start with the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
// continued...
const filterByText = (
  text: string,
  arr: string[]
): string[] =&gt; arr.filter(<strong class="bold">(v) =&gt; v.endsWith(text)</strong>);</pre>
			<p>This function takes an array of strings and filters out elements that do not end with the given text, so we can <a id="_idIndexMarker604"/>now write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const filterOdt = (arr: string[]): string[] =&gt;
  <strong class="bold">filterByText(".odt", arr)</strong>;</pre>
			<p>Better still, we can apply currying and go for pointfree style, as shown in the <em class="italic">An unnecessary mistake</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>, and write <span class="No-Break">this, instead:</span></p>
			<pre class="source-code">
// continued...
const filterOdt = <strong class="bold">curry(filterByText)</strong>(".odt");</pre>
			<p>Both versions of the filtering function are equivalent; which one you use comes down to your tastes. Finally, we can write the following to count elements in an array. Since <strong class="source-inline">length</strong> is not a function, we cannot apply our <span class="No-Break">demethodizing trick:</span></p>
			<pre class="source-code">
// continued...
const count = &lt;T&gt;(arr: T[]): number =&gt; <strong class="bold">arr.length</strong>;</pre>
			<p>With these functions, we could write something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
// continued...
const countOdtFiles = (path: string): number =&gt; {
  const files = getDir(path);
  const filteredFiles = filterOdt(files);
  const countOfFiles = count(filteredFiles);
  return countOfFiles;
};
<strong class="bold">countOdtFiles("/home/fkereki/Documents")</strong>;
// 4, as with the command line solution</pre>
			<p>We are essentially doing the same process as in Linux: getting the files, keeping only the <strong class="source-inline">odt</strong> ones, and counting how many files result from this. If you wanted to get rid of all the intermediate variables, you could also go for a one-liner definition that does precisely the same job in the very same way, albeit with <span class="No-Break">fewer lines:</span></p>
			<pre class="source-code">
const countOdtFiles2 = (path: string): number =&gt;
  <strong class="bold">count(filterOdt(getDir(path)))</strong>;
const c2 = countOdtFiles2("/home/fkereki/Documents");
// 4, again</pre>
			<p>This gets to the <a id="_idIndexMarker605"/>crux of the matter: both implementations of our file-counting function have disadvantages. The first definition uses several intermediate variables to hold the results and makes a multiline function out of what was a single line of code in the Linux shell. On the other hand, the second, much shorter definition is harder to understand, insofar as we are writing the steps of the computation in seemingly reverse order! Our pipeline has to read files first, then filter them, and finally count them, but those functions appear <em class="italic">the other way around</em> in <span class="No-Break">our definition!</span></p>
			<p>We can undoubtedly implement pipelining by hand, as we have seen, but it would be better if we went for a more <span class="No-Break">declarative style.</span></p>
			<p>Let’s move on and try to build a better pipeline more clearly and more understandably by applying some of the concepts we’ve <span class="No-Break">already seen.</span></p>
			<h3>Using other constructs</h3>
			<p>If we think in functional terms, what<a id="_idIndexMarker606"/> we have is a list of functions and we want to apply them sequentially, starting with the first, then applying the second to whatever the first function produced as its result, and then applying the third to the second function’s results, and so on. If we were fixing a pipeline of two functions, we could use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const pipeTwo =
  &lt;AF extends any[], RF, RG&gt;(
    f: (...args: AF[]) =&gt; RF,
    g: (arg: RF) =&gt; RG
  ) =&gt;
  (...args: any[]) =&gt; g(f(...args));</pre>
			<p>This is the basic definition we provided earlier in this chapter: we evaluate the first function, and its output becomes the input for the second function; relatively straightforward! Typing is simple: the first function to apply (<strong class="source-inline">f()</strong>) may have any number of parameters, but the second function (<strong class="source-inline">g()</strong>) must have a single one, the same type that <strong class="source-inline">f()</strong> returns. The return type of the pipeline is the return type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">g()</strong></span><span class="No-Break">.</span></p>
			<p>You may object, though, that this pipeline of only two functions is a bit too limited! This is not as useless as it may seem because we can compose longer pipelines—though I’ll admit that it requires<a id="_idIndexMarker607"/> too much writing! Suppose we wanted to write our three-function pipeline (from the previous section); we could do so in two different, <span class="No-Break">equivalent ways:</span></p>
			<pre class="source-code">
// continued...
const countOdtFiles3 = (path: string): number =&gt;
  <strong class="bold">pipeTwo(pipeTwo(getDir, filterOdt), count)</strong>(path);
const countOdtFiles4 = (path: string): number =&gt;
  <strong class="bold">pipeTwo(getDir, pipeTwo(filterOdt, count))</strong>(path);</pre>
			<p class="callout-heading">A touch of math</p>
			<p class="callout">We are taking advantage of the fact that piping is an associative operation. In mathematics, the associative property is the one that says that we can compute 1+2+3 either by adding 1+2 first and then adding that result to 3 or by adding 1 to the result of first adding 2+3: in other terms, 1+2+3 is the same as (1+2)+3 <span class="No-Break">or 1+(2+3).</span></p>
			<p>How do they work? How is it that they are equivalent? Following the execution of a given call will be useful; it’s quite easy to get confused with so many calls! The first implementation can be followed step by step until the final result, which matches what we <span class="No-Break">already know:</span></p>
			<pre class="source-code">
countOdtFiles3(path) ===
  pipeTwo(pipeTwo(getDir, filterOdt), count)
  pipeTwo(filterOdt(getDir(path)), count)(path)
  pipeTwo(count(filterOdt(getDir(path))))</pre>
			<p>The second implementation also comes to the same <span class="No-Break">final result:</span></p>
			<pre class="source-code">
countOdtFiles4(path) ===
  pipeTwo(getDir, pipeTwo(filterOdt, count))(path)
  pipeTwo(getDir(path), pipeTwo(filterOdt, count))
  pipeTwo(filterOdt, count)(getDir(path))
  pipeTwo(count(filterOdt(getDir(path))))</pre>
			<p>Both derivations arrived at the same final expression—the same we had written by hand earlier, in fact—so <a id="_idIndexMarker608"/>we now know that we can make do just with a basic <em class="italic">pipe of two</em> higher-order functions, but we’d really like to be able to work in a shorter, more compact way. A first implementation could be along the lines of the following, and let’s look at <span class="No-Break">typing later:</span></p>
			<pre class="source-code">
function pipeline(...fns) {
  return (...args) =&gt; {
    let result = fns[0](...args);
    for (let i = 1; i &lt; fns.length; i++) {
      result = fns[i](result);
    }
    return result;
  };
}
<strong class="bold">pipeline(</strong>
<strong class="bold">  getDir,</strong>
<strong class="bold">  filterOdt,</strong>
<strong class="bold">  count</strong>
<strong class="bold">)</strong>("/home/fkereki/Documents"); // still 4</pre>
			<p>This does work—and specifying our file-counting pipeline is much clearer since the functions are given in their proper order. However, the implementation of the <strong class="source-inline">pipeline()</strong> function is not very functional and goes back to old, imperative, loop-by-hand methods. We can do better using <strong class="source-inline">reduce()</strong>, as in <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <span class="No-Break"><em class="italic">Programming Declaratively</em></span><span class="No-Break">.</span></p>
			<p>The idea is to start the evaluation with the first function, pass the result to the second, then that result to the third, and so on. By doing this, we can pipeline with shorter code, and again we’ll leave typing <span class="No-Break">for later:</span></p>
			<pre class="source-code">
// continued...
function pipeline2(...fns) {
  return fns.reduce(
    (result, f) =&gt;
      (...args) =&gt;
        f(result(...args))
  );
}</pre>
			<p>This code is more declarative. However, you could have gone one better by writing it using our <strong class="source-inline">pipeTwo()</strong> function, which does the same thing but <span class="No-Break">more concisely:</span></p>
			<pre class="source-code">
// continued...
function pipeline3(...fns) {
  return fns.reduce(pipeTwo);
}</pre>
			<p>(Using an arrow<a id="_idIndexMarker609"/> function would make for even shorter code.) You can understand this code by realizing that it uses the associative property we mentioned previously and pipes the first function to the second; then, it pipes this result to the third function, and <span class="No-Break">so on.</span></p>
			<p>Which version is better? I would say that the version that refers to the <strong class="source-inline">pipeTwo()</strong> function is clearer: if you know how <strong class="source-inline">reduce()</strong> works, you can readily understand that our pipeline goes through the functions two at a time, starting from the first—and that matches what you know about how pipes work. The other versions we wrote are more or less declarative, but not as simple <span class="No-Break">to understand.</span></p>
			<p>We didn’t look at typing for all our pipelining functions, so let’s do <span class="No-Break">that now.</span></p>
			<h3>Typing</h3>
			<p>When we pipeline several<a id="_idIndexMarker610"/> functions, a function’s output type should be the same as the following function’s parameter type. Let’s have an auxiliary <strong class="source-inline">FnsMatchPipe&lt;&gt;</strong> type to check whether two types satisfy <span class="No-Break">this condition:</span></p>
			<pre class="source-code">
// continued…
type FN = (...args: any[]) =&gt; any;
type FnsMatchPipe&lt;FNS extends FN[]&gt; =
  1 extends FNS["length"]
    ? boolean
    : FNS extends [
        infer FN1st extends FN,
        infer FN2nd extends FN,
        ...infer FNRest extends FN[]
      ]
    ? Parameters&lt;FN2nd&gt; extends [ReturnType&lt;FN1st&gt;]
      ? FnsMatchPipe&lt;[FN2nd, ...FNRest]&gt;
      : never
    : never;</pre>
			<p>This works recursively. If we have a single function in the pipeline (the length of <strong class="source-inline">FNS</strong> is <strong class="source-inline">1</strong>), then we return <strong class="source-inline">boolean</strong> to signify success. If we have more than one function, we take the first and second functions, check that the parameter of the latter is the same type as the return type<a id="_idIndexMarker611"/> of the former, and apply recursion to check types from the second function onward. If there’s no match in types, we return <strong class="source-inline">never</strong> to mark <span class="No-Break">a failure.</span></p>
			<p>Now, what’s the type of the pipeline? The type of its arguments will match the first function’s argument type, and the type of the result will match the last function’s <span class="No-Break">result type:</span></p>
			<pre class="source-code">
// continued...
type Pipeline&lt;FNS extends FN[]&gt; =
  boolean extends FnsMatchPipe&lt;FNS&gt;
    ? 1 extends FNS["length"]
      ? FNS[0]
      : FNS extends [
          infer FNFIRST extends FN,
          ...FN[],
          infer FNLAST extends FN
        ]
      ? (...args: Parameters&lt;FNFIRST&gt;) =&gt; ReturnType&lt;FNLAST&gt;
      : never
    : never;</pre>
			<p>We first verify that the function’s types are correct, using <strong class="source-inline">FnsMatchPipe&lt;&gt;</strong>. If the types match, the type of the whole pipeline is that of a function that gets arguments of the same type as the first function in the pipeline and returns a value of the same type as the last <span class="No-Break">pipelined function.</span></p>
			<p>Now, our pipelines can be properly written – and we’ll have to use the same “overloading” as in the previous chapter to help TypeScript work <span class="No-Break">out types:</span></p>
			<pre class="source-code">
// continued...
function pipeline<strong class="bold">&lt;FNS extends FN[]&gt;(</strong>
<strong class="bold">  ...fns: FNS</strong>
<strong class="bold">): Pipeline&lt;FNS&gt;</strong>;
function pipeline&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return (...args: Parameters&lt;FNS[0]&gt;) =&gt; {
    let result = fns[0](...args);
    for (let i = 1; i &lt; fns.length; i++) {
      result = fns[i](result);
    }
    return result;
  };
}
function pipeline2<strong class="bold">&lt;FNS extends FN[]&gt;(</strong>
<strong class="bold">  ...fns: FNS</strong>
<strong class="bold">): Pipeline&lt;FNS&gt;</strong>;
function pipeline2&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return fns.reduce(
    (result, f) =&gt;
      (...args) =&gt;
        f(result(...args))
  );
}
function pipeline3<strong class="bold">&lt;FNS extends FN[]&gt;(</strong>
<strong class="bold">  ...fns: FNS</strong>
<strong class="bold">): Pipeline&lt;FNS&gt;</strong>;
function pipeline3&lt;FNS extends FN[]&gt;(
  ...fns: FNS
): (...fns: FNS) =&gt; FN {
  return fns.reduce(pipeTwo);
}</pre>
			<p>Before we look at <a id="_idIndexMarker612"/>other ways to connect functions, let’s consider how we would debug <span class="No-Break">our pipelines.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor154"/>Debugging pipelines</h2>
			<p>Now, let’s turn to a practical question: how do you debug your code? With pipelining, you can’t see what’s<a id="_idIndexMarker613"/> passed on from function to function, so how do you do it? We have two answers for that: one (also) comes from the Unix/Linux world, and the other (the most <a id="_idIndexMarker614"/>appropriate for this book) uses wrappers to provide <span class="No-Break">some logs.</span></p>
			<h3>Using tee</h3>
			<p>The first solution we’ll use implies adding a function<a id="_idIndexMarker615"/> to the pipeline, which will just log its input. We want to implement something similar to the <strong class="source-inline">tee</strong> Linux command, which can intercept the standard data flow in a pipeline and send a copy to an alternate file or device. Remembering that <strong class="source-inline">/dev/tty</strong> is the usual console, we could<a id="_idIndexMarker616"/> execute something similar to the following and get an onscreen copy of everything that passes using the <span class="No-Break"><strong class="source-inline">tee</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ ls -1 | grep "odt$" | tee /dev/tty | wc -l
...the list of files with names ending in odt...
4</pre>
			<p>We could write a similar function <span class="No-Break">with ease:</span></p>
			<pre class="source-code">
// pipeline_debug.ts
const tee = &lt;A&gt;(arg: A) =&gt; {
  console.log(arg);
  return arg;
};</pre>
			<p class="callout-heading">Comma power!</p>
			<p class="callout">If you are aware of the uses of the comma operator, you can be more concise and write <strong class="source-inline">const tee2 = &lt;A&gt;(arg: A) =&gt; (console.log(arg), arg)</strong>—do you see why? Check out <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator</a> for <span class="No-Break">the answer!</span></p>
			<p>Our logging function is <a id="_idIndexMarker617"/>short and to the point: it will receive a single argument, list it, and pass it on to the<a id="_idIndexMarker618"/> following function in the pipe. We can see it working in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
console.log(
  pipeline3(
    getDir,
<strong class="bold">    tee,</strong>
    filterOdt,
<strong class="bold">    tee,</strong>
    count
  )("/home/fkereki/Documents")
);
<strong class="bold">...the list of all the files in the directory...</strong>
<strong class="bold">...the list of files with names ending in odt...</strong>
<strong class="bold">4</strong></pre>
			<p>It would be even better if our <strong class="source-inline">tee()</strong> function could receive a logger function as a parameter, as in the <em class="italic">Logging in a functional way</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Producing Functions</em>; it’s just a matter of making the same kind of change we managed there. The same good design concepts are <span class="No-Break">applied again!</span></p>
			<pre class="source-code">
// continued...
const tee2 = &lt;A&gt;(arg: A, <strong class="bold">logger = console.log</strong>) =&gt; {
  logger(arg);
  return arg;
};</pre>
			<p>This function works exactly in the same way as the previous <strong class="source-inline">tee()</strong>, although it will allow us to be more flexible when it comes to applying and testing. However, in our case, this would just be an extra enhancement to an already <span class="No-Break">easily-testable function.</span></p>
			<p>Let’s consider an even more generic tapping function, with more possibilities than just doing a bit <span class="No-Break">of logging.</span></p>
			<h3>Tapping into a flow</h3>
			<p>If you wish, you could write an enhanced <strong class="source-inline">tee()</strong> function to produce more debugging information, send the reported data to a file or remote service, and so on—there are many possibilities you can <a id="_idIndexMarker619"/>explore. You could also explore a more general solution, of which <strong class="source-inline">tee()</strong> would be a particular case and allow us to create personalized tapping functions. This can be seen in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_8.2_B19301.jpg" alt="Figure 8.2 – Tapping allows you to apply a function so that you can inspect data as it ﬂows through the pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Tapping allows you to apply a function so that you can inspect data as it ﬂows through the pipeline</p>
			<p>When working with pipelines, you may want to put a logging function in the middle of them, or you might want some other kind of <em class="italic">snooping</em> function—possibly for storing data somewhere, calling a service, or some other kind of side effect. We could have a generic <strong class="source-inline">tap()</strong> function to allow us to inspect data as it moves along our pipeline, which would behave in the <span class="No-Break">following way:</span></p>
			<pre class="source-code">
// continued...
const tap = curry(&lt;A&gt;(fn: FN, x: A) =&gt; (fn(x), x));</pre>
			<p>This is a candidate for the <em class="italic">trickiest-looking code-in-the-book</em> award, so let’s explain it. We want to produce a function that, given a function, <strong class="source-inline">fn()</strong>, and an argument, <strong class="source-inline">x</strong>, will evaluate <strong class="source-inline">fn(x)</strong> (to produce whatever sort of side effect we may be interested in) but return <strong class="source-inline">x</strong> (so the pipeline<a id="_idIndexMarker620"/> goes on without interference). The comma operator has exactly that behavior: if you write something similar to <strong class="source-inline">(a, b, c)</strong>, JavaScript will evaluate the three expressions in order and use the last value as the <span class="No-Break">expression’s value.</span></p>
			<p>Here, we can use currying to produce several different tapping functions. The one we wrote in the previous section, <strong class="source-inline">tee()</strong>, could also be written in the <span class="No-Break">following fashion:</span></p>
			<pre class="source-code">
// continued...
const tee3 = tap(console.log);</pre>
			<p>By the way, you could have also written <strong class="source-inline">tap()</strong> without currying, but you’ll have to admit it loses some of its mystery! This is <span class="No-Break">demonstrated here:</span></p>
			<pre class="source-code">
// continued...
const tap2 = (fn: FN) =&gt; &lt;A&gt;(x: A) =&gt; (fn(x), x);</pre>
			<p>This does exactly the<a id="_idIndexMarker621"/> same job, and you’ll recognize this way of currying from the <em class="italic">Currying by hand</em> section of <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><em class="italic">, Transforming Functions</em>. Now that we have learned how to tap into a pipeline, let’s move on to a different way of logging by revisiting some concepts we looked at in <span class="No-Break">previous chapters.</span></p>
			<h3>Using a logging wrapper</h3>
			<p>The second idea we <a id="_idIndexMarker622"/>mentioned is based on the <strong class="source-inline">addLogging()</strong> function we wrote in the <em class="italic">Logging</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Producing Functions</em>. The idea was to wrap a function with some logging functionality so that, on <a id="_idIndexMarker623"/>entry, the arguments would be printed and, on exit, the result of the function would <span class="No-Break">be shown:</span></p>
			<pre class="source-code">
pipeline2(
  addLogging(getDir),
  addLogging(filterOdt),
  addLogging(count)
)("/home/fkereki/Documents");
entering getDir(/home/fkereki/Documents)
exiting  getDir=&gt; ...list of files...
entering filterOdt(...list of files, again...)
exiting  =&gt; ...list of .odt files...
entering count(...list of .odt files ...)
exiting  count=&gt;4</pre>
			<p>We can trivially verify that the <strong class="source-inline">pipeline()</strong> function is doing its thing correctly—whatever a function produces as a result is given as input to the next function in the line, and we can also understand what’s happening with each call. Of course, you don’t need to add logging to every function in the pipeline: you would probably do so in places where you suspected an error <span class="No-Break">was occurring.</span></p>
			<p>Now that we’ve looked at how to join functions, let’s look at a common way of defining functions in FP, <em class="italic">pointfree style</em>, which you <span class="No-Break">may encounter.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor155"/>Pointfree style</h2>
			<p>When you join functions together, either in a pipeline or with composition, as we’ll see later in this chapter, you don’t need any intermediate variables to hold the results that will become arguments to the following function in line: they are implicit. Similarly, you can write functions without <a id="_idIndexMarker624"/>mentioning their parameters; this is called the <span class="No-Break"><em class="italic">pointfree style</em></span><span class="No-Break">.</span></p>
			<p>(By the way, pointfree style is also called <em class="italic">tacit</em> programming and <em class="italic">pointless</em> programming by detractors! The term point itself means a function parameter, while pointfree refers to not naming <span class="No-Break">those parameters.)</span></p>
			<h3>Defining pointfree functions</h3>
			<p>You can easily recognize a pointfree function <a id="_idIndexMarker625"/>definition because it doesn’t need the <strong class="source-inline">function</strong> keyword or the <strong class="source-inline">=&gt;</strong> arrow. Let’s revisit some of the previous functions we wrote in this chapter and check them out. For example, the definition of our original file-counting functions is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const countOdtFiles3 = (path: string): number =&gt;
  pipeTwo(pipeTwo(getDir, filterOdt), count)(path);
const countOdtFiles4 = (path: string): number =&gt;
  pipeTwo(getDir, pipeTwo(filterOdt, count))(path);</pre>
			<p>The preceding code could be rewritten <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// pointfree.ts
const countOdtFiles3b = pipeTwo(
  pipeTwo(getDir, filterOdt),
  count
);
const countOdtFiles4b = pipeTwo(
  getDir,
  pipeTwo(filterOdt, count)
);</pre>
			<p>The new definitions don’t reference the parameter for the newly <span class="No-Break">defined functions.</span></p>
			<p>You can deduce this by examining the first function in the pipeline (<strong class="source-inline">getDir()</strong>, in this case) and seeing what it receives as arguments. (Using type signatures, as we’ll see in <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, is of great help in terms of documentation, and complements TypeScript types.) In our <em class="italic">Revisiting an example</em> section, we could have written a <strong class="source-inline">getLat()</strong> function to get the <strong class="source-inline">lat</strong> field out of an object in a <span class="No-Break">pointfree fashion:</span></p>
			<pre class="source-code">
const getLat = curry(getField)("lat");</pre>
			<p>What should the equivalent full-style definition be? You’d have to examine the <strong class="source-inline">getField()</strong> function (we looked at this in the <em class="italic">Revisiting an example</em> section) to decide that it expects <a id="_idIndexMarker626"/>an object as an argument. However, making that need explicit by writing the following wouldn’t make <span class="No-Break">much sense:</span></p>
			<pre class="source-code">
const getLat = (obj) =&gt; curry(getField)("lat")(obj);</pre>
			<p>If you were willing to write all this, you might wish to stick with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const getLat = (obj) =&gt; obj.lat;</pre>
			<p>Then, you simply wouldn’t need to worry <span class="No-Break">about currying!</span></p>
			<h3>Converting to pointfree style</h3>
			<p>On the other hand, you had <a id="_idIndexMarker627"/>better pause for a minute and try not to write everything in pointfree code, at any cost. For example, consider the <strong class="source-inline">isNegativeBalance()</strong> function we wrote back in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <span class="No-Break"><em class="italic">Producing Functions</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const isNegativeBalance = v =&gt; v.balance &lt; 0;</pre>
			<p>Can we write this in a pointfree style? Yes, we can, and we’ll see how—but I’m not sure we’d want to code this way! We can consider building a pipeline of two functions: one will extract the balance from the given object, while the other will check whether it’s negative. Due to this, we will write our alternative version of the balance-checking function <span class="No-Break">like so:</span></p>
			<pre class="source-code">
const isNegativeBalance2 = pipeline(getBalance,
  isNegative);</pre>
			<p>To extract the <strong class="source-inline">balance</strong> attribute from a given object, we can use <strong class="source-inline">getField()</strong> and a bit of currying, and write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const getBalance = curry(getField)("balance");</pre>
			<p>For the second function, we could write the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const isNegative = (x: number): boolean =&gt; x &lt; 0;</pre>
			<p>There goes our pointfree goal! Instead, we can use the <strong class="source-inline">binaryOp()</strong> function, also from the same chapter we mentioned earlier, plus some more currying, to write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const isNegative = curry(binaryOp("&gt;"))(0);</pre>
			<p>I wrote the test the other way around (<strong class="source-inline">0&gt;x</strong> instead of <strong class="source-inline">x&lt;0</strong>) just for ease. An alternative would have been to use<a id="_idIndexMarker628"/> the enhanced functions I mentioned in the <em class="italic">A handier implementation</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, which is a bit less complex, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const isNegative = binaryOpRight("&lt;", 0);</pre>
			<p>So, finally, we could write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const isNegativeBalance2 = <strong class="bold">pipeline</strong>(
  curry(getField)("balance"),
  curry(binaryOp("&gt;"))(0)
);</pre>
			<p>Alternatively, we could write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const isNegativeBalance3 = <strong class="bold">pipeline</strong>(
  curry(getField)("balance"),
  binaryOpRight("&lt;", 0)
);</pre>
			<p>Is that an improvement? Our new versions of <strong class="source-inline">isNegativeBalance()</strong> don’t make a reference to their argument and are fully pointfree, but the idea of using pointfree style should be to help improve the clarity and readability of your code and not to produce obfuscation and opaqueness! I doubt anybody would look at our new versions of the function and consider them to be an advantage over <span class="No-Break">the original.</span></p>
			<p>If you find that your code is becoming harder to understand due to using pointfree programming, stop and roll back your changes. Remember our doctrine for this book: we want to do FP, but we don’t want to go overboard with it—and using the pointfree style is not <span class="No-Break">a requirement!</span></p>
			<p>In this section, we’ve learned<a id="_idIndexMarker629"/> how to build pipelines of functions—this is a powerful technique. For objects and arrays, however, we have another special technique that you may have used already: <em class="italic">chaining</em>. Let’s take a look at <span class="No-Break">this now.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor156"/>Chaining and fluent interfaces</h1>
			<p>When you work with objects or arrays, there is another way of linking the execution of several calls together: by applying <em class="italic">chaining</em>. For example, when you work with arrays, if you apply a <strong class="source-inline">map()</strong> or <strong class="source-inline">filter()</strong> method, the<a id="_idIndexMarker630"/> result is a new array, to which you can then apply another <strong class="source-inline">map()</strong> or <strong class="source-inline">filter()</strong> function, and so forth. We used these methods when we defined the <strong class="source-inline">range()</strong> function back in the <em class="italic">Working with ranges</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Programming Declaratively</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const range = (start: number, stop: number): number[] =&gt;
  new Array(stop - start).fill(0).map((v, i) =&gt; start + i);</pre>
			<p>First, we created a new array; then, we applied the <strong class="source-inline">fill()</strong> method to it, which updated the array in place (side effect) and returned the updated array, to which we finally applied a <strong class="source-inline">map()</strong> method. The latter method generated a new array, to which we could have applied further mapping, filtering, or any other <span class="No-Break">available method.</span></p>
			<p>Let’s take a look at a common example of fluent APIs, which work by chaining, and then consider how we can do this on <span class="No-Break">our own.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor157"/>An example of fluent APIs</h2>
			<p>This style of<a id="_idIndexMarker631"/> continuous chained operations is also used in fluent APIs or interfaces. To give just one example, the graphic <strong class="source-inline">D3.js</strong> library (see <a href="http://d3js.org">d3js.org</a> for more on it) frequently uses this style. The following example, taken from <a href="http://bl.ocks.org/mbostock/4063269">bl.ocks.org/mbostock/4063269</a>, shows it <span class="No-Break">in action:</span></p>
			<pre class="source-code">
var node = svg
  .selectAll(".node")
  .data(pack(root).leaves())
  .enter()
  .append("g")
  .attr("class", "node")
  .attr("transform", function (d) {
    return "translate(" + d.x + "," + d.y + ")";
  });
node
  .append("circle")
  .attr("id", function (d) {
    return d.id;
  })
  .attr("r", function (d) {
    return d.r;
  })
  .style("fill", function (d) {
    return color(d.package);
  });</pre>
			<p>Each method works on the previous object and provides access to a new object to which future method calls will be applied (such as the <strong class="source-inline">selectAll()</strong> or <strong class="source-inline">append()</strong> methods) or updates <a id="_idIndexMarker632"/>the current one (as the <strong class="source-inline">attr()</strong> attribute setting calls do). This style is not unique, and several other well-known libraries (jQuery comes to mind) also <span class="No-Break">apply it.</span></p>
			<p>Can we automate this? In this case, the answer is “possibly, but I’d rather not.” I think using <strong class="source-inline">pipeline()</strong> or <strong class="source-inline">compose()</strong> works just as well and achieves the same thing. With object chaining, you are limited to returning new objects or arrays or something that methods can be applied to. (Remember, if you are working with standard types, such as strings or numbers, you can’t add methods to them unless you mess with their prototype, which isn’t recommended!). With composition, however, you can return any value; the only restriction is that the next function in line must expect the data type <span class="No-Break">you provide.</span></p>
			<p>On the other hand, if you are writing your own API, you can provide a fluent interface by just having each method return <strong class="source-inline">this</strong>—unless it needs to return something else! If you were working with someone else’s API, you could also do some trickery by using a proxy. However, be aware that there may be cases in which your proxied code might fail: maybe another proxy is being used, or there are some getters or setters that somehow cause problems, and <span class="No-Break">so on.</span></p>
			<p class="callout-heading">On proxies</p>
			<p class="callout">You may want to read up on proxy objects at <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a> – they are very powerful and <a id="_idIndexMarker633"/>allow for interesting metaprogramming functionalities. Still, they can trap you with technicalities and will cause an (albeit slight) slowdown in your <span class="No-Break">proxied code.</span></p>
			<p>Let’s now look at how to chain calls so we can do this with <span class="No-Break">any class.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor158"/>Chaining method calls</h2>
			<p>Let’s go for a basic<a id="_idIndexMarker634"/> example. We have a <strong class="source-inline">City</strong> class with <strong class="source-inline">name</strong>, latitude (<strong class="source-inline">lat</strong>), and longitude (<span class="No-Break"><strong class="source-inline">long</strong></span><span class="No-Break">) attributes:</span></p>
			<pre class="source-code">
// chaining.ts
class City {
  name: string;
  lat: number;
  long: number;
  constructor(name: string, lat: number, long: number) {
    this.name = name;
    this.lat = lat;
    this.long = long;
  }
  getName() {
    return this.name;
  }
  setName(newName: string) {
    this.name = newName;
  }
  setLat(newLat: number) {
    this.lat = newLat;
  }
  setLong(newLong: number) {
    this.long = newLong;
  }
  getCoords() {
    return [this.lat, this.long];
  }
}</pre>
			<p>This is a common class with a few methods; everything’s quite normal. We could use this class as follows and provide details about my native city, <span class="No-Break">Montevideo, Uruguay:</span></p>
			<pre class="source-code">
const myCity = new City(
  "Montevideo, Uruguay",
  -34.9011,
  -56.1645
);
console.log(myCity.getCoords(), myCity.getName());
<strong class="bold">// [ -34.9011, -56.1645 ] 'Montevideo, Uruguay'</strong></pre>
			<p>If we wanted the setters to be handled in a fluent manner, we could set up a proxy to detect these calls and provide the missing <strong class="source-inline">return this</strong>. How can we do that? If the original method doesn’t return anything, JavaScript will include a <strong class="source-inline">return undefined</strong> statement by default so that we can detect whether that’s what the method returns and substitute <strong class="source-inline">return this</strong> instead. Of course, this is a problem: what would we do if we had a method that could legally return <strong class="source-inline">undefined</strong> because of its semantics? We could<a id="_idIndexMarker635"/> have some kind of exceptions list to tell our proxy not to add anything in those cases, but let’s not get <span class="No-Break">into that.</span></p>
			<p>The code for our handler is as follows. Whenever the method of an object is invoked, a <strong class="source-inline">get()</strong> is implicitly called, and we catch it. If we get a function, we wrap it with some code of our own that will call the original method and then decide whether to return its value or a reference to the proxied object instead. If we didn’t get a function, we would return the requested property’s value. Our <strong class="source-inline">chainify()</strong> function will take care of assigning the handler to an object and creating the <span class="No-Break">needed proxy:</span></p>
			<pre class="source-code">
// chainify.ts
const chainify = &lt;OBJ extends { [key: string]: any }&gt;(
  obj: OBJ
): Chainify&lt;OBJ&gt; =&gt;
  new Proxy(obj, {
    get(target, property, receiver) {
      if (typeof property === "string") {
        if (typeof target[property] === "function") {
          // requesting a method? return a wrapped version
          return (...args: any[]) =&gt; {
            const result = target[property](...args);
            return result === undefined ? receiver :
              result;
          };
        } else {
          // an attribute was requested - just return it
          return target[property];
        }
      } else {
        return Reflect.get(target, property, receiver);
      }
    },
  });</pre>
			<p>We must check whether the invoked <strong class="source-inline">get()</strong> was for a function or an attribute. In the first case, we wrap the <a id="_idIndexMarker636"/>method with extra code so that it will execute it and then return its results (if any) or a reference to the object itself. In the second case, we return the attribute, which is the expected behavior. (For the use of <strong class="source-inline">Reflect.get()</strong>, check <span class="No-Break">out </span><a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get</span></a><span class="No-Break">.)</span></p>
			<p>What’s the type of a “chainified” object? Any property that isn’t a function is the same. A property that is a function that returns some non-<strong class="source-inline">void</strong> value is also still the same. However, if a function returns <strong class="source-inline">void</strong>, we wrap it, so it returns the object itself. The <strong class="source-inline">Chainify&lt;&gt;</strong> type definition <span class="No-Break">does that:</span></p>
			<pre class="source-code">
// continued...
type Chainify&lt;A extends { [key: string]: any }&gt; = {
  [key in keyof A]: A[key] extends (...args: any[]) =&gt; any
    ? void extends ReturnType&lt;A[key]&gt;
      ? (...args: Parameters&lt;A[key]&gt;) =&gt; Chainify&lt;A&gt;
      : (...args: Parameters&lt;A[key]&gt;) =&gt; ReturnType&lt;A[key]&gt;
    : A[key];
};</pre>
			<p>With this, we can chainify any object so that we can inspect any called method. As I’m writing this, I’m currently living in Pune, India, so let’s reflect <span class="No-Break">that change:</span></p>
			<pre class="source-code">
const myCity2 = chainify(myCity);
console.log(
  myCity2
    .setName("Pune, India")
    .setLat(18.5626)
    .setLong(73.8087)
    .getCoords(),
  myCity.getName()
);
// [ 18.5626, 73.8087 ] 'Pune, India'</pre>
			<p>Notice <span class="No-Break">the following:</span></p>
			<ul>
				<li>The type of <strong class="source-inline">myCity2</strong> (which is chainified) is different from the type of <strong class="source-inline">myCity</strong>. For instance, <strong class="source-inline">myCity2.setLong()</strong> is now of the <strong class="source-inline">setLong(newLong: number): Chainify&lt;City&gt;</strong> type instead of <strong class="source-inline">setLong(newLong: number): void</strong> as before. (See <span class="No-Break"><em class="italic">Question 8.8</em></span><span class="No-Break">.)</span></li>
				<li>We call several setters in a fluent manner, and they are working fine since our proxy is taking care of providing the value for the <span class="No-Break">following call.</span></li>
				<li>The calls to <strong class="source-inline">getCoords()</strong> and <strong class="source-inline">getName()</strong> are intercepted, but nothing special is done because they already return <span class="No-Break">a value.</span></li>
			</ul>
			<p>Is working in a<a id="_idIndexMarker637"/> chained way worth it? That’s up to you—but remember that there may be cases in which this approach fails, so be wary! Now, let’s move on to composing, the other most common way of <span class="No-Break">joining functions.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor159"/>Composing</h1>
			<p><em class="italic">Composing</em> is quite similar to<a id="_idIndexMarker638"/> pipelining, but has its roots in mathematical theory. The concept of composition is a sequence of function calls in which the output of one function is the input for the next one—but in the opposite order to when pipelining. So, if you have a series of functions, from left to right, when pipelining, the first function of the series to be applied is the leftmost one, but when you use composition, you start with the <span class="No-Break">rightmost one.</span></p>
			<p>Let’s investigate this a bit more. When you define the composition of, say, three functions as (<strong class="source-inline">f</strong>∘<strong class="source-inline">g</strong>∘<strong class="source-inline">h</strong>) and apply this composition to <strong class="source-inline">x</strong>, this is equivalent to <span class="No-Break">writing </span><span class="No-Break"><strong class="source-inline">f(g(h(x)))</strong></span><span class="No-Break">.</span></p>
			<p>It’s important to note that, as with pipelining, the arity of the first function to be applied (actually the last one in the list) can be anything, but all the other functions must be unary. Also, besides the difference in the sequence of function evaluation, composing is an important tool in FP: it abstracts the implementation details (putting your focus on what you need to accomplish rather than on the specific details for achieving that), thereby letting you<a id="_idIndexMarker639"/> work in a more <span class="No-Break">declarative fashion.</span></p>
			<p class="callout-heading">Tip for reading</p>
			<p class="callout">If it helps, you can read (<em class="italic">f</em>∘<em class="italic">g</em>∘<em class="italic">h</em>) as “<em class="italic">f</em> after <em class="italic">g</em> after <em class="italic">h</em>” so that it becomes clear that <em class="italic">h</em> is the first function to be applied, while <em class="italic">f</em> is <span class="No-Break">the last.</span></p>
			<p>Given its similarity to pipelining, it will be no surprise that implementing composition isn’t very hard. However, there are still some important and interesting details. Let’s see some examples of composition before moving on to using higher-order functions and finishing with some considerations about testing <span class="No-Break">composed functions.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor160"/>Some examples of composition</h2>
			<p>It may not be a surprise to<a id="_idIndexMarker640"/> you, but we have already seen several examples of composition—or, at the very least, cases in which the solutions we achieved were functionally equivalent to using composition. Let’s review some of these and work with some new <span class="No-Break">examples too.</span></p>
			<h3>Unary operators</h3>
			<p>In the <em class="italic">Logically negating a function</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, we wrote a <strong class="source-inline">not()</strong> function that, given another function, would logically invert its result. We used that function to negate a check <a id="_idIndexMarker641"/>for negative balances; the sample code for this (and I’m going with plain JavaScript here, for clarity) could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const not = (fn) =&gt; (...args) =&gt; !fn(...args);
const positiveBalance = not(isNegativeBalance);</pre>
			<p>In another section (<em class="italic">Turning operations into functions</em>) of that chapter, I left you with the challenge of writing a <strong class="source-inline">unaryOp()</strong> function that would provide unary functions equivalent to common JavaScript operators. If you met that challenge, you should be able to write <a id="_idIndexMarker642"/>something such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const logicalNot = unaryOp("!");</pre>
			<p>Assuming the existence of a <strong class="source-inline">compose()</strong> function, you could have also written <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const positiveBalance = <strong class="bold">compose(</strong>
<strong class="bold">  logicalNot,</strong>
<strong class="bold">  isNegativeBalance</strong>
<strong class="bold">)</strong>;</pre>
			<p>Which one do you prefer? It’s a matter of taste—but I think the second version clarifies what we are trying to do better. With the <strong class="source-inline">not()</strong> function, you must check what it does to understand the general code. With composition, you still need to know what <strong class="source-inline">logicalNot()</strong> is, but the global construct is open <span class="No-Break">to see.</span></p>
			<p>To look at just one more example in the same vein, you could have achieved the same results that we got in the <em class="italic">Inverting the results</em> section in the same chapter. Recall that we had a function that could compare strings according to the rules of Spanish, but we wanted to invert the result of the comparison so that it was sorted in <span class="No-Break">descending order:</span></p>
			<pre class="source-code">
const changeSign = unaryOp("-");
palabras.sort(<strong class="bold">compose(changeSign, spanishComparison)</strong>);</pre>
			<p>This code produces the same result that our previous sorting problem did, but the logic is expressed more clearly and with less code: a typical FP result! Let’s look at some more examples of composing functions by reviewing another task we <span class="No-Break">discussed earlier.</span></p>
			<h3>Counting files</h3>
			<p>We can also go back to our <a id="_idIndexMarker643"/>pipeline. We wrote a single-line function to count the <strong class="source-inline">odt</strong> files in a <span class="No-Break">given path:</span></p>
			<pre class="source-code">
const countOdtFiles2 = (path: string): number =&gt;
  <strong class="bold">count(filterOdt(getDir(path)))</strong>;</pre>
			<p>Disregarding (at least for the moment) the observation that this code is not as clear as the pipeline version that we developed later, we could have also written this function <span class="No-Break">with composition:</span></p>
			<pre class="source-code">
const countOdtFiles2b = (path: string): number =&gt;
  <strong class="bold">compose(count, filterOdt, getDir)(path)</strong>;
countOdtFiles2b("/home/fkereki/Documents");
// 4, no change here</pre>
			<p>We may also see this written in a <span class="No-Break">one-liner fashion:</span></p>
			<pre class="source-code">
compose(count, filterOdt, getDir)("/home/fkereki/Documents");</pre>
			<p>Even if it’s not as clear as the pipeline version (and that’s just my opinion, which may be biased due to my liking of Linux!), this declarative implementation makes it clear that we depend on combining three distinct functions to get our result—this is easy to see and applies the idea <a id="_idIndexMarker644"/>of building large solutions out of simpler pieces <span class="No-Break">of code.</span></p>
			<p>Let’s take a look at another example that’s designed to compose as many functions <span class="No-Break">as possible.</span></p>
			<h3>Finding unique words</h3>
			<p>Finally, let’s go for another<a id="_idIndexMarker645"/> example, which, I agree, could have also been used for pipelining. Suppose you have some text and want to extract all the unique words from it: how would you go about doing so? If you think about it in steps (instead of trying to create a full solution in one go), you would probably come up with a solution similar <span class="No-Break">to this:</span></p>
			<ol>
				<li>Ignore all <span class="No-Break">non-alphabetic characters.</span></li>
				<li>Put everything <span class="No-Break">in uppercase.</span></li>
				<li>Split the text <span class="No-Break">into words.</span></li>
				<li>Create a set <span class="No-Break">of words.</span></li>
			</ol>
			<p>(Why a set? Because it <a id="_idIndexMarker646"/>automatically discards repeated values; check out <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set</a> for more on this. By the way, we will use the <strong class="source-inline">Array.from()</strong> method to produce an array out of our set; see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from</a> for more <span class="No-Break">on this.)</span></p>
			<p>Now, using FP, let’s solve <span class="No-Break">each problem:</span></p>
			<pre class="source-code">
const removeNonAlpha = (str: string): string =&gt;
  str.replace(/[^a-z]/gi, " ");
const toUpperCase = demethodize(
  String.prototype.toUpperCase
);
const splitInWords = (str: string): string[] =&gt;
  str.trim().split(/\s+/);
const arrayToSet = (arr: string[]): Set&lt;string&gt; =&gt;
  new Set(arr);
const setToList = (set: Set&lt;string&gt;): string[] =&gt;
  Array.from(set).sort();</pre>
			<p>With these functions, the result <a id="_idIndexMarker647"/>can be written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const getUniqueWords = <strong class="bold">compose</strong>(
  setToList,
  arrayToSet,
  splitInWords,
  toUpperCase,
  removeNonAlpha
);</pre>
			<p>Since you don’t get to see the arguments of any of the composed functions, you don’t need to show the parameter for <strong class="source-inline">getUniqueWords()</strong> either, so the pointfree style is natural in <span class="No-Break">this case.</span></p>
			<p>Now, let’s test our function. To do this, let’s apply this function to the first two sentences of <a id="_idIndexMarker648"/>Abraham Lincoln’s address at Gettysburg (which we already used in an example back in the <em class="italic">Mapping and flattening – flatMap</em> section of <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Programming Declaratively</em>) and print out the 43 different words (trust me, I counted them!) <span class="No-Break">in it:</span></p>
			<pre class="source-code">
const GETTYSBURG_1_2 = `Four score and seven years ago
our fathers brought forth on this continent, a new nation, conceived in liberty, and dedicated to the proposition that all men are created equal. Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long
endure.`;
console.log(getUniqueWords(GETTYSBURG_1_2));
// Output: 43 words, namely
  'A',           'AGO',       'ALL',
  'AND',         'ANY',       'ARE',
  'BROUGHT',     'CAN',       'CIVIL',
  'CONCEIVED',   'CONTINENT', 'CREATED',
  'DEDICATED',   'ENDURE',    'ENGAGED',
  'EQUAL',       'FATHERS',   'FORTH',
  'FOUR',        'GREAT',     'IN',
  'LIBERTY',     'LONG',      'MEN',
  'NATION',      'NEW',       'NOW',
  'ON',          'OR',        'OUR',
  'PROPOSITION', 'SCORE',     'SEVEN',
  'SO',          'TESTING',   'THAT',
  'THE',         'THIS',      'TO',
  'WAR',         'WE',        'WHETHER',
  'YEARS'</pre>
			<p>Of course, you could have written <strong class="source-inline">getUniqueWords()</strong> more succinctly, but the point I’m making is that by composing your solution out of several shorter steps, your code is clearer and easier to grasp. However, if you wish to say that a pipelined solution seems better, it’s just a matter <span class="No-Break">of opinion!</span></p>
			<p>We have looked at<a id="_idIndexMarker649"/> many examples of function composition at this point, but there’s another way to manage this—by using <span class="No-Break">higher-order functions.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor161"/>Composing with higher-order functions</h2>
			<p>Evidently, composing by<a id="_idIndexMarker650"/> hand can be done similarly to pipelining. For example, the unique word-counting function that we wrote previously could be written in simple <span class="No-Break">JavaScript style:</span></p>
			<pre class="source-code">
const getUniqueWords1 = (str: string): string[] =&gt; {
  const str1 = removeNonAlpha(str);
  const str2 = toUpperCase(str1);
  const arr1 = splitInWords(str2);
  const set1 = arrayToSet(arr1);
  const arr2 = setToList(set1);
  return arr2;
};
console.log(getUniqueWords1(GETTYSBURG_1_2));
// Output: the same 43 words</pre>
			<p>Alternatively, it could be<a id="_idIndexMarker651"/> written more concisely (but more obscurely!) in a <span class="No-Break">one-liner style:</span></p>
			<pre class="source-code">
const getUniqueWords2 = (str: string): string[] =&gt;
  setToList(
    arrayToSet(
      splitInWords(toUpperCase(removeNonAlpha(str)))
    )
  );
console.log(getUniqueWords2(GETTYSBURG_1_2));
// Output: the same 43 words</pre>
			<p>This works fine, but as when we studied pipelining, let’s look for a more general solution that won’t require writing a new particular function every time we want to compose some <span class="No-Break">other functions.</span></p>
			<p>Composing two functions is relatively easy and requires making a small change to our <strong class="source-inline">pipeTwo()</strong> function, which we looked at earlier in this chapter. We just have to exchange <strong class="source-inline">f</strong> and <strong class="source-inline">g</strong> to get the <span class="No-Break">new definition!</span></p>
			<pre class="source-code">
// compose.ts
const pipeTwo =
  &lt;F extends FN, G extends FN&gt;(f: F, g: G) =&gt;
  <strong class="bold">(...args: Parameters&lt;F&gt;): ReturnType&lt;G&gt; =&gt;</strong>
    <strong class="bold">g(f(...args))</strong>;
const composeTwo =
  &lt;F extends FN, G extends FN&gt;(f: F, g: G) =&gt;
  <strong class="bold">(...args: Parameters&lt;G&gt;): ReturnType&lt;F&gt; =&gt;</strong>
    <strong class="bold">f(g(...args))</strong>;</pre>
			<p>The only difference is that, with piping, you apply the leftmost function first, while with composing, you start with the rightmost function first. This variation suggests that we could have used the <strong class="source-inline">flipTwo()</strong> higher-order function from the <em class="italic">Parameter order</em> section of <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><em class="italic">, Transforming Functions</em>. Is it clearer? Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
// continued...
const composeTwoByFlipping = flipTwo(pipeTwo);</pre>
			<p>In any case, if we <a id="_idIndexMarker652"/>want to compose more than two functions, we can take advantage of the associative property and write something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const getUniqueWords3 = composeTwo(
  setToList,
  <strong class="bold">composeTwo</strong>(
    arrayToSet,
    <strong class="bold">composeTwo</strong>(
      splitInWords,
      <strong class="bold">composeTwo</strong>(toUpperCase, removeNonAlpha)
    )
  )
);</pre>
			<p>Even though this works, let’s go for a better solution—we can provide several. We could use a loop like when we wrote our first <span class="No-Break">pipelining function:</span></p>
			<pre class="source-code">
// continued...
function compose(...fns) {
  return (...args) =&gt; {
    let result = fns[fns.length - 1](...args);
    for (let i = fns.length - 2; i &gt;= 0; i--) {
      result = fns[i](result);
    }
    return result;
  };
}
console.log(
  <strong class="bold">compose(</strong>
    setToList,
    arrayToSet,
    splitInWords,
    toUpperCase,
    removeNonAlpha
  <strong class="bold">)(GETTYSBURG_1_2)</strong>
);
// same output as earlier</pre>
			<p>We could also note that pipelining and composing work in opposite directions. We apply functions from left to right when pipelining, and from right to left when composing. Thus, we can achieve the same result we achieved with composition by reversing the order of the functions and doing pipelining instead; a very functional solution, which I really like! This is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
function compose1(...fns) {
  return pipeline(...fns.reverse());
}</pre>
			<p>The only tricky part is<a id="_idIndexMarker653"/> the usage of the spread operator before calling <strong class="source-inline">pipeline()</strong>. After reversing the <strong class="source-inline">fns</strong> array, we must spread its elements to call <span class="No-Break"><strong class="source-inline">pipeline()</strong></span><span class="No-Break"> correctly.</span></p>
			<p>Yet another solution, less declarative, is to use <strong class="source-inline">reduceRight()</strong> so that instead of reversing the list of functions, we reverse the order of <span class="No-Break">processing them:</span></p>
			<pre class="source-code">
// continued...
function compose2(...fns) {
  return fns.reduceRight(
    <strong class="bold">(f, g) =&gt; (...args) =&gt; g(f(...args))</strong>
  );
}
console.log(
  <strong class="bold">compose2(</strong>
    setToList,
    arrayToSet,
    splitInWords,
    toUpperCase,
    removeNonAlpha
  <strong class="bold">)(GETTYSBURG_1_2)</strong>
);
// still same output</pre>
			<p>Why and how <a id="_idIndexMarker654"/>does this work? Let’s look at the inner workings of <span class="No-Break">this call:</span></p>
			<ul>
				<li>Since no initial value is provided, <strong class="source-inline">f()</strong> is <strong class="source-inline">removeNonAlpha()</strong> and <strong class="source-inline">g()</strong> is <strong class="source-inline">toUpperCase()</strong>, so the first intermediate result is a function, <strong class="source-inline">(...args) =&gt; toUpperCase(removeNonAlpha(...args))</strong>; let’s call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">step1()</strong></span><span class="No-Break">.</span></li>
				<li>The second time, <strong class="source-inline">f()</strong> is <strong class="source-inline">step1()</strong> from the previous step, while <strong class="source-inline">g()</strong> is <strong class="source-inline">splitInWords()</strong>, so the new result is a function, <strong class="source-inline">(...args) =&gt; splitInWords(step1(...args)))</strong>, which we can <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">step2()</strong></span><span class="No-Break">.</span></li>
				<li>The third time around, in the same fashion, we get <strong class="source-inline">(...args) =&gt; arrayToSet(step2(...args))))</strong>, which we <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">step3()</strong></span><span class="No-Break">.</span></li>
				<li>Finally, the result is <strong class="source-inline">(...args) =&gt; setToList(step3(...args))</strong>, a function; let’s call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">step4()</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The final result turns out to be a function that receives <strong class="source-inline">(...args)</strong> and starts by applying <strong class="source-inline">removeNonAlpha()</strong> to it, then <strong class="source-inline">toUpperCase()</strong>, and so on, before finishing by <span class="No-Break">applying </span><span class="No-Break"><strong class="source-inline">setToList()</strong></span><span class="No-Break">.</span></p>
			<p>It may come as a surprise that we can also make this work with <strong class="source-inline">reduce()</strong>—can you see why? The reasoning is similar to what we did previously, so we’ll leave this as an exercise <span class="No-Break">for you:</span></p>
			<pre class="source-code">
// continued...
function compose3(...fns) {
  return <strong class="bold">fns.reduceRight(pipeTwo)</strong>;
}</pre>
			<p class="callout-heading">A symmetric challenge!</p>
			<p class="callout">After working out how <strong class="source-inline">compose3()</strong> works, you might want to write a version of <strong class="source-inline">pipeline()</strong> that uses <strong class="source-inline">reduceRight()</strong>, just for symmetry, to round <span class="No-Break">things out!</span></p>
			<h3>Data typing for composition</h3>
			<p>Given what we did for pipelining, data<a id="_idIndexMarker655"/> typing for composition is very much the same, and we’ll follow what we did in parallel. First, we’ll have an auxiliary type to check whether our functions’ types can be <span class="No-Break">composed correctly:</span></p>
			<pre class="source-code">
// compose.ts
type FnsMatchComp&lt;FNS extends FN[]&gt; =
  1 extends FNS["length"]
    ? boolean
    : FNS extends [
        ...infer FNInit extends FN[],
        infer FNPrev extends FN,
        infer FNLast extends FN
      ]
    ? Parameters&lt;FNPrev&gt; extends [ReturnType&lt;FNLast&gt;]
      ? FnsMatchComp&lt;[...FNInit, FNPrev]&gt;
      : never
    : never;</pre>
			<p>This is essentially the same as what we wrote for pipelining, except that we process functions from right to left. With this done, we can now write our <span class="No-Break"><strong class="source-inline">Compose&lt;&gt;</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
// continued...
type Compose&lt;FNS extends FN[]&gt; =
  boolean extends FnsMatchComp&lt;FNS&gt;
    ? 1 extends FNS["length"]
      ? FNS[0]
      : FNS extends [
          infer FNFIRST extends FN,
          ...FN[],
          infer FNLAST extends FN
        ]
      ? <strong class="bold">(...args: Parameters&lt;FNLAST&gt;) =&gt;</strong>
<strong class="bold">        ReturnType&lt;FNFIRST&gt;</strong>
      : never
    : never;</pre>
			<p>This is also what we had for pipelining, except for the type of the result, which is symmetrical. Finally, we can <a id="_idIndexMarker656"/>apply types to our composing functions; let’s see just one example, because (logically!) typing is the same for all the versions of <span class="No-Break">our code!</span></p>
			<pre class="source-code">
function compose<strong class="bold">&lt;FNS extends FN[]&gt;</strong>(
  ...fns<strong class="bold">: FNS</strong>
)<strong class="bold">: Compose&lt;FNS&gt;</strong>;
function compose&lt;FNS extends FN[]&gt;(...fns: FNS): FN {
  return (...args: Parameters&lt;FNS[0]&gt;) =&gt; {
    let result = fns[fns.length - 1](...args);
    for (let i = fns.length - 2; i &gt;= 0; i--) {
      result = fns[i](result);
    }
    return result;
  };
}</pre>
			<p>So far, we have looked at the important methods we can use to connect functions using pipelining, chaining, and composition. All this works very well, but we’ll see that there’s a particular case in which the performance of your code can be affected and that will require a new way to handle <span class="No-Break">composition: </span><span class="No-Break"><em class="italic">transducing</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor162"/>Transducing</h1>
			<p>Let’s consider a performance problem in JavaScript that happens when we’re dealing with large arrays and applying several <strong class="source-inline">map()</strong>, <strong class="source-inline">filter()</strong>, or <strong class="source-inline">reduce()</strong> operations. If you start with an array and <a id="_idIndexMarker657"/>apply these operations (via chaining, as we saw earlier in this chapter), you get the desired result. However, many intermediate arrays are created, processed, and discarded—and that causes delays. If you are dealing with small arrays, the extra time won’t make an impact, but with larger arrays (as in a big data process, maybe in Node.js, where you’re working with the results of a large database query), then you will probably have to need some optimization. We’ll do this by learning about a new tool for composing <span class="No-Break">functions: </span><span class="No-Break"><em class="italic">transducing</em></span><span class="No-Break">.</span></p>
			<p>First, let’s create some functions and data. We’ll make do with a nonsensical example since we aren’t focusing on the actual operations but on the general process. We’ll start with some filtering<a id="_idIndexMarker658"/> functions and <span class="No-Break">some mapping:</span></p>
			<pre class="source-code">
// transducing.ts
const testOdd = (x: number): boolean =&gt; x % 2 === 1;
const testUnderFifty = (x: number): boolean =&gt; x &lt; 50;
const duplicate = (x: number): number =&gt; x + x;
const addThree = (x: number): number =&gt; x + 3;</pre>
			<p>Now, let’s apply those maps and filters to an array. First, we drop the even numbers, duplicate the odd numbers, drop results over 50, and end by adding 3 to all <span class="No-Break">the results:</span></p>
			<pre class="source-code">
// continued...
const myArray = [22, 9, 60, 24, 11, 63];
const a0 = myArray
  .filter(testOdd)
  .map(duplicate)
  .filter(testUnderFifty)
  .map(addThree);
console.log(a0);
<strong class="bold">// Output: [ 21, 25 ]</strong></pre>
			<p>The following diagram shows how this sequence of <span class="No-Break">operations works:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_8.3_B19301.jpg" alt="Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays to be created and later discarded"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays to be created and later discarded</p>
			<p>Here, we can see that chaining together several <strong class="source-inline">map()</strong>, <strong class="source-inline">filter()</strong>, and <strong class="source-inline">reduce()</strong> operations causes intermediate arrays (three, in this case) to be created and later discarded—and for large arrays, that can <span class="No-Break">become cumbersome.</span></p>
			<p>How can we optimize this? The problem here is that processing applies the first transformation to<a id="_idIndexMarker659"/> the input array; then, the second transformation is applied to the resulting array; then the third, and so on. An alternative solution would be to take the first element of the input array and apply all the transformations in sequence to it. Then, you would need to take the second element of the input array and apply all the transformations to it, then take the third, and so on. In pseudocode, the difference is <span class="No-Break">between this:</span></p>
			<pre class="source-code">
for each transformation to be applied:
    for each element in the input list:
        apply the transformation to the element</pre>
			<p>And then <span class="No-Break">this approach:</span></p>
			<pre class="source-code">
for each element in the input list:
    for each transformation to be applied:
        apply the transformation to the element</pre>
			<p>With the first logic, we go transformation by transformation, applying it to each list and generating a new one. This requires several intermediate lists to be produced. With the second logic, we go element by element and apply all the transformations to each one in sequence to arrive at the final output list without any intermediate lists <span class="No-Break">being created.</span></p>
			<p>Now, the problem is being able to transpose the transformations; how can we do this? We saw this key concept in <a href="B19301_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Programming Declaratively</em>, and we can define <strong class="source-inline">map()</strong> and <strong class="source-inline">filter()</strong> in terms of <strong class="source-inline">reduce()</strong>. Using those definitions, instead of a sequence of different functions, we will apply the same operation (<strong class="source-inline">reduce()</strong>) at each<a id="_idIndexMarker660"/> step, and here is the secret! As shown in the following diagram, we change the order of evaluation by composing all the transformations so that they can be applied in a single pass with no intermediate <span class="No-Break">arrays whatsoever:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_8.4_B19301.jpg" alt="Figure 8.4 – By applying transducers, we will change the order of evaluation but get the same result"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – By applying transducers, we will change the order of evaluation but get the same result</p>
			<p>Instead of applying a first <strong class="source-inline">reduce()</strong> operation, passing its result to a second, its result to a third, and so on, we will compose all the reducing functions into a single one! Let’s <span class="No-Break">analyze this.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/>Composing reducers</h2>
			<p>Essentially, what we want is to transform each function (<strong class="source-inline">testOdd()</strong>, <strong class="source-inline">duplicate()</strong>, and so on) into a reducing <a id="_idIndexMarker661"/>operation that will call the following reducer. A couple of higher-order functions will help; one for mapping functions and another for filtering ones. With this idea, the result of an operation will be passed to the next one, avoiding <span class="No-Break">intermediate arrays:</span></p>
			<pre class="source-code">
// continued...
const mapTR =
  &lt;V, W&gt;(fn: (x: V) =&gt; W) =&gt;
  &lt;A&gt;(reducer: (am: A, wm: W) =&gt; A) =&gt;
  (accum: A, value: V): A =&gt;
    reducer(accum, fn(value));
const filterTR =
  &lt;V&gt;(fn: (x: V) =&gt; boolean) =&gt;
  &lt;A&gt;(reducer: (af: A, wf: V) =&gt; A) =&gt;
  (accum: A, value: V): A =&gt;
    fn(value) ? reducer(accum, value) : accum;</pre>
			<p>These two transforming functions are <em class="italic">transducers</em>: functions that accept a reducing function and return a new reducing function. (Some trivia: the word <em class="italic">transduce</em> comes from Latin, meaning transform, transport, convert, change over, and is applied in many different fields, including biology, psychology, machine learning, physics, electronics, <span class="No-Break">and more.)</span></p>
			<p>Typing is not too hard. For mapping, we assume a mapping function that gets a value of type <strong class="source-inline">V</strong> and produces a result of type <strong class="source-inline">W</strong>. The generic reducer takes an accumulator of type <strong class="source-inline">A</strong> and a value of type <strong class="source-inline">W</strong> and produces a new accumulator, also of type <strong class="source-inline">A</strong>. For filtering, the filtering function gets a value of type <strong class="source-inline">V</strong> and produces a <strong class="source-inline">Boolean</strong> value, and the reducer gets an accumulator of type <strong class="source-inline">A</strong> and a value of type <strong class="source-inline">V</strong>, returning a type <span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break"> result.</span></p>
			<p>How do we use these transducers? We can write code such as the following, although we’ll want a more abstract, generic <span class="No-Break">version later:</span></p>
			<pre class="source-code">
// continued...
const testOddR = filterTR(testOdd);
const testUnderFiftyR = filterTR(testUnderFifty);
const duplicateR = mapTR(duplicate);
const addThreeR = mapTR(addThree);</pre>
			<p>Each of our original four functions is transformed, so they will calculate their result and call a reducer to deal with this further. As an example, <strong class="source-inline">addThreeR()</strong> will add three to its input and pass the<a id="_idIndexMarker662"/> incremented value to the next reducer, which in this case <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">addToArray()</strong></span><span class="No-Break">.</span></p>
			<p>This will build up the final resulting array. Now, we can write our whole transformation in a <span class="No-Break">single step:</span></p>
			<pre class="source-code">
// continued...
const addToArray = (a: any[], v: any): any[] =&gt; {
  a.push(v);
  return a;
};
const a1 = myArray.reduce(
<strong class="bold">  testOddR(</strong>
<strong class="bold">    duplicateR(testUnderFiftyR(addThreeR(addToArray)))</strong>
<strong class="bold">  )</strong>,
  []
);
console.log(a1);
<strong class="bold">// Output: [ 21, 25 ], again</strong></pre>
			<p>This is quite a mouthful, but it works! However, we can simplify our code by using the <span class="No-Break"><strong class="source-inline">compose()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
// continued...
const transduce = &lt;A&gt;(arr: A[], fns: FN[]) =&gt;
  <strong class="bold">arr.reduce(compose(...fns)(addToArray), [])</strong>;
console.log(
  transduce(myArray, [
    testOddR,
    duplicateR,
    testUnderFiftyR,
    addThreeR,
  ])
);
<strong class="bold">// Output: [ 21, 25 ], yet again</strong></pre>
			<p>The code is the same, but pay particular attention to the <strong class="source-inline">compose(...fns)(addToArray)</strong> expression: we compose all the mapping and filtering functions—with the last one being <strong class="source-inline">addToArray</strong>—to build up the output. However, this is not <a id="_idIndexMarker663"/>as general as we may want it to be: why do we have to create an array? Why can’t we have a different final reducing function? We can go one better by generalizing a <span class="No-Break">bit more.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor164"/>Generalizing for all reducers</h2>
			<p>To be able to work with<a id="_idIndexMarker664"/> all kinds of reducers and produce whatever kind of result they build, we’ll need to make a small change. The idea is simple: let’s modify our <strong class="source-inline">transduce()</strong> function so that it will accept a final reducer and a starting value for <span class="No-Break">the accumulator:</span></p>
			<pre class="source-code">
// continued...
const transduce2 = &lt;A&gt;(
  arr: A[],
  fns: FN[],
<strong class="bold">  reducer: FN = addToArray,</strong>
<strong class="bold">  initial: any = []</strong>
) =&gt; arr.reduce(compose(...fns)(<strong class="bold">reducer</strong>), <strong class="bold">initial</strong>);
console.log(
  transduce2(myArray, [
    testOddR,
    duplicateR,
    testUnderFiftyR,
    addThreeR,
  ])
);
<strong class="bold">// Output: [ 21, 25 ], always</strong></pre>
			<p>To make this function more usable, we specified our array-building function (and an empty array as a starting accumulator value) so that if you skip those two parameters, you’ll get a reducer that produces an array. Now, let’s look at the other option: instead of an array, let’s<a id="_idIndexMarker665"/> calculate the sum of the resulting numbers after all the mapping <span class="No-Break">and filtering:</span></p>
			<pre class="source-code">
// continued...
console.log(
  transduce2(
    myArray,
    [testOddR, duplicateR, testUnderFiftyR, addThreeR],
   <strong class="bold"> (acc, value) =&gt; acc + value</strong>,
   <strong class="bold"> 0</strong>
  )
);
<strong class="bold">// 46</strong></pre>
			<p>By using transducers, we have been able to optimize a sequence of <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">reduce</strong> operations so that the input array is processed once and directly produces the output result (whether an array or a single value) without creating any intermediate arrays; a <span class="No-Break">good gain!</span></p>
			<p>We’ve seen several ways of connecting functions; to round this off, let’s see how to write unit tests for <span class="No-Break">connected functions.</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor165"/>Testing connected functions</h1>
			<p>Let’s finish by considering testing for functions connected in all the ways we’ve seen in this chapter. Given that the<a id="_idIndexMarker666"/> mechanisms for pipelining and composition are similar, we will look at examples of both. They won’t differ, other than their logical differences due to the left-to-right or right-to-left order of <span class="No-Break">function evaluation.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor166"/>Testing pipelined functions</h2>
			<p>When it comes to <a id="_idIndexMarker667"/>pipelining, we can start by looking at how to test the <strong class="source-inline">pipeTwo()</strong> function since the setup will be similar to <strong class="source-inline">pipeline()</strong>. We need to create some mocks and check whether they were called the correct number of times and whether they received the correct arguments each time. We will set them to provide a known answer to <span class="No-Break">a call.</span></p>
			<p>By doing this, we can check whether the output of a function becomes the input of the next function in <span class="No-Break">the pipeline:</span></p>
			<pre class="source-code">
// pipetwo.test.ts
describe("pipeTwo", function () {
  it("works with single arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(1);
    const fn2 = jest.fn().mockReturnValue(2);
    const pipe = pipeTwo(fn1, fn2);
    const result = pipe(22);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(22);
    expect(fn2).toHaveBeenCalledWith(1);
    expect(result).toBe(2);
  });
  it("works with multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(11);
    const fn2 = jest.fn().mockReturnValue(22);
    const pipe = pipeTwo(fn1, fn2);
    const result = pipe(12, 4, 56);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(12, 4, 56);
    expect(fn2).toHaveBeenCalledWith(11);
    expect(result).toBe(22);
  });
});</pre>
			<p>There is little to test given that our function always receives two functions as parameters. The only<a id="_idIndexMarker668"/> difference between the tests is that one shows a pipeline applied to a single argument, while the other shows it applied to <span class="No-Break">several arguments.</span></p>
			<p>Moving on to <strong class="source-inline">pipeline()</strong>, the tests would be quite similar. However, we can add a test for a single-function pipeline (a border case!) and another with <span class="No-Break">four functions:</span></p>
			<pre class="source-code">
// pipeline.test.ts
describe("pipeline", function () {
  it("works with a single function", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(11);
    const pipe = pipeline(fn1);
    const result = pipe(60);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(60);
    expect(result).toBe(11);
  });
  it("works with single arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(1);
    const fn2 = jest.fn().mockReturnValue(2);
    const pipe = pipeline(fn1, fn2);
    const result = pipe(22);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(22);
    expect(fn2).toHaveBeenCalledWith(1);
    expect(result).toBe(2);
  });
  it("works with multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(11);
    const fn2 = jest.fn().mockReturnValue(22);
    const pipe = pipeline(fn1, fn2);
    const result = pipe(12, 4, 56);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(12, 4, 56);
    expect(fn2).toHaveBeenCalledWith(11);
    expect(result).toBe(22);
  });
  it("works with 4 functions, multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(111);
    const fn2 = jest.fn().mockReturnValue(222);
    const fn3 = jest.fn().mockReturnValue(333);
    const fn4 = jest.fn().mockReturnValue(444);
    const pipe = pipeline(fn1, fn2, fn3, fn4);
    const result = pipe(24, 11, 63);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn3).toHaveBeenCalledTimes(1);
    expect(fn4).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(24, 11, 63);
    expect(fn2).toHaveBeenCalledWith(111);
    expect(fn3).toHaveBeenCalledWith(222);
    expect(fn4).toHaveBeenCalledWith(333);
    expect(result).toBe(444);
  });
});</pre>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor167"/>Testing composed functions</h2>
			<p>For composition, the style is the same (except that the order of function evaluation is reversed), so let’s take a<a id="_idIndexMarker669"/> look at a single test—here, I simply changed the order of the functions in the <span class="No-Break">preceding test:</span></p>
			<pre class="source-code">
// compose.test.ts
describe("compose", function () {
  // other tests, omitted here
  it("works with 4 functions, multiple arguments", () =&gt; {
    const fn1 = jest.fn().mockReturnValue(111);
    const fn2 = jest.fn().mockReturnValue(222);
    const fn3 = jest.fn().mockReturnValue(333);
    const fn4 = jest.fn().mockReturnValue(444);
    const comp = <strong class="bold">compose(fn4, fn3, fn2, fn1)</strong>;
    const result = comp(24, 11, 63);
    expect(fn1).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
    expect(fn3).toHaveBeenCalledTimes(1);
    expect(fn4).toHaveBeenCalledTimes(1);
    expect(fn1).toHaveBeenCalledWith(24, 11, 63);
    expect(fn2).toHaveBeenCalledWith(111);
    expect(fn3).toHaveBeenCalledWith(222);
    expect(fn4).toHaveBeenCalledWith(333);
    expect(result).toBe(444);
  });
});</pre>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>Testing chained functions</h2>
			<p>To test the <strong class="source-inline">chainify()</strong> function, I opted to use the preceding <strong class="source-inline">City</strong> object I created—I didn’t want to mess with<a id="_idIndexMarker670"/> mocks, stubs, spies, and the like; I wanted to ensure that the code worked under <span class="No-Break">normal conditions:</span></p>
			<pre class="source-code">
// chaining.test.ts
class City {
// as above
}
let myCity: City;
let myCity2: Chainify&lt;City&gt;;
describe("chainify", function () {
  beforeEach(() =&gt; {
    myCity = new City(
      "Montevideo, Uruguay",
      -34.9011,
      -56.1645
    );
    myCity2 = chainify(myCity);
  });
  it("doesn't affect get functions", () =&gt; {
    expect(myCity2.getName()).toBe("Montevideo, Uruguay");
    expect(myCity2.getCoords()[0]).toBe(-34.9011);
    expect(myCity2.getCoords()[1]).toBe(-56.1645);
  });
  it("doesn't affect getting attributes", () =&gt; {
    expect(myCity2.name).toBe("Montevideo, Uruguay");
    expect(myCity2.lat).toBe(-34.9011);
    expect(myCity2.long).toBe(-56.1645);
  });
  it("returns itself from setting functions", () =&gt; {
    //    expect(myCity2.setName("Other
      name")).toBe(myCity2);
    expect(myCity2.setLat(11)).toBe(myCity2);
    expect(myCity2.setLong(22)).toBe(myCity2);
  });
  it("allows chaining", () =&gt; {
    const newCoords = myCity2
      .setName("Pune, India")
      .setLat(18.5626)
      .setLong(73.8087)
      .getCoords();
    expect(myCity2.name).toBe("Pune, India");
    expect(newCoords[0]).toBe(18.5626);
    expect(newCoords[1]).toBe(73.8087);
  });
});</pre>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor169"/>Testing transduced functions</h2>
			<p>We tried several examples <a id="_idIndexMarker671"/>earlier in the chapter, and it’s easy to turn them into tests. We’ll also add new tests for border cases (for instance, just one function, only mapping functions, etc.) for more generality. For simplicity, I kept using the same data array and mapping and filtering functions I <span class="No-Break">used before:</span></p>
			<pre class="source-code">
// transducing.test.ts
describe("transducing", () =&gt; {
  it("works with several functions", () =&gt; {
    expect(
      transduce(myArray, [
        testOddR,
        duplicateR,
        testUnderFiftyR,
        addThreeR,
      ])
    ).toEqual([21, 25]);
  });
  it("works with just one function at all", () =&gt; {
    expect(transduce(myArray, [testOddR])).toEqual([
      9, 11, 63,
    ]);
    expect(transduce(myArray, [addThreeR])).toEqual([
      25, 12, 63, 27, 14, 66,
    ]);
  });
  it("works with just mapping", () =&gt; {
    expect(
      transduce(myArray, [addThreeR, duplicateR])
    ).toEqual([50, 24, 126, 54, 28, 132]);
  });
  it("works with just filtering", () =&gt; {
    expect(
      transduce(myArray, [testOddR, testUnderFiftyR])
    ).toEqual([9, 11]);
  });
  it("works with special reducer", () =&gt; {
    expect(
      transduce2(
        myArray,
        [testOddR, duplicateR, testUnderFiftyR, addThreeR],
        (acc, value) =&gt; acc + value,
        0
      )
    ).toBe(46);
  });
});</pre>
			<p>The final result of all of these tests can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_8.5_B19301.jpg" alt="Figure 8.5 – A successful run of testing for connected functions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – A successful run of testing for connected functions</p>
			<p>As we can see, all our<a id="_idIndexMarker672"/> tests passed <span class="No-Break">successfully; good!</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we learned how to create new functions by joining several other functions in different ways using pipelining and composition. We also looked at fluent interfaces, which apply chaining, and transducing, a way to compose reducers to get higher-speed sequences of transformations. With these methods, you’ll be able to create new functions out of existing ones and keep programming in the declarative way <span class="No-Break">we favor.</span></p>
			<p>In <a href="B19301_09.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Designing Functions</em>, we will move on to function design and study the usage of recursion, which is a basic tool in FP and allows for very clean <span class="No-Break">algorithm designs.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor171"/>Questions</h1>
			<p>8.1 <strong class="bold">Headline capitalization</strong>: Let’s define headline-style capitalization, so ensure that a sentence is all written in lowercase, except the first letter of each word. (The real definition of this style is more complicated, so let’s simplify it for this question.) Write a <strong class="source-inline">headline(sentence)</strong> function that will receive a string as an argument and return an appropriately capitalized version. Spaces separate words. Build this function by connecting <span class="No-Break">smaller functions:</span></p>
			<pre class="source-code">
console.log(headline("Alice's ADVENTURES in WoNdErLaNd"));
// Alice's Adventures In Wonderland</pre>
			<p>8.2 <strong class="bold">Pending tasks</strong>: A web service returns a result such as the following, showing all assigned tasks person by person. Tasks may be finished (<strong class="source-inline">done===true</strong>) or pending (<strong class="source-inline">done===false</strong>). Your goal is to produce an array with the IDs of the pending tasks for a given person, identified by name, which should match the responsible field. Solve this by using composition <span class="No-Break">or pipelining:</span></p>
			<pre class="source-code">
const allTasks = {
  date: "2017-09-22",
  byPerson: [
    {
      responsible: "EG",
      tasks: [
        { id: 111, desc: "task 111", done: false },
        { id: 222, desc: "task 222", done: false },
      ],
    },
    {
      responsible: "FK",
      tasks: [
        { id: 555, desc: "task 555", done: false },
        { id: 777, desc: "task 777", done: true },
        { id: 999, desc: "task 999", done: false },
      ],
    },
    {
      responsible: "ST",
      tasks: [{ id: 444, desc: "task 444", done: true }],
    },
  ],
};</pre>
			<p>Ensure your code doesn’t throw an exception if, for example, the person you are looking for doesn’t appear in the web <span class="No-Break">service result!</span></p>
			<p>8.3 <strong class="bold">Thinking in abstract terms</strong>: Suppose you are looking through somewhat old code and find a function that looks like the following one. (I’m keeping the names vague and abstract so that you can focus on the structure and not on the actual functionality). Can you transform this into <span class="No-Break">pointfree style?</span></p>
			<pre class="source-code">
function getSomeResults(things) {
  return sort(group(filter(select(things))));
}</pre>
			<p>8.4 <strong class="bold">Reversing types</strong>: You can define the <strong class="source-inline">Compose&lt;&gt;</strong> type using the <strong class="source-inline">Pipeline&lt;&gt;</strong> type plus a new <strong class="source-inline">Reverse&lt;&gt;</strong> type. What should that new <span class="No-Break">type be?</span></p>
			<p>8.5 <strong class="bold">Empty pipeline?</strong> Do our pipelining functions work with an empty array of functions? Can you <span class="No-Break">fix that?</span></p>
			<p>8.6 <strong class="bold">Undetected impurity?</strong>: Did you notice that the <strong class="source-inline">addToArray()</strong> function we wrote is actually impure? (Check out the <em class="italic">Argument mutation</em> section of <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic">, Behaving Properly,</em> if you aren’t convinced!) Would it be better if we wrote it as follows? Should we go <span class="No-Break">for it?</span></p>
			<pre class="source-code">
const addToArray = (a, v) =&gt; [...a, v];</pre>
			<p>8.7 <strong class="bold">Needless transducing?</strong> We used transducers to simplify any sequence of mapping and filtering operations. Would you have needed this if you only had <strong class="source-inline">map()</strong> operations? What if you only had <span class="No-Break"><strong class="source-inline">filter()</strong></span><span class="No-Break"> operations?</span></p>
			<p>8.8 <strong class="bold">What type?</strong> In the <em class="italic">Chaining method calls</em> section, I explained that the type of the (chainified) <strong class="source-inline">myCity2</strong> object was not the same as the type of the original <strong class="source-inline">myCity</strong> one. What is its <span class="No-Break">type exactly?</span></p>
		</div>
	</body></html>