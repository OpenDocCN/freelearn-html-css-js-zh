<html><head></head><body>
		<div><h1 id="_idParaDest-93" class="chapter-number"><a id="_idTextAnchor117"/>6</h1>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor118"/>The setValue Wrapper – Entering Text and Dynamic Data Replacement</h1>
			<p>In this chapter, we’re going to adapt the functionality from the <a id="_idTextAnchor119"/><code>click()</code> method in the earlier chapter and extend it to the <code>setValue()</code> method. In addition, the wrapper method introduces multiple approaches to clear the field before entering the data. This chapter shows you how to implement a dynamic data tag replacement as an enhancement. This is the focal point where data can be prevented from becoming stale. For example, a test might require a future or past date. Lastly, we will look at detecting a password field and masking it with the <code>setPassword()</code> function.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating a <code>setValue</code> Wrapper</li>
				<li>Normalizing the element class description from plain English</li>
				<li>Alternative ways to clear a field and enter data</li>
				<li>Dynamically replacing <code>&lt;Today&gt;</code> tags with a date</li>
				<li>Masking sensitive credential data</li>
			</ul>
			<p>First, some housekeeping is in order. In the last chapter, we introduced class switching for our button. We will do the same thing for our input fields and upcoming lists and text elements. While we can deduce the type of element being passed to the <code>getValidElement()</code> method, we can just as easily pass the type directly from the wrapper:</p>
			<pre class="source-code">
inputField = await getValidElement(inputField, "field");</pre>			<p>This means we can <a id="_idTextAnchor120"/>optimize the code for speed by skipping the code that extracts the <code>element</code> class, by explicitly stating the element type:</p>
			<pre class="source-code">
 // Extract the element type if not <a id="_idTextAnchor121"/>provided
 if (elementType === "") {
 let index: number = selector.indexOf("[");
elementType = selector.substring(0, index);
 <a id="_idTextAnchor122"/>}else{
 elementText = normalizeElementType(elementType);
}</pre>			<p>However, the explicit <code>field</code> string will not match the implicit string type of <code>//input</code>. To resolve this, we will add a method that will change generic descriptors such as <code>field</code> or <code>item</code> to a suitable class string such as <code>//input</code> and “<code>//li</code>”.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor123"/>Normalizing the element type</h1>
			<p>This is where we will write a method<a id="_idIndexMarker260"/> to normalize all the explicit strings. Here, <code>link </code>becomes <code>//a</code>,  <code>button</code> becomes <code>//button</code>, and so on. Your framework can continue to expand with many other element types as needed. The following function, <code>normalizeElementType()</code>, will take a plain English description of the element and translate it into a common <code>xPath</code> equivalent. Note that <code>field</code> and <code>input</code> become the same class, while an empty class description becomes a locator for all elements:</p>
			<pre class="source-code">
function normalizeElementType(elementType: string)
{
  // Pessimistic: return all matches if the type is unknown
  let elementText = "//*"
  switch (elementType)
  {
    case "link":
      elementText = "//a";
      break;
    case "button":
      elementText = "//button";
      break;
    // Support different terms of the same field type
    case "field": // plain English reference to a type input field
    case "input": // type input
      elementText = "//input";
      break;
    case "list":
      elementText = "//select";
      break;
    case "text":
      elementText = "//p";
      break;
    default:
      log (`WARNING: Unable to normalize element type ${elementType}`)
  }
  return elementText;
}</pre>			<p>There are a couple of items<a id="_idIndexMarker261"/> of note in this function. The first is the pessimistic nature of the function, which assumes the locator string passed was empty or <code>null</code>. <code>elementText</code> is initialized to <code>//*</code> to return all the elements in the first line. This means we assume at some point that a value might get passed a string that is yet to be implemented – for example, <code>list</code>. For documentation, we output the name of the unknown string as a warning to the console log.</p>
			<p> Second, we change the element to match all values rather than stopping the test. We want the framework to try its best to get to the endpoint without incurring more maintenance time. However, it does give a warning that we should be as descriptive as possible.</p>
			<p>Because we are now supporting unknown element types, we will add a generic locator to the <code>getValidElement()</code> function:</p>
			<pre class="source-code">
case "//*":
elementText = selector.match(<a id="_idTextAnchor124"/>/=".<a id="_idTextAnchor125"/>*"/)<a id="_idTextAnchor126"/>[0].slice(2, -1);
newSelector = `//<a id="_idTextAnchor127"/>*[contain<a id="_idTextAnchor128"/>s(text(), '${elementText<a id="_idTextAnchor129"/>}'])`;
found = await isElementVisible(await $(newSelector));
break;</pre>			<p>When we normalize text, we take common English descriptors and replace them with <code>xpath</code> element or CSS string locator equivalents. However, that’s not just applicable in the class. This same concept is leveraged in many attributes as well. Let’s take a moment to look at a link before we move on to input fields.</p>
			<p>Normalizing text can be seen in XPath locators<a id="_idIndexMarker262"/> <a id="_idTextAnchor130"/>to allow us to find elements that have embedded carriage returns and extraneous transient white space. In this example, the “Embedded Carriage Return” web page element has extra spaces and a carriage return:</p>
			<pre class="source-code">
 &lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Dynamic Loading Example&lt;/title&gt;
    &lt;script&gt;
        function embeddedCarriageReturn() {
            var paragraph = document.getElementById("change-me");
            paragraph.innerHTML = "You clicked the Embedded Carriage             Return link!";
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Weblink Challenge!&lt;/h1&gt;
    &lt;p&gt;Can you framework click the link below&lt;/p&gt;
    &lt;a href="#" onclick="embeddedCarriageReturn()"&gt;Embedded &lt;br&gt;        Carriage  Return&lt;/a&gt;
    &lt;p id="change-me"&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>			<div><div><img src="img/B19395_06_1.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>This means that this xPath<a id="_idIndexMarker263"/> won’t work to recognize the link:</p>
			<pre class="source-code">
  public get btnEmbeddedCarriageReturn() {
    return $("//a[text()='Embedded Carriage Return']");
  }</pre>			<div><div><img src="img/B19395_06_2.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>However, we can normalize the text with the <code>normalize-space()</code> node to remove carriage return <code>&lt;br&gt;</code> breaks and even stray white space:</p>
			<pre class="source-code">
  public get btnEmbeddedCarriageReturn () {
    return $("//a[contains(normalize-space(),'Embedded Carriage     Return')] ");
  }</pre>			<div><div><img src="img/B19395_06_3.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Now that we have yet another tool in our utility belt, we can write locators that can find elements with extra spaces and line breaks, reducing the maintenance time should these be cleaned<a id="_idIndexMarker264"/> up by the developers. Let’s take this to the next level with input elements and the <code>setValue</code> method.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor131"/>Adding the setValue() method wrapper</h1>
			<p>We begin by adding<a id="_idIndexMarker265"/> a new wrapper to our <code>helpers</code> file that we will extend with several checks, before performing the intrinsic <code>setValue()</code> method:</p>
			<pre class="source-code">
export async function setValueAdv(
  inputField: ChainablePromiseElement&lt;WebdriverIO.Element&gt;,
  text: string) {
//Custom setValue wrapper code here
await element.setValue(newValue);
}</pre>			<p>Now, we are ready<a id="_idIndexMarker266"/> to begin to enhance the data population aspect of our framework.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor132"/>Is this trip really necessary?</h1>
			<p>The first thing to do is to check whether<a id="_idIndexMarker267"/> any of the follo<a id="_idTextAnchor133"/>wing code must be executed at all. There is no reason to find and replace a state element with a valid one if we don’t have any text to enter. So, we will first check whether any data has been passed to be entered:</p>
			<pre class="source-code">
//Custom setValue wrapper code <a id="_idTextAnchor134"/>here
try{
    if (text.length === 0) {
        log (`      Warn<a id="_idTextAnchor135"/>ing: Attempted to enter "" into ${element.selector}`)
    return true<a id="_idTextAnchor136"/>;
}
}catch (<a id="_idTextAnchor137"/>error){
    log (`      Warn<a id="_idTextAnchor138"/>ing: Attempted to enter NULL into ${element.selector}`)
    log (`      Check if there was a query column to a missing column in a data file `)
    return false;
}</pre>			<p>This function has three actions:</p>
			<ul>
				<li>If the text is not null and not empty, the code continues to execute the rest of the method.</li>
				<li>If the text was an empty string it returns <code>true</code>, meaning the test can continue. This is useful, as we might be populating an entire page, but not every field takes a value. We could be searching by any combination of last name, zip code, and state. This allows for a page method design that has every input field but only interacts with the elements that receive some data.</li>
				<li>A null value<a id="_idIndexMarker268"/> is a special situation. It’s a clue that something is amiss. As superheroes, we always want to collect clu<a id="_idTextAnchor139"/>es to identify the usual suspect who is committing the crime. If the clue is in the form of a riddle, we might check with the local asylum to see whether the cell adorned with question marks still holds an inmate.</li>
				<li>In this case, a NULL value usually shows that the value was returned from a query that found nothing. We send a warning to the console and return <code>false</code> as the status. Just like with an empty value, it skips the rest of the function.</li>
			</ul>
			<p>With the input data confirmed, we will take a second step and add the ability to keep our data fresh.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor140"/>Coal into diamonds – replacing dynamic data tags</h1>
			<p>A very common task<a id="_idIndexMarker269"/> in test automation is to populate a field with the current date. Now, we don’t want to be changing the date every single day manually, so we want something dynamic that provides us with that functionality. If we’re clever, that functionality can return the current, past, or future date. Even the date format could be modified. This is where the techniques of embedded dynamic data tags come into play.</p>
			<p>Dynamic data tags are a way to keep data that changes at a regular cadence fresh. It might be the current day of the week, a unique order number that was created by a batch job that needs completion, or a future business date excluding weekends and holidays.</p>
			<p>There are many applications that will be unique to each individual project. In this case, we will provide a simple example of the most common data replacement – replacing a tag name, <code>"Today is: &lt;today&gt;"</code>, with the current date (i.e., <code>"Today </code><code>is 6/21/2023</code>).</p>
			<p>However, we won’t stop there. We will also<a id="_idIndexMarker270"/> offset the date by any amount of days for a future date:</p>
			<pre class="source-code">
"Tomorrow is: &lt;today+1&gt;"
"Tomorrow is: 6/22/2023"</pre>			<p>Alternatively, we can do it for a past date:</p>
			<pre class="source-code">
"Last week was: &lt;today-7&gt;"
"Last week was: 6/14/2023"</pre>			<p>Finally, we want to have the ability to change the formatting:</p>
			<pre class="source-code">
"Yesterday in European format: &lt;today-1 dd/mm/yyyy&gt;"
"Yesterday in European format: 20/6/2023"</pre>			<p>The basic format of this <code>&lt;today&gt;</code> tag gets replaced with a past or future date, with the custom <code>replaceTags()</code> function. Next, we add the function that detects these tags in every string passed through <code>setValueAdv()</code>. This will handle all sorts of tags:</p>
			<pre class="source-code">
function replaceTags(text: string) {
  //check if the passed tag is in the format of "&lt;someTag&gt;"
  let newText: string = text;
  // Capture anything that is not a space
  let match = newText.match(/\&lt;(.*?)\&gt;/);</pre>			<p>We use a bit of dark magic called a regular expression, which identifies<a id="_idIndexMarker271"/> strings encased in square brackets and extracts them:</p>
			<ul>
				<li><code>/</code>: This is the start delimiter for the regular expression.</li>
				<li><code>\&lt;</code>: This matches the opening angle bracket, <code>&lt;</code>, in the text.</li>
				<li><code>(.*?)</code>: This is a capturing group that matches any character (represented by the dot, <code>.</code> ) zero or more times (represented by <code>*?</code>) until it encounters the next character in the regular expression (in this case, the closing angle bracket &gt;). <code>?</code> makes the <code>*</code> quantifier lazy, meaning it will match as few characters as possible to satisfy the regex pattern.</li>
				<li><code>\&gt;</code>: This matches the closing angle bracket, <code>&gt;</code>, in the text.</li>
				<li><code>/</code>: This is the end delimiter for the regular expression.</li>
			</ul>
			<p>It is possible that multiple tags<a id="_idIndexMarker272"/> might need to be replaced in the string. So, we will loop through all of them. Tag identification is case-insensitive, meaning <code>&lt;today&gt;</code> and <code>&lt;TODAY&gt;</code> are equivalent:</p>
			<pre class="source-code">
  while (match) {
    let tag = match[0].toLowerCase();
    let tagType = match[1].toLowerCase();</pre>			<p>This <code>switch</code> statement matches the first part of the tag extension to multiple tags in the future. In this case, our first match will be a tag that starts with <code>&lt;today</code> and splits out <code>+</code> or <code>-</code> with the following value to offset the date:</p>
			<pre class="source-code">
    switch (true) {
      case tag.includes("&lt;today"):</pre>			<p>We have the <code>tag</code> string. Now, we split the date format, if it exists, to transform the date at the end of the function:</p>
			<pre class="source-code">
        let format: string = tagType.split(" ")[1] ? tagType.split(" ")[1] : "";
        let days: number = 0;
        const match = tag.match(/[+-](\d+)/);</pre>			<p>Another regular expression here extracts the days to offset the date:</p>
			<ul>
				<li> <code>/</code> : This is the start delimiter for the regular expression.</li>
				<li><code>[+-]</code> : This matches either the <code>+</code> or <code>-</code> character in the text. The square brackets denote a character class, which means that the regular expression will match any one of the characters inside the brackets.</li>
				<li><code>(\d+)</code>: This is a capturing group that matches one or more digits (represented by <code>\d</code>) in the text). The parentheses surrounding <code>\d+</code> capture the matched digits as a group. The <code>+</code> quantifier means that the regular expression will match one or more digits.</li>
				<li><code>/</code>: This is the end delimiter for the regular expression.</li>
			</ul>
			<p>The next action is to determine<a id="_idIndexMarker273"/> whether there is an offset by a number of days to a past or future date:</p>
			<pre class="source-code">
        if (match) {
          const days = parseInt(match[0]);
        }</pre>			<p>Here, we replace the tag in the string with a function that gets the current date offset and custom format:</p>
			<pre class="source-code">
        newText = newText.replace(tag, getToday(days, format));
        break;
      default:
        log(`ERROR: Unknown tag &lt;${tag}&gt;`);
        break;
    }
    match = newText.match(/\&lt;(.*?)\&gt;/);
  }</pre>			<p>This loop continues until all the tags have been replaced. If any tags are discovered and replaced, the new text is output<a id="_idIndexMarker274"/> to the console for logging:</p>
			<pre class="source-code">
  if (newText !== text) {
    log(`    Replaced tags in '${text}' with '${newText}'`);
  }
  return newText;
}</pre>			<p>Now that we have the ability to extract dynamic date tags, we need to process the offset date and formatting with the <code>getToday()</code> function. The default, today’s date, is empty, and the date format is <code>MM-dd-yyyy</code> if the format argument is blank.</p>
			<pre class="source-code">
export function getToday(offset: number = 0, format: string = "MM-dd-yyyy") {
  const currentDate = new Date();
  currentDate.setDate(currentDate.getDate() + offset);</pre>			<p>Here is our super-secret serum. This code will produce the date based on the format passed in. Why write loads of code to support all date formats, from 2-digit or 4-digit years and <code>0</code> leading dates to a European format, when <code>Date.toLocalDateString</code> can do it all for us in just these few lines of code?</p>
			<pre class="source-code">
  return currentDate.toLocaleDateString(undefined, {
    year: format.includes("yyyy") ? "numeric" : undefined,
    month: format.includes("MM")
      ? "2-digit"
      : format.includes("M")
      ? "numeric"
      : undefined,
    day: format.includes("dd")
      ? "2-digit"
      : format.includes("d")
      ? "numeric"
      : undefined,
  });
}</pre>			<p>Our dynamic date tag extractor<a id="_idIndexMarker275"/> and formatter are complete! The next trick is to populate it in a field. And, as you might guess, there is more than one way to do this – the slow way and the fast way.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor141"/>Injecting versus typing text into a field</h1>
			<p>We may want to override<a id="_idIndexMarker276"/> the intrinsic <code>setValue()</code> command to populate<a id="_idIndexMarker277"/> a field:</p>
			<pre class="source-code">
await inputField.setValue(newValue);</pre>			<p>The reason is that injecting a value into an element may not necessaril<a id="_idTextAnchor142"/>y kick off any additional JavaScript code behind the element. This might also skip some formatting that the developers added when we inject the data.  Alternatively, we could use <code>addValue()</code>:</p>
			<pre class="source-code">
await inputField.addValue(newValue);</pre>			<p>Now, we might be appending text into a field that already has text. What we want is a function that will first clear the field, if populated, and then type just as a user would – letter by letter followed by the <em class="italic">Tab</em> key to move out of the field<a id="_idTextAnchor143"/>.</p>
			<p>This can be accomplished in our framework in two ways.</p>
			<p>First, we set the focus on the element and sending keystrokes through the <code>browser.keys()</code> method. Second, we send keys to the element directly with its <code>AddValue()</code> method. This would be a backup approach being slightly slower. Regardless of the tool used, sometimes an element just does not receive the text correctly when entered at a high typing speed. So, the <code>AddValue</code> approach would be a backup to ensure fields get populated accurately.</p>
			<p>Let’s begin with the first approach, using the <code>browser.keys</code> method to send text to the element, with a focus on speed. This is carried out by setting focus on the element with a click:</p>
			<pre class="source-code">
await highlightOn(inputField);
await inputField.click();</pre>			<p>The element now has focus, and thanks<a id="_idIndexMarker278"/> to the highlight, we can see which element<a id="_idIndexMarker279"/> will take the input. We should check whether the field needs to be cleared.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor144"/>Checking whether the field is pre-populated for speed</h1>
			<p>Next, we will clear the field<a id="_idIndexMarker280"/> if it has any pre-existing text. The basic way<a id="_idIndexMarker281"/> to d<a id="_idTextAnchor145"/>o this is with the <code>clear()</code> method:</p>
			<pre class="source-code">
if (await inputField.g<a id="_idTextAnchor146"/>etAttribute('value') !== '') {
await inputField.clear();
}</pre>			<p>An alternative way to clear the field can also be done by issuing a <code>Meta-a</code> command to select all the text. The selected text is cleared by sending the backspace ASCII key code from the browser:</p>
			<pre class="source-code">
await browser.keys(['Meta', 'a']);
await browser.keys(['\ue003']);</pre>			<p>Now, we will type the text passed to the wrapper into the field from the browser:</p>
			<pre class="source-code">
await browser.keys(text);</pre>			<p>Faster is not always better. If you find the speed of WebdriverIO typing text is causing issues, you can control how quickly text is typed with this alternative code:</p>
			<pre class="source-code">
// type text letter by letter
for (let letter = 0; letter &lt; t<a id="_idTextAnchor147"/>ext.length<a id="_idTextAnchor148"/>; letter++){
await pause(10); // control the typing speed
await inputField.addValue(text[letter]);
}</pre>			<p>Once the text is entered, the field can be activated by typing the <em class="italic">Tab</em> key:</p>
			<pre class="source-code">
await browser.keys(['tab']);</pre>			<p>While the <em class="italic">Tab</em> key is universal to activate an element, sometimes the <em class="italic">Enter</em> key is needed instead:</p>
			<pre class="source-code">
await browser.keys(['\ue007']);</pre>			<p>However, are we about to send<a id="_idIndexMarker282"/> our password to the console for everyone<a id="_idIndexMarker283"/> to see? It’s a bad day in the city when a supervillain is able to take the hero’s supercharged crime-fighting vehicle for a joyride. Let’s make that less likely to happen.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor149"/>Behind the mask – SetValuePassword() to keep data secure</h1>
			<p>Superheroes wear a mask<a id="_idIndexMarker284"/> to protect family and friends. In test automation, we need to protect our sensitive data such as passwords. In this method, we take the extra step to be sure our passwords are not displayed in the console and report output by replacing most of the string with asterisks (<code>Password" = "Pa****rd</code>). However, if the root cause of our issues is that a password expired, we might want to have a small clue. So, we need to mask just a part of our credentials:</p>
			<pre class="source-code">
function maskString(str: string): string {
  let maskedStr = '';
  for (let charIndex = 0; charIndex &lt; str.length; charIndex++) {
    if (charIndex &gt; 1 &amp;&amp; charIndex &lt; str.length - 2) {
      maskedStr += '*';
    } else {
      maskedStr += str[charIndex];
    }
  }
  return maskedStr;
}</pre>			<p>Here is an example of the original password and the value returned:</p>
			<pre class="source-code">
let originalString = "SuperSecretPassword!";
let maskedString = maskString(originalString);
console.log(originalString); // Output: 'SuperSecretPassword! '
console.log(maskedString); // Output: 'se**********ation'</pre>			<h2 id="_idParaDest-102"><a id="_idTextAnchor150"/>Detecting and masking passwords in your output</h2>
			<p>The next step is to detect a field<a id="_idIndexMarker285"/> that might be a password and then scrub<a id="_idIndexMarker286"/> the data that’s being passed to it. We’ll send the password<a id="_idIndexMarker287"/> to the field but output a scrubbed version<a id="_idIndexMarker288"/> of the data to our results. First, let’s get a scrubbed version of the text:</p>
			<pre class="source-code">
scrubbedtext = maskString (text)</pre>			<p>Next, we will get the field element name and check whether it includes the <code>ssword</code> string pattern. This makes it likely that we will scrub any field that has the <code>password</code> or <code>Password</code> string. This is provided by a custom <code>getFieldName()</code> helper method:</p>
			<pre class="source-code">
/**
* Returns the first non-null property from the prioritized list: 'name', 'id', 'type', and 'class'. Can be amended to add other attributes such as "aria-label"
* @param {WebdriverIO.Element} element - The WebdriverIO element to get the name of the field
* @returns {string | null} The field name, or null if no properties have a value
*/
async function getFieldName(element: WebdriverIO.Element) {
// Add any custom properties here, e.g.:
// const customPropertyName = await element.getAttribute("aria-label");
// if (customPropertyName) return custom;
// Get the 'name' property of the element
  const name = await element.getAttribute("name");
  if (name) return name;
  // Get the 'id' property of the element
  const id = await element.getAttribute("id");
  if (id) return id;
  // Get the 'type' property of the element
  const type = await element.getAttribute("type");
  if (type) return type;
  // Get the 'class' property of the element if others are null
  const className = await element.getAttribute("class");
  return className;
}</pre>			<p>You might be wondering, why not create a generic method called <code>getElementName()</code> to return the name of any element? The reason is that the properties and prioritizations<a id="_idIndexMarker289"/> can be different, depending on whether we are seeking an input field, a button, a list, or other<a id="_idIndexMarker290"/> <a id="_idTextAnchor151"/>elements. This allows us to optimize<a id="_idIndexMarker291"/> the code execution based<a id="_idIndexMarker292"/> on the element type.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor152"/>Putting it all together</h1>
			<p>Now that we’ve got<a id="_idIndexMarker293"/> all the custom-made parts, let’s put together our superpowered method. These methods will return a success value of <code>true</code> or <code>false</code>. We ensure that we have a valid element from the earlier chapter. We will replace tags such as the date with a future or past offset. We will detect whether the field is a password<a id="_idIndexMarker294"/> and mask our value output accordingly:</p>
			<pre class="source-code">
export async function setValueAdv(
  inputField: WebdriverIO.Element,
  text: string
) {
  let success: boolean = false;
  inputField = await getValidElement(inputField, "field");
  const SELECTOR = await inputField.selector;
  let newValue: string = replaceTags(text);
  let scrubbedValue: string = newValue
  let fieldName: string = await getFieldName(inputField)
  //Mask Passwords in output
  if (fieldName.includes("ssword") ){
    scrubbedValue = maskValue(scrubbedValue)
  }
  await log(`Entering '${scrubbedValue}' into ${SELECTOR}`);
  try {
    // await element.waitForDisplayed();
    if (!(await isElementInViewport(inputField))) {
      await scrollIntoView(inputField);
      await waitForElementToStopMoving(inputField);
    }
    await highlightOn(inputField);
    //Check if text was entered
    // Clear input field
    await inputField.click();
    // Do we need to clear the field?
    if (await inputField.getValue()) await inputField.setValue(newValue);
    // Send text to input field
    for (const letter of text) {
      await inputField.addValue(letter);
    }
    success = true;
  } catch (error: any) {
    await log(`  ERROR: ${SELECTOR} was not populated with ${scrubbedValue}.\n       ${error.message}`
    );
    expect(`to be editable`).toEqual(SELECTOR);
    // Throw the error to stop the test, still masking password
    await inputField.setValue(scrubbedValue);
  }
  return success;
}</pre>			<p>The following is an example of the masked credentials in our output:</p>
			<pre class="source-code">
[0-0] ---&gt; Logging in with user role 'tomsmith'
[0-0] ---&gt; Entering 'tomsmith' into #username
[0-0] ---&gt; Entering 'Su****************d!' into #password</pre>			<p>There are a lot of other features we could implement to customize the data input of our fields. We could use the same technique to inject SQL statements to always pull a valid order number for a search. Strings of random <code>Corporate Lorem Ipsum</code> filler words could be populated to check exact field length boundaries. Text with vulgar words could be tested to make sure they get flagged and notification emails are sent to test accounts. Take a few minutes to think about all the types of dynamic and special data that might be available to test<a id="_idIndexMarker295"/> against with an automated framework.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor153"/>Summary</h1>
			<p>In this chapter, we added all sorts of custom-made gadgets to our <code>setValueAdv() </code>method. This method delivers a result indicating the success or failure of <code>true</code> or <code>false</code>. We conducted a background check to ensure that we had a valid element. Our approach involved wielding the power of time travel by replacing date-related tags with the present, future, or past date offset. We also kept security in mind and made sure to mask our output value when the field in question was a likely credential input.</p>
			<p>Next, we will supercharge the <code>Select()</code> method with lists and comboboxes.</p>
		</div>
	</body></html>