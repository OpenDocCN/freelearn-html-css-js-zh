<html><head></head><body>
		<div id="_idContainer076">
			<h1 id="_idParaDest-93" class="chapter-number"><a id="_idTextAnchor117"/>6</h1>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor118"/>The setValue Wrapper – Entering Text and Dynamic Data Replacement</h1>
			<p>In this chapter, we’re going to adapt the functionality from the <a id="_idTextAnchor119"/><strong class="source-inline">click()</strong> method in the earlier chapter and extend it to the <strong class="source-inline">setValue()</strong> method. In addition, the wrapper method introduces multiple approaches to clear the field before entering the data. This chapter shows you how to implement a dynamic data tag replacement as an enhancement. This is the focal point where data can be prevented from becoming stale. For example, a test might require a future or past date. Lastly, we will look at detecting a password field and masking it with the <span class="No-Break"><strong class="source-inline">setPassword()</strong></span><span class="No-Break"> function.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating a <span class="No-Break"><strong class="source-inline">setValue</strong></span><span class="No-Break"> Wrapper</span></li>
				<li>Normalizing the element class description from <span class="No-Break">plain English</span></li>
				<li>Alternative ways to clear a field and <span class="No-Break">enter data</span></li>
				<li>Dynamically replacing <strong class="source-inline">&lt;Today&gt;</strong> tags with <span class="No-Break">a date</span></li>
				<li>Masking sensitive <span class="No-Break">credential data</span></li>
			</ul>
			<p>First, some housekeeping is in order. In the last chapter, we introduced class switching for our button. We will do the same thing for our input fields and upcoming lists and text elements. While we can deduce the type of element being passed to the <strong class="source-inline">getValidElement()</strong> method, we can just as easily pass the type directly from <span class="No-Break">the wrapper:</span></p>
			<pre class="source-code">
inputField = await getValidElement(inputField, "field");</pre>			<p>This means we can <a id="_idTextAnchor120"/>optimize the code for speed by skipping the code that extracts the <strong class="source-inline">element</strong> class, by explicitly stating the <span class="No-Break">element type:</span></p>
			<pre class="source-code">
 // Extract the element type if not <a id="_idTextAnchor121"/>provided
 if (elementType === "") {
 let index: number = selector.indexOf("[");
elementType = selector.substring(0, index);
 <a id="_idTextAnchor122"/>}else{
 elementText = normalizeElementType(elementType);
}</pre>			<p>However, the explicit <strong class="source-inline">field</strong> string will not match the implicit string type of <strong class="source-inline">//input</strong>. To resolve this, we will add a method that will change generic descriptors such as <strong class="source-inline">field</strong> or <strong class="source-inline">item</strong> to a suitable class string such as <strong class="source-inline">//input</strong> <span class="No-Break">and “</span><span class="No-Break"><strong class="source-inline">//li</strong></span><span class="No-Break">”.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor123"/>Normalizing the element type</h1>
			<p>This is where we will write a method<a id="_idIndexMarker260"/> to normalize all the explicit strings. Here, <strong class="source-inline">link </strong>becomes <strong class="source-inline">//a</strong>,  <strong class="source-inline">button</strong> becomes <strong class="source-inline">//button</strong>, and so on. Your framework can continue to expand with many other element types as needed. The following function, <strong class="source-inline">normalizeElementType()</strong>, will take a plain English description of the element and translate it into a common <strong class="source-inline">xPath</strong> equivalent. Note that <strong class="source-inline">field</strong> and <strong class="source-inline">input</strong> become the same class, while an empty class description becomes a locator for <span class="No-Break">all elements:</span></p>
			<pre class="source-code">
function normalizeElementType(elementType: string)
{
  // Pessimistic: return all matches if the type is unknown
  let elementText = "//*"
  switch (elementType)
  {
    case "link":
      elementText = "//a";
      break;
    case "button":
      elementText = "//button";
      break;
    // Support different terms of the same field type
    case "field": // plain English reference to a type input field
    case "input": // type input
      elementText = "//input";
      break;
    case "list":
      elementText = "//select";
      break;
    case "text":
      elementText = "//p";
      break;
    default:
      log (`WARNING: Unable to normalize element type ${elementType}`)
  }
  return elementText;
}</pre>			<p>There are a couple of items<a id="_idIndexMarker261"/> of note in this function. The first is the pessimistic nature of the function, which assumes the locator string passed was empty or <strong class="source-inline">null</strong>. <strong class="source-inline">elementText</strong> is initialized to <strong class="source-inline">//*</strong> to return all the elements in the first line. This means we assume at some point that a value might get passed a string that is yet to be implemented – for example, <strong class="source-inline">list</strong>. For documentation, we output the name of the unknown string as a warning to the <span class="No-Break">console log.</span></p>
			<p> Second, we change the element to match all values rather than stopping the test. We want the framework to try its best to get to the endpoint without incurring more maintenance time. However, it does give a warning that we should be as descriptive <span class="No-Break">as possible.</span></p>
			<p>Because we are now supporting unknown element types, we will add a generic locator to the <span class="No-Break"><strong class="source-inline">getValidElement()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
case "//*":
elementText = selector.match(<a id="_idTextAnchor124"/>/=".<a id="_idTextAnchor125"/>*"/)<a id="_idTextAnchor126"/>[0].slice(2, -1);
newSelector = `//<a id="_idTextAnchor127"/>*[contain<a id="_idTextAnchor128"/>s(text(), '${elementText<a id="_idTextAnchor129"/>}'])`;
found = await isElementVisible(await $(newSelector));
break;</pre>			<p>When we normalize text, we take common English descriptors and replace them with <strong class="source-inline">xpath</strong> element or CSS string locator equivalents. However, that’s not just applicable in the class. This same concept is leveraged in many attributes as well. Let’s take a moment to look at a link before we move on to <span class="No-Break">input fields.</span></p>
			<p>Normalizing text can be seen in XPath locators<a id="_idIndexMarker262"/> <a id="_idTextAnchor130"/>to allow us to find elements that have embedded carriage returns and extraneous transient white space. In this example, the “Embedded Carriage Return” web page element has extra spaces and a <span class="No-Break">carriage return:</span></p>
			<pre class="source-code">
 &lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Dynamic Loading Example&lt;/title&gt;
    &lt;script&gt;
        function embeddedCarriageReturn() {
            var paragraph = document.getElementById("change-me");
            paragraph.innerHTML = "You clicked the Embedded Carriage             Return link!";
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Weblink Challenge!&lt;/h1&gt;
    &lt;p&gt;Can you framework click the link below&lt;/p&gt;
    &lt;a href="#" onclick="embeddedCarriageReturn()"&gt;Embedded &lt;br&gt;        Carriage  Return&lt;/a&gt;
    &lt;p id="change-me"&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B19395_06_1.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>This means that this xPath<a id="_idIndexMarker263"/> won’t work to recognize <span class="No-Break">the link:</span></p>
			<pre class="source-code">
  public get btnEmbeddedCarriageReturn() {
    return $("//a[text()='Embedded Carriage Return']");
  }</pre>			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B19395_06_2.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>However, we can normalize the text with the <strong class="source-inline">normalize-space()</strong> node to remove carriage return <strong class="source-inline">&lt;br&gt;</strong> breaks and even stray <span class="No-Break">white space:</span></p>
			<pre class="source-code">
  public get btnEmbeddedCarriageReturn () {
    return $("//a[contains(normalize-space(),'Embedded Carriage     Return')] ");
  }</pre>			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B19395_06_3.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Now that we have yet another tool in our utility belt, we can write locators that can find elements with extra spaces and line breaks, reducing the maintenance time should these be cleaned<a id="_idIndexMarker264"/> up by the developers. Let’s take this to the next level with input elements and the <span class="No-Break"><strong class="source-inline">setValue</strong></span><span class="No-Break"> method.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor131"/>Adding the setValue() method wrapper</h1>
			<p>We begin by adding<a id="_idIndexMarker265"/> a new wrapper to our <strong class="source-inline">helpers</strong> file that we will extend with several checks, before performing the intrinsic <span class="No-Break"><strong class="source-inline">setValue()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
export async function setValueAdv(
  inputField: ChainablePromiseElement&lt;WebdriverIO.Element&gt;,
  text: string) {
//Custom setValue wrapper code here
await element.setValue(newValue);
}</pre>			<p>Now, we are ready<a id="_idIndexMarker266"/> to begin to enhance the data population aspect of <span class="No-Break">our framework.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor132"/>Is this trip really necessary?</h1>
			<p>The first thing to do is to check whether<a id="_idIndexMarker267"/> any of the follo<a id="_idTextAnchor133"/>wing code must be executed at all. There is no reason to find and replace a state element with a valid one if we don’t have any text to enter. So, we will first check whether any data has been passed to <span class="No-Break">be entered:</span></p>
			<pre class="source-code">
//Custom setValue wrapper code <a id="_idTextAnchor134"/>here
try{
    if (text.length === 0) {
        log (`      Warn<a id="_idTextAnchor135"/>ing: Attempted to enter "" into ${element.selector}`)
    return true<a id="_idTextAnchor136"/>;
}
}catch (<a id="_idTextAnchor137"/>error){
    log (`      Warn<a id="_idTextAnchor138"/>ing: Attempted to enter NULL into ${element.selector}`)
    log (`      Check if there was a query column to a missing column in a data file `)
    return false;
}</pre>			<p>This function has <span class="No-Break">three actions:</span></p>
			<ul>
				<li>If the text is not null and not empty, the code continues to execute the rest of <span class="No-Break">the method.</span></li>
				<li>If the text was an empty string it returns <strong class="source-inline">true</strong>, meaning the test can continue. This is useful, as we might be populating an entire page, but not every field takes a value. We could be searching by any combination of last name, zip code, and state. This allows for a page method design that has every input field but only interacts with the elements that receive <span class="No-Break">some data.</span></li>
				<li>A null value<a id="_idIndexMarker268"/> is a special situation. It’s a clue that something is amiss. As superheroes, we always want to collect clu<a id="_idTextAnchor139"/>es to identify the usual suspect who is committing the crime. If the clue is in the form of a riddle, we might check with the local asylum to see whether the cell adorned with question marks still holds <span class="No-Break">an inmate.</span></li>
				<li>In this case, a NULL value usually shows that the value was returned from a query that found nothing. We send a warning to the console and return <strong class="source-inline">false</strong> as the status. Just like with an empty value, it skips the rest of <span class="No-Break">the function.</span></li>
			</ul>
			<p>With the input data confirmed, we will take a second step and add the ability to keep our <span class="No-Break">data fresh.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor140"/>Coal into diamonds – replacing dynamic data tags</h1>
			<p>A very common task<a id="_idIndexMarker269"/> in test automation is to populate a field with the current date. Now, we don’t want to be changing the date every single day manually, so we want something dynamic that provides us with that functionality. If we’re clever, that functionality can return the current, past, or future date. Even the date format could be modified. This is where the techniques of embedded dynamic data tags come <span class="No-Break">into play.</span></p>
			<p>Dynamic data tags are a way to keep data that changes at a regular cadence fresh. It might be the current day of the week, a unique order number that was created by a batch job that needs completion, or a future business date excluding weekends <span class="No-Break">and holidays.</span></p>
			<p>There are many applications that will be unique to each individual project. In this case, we will provide a simple example of the most common data replacement – replacing a tag name, <strong class="source-inline">"Today is: &lt;today&gt;"</strong>, with the current date (i.e., <strong class="source-inline">"Today </strong><span class="No-Break"><strong class="source-inline">is 6/21/2023</strong></span><span class="No-Break">).</span></p>
			<p>However, we won’t stop there. We will also<a id="_idIndexMarker270"/> offset the date by any amount of days for a <span class="No-Break">future date:</span></p>
			<pre class="source-code">
"Tomorrow is: &lt;today+1&gt;"
"Tomorrow is: 6/22/2023"</pre>			<p>Alternatively, we can do it for a <span class="No-Break">past date:</span></p>
			<pre class="source-code">
"Last week was: &lt;today-7&gt;"
"Last week was: 6/14/2023"</pre>			<p>Finally, we want to have the ability to change <span class="No-Break">the formatting:</span></p>
			<pre class="source-code">
"Yesterday in European format: &lt;today-1 dd/mm/yyyy&gt;"
"Yesterday in European format: 20/6/2023"</pre>			<p>The basic format of this <strong class="source-inline">&lt;today&gt;</strong> tag gets replaced with a past or future date, with the custom <strong class="source-inline">replaceTags()</strong> function. Next, we add the function that detects these tags in every string passed through <strong class="source-inline">setValueAdv()</strong>. This will handle all sorts <span class="No-Break">of tags:</span></p>
			<pre class="source-code">
function replaceTags(text: string) {
  //check if the passed tag is in the format of "&lt;someTag&gt;"
  let newText: string = text;
  // Capture anything that is not a space
  let match = newText.match(/\&lt;(.*?)\&gt;/);</pre>			<p>We use a bit of dark magic called a regular expression, which identifies<a id="_idIndexMarker271"/> strings encased in square brackets and <span class="No-Break">extracts them:</span></p>
			<ul>
				<li><strong class="source-inline">/</strong>: This is the start delimiter for the <span class="No-Break">regular expression.</span></li>
				<li><strong class="source-inline">\&lt;</strong>: This matches the opening angle bracket, <strong class="source-inline">&lt;</strong>, in <span class="No-Break">the text.</span></li>
				<li><strong class="source-inline">(.*?)</strong>: This is a capturing group that matches any character (represented by the dot, <strong class="source-inline">.</strong> ) zero or more times (represented by <strong class="source-inline">*?</strong>) until it encounters the next character in the regular expression (in this case, the closing angle bracket &gt;). <strong class="source-inline">?</strong> makes the <strong class="source-inline">*</strong> quantifier lazy, meaning it will match as few characters as possible to satisfy the <span class="No-Break">regex pattern.</span></li>
				<li><strong class="source-inline">\&gt;</strong>: This matches the closing angle bracket, <strong class="source-inline">&gt;</strong>, in <span class="No-Break">the text.</span></li>
				<li><strong class="source-inline">/</strong>: This is the end delimiter for the <span class="No-Break">regular expression.</span></li>
			</ul>
			<p>It is possible that multiple tags<a id="_idIndexMarker272"/> might need to be replaced in the string. So, we will loop through all of them. Tag identification is case-insensitive, meaning <strong class="source-inline">&lt;today&gt;</strong> and <strong class="source-inline">&lt;TODAY&gt;</strong> <span class="No-Break">are equivalent:</span></p>
			<pre class="source-code">
  while (match) {
    let tag = match[0].toLowerCase();
    let tagType = match[1].toLowerCase();</pre>			<p>This <strong class="source-inline">switch</strong> statement matches the first part of the tag extension to multiple tags in the future. In this case, our first match will be a tag that starts with <strong class="source-inline">&lt;today</strong> and splits out <strong class="source-inline">+</strong> or <strong class="source-inline">-</strong> with the following value to offset <span class="No-Break">the date:</span></p>
			<pre class="source-code">
    switch (true) {
      case tag.includes("&lt;today"):</pre>			<p>We have the <strong class="source-inline">tag</strong> string. Now, we split the date format, if it exists, to transform the date at the end of <span class="No-Break">the function:</span></p>
			<pre class="source-code">
        let format: string = tagType.split(" ")[1] ? tagType.split(" ")[1] : "";
        let days: number = 0;
        const match = tag.match(/[+-](\d+)/);</pre>			<p>Another regular expression here extracts the days to offset <span class="No-Break">the date:</span></p>
			<ul>
				<li> <strong class="source-inline">/</strong> : This is the start delimiter for the <span class="No-Break">regular expression.</span></li>
				<li><strong class="source-inline">[+-]</strong> : This matches either the <strong class="source-inline">+</strong> or <strong class="source-inline">-</strong> character in the text. The square brackets denote a character class, which means that the regular expression will match any one of the characters inside <span class="No-Break">the brackets.</span></li>
				<li><strong class="source-inline">(\d+)</strong>: This is a capturing group that matches one or more digits (represented by <strong class="source-inline">\d</strong>) in the text). The parentheses surrounding <strong class="source-inline">\d+</strong> capture the matched digits as a group. The <strong class="source-inline">+</strong> quantifier means that the regular expression will match one or <span class="No-Break">more digits.</span></li>
				<li><strong class="source-inline">/</strong>: This is the end delimiter for the <span class="No-Break">regular expression.</span></li>
			</ul>
			<p>The next action is to determine<a id="_idIndexMarker273"/> whether there is an offset by a number of days to a past or <span class="No-Break">future date:</span></p>
			<pre class="source-code">
        if (match) {
          const days = parseInt(match[0]);
        }</pre>			<p>Here, we replace the tag in the string with a function that gets the current date offset and <span class="No-Break">custom format:</span></p>
			<pre class="source-code">
        newText = newText.replace(tag, getToday(days, format));
        break;
      default:
        log(`ERROR: Unknown tag &lt;${tag}&gt;`);
        break;
    }
    match = newText.match(/\&lt;(.*?)\&gt;/);
  }</pre>			<p>This loop continues until all the tags have been replaced. If any tags are discovered and replaced, the new text is output<a id="_idIndexMarker274"/> to the console <span class="No-Break">for logging:</span></p>
			<pre class="source-code">
  if (newText !== text) {
    log(`    Replaced tags in '${text}' with '${newText}'`);
  }
  return newText;
}</pre>			<p>Now that we have the ability to extract dynamic date tags, we need to process the offset date and formatting with the <strong class="source-inline">getToday()</strong> function. The default, today’s date, is empty, and the date format is <strong class="source-inline">MM-dd-yyyy</strong> if the format argument <span class="No-Break">is blank.</span></p>
			<pre class="source-code">
export function getToday(offset: number = 0, format: string = "MM-dd-yyyy") {
  const currentDate = new Date();
  currentDate.setDate(currentDate.getDate() + offset);</pre>			<p>Here is our super-secret serum. This code will produce the date based on the format passed in. Why write loads of code to support all date formats, from 2-digit or 4-digit years and <strong class="source-inline">0</strong> leading dates to a European format, when <strong class="source-inline">Date.toLocalDateString</strong> can do it all for us in just these few lines <span class="No-Break">of code?</span></p>
			<pre class="source-code">
  return currentDate.toLocaleDateString(undefined, {
    year: format.includes("yyyy") ? "numeric" : undefined,
    month: format.includes("MM")
      ? "2-digit"
      : format.includes("M")
      ? "numeric"
      : undefined,
    day: format.includes("dd")
      ? "2-digit"
      : format.includes("d")
      ? "numeric"
      : undefined,
  });
}</pre>			<p>Our dynamic date tag extractor<a id="_idIndexMarker275"/> and formatter are complete! The next trick is to populate it in a field. And, as you might guess, there is more than one way to do this – the slow way and the <span class="No-Break">fast way.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor141"/>Injecting versus typing text into a field</h1>
			<p>We may want to override<a id="_idIndexMarker276"/> the intrinsic <strong class="source-inline">setValue()</strong> command to populate<a id="_idIndexMarker277"/> <span class="No-Break">a field:</span></p>
			<pre class="source-code">
await inputField.setValue(newValue);</pre>			<p>The reason is that injecting a value into an element may not necessaril<a id="_idTextAnchor142"/>y kick off any additional JavaScript code behind the element. This might also skip some formatting that the developers added when we inject the data.  Alternatively, we could <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">addValue()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
await inputField.addValue(newValue);</pre>			<p>Now, we might be appending text into a field that already has text. What we want is a function that will first clear the field, if populated, and then type just as a user would – letter by letter followed by the <em class="italic">Tab</em> key to move out of <span class="No-Break">the field<a id="_idTextAnchor143"/>.</span></p>
			<p>This can be accomplished in our framework in <span class="No-Break">two ways.</span></p>
			<p>First, we set the focus on the element and sending keystrokes through the <strong class="source-inline">browser.keys()</strong> method. Second, we send keys to the element directly with its <strong class="source-inline">AddValue()</strong> method. This would be a backup approach being slightly slower. Regardless of the tool used, sometimes an element just does not receive the text correctly when entered at a high typing speed. So, the <strong class="source-inline">AddValue</strong> approach would be a backup to ensure fields get <span class="No-Break">populated accurately.</span></p>
			<p>Let’s begin with the first approach, using the <strong class="source-inline">browser.keys</strong> method to send text to the element, with a focus on speed. This is carried out by setting focus on the element with <span class="No-Break">a click:</span></p>
			<pre class="source-code">
await highlightOn(inputField);
await inputField.click();</pre>			<p>The element now has focus, and thanks<a id="_idIndexMarker278"/> to the highlight, we can see which element<a id="_idIndexMarker279"/> will take the input. We should check whether the field needs to <span class="No-Break">be cleared.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor144"/>Checking whether the field is pre-populated for speed</h1>
			<p>Next, we will clear the field<a id="_idIndexMarker280"/> if it has any pre-existing text. The basic way<a id="_idIndexMarker281"/> to d<a id="_idTextAnchor145"/>o this is with the <span class="No-Break"><strong class="source-inline">clear()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
if (await inputField.g<a id="_idTextAnchor146"/>etAttribute('value') !== '') {
await inputField.clear();
}</pre>			<p>An alternative way to clear the field can also be done by issuing a <strong class="source-inline">Meta-a</strong> command to select all the text. The selected text is cleared by sending the backspace ASCII key code from <span class="No-Break">the browser:</span></p>
			<pre class="source-code">
await browser.keys(['Meta', 'a']);
await browser.keys(['\ue003']);</pre>			<p>Now, we will type the text passed to the wrapper into the field from <span class="No-Break">the browser:</span></p>
			<pre class="source-code">
await browser.keys(text);</pre>			<p>Faster is not always better. If you find the speed of WebdriverIO typing text is causing issues, you can control how quickly text is typed with this <span class="No-Break">alternative code:</span></p>
			<pre class="source-code">
// type text letter by letter
for (let letter = 0; letter &lt; t<a id="_idTextAnchor147"/>ext.length<a id="_idTextAnchor148"/>; letter++){
await pause(10); // control the typing speed
await inputField.addValue(text[letter]);
}</pre>			<p>Once the text is entered, the field can be activated by typing the <span class="No-Break"><em class="italic">Tab</em></span><span class="No-Break"> key:</span></p>
			<pre class="source-code">
await browser.keys(['tab']);</pre>			<p>While the <em class="italic">Tab</em> key is universal to activate an element, sometimes the <em class="italic">Enter</em> key is <span class="No-Break">needed instead:</span></p>
			<pre class="source-code">
await browser.keys(['\ue007']);</pre>			<p>However, are we about to send<a id="_idIndexMarker282"/> our password to the console for everyone<a id="_idIndexMarker283"/> to see? It’s a bad day in the city when a supervillain is able to take the hero’s supercharged crime-fighting vehicle for a joyride. Let’s make that less likely <span class="No-Break">to happen.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor149"/>Behind the mask – SetValuePassword() to keep data secure</h1>
			<p>Superheroes wear a mask<a id="_idIndexMarker284"/> to protect family and friends. In test automation, we need to protect our sensitive data such as passwords. In this method, we take the extra step to be sure our passwords are not displayed in the console and report output by replacing most of the string with asterisks (<strong class="source-inline">Password" = "Pa****rd</strong>). However, if the root cause of our issues is that a password expired, we might want to have a small clue. So, we need to mask just a part of <span class="No-Break">our credentials:</span></p>
			<pre class="source-code">
function maskString(str: string): string {
  let maskedStr = '';
  for (let charIndex = 0; charIndex &lt; str.length; charIndex++) {
    if (charIndex &gt; 1 &amp;&amp; charIndex &lt; str.length - 2) {
      maskedStr += '*';
    } else {
      maskedStr += str[charIndex];
    }
  }
  return maskedStr;
}</pre>			<p>Here is an example of the original password and the <span class="No-Break">value returned:</span></p>
			<pre class="source-code">
let originalString = "SuperSecretPassword!";
let maskedString = maskString(originalString);
console.log(originalString); // Output: 'SuperSecretPassword! '
console.log(maskedString); // Output: 'se**********ation'</pre>			<h2 id="_idParaDest-102"><a id="_idTextAnchor150"/>Detecting and masking passwords in your output</h2>
			<p>The next step is to detect a field<a id="_idIndexMarker285"/> that might be a password and then scrub<a id="_idIndexMarker286"/> the data that’s being passed to it. We’ll send the password<a id="_idIndexMarker287"/> to the field but output a scrubbed version<a id="_idIndexMarker288"/> of the data to our results. First, let’s get a scrubbed version of <span class="No-Break">the text:</span></p>
			<pre class="source-code">
scrubbedtext = maskString (text)</pre>			<p>Next, we will get the field element name and check whether it includes the <strong class="source-inline">ssword</strong> string pattern. This makes it likely that we will scrub any field that has the <strong class="source-inline">password</strong> or <strong class="source-inline">Password</strong> string. This is provided by a custom <strong class="source-inline">getFieldName()</strong> <span class="No-Break">helper method:</span></p>
			<pre class="source-code">
/**
* Returns the first non-null property from the prioritized list: 'name', 'id', 'type', and 'class'. Can be amended to add other attributes such as "aria-label"
* @param {WebdriverIO.Element} element - The WebdriverIO element to get the name of the field
* @returns {string | null} The field name, or null if no properties have a value
*/
async function getFieldName(element: WebdriverIO.Element) {
// Add any custom properties here, e.g.:
// const customPropertyName = await element.getAttribute("aria-label");
// if (customPropertyName) return custom;
// Get the 'name' property of the element
  const name = await element.getAttribute("name");
  if (name) return name;
  // Get the 'id' property of the element
  const id = await element.getAttribute("id");
  if (id) return id;
  // Get the 'type' property of the element
  const type = await element.getAttribute("type");
  if (type) return type;
  // Get the 'class' property of the element if others are null
  const className = await element.getAttribute("class");
  return className;
}</pre>			<p>You might be wondering, why not create a generic method called <strong class="source-inline">getElementName()</strong> to return the name of any element? The reason is that the properties and prioritizations<a id="_idIndexMarker289"/> can be different, depending on whether we are seeking an input field, a button, a list, or other<a id="_idIndexMarker290"/> <a id="_idTextAnchor151"/>elements. This allows us to optimize<a id="_idIndexMarker291"/> the code execution based<a id="_idIndexMarker292"/> on the <span class="No-Break">element type.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor152"/>Putting it all together</h1>
			<p>Now that we’ve got<a id="_idIndexMarker293"/> all the custom-made parts, let’s put together our superpowered method. These methods will return a success value of <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. We ensure that we have a valid element from the earlier chapter. We will replace tags such as the date with a future or past offset. We will detect whether the field is a password<a id="_idIndexMarker294"/> and mask our value <span class="No-Break">output accordingly:</span></p>
			<pre class="source-code">
export async function setValueAdv(
  inputField: WebdriverIO.Element,
  text: string
) {
  let success: boolean = false;
  inputField = await getValidElement(inputField, "field");
  const SELECTOR = await inputField.selector;
  let newValue: string = replaceTags(text);
  let scrubbedValue: string = newValue
  let fieldName: string = await getFieldName(inputField)
  //Mask Passwords in output
  if (fieldName.includes("ssword") ){
    scrubbedValue = maskValue(scrubbedValue)
  }
  await log(`Entering '${scrubbedValue}' into ${SELECTOR}`);
  try {
    // await element.waitForDisplayed();
    if (!(await isElementInViewport(inputField))) {
      await scrollIntoView(inputField);
      await waitForElementToStopMoving(inputField);
    }
    await highlightOn(inputField);
    //Check if text was entered
    // Clear input field
    await inputField.click();
    // Do we need to clear the field?
    if (await inputField.getValue()) await inputField.setValue(newValue);
    // Send text to input field
    for (const letter of text) {
      await inputField.addValue(letter);
    }
    success = true;
  } catch (error: any) {
    await log(`  ERROR: ${SELECTOR} was not populated with ${scrubbedValue}.\n       ${error.message}`
    );
    expect(`to be editable`).toEqual(SELECTOR);
    // Throw the error to stop the test, still masking password
    await inputField.setValue(scrubbedValue);
  }
  return success;
}</pre>			<p>The following is an example of the masked credentials in <span class="No-Break">our output:</span></p>
			<pre class="source-code">
[0-0] ---&gt; Logging in with user role 'tomsmith'
[0-0] ---&gt; Entering 'tomsmith' into #username
[0-0] ---&gt; Entering 'Su****************d!' into #password</pre>			<p>There are a lot of other features we could implement to customize the data input of our fields. We could use the same technique to inject SQL statements to always pull a valid order number for a search. Strings of random <strong class="source-inline">Corporate Lorem Ipsum</strong> filler words could be populated to check exact field length boundaries. Text with vulgar words could be tested to make sure they get flagged and notification emails are sent to test accounts. Take a few minutes to think about all the types of dynamic and special data that might be available to test<a id="_idIndexMarker295"/> against with an <span class="No-Break">automated framework.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor153"/>Summary</h1>
			<p>In this chapter, we added all sorts of custom-made gadgets to our <strong class="source-inline">setValueAdv() </strong>method. This method delivers a result indicating the success or failure of <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. We conducted a background check to ensure that we had a valid element. Our approach involved wielding the power of time travel by replacing date-related tags with the present, future, or past date offset. We also kept security in mind and made sure to mask our output value when the field in question was a likely <span class="No-Break">credential input.</span></p>
			<p>Next, we will supercharge the <strong class="source-inline">Select()</strong> method with lists <span class="No-Break">and comboboxes.</span></p>
		</div>
	</body></html>