- en: Chapter 5. Routing Best Practices and Subrouting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 路由最佳实践和子路由
- en: A router is one of the most useful objects in Backbone; it is mainly used to
    route application URLs using hash fragments or standard URLs. In the earlier versions
    of Backbone, `Backbone.Controller` was used to take care of routing as well as
    default controller tasks, instead of `Backbone.Router`. Later, it was changed
    to `Backbone.Router`, because the router is meant to only handle routing client
    side pages and connect them to events and actions via URLs, while the functional
    logic must be taken care of by the presenters (that is, Backbone views). The concept
    of a router is pretty straightforward—it matches the method name to the URL fragment
    and calls the method. The method then takes care of the events and actions as
    required.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器是Backbone中最有用的对象之一；它主要用于使用哈希片段或标准URL路由应用程序URL。在Backbone的早期版本中，`Backbone.Controller`被用来处理路由以及默认控制器任务，而不是`Backbone.Router`。后来，它被改为`Backbone.Router`，因为路由器旨在仅处理路由客户端页面并将它们通过URL连接到事件和动作，而功能逻辑必须由演示者（即Backbone视图）负责。路由器的概念相当简单——它将方法名称与URL片段匹配并调用该方法。然后，该方法负责所需的事件和动作。
- en: 'In this chapter, we will learn about some best practices, such as how to organize
    routers for medium- and large-scale applications, and which types of tasks should
    be handled by a router. The main topics to be covered are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些最佳实践，例如如何为中型和大型应用程序组织路由器，以及哪些类型的任务应由路由器处理。主要涵盖的主题如下：
- en: '**Working with routers**: This provides a basic example of how routers work,
    along with an analysis of what can go wrong while working with routers.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与路由器一起工作**：这提供了一个基本示例，说明了路由器的工作原理，以及在使用路由器时可能出现的错误分析。'
- en: '**Best practices for working with routers**: We will look into some good practices
    that one should follow while working with routers.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与路由器一起工作的最佳实践**：我们将探讨一些在使用路由器时应遵循的良好实践。'
- en: '**Subrouting – a key to organize complex apps**: Once your application grows,
    maintaining a single router becomes a mammoth task. Dividing the app router into
    multiple subrouters is a preferable way to manage it.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子路由——组织复杂应用程序的关键**：一旦应用程序增长，维护单个路由器变成了一项艰巨的任务。将应用程序路由器划分为多个子路由是一种更可取的管理方式。'
- en: Working with routers
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与路由器一起工作
- en: 'The Backbone router provides methods to route client-side pages by using hash
    fragments or standard URLs as per the History API. Routes that use the hash fragments
    or History API may look like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone路由器提供方法，通过使用哈希片段或标准URL（根据历史API）来路由客户端页面。使用哈希片段或历史API的路由可能看起来像这样：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The routes and actions that will be triggered when the URL fragment matches
    the specific routes are defined in the `routes` object of the router:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当URL片段与特定路由匹配时将触发路由和动作，这些路由和动作在路由器的`routes`对象中定义：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's see how we can create a basic router. Assume that we are developing
    an application with a few modules, among which the `User` module is an important
    one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建一个基本的路由器。假设我们正在开发一个包含几个模块的应用程序，其中`User`模块是一个重要的模块。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Quite simple! There are a number of options that modify the routes to get the
    expected result. For example, you can use "splats" or optional parts in a route;
    for a detailed overview of routes, refer to the Backbone.js API at [http://backbonejs.org/#Router](http://backbonejs.org/#Router).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单！有许多选项可以修改路由以获得预期的结果。例如，您可以在路由中使用“splat”或可选部分；有关路由的详细概述，请参阅Backbone.js API
    [http://backbonejs.org/#Router](http://backbonejs.org/#Router)。
- en: In the preceding example, all the show methods (`showUsers()` and `showUserDetails()`)
    will most likely create the view instances, send AJAX requests to the server to
    get their details, and then show the views in the DOM. Similarly, the update and
    delete methods will also send requests to the server for the desired actions to
    be taken. Now, assume the `User` module has multiple other methods in this router
    along with these CRUD methods. In addition, the entire application has a number
    of similar modules whose routes will also get added to this router. As a result,
    the router will soon become a gigantic one with hundreds of lines of code; this
    is something that is beyond our control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，所有的显示方法（`showUsers()`和`showUserDetails()`）很可能会创建视图实例，向服务器发送AJAX请求以获取其详细信息，然后在DOM中显示视图。同样，更新和删除方法也会向服务器发送请求以执行所需操作。现在，假设`User`模块在这个路由器中还有其他多个方法，除了这些CRUD方法。此外，整个应用程序还有许多类似的模块，其路由也将添加到这个路由器中。结果，路由器很快就会变得庞大，有数百行代码；这是超出我们控制范围的事情。
- en: We should take care of a few things while working with routers and avoid such
    situations. We will look at some good practices in the following section that
    will make our routers simple, flexible, and easy-to-maintain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在与路由器一起工作时，我们应该注意一些事项，以避免出现此类情况。在下一节中，我们将探讨一些良好的实践，这些实践将使我们的路由器变得简单、灵活且易于维护。
- en: Best practices for working with routers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与路由器一起工作的最佳实践
- en: Working with a Backbone router is fairly easy when the application is of a small
    size. However, as the complexity increases, maintaining a router becomes difficult
    unless some rules are followed. In the following section, we will discuss some
    points that you should take care of while using routers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序规模较小时，使用骨干路由器相对容易。然而，随着复杂性的增加，除非遵循某些规则，否则维护路由器会变得困难。在下一节中，我们将讨论在使用路由器时应注意的一些要点。
- en: Avoiding large functional code in route methods
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在路由方法中使用大量功能代码
- en: Though the basic task of a router is to monitor the routes and trigger functions,
    it manages some business logics of the app too. In an MVC architecture, the task
    of a controller is to handle the data request that is sent from the client and
    work upon the data that comes from the server in response. Similarly for a router,
    since the URL fragments reflect some part of the application's data, the data
    communication, calling view methods, or updating model attributes are done using
    router methods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管路由器的基本任务是监控路由并触发函数，但它也管理应用程序的一些业务逻辑。在MVC架构中，控制器的任务是处理客户端发送的数据请求，并处理从服务器响应中来的数据。同样，对于路由器，由于URL片段反映了应用程序数据的一部分，数据通信、调用视图方法或更新模型属性都是通过路由器方法完成的。
- en: A trend I often see in beginner-level developer code is that they frequently
    include a large chunk of functional code inside the router methods. On one hand,
    this increases the size of the router, and on the other hand, it complicates the
    logic. It is always advisable to keep your router methods as short as possible
    by pushing the functional logic in views and using events instead of callbacks.
    In the following section we will see how we can keep our router clean. Also, we
    will look at event delegation, custom events, and callback methods in more detail
    in [Chapter 6](ch06.html "Chapter 6. Working with Events, Sync, and Storage"),
    *Working with Events, Storage, and Sync*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我在初级开发者代码中经常看到的一个趋势是，他们经常在路由器方法中包含大量功能代码。一方面，这增加了路由器的大小，另一方面，它也复杂化了逻辑。始终建议尽可能保持路由器方法尽可能短，通过将功能逻辑推送到视图并使用事件而不是回调来实现。在下一节中，我们将看到如何保持我们的路由器整洁。此外，我们将在[第6章](ch06.html
    "第6章。与事件、同步和存储一起工作")“与事件、存储和同步一起工作”中更详细地探讨事件委托、自定义事件和回调方法。
- en: Instantiating views in router methods
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在路由器方法中实例化视图
- en: 'I have seen many developers who instantiate their application views inside
    router methods. While there is no such restriction in instantiating views or modifying
    DOM elements in router methods, it is a good practice to avoid such operations
    in routers. This is somewhat related to the first point that I mentioned in this
    section. In the following code, we have instantiated a `UserView` class and rendered
    it in the DOM inside the router method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过许多开发者将应用程序视图实例化在路由器方法中。虽然在这种情况下在路由器方法中实例化视图或修改DOM元素没有限制，但避免在路由器中执行此类操作是一种良好的实践。这与我在本节中提到的第一个要点有些相关。在下面的代码中，我们实例化了一个`UserView`类，并在路由器方法中将其渲染到DOM中：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This looks simple and works perfectly. But will it not clutter the router if
    there are 20 or more such methods? Why not create a controller or a high-level
    application object and add the method there? Then you can call this controller
    method from the router method as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，并且工作得完美。但是，如果有20个或更多这样的方法，它不会使路由器变得杂乱吗？为什么不创建一个控制器或高级应用程序对象，并将方法添加到那里？然后你可以从路由器方法中调用这个控制器方法，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now any change in the `showUsers()` method functionality will not force you
    to touch the router. There's really not much of a visible difference—but personally,
    as I have used the second pattern several times and benefited from it, I can guarantee
    you that the separation of concern will produce a much cleaner router along with
    a maintainable code base.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对`showUsers()`方法功能性的任何更改都不会强迫你接触路由器。实际上，并没有太大的可见差异——但就我个人而言，因为我已经多次使用第二种模式并从中受益，我可以向你保证，关注点的分离将产生一个更干净的路由器，以及可维护的代码库。
- en: Also, in this context, we recommend you check out `Marionette.AppRouter` ([https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md))
    and `Marionette.Controller` ([https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md)).
    Marionette `AppRouter` and `Controller` work in the same way as our `UserController`
    and the base router. The controller actually does the work (such as assembling
    the data, instantiating the view, displaying them in regions) and can update the
    URL to reflect the application's state (for example, displayed content). The router
    simply triggers the controller action based on the URL that has been entered in
    the address bar. Both these classes are quite useful, and you can go for either
    of them if needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在此上下文中，我们建议你查看`Marionette.AppRouter` ([https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md))
    和 `Marionette.Controller` ([https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md))。Marionette的`AppRouter`和`Controller`与我们的`UserController`和基础路由器工作方式相同。控制器实际上执行工作（例如组装数据、实例化视图、在区域中显示它们）并可以更新URL以反映应用程序的状态（例如，显示的内容）。路由器只是根据在地址栏中输入的URL触发控制器动作。这两个类都非常有用，如果需要，你可以选择其中的任何一个。
- en: Using regular expressions for selective routing
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用正则表达式进行选择性路由
- en: If you want to trigger a router method only when a specific condition is matched,
    a **regular expression** comes to the rescue. Regular expressions are flexible
    with routes and Backbone supports them completely. In fact, all of the routes
    are first converted into `RegExp` objects when they are added to the routing table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想在特定条件匹配时触发路由器方法，正则表达式就能派上用场。正则表达式在路由方面非常灵活，Backbone完全支持它们。实际上，当它们被添加到路由表时，所有的路由首先都会被转换为`RegExp`对象。
- en: 'However, JavaScript will not allow you to add a regular expression as a property
    of the `routes` object, unlike the other string URL fragments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其它字符串URL片段不同，JavaScript不允许你将正则表达式作为`routes`对象的属性添加：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The solution is that you can add the regular expression in the `routes` object
    in the `initialize()` method of the router:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在路由器的`initialize()`方法中的`routes`对象中添加正则表达式：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is an example where only numbers are allowed in the URL fragment after
    `#user`. If you try to open a URL ending with `#user/abc`, the `showUserDetails()`
    method will not be called, but with the URL fragment `#user/123`, the same method
    will be triggered. So, this is a very generic example of using a regular expression
    as a route. Regular expressions are very useful for more complex levels of URL
    fragments in order to provide a level of restriction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，其中在`#user`之后的URL片段中只允许使用数字。如果你尝试打开以`#user/abc`结尾的URL，`showUserDetails()`方法将不会被调用，但使用URL片段`#user/123`时，将触发相同的方法。因此，这是一个使用正则表达式作为路由的非常通用的例子。正则表达式对于更复杂的URL片段级别非常有用，以便提供一种限制级别。
- en: Subrouting – a key to organizing complex apps
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子路由——组织复杂应用程序的关键
- en: Subrouting is the idea of dividing an application's router into a number of
    module-specific routers. In a small- or medium-level application, you may never
    need something like this. However, for an application with multiple modules, a
    single router that handles all of the routes soon turns into a huge, unmanageable
    class. So, it is always preferable to split the main router into a set of module-specific
    routers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 子路由是将应用程序的路由器划分为多个特定模块路由器的想法。在小型或中型应用程序中，你可能永远不需要这样的东西。然而，对于具有多个模块的应用程序，处理所有路由的单个路由器很快就会变成一个庞大且难以管理的类。因此，总是将主路由器拆分为一组特定模块的路由器更为可取。
- en: '`Backbone.Subroute` ([https://github.com/ModelN/backbone.subroute](https://github.com/ModelN/backbone.subroute)),
    a wonderful extension developed by Dave Cadwallader, provides the functionality
    that we are talking about. It lets the base router delegate all of the module-specific
    routes to the subrouter associated with that module. Let''s understand the difference
    between a router and subrouter with the two examples that follow.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.Subroute` ([https://github.com/ModelN/backbone.subroute](https://github.com/ModelN/backbone.subroute))，由Dave
    Cadwallader开发的一个出色的扩展，提供了我们所讨论的功能。它允许基础路由器将所有特定模块的路由委托给与该模块关联的子路由器。让我们通过以下两个示例来了解路由器和子路由器之间的区别。'
- en: The all-in-one router
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一体化路由器
- en: 'The following is the code for a single router that handles the routes of all
    the modules of an application:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为处理应用程序中所有模块路由的单个路由器编写的代码：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's use `Backbone.Subroute` and see how to define the base router and
    module-specific routers. With `Subroute`, the base router becomes a tiny router
    that only takes care of the router redirections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `Backbone.Subroute` 来看看如何定义基础路由器和特定模块路由器。使用 `Subroute`，基础路由器变成了一个微小的路由器，它只负责路由重定向。
- en: The base router
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础路由器
- en: 'The following is the code for the base router:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为基础路由器编写的代码：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Users module router
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Users 模块路由器
- en: 'The following is the code for the `Users` module router:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 `Users` 模块路由器编写的代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Look at the base router. What we are doing here is pretty simple—we use a wildcard
    (or splat) to trigger a method that lazily instantiates a subrouter and passes
    the initial parameter of the hash. Now, because `Backbone.Subroute` extends Backbone's
    `Router` class, we can expect that anything passed after /`users/` or `/company/`
    should be taken care of by the respective subrouter, that is, `App.UsersRouter`
    or `App.CompanyRouter`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 看看基础路由器。我们在这里做的事情非常简单——我们使用通配符（或splat）来触发一个懒加载实例化子路由器并传递哈希的初始参数。现在，因为 `Backbone.Subroute`
    扩展了 Backbone 的 `Router` 类，我们可以预期在 `/users/` 或 `/company/` 之后传递的任何内容都应该由相应的子路由器处理，即
    `App.UsersRouter` 或 `App.CompanyRouter`。
- en: We can add as many subrouters as we want and the base router won't care about
    it. Similarly, the subrouters do not know what prefix they have. Any changes in
    the module name or prefix should be done only in the base router without modifying
    the related subrouter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加任意多的子路由器，而基础路由器不会关心它们。同样，子路由器也不知道它们的前缀是什么。模块名称或前缀的任何更改都应该仅在基础路由器中进行，而无需修改相关的子路由器。
- en: '`Backbone.Subroute` is a small yet excellent plugin that you should always
    include in your application to keep your base router clean. The more modules get
    added to your application, the more you will understand the benefit of subrouters.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.Subroute` 是一个小巧而优秀的插件，你应该始终将其包含在你的应用程序中，以保持你的基础路由器整洁。随着你的应用程序中模块的增加，你会越来越理解子路由器的优势。'
- en: Summary
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The functionality of the Backbone router is quite simple and easy to learn.
    For a simple application, you will not find any problems in maintaining it. The
    issues will start creeping in once your application grows and your router becomes
    huge. In this chapter, we discussed the best practices of router management, those
    that you should always adhere to. We also learned about subrouting, which helps
    by splitting up the main router into multiple module-specific routers and dividing
    the tasks among them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 路由器的功能非常简单且易于学习。对于简单的应用程序，你将不会在维护它时遇到任何问题。一旦你的应用程序增长并且路由器变得庞大，问题就会逐渐出现。在本章中，我们讨论了路由器管理的最佳实践，那些你应该始终遵守的。我们还学习了子路由，它通过将主路由器拆分为多个特定模块的路由器并分配任务来提供帮助。
- en: In the next chapter, we will discuss Backbone events, custom events, storages,
    and sync.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Backbone 事件、自定义事件、存储和同步。
