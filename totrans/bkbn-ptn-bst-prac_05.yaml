- en: Chapter 5. Routing Best Practices and Subrouting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A router is one of the most useful objects in Backbone; it is mainly used to
    route application URLs using hash fragments or standard URLs. In the earlier versions
    of Backbone, `Backbone.Controller` was used to take care of routing as well as
    default controller tasks, instead of `Backbone.Router`. Later, it was changed
    to `Backbone.Router`, because the router is meant to only handle routing client
    side pages and connect them to events and actions via URLs, while the functional
    logic must be taken care of by the presenters (that is, Backbone views). The concept
    of a router is pretty straightforward—it matches the method name to the URL fragment
    and calls the method. The method then takes care of the events and actions as
    required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about some best practices, such as how to organize
    routers for medium- and large-scale applications, and which types of tasks should
    be handled by a router. The main topics to be covered are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with routers**: This provides a basic example of how routers work,
    along with an analysis of what can go wrong while working with routers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices for working with routers**: We will look into some good practices
    that one should follow while working with routers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subrouting – a key to organize complex apps**: Once your application grows,
    maintaining a single router becomes a mammoth task. Dividing the app router into
    multiple subrouters is a preferable way to manage it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Backbone router provides methods to route client-side pages by using hash
    fragments or standard URLs as per the History API. Routes that use the hash fragments
    or History API may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The routes and actions that will be triggered when the URL fragment matches
    the specific routes are defined in the `routes` object of the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how we can create a basic router. Assume that we are developing
    an application with a few modules, among which the `User` module is an important
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Quite simple! There are a number of options that modify the routes to get the
    expected result. For example, you can use "splats" or optional parts in a route;
    for a detailed overview of routes, refer to the Backbone.js API at [http://backbonejs.org/#Router](http://backbonejs.org/#Router).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, all the show methods (`showUsers()` and `showUserDetails()`)
    will most likely create the view instances, send AJAX requests to the server to
    get their details, and then show the views in the DOM. Similarly, the update and
    delete methods will also send requests to the server for the desired actions to
    be taken. Now, assume the `User` module has multiple other methods in this router
    along with these CRUD methods. In addition, the entire application has a number
    of similar modules whose routes will also get added to this router. As a result,
    the router will soon become a gigantic one with hundreds of lines of code; this
    is something that is beyond our control.
  prefs: []
  type: TYPE_NORMAL
- en: We should take care of a few things while working with routers and avoid such
    situations. We will look at some good practices in the following section that
    will make our routers simple, flexible, and easy-to-maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for working with routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with a Backbone router is fairly easy when the application is of a small
    size. However, as the complexity increases, maintaining a router becomes difficult
    unless some rules are followed. In the following section, we will discuss some
    points that you should take care of while using routers.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding large functional code in route methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though the basic task of a router is to monitor the routes and trigger functions,
    it manages some business logics of the app too. In an MVC architecture, the task
    of a controller is to handle the data request that is sent from the client and
    work upon the data that comes from the server in response. Similarly for a router,
    since the URL fragments reflect some part of the application's data, the data
    communication, calling view methods, or updating model attributes are done using
    router methods.
  prefs: []
  type: TYPE_NORMAL
- en: A trend I often see in beginner-level developer code is that they frequently
    include a large chunk of functional code inside the router methods. On one hand,
    this increases the size of the router, and on the other hand, it complicates the
    logic. It is always advisable to keep your router methods as short as possible
    by pushing the functional logic in views and using events instead of callbacks.
    In the following section we will see how we can keep our router clean. Also, we
    will look at event delegation, custom events, and callback methods in more detail
    in [Chapter 6](ch06.html "Chapter 6. Working with Events, Sync, and Storage"),
    *Working with Events, Storage, and Sync*.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating views in router methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I have seen many developers who instantiate their application views inside
    router methods. While there is no such restriction in instantiating views or modifying
    DOM elements in router methods, it is a good practice to avoid such operations
    in routers. This is somewhat related to the first point that I mentioned in this
    section. In the following code, we have instantiated a `UserView` class and rendered
    it in the DOM inside the router method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks simple and works perfectly. But will it not clutter the router if
    there are 20 or more such methods? Why not create a controller or a high-level
    application object and add the method there? Then you can call this controller
    method from the router method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now any change in the `showUsers()` method functionality will not force you
    to touch the router. There's really not much of a visible difference—but personally,
    as I have used the second pattern several times and benefited from it, I can guarantee
    you that the separation of concern will produce a much cleaner router along with
    a maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in this context, we recommend you check out `Marionette.AppRouter` ([https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md))
    and `Marionette.Controller` ([https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md)).
    Marionette `AppRouter` and `Controller` work in the same way as our `UserController`
    and the base router. The controller actually does the work (such as assembling
    the data, instantiating the view, displaying them in regions) and can update the
    URL to reflect the application's state (for example, displayed content). The router
    simply triggers the controller action based on the URL that has been entered in
    the address bar. Both these classes are quite useful, and you can go for either
    of them if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions for selective routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to trigger a router method only when a specific condition is matched,
    a **regular expression** comes to the rescue. Regular expressions are flexible
    with routes and Backbone supports them completely. In fact, all of the routes
    are first converted into `RegExp` objects when they are added to the routing table.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JavaScript will not allow you to add a regular expression as a property
    of the `routes` object, unlike the other string URL fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is that you can add the regular expression in the `routes` object
    in the `initialize()` method of the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is an example where only numbers are allowed in the URL fragment after
    `#user`. If you try to open a URL ending with `#user/abc`, the `showUserDetails()`
    method will not be called, but with the URL fragment `#user/123`, the same method
    will be triggered. So, this is a very generic example of using a regular expression
    as a route. Regular expressions are very useful for more complex levels of URL
    fragments in order to provide a level of restriction.
  prefs: []
  type: TYPE_NORMAL
- en: Subrouting – a key to organizing complex apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subrouting is the idea of dividing an application's router into a number of
    module-specific routers. In a small- or medium-level application, you may never
    need something like this. However, for an application with multiple modules, a
    single router that handles all of the routes soon turns into a huge, unmanageable
    class. So, it is always preferable to split the main router into a set of module-specific
    routers.
  prefs: []
  type: TYPE_NORMAL
- en: '`Backbone.Subroute` ([https://github.com/ModelN/backbone.subroute](https://github.com/ModelN/backbone.subroute)),
    a wonderful extension developed by Dave Cadwallader, provides the functionality
    that we are talking about. It lets the base router delegate all of the module-specific
    routes to the subrouter associated with that module. Let''s understand the difference
    between a router and subrouter with the two examples that follow.'
  prefs: []
  type: TYPE_NORMAL
- en: The all-in-one router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the code for a single router that handles the routes of all
    the modules of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's use `Backbone.Subroute` and see how to define the base router and
    module-specific routers. With `Subroute`, the base router becomes a tiny router
    that only takes care of the router redirections.
  prefs: []
  type: TYPE_NORMAL
- en: The base router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the code for the base router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Users module router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the code for the `Users` module router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Look at the base router. What we are doing here is pretty simple—we use a wildcard
    (or splat) to trigger a method that lazily instantiates a subrouter and passes
    the initial parameter of the hash. Now, because `Backbone.Subroute` extends Backbone's
    `Router` class, we can expect that anything passed after /`users/` or `/company/`
    should be taken care of by the respective subrouter, that is, `App.UsersRouter`
    or `App.CompanyRouter`.
  prefs: []
  type: TYPE_NORMAL
- en: We can add as many subrouters as we want and the base router won't care about
    it. Similarly, the subrouters do not know what prefix they have. Any changes in
    the module name or prefix should be done only in the base router without modifying
    the related subrouter.
  prefs: []
  type: TYPE_NORMAL
- en: '`Backbone.Subroute` is a small yet excellent plugin that you should always
    include in your application to keep your base router clean. The more modules get
    added to your application, the more you will understand the benefit of subrouters.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality of the Backbone router is quite simple and easy to learn.
    For a simple application, you will not find any problems in maintaining it. The
    issues will start creeping in once your application grows and your router becomes
    huge. In this chapter, we discussed the best practices of router management, those
    that you should always adhere to. We also learned about subrouting, which helps
    by splitting up the main router into multiple module-specific routers and dividing
    the tasks among them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss Backbone events, custom events, storages,
    and sync.
  prefs: []
  type: TYPE_NORMAL
