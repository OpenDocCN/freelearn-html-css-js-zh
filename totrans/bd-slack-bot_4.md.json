["```js\nwhich brew\n\n```", "```js\n/usr/bin/ruby -e \"$(curl –fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n```", "```js\nbrew install redis\n\n```", "```js\nredis-server\n\n```", "```js\nnpm install redis\n\n```", "```js\n'use strict';\n\nconst redis = require('redis');\nconst Bot = require('./Bot');\n\nconst client = redis.createClient();\n\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n\nclient.on('error', (err) => {\n    console.log('Error ' + err);\n});\n\nclient.on('connect', () => {\n  console.log('Connected to Redis!');\n});\n```", "```js\nlet client = redis.createClient(port, host);\n```", "```js\nSLACK_TOKEN=[your_token_here] node index.js\n\n```", "```js\nclient.set('hello', 'Hello World!');\n\nclient.get('hello', (err, reply) => {\n  if (err) {\n    console.log(err);\n    return;\n  }\n\n  console.log(`Retrieved: ${reply}`);\n});\n```", "```js\nlet val = client.get('hello');\nconsole.log('val:', val);\n```", "```js\nval: false\n\n```", "```js\nclient.set('hello', 'Hello World!', redis.print);\n\nclient.get('hello', redis.print);\n```", "```js\nReply: OK\nReply: Hello World!\n\n```", "```js\nbot.respondTo('store', (message, channel, user) => {\n  let msg = getArgs(message.text);\n\n  client.set(user.name, msg, (err) => {\n    if (err) {\n      channel.send('Oops! I tried to store that but something went wrong :(');\n    } else {\n      channel.send(`Okay ${user.name}, I will remember that for you.`);\n    }\n  });\n}, true);\n\nbot.respondTo('retrieve', (message, channel, user) => {\n  bot.setTypingIndicator(message.channel);\n\n  client.get(user.name, (err, reply) => {\n    if (err) {\n     console.log(err);\n     return;\n    }\n\n    channel.send('Here\\'s what I remember: ' + reply);\n  });\n});\n```", "```js\nbot.respondTo('store', (message, channel, user) => {\n  let args = getArgs(message.text);\n\n let key = args.shift();\n let value = args.join(' ');\n\n client.set(key, value, (err) => {\n if (err) {\n channel.send('Oops! I tried to store something but something went wrong :(');\n } else {\n channel.send(`Okay ${user.name}, I will remember that for you.`);\n }\n });\n}, true);\n\nbot.respondTo('retrieve', (message, channel, user) => {\n  bot.setTypingIndicator(message.channel);\n\n  let key = getArgs(message.text).shift();\n\n  client.get(key, (err, reply) => {\n    if (err) {\n     console.log(err);\n     channel.send('Oops! I tried to retrieve something but something went wrong :(');\n     return;\n    }\n\n    channel.send('Here\\'s what I remember: ' + reply);\n  });\n});\n```", "```js\nstore [key] [value]\n\n```", "```js\nlet obj = {\n  foo: 'bar',\n  baz: {\n    foobar: 'bazfoo'\n  }\n};\n```", "```js\nclient.hmset('obj', obj);\n```", "```js\nclient.hgetall('obj', (err, object) => {\n  console.log(object);\n});\n```", "```js\n{ foo: 'bar', baz: '[object Object]' }\n```", "```js\nlet obj = {\n  foo: 'bar',\n  baz: {\n    foobar: 'bazfoo'\n  }\n};\n\nfunction stringifyNestedObjects(obj) {\n  for (let k in obj) {\n    if (obj[k] instanceof Object) {\n      obj[k] = JSON.stringify(obj[k]);  \n    }\n  }\n\n  return obj;\n}\n\nfunction parseNestedObjects(obj) {\n  for (let k in obj) {\n    if (typeof obj[k] === 'string' || obj[k] instanceof String) {\n      try {\n        obj[k] = JSON.parse(obj[k]);\n      } catch(e) {\n        // string wasn't a stringified object, so fail silently\n      }      \n    }\n  }\n\n  return obj;\n}\n\nclient.hmset('obj', stringifyNestedObjects(obj));\n\nclient.hgetall('obj', (err, object) => {\n  console.log(parseNestedObjects(object));\n});\n```", "```js\n{ foo: 'bar', baz: { foobar: 'bazfoo' } }\n```", "```js\nclient.rpush('heroes', ['batman', 'superman', 'spider-man']);\n```", "```js\nclient.lpush('heroes', 'iron-man');\n```", "```js\n[ 'iron-man', 'batman', 'superman', 'spider-man' ]\n```", "```js\nclient.lrange('heroes', 0, -1, (err, list) => {\n  console.log(list);\n});\n```", "```js\nclient.sadd('fruits', ['apples', 'bananas', 'oranges']);\nclient.sadd('fruits', 'bananas');\n\nclient.smembers('fruits', (err, set) => {\n  console.log(set);\n});\n```", "```js\n[ 'oranges', 'apples', 'bananas' ]\n```", "```js\nclient.zadd('scores', [3, 'paul', 2, 'caitlin', 1, 'alex']);\n\nclient.zrange('scores', 0, -1, (err, set) => {\n  console.log(set);\n});\n\nclient.zrevrange('scores', 0, -1, 'withscores', (err, set) => {\n  console.log(set);\n});\n```", "```js\n[ score, value, score, value ... ]\n```", "```js\n[ 'alex', 'caitlin', 'paul' ]\n```", "```js\n[ 'paul', '3', 'caitlin', '2', 'alex', '1' ]\n```", "```js\nbot.respondTo('roll', (message, channel, user) => {\n  // get the members of the channel\n  const members = bot.getMembersByChannel(channel);\n\n  // make sure there actually members to interact with. If there\n  // aren't then it usually means that the command was given in a  \n  // direct message\n  if (!members) {\n    channel.send('You have to challenge someone in a channel, not a direct message!');\n    return;\n  }\n\n  // get the arguments from the message body\n  let args = getArgs(message.text);\n\n  // if args is empty, return with a warning\n  if (args.length < 1) {\n    channel.send('You have to provide the name of the person you wish to challenge!');\n    return;\n  }\n\n  // the user shouldn't challenge themselves\n  if (args.indexOf(user.name) > -1) {\n    channel.send(`Challenging yourself is probably not the best use of your or my time, ${user.name}`);\n    return;\n  }\n\n  // does the opponent exist in this channel?\n  if (members.indexOf(args[0]) < 0) {\n    channel.send(`Sorry ${user.name}, but I either can't find ${args[0]} in this channel, or they are a bot!`);\n    return;\n  }\n\n  // Roll two random numbers between 0 and 100\n  let firstRoll = Math.round(Math.random() * 100);\n  let secondRoll = Math.round(Math.random() * 100);\n\n  let challenger = user.name;\n  let opponent = args[0];\n\n  // reroll in the unlikely event that it's a tie\n  while (firstRoll === secondRoll) {\n    secondRoll = Math.round(Math.random() * 100);\n  }\n\n  let winner = firstRoll > secondRoll ? challenger : opponent;\n\n client.zincrby('rollscores', 1, winner);\n\n  // Using new line characters (\\n) to format our response\n  channel.send(\n    `${challenger} fancies their changes against ${opponent}!\\n\n    ${challenger} rolls: ${firstRoll}\\n\n    ${opponent} rolls: ${secondRoll}\\n\\n\n    *${winner} is the winner!*`\n  );\n\n}, true);\n```", "```js\nbot.respondTo('scoreboard', (message, channel) => {\n  client.zrevrange('rollscores', 0, -1, 'withscores', (err, set) => {\n    if (err) {\n      channel.send('Oops, something went wrong! Please try again later');\n      return;\n    }\n\n    let scores = [];\n\n    // format the set into something a bit easier to use\n    for (let i = 0; i < set.length; i++) {\n      scores.push([set[i], set[i + 1]]);\n      i++;\n    }\n\n    channel.send('The current scoreboard is:');\n    scores.forEach((score, index) => {\n      channel.send(`${index + 1}. ${score[0]} with ${score[1]} points.`);\n    });\n  });\n}, true);\n```", "```js\n[ NAME, SCORE, NAME2, SCORE2, NAME3, SCORE3, …]\n```", "```js\n[ [NAME, SCORE], [NAME2, SCORE2], [NAME3, SCORE3], …]\n```", "```js\nbot.respondTo('scoreboard', (message, channel, user) => {\n  let args = getArgs(message.text);\n\n if (args[0] === 'wipe') {\n client.del('rollscores');\n channel.send('The scoreboard has been wiped!');\n return;\n }\n\n  client.zrevrange('rollscores', 0, -1, 'withscores', (err, set) => {\n    if (err) {\n      channel.send('Oops, something went wrong! Please try again later');\n      return;\n    }\n\n if (set.length < 1) {\n channel.send('No scores yet! Challenge each other with the \\`roll\\` command!');\n return;\n }\n\n    let scores = [];\n\n    // format the set into something a bit easier to use\n    for (let i = 0; i < set.length; i++) {\n      scores.push([set[i], set[i + 1]]);\n      i++;\n    }\n\n    channel.send('The current scoreboard is:');\n    scores.forEach((score, index) => {\n      channel.send(`${index + 1}. ${score[0]} with ${score[1]} points.`);\n    });\n  });\n}, true);\n```", "```js\nbot.respondTo('todo', (message, channel, user) => {\n  let args = getArgs(message.text);\n\n  switch(args[0]) {\n    case 'add':\n\n      break;\n\n    case 'complete':\n\n      break;\n\n    case 'delete':\n\n      break;\n\n    case 'help':\n      channel.send('Create tasks with \\`todo add [TASK]\\`, complete them with \\`todo complete [TASK_NUMBER]\\` and remove them with \\`todo delete [TASK_NUMBER]\\` or \\`todo delete all\\`');\n      break;\n\n    default:\n      showTodos(user.name, channel);\n      break;\n  }\n}, true);\n\nfunction showTodos(name, channel) {\n  client.smembers(name, (err, set) => {\n    if (err || set.length < 1) {\n      channel.send(`You don\\'t have any tasks listed yet, ${name}!`);\n      return;\n    }\n\n    channel.send(`${name}'s to-do list:`);\n\n    set.forEach((task, index) => {\n      channel.send(`${index + 1}. ${task}`);\n    });\n  });\n}\n```", "```js\ncase 'add':\n  addTask(user.name, args.slice(1).join(' '), channel);\n     break;\n```", "```js\nfunction addTask(name, task, channel) {\n  if (task === '') {\n    channel.send('Usage: \\`todo add [TASK]\\`');\n    return;\n  }\n\n  client.sadd(name, task);\n  channel.send('You added a task!');\n  showTodos(name, channel);\n}\n```", "```js\ncase 'complete':\n  completeTask(user.name, parseInt(args[1], 10), channel);\n  break;\n```", "```js\nfunction completeTask(name, taskNum, channel) {\n  if (Number.isNaN(taskNum)) {\n    channel.send('Usage: \\`todo complete [TASK_NUMBER]\\`');\n    return;\n  }\n\n  client.smembers(name, (err, set) => {\n    if (err || set.length < 1) {\n      channel.send(`You don\\'t have any tasks listed yet, ${user.name}!`);\n      return;\n    }\n\n    // make sure no task numbers that are out of bounds are given\n    if (taskNum > set.length || taskNum <= 0) {\n      channel.send('Oops, that task doesn\\'t exist!');\n      return;\n    }\n\n    let task = set[taskNum - 1];\n\n    if (/~/i.test(task)) {\n      channel.send('That task has already been completed!');\n      return;\n    }\n\n    // remove the task from the set\n    client.srem(name, task);\n\n    // re-add the task, but with a strikethrough effect\n    client.sadd(name, `~${task}~`);\n\n    channel.send('You completed a task!');\n    showTodos(name, channel);\n  });\n}\n```", "```js\ncase 'delete':\n      removeTaskOrTodoList(user.name, args[1], channel);\n      break;\n```", "```js\nfunction removeTaskOrTodoList(name, target, channel) {\n  if (typeof target === 'string' && target === 'all') {\n    client.del(name);\n    channel.send('To-do list cleared!');\n    return;\n  }\n\n  let taskNum = parseInt(target, 10);\n\n  if (Number.isNaN(taskNum)) {\n    channel.send('Usage: \\`todo delete [TASK_NUMBER]\\` or \\`todo delete all\\`');\n    return;\n  }\n\n  // get the set and the exact task\n  client.smembers(name, (err, set) => {\n    if (err || set.length < 1) {\n      channel.send(`You don\\'t have any tasks to delete, ${name}!`);\n      return;\n    }\n\n    if (taskNum > set.length || taskNum <= 0) {\n      channel.send('Oops, that task doesn\\'t exist!');\n      return;\n    }\n\n    client.srem(name, set[taskNum - 1]);\n    channel.send('You deleted a task!');\n    showTodos(name, channel);\n  });\n}\n```"]