- en: Chapter 7. Build Like a Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some years ago, you could create a website with PHP, upload your source files
    through FTP to a server, and then go online. During those days, JavaScript was
    a tight piece of the whole system, used for UI tasks such as validating forms
    or small chunks of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Today, web is more JavaScript intensive, we are building web applications instead
    websites, this means that JavaScript is no more a trivial piece of applications,
    it is now a core piece. For this reason, it is important to pack our JavaScript
    application before being deployed for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a workflow to automatically process your source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minifying the application script size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minifying the number of requests to the server when the application is loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minifying the images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the CSS files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring up everything in an HTML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a development environment to automatically reload the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the time of writing this book, there are many tools to build JavaScript
    applications; however, two of them are the most popular: Grunt and Gulp. Grunt
    is an older choice with a big community around and an amazing collection of plugins
    available. Gulp, on the other hand, is gaining more popularity each day and almost
    has the most popular plugins that exist for Grunt.'
  prefs: []
  type: TYPE_NORMAL
- en: Development workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are developing an application, some tasks are very repetitive; for
    example, our contacts application uses Browserify to manage dependencies. It needs
    to rebundle the source code every time you make a change, which means that you
    need to run the `browserify` command each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To run these commands every time you make a small change is a very tedious
    task, there should be a better way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Development workflow](img/B01962_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1\. Development workflow
  prefs: []
  type: TYPE_NORMAL
- en: The above figure shows the ideal development process; the first time you run
    the application, you should bundle the source files and run the BrowserSync web
    server and then open the browser. After that, for any change that you make in
    any source file, the application should be rebundled and then the browser should
    be refreshed to get the new changes.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we are manually doing this process; however, in the next section,
    you will learn how to automatize this task to let the machine do all this for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: What's a task runner?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A task runner is computer program that runs a sequence of tasks over your source
    code, applying transformations to the files. For example, consider that you are
    writing a source code in the CoffeeScript programming language, one task would
    be compiling all your source code in JavaScript, other task can be concatenating
    all the output JavaScript files in a single file, and the third task can finally
    be minifying the concatenated file to minimize the file size.
  prefs: []
  type: TYPE_NORMAL
- en: These tasks will automatically be run by the task runner, you just need to write
    a script file to program what needs to be done and then forget to run any command
    line again. The task runner provides triggers to start a task whenever you change
    a file so that it is done transparently.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a task runner can improve your productivity as you can forget
    about the details of the compilation process once you have correctly configured
    a task runner. It will allow you to automate all these repetitive and boring tasks
    and then, you can focus on product development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grunt and Gulp are the most popular task runners for JavaScript; they take
    different approach to run the tasks. In Grunt, the tasks are run sequentially:
    once a task is running, the next task cannot start until the first is done. In
    Gulp, the tasks can run parallel to each other, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What''s a task runner?](img/B01962_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 Different approach on running task by Grunt and Gulp
  prefs: []
  type: TYPE_NORMAL
- en: The above figure illustrates how Grunt and Gulp will run three tasks. Task B
    depends on whether Task A and Task C are done. Note that Grunt can run the tasks
    parallel to each other using plugins. While, Gulp does this from its core design.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between Grunt and Gulp is that, in Grunt, you can configure
    the tasks on writing a big configuration object. While, in Gulp, you will write
    standard JavaScript functions. An interesting point is that Grunt and Gulp can
    work together in the same project; however, it is better to choose just one of
    them in order to reduce complexity.
  prefs: []
  type: TYPE_NORMAL
- en: If your project uses Grunt, you should not switch to Gulp unless have a good
    reason to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How Gulp works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned at the beginning of the chapter, Gulp is the most popular JavaScript
    task runner at the time of writing this book and that's the main reason why we
    chose it. Gulp and Grunt work in a similar way, they both use third-party plugins
    to work. Keep in mind that Gulp is more like a framework, it does not make too
    much by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gulp acts as the glue that coordinates the build workflow; it has some basic
    functionality and an API, which the Gulp plugins can use to do their work. The
    plugins use the compilers and utility programs that make the real file processing,
    such as the CoffeeScript transpiler. The plugins connect these programs to the
    Gulp workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Gulp works](img/B01962_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 Relationship between Gulp plugins and libraries
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the relationship that was described earlier, you
    can get a better idea of how Gulp connects with its plugins; notice how the plugins
    delegate the file processing to the utility programs that they connect to.
  prefs: []
  type: TYPE_NORMAL
- en: Gulp is composed of several named tasks where each task can have dependencies
    on other tasks. A typical Gulp task opens a stream of files at the beginning and
    applies transformation to each file in the stream with the installed plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stream is opened with the `gulp.src()` method. It starts a stream that you
    can connect to several pipes in order to apply the necessary transformations.
    When you open a stream, you need to specify the target files that will be used
    in the stream. You will select these files using the `node-glob format`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easy to specify the files for the stream, it is similar to what you do
    in the command line. The figure below shows how the stream and pipes are connected.
    The files that are selected are streamed into the Gulp plugins, they make the
    transformations and put the output back in the stream, the next plugin can then
    make its work, and put the result back in the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Gulp works](img/B01962_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 Using node-blob to select files
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the pipe, you will normally write the result in a file that is
    ready to be used. You can put as many Gulp tasks as you need and each task can
    have as many dependencies as it needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, install the Gulp package globally; this will give you access
    to the `gulp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have installed Gulp globally, you will need to install it in your
    local project in order to have access to the Gulp core utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure the Gulp tasks, you will need to create a file called `gulpfile.js`
    that Gulp will read every time you run the `gulp` command. All Gulp tasks have
    a name and a function that is executed when the task is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following simple Gulp task will print Hello world! on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note how we invoke Gulp, `gulp hello`, the argument used in the command is the
    name of the task to be executed. This is the simplest Gulp task that you can write
    and it is the starting point for developing an effective build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a development workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will build a script to help us in the development process
    and, later, to build a production-ready script. You will need to install the basic
    dependencies first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `gulp-load-plugins` is useful to automatically load all the available plugins
    without manually requiring them in the `gulpfile.js` script; the `gulp-util` plugin
    provides utility functions such as log messages.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling the JavaScript files with Browserify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gulp-browserify` plugin is currently deprecated and should not be used.
    The project author recommends using one of the recipes developed by the Gulp development
    team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes described in the repository needs to install some plugins first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In `gulpfile.js`, we can define the `browserify` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we configure the Browserify bundle, we use the Browserify `jstify`
    transformation to compile the underscore templates. As the `browserify` task is
    not a standard Gulp plugin, we are using `vinyl-source-stream` to stream the files
    to the bundler. Finally, we will write the output in the `.tmp/js` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can run Gulp with the Browserify argument to run the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The`.tmp/js/app.js` file should exist and be ready to be used. You can run
    the project to verify all is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sourcemaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you run the project, the browser gets a single file named `app.js`, which
    contains all the concatenated source code. That's good for the production environments
    as it reduces the number of requests made to the server in order to get the assets.
    However, in development environments, it is more useful to see the individual
    files in the browser as you have it in the source code for the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: You can make sure that the browser shows you the original source files with
    sourcemaps so that you can put debug breakpoints or simply inspect the code without
    the noise of the other dependencies such as the Backbone library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include sourcemaps in the `browserify` task, you will need to install some
    extra dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows the source files in the Google Chrome browser. You
    can inspect the original files and put breakpoints, the browser will ensure to
    stop the execution at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is useful for Browserify bundles to see all the original files instead of
    a huge script; however, this technique can be used for the compiled programming
    languages such as CoffeeScript or maybe you can write your source code in ECMAScript
    6 and transpile it with babel and then, the original files with sourcemaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sourcemaps](img/B01962_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 Sourcemaps in action
  prefs: []
  type: TYPE_NORMAL
- en: Re-bundle automatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you change a source file, then you will need to run the `browserify` task
    again. You can make sure that Gulp and Browserify do this job for you. First,
    you will need to install another Browserify plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `watchify` plugin listens for file changes in the source code and can be
    used to trigger a re-bundle task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When a change is triggered, the `rebundle()` function will be executed automatically
    so that you only need to refresh the browser. In the next section, you will see
    how to automate this too.
  prefs: []
  type: TYPE_NORMAL
- en: BrowserSync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BrowserSync is an asset server that is useful for the purpose of developing,
    you should avoid its use for production environments. BrowserSync is a node package
    that runs an HTTP server that automatically reloads the browser when a change
    on the files that serve is detected. With BrowserSync, you may forget to manually
    refresh your browser every time you make a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install the package before starting to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package is installed, we can create a new Gulp task to run BrowserSync:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: On this Gulp task, we will run BrowserSync in the 9000 port and open an additional
    9001 port to allow us to configure the BrowserSync behavior. You can, for example,
    remotely debug your application, which is useful for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: We configure BrowserSync to serve the files from the `app` and `.tmp` directories.
    If you access `http://localhost:9000/`from your browser, the `app/index.html`
    file will be served as default and will use the script files in the `.tmp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: To automatically refresh the browser when a change in the source files is detected,
    we use the `gulp.watch()` method as it accepts a list of files to watch in the
    `node-blob` format and then, we can listen for the `change` event to fire a refresh
    signal to the browser through the `reload()` function that is included in BrowserSync.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the server task depends on the availability of the bundle script file, this
    task should depend on the Browserify task that we earlier created. To indicate
    Gulp that the task has a dependency, we should add a new argument to the `gulp.task()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The second argument is a list of strings that the task depends on. In the previous
    snippet, Gulp will ensure that the `browserify` task runs and finishes first before
    executing the `browserify` task function.
  prefs: []
  type: TYPE_NORMAL
- en: Run server with Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the assets server working, we need to run our Express server
    with `nodemon`, this package is very similar to BrowserSync; however, it does
    not include the browser features. With nodemon, you can run a node script that
    will watch for any changes on the JavaScript files. When a change is detected,
    the node script will be reloaded automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install the npm package first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create the task for nodemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this task, we are informing nodemon to ignore the changes under the `app`
    directory. The reason for this is that the `app` path is already watched by BrowserSync.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the server, and the assets are served and reloaded automatically,
    we can merge these two tasks in order to run the project in development mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A new dependency should be installed, **http-proxy**. This dependency allows
    us to redirect all the API requests to the Express server so that BrowserSync
    does not try to serve these requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This time, we add the `express` task dependency to the `serve` task. As we are
    now running two servers on different ports, assets on 9000 and API on 8000, we
    add a middleware in BrowserSync to redirect the traffic that starts with `/api/`
    or `/avatar/` to the server located at port 8000.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you run the `serve` task from your command line, you will get an amazing
    development environment. Every time a file in the frontend is changed, the browser
    will be reloaded automatically with a new bundle. If a change in the server files
    is detected, the Express server will also be reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: That's a great improvement for your development workflow; you will be more productive
    and forget about manual reloads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a production workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development workflow that we built in the previous sections is an amazing
    improvement for the project; however, we are not finished yet. In this section,
    you will see how to optimize the project that is to be run in the production environments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to minimize your JavaScript and CSS files
    to obfuscate your source code and reduce the time the browser takes to load the
    asset files. The images can also be minified in order to reduce its weight without
    altering its appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Gulp useref
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gulp-useref` plugin processes your HTML files to concatenate your JavaScript
    and CSS assets into a single file. Please note that the JavaScript is already
    processed by Browserify, therefore, it is not necessary to process the JavaScript
    files with useref; on the other hand, CSS can be processed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to install the plugin with npm as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to use it, you will need to create a new task. Let''s call it `html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `gulp.src('app/*.html')` function grabs all the files with the`.html` extension.
    In our case, only the `index.html` file exists, therefore, it is the only file
    that will be processed. The `useref.assets()` function concatenates all the assets
    that are found in the HTML files and puts them in a stream, the `assets.restore()`
    function will restore the original stream of HTML files that are picked in the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: When you call the `useref()` function, the HTML file is parsed in order to replace
    the assets files in a single HTML tag. For example, if you have five CSS files,
    it replaces these five link tags in the HTML file in a single tag that points
    to the concatenated version.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should indicate the `useref` task how to concatenate the files with special
    tags in the HTML files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You need add two HTML comments to the code, these comments have a special meaning
    for useref. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we are processing CSS files, we use `css` as type, and the search path indicates
    where useref will look for the files. If we left this optional parameter blank,
    then it will use the root project path. The last `path` argument indicates where
    the concatenated CSS files will be put.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the Gulp `html` task, you will get a concatenated file with all
    your styles under the `dist/css/vendor.css` path. The output HTML file will point
    to this file instead of the development ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can optimize the output CSS files by minifying them with the `gulp-minify-css`
    plugin. As you may have guessed, you should install the plugin with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can use the plugin in your build process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will minify the concatenated CSS file. However, as `useref` can process
    CSS and JavaScript files, the code can be buggy if a JavaScript build tag is added.
    To prevent errors, you can use the `gulp-if` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will also install `uglify` in order to also process the JavaScript files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With `gulp-if` we test if the file in the stream is a CSS or a JavaScript file
    and then apply the right transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Image Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are developing your project in the local machine, the assets load pretty
    fast as images and code live in the same computer; however, when you go to the
    production images, they travel through the Internet to your user machine.
  prefs: []
  type: TYPE_NORMAL
- en: With image optimization, we can compress these images in order to reduce the
    amount of data that your app downloads from the server. With node, you can use
    the `imagemin` package; however, as we are using Gulp, `gulp-imagemin` will do
    the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did earlier, you will need to install the plugin first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the plugin is installed, we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It grabs the images from the `app/images` path and applies the `imagemin()`
    process to each image.
  prefs: []
  type: TYPE_NORMAL
- en: Fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fonts for Bootstrap are located under the `node_modules/` directory. If you
    install other type of fonts, such as Font Awesome, or download a specific fonts;
    they should be copied to the `dist/` directory. You can create a `fonts` task
    to do this, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you will need to install the `gulp-flatten` plugin; this plugin will
    remove any prefix directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Bundle JavaScript files for production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `browserify` task that we have is useful for development, it creates sourcemaps
    and the output is not minified. If you want to go to the production, you will
    need to remove the sourcemaps and minimize the output too.
  prefs: []
  type: TYPE_NORMAL
- en: For production environment, we will transform the ECMAScript 6 code into JavaScript
    in order to add support for these browsers that does not support for ECMAScript
    6\. Babel is the best transpiler at the moment to make this transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The babelify plugin of Browserify will apply the transformations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to configure Babel before using the babelify plugin. In Babel
    6, you have to install individual packages for the functions that you want to
    support. For this project, we support ES2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `.babelrc` file, you should configure the preset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have configured Babel properly, we can create the `browserify` task
    for production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This task does not generate sourcemaps and optimize the output.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have learned how to optimize several kind of assets: CSS, JavaScript, and
    images. Now let''s put all this together in order to build our application. The
    `serve:dist` task wires all the processes into a pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To test our pipeline, we can run the `serve:dist` task in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the tasks are executed by Gulp. After all these processes, the browser
    will automatically open while pointing to the `http://localhost:9000` address,
    running the application in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use tools to build our Backbone application.
    First, you learned what a task runner is and the most popular choices available
    for Node. Then, we saw how Gulp works and creates tasks.
  prefs: []
  type: TYPE_NORMAL
- en: With Gulp, you can build a development environment and configure it in order
    to apply optimizations to your assets for the production environments. Gulp is
    stream-based, which means that you can grab a bunch of files from a `glob` specification
    and stream these files in order to apply transformations, such as compiling, concatenating,
    transpiling, and so on, as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Task runners are amazing tools that allow you to automatize tasks. You can not
    only create development and production workflows, but also tasks for almost anything,
    which you don't want to repeat. For example, a task to make deployments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to test the Backbone applications. You
    will learn how to isolate and fake dependencies for easy testing, the what and
    how to make Backbone testing.
  prefs: []
  type: TYPE_NORMAL
