<html><head></head><body>
  <div id="_idContainer031">
   <h1 class="chapter-number" id="_idParaDest-205">
    <a id="_idTextAnchor212">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     7
    </span>
   </h1>
   <h1 id="_idParaDest-206">
    <a id="_idTextAnchor213">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Persisting to Databases
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In the world of application development, being able to save and retrieve data is essential.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Imagine you’re building a game where you need to keep scores or a social media application where users need to save their profiles and posts.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     A lot of the time, a traditional relational database is what you need for this.
    </span>
    <span class="koboSpan" id="kobo.3.4">
     It’s like an organized filing system where everything has its place in neat tables, and these tables can relate to each other in specific ways.
    </span>
    <span class="koboSpan" id="kobo.3.5">
     For instance, one table might store information about books while another stores information about authors, and links between the two can show which author wrote
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      which book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     But what if your data doesn’t fit into this structured format?
    </span>
    <span class="koboSpan" id="kobo.5.2">
     What if you’re dealing with something more flexible or unpredictable, such as posts on a social media feed where some posts have images, some have videos, and others have just text?
    </span>
    <span class="koboSpan" id="kobo.5.3">
     This is where non-relational, or NoSQL, databases come in.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     They’re designed to handle a wide variety of data structures, from simple key-value pairs to more complex documents or graphs.
    </span>
    <span class="koboSpan" id="kobo.5.5">
     This makes them a great choice for modern applications that require flexibility
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      and scalability.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.7.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.8.1">
     This chapter will focus on interacting with these databases in Node.js.
    </span>
    <span class="koboSpan" id="kobo.8.2">
     As such, some elementary knowledge of databases
    </span>
    <a id="_idIndexMarker509">
    </a>
    <span class="koboSpan" id="kobo.9.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.10.1">
      Structured Query Language
     </span>
    </strong>
    <span class="koboSpan" id="kobo.11.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.12.1">
      SQL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.13.1">
     )
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      is assumed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.15.1">
     We’ll start with setting up a simple SQL database to understand the fundamentals of database operations.
    </span>
    <span class="koboSpan" id="kobo.15.2">
     Then, we’ll explore the dynamic world of NoSQL databases, learning how to interact with them to handle more flexible data structures.
    </span>
    <span class="koboSpan" id="kobo.15.3">
     By the end of this chapter, you’ll have a foundation in using diverse types of databases in your Node.js applications, giving you the flexibility to choose the right storage solution for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      your projects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.17.1">
     This chapter will cover the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.18.1">
      following recipes:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Connecting and persisting to a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       MySQL database
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.21.1">
      Connecting and persisting to a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       PostgreSQL database
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Connecting and persisting
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       to MongoDB
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.25.1">
      Persisting data
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       with Redis
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.27.1">
       Exploring GraphQL
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-207">
    <a id="_idTextAnchor214">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     Throughout this chapter, we will use Docker to provision databases in containers.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     Using a database container is common when building scalable and resilient architectures – particularly when using a container orchestrator such
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      as Kubernetes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     However, the main reason why we’ll be using Docker containers throughout this chapter is to save us from having to manually install each of the database
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.32.1">
      command-line interfaces
     </span>
    </strong>
    <span class="koboSpan" id="kobo.33.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.34.1">
      CLIs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.35.1">
     ) and servers onto our system.
    </span>
    <span class="koboSpan" id="kobo.35.2">
     In this chapter, we will be using Docker to provision containerized MySQL, PostgreSQL, MongoDB, and Redis
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      data stores.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     It is recommended to install Docker Desktop
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      from
     </span>
    </span>
    <a href="https://docs.docker.com/engine/install/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.39.1">
       https://docs.docker.com/engine/install/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     If you are unable to install Docker, then you can still complete the recipes, but you will need to manually install the specific databases for each recipe or connect to a remote
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      database service.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     Note that this chapter will not cover how to enable persistent data storage from Docker containers, as this requires knowledge of Docker that is out of scope for a Node.js tutorial.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     Therefore, once the containers are destroyed or removed, the data accrued during the tutorials will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      be lost.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     It will also be worthwhile cleaning up and removing your database containers once you’ve completed each recipe by following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      these steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.47.1">
      Enter
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.48.1">
       $ docker ps
      </span>
     </strong>
     <span class="koboSpan" id="kobo.49.1">
      in your terminal to list your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.50.1">
       Docker containers.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.51.1">
      From there, locate the container identifier and pass this to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.52.1">
       $ docker stop &lt;ContainerID&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.53.1">
      command to stop
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.54.1">
       the container.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.55.1">
      Follow it up with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.56.1">
       $ docker rm --force &lt;ContainerID&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.57.1">
      to remove
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.58.1">
       the container.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Alternatively, you can use the following command to remove all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.60.1">
      Docker containers:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.61.1">$ docker rm --force $(docker ps --all --quiet)</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     Take caution when using this command if you have other Docker containers, unrelated to the recipes in this book, running on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      your device.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.64.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.65.1">
     Docker refers to both the virtualization technology and the company Docker Inc.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     that created the technology.
    </span>
    <span class="koboSpan" id="kobo.65.3">
     Docker allows you to build applications and services into packages named containers.
    </span>
    <span class="koboSpan" id="kobo.65.4">
     Refer to
    </span>
    <a href="B19212_11.xhtml#_idTextAnchor353">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.66.1">
        Chapter 11
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.67.1">
     for more detailed information about the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.68.1">
      Docker technology.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.69.1">
     In several of the recipes, we will also make use of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      dotenv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.71.1">
     module (
    </span>
    <a href="https://www.npmjs.com/package/dotenv">
     <span class="koboSpan" id="kobo.72.1">
      https://www.npmjs.com/package/dotenv
     </span>
    </a>
    <span class="koboSpan" id="kobo.73.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.73.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.74.1">
      dotenv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     module loads environment variables from a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      .env
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     file into the Node.js process.
    </span>
    <span class="koboSpan" id="kobo.77.2">
     Where necessary, we will be storing example database credentials in a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.78.1">
      .env
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     file and then using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      dotenv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     module to parse these into our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      Node.js process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     You will also need to have Node.js installed, preferably the latest version, Node.js 22, and access to an editor and browser of your choice.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     The code samples produced for this chapter are available on GitHub at
    </span>
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     <span class="koboSpan" id="kobo.84.1">
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     </span>
    </a>
    <span class="koboSpan" id="kobo.85.1">
     in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.86.1">
       Chapter07
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.87.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-208">
    <a id="_idTextAnchor215">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     Connecting and persisting to a MySQL database
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     SQL is a standard for
    </span>
    <a id="_idIndexMarker510">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     communicating with relational databases.
    </span>
    <span class="koboSpan" id="kobo.90.2">
     Both
    </span>
    <a id="_idIndexMarker511">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     MySQL (
    </span>
    <a href="https://www.mysql.com/">
     <span class="koboSpan" id="kobo.92.1">
      https://www.mysql.com/
     </span>
    </a>
    <span class="koboSpan" id="kobo.93.1">
     ) and
    </span>
    <a id="_idIndexMarker512">
    </a>
    <span class="koboSpan" id="kobo.94.1">
     PostgreSQL (
    </span>
    <a href="https://www.postgresql.org/">
     <span class="koboSpan" id="kobo.95.1">
      https://www.postgresql.org/
     </span>
    </a>
    <span class="koboSpan" id="kobo.96.1">
     ) are
    </span>
    <a id="_idIndexMarker513">
    </a>
    <span class="koboSpan" id="kobo.97.1">
     popular open source
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.98.1">
      relational database management systems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.100.1">
      RDBMSs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.101.2">
     There are many
    </span>
    <a id="_idIndexMarker514">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     implementations of SQL databases, and each of them has its extensions and proprietary features.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     However, there is a base set of commands for storing, updating, and querying data implemented across all these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      SQL databases.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.104.1">
     In this recipe, we’re going to communicate with a MySQL
    </span>
    <a id="_idIndexMarker515">
    </a>
    <span class="koboSpan" id="kobo.105.1">
     database from Node.js using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.106.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     (
    </span>
    <a href="https://www.npmjs.com/package/mysql2">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.108.1">
       https://www.npmjs.com/package/mysql2
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      ) module.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-209">
    <a id="_idTextAnchor216">
    </a>
    <span class="koboSpan" id="kobo.110.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.111.1">
     First, we need to get a MySQL database running locally.
    </span>
    <span class="koboSpan" id="kobo.111.2">
     To do this, and for the other databases in this chapter, where possible, we will use Docker.
    </span>
    <span class="koboSpan" id="kobo.111.3">
     MySQL provides a Docker official image on Docker
    </span>
    <a id="_idIndexMarker516">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     Hub (
    </span>
    <a href="https://hub.docker.com/_/mysql">
     <span class="koboSpan" id="kobo.113.1">
      https://hub.docker.com/_/mysql
     </span>
    </a>
    <span class="koboSpan" id="kobo.114.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.114.2">
     This recipe assumes some, but minimal, prior knowledge of SQL and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      relational databases.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.116.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.117.1">
     In this tutorial, we will use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     package from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.120.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     for interacting with MySQL databases in Node.js due to its compatibility with the latest MySQL features and its support for promises.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     The choice of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.122.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     over the previously used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.124.1">
      mysql
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     package is driven by it being more up to date, allowing us to leverage newer features and capabilities such as the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.126.1">
      Promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.127.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.128.1">
       async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      /
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.130.1">
       await
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      syntax.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     To set up a MySQL
    </span>
    <a id="_idIndexMarker517">
    </a>
    <span class="koboSpan" id="kobo.133.1">
     database
    </span>
    <a id="_idIndexMarker518">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     using Docker and prepare your project, follow
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.135.1">
      these steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.136.1">
      In a terminal window, type the following command to start a MySQL database listening on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.137.1">
       port
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.138.1">
        3306
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.139.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.140.1">$ docker run --publish 3306:3306 --name node-mysql --env MYSQL_ROOT_PASSWORD=PASSWORD --detach mysql:8</span></strong></pre>
    </li>
   </ol>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.141.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.142.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      --publish 3306:3306
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     option in a Docker command maps port
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      3306
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     on the host machine to port
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.147.1">
      3306
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     on the Docker container, allowing external access to the container’s service running on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.149.1">
      that port.
     </span>
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.150.1">
     If you do not have the images locally, then Docker will first pull down the image from Docker Hub.
    </span>
    <span class="koboSpan" id="kobo.150.2">
     While Docker is pulling down the image, expect to see output like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.151.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.152.1">
Unable to find image 'mysql:8' locally
latest: Pulling from library/mysql
ea4e27ae0b4c: Pull complete
837904302482: Pull complete
3c574b61b241: Pull complete
654fc4f3eb2d: Pull complete
32da9c2187e3: Pull complete
dc99c3c88bd6: Pull complete
970181cc0aa6: Pull complete
d77b716c39d5: Pull complete
9e650d7f9f83: Pull complete
acc21ff36b4b: Pull complete
Digest: sha256:ff5ab9cdce0b4c59704b4e2a09deed5ab8467be795e0ea20228b8528f53fcf82
Status: Downloaded newer image for mysql:8
dbb88d7d042966351a79ae159eb73129d69961b2c3dab943d9f4cdd6697d5220</span></pre>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.153.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      --detach
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     argument indicates that we wish to start the container in detached mode – this
    </span>
    <a id="_idIndexMarker519">
    </a>
    <span class="koboSpan" id="kobo.156.1">
     means
    </span>
    <a id="_idIndexMarker520">
    </a>
    <span class="koboSpan" id="kobo.157.1">
     that the container is running in the background.
    </span>
    <span class="koboSpan" id="kobo.157.2">
     Omitting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      --detach
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     argument would mean your terminal window would be held by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      the container.
     </span>
    </span>
   </p>
   <ol>
    <li value="2">
     <span class="koboSpan" id="kobo.161.1">
      Next, we will create a new directory for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.162.1">
       this recipe:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.163.1">$ mkdir mysql-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.164.1">$ cd mysql-app</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.165.1">
      As we will be installing modules from
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.166.1">
       npm
      </span>
     </strong>
     <span class="koboSpan" id="kobo.167.1">
      , we also need to initialize
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.168.1">
       our project:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.169.1">$ npm init --yes</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.170.1">
       We’ll also prepare two files for use in the recipe.
      </span>
      <span class="koboSpan" id="kobo.170.2">
       The first will be a script named
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.171.1">
        setupDb.mjs
       </span>
      </strong>
      <span class="koboSpan" id="kobo.172.1">
       to create the database; the second will be a script to add a new task to the database, named
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.173.1">
        task.mjs
       </span>
      </strong>
      <span class="koboSpan" id="kobo.174.1">
       .
      </span>
      <span class="koboSpan" id="kobo.174.2">
       While we’re here, let’s also create a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.175.1">
        .env
       </span>
      </strong>
      <span class="koboSpan" id="kobo.176.1">
       file ready to store our
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.177.1">
        database credentials:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.178.1">$ touch setupDb.mjs tasks.mjs
$ touch .env</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.179.1">
      Add the example credentials for our MySQL instance to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.180.1">
       .
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.181.1">
        env
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.182.1">
       file:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.183.1">
DB_MYSQL_USER=root
DB_MYSQL_PASSWORD=PASSWORD</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.184.1">
       Be aware these are example credentials for simplicity – you should use stronger credentials in your applications.
      </span>
      <span class="koboSpan" id="kobo.184.2">
       Also, be sure not to accidentally commit
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.185.1">
        .env
       </span>
      </strong>
      <span class="koboSpan" id="kobo.186.1">
       files to
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.187.1">
        version control systems
       </span>
      </strong>
      <span class="koboSpan" id="kobo.188.1">
       (
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.189.1">
        VCSs
       </span>
      </strong>
      <span class="koboSpan" id="kobo.190.1">
       , such as Git) as this can lead to leaking of
      </span>
      <a id="_idIndexMarker521">
      </a>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.191.1">
        sensitive credentials.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.192.1">
     Now that we have the
    </span>
    <a id="_idIndexMarker522">
    </a>
    <span class="koboSpan" id="kobo.193.1">
     MySQL
    </span>
    <a id="_idIndexMarker523">
    </a>
    <span class="koboSpan" id="kobo.194.1">
     database running and our project initialized, we’re ready to move on to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.195.1">
      the recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-210">
    <a id="_idTextAnchor217">
    </a>
    <span class="koboSpan" id="kobo.196.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.197.1">
     In this recipe, we’ll be focusing on how to install the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     module from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     , connect to a MySQL database, and perform basic SQL queries.
    </span>
    <span class="koboSpan" id="kobo.201.2">
     We’ll use a straightforward task list example to illustrate these concepts.
    </span>
    <span class="koboSpan" id="kobo.201.3">
     We’ll also be using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.202.1">
      ECMAScript Modules
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.204.1">
      ESM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     ) syntax, covered
    </span>
    <a id="_idIndexMarker524">
    </a>
    <span class="koboSpan" id="kobo.206.1">
     in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.207.1">
      Using ECMAScript modules
     </span>
    </em>
    <span class="koboSpan" id="kobo.208.1">
     recipe of
    </span>
    <a href="B19212_05.xhtml#_idTextAnchor139">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.209.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.210.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     This approach should help you understand the practical application of managing and manipulating data with SQL in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      MySQL database.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.213.1">
      First, we need to install the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.214.1">
       dotenv
      </span>
     </strong>
     <span class="koboSpan" id="kobo.215.1">
      module, for parsing environment variable configuration, and the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.216.1">
        mysql2
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.217.1">
       module:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.218.1">$ npm install dotenv mysql2</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.219.1">
      We’ll start by writing a script to set up our task list database.
     </span>
     <span class="koboSpan" id="kobo.219.2">
      To do this, we’ll first need to import and load our credentials using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.220.1">
       dotenv
      </span>
     </strong>
     <span class="koboSpan" id="kobo.221.1">
      module and import the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.222.1">
       mysql2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.223.1">
      module.
     </span>
     <span class="koboSpan" id="kobo.223.2">
      Add the following to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.224.1">
       setupDb.mjs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.225.1">
      to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.226.1">
       do that:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.227.1">
import dotenv from 'dotenv';
import mysql from 'mysql2/promise';
dotenv.config();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.228.1">
      Now, let’s scaffold a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.229.1">
       main()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.230.1">
      function.
     </span>
     <span class="koboSpan" id="kobo.230.2">
      We will add the logic to this function as we progress through the tutorial steps.
     </span>
     <span class="koboSpan" id="kobo.230.3">
      Add the following
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.231.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.232.1">
        setupDb.mjs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.233.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.234.1">
async function main () {
}
main().catch(console.error);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.235.1">
      Now, let’s start adding our connection logic, and we’ll wrap this in a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.236.1">
       try
      </span>
     </strong>
     <span class="koboSpan" id="kobo.237.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.238.1">
       catch
      </span>
     </strong>
     <span class="koboSpan" id="kobo.239.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.240.1">
       finally
      </span>
     </strong>
     <span class="koboSpan" id="kobo.241.1">
      structure where
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.242.1">
       finally
      </span>
     </strong>
     <span class="koboSpan" id="kobo.243.1">
      will close the database connection.
     </span>
     <span class="koboSpan" id="kobo.243.2">
      Within
     </span>
     <a id="_idIndexMarker525">
     </a>
     <span class="koboSpan" id="kobo.244.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.245.1">
       main()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.246.1">
      function, add
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.247.1">
       the
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker526">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.248.1">
       following:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.249.1">
async function main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.250.1">  let connection;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.251.1">  try {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.252.1">    connection = await mysql.createConnection({</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.253.1">      user: process.env.DB_MYSQL_USER,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.254.1">      password: process.env.DB_MYSQL_PASSWORD,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.255.1">    });</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.256.1">    console.log('Connected as id ' +</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.257.1">        connection.threadId);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.258.1">   } catch (error) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.259.1">    console.error('Error connecting: ' + error.stack);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.260.1">  } finally {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.261.1">    if (connection) await connection.end();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.262.1">  }</span></strong><span class="koboSpan" id="kobo.263.1">
}</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.264.1">
       We can run this file in our terminal to test
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.265.1">
        the connection:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.266.1">$ node setupDb.mjs</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.267.1">Connected as id 10</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.268.1">
      Now, let’s add our logic to create tables.
     </span>
     <span class="koboSpan" id="kobo.268.2">
      To do this, we’ll use two separate SQL statements.
     </span>
     <span class="koboSpan" id="kobo.268.3">
      The first will create a database and instruct the connection to use it.
     </span>
     <span class="koboSpan" id="kobo.268.4">
      The second will
     </span>
     <a id="_idIndexMarker527">
     </a>
     <span class="koboSpan" id="kobo.269.1">
      create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.270.1">
       tasks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.271.1">
      database table.
     </span>
     <span class="koboSpan" id="kobo.271.2">
      Add the following to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.272.1">
       main()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.273.1">
      function, below
     </span>
     <a id="_idIndexMarker528">
     </a>
     <span class="koboSpan" id="kobo.274.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.275.1">
       console.log('Connected as ...
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.276.1">
       line:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.277.1">await connection.query('CREATE DATABASE IF NOT EXISTS</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.278.1">  tasks');</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.279.1">console.log('Database created or already exists.');</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.280.1">await connection.query('USE tasks');</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.281.1">const createTasksTableSql =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.282.1">  `CREATE TABLE IF NOT EXISTS tasks (</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.283.1">    id INT AUTO_INCREMENT PRIMARY KEY,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.284.1">    task VARCHAR(255) NOT NULL,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.285.1">    completed BOOLEAN NOT NULL DEFAULT FALSE</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.286.1">    )`;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.287.1">await connection.query(createTasksTableSql);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.288.1">console.log('Tasks table created or already exists.');</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.289.1">
      Run the program in your terminal with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.290.1">
       following command:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.291.1">
$ </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">node setupDb.mjs</span></strong><span class="koboSpan" id="kobo.293.1">
Connected as id 18
Database created or already exists.
</span><span class="koboSpan" id="kobo.293.2">Tasks table created or already exists.</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.294.1">
      Now, we can implement our logic in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.295.1">
       tasks.mjs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.296.1">
      to input some data into our table, again via a SQL
     </span>
     <a id="_idIndexMarker529">
     </a>
     <span class="koboSpan" id="kobo.297.1">
      query.
     </span>
     <span class="koboSpan" id="kobo.297.2">
      Start
     </span>
     <a id="_idIndexMarker530">
     </a>
     <span class="koboSpan" id="kobo.298.1">
      by copying the same connection logic we used
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.299.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.300.1">
        setupDb.mjs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.301.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.302.1">
import dotenv from 'dotenv';
import mysql from 'mysql2/promise';
dotenv.config();
async function main() {
  let connection;
  try {
    connection = await mysql.createConnection({
      user: process.env.DB_MYSQL_USER,
      password: process.env.DB_MYSQL_PASSWORD,
    });
    console.log('Connected as id ' +
        connection.threadId);
  } catch (error) {
    console.error('Error connecting: ' + error.stack);
  } finally {
    if (connection) await connection.end();
  }
}
main().catch(console.error);</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.303.1">
       Note that we end the connection to our MySQL database
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.304.1">
        using
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.305.1">
         connection.end()
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.306.1">
        .
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.307.1">
      Now, we can add some logic to receive the task details from the command line.
     </span>
     <span class="koboSpan" id="kobo.307.2">
      Add the following logic below the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.308.1">
       console.log('Connected
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.309.1">
        as
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.310.1">
       … line
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.311.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.312.1">
    if (process.argv[2]) {
      await connection.query(
          `INSERT INTO tasks.tasks (task) VALUES
              (?);`,
          [process.argv[2]]
      );
    }</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.313.1">
      Let’s add a query that will obtain the contents of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.314.1">
        tasks
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.315.1">
       table:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.316.1">
const [results] = await connection.query('SELECT *
  FROM tasks.tasks;');
    console.log(results);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.317.1">
      Now, run the
     </span>
     <a id="_idIndexMarker531">
     </a>
     <span class="koboSpan" id="kobo.318.1">
      program
     </span>
     <a id="_idIndexMarker532">
     </a>
     <span class="koboSpan" id="kobo.319.1">
      with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.320.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.321.1">$ node tasks.mjs "Walk the dog."</span></strong><span class="koboSpan" id="kobo.322.1">
Connected as id 10
[ { id: 1, task: 'Walk the dog.', completed: 0 } ]</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.323.1">
       Each time we run the program, our insert query will be executed, meaning a new entry will be made in the
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.324.1">
         tasks
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.325.1">
        table.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <h2 id="_idParaDest-211">
    <a id="_idTextAnchor218">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.327.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.328.1">
      createConnection()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     method exposed from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     module establishes a connection to the MySQL server based on the configuration and credentials passed to the method.
    </span>
    <span class="koboSpan" id="kobo.331.2">
     In the recipe, we passed the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.332.1">
      createConnection()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.333.1">
     method the username and password for our database using environment variables.
    </span>
    <span class="koboSpan" id="kobo.333.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     module defaults to looking for a MySQL database at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      localhost:3306
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     , which is where the MySQL Docker container that we created in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.338.1">
      Getting ready
     </span>
    </em>
    <span class="koboSpan" id="kobo.339.1">
     section of the recipe was exposed.
    </span>
    <span class="koboSpan" id="kobo.339.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     module from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.342.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.343.1">
     aims to provide equivalent functionality to the preceding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.344.1">
      mysql
     </span>
    </strong>
    <span class="koboSpan" id="kobo.345.1">
     module from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.346.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.347.1">
     .
    </span>
    <span class="koboSpan" id="kobo.347.2">
     A complete list of options that can be passed to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.348.1">
      createConnection()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.349.1">
     method is available in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.350.1">
      mysql
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     module API documentation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.352.1">
      at
     </span>
    </span>
    <a href="https://github.com/mysqljs/mysql#connection-options">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.353.1">
       https://github.com/mysqljs/mysql#connection-options
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      .
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.355.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.356.1">
     Connection pools can also be utilized to minimize the time needed to connect to the MySQL server by reusing existing connections instead of closing them after use.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     This approach enhances query latency by eliminating the overhead associated with setting up new connections.
    </span>
    <span class="koboSpan" id="kobo.356.3">
     Such a strategy is crucial for the development of large-scale applications.
    </span>
    <span class="koboSpan" id="kobo.356.4">
     For more details, consult the API documentation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      at
     </span>
    </span>
    <a href="https://sidorares.github.io/node-mysql2/docs#using-connection-pools">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.358.1">
       https://sidorares.github.io/node-mysql2/docs#using-connection-pools
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.359.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.360.1">
     Throughout the recipe, we used the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.361.1">
      query()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.362.1">
     method to send SQL statements to the MySQL database.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     The SQL statements in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.363.1">
      setupDb.mjs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.364.1">
     file created a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.365.1">
      tasks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.366.1">
     database and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.367.1">
      tasks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.368.1">
     table.
    </span>
    <span class="koboSpan" id="kobo.368.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.369.1">
      task.mjs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.370.1">
     file included SQL to insert a single task into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      tasks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     table.
    </span>
    <span class="koboSpan" id="kobo.372.2">
     The final SQL statement we sent to the database using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.373.1">
      query()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.374.1">
     method was
    </span>
    <a id="_idIndexMarker533">
    </a>
    <span class="koboSpan" id="kobo.375.1">
     a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.376.1">
      SELECT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     statement, which
    </span>
    <a id="_idIndexMarker534">
    </a>
    <span class="koboSpan" id="kobo.378.1">
     returned the contents of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.379.1">
       tasks
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.380.1">
      table.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.381.1">
     Each of the SQL statements is queued and executed asynchronously.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     It is possible to pass a callback function as a parameter to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      query()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     method, but we instead leverage the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.384.1">
       async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.385.1">
      /
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.386.1">
       await
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      syntax.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.388.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.389.1">
      end()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.390.1">
     method, as the name suggests, ends the connection to the database.
    </span>
    <span class="koboSpan" id="kobo.390.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.391.1">
      end()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.392.1">
     method ensures that there are no queries still queued or processing before ending the connection.
    </span>
    <span class="koboSpan" id="kobo.392.2">
     There’s another method,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      destroy()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     , that will immediately terminate the connection to the database, ignoring the state of any pending or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      executing queries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     One of the common types of attacks on user-facing web applications that it is necessary to be aware of is SQL
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      injection attacks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     A SQL injection is where an attacker sends malicious SQL statements to your database.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     This is often achieved by inserting the malicious SQL statement into a web page input field.
    </span>
    <span class="koboSpan" id="kobo.398.3">
     This is not a Node.js-specific problem; it also applies to other programming languages where the SQL query is created through string concatenation.
    </span>
    <span class="koboSpan" id="kobo.398.4">
     The way to mitigate against any of these attacks is to sanitize or escape user input such that our SQL statements cannot be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      maliciously manipulated.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.400.1">
     You can manually escape user-supplied data directly by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.401.1">
      connection.escape()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.402.1">
     .
    </span>
    <span class="koboSpan" id="kobo.402.2">
     In the recipe, however, we used the placeholder (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.403.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     ) syntax in our SQL query to achieve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.405.1">
      the same:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.406.1">
await connection.query(
          `INSERT INTO tasks.tasks (task) VALUES (?);`,
          [process.argv[2]]
      );</span></pre>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      mysql2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     module handles the sanitizing of user input for us if we pass our input values to the query via the second parameter of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.410.1">
      query
     </span>
    </strong>
    <span class="koboSpan" id="kobo.411.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     Multiple placeholders (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.412.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.413.1">
     ) are mapped
    </span>
    <a id="_idIndexMarker535">
    </a>
    <span class="koboSpan" id="kobo.414.1">
     to
    </span>
    <a id="_idIndexMarker536">
    </a>
    <span class="koboSpan" id="kobo.415.1">
     values in the SQL query in the order they
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.416.1">
      are supplied.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-212">
    <a id="_idTextAnchor219">
    </a>
    <span class="koboSpan" id="kobo.417.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     Building on the basics
    </span>
    <a id="_idIndexMarker537">
    </a>
    <span class="koboSpan" id="kobo.419.1">
     of interacting with MySQL with Node.js, this section introduces how to create a REST API using Fastify in conjunction with MySQL.
    </span>
    <span class="koboSpan" id="kobo.419.2">
     We’ll walk through essential steps such as setting up the project, starting a Fastify server, connecting it to MySQL with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      @fastify/mysql
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     plugin (
    </span>
    <a href="https://www.npmjs.com/package/@fastify/mysql">
     <span class="koboSpan" id="kobo.422.1">
      https://www.npmjs.com/package/@fastify/mysql
     </span>
    </a>
    <span class="koboSpan" id="kobo.423.1">
     ), and creating
    </span>
    <a id="_idIndexMarker538">
    </a>
    <span class="koboSpan" id="kobo.424.1">
     routes to handle
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.425.1">
      create, read, update, delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     (
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.427.1">
       CRUD
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      ) operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     Ensure you have a MySQL database available.
    </span>
    <span class="koboSpan" id="kobo.429.2">
     For this, we will reuse the database we created in the main
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.430.1">
      recipe steps.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.431.1">
      First, we will create a new directory for the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.432.1">
       fastify-mysql
      </span>
     </strong>
     <span class="koboSpan" id="kobo.433.1">
      project and initialize it
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.434.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.435.1">
        npm
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.436.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.437.1">$ mkdir fastify-mysql</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.438.1">$ cd fastify-mysql</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.439.1">$ npm init --yes</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.440.1">
      Install
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.441.1">
       fastify
      </span>
     </strong>
     <span class="koboSpan" id="kobo.442.1">
      and the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.443.1">
       @fastify/mysql
      </span>
     </strong>
     <span class="koboSpan" id="kobo.444.1">
      plugin
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.445.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.446.1">
        npm
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.447.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.448.1">$ npm install fastify @fastify/mysql</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.449.1">
      Create a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.450.1">
       server.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.451.1">
      in your project root.
     </span>
     <span class="koboSpan" id="kobo.451.2">
      This file will configure the Fastify server, connect to the MySQL database, and define
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.452.1">
       the routes:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.453.1">$ touch server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.454.1">
      Start by requiring
     </span>
     <a id="_idIndexMarker539">
     </a>
     <span class="koboSpan" id="kobo.455.1">
      Fastify – we’ll also
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.456.1">
       enable logging:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.457.1">
const fastify = require('fastify')({ logger: true });</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.458.1">
      Now, we can register the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.459.1">
       @fastify/mysql
      </span>
     </strong>
     <span class="koboSpan" id="kobo.460.1">
      plugin we
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.461.1">
       installed earlier:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.462.1">
fastify.register(require('@fastify/mysql'), {
  connectionString:
    'mysql://root:PASSWORD@localhost/tasks'
});</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.463.1">
       Note that the connection string contains the credentials of our MySQL database – ideally, this
      </span>
      <a id="_idIndexMarker540">
      </a>
      <span class="koboSpan" id="kobo.464.1">
       connection
      </span>
      <a id="_idIndexMarker541">
      </a>
      <span class="koboSpan" id="kobo.465.1">
       string should be stored in a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.466.1">
        .env
       </span>
      </strong>
      <span class="koboSpan" id="kobo.467.1">
       file as covered in
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.468.1">
        previous recipes.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.469.1">
      Now, let’s register a route to return all tasks in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.470.1">
       the database:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.471.1">
fastify.get('/tasks', (req, reply) =&gt; {
  fastify.mysql.query(
    'SELECT * FROM tasks.tasks',
    function onResult (err, result) {
      reply.send(err || result);
    }
  );
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.472.1">
      Finally, we’ll add the logic to run
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.473.1">
       the server:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.474.1">
fastify.listen({ port: 3000 }, err =&gt; {
  if (err) throw err;
  console.log(`server listening on
    ${fastify.server.address().port}`);
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.475.1">
      Let’s start the Fastify
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.476.1">
       MySQL application:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.477.1">$ node server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.478.1">
      To test your API,  open a new terminal window while your server is running and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.479.1">
       use
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.480.1">
        curl
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.481.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.482.1">$ curl http://localhost:3000/tasks</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     This tutorial provided a basic introduction to creating a REST API with Fastify and MySQL, covering project
    </span>
    <a id="_idIndexMarker542">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     setup, initializing
    </span>
    <a id="_idIndexMarker543">
    </a>
    <span class="koboSpan" id="kobo.485.1">
     the
    </span>
    <a id="_idIndexMarker544">
    </a>
    <span class="koboSpan" id="kobo.486.1">
     server, connecting to the database, and retrieving items from the database.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     Fastify provides equivalent plugins for the other databases utilized in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.487.1">
      this recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-213">
    <a id="_idTextAnchor220">
    </a>
    <span class="koboSpan" id="kobo.488.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.489.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.490.1">
       Connecting and persisting to a PostgreSQL database
      </span>
     </em>
     <span class="koboSpan" id="kobo.491.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.492.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.493.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.494.1">
       Connecting and persisting to MongoDB
      </span>
     </em>
     <span class="koboSpan" id="kobo.495.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.496.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.497.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.498.1">
       Persisting data with Redis
      </span>
     </em>
     <span class="koboSpan" id="kobo.499.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.500.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <a href="B19212_09.xhtml#_idTextAnchor274">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.501.1">
         Chapter 9
        </span>
       </em>
      </span>
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-214">
    <a id="_idTextAnchor221">
    </a>
    <span class="koboSpan" id="kobo.502.1">
     Connecting and persisting to a PostgreSQL database
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     PostgreSQL, first introduced
    </span>
    <a id="_idIndexMarker545">
    </a>
    <span class="koboSpan" id="kobo.504.1">
     in 1996, is a powerful open source object-relational
    </span>
    <a id="_idIndexMarker546">
    </a>
    <span class="koboSpan" id="kobo.505.1">
     database system that has stood the test of time due to its reliability, feature robustness, and performance.
    </span>
    <span class="koboSpan" id="kobo.505.2">
     One of PostgreSQL’s standout features is its ability to be utilized as both a traditional relational database, where data is stored in tables with relationships among them, and as a document database, such as NoSQL databases, where data can be stored in JSON format.
    </span>
    <span class="koboSpan" id="kobo.505.3">
     This flexibility allows developers to choose the most appropriate data storage model based on their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      application’s requirements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     Throughout this tutorial, we will explore the basics of interacting with a PostgreSQL database from a Node.js application.
    </span>
    <span class="koboSpan" id="kobo.507.2">
     We’ll use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.508.1">
      pg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.509.1">
     module, a popular and comprehensive PostgreSQL client for Node.js.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.510.1">
      pg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.511.1">
     module simplifies connecting to and executing queries against a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.512.1">
      PostgreSQL database.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-215">
    <a id="_idTextAnchor222">
    </a>
    <span class="koboSpan" id="kobo.513.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.514.1">
     To get started, we will need a PostgreSQL server to connect to.
    </span>
    <span class="koboSpan" id="kobo.514.2">
     We will use Docker to provision a containerized PostgreSQL database.
    </span>
    <span class="koboSpan" id="kobo.514.3">
     Refer to the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.515.1">
      Technical requirements
     </span>
    </em>
    <span class="koboSpan" id="kobo.516.1">
     section of this chapter for more information about using Docker to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.517.1">
      provision databases.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.518.1">
     We will be using the Docker official PostgreSQL image
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.519.1">
      from
     </span>
    </span>
    <a href="https://hub.docker.com/_/postgres">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.520.1">
       https://hub.docker.com/_/postgres
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.521.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.522.1">
     The following steps will initialize our PostgreSQL server and prepare our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.523.1">
      project directory:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.524.1">
      In a terminal window, type the following to provision a
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.525.1">
        postgres
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.526.1">
       container:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.527.1">$ docker run --publish 5432:5432 --name node-postgres-latest --env POSTGRES_PASSWORD=PASSWORD --detach postgres:16</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.528.1">
       Assuming you do not have a copy of the PostgreSQL image locally, expect to see the following output while Docker downloads
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.529.1">
        the image:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.530.1">Unable to find image 'postgres:16' locally
latest: Pulling from library/postgres
f546e941f15b: Pull complete
926c64b890ad: Pull complete
eca757527cc4: Pull complete
93d9b27ec7dc: Pull complete
86e78387c4e9: Pull complete
8776625edd8f: Pull complete
d1afcbffdf18: Pull complete
6a6c8f936428: Pull complete
ae47f32f8312: Pull complete
82fb85897d06: Pull complete
ce4a61041646: Pull complete
ca83cd3ae7cf: Pull complete
f7fbf31fd41d: Pull complete
353df72b8bf7: Pull complete
Digest: sha256:f58300ac8d393b2e3b09d36ea12d7d24ee9440440e421472a300e929ddb63460
Status: Downloaded newer image for postgres:16
86ce1ac06849f737e669c34e50e6f91383074cdecb1a18f8f23a6becaa085ba0</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.531.1">
       We should now have
      </span>
      <a id="_idIndexMarker547">
      </a>
      <span class="koboSpan" id="kobo.532.1">
       a
      </span>
      <a id="_idIndexMarker548">
      </a>
      <span class="koboSpan" id="kobo.533.1">
       PostgreSQL database listening on
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.534.1">
        port
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.535.1">
         5432
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.536.1">
        .
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.537.1">
      Next, we’ll set up a directory and files ready for our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.538.1">
       PostgreSQL application:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.539.1">$ mkdir postgres-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.540.1">$ cd postgres-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.541.1">$ touch tasks.js .env</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.542.1">
      As we’ll be using a third-party module, we’ll also need to use
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.543.1">
       npm
      </span>
     </strong>
     <span class="koboSpan" id="kobo.544.1">
      to initialize a project.
     </span>
     <span class="koboSpan" id="kobo.544.2">
      Let’s just accept
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.545.1">
       the defaults:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.546.1">$ npm init --yes</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.547.1">
     Now, we’re ready to move on to the recipe, where we will be using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      pg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     module to interact with our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      PostgreSQL database.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-216">
    <a id="_idTextAnchor223">
    </a>
    <span class="koboSpan" id="kobo.551.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     In this recipe, we will be installing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.553.1">
      pg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.554.1">
     module to interact with our PostgreSQL database using Node.js.
    </span>
    <span class="koboSpan" id="kobo.554.2">
     We will also send some simple queries to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      our database.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.556.1">
      First, we need to install the third-party
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.557.1">
        pg
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.558.1">
       module:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.559.1">$ npm install pg</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.560.1">
      We’ll also be using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.561.1">
       dotenv
      </span>
     </strong>
     <span class="koboSpan" id="kobo.562.1">
      module in this recipe; install that with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.563.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.564.1">$ npm install dotenv</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.565.1">
      We’ll also
     </span>
     <a id="_idIndexMarker549">
     </a>
     <span class="koboSpan" id="kobo.566.1">
      use
     </span>
     <a id="_idIndexMarker550">
     </a>
     <span class="koboSpan" id="kobo.567.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.568.1">
       .env
      </span>
     </strong>
     <span class="koboSpan" id="kobo.569.1">
      file to store our PostgreSQL database credentials and use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.570.1">
       dotenv
      </span>
     </strong>
     <span class="koboSpan" id="kobo.571.1">
      module to pass them to our program.
     </span>
     <span class="koboSpan" id="kobo.571.2">
      Add the following credentials
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.572.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.573.1">
        .env
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.574.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.575.1">
PGUSER=postgres
PGPASSWORD=PASSWORD
PGPORT=5432</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.576.1">
      Open
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.577.1">
       tasks.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.578.1">
      and import our environment variables using the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.579.1">
        dotenv
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.580.1">
       module:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.581.1">
require('dotenv').config();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.582.1">
      Next, in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.583.1">
       tasks.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.584.1">
      , we need to import the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.585.1">
       pg
      </span>
     </strong>
     <span class="koboSpan" id="kobo.586.1">
      module and create a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.587.1">
       PostgreSQL client:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.588.1">
const pg = require('pg');
const db = new pg.Client();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.589.1">
      Now, let’s allow our program to handle input via a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.590.1">
       command-line argument:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.591.1">
const task = process.argv[2];</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.592.1">
      Next, we’ll define the SQL queries we’re going to be using as constants.
     </span>
     <span class="koboSpan" id="kobo.592.2">
      This will improve the readability of our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.593.1">
       code later:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.594.1">
const CREATE_TABLE_SQL = `CREATE TABLE IF NOT EXISTS
  tasks (id SERIAL, task TEXT NOT NULL, PRIMARY KEY (
    id ));`;
const INSERT_TASK_SQL = 'INSERT INTO tasks (task)
  VALUES ($1);';
const GET_TASKS_SQL = 'SELECT * FROM tasks;';</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.595.1">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.596.1">
        SELECT * FROM tasks;
       </span>
      </strong>
      <span class="koboSpan" id="kobo.597.1">
       SQL
      </span>
      <a id="_idIndexMarker551">
      </a>
      <span class="koboSpan" id="kobo.598.1">
       query
      </span>
      <a id="_idIndexMarker552">
      </a>
      <span class="koboSpan" id="kobo.599.1">
       returns all tasks in the
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.600.1">
         tasks
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.601.1">
        table.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.602.1">
      Next, we’ll add the following code to connect to our database.
     </span>
     <span class="koboSpan" id="kobo.602.2">
      Create a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.603.1">
       tasks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.604.1">
      table if it doesn’t already exist, insert a task, and finally, list all tasks stored in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.605.1">
       the database:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.606.1">
db.connect((err) =&gt; {
  if (err) throw err;
  db.query(CREATE_TABLE_SQL, (err) =&gt; {
    if (err) throw err;
    if (task) {
      db.query(INSERT_TASK_SQL, [task], (err) =&gt; {
        if (err) throw err;
        listTasks();
      });
    } else {
      listTasks();
    }
  });
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.607.1">
      Finally, we’ll create our
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.608.1">
       listTasks()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.609.1">
      function, which will use
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.610.1">
       GET_TASKS_SQL
      </span>
     </strong>
     <span class="koboSpan" id="kobo.611.1">
      .
     </span>
     <span class="koboSpan" id="kobo.611.2">
      This function
     </span>
     <a id="_idIndexMarker553">
     </a>
     <span class="koboSpan" id="kobo.612.1">
      will also end the connection
     </span>
     <a id="_idIndexMarker554">
     </a>
     <span class="koboSpan" id="kobo.613.1">
      to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.614.1">
       our database:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.615.1">
function listTasks () {
  db.query(GET_TASKS_SQL, (err, results) =&gt; {
    if (err) throw err;
    console.log(results.rows);
    db.end();
  });
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.616.1">
      Run
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.617.1">
       tasks.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.618.1">
      , passing a task as a command-line argument.
     </span>
     <span class="koboSpan" id="kobo.618.2">
      The task will be inserted into the database and listed out before the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.619.1">
       program ends:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.620.1">$ node tasks.js "Bath the dog."</span></strong><span class="koboSpan" id="kobo.621.1">
[
  { id: 1, task: 'Bath the dog.' </span><span class="koboSpan" id="kobo.621.2">}
]</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.622.1">
      We can also run the program without passing a task.
     </span>
     <span class="koboSpan" id="kobo.622.2">
      When we run
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.623.1">
       tasks.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.624.1">
      with no
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.625.1">
       task
      </span>
     </strong>
     <span class="koboSpan" id="kobo.626.1">
      parameter, the program will output the tasks stored in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.627.1">
       the database:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.628.1">$ node tasks.js</span></strong><span class="koboSpan" id="kobo.629.1">
[
  { id: 1, task: 'Bath the dog.' </span><span class="koboSpan" id="kobo.629.2">}
]</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.630.1">
     By following these steps, you’ve gained an understanding of how to integrate PostgreSQL
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      with Node.js.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-217">
    <a id="_idTextAnchor224">
    </a>
    <span class="koboSpan" id="kobo.632.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.633.1">
     In the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.634.1">
      Getting ready
     </span>
    </em>
    <span class="koboSpan" id="kobo.635.1">
     section of this recipe, we provisioned a containerized PostgreSQL database using the Docker official image from Docker Hub.
    </span>
    <span class="koboSpan" id="kobo.635.2">
     The provisioned PostgreSQL database was provisioned in
    </span>
    <a id="_idIndexMarker555">
    </a>
    <span class="koboSpan" id="kobo.636.1">
     a
    </span>
    <a id="_idIndexMarker556">
    </a>
    <span class="koboSpan" id="kobo.637.1">
     Docker container named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.638.1">
      node-postgres
     </span>
    </strong>
    <span class="koboSpan" id="kobo.639.1">
     .
    </span>
    <span class="koboSpan" id="kobo.639.2">
     By default, the PostgreSQL Docker image creates a user and database named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.640.1">
      postgres
     </span>
    </strong>
    <span class="koboSpan" id="kobo.641.1">
     .
    </span>
    <span class="koboSpan" id="kobo.641.2">
     The Docker command we used to provision the database instructed the container to make the PostgreSQL database available at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.642.1">
      localhost:5432
     </span>
    </strong>
    <span class="koboSpan" id="kobo.643.1">
     with a placeholder password
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.644.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.645.1">
       PASSWORD
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.646.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.647.1">
     The configuration information required for a connection to our PostgreSQL database was specified in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.648.1">
      .env
     </span>
    </strong>
    <span class="koboSpan" id="kobo.649.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.649.2">
     We used the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.650.1">
      dotenv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.651.1">
     module to load this configuration information as environment variables to our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.652.1">
      Node.js process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.653.1">
     Notice that we didn’t have to directly pass any of the environment variables to the client.
    </span>
    <span class="koboSpan" id="kobo.653.2">
     This is because the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.654.1">
      pg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.655.1">
     module automatically looks for specifically named variables (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.656.1">
      PGHOST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.657.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.658.1">
      PGPORT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.659.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.660.1">
      PGUSER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.661.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.661.2">
     However, if we wanted, we could specify the values when we create the client,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.662.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.663.1">
const client = new Client({
  host: 'localhost',
  port: 5432,
  user: 'postgres'
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.664.1">
     We use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.665.1">
      connect()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.666.1">
     method to connect to our PostgreSQL database.
    </span>
    <span class="koboSpan" id="kobo.666.2">
     We provide this method with a callback function to be executed once the connection attempt is complete.
    </span>
    <span class="koboSpan" id="kobo.666.3">
     We added error handling within our callback function so that if the connection attempt fails, then an error
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.667.1">
      is thrown.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.668.1">
     Throughout the remainder of the program, we use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.669.1">
      query()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.670.1">
     method provided by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.671.1">
      pg
     </span>
    </strong>
    <span class="koboSpan" id="kobo.672.1">
     module to execute SQL queries against the PostgreSQL database.
    </span>
    <span class="koboSpan" id="kobo.672.2">
     Each of our calls to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.673.1">
      query()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.674.1">
     method
    </span>
    <a id="_idIndexMarker557">
    </a>
    <span class="koboSpan" id="kobo.675.1">
     is
    </span>
    <a id="_idIndexMarker558">
    </a>
    <span class="koboSpan" id="kobo.676.1">
     supplied with a callback function to be executed upon completion of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.677.1">
      the query.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-218">
    <a id="_idTextAnchor225">
    </a>
    <span class="koboSpan" id="kobo.678.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.679.1">
     As well as storing traditional relational data, PostgreSQL also provides the ability to store object data.
    </span>
    <span class="koboSpan" id="kobo.679.2">
     This enables the storing of relational data alongside
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.680.1">
      document storage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.681.1">
     We can adapt the program we created in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.682.1">
      Connecting and persisting to a PostgreSQL database
     </span>
    </em>
    <span class="koboSpan" id="kobo.683.1">
     recipe to handle both relational and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.684.1">
      object data.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.685.1">
      Copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.686.1">
       postgres-app
      </span>
     </strong>
     <span class="koboSpan" id="kobo.687.1">
      directory to a directory
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.688.1">
       called
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.689.1">
        postgres-object-app
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.690.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.691.1">$ cp -r postgres-app postgres-object-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.692.1">$ cd postgres-object-app</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.693.1">
      Now, we’ll edit our SQL queries to create a new table named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.694.1">
       task_docs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.695.1">
      that stores document data.
     </span>
     <span class="koboSpan" id="kobo.695.2">
      Change your SQL query constants to the following in our
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.696.1">
        tasks.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.697.1">
       file:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.698.1">
const CREATE_TABLE_SQL = `CREATE TABLE IF NOT EXISTS
  task_docs (id SERIAL, doc jsonb);`;
const INSERT_TASK_SQL = `INSERT INTO task_docs (doc)
  VALUES ($1);`;
const GET_TASKS_SQL = `SELECT * FROM task_docs;`;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.699.1">
      Now, when we run our application, we can pass it JSON input to represent the task.
     </span>
     <span class="koboSpan" id="kobo.699.2">
      Note that we will need to wrap the JSON input in single quotes, and then use double quotes for the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.700.1">
       key-value pairs:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.701.1">$ node tasks.js '{"task":"Walk the dog."}'</span></strong><span class="koboSpan" id="kobo.702.1">
[ { id: 1, doc: { task: 'Walk the dog.' </span><span class="koboSpan" id="kobo.702.2">} } ]</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.703.1">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.704.1">
        doc
       </span>
      </strong>
      <span class="koboSpan" id="kobo.705.1">
       field was created with the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.706.1">
        jsonb
       </span>
      </strong>
      <span class="koboSpan" id="kobo.707.1">
       type, which represents the JSON binary type.
      </span>
      <span class="koboSpan" id="kobo.707.2">
       PostgreSQL provides two JSON data types:
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.708.1">
        json
       </span>
      </strong>
      <span class="koboSpan" id="kobo.709.1">
       and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.710.1">
        jsonb
       </span>
      </strong>
      <span class="koboSpan" id="kobo.711.1">
       .
      </span>
      <span class="koboSpan" id="kobo.711.2">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.712.1">
        json
       </span>
      </strong>
      <span class="koboSpan" id="kobo.713.1">
       data type is like a regular text input field but with the addition that it validates the JSON.
      </span>
      <span class="koboSpan" id="kobo.713.2">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.714.1">
        jsonb
       </span>
      </strong>
      <span class="koboSpan" id="kobo.715.1">
       type is structured and facilitates queries and indexes within the document objects.
      </span>
      <span class="koboSpan" id="kobo.715.2">
       You’d opt for the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.716.1">
        jsonb
       </span>
      </strong>
      <span class="koboSpan" id="kobo.717.1">
       data type over the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.718.1">
        json
       </span>
      </strong>
      <span class="koboSpan" id="kobo.719.1">
       data type when you require the ability to query or index
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.720.1">
        the data.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.721.1">
     Based on this example, a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.722.1">
      jsonb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.723.1">
     query would look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.724.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.725.1">
SELECT * FROM task_docs WHERE doc -&gt;&gt; task= "Bath the dog."</span></pre>
   <p>
    <span class="koboSpan" id="kobo.726.1">
     Note that we’re able
    </span>
    <a id="_idIndexMarker559">
    </a>
    <span class="koboSpan" id="kobo.727.1">
     to
    </span>
    <a id="_idIndexMarker560">
    </a>
    <span class="koboSpan" id="kobo.728.1">
     query against the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.729.1">
      task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     property within the document object.
    </span>
    <span class="koboSpan" id="kobo.730.2">
     For more information about the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.731.1">
      jsonb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.732.1">
     data type, refer to the official PostgreSQL documentation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.733.1">
      at
     </span>
    </span>
    <a href="https://www.postgresql.org/docs/9.4/datatype-json.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.734.1">
       https://www.postgresql.org/docs/9.4/datatype-json.html
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.735.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-219">
    <a id="_idTextAnchor226">
    </a>
    <span class="koboSpan" id="kobo.736.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.737.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.738.1">
       Connecting and persisting to a MySQL database
      </span>
     </em>
     <span class="koboSpan" id="kobo.739.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.740.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.741.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.742.1">
       Connecting and persisting to MongoDB
      </span>
     </em>
     <span class="koboSpan" id="kobo.743.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.744.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.745.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.746.1">
       Persisting data with Redis
      </span>
     </em>
     <span class="koboSpan" id="kobo.747.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.748.1">
       this chapter
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-220">
    <a id="_idTextAnchor227">
    </a>
    <span class="koboSpan" id="kobo.749.1">
     Connecting and persisting to MongoDB
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.750.1">
     MongoDB is a
    </span>
    <a id="_idIndexMarker561">
    </a>
    <span class="koboSpan" id="kobo.751.1">
     NoSQL
    </span>
    <a id="_idIndexMarker562">
    </a>
    <span class="koboSpan" id="kobo.752.1">
     database management system built around a document-oriented model.
    </span>
    <span class="koboSpan" id="kobo.752.2">
     Data is stored in flexible, JSON-like documents
    </span>
    <a id="_idIndexMarker563">
    </a>
    <span class="koboSpan" id="kobo.753.1">
     called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.754.1">
      Binary JSON
     </span>
    </strong>
    <span class="koboSpan" id="kobo.755.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.756.1">
      BSON
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     ), which are organized
    </span>
    <a id="_idIndexMarker564">
    </a>
    <span class="koboSpan" id="kobo.758.1">
     into
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.759.1">
      collections
     </span>
    </strong>
    <span class="koboSpan" id="kobo.760.1">
     , analogous to tables in relational databases.
    </span>
    <span class="koboSpan" id="kobo.760.2">
     Each document within a collection can have a different structure, allowing for dynamic schemas and easy modification of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.761.1">
      data models.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.762.1">
     MongoDB supports powerful querying capabilities using its query language, which includes various operators and methods for filtering, sorting, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.763.1">
      manipulating data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.764.1">
     This recipe will use a book/author example using the MongoDB Node.js driver directly.
    </span>
    <span class="koboSpan" id="kobo.764.2">
     We’ll write functions to create and find authors and books within our MongoDB database.
    </span>
    <span class="koboSpan" id="kobo.764.3">
     This script will illustrate basic CRUD operations without the use of a web framework, focusing purely on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.765.1">
      database interactions.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-221">
    <a id="_idTextAnchor228">
    </a>
    <span class="koboSpan" id="kobo.766.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.767.1">
     To set up a MongoDB database with Docker and get your project directory ready for the application, follow
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.768.1">
      these steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.769.1">
      As with the
     </span>
     <a id="_idIndexMarker565">
     </a>
     <span class="koboSpan" id="kobo.770.1">
      other
     </span>
     <a id="_idIndexMarker566">
     </a>
     <span class="koboSpan" id="kobo.771.1">
      databases in this chapter, we will be using Docker to provision a MongoDB database using the MongoDB Docker image available
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.772.1">
       at
      </span>
     </span>
     <a href="https://hub.docker.com/_/mongo">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.773.1">
        https://hub.docker.com/_/mongo
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.774.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.775.1">$ docker run --publish 27017:27017 --name node-mongo --detach mongo:7</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.776.1">
       Assuming you do not have a copy of the MongoDB image locally, expect to see the following output while Docker downloads
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.777.1">
        the image:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.778.1">Unable to find image 'mongo:7' locally
latest: Pulling from library/mongo
bccd10f490ab: Pull complete
b00c7ff578b0: Pull complete
a1f43ab85151: Pull complete
9e72f6a5998a: Pull complete
8424336879e4: Pull complete
85a6d3c2e6c8: Pull complete
c533c21e5fb8: Pull complete
1fddf702bb73: Pull complete
Digest: sha256:0e145625e78b94224d16222ff2609c4621ff6e2c390300e4e6bf698305596792
Status: Downloaded newer image for mongo:7
9230ee867d2b2272448f2596ddc19a7f4de5112c99e4dd31b2d7746b28fbc674</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.779.1">
      We’ll also create a directory for the MongoDB
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.780.1">
       Node.js application:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.781.1">$ mkdir mongodb-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.782.1">$ cd mongodb-app</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.783.1">
      In this recipe, we will need to install modules from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.784.1">
       npm
      </span>
     </strong>
     <span class="koboSpan" id="kobo.785.1">
      registry, so we need to initialize our project with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.786.1">
       $
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.787.1">
        npm init
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.788.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.789.1">$ npm init --yes</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.790.1">
      Create a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.791.1">
       index.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.792.1">
      ; this will contain our application code that interacts
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.793.1">
       with MongoDB:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.794.1">$ touch index.js</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.795.1">
     Now that we have our
    </span>
    <a id="_idIndexMarker567">
    </a>
    <span class="koboSpan" id="kobo.796.1">
     database
    </span>
    <a id="_idIndexMarker568">
    </a>
    <span class="koboSpan" id="kobo.797.1">
     running and the project initialized, we’re ready to move on to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.798.1">
      the recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-222">
    <a id="_idTextAnchor229">
    </a>
    <span class="koboSpan" id="kobo.799.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.800.1">
     In this recipe, we will be using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      mongodb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     module to demonstrate how we can interact with our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.803.1">
      MongoDB database.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.804.1">
      Start by installing the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.805.1">
        mongodb
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.806.1">
       module:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.807.1">$ npm install mongodb</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.808.1">
      First, we’ll add the logic to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.809.1">
       index.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.810.1">
      file to establish a connection to our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.811.1">
       MongoDB database:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.812.1">
const { MongoClient } = require('mongodb');
const URI = 'mongodb://localhost:27017';
const client = new MongoClient(URI);
async function connectToMongoDB () {
  try {
    await client.connect();
    console.log('Connected successfully to server');
    return client.db('Library');
  } catch (err) {
    console.error('Connection to MongoDB failed:',
      err);
  }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.813.1">
      Next, we will craft a function
     </span>
     <a id="_idIndexMarker569">
     </a>
     <span class="koboSpan" id="kobo.814.1">
      to
     </span>
     <a id="_idIndexMarker570">
     </a>
     <span class="koboSpan" id="kobo.815.1">
      insert an author into the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.816.1">
        authors
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.817.1">
       collection:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.818.1">
async function createAuthor (db, author) {
  try {
    const result = await
      db.collection('authors').insertOne(author);
    console.log(`Author created with the following id:
      ${result.insertedId}`);
    return result.insertedId;
  } catch (err) {
    console.error('Create author failed:', err);
  }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.819.1">
      Create a function to insert a book into the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.820.1">
        books
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.821.1">
       collection:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.822.1">
async function createBook (db, book) {
  try {
    const result = await
      db.collection('books').insertOne(book);
    console.log(`Book created with the following id:
      ${result.insertedId}`);
    return result.insertedId;
  } catch (err) {
    console.error('Create book failed:', err);
  }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.823.1">
      Create a function to
     </span>
     <a id="_idIndexMarker571">
     </a>
     <span class="koboSpan" id="kobo.824.1">
      find
     </span>
     <a id="_idIndexMarker572">
     </a>
     <span class="koboSpan" id="kobo.825.1">
      all authors in the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.826.1">
        authors
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.827.1">
       collection:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.828.1">
async function findAllAuthors (db) {
  try {
    const authors = await
      db.collection('authors').find().toArray();
    console.log('Authors:', authors);
    return authors;
  } catch (err) {
    console.error('Find all authors failed:', err);
  }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.829.1">
      Create a function to find all books and populate them with author details using an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.830.1">
       aggregation pipeline:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.831.1">
async function findAllBooksWithAuthors (db) {
  try {
    const books = await
      db.collection('books').aggregate([
      {
        $lookup: {
          from: 'authors',
          localField: 'authorId',
          foreignField: '_id',
          as: 'authorDetails'
        }
      }
    ]).toArray();
    console.log('Books with author details:', books);
    return books;
  } catch (err) {
    console.error('Find all books with authors
      failed:', err);
  }
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.832.1">
      Finally, we will
     </span>
     <a id="_idIndexMarker573">
     </a>
     <span class="koboSpan" id="kobo.833.1">
      use
     </span>
     <a id="_idIndexMarker574">
     </a>
     <span class="koboSpan" id="kobo.834.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.835.1">
       createAuthor()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.836.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.837.1">
       createBook()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.838.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.839.1">
       findAllAuthors()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.840.1">
      , and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.841.1">
       findAllBooksWithAuthors()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.842.1">
      functions in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.843.1">
       main()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.844.1">
      function to perform the operations
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.845.1">
       in sequence:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.846.1">
async function main () {
  const db = await connectToMongoDB();
  if (!db) return;
  const authorId = await createAuthor(db, { name:
    'Richard Adams' });
  if (!authorId) return;
  await createBook(db, { title: 'Watership Down',
    authorId });
  await findAllAuthors(db);
  await findAllBooksWithAuthors(db);
  client.close();
}
main().catch(console.error);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.847.1">
      Run
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.848.1">
       the script:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.849.1">$ node index.js</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.850.1">
     In this recipe, we built a
    </span>
    <a id="_idIndexMarker575">
    </a>
    <span class="koboSpan" id="kobo.851.1">
     Node.js
    </span>
    <a id="_idIndexMarker576">
    </a>
    <span class="koboSpan" id="kobo.852.1">
     script that serves as a functional interface to interact with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.853.1">
      MongoDB database.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-223">
    <a id="_idTextAnchor230">
    </a>
    <span class="koboSpan" id="kobo.854.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.855.1">
     In the recipe, we begin by importing the necessary modules, notably the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.856.1">
      MongoClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.857.1">
     class from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.858.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.859.1">
     ’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.860.1">
      mongodb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.861.1">
     module.
    </span>
    <span class="koboSpan" id="kobo.861.2">
     Setting up the MongoDB connection involves defining a URI to connect to the local MongoDB server and initializing a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.862.1">
      MongoClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.863.1">
     instance with this URI.
    </span>
    <span class="koboSpan" id="kobo.863.2">
     In our case, our database was hosted on the typical default host and port for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.864.1">
      MongoDB:
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.865.1">
       mongodb://localhost:27017
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.866.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.867.1">
     Note that MongoDB does not enable authentication by default when using Docker, so no authentication parameters were needed in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.868.1">
      connection string.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.869.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.870.1">
      connectToMongoDB()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.871.1">
     function asynchronously attempts to establish a connection to the MongoDB server, logging success or failure messages accordingly and returning a reference to the specified database
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.872.1">
      if successful.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.873.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.874.1">
      mongodb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.875.1">
     module from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.876.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.877.1">
     exposes a vast range of CRUD methods to interact with the MongoDB collections in your MongoDB database.
    </span>
    <span class="koboSpan" id="kobo.877.2">
     The term
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.878.1">
      CRUD
     </span>
    </em>
    <span class="koboSpan" id="kobo.879.1">
     is used to represent the basic functions for persistent storage.
    </span>
    <span class="koboSpan" id="kobo.879.2">
     In this recipe, we used the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.880.1">
      find()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.881.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.882.1">
      insertOne()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.883.1">
     CRUD methods.
    </span>
    <span class="koboSpan" id="kobo.883.2">
     A full list of available methods is defined in the Node.js MongoDB driver API
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      documentation (
     </span>
    </span>
    <a href="https://mongodb.github.io/node-mongodb-native/6.5/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.885.1">
       https://mongodb.github.io/node-mongodb-native/6.5/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.886.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.887.1">
     We also used the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.888.1">
      aggregate()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.889.1">
     method in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.890.1">
      findAllBooksWithAuthors()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.891.2">
     An aggregation pipeline can contain one or more stages to create a flow of operations that processes, transforms, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.892.1">
      returns results.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.893.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.894.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.895.1">
     function orchestrates the execution flow, starting with connecting to the MongoDB database.
    </span>
    <span class="koboSpan" id="kobo.895.2">
     Upon successful connection, it proceeds to create an author document for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.896.1">
      Richard Adams
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     and a corresponding book document titled
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      Watership Down
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     , associating them together.
    </span>
    <span class="koboSpan" id="kobo.899.2">
     Subsequently, it retrieves all authors and books with their associated author details using the defined functions.
    </span>
    <span class="koboSpan" id="kobo.899.3">
     Error handling is implemented throughout the script using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.900.1">
      try
     </span>
    </strong>
    <span class="koboSpan" id="kobo.901.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.902.1">
      catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.903.1">
     blocks to handle any potential errors that may arise during execution.
    </span>
    <span class="koboSpan" id="kobo.903.2">
     Finally, the script concludes by closing the MongoDB
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.904.1">
      client connection.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.905.1">
     Overall, this script serves
    </span>
    <a id="_idIndexMarker577">
    </a>
    <span class="koboSpan" id="kobo.906.1">
     as
    </span>
    <a id="_idIndexMarker578">
    </a>
    <span class="koboSpan" id="kobo.907.1">
     a practical example of how to utilize Node.js and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.908.1">
      mongodb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.909.1">
     package to perform CRUD operations on a MongoDB database, demonstrating basic functionalities such as connecting to the database, inserting documents, querying collections, and handling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.910.1">
      errors effectively.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-224">
    <a id="_idTextAnchor231">
    </a>
    <span class="koboSpan" id="kobo.911.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.912.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.913.1">
       Connecting and persisting to a MySQL database
      </span>
     </em>
     <span class="koboSpan" id="kobo.914.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.915.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.916.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.917.1">
       Connecting and persisting to a PostgreSQL database
      </span>
     </em>
     <span class="koboSpan" id="kobo.918.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.919.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.920.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.921.1">
       Persisting data with Redis
      </span>
     </em>
     <span class="koboSpan" id="kobo.922.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.923.1">
       this chapter
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-225">
    <a id="_idTextAnchor232">
    </a>
    <span class="koboSpan" id="kobo.924.1">
     Persisting data with Redis
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.925.1">
     Redis is an open
    </span>
    <a id="_idIndexMarker579">
    </a>
    <span class="koboSpan" id="kobo.926.1">
     source in-memory
    </span>
    <a id="_idIndexMarker580">
    </a>
    <span class="koboSpan" id="kobo.927.1">
     key-value data store.
    </span>
    <span class="koboSpan" id="kobo.927.2">
     Used in the correct setting, Redis can be a fast-performing data store.
    </span>
    <span class="koboSpan" id="kobo.927.3">
     It is often used to provide caching in applications but can also be used as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.928.1">
      a database.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.929.1">
      Redis
     </span>
    </strong>
    <span class="koboSpan" id="kobo.930.1">
     , an acronym for
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.931.1">
      Remote Dictionary Server
     </span>
    </strong>
    <span class="koboSpan" id="kobo.932.1">
     , is an in-memory data structure store, often used as a database, cache, and message broker.
    </span>
    <span class="koboSpan" id="kobo.932.2">
     It excels in scenarios requiring high speed and efficiency, such as caching, session management, real-time analytics, and message queuing.
    </span>
    <span class="koboSpan" id="kobo.932.3">
     Redis’s ability to support various data structures, combined with its atomic operations
    </span>
    <a id="_idIndexMarker581">
    </a>
    <span class="koboSpan" id="kobo.933.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.934.1">
      publish/subscribe
     </span>
    </strong>
    <span class="koboSpan" id="kobo.935.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.936.1">
      pub/sub
     </span>
    </strong>
    <span class="koboSpan" id="kobo.937.1">
     ) messaging capabilities, makes it a powerful tool for enhancing the performance and scalability of Node.js applications.
    </span>
    <span class="koboSpan" id="kobo.937.2">
     Its in-memory nature ensures rapid access to data, significantly reducing latency compared to traditional disk-based databases, making it ideal for applications where speed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.938.1">
      is critical.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.939.1">
     In the context of Node.js, Redis is particularly valuable for managing session data in web applications, enabling quick data retrieval, and improving user experience.
    </span>
    <span class="koboSpan" id="kobo.939.2">
     It’s also widely used for implementing caching mechanisms, reducing the load on databases, and speeding up response times.
    </span>
    <span class="koboSpan" id="kobo.939.3">
     Moreover, its pub/sub messaging system facilitates the development of real-time applications, such as chat applications or live notifications, by allowing efficient communication between clients and servers.
    </span>
    <span class="koboSpan" id="kobo.939.4">
     Whether you’re looking to optimize your application’s performance, scale efficiently, or build feature-rich real-time interactions, integrating Redis with Node.js offers a robust solution to meet
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.940.1">
      these needs.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-226">
    <a id="_idTextAnchor233">
    </a>
    <span class="koboSpan" id="kobo.941.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.942.1">
     Before diving into Redis module integration, it’s essential to note that we’ll be using ESM for compatibility.
    </span>
    <span class="koboSpan" id="kobo.942.2">
     For more information on modules, refer to
    </span>
    <a href="B19212_05.xhtml#_idTextAnchor139">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.943.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.944.1">
      .
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.945.1">
      As with the previous databases in this chapter, we will use Docker to provision a Redis database, based on the Docker image available at
     </span>
     <a href="https://hub.docker.com/_/redis">
      <span class="koboSpan" id="kobo.946.1">
       https://hub.docker.com/_/redis
      </span>
     </a>
     <span class="koboSpan" id="kobo.947.1">
      .
     </span>
     <span class="koboSpan" id="kobo.947.2">
      Run the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.948.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.949.1">$ docker run --publish 6379:6379 --name node-redis --detach redis</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.950.1">
       By default, the containerized Redis database will be available
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.951.1">
        at
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.952.1">
         localhost:6379
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.953.1">
        .
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.954.1">
      We will also create a new folder named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.955.1">
       redis-app
      </span>
     </strong>
     <span class="koboSpan" id="kobo.956.1">
      containing a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.957.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.958.1">
        tasks.mjs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.959.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.960.1">$ mkdir redis-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.961.1">$ cd redis-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.962.1">$ touch tasks.mjs</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.963.1">
      In this recipe, we will be making use of third-party
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.964.1">
       npm
      </span>
     </strong>
     <span class="koboSpan" id="kobo.965.1">
      modules; therefore, we need to initialize
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.966.1">
       our project:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.967.1">$ npm init --yes</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.968.1">
     Now that we have Redis running and our project set up, we’re ready to move on to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.969.1">
      the recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-227">
    <a id="_idTextAnchor234">
    </a>
    <span class="koboSpan" id="kobo.970.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.971.1">
     In this recipe, we will
    </span>
    <a id="_idIndexMarker582">
    </a>
    <span class="koboSpan" id="kobo.972.1">
     be using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.973.1">
      redis
     </span>
    </strong>
    <span class="koboSpan" id="kobo.974.1">
     module
    </span>
    <a id="_idIndexMarker583">
    </a>
    <span class="koboSpan" id="kobo.975.1">
     to interact with our Redis
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.976.1">
      data store.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.977.1">
      Start by installing the third-party
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.978.1">
        redis
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.979.1">
       module:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.980.1">$ npm install redis</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.981.1">
      We now need to import and create a Redis client
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.982.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.983.1">
        tasks.mjs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.984.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.985.1">
import { createClient } from 'redis';
const client = createClient();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.986.1">
      We’ll also accept command-line input for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.987.1">
       our task:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.988.1">
const task = process.argv[2];</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.989.1">
      Next, we’ll add an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.990.1">
       error
      </span>
     </strong>
     <span class="koboSpan" id="kobo.991.1">
      event handler to catch any errors that occur on our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.992.1">
       Redis client:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.993.1">
client.on('error', (err) =&gt; {
    console.log('Error:', err);
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.994.1">
      We need to initialize
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.995.1">
       the connection:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.996.1">
await client.connect();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.997.1">
      Now, we’ll add a statement that will control the flow of our program.
     </span>
     <span class="koboSpan" id="kobo.997.2">
      If a task is passed as input to our program, we will add this task and then list the tasks stored in Redis.
     </span>
     <span class="koboSpan" id="kobo.997.3">
      If no task is supplied, then we will just list the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.998.1">
       stored tasks:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.999.1">
if (!task) {
    listTasks();
} else {
    addTask(task);
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1000.1">
      Below this
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1001.1">
       if
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1002.1">
      statement, we
     </span>
     <a id="_idIndexMarker584">
     </a>
     <span class="koboSpan" id="kobo.1003.1">
      will
     </span>
     <a id="_idIndexMarker585">
     </a>
     <span class="koboSpan" id="kobo.1004.1">
      create our
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1005.1">
        addTask()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1006.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1007.1">
async function addTask(task) {
    const key =
      `Task:${Math.random().toString(32).replace('.',
        '')}`;
    await client.hSet(key, 'task', task);
    listTasks();
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1008.1">
      Finally, after the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1009.1">
       addTask()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1010.1">
      function, we’ll add our
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1011.1">
        listTasks()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1012.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
async function listTasks() {
    const keys = await client.keys('Task:*');
    for (const key of keys) {
        const task = await client.hGetAll(key);
        console.log(task);
    }
    client.quit();
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1014.1">
      Now, we can run the program with a task passed as command-line input.
     </span>
     <span class="koboSpan" id="kobo.1014.2">
      The task will be stored in Redis and subsequently printed via the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1015.1">
        listTasks()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1016.1">
       function:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1017.1">$ node tasks.mjs "Walk the dog."</span></strong><span class="koboSpan" id="kobo.1018.1">
{ task: 'Walk the dog.' </span><span class="koboSpan" id="kobo.1018.2">}</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1019.1">
     We’ve now
    </span>
    <a id="_idIndexMarker586">
    </a>
    <span class="koboSpan" id="kobo.1020.1">
     persisted data in our Redis data store
    </span>
    <a id="_idIndexMarker587">
    </a>
    <span class="koboSpan" id="kobo.1021.1">
     using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1022.1">
       redis
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1023.1">
      module.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-228">
    <a id="_idTextAnchor235">
    </a>
    <span class="koboSpan" id="kobo.1024.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1025.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1026.1">
      createClient()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1027.1">
     method initializes
    </span>
    <a id="_idIndexMarker588">
    </a>
    <span class="koboSpan" id="kobo.1028.1">
     a new client connection.
    </span>
    <span class="koboSpan" id="kobo.1028.2">
     This method will default to configuration for a Redis instance at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1029.1">
      localhost:6379
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1030.1">
     , where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1031.1">
      6379
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1032.1">
     is the conventional port for Redis.
    </span>
    <span class="koboSpan" id="kobo.1032.2">
     In previous versions of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1033.1">
      redis
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1034.1">
     module from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1035.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1036.1">
     , the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1037.1">
      createClient()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1038.1">
     method would automatically connect to the server.
    </span>
    <span class="koboSpan" id="kobo.1038.2">
     However, it’s now necessary to explicitly call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1039.1">
      client.connect()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1040.1">
     to establish
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1041.1">
      a connection.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1042.1">
     Within our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1043.1">
      addTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1044.1">
     function, we generate a random string, or hash, to append to our task key.
    </span>
    <span class="koboSpan" id="kobo.1044.2">
     This ensures that each task key is unique, while still having a specifier indicating that it is a task to aid debugging.
    </span>
    <span class="koboSpan" id="kobo.1044.3">
     This is a common convention when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1045.1">
      using Redis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1046.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1047.1">
      hSet()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1048.1">
     method sets
    </span>
    <a id="_idIndexMarker589">
    </a>
    <span class="koboSpan" id="kobo.1049.1">
     the key and value in Redis; this is what stores our task in Redis.
    </span>
    <span class="koboSpan" id="kobo.1049.2">
     If we supplied a key that already existed, this method would overwrite
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1050.1">
      the contents.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.1051.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1052.1">
     The legacy
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1053.1">
      hmset()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1054.1">
     method is
    </span>
    <a id="_idIndexMarker590">
    </a>
    <span class="koboSpan" id="kobo.1055.1">
     considered deprecated in newer versions of Redis.
    </span>
    <span class="koboSpan" id="kobo.1055.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1056.1">
      hSet()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1057.1">
     method used in the recipe should be used for setting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1058.1">
      hash values.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1059.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1060.1">
      listTasks()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1061.1">
     function, we use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1062.1">
      keys()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1063.1">
     method to search for all keys stored in our Redis data store that match the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1064.1">
      Tasks:*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1065.1">
     wildcard.
    </span>
    <span class="koboSpan" id="kobo.1065.2">
     We’re leveraging the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1066.1">
      keys()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1067.1">
     method to list all tasks we have stored in Redis.
    </span>
    <span class="koboSpan" id="kobo.1067.2">
     Note that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1068.1">
      keys()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1069.1">
     method in real applications should be used with caution.
    </span>
    <span class="koboSpan" id="kobo.1069.2">
     This is because, in applications with many keys, searching could have negative
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1070.1">
      performance implications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1071.1">
     Once we have all our task keys, we use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1072.1">
      hGetAll()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1073.1">
     method to return the value at each key.
    </span>
    <span class="koboSpan" id="kobo.1073.2">
     Once obtained, we print this value to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1074.1">
      STDOUT
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1075.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1076.1">
       console.log()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1077.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1078.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1079.1">
      redis
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1080.1">
     module
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1081.1">
      npm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1082.1">
     provides a one-to-one mapping of all available Redis commands.
    </span>
    <span class="koboSpan" id="kobo.1082.2">
     Refer to
    </span>
    <a href="https://redis.io/commands">
     <span class="koboSpan" id="kobo.1083.1">
      https://redis.io/commands
     </span>
    </a>
    <span class="koboSpan" id="kobo.1084.1">
     for a complete list of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1085.1">
      Redis commands.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-229">
    <a id="_idTextAnchor236">
    </a>
    <span class="koboSpan" id="kobo.1086.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1087.1">
     The Redis instance
    </span>
    <a id="_idIndexMarker591">
    </a>
    <span class="koboSpan" id="kobo.1088.1">
     you’re interacting with may require authentication.
    </span>
    <span class="koboSpan" id="kobo.1088.2">
     Let’s look at how we can connect to a Redis instance that requires
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1089.1">
      a password.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.1090.1">
     Authenticating with Redis
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.1091.1">
     To connect to a
    </span>
    <a id="_idIndexMarker592">
    </a>
    <span class="koboSpan" id="kobo.1092.1">
     Redis client that requires authentication, we can supply the credentials via the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1093.1">
       createClient()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1094.1">
      method.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1095.1">
      We can, again, use Docker to create a password-protected Redis instance.
     </span>
     <span class="koboSpan" id="kobo.1095.2">
      This Redis container will be available
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1096.1">
       at
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1097.1">
        localhost:6380
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1098.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1099.1">$ docker run --publish 6380:6379 --name node-redis-pw --detach redis redis-server --requirepass PASSWORD</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1100.1">
      Copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1101.1">
       tasks.mjs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1102.1">
      file into a new file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1103.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1104.1">
        tasks-auth.mjs
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1105.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1106.1">$ cp tasks.mjs tasks-auth.mjs</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1107.1">
      Now, we need to pass the new Redis instance’s configuration information to the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1108.1">
        createClient()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1109.1">
       method:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1110.1">
import { createClient } from 'redis';
</span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">const client = redis.createClient({</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1112.1">    port: 6380,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1113.1">    password: 'PASSWORD',</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1114.1">});</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1115.1">
      Now, as before, we can run the program with a task passed as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1116.1">
       command-line input:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1117.1">$ node tasks-auth.mjs "Wash the car."</span></strong><span class="koboSpan" id="kobo.1118.1">
{ task: 'Wash the car.' </span><span class="koboSpan" id="kobo.1118.2">}</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1119.1">
     Note that as we’re
    </span>
    <a id="_idIndexMarker593">
    </a>
    <span class="koboSpan" id="kobo.1120.1">
     pointing to a different Redis instance, it will not contain the tasks we added in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1121.1">
      main recipe.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.1122.1">
     Transactions with Redis
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.1123.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1124.1">
      redis
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1125.1">
     module exposes
    </span>
    <a id="_idIndexMarker594">
    </a>
    <span class="koboSpan" id="kobo.1126.1">
     a method named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1127.1">
      multi()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1128.1">
     that can
    </span>
    <a id="_idIndexMarker595">
    </a>
    <span class="koboSpan" id="kobo.1129.1">
     be used to create a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1130.1">
      transaction
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1131.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1131.2">
     A transaction is a series of commands that are queued and then executed as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1132.1">
      single unit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1133.1">
     For example, we could use the following to update a task as a transaction by executing a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1134.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1135.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1136.1">
      set()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1137.1">
     ,
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1138.1">
       get()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1139.1">
      sequence:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1140.1">
import { createClient } from 'redis';
const client = createClient();
client.on('error', (err) =&gt; {
  console.log('Error:', err);
});
await client.connect();
await client.set('Task:3', 'Write letter.');
</span><strong class="bold"><span class="koboSpan" id="kobo.1141.1">const resultsArray = await client</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1142.1">  .multi()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1143.1">  .get('Task:3')</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1144.1">  .set('Task:3', 'Mail letter.')</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1145.1">  .get('Task:3')</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1146.1">  .exec();</span></strong><span class="koboSpan" id="kobo.1147.1">
console.log(resultsArray);
// ['Write letter.', 'OK', 'Mail letter.']
client.quit();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1148.1">
     Each of the tasks is queued until the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1149.1">
      exec()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1150.1">
     method is executed.
    </span>
    <span class="koboSpan" id="kobo.1150.2">
     If any command fails to be queued, none of the commands in the batch are executed.
    </span>
    <span class="koboSpan" id="kobo.1150.3">
     During the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1151.1">
      exec()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1152.1">
     method, all
    </span>
    <a id="_idIndexMarker596">
    </a>
    <span class="koboSpan" id="kobo.1153.1">
     commands
    </span>
    <a id="_idIndexMarker597">
    </a>
    <span class="koboSpan" id="kobo.1154.1">
     are executed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1155.1">
      in order.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-230">
    <a id="_idTextAnchor237">
    </a>
    <span class="koboSpan" id="kobo.1156.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1157.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1158.1">
       Connecting and persisting to a MySQL database
      </span>
     </em>
     <span class="koboSpan" id="kobo.1159.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1160.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1161.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1162.1">
       Connecting and persisting to a PostgreSQL database
      </span>
     </em>
     <span class="koboSpan" id="kobo.1163.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1164.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1165.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1166.1">
       Connecting and persisting to MongoDB
      </span>
     </em>
     <span class="koboSpan" id="kobo.1167.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1168.1">
       this chapter
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-231">
    <a id="_idTextAnchor238">
    </a>
    <span class="koboSpan" id="kobo.1169.1">
     Exploring GraphQL
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1170.1">
     GraphQL serves as a
    </span>
    <a id="_idIndexMarker598">
    </a>
    <span class="koboSpan" id="kobo.1171.1">
     query language for APIs and provides a runtime environment for executing queries.
    </span>
    <span class="koboSpan" id="kobo.1171.2">
     Unlike REST, which relies on rigid endpoint structures, GraphQL allows clients to request exactly what they need and nothing more, making it efficient for fetching data.
    </span>
    <span class="koboSpan" id="kobo.1171.3">
     This flexibility reduces the amount of data transferred over the network and allows for more precise and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1172.1">
      optimized queries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1173.1">
     In projects where your application deals with complex, interrelated data structures, such as social networks, e-commerce platforms, or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1174.1">
      content management systems
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1175.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1176.1">
      CMSs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1177.1">
     ), GraphQL’s ability to query deeply nested data in a single request makes it a perfect match
    </span>
    <a id="_idIndexMarker599">
    </a>
    <span class="koboSpan" id="kobo.1178.1">
     with Node.js.
    </span>
    <span class="koboSpan" id="kobo.1178.2">
     This combination reduces the need for multiple REST endpoints and minimizes data over-fetching, optimizing both the network performance and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1179.1">
      developer experience.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-232">
    <a id="_idTextAnchor239">
    </a>
    <span class="koboSpan" id="kobo.1180.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1181.1">
     In this tutorial, we will create a simple GraphQL API with a book and author relationship using Fastify and Mercurius (
    </span>
    <a href="http://npmjs.com/package/mercurius">
     <span class="koboSpan" id="kobo.1182.1">
      http://npmjs.com/package/mercurius
     </span>
    </a>
    <span class="koboSpan" id="kobo.1183.1">
     ), a GraphQL adapter for Fastify.
    </span>
    <span class="koboSpan" id="kobo.1183.2">
     This tutorial will guide you through setting up your Node.js project, installing dependencies, defining your GraphQL schema, implementing resolvers, and running your server.
    </span>
    <span class="koboSpan" id="kobo.1183.3">
     We’ll use a simple in-memory data structure to simulate a database for authors
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1184.1">
      and books.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1185.1">
     Before diving into the creation of a GraphQL API using Fastify and Mercurius, you’ll need to set up your
    </span>
    <a id="_idIndexMarker600">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1186.1">
      development environment.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1187.1">
      Start by creating a new directory for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1188.1">
       your project:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1189.1">$ mkdir fastify-graphql</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1190.1">$ cd fastify-graphql</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1191.1">
      Initialize the Node.js project
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1192.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1193.1">
        npm
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1194.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1195.1">$ npm init --yes</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1196.1">
     With your environment ready and dependencies installed, let’s move on to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1197.1">
      recipe steps.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-233">
    <a id="_idTextAnchor240">
    </a>
    <span class="koboSpan" id="kobo.1198.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1199.1">
     We’re now ready to build the core functionality of our Fastify GraphQL API.
    </span>
    <span class="koboSpan" id="kobo.1199.2">
     This part of the process involves defining our data models, setting up a GraphQL schema, writing resolvers to handle data fetching, and finally, starting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1200.1">
      our server.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1201.1">
      Let’s start by installing the necessary modules.
     </span>
     <span class="koboSpan" id="kobo.1201.2">
      Our GraphQL server will need a few dependencies to run.
     </span>
     <span class="koboSpan" id="kobo.1201.3">
      Specifically, we will be using Fastify as the web framework and Mercurius as the GraphQL adapter.
     </span>
     <span class="koboSpan" id="kobo.1201.4">
      Install these by running the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1202.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1203.1">$ npm install fastify mercurius</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1204.1">
      Now, we need to create some mock data to work with.
     </span>
     <span class="koboSpan" id="kobo.1204.2">
      This will help us test our GraphQL API without needing a database.
     </span>
     <span class="koboSpan" id="kobo.1204.3">
      In your project folder, create a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1205.1">
       data.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1206.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1206.2">
      This file will contain arrays of authors and books, establishing a simple relationship between them where each book is linked to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1207.1">
       an author:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1208.1">$ touch data.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1209.1">
      Then, add the
     </span>
     <a id="_idIndexMarker601">
     </a>
     <span class="koboSpan" id="kobo.1210.1">
      following to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1211.1">
       data.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1212.1">
      to populate some author and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1213.1">
       book data:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1214.1">
const authors = [
  { id: '1', name: 'Richard Adams' },
  { id: '2', name: 'George Orwell' }
];
const books = [
  { id: '1', name: 'Watership Down', authorId: '1' },
  { id: '2', name: 'Animal Farm', authorId: '2' },
  { id: '3', name: 'Nineteen Eighty-four', authorId:
    '2' },
];
module.exports = { authors, books };</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1215.1">
      Next, we need to create a GraphQL schema to represent our author and book relationship and queries.
     </span>
     <span class="koboSpan" id="kobo.1215.2">
      Create a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1216.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1217.1">
        schema.graphql
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1218.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1219.1">$ touch schema.graphql</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1220.1">
       Now, add the following GraphQL schema
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1221.1">
        to
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.1222.1">
         schema.graphql
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1223.1">
        :
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.1224.1">type Query {
  books: [Book]
  authors: [Author]
}
type Book {
  id: ID
  name: String
  author: Author
}
type Author {
  id: ID
  name: String
  books: [Book]
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1225.1">
      Now, create
     </span>
     <a id="_idIndexMarker602">
     </a>
     <span class="koboSpan" id="kobo.1226.1">
      a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1227.1">
       resolvers.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1228.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1228.2">
      This file will contain functions to handle the logic for fetching
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1229.1">
       the data:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1230.1">$ touch resolvers.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1231.1">
      To implement our GraphQL resolvers, add the following code
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1232.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1233.1">
        resolvers.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1234.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1235.1">
const { authors, books } = require('./data');
const resolvers = {
  Query: {
    books: () =&gt; books,
    authors: () =&gt; authors,
  },
  Book: {
    author: (parent) =&gt; authors.find(author =&gt;
     author.id === parent.authorId),
  },
  Author: {
    books: (parent) =&gt; books.filter(book =&gt;
      book.authorId === parent.id),
  },
};
module.exports = { resolvers };</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1236.1">
      Finally, we can create our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1237.1">
       Fastify server:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1238.1">$ touch server.js</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1239.1">
       Add the
      </span>
      <a id="_idIndexMarker603">
      </a>
      <span class="koboSpan" id="kobo.1240.1">
       following
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1241.1">
        to
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.1242.1">
         server.js
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1243.1">
        :
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.1244.1">const fastify = require('fastify')();
const mercurius = require('mercurius');
const { readFileSync } = require('node:fs');
const { resolvers } = require('./resolvers');
const schema = readFileSync('./schema.graphql', 'utf-
  8');
fastify.register(mercurius, {
  schema,
  resolvers,
  graphiql: true
});
fastify.listen({ port: 3000 }, () =&gt; {
  console.log('Server running at
    http://localhost:3000');
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1245.1">
      Start your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1246.1">
       Fastify server:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1247.1">$ node server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1248.1">
      Open your browser and navigate to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1249.1">
       http://localhost:3000/graphiql
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1250.1">
      to access the
     </span>
     <a id="_idIndexMarker604">
     </a>
     <span class="koboSpan" id="kobo.1251.1">
      GraphiQL interface.
     </span>
     <span class="koboSpan" id="kobo.1251.2">
      You should expect to see an interface
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1252.1">
       like this:
      </span>
     </span>
     <div class="IMG---Figure" id="_idContainer029">
      <span class="koboSpan" id="kobo.1253.1">
       <img alt="Figure 7.1 – GraphiQL interface showing query result" src="image/B19212_07_01.jpg"/>
      </span>
     </div>
    </li>
   </ol>
   <p class="IMG---Figure">
    <a id="_idIndexMarker605">
    </a>
   </p>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1254.1">
     Figure 7.1 – GraphiQL interface showing query result
    </span>
   </p>
   <ol>
    <li value="10">
     <span class="koboSpan" id="kobo.1255.1">
      Try crafting some queries in the GraphiQL interface.
     </span>
     <span class="koboSpan" id="kobo.1255.2">
      For example, try executing the following query to fetch all books with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1256.1">
       their authors:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1257.1">
 query {
  books {
    name
    author {
      name
    }
  }
}</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1258.1">
       Expect to see
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1259.1">
        this
       </span>
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker606">
       </a>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1260.1">
        output:
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer030">
     <span class="koboSpan" id="kobo.1261.1">
      <img alt="Figure 7.2 – GraphiQL interface showing query result" src="image/B19212_07_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1262.1">
     Figure 7.2 – GraphiQL interface showing query result
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1263.1">
     This tutorial provides you with a foundation for creating a GraphQL API using Fastify and Mercurius.
    </span>
    <span class="koboSpan" id="kobo.1263.2">
     From here, you can extend your API by adding more complex types, queries, and mutations or by integrating a database for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1264.1">
      persistent storage.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-234">
    <a id="_idTextAnchor241">
    </a>
    <span class="koboSpan" id="kobo.1265.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1266.1">
     In the tutorial, we explore the creation of a GraphQL API using Fastify and Mercurius by defining data models, establishing a GraphQL schema, implementing resolvers for data fetching, and setting up a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1267.1">
      Fastify server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1268.1">
     By creating mock data in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1269.1">
      data.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1270.1">
     , we simulate a backend data store that contains authors and books.
    </span>
    <span class="koboSpan" id="kobo.1270.2">
     This approach allows us to focus on the GraphQL setup without the complexity of integrating an actual database.
    </span>
    <span class="koboSpan" id="kobo.1270.3">
     The data represents a basic relationship between books and their authors, serving as the foundation for our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1271.1">
      GraphQL queries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1272.1">
     The GraphQL schema defined in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1273.1">
      schema.graphql
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1274.1">
     acts as a contract between the server and the client.
    </span>
    <span class="koboSpan" id="kobo.1274.2">
     It specifies the types of queries that can be made, the types of data that can be fetched, and the relationships between different data types.
    </span>
    <span class="koboSpan" id="kobo.1274.3">
     In our case, the schema outlines how to query books and authors and indicates that each book is linked to an author and vice versa.
    </span>
    <span class="koboSpan" id="kobo.1274.4">
     This structure allows clients to understand and predict the shape of the data returned by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1275.1">
      the API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1276.1">
     The resolvers in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1277.1">
      resolvers.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1278.1">
     are functions that handle the logic for fetching the data for each type specified in the schema.
    </span>
    <span class="koboSpan" id="kobo.1278.2">
     They connect the GraphQL queries to the underlying data, essentially telling the server where and how to retrieve or modify the data.
    </span>
    <span class="koboSpan" id="kobo.1278.3">
     In the recipe, resolvers
    </span>
    <a id="_idIndexMarker607">
    </a>
    <span class="koboSpan" id="kobo.1279.1">
     fetch books and authors from the mock data and resolve the relationships between them, such as finding an author for a book or listing all books written by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1280.1">
      an author.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1281.1">
     Finally, setting up the Fastify server and integrating Mercurius allows us to serve our GraphQL API over HTTP.
    </span>
    <span class="koboSpan" id="kobo.1281.2">
     The server listens for requests on a specified port and uses the schema and resolvers to process
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1282.1">
      GraphQL queries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1283.1">
     Upon running the server, you can navigate to the GraphiQL interface to visually construct and execute queries against your API.
    </span>
    <span class="koboSpan" id="kobo.1283.2">
     This interactive environment is useful for testing and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1284.1">
      debugging queries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1285.1">
     Whether GraphQL is the appropriate architecture for your project is a vast topic that goes well beyond the basics covered in this recipe.
    </span>
    <span class="koboSpan" id="kobo.1285.2">
     It involves deep considerations such as optimizing query performance, ensuring security, efficient data loading to avoid over- or under-fetching, and integrating with different databases or APIs.
    </span>
    <span class="koboSpan" id="kobo.1285.3">
     While we’ve laid the groundwork with Fastify
    </span>
    <a id="_idIndexMarker608">
    </a>
    <span class="koboSpan" id="kobo.1286.1">
     and Mercurius, diving into these more complex aspects is essential for developing sophisticated, production-ready
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1287.1">
      GraphQL services.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-235">
    <a id="_idTextAnchor242">
    </a>
    <span class="koboSpan" id="kobo.1288.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.1289.1">
         Chapter 6
        </span>
       </em>
      </span>
     </a>
    </li>
    <li>
     <a href="B19212_11.xhtml#_idTextAnchor353">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.1290.1">
         Chapter 11
        </span>
       </em>
      </span>
     </a>
    </li>
   </ul>
  </div>
 </body></html>