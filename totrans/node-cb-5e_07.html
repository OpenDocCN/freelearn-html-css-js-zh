<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-205">
    <a id="_idTextAnchor212">
    </a>
    
     7
    
   </h1>
   <h1 id="_idParaDest-206">
    <a id="_idTextAnchor213">
    </a>
    
     Persisting to Databases
    
   </h1>
   <p>
    
     In the world of application development, being able to save and retrieve data is essential.
    
    
     Imagine you’re building a game where you need to keep scores or a social media application where users need to save their profiles and posts.
    
    
     A lot of the time, a traditional relational database is what you need for this.
    
    
     It’s like an organized filing system where everything has its place in neat tables, and these tables can relate to each other in specific ways.
    
    
     For instance, one table might store information about books while another stores information about authors, and links between the two can show which author wrote
    
    
     
      which book.
     
    
   </p>
   <p>
    
     But what if your data doesn’t fit into this structured format?
    
    
     What if you’re dealing with something more flexible or unpredictable, such as posts on a social media feed where some posts have images, some have videos, and others have just text?
    
    
     This is where non-relational, or NoSQL, databases come in.
    
    
     They’re designed to handle a wide variety of data structures, from simple key-value pairs to more complex documents or graphs.
    
    
     This makes them a great choice for modern applications that require flexibility
    
    
     
      and scalability.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     This chapter will focus on interacting with these databases in Node.js.
    
    
     As such, some elementary knowledge of databases
    
    <a id="_idIndexMarker509">
    </a>
    
     and
    
    <strong class="bold">
     
      Structured Query Language
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SQL
     
    </strong>
    
     )
    
    
     
      is assumed.
     
    
   </p>
   <p>
    
     We’ll start with setting up a simple SQL database to understand the fundamentals of database operations.
    
    
     Then, we’ll explore the dynamic world of NoSQL databases, learning how to interact with them to handle more flexible data structures.
    
    
     By the end of this chapter, you’ll have a foundation in using diverse types of databases in your Node.js applications, giving you the flexibility to choose the right storage solution for
    
    
     
      your projects.
     
    
   </p>
   <p>
    
     This chapter will cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Connecting and persisting to a
     
     
      
       MySQL database
      
     
    </li>
    <li>
     
      Connecting and persisting to a
     
     
      
       PostgreSQL database
      
     
    </li>
    <li>
     
      Connecting and persisting
     
     
      
       to MongoDB
      
     
    </li>
    <li>
     
      Persisting data
     
     
      
       with Redis
      
     
    </li>
    <li>
     
      
       Exploring GraphQL
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-207">
    <a id="_idTextAnchor214">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     Throughout this chapter, we will use Docker to provision databases in containers.
    
    
     Using a database container is common when building scalable and resilient architectures – particularly when using a container orchestrator such
    
    
     
      as Kubernetes.
     
    
   </p>
   <p>
    
     However, the main reason why we’ll be using Docker containers throughout this chapter is to save us from having to manually install each of the database
    
    <strong class="bold">
     
      command-line interfaces
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CLIs
     
    </strong>
    
     ) and servers onto our system.
    
    
     In this chapter, we will be using Docker to provision containerized MySQL, PostgreSQL, MongoDB, and Redis
    
    
     
      data stores.
     
    
   </p>
   <p>
    
     It is recommended to install Docker Desktop
    
    
     
      from
     
    
    <a href="https://docs.docker.com/engine/install/">
     
      
       https://docs.docker.com/engine/install/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     If you are unable to install Docker, then you can still complete the recipes, but you will need to manually install the specific databases for each recipe or connect to a remote
    
    
     
      database service.
     
    
   </p>
   <p>
    
     Note that this chapter will not cover how to enable persistent data storage from Docker containers, as this requires knowledge of Docker that is out of scope for a Node.js tutorial.
    
    
     Therefore, once the containers are destroyed or removed, the data accrued during the tutorials will
    
    
     
      be lost.
     
    
   </p>
   <p>
    
     It will also be worthwhile cleaning up and removing your database containers once you’ve completed each recipe by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Enter
     
     <strong class="source-inline">
      
       $ docker ps
      
     </strong>
     
      in your terminal to list your
     
     
      
       Docker containers.
      
     
    </li>
    <li>
     
      From there, locate the container identifier and pass this to the
     
     <strong class="source-inline">
      
       $ docker stop &lt;ContainerID&gt;
      
     </strong>
     
      command to stop
     
     
      
       the container.
      
     
    </li>
    <li>
     
      Follow it up with
     
     <strong class="source-inline">
      
       $ docker rm --force &lt;ContainerID&gt;
      
     </strong>
     
      to remove
     
     
      
       the container.
      
     
    </li>
   </ol>
   <p>
    
     Alternatively, you can use the following command to remove all
    
    
     
      Docker containers:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">$ docker rm --force $(docker ps --all --quiet)</strong></pre>
   <p>
    
     Take caution when using this command if you have other Docker containers, unrelated to the recipes in this book, running on
    
    
     
      your device.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Docker refers to both the virtualization technology and the company Docker Inc.
    
    
     that created the technology.
    
    
     Docker allows you to build applications and services into packages named containers.
    
    
     Refer to
    
    <a href="B19212_11.xhtml#_idTextAnchor353">
     
      <em class="italic">
       
        Chapter 11
       
      </em>
     
    </a>
    
     for more detailed information about the
    
    
     
      Docker technology.
     
    
   </p>
   <p>
    
     In several of the recipes, we will also make use of the
    
    <strong class="source-inline">
     
      dotenv
     
    </strong>
    
     module (
    
    <a href="https://www.npmjs.com/package/dotenv">
     
      https://www.npmjs.com/package/dotenv
     
    </a>
    
     ).
    
    
     The
    
    <strong class="source-inline">
     
      dotenv
     
    </strong>
    
     module loads environment variables from a
    
    <strong class="source-inline">
     
      .env
     
    </strong>
    
     file into the Node.js process.
    
    
     Where necessary, we will be storing example database credentials in a
    
    <strong class="source-inline">
     
      .env
     
    </strong>
    
     file and then using the
    
    <strong class="source-inline">
     
      dotenv
     
    </strong>
    
     module to parse these into our
    
    
     
      Node.js process.
     
    
   </p>
   <p>
    
     You will also need to have Node.js installed, preferably the latest version, Node.js 22, and access to an editor and browser of your choice.
    
    
     The code samples produced for this chapter are available on GitHub at
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     in the
    
    
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-208">
    <a id="_idTextAnchor215">
    </a>
    
     Connecting and persisting to a MySQL database
    
   </h1>
   <p>
    
     SQL is a standard for
    
    <a id="_idIndexMarker510">
    </a>
    
     communicating with relational databases.
    
    
     Both
    
    <a id="_idIndexMarker511">
    </a>
    
     MySQL (
    
    <a href="https://www.mysql.com/">
     
      https://www.mysql.com/
     
    </a>
    
     ) and
    
    <a id="_idIndexMarker512">
    </a>
    
     PostgreSQL (
    
    <a href="https://www.postgresql.org/">
     
      https://www.postgresql.org/
     
    </a>
    
     ) are
    
    <a id="_idIndexMarker513">
    </a>
    
     popular open source
    
    <strong class="bold">
     
      relational database management systems
     
    </strong>
    
     (
    
    <strong class="bold">
     
      RDBMSs
     
    </strong>
    
     ).
    
    
     There are many
    
    <a id="_idIndexMarker514">
    </a>
    
     implementations of SQL databases, and each of them has its extensions and proprietary features.
    
    
     However, there is a base set of commands for storing, updating, and querying data implemented across all these
    
    
     
      SQL databases.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to communicate with a MySQL
    
    <a id="_idIndexMarker515">
    </a>
    
     database from Node.js using the
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     (
    
    <a href="https://www.npmjs.com/package/mysql2">
     
      
       https://www.npmjs.com/package/mysql2
      
     
    </a>
    
     
      ) module.
     
    
   </p>
   <h2 id="_idParaDest-209">
    <a id="_idTextAnchor216">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     First, we need to get a MySQL database running locally.
    
    
     To do this, and for the other databases in this chapter, where possible, we will use Docker.
    
    
     MySQL provides a Docker official image on Docker
    
    <a id="_idIndexMarker516">
    </a>
    
     Hub (
    
    <a href="https://hub.docker.com/_/mysql">
     
      https://hub.docker.com/_/mysql
     
    </a>
    
     ).
    
    
     This recipe assumes some, but minimal, prior knowledge of SQL and
    
    
     
      relational databases.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     In this tutorial, we will use the
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     package from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     for interacting with MySQL databases in Node.js due to its compatibility with the latest MySQL features and its support for promises.
    
    
     The choice of
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     over the previously used
    
    <strong class="source-inline">
     
      mysql
     
    </strong>
    
     package is driven by it being more up to date, allowing us to leverage newer features and capabilities such as the
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       async
      
     </strong>
    
    
     
      /
     
    
    
     <strong class="source-inline">
      
       await
      
     </strong>
    
    
     
      syntax.
     
    
   </p>
   <p>
    
     To set up a MySQL
    
    <a id="_idIndexMarker517">
    </a>
    
     database
    
    <a id="_idIndexMarker518">
    </a>
    
     using Docker and prepare your project, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      In a terminal window, type the following command to start a MySQL database listening on
     
     
      
       port
      
     
     
      <strong class="source-inline">
       
        3306
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ docker run --publish 3306:3306 --name node-mysql --env MYSQL_ROOT_PASSWORD=PASSWORD --detach mysql:8</strong></pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      --publish 3306:3306
     
    </strong>
    
     option in a Docker command maps port
    
    <strong class="source-inline">
     
      3306
     
    </strong>
    
     on the host machine to port
    
    <strong class="source-inline">
     
      3306
     
    </strong>
    
     on the Docker container, allowing external access to the container’s service running on
    
    
     
      that port.
     
    
   </p>
   <p class="list-inset">
    
     If you do not have the images locally, then Docker will first pull down the image from Docker Hub.
    
    
     While Docker is pulling down the image, expect to see output like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
Unable to find image 'mysql:8' locally
latest: Pulling from library/mysql
ea4e27ae0b4c: Pull complete
837904302482: Pull complete
3c574b61b241: Pull complete
654fc4f3eb2d: Pull complete
32da9c2187e3: Pull complete
dc99c3c88bd6: Pull complete
970181cc0aa6: Pull complete
d77b716c39d5: Pull complete
9e650d7f9f83: Pull complete
acc21ff36b4b: Pull complete
Digest: sha256:ff5ab9cdce0b4c59704b4e2a09deed5ab8467be795e0ea20228b8528f53fcf82
Status: Downloaded newer image for mysql:8
dbb88d7d042966351a79ae159eb73129d69961b2c3dab943d9f4cdd6697d5220</pre>
   <p class="list-inset">
    
     The
    
    <strong class="source-inline">
     
      --detach
     
    </strong>
    
     argument indicates that we wish to start the container in detached mode – this
    
    <a id="_idIndexMarker519">
    </a>
    
     means
    
    <a id="_idIndexMarker520">
    </a>
    
     that the container is running in the background.
    
    
     Omitting the
    
    <strong class="source-inline">
     
      --detach
     
    </strong>
    
     argument would mean your terminal window would be held by
    
    
     
      the container.
     
    
   </p>
   <ol>
    <li value="2">
     
      Next, we will create a new directory for
     
     
      
       this recipe:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir mysql-app</strong>
<strong class="bold">$ cd mysql-app</strong></pre>
    </li>
    <li>
     
      As we will be installing modules from
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      , we also need to initialize
     
     
      
       our project:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
     <p class="list-inset">
      
       We’ll also prepare two files for use in the recipe.
      
      
       The first will be a script named
      
      <strong class="source-inline">
       
        setupDb.mjs
       
      </strong>
      
       to create the database; the second will be a script to add a new task to the database, named
      
      <strong class="source-inline">
       
        task.mjs
       
      </strong>
      
       .
      
      
       While we’re here, let’s also create a
      
      <strong class="source-inline">
       
        .env
       
      </strong>
      
       file ready to store our
      
      
       
        database credentials:
       
      
     </p>
     <pre class="source-code">$ touch setupDb.mjs tasks.mjs
$ touch .env</pre>
    </li>
    <li>
     
      Add the example credentials for our MySQL instance to the
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        env
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
DB_MYSQL_USER=root
DB_MYSQL_PASSWORD=PASSWORD</pre>
     <p class="list-inset">
      
       Be aware these are example credentials for simplicity – you should use stronger credentials in your applications.
      
      
       Also, be sure not to accidentally commit
      
      <strong class="source-inline">
       
        .env
       
      </strong>
      
       files to
      
      <strong class="bold">
       
        version control systems
       
      </strong>
      
       (
      
      <strong class="bold">
       
        VCSs
       
      </strong>
      
       , such as Git) as this can lead to leaking of
      
      <a id="_idIndexMarker521">
      </a>
      
       
        sensitive credentials.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     Now that we have the
    
    <a id="_idIndexMarker522">
    </a>
    
     MySQL
    
    <a id="_idIndexMarker523">
    </a>
    
     database running and our project initialized, we’re ready to move on to
    
    
     
      the recipe.
     
    
   </p>
   <h2 id="_idParaDest-210">
    <a id="_idTextAnchor217">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll be focusing on how to install the
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     module from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     , connect to a MySQL database, and perform basic SQL queries.
    
    
     We’ll use a straightforward task list example to illustrate these concepts.
    
    
     We’ll also be using
    
    <strong class="bold">
     
      ECMAScript Modules
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ESM
     
    </strong>
    
     ) syntax, covered
    
    <a id="_idIndexMarker524">
    </a>
    
     in the
    
    <em class="italic">
     
      Using ECMAScript modules
     
    </em>
    
     recipe of
    
    <a href="B19212_05.xhtml#_idTextAnchor139">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     This approach should help you understand the practical application of managing and manipulating data with SQL in a
    
    
     
      MySQL database.
     
    
   </p>
   <ol>
    <li>
     
      First, we need to install the
     
     <strong class="source-inline">
      
       dotenv
      
     </strong>
     
      module, for parsing environment variable configuration, and the
     
     
      <strong class="source-inline">
       
        mysql2
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install dotenv mysql2</strong></pre>
    </li>
    <li>
     
      We’ll start by writing a script to set up our task list database.
     
     
      To do this, we’ll first need to import and load our credentials using the
     
     <strong class="source-inline">
      
       dotenv
      
     </strong>
     
      module and import the
     
     <strong class="source-inline">
      
       mysql2
      
     </strong>
     
      module.
     
     
      Add the following to
     
     <strong class="source-inline">
      
       setupDb.mjs
      
     </strong>
     
      to
     
     
      
       do that:
      
     
     <pre class="source-code">
import dotenv from 'dotenv';
import mysql from 'mysql2/promise';
dotenv.config();</pre>
    </li>
    <li>
     
      Now, let’s scaffold a
     
     <strong class="source-inline">
      
       main()
      
     </strong>
     
      function.
     
     
      We will add the logic to this function as we progress through the tutorial steps.
     
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        setupDb.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
async function main () {
}
main().catch(console.error);</pre>
    </li>
    <li>
     
      Now, let’s start adding our connection logic, and we’ll wrap this in a
     
     <strong class="source-inline">
      
       try
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       catch
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       finally
      
     </strong>
     
      structure where
     
     <strong class="source-inline">
      
       finally
      
     </strong>
     
      will close the database connection.
     
     
      Within
     
     <a id="_idIndexMarker525">
     </a>
     
      the
     
     <strong class="source-inline">
      
       main()
      
     </strong>
     
      function, add
     
     
      
       the
      
     
     
      <a id="_idIndexMarker526">
      </a>
     
     
      
       following:
      
     
     <pre class="source-code">
async function main() {
<strong class="bold">  let connection;</strong>
<strong class="bold">  try {</strong>
<strong class="bold">    connection = await mysql.createConnection({</strong>
<strong class="bold">      user: process.env.DB_MYSQL_USER,</strong>
<strong class="bold">      password: process.env.DB_MYSQL_PASSWORD,</strong>
<strong class="bold">    });</strong>
<strong class="bold">    console.log('Connected as id ' +</strong>
<strong class="bold">        connection.threadId);</strong>
<strong class="bold">   } catch (error) {</strong>
<strong class="bold">    console.error('Error connecting: ' + error.stack);</strong>
<strong class="bold">  } finally {</strong>
<strong class="bold">    if (connection) await connection.end();</strong>
<strong class="bold">  }</strong>
}</pre>
     <p class="list-inset">
      
       We can run this file in our terminal to test
      
      
       
        the connection:
       
      
     </p>
     <pre class="source-code"><strong class="bold">$ node setupDb.mjs</strong>
<strong class="bold">Connected as id 10</strong></pre>
    </li>
    <li>
     
      Now, let’s add our logic to create tables.
     
     
      To do this, we’ll use two separate SQL statements.
     
     
      The first will create a database and instruct the connection to use it.
     
     
      The second will
     
     <a id="_idIndexMarker527">
     </a>
     
      create a
     
     <strong class="source-inline">
      
       tasks
      
     </strong>
     
      database table.
     
     
      Add the following to the
     
     <strong class="source-inline">
      
       main()
      
     </strong>
     
      function, below
     
     <a id="_idIndexMarker528">
     </a>
     
      the
     
     <strong class="source-inline">
      
       console.log('Connected as ...
      
     </strong>
     
      
       line:
      
     
     <pre class="source-code">
<strong class="bold">await connection.query('CREATE DATABASE IF NOT EXISTS</strong>
<strong class="bold">  tasks');</strong>
<strong class="bold">console.log('Database created or already exists.');</strong>
<strong class="bold">await connection.query('USE tasks');</strong>
<strong class="bold">const createTasksTableSql =</strong>
<strong class="bold">  `CREATE TABLE IF NOT EXISTS tasks (</strong>
<strong class="bold">    id INT AUTO_INCREMENT PRIMARY KEY,</strong>
<strong class="bold">    task VARCHAR(255) NOT NULL,</strong>
<strong class="bold">    completed BOOLEAN NOT NULL DEFAULT FALSE</strong>
<strong class="bold">    )`;</strong>
<strong class="bold">await connection.query(createTasksTableSql);</strong>
<strong class="bold">console.log('Tasks table created or already exists.');</strong></pre>
    </li>
    <li>
     
      Run the program in your terminal with the
     
     
      
       following command:
      
     
     <pre class="source-code">
$ <strong class="bold">node setupDb.mjs</strong>
Connected as id 18
Database created or already exists.
Tasks table created or already exists.</pre>
    </li>
    <li>
     
      Now, we can implement our logic in
     
     <strong class="source-inline">
      
       tasks.mjs
      
     </strong>
     
      to input some data into our table, again via a SQL
     
     <a id="_idIndexMarker529">
     </a>
     
      query.
     
     
      Start
     
     <a id="_idIndexMarker530">
     </a>
     
      by copying the same connection logic we used
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        setupDb.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
import dotenv from 'dotenv';
import mysql from 'mysql2/promise';
dotenv.config();
async function main() {
  let connection;
  try {
    connection = await mysql.createConnection({
      user: process.env.DB_MYSQL_USER,
      password: process.env.DB_MYSQL_PASSWORD,
    });
    console.log('Connected as id ' +
        connection.threadId);
  } catch (error) {
    console.error('Error connecting: ' + error.stack);
  } finally {
    if (connection) await connection.end();
  }
}
main().catch(console.error);</pre>
     <p class="list-inset">
      
       Note that we end the connection to our MySQL database
      
      
       
        using
       
      
      
       <strong class="source-inline">
        
         connection.end()
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      Now, we can add some logic to receive the task details from the command line.
     
     
      Add the following logic below the
     
     <strong class="source-inline">
      
       console.log('Connected
      
     </strong>
     
      <strong class="source-inline">
       
        as
       
      </strong>
     
     
      
       … line
      
     
     
      
       :
      
     
     <pre class="source-code">
    if (process.argv[2]) {
      await connection.query(
          `INSERT INTO tasks.tasks (task) VALUES
              (?);`,
          [process.argv[2]]
      );
    }</pre>
    </li>
    <li>
     
      Let’s add a query that will obtain the contents of the
     
     
      <strong class="source-inline">
       
        tasks
       
      </strong>
     
     
      
       table:
      
     
     <pre class="source-code">
const [results] = await connection.query('SELECT *
  FROM tasks.tasks;');
    console.log(results);</pre>
    </li>
    <li>
     
      Now, run the
     
     <a id="_idIndexMarker531">
     </a>
     
      program
     
     <a id="_idIndexMarker532">
     </a>
     
      with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node tasks.mjs "Walk the dog."</strong>
Connected as id 10
[ { id: 1, task: 'Walk the dog.', completed: 0 } ]</pre>
     <p class="list-inset">
      
       Each time we run the program, our insert query will be executed, meaning a new entry will be made in the
      
      
       <strong class="source-inline">
        
         tasks
        
       </strong>
      
      
       
        table.
       
      
     </p>
    </li>
   </ol>
   <h2 id="_idParaDest-211">
    <a id="_idTextAnchor218">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      createConnection()
     
    </strong>
    
     method exposed from the
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     module establishes a connection to the MySQL server based on the configuration and credentials passed to the method.
    
    
     In the recipe, we passed the
    
    <strong class="source-inline">
     
      createConnection()
     
    </strong>
    
     method the username and password for our database using environment variables.
    
    
     The
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     module defaults to looking for a MySQL database at
    
    <strong class="source-inline">
     
      localhost:3306
     
    </strong>
    
     , which is where the MySQL Docker container that we created in the
    
    <em class="italic">
     
      Getting ready
     
    </em>
    
     section of the recipe was exposed.
    
    
     The
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     module from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     aims to provide equivalent functionality to the preceding
    
    <strong class="source-inline">
     
      mysql
     
    </strong>
    
     module from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     .
    
    
     A complete list of options that can be passed to the
    
    <strong class="source-inline">
     
      createConnection()
     
    </strong>
    
     method is available in the
    
    <strong class="source-inline">
     
      mysql
     
    </strong>
    
     module API documentation
    
    
     
      at
     
    
    <a href="https://github.com/mysqljs/mysql#connection-options">
     
      
       https://github.com/mysqljs/mysql#connection-options
      
     
    </a>
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Connection pools can also be utilized to minimize the time needed to connect to the MySQL server by reusing existing connections instead of closing them after use.
    
    
     This approach enhances query latency by eliminating the overhead associated with setting up new connections.
    
    
     Such a strategy is crucial for the development of large-scale applications.
    
    
     For more details, consult the API documentation
    
    
     
      at
     
    
    <a href="https://sidorares.github.io/node-mysql2/docs#using-connection-pools">
     
      
       https://sidorares.github.io/node-mysql2/docs#using-connection-pools
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Throughout the recipe, we used the
    
    <strong class="source-inline">
     
      query()
     
    </strong>
    
     method to send SQL statements to the MySQL database.
    
    
     The SQL statements in the
    
    <strong class="source-inline">
     
      setupDb.mjs
     
    </strong>
    
     file created a
    
    <strong class="source-inline">
     
      tasks
     
    </strong>
    
     database and a
    
    <strong class="source-inline">
     
      tasks
     
    </strong>
    
     table.
    
    
     The
    
    <strong class="source-inline">
     
      task.mjs
     
    </strong>
    
     file included SQL to insert a single task into the
    
    <strong class="source-inline">
     
      tasks
     
    </strong>
    
     table.
    
    
     The final SQL statement we sent to the database using the
    
    <strong class="source-inline">
     
      query()
     
    </strong>
    
     method was
    
    <a id="_idIndexMarker533">
    </a>
    
     a
    
    <strong class="source-inline">
     
      SELECT
     
    </strong>
    
     statement, which
    
    <a id="_idIndexMarker534">
    </a>
    
     returned the contents of the
    
    
     <strong class="source-inline">
      
       tasks
      
     </strong>
    
    
     
      table.
     
    
   </p>
   <p>
    
     Each of the SQL statements is queued and executed asynchronously.
    
    
     It is possible to pass a callback function as a parameter to the
    
    <strong class="source-inline">
     
      query()
     
    </strong>
    
     method, but we instead leverage the
    
    
     <strong class="source-inline">
      
       async
      
     </strong>
    
    
     
      /
     
    
    
     <strong class="source-inline">
      
       await
      
     </strong>
    
    
     
      syntax.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      end()
     
    </strong>
    
     method, as the name suggests, ends the connection to the database.
    
    
     The
    
    <strong class="source-inline">
     
      end()
     
    </strong>
    
     method ensures that there are no queries still queued or processing before ending the connection.
    
    
     There’s another method,
    
    <strong class="source-inline">
     
      destroy()
     
    </strong>
    
     , that will immediately terminate the connection to the database, ignoring the state of any pending or
    
    
     
      executing queries.
     
    
   </p>
   <p>
    
     One of the common types of attacks on user-facing web applications that it is necessary to be aware of is SQL
    
    
     
      injection attacks.
     
    
   </p>
   <p>
    
     A SQL injection is where an attacker sends malicious SQL statements to your database.
    
    
     This is often achieved by inserting the malicious SQL statement into a web page input field.
    
    
     This is not a Node.js-specific problem; it also applies to other programming languages where the SQL query is created through string concatenation.
    
    
     The way to mitigate against any of these attacks is to sanitize or escape user input such that our SQL statements cannot be
    
    
     
      maliciously manipulated.
     
    
   </p>
   <p>
    
     You can manually escape user-supplied data directly by using
    
    <strong class="source-inline">
     
      connection.escape()
     
    </strong>
    
     .
    
    
     In the recipe, however, we used the placeholder (
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     ) syntax in our SQL query to achieve
    
    
     
      the same:
     
    
   </p>
   <pre class="source-code">
await connection.query(
          `INSERT INTO tasks.tasks (task) VALUES (?);`,
          [process.argv[2]]
      );</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      mysql2
     
    </strong>
    
     module handles the sanitizing of user input for us if we pass our input values to the query via the second parameter of the
    
    <strong class="source-inline">
     
      query
     
    </strong>
    
     function.
    
    
     Multiple placeholders (
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     ) are mapped
    
    <a id="_idIndexMarker535">
    </a>
    
     to
    
    <a id="_idIndexMarker536">
    </a>
    
     values in the SQL query in the order they
    
    
     
      are supplied.
     
    
   </p>
   <h2 id="_idParaDest-212">
    <a id="_idTextAnchor219">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Building on the basics
    
    <a id="_idIndexMarker537">
    </a>
    
     of interacting with MySQL with Node.js, this section introduces how to create a REST API using Fastify in conjunction with MySQL.
    
    
     We’ll walk through essential steps such as setting up the project, starting a Fastify server, connecting it to MySQL with the
    
    <strong class="source-inline">
     
      @fastify/mysql
     
    </strong>
    
     plugin (
    
    <a href="https://www.npmjs.com/package/@fastify/mysql">
     
      https://www.npmjs.com/package/@fastify/mysql
     
    </a>
    
     ), and creating
    
    <a id="_idIndexMarker538">
    </a>
    
     routes to handle
    
    <strong class="bold">
     
      create, read, update, delete
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       CRUD
      
     </strong>
    
    
     
      ) operations.
     
    
   </p>
   <p>
    
     Ensure you have a MySQL database available.
    
    
     For this, we will reuse the database we created in the main
    
    
     
      recipe steps.
     
    
   </p>
   <ol>
    <li>
     
      First, we will create a new directory for the
     
     <strong class="source-inline">
      
       fastify-mysql
      
     </strong>
     
      project and initialize it
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir fastify-mysql</strong>
<strong class="bold">$ cd fastify-mysql</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Install
     
     <strong class="source-inline">
      
       fastify
      
     </strong>
     
      and the
     
     <strong class="source-inline">
      
       @fastify/mysql
      
     </strong>
     
      plugin
     
     
      
       using
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ npm install fastify @fastify/mysql</strong></pre>
    </li>
    <li>
     
      Create a file named
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      in your project root.
     
     
      This file will configure the Fastify server, connect to the MySQL database, and define
     
     
      
       the routes:
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Start by requiring
     
     <a id="_idIndexMarker539">
     </a>
     
      Fastify – we’ll also
     
     
      
       enable logging:
      
     
     <pre class="source-code">
const fastify = require('fastify')({ logger: true });</pre>
    </li>
    <li>
     
      Now, we can register the
     
     <strong class="source-inline">
      
       @fastify/mysql
      
     </strong>
     
      plugin we
     
     
      
       installed earlier:
      
     
     <pre class="source-code">
fastify.register(require('@fastify/mysql'), {
  connectionString:
    'mysql://root:PASSWORD@localhost/tasks'
});</pre>
     <p class="list-inset">
      
       Note that the connection string contains the credentials of our MySQL database – ideally, this
      
      <a id="_idIndexMarker540">
      </a>
      
       connection
      
      <a id="_idIndexMarker541">
      </a>
      
       string should be stored in a
      
      <strong class="source-inline">
       
        .env
       
      </strong>
      
       file as covered in
      
      
       
        previous recipes.
       
      
     </p>
    </li>
    <li>
     
      Now, let’s register a route to return all tasks in
     
     
      
       the database:
      
     
     <pre class="source-code">
fastify.get('/tasks', (req, reply) =&gt; {
  fastify.mysql.query(
    'SELECT * FROM tasks.tasks',
    function onResult (err, result) {
      reply.send(err || result);
    }
  );
});</pre>
    </li>
    <li>
     
      Finally, we’ll add the logic to run
     
     
      
       the server:
      
     
     <pre class="source-code">
fastify.listen({ port: 3000 }, err =&gt; {
  if (err) throw err;
  console.log(`server listening on
    ${fastify.server.address().port}`);
});</pre>
    </li>
    <li>
     
      Let’s start the Fastify
     
     
      
       MySQL application:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      To test your API,  open a new terminal window while your server is running and
     
     
      
       use
      
     
     
      <strong class="source-inline">
       
        curl
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ curl http://localhost:3000/tasks</strong></pre>
    </li>
   </ol>
   <p>
    
     This tutorial provided a basic introduction to creating a REST API with Fastify and MySQL, covering project
    
    <a id="_idIndexMarker542">
    </a>
    
     setup, initializing
    
    <a id="_idIndexMarker543">
    </a>
    
     the
    
    <a id="_idIndexMarker544">
    </a>
    
     server, connecting to the database, and retrieving items from the database.
    
    
     Fastify provides equivalent plugins for the other databases utilized in
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-213">
    <a id="_idTextAnchor220">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to a PostgreSQL database
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to MongoDB
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Persisting data with Redis
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     <a href="B19212_09.xhtml#_idTextAnchor274">
      
       <em class="italic">
        
         Chapter 9
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-214">
    <a id="_idTextAnchor221">
    </a>
    
     Connecting and persisting to a PostgreSQL database
    
   </h1>
   <p>
    
     PostgreSQL, first introduced
    
    <a id="_idIndexMarker545">
    </a>
    
     in 1996, is a powerful open source object-relational
    
    <a id="_idIndexMarker546">
    </a>
    
     database system that has stood the test of time due to its reliability, feature robustness, and performance.
    
    
     One of PostgreSQL’s standout features is its ability to be utilized as both a traditional relational database, where data is stored in tables with relationships among them, and as a document database, such as NoSQL databases, where data can be stored in JSON format.
    
    
     This flexibility allows developers to choose the most appropriate data storage model based on their
    
    
     
      application’s requirements.
     
    
   </p>
   <p>
    
     Throughout this tutorial, we will explore the basics of interacting with a PostgreSQL database from a Node.js application.
    
    
     We’ll use the
    
    <strong class="source-inline">
     
      pg
     
    </strong>
    
     module, a popular and comprehensive PostgreSQL client for Node.js.
    
    
     The
    
    <strong class="source-inline">
     
      pg
     
    </strong>
    
     module simplifies connecting to and executing queries against a
    
    
     
      PostgreSQL database.
     
    
   </p>
   <h2 id="_idParaDest-215">
    <a id="_idTextAnchor222">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To get started, we will need a PostgreSQL server to connect to.
    
    
     We will use Docker to provision a containerized PostgreSQL database.
    
    
     Refer to the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section of this chapter for more information about using Docker to
    
    
     
      provision databases.
     
    
   </p>
   <p>
    
     We will be using the Docker official PostgreSQL image
    
    
     
      from
     
    
    <a href="https://hub.docker.com/_/postgres">
     
      
       https://hub.docker.com/_/postgres
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The following steps will initialize our PostgreSQL server and prepare our
    
    
     
      project directory:
     
    
   </p>
   <ol>
    <li>
     
      In a terminal window, type the following to provision a
     
     
      <strong class="source-inline">
       
        postgres
       
      </strong>
     
     
      
       container:
      
     
     <pre class="source-code">
<strong class="bold">$ docker run --publish 5432:5432 --name node-postgres-latest --env POSTGRES_PASSWORD=PASSWORD --detach postgres:16</strong></pre>
     <p class="list-inset">
      
       Assuming you do not have a copy of the PostgreSQL image locally, expect to see the following output while Docker downloads
      
      
       
        the image:
       
      
     </p>
     <pre class="source-code">Unable to find image 'postgres:16' locally
latest: Pulling from library/postgres
f546e941f15b: Pull complete
926c64b890ad: Pull complete
eca757527cc4: Pull complete
93d9b27ec7dc: Pull complete
86e78387c4e9: Pull complete
8776625edd8f: Pull complete
d1afcbffdf18: Pull complete
6a6c8f936428: Pull complete
ae47f32f8312: Pull complete
82fb85897d06: Pull complete
ce4a61041646: Pull complete
ca83cd3ae7cf: Pull complete
f7fbf31fd41d: Pull complete
353df72b8bf7: Pull complete
Digest: sha256:f58300ac8d393b2e3b09d36ea12d7d24ee9440440e421472a300e929ddb63460
Status: Downloaded newer image for postgres:16
86ce1ac06849f737e669c34e50e6f91383074cdecb1a18f8f23a6becaa085ba0</pre>
     <p class="list-inset">
      
       We should now have
      
      <a id="_idIndexMarker547">
      </a>
      
       a
      
      <a id="_idIndexMarker548">
      </a>
      
       PostgreSQL database listening on
      
      
       
        port
       
      
      
       <strong class="source-inline">
        
         5432
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      Next, we’ll set up a directory and files ready for our
     
     
      
       PostgreSQL application:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir postgres-app</strong>
<strong class="bold">$ cd postgres-app</strong>
<strong class="bold">$ touch tasks.js .env</strong></pre>
    </li>
    <li>
     
      As we’ll be using a third-party module, we’ll also need to use
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      to initialize a project.
     
     
      Let’s just accept
     
     
      
       the defaults:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
   </ol>
   <p>
    
     Now, we’re ready to move on to the recipe, where we will be using the
    
    <strong class="source-inline">
     
      pg
     
    </strong>
    
     module to interact with our
    
    
     
      PostgreSQL database.
     
    
   </p>
   <h2 id="_idParaDest-216">
    <a id="_idTextAnchor223">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will be installing the
    
    <strong class="source-inline">
     
      pg
     
    </strong>
    
     module to interact with our PostgreSQL database using Node.js.
    
    
     We will also send some simple queries to
    
    
     
      our database.
     
    
   </p>
   <ol>
    <li>
     
      First, we need to install the third-party
     
     
      <strong class="source-inline">
       
        pg
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install pg</strong></pre>
    </li>
    <li>
     
      We’ll also be using the
     
     <strong class="source-inline">
      
       dotenv
      
     </strong>
     
      module in this recipe; install that with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install dotenv</strong></pre>
    </li>
    <li>
     
      We’ll also
     
     <a id="_idIndexMarker549">
     </a>
     
      use
     
     <a id="_idIndexMarker550">
     </a>
     
      the
     
     <strong class="source-inline">
      
       .env
      
     </strong>
     
      file to store our PostgreSQL database credentials and use the
     
     <strong class="source-inline">
      
       dotenv
      
     </strong>
     
      module to pass them to our program.
     
     
      Add the following credentials
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        .env
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
PGUSER=postgres
PGPASSWORD=PASSWORD
PGPORT=5432</pre>
    </li>
    <li>
     
      Open
     
     <strong class="source-inline">
      
       tasks.js
      
     </strong>
     
      and import our environment variables using the
     
     
      <strong class="source-inline">
       
        dotenv
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
require('dotenv').config();</pre>
    </li>
    <li>
     
      Next, in
     
     <strong class="source-inline">
      
       tasks.js
      
     </strong>
     
      , we need to import the
     
     <strong class="source-inline">
      
       pg
      
     </strong>
     
      module and create a
     
     
      
       PostgreSQL client:
      
     
     <pre class="source-code">
const pg = require('pg');
const db = new pg.Client();</pre>
    </li>
    <li>
     
      Now, let’s allow our program to handle input via a
     
     
      
       command-line argument:
      
     
     <pre class="source-code">
const task = process.argv[2];</pre>
    </li>
    <li>
     
      Next, we’ll define the SQL queries we’re going to be using as constants.
     
     
      This will improve the readability of our
     
     
      
       code later:
      
     
     <pre class="source-code">
const CREATE_TABLE_SQL = `CREATE TABLE IF NOT EXISTS
  tasks (id SERIAL, task TEXT NOT NULL, PRIMARY KEY (
    id ));`;
const INSERT_TASK_SQL = 'INSERT INTO tasks (task)
  VALUES ($1);';
const GET_TASKS_SQL = 'SELECT * FROM tasks;';</pre>
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        SELECT * FROM tasks;
       
      </strong>
      
       SQL
      
      <a id="_idIndexMarker551">
      </a>
      
       query
      
      <a id="_idIndexMarker552">
      </a>
      
       returns all tasks in the
      
      
       <strong class="source-inline">
        
         tasks
        
       </strong>
      
      
       
        table.
       
      
     </p>
    </li>
    <li>
     
      Next, we’ll add the following code to connect to our database.
     
     
      Create a
     
     <strong class="source-inline">
      
       tasks
      
     </strong>
     
      table if it doesn’t already exist, insert a task, and finally, list all tasks stored in
     
     
      
       the database:
      
     
     <pre class="source-code">
db.connect((err) =&gt; {
  if (err) throw err;
  db.query(CREATE_TABLE_SQL, (err) =&gt; {
    if (err) throw err;
    if (task) {
      db.query(INSERT_TASK_SQL, [task], (err) =&gt; {
        if (err) throw err;
        listTasks();
      });
    } else {
      listTasks();
    }
  });
});</pre>
    </li>
    <li>
     
      Finally, we’ll create our
     
     <strong class="source-inline">
      
       listTasks()
      
     </strong>
     
      function, which will use
     
     <strong class="source-inline">
      
       GET_TASKS_SQL
      
     </strong>
     
      .
     
     
      This function
     
     <a id="_idIndexMarker553">
     </a>
     
      will also end the connection
     
     <a id="_idIndexMarker554">
     </a>
     
      to
     
     
      
       our database:
      
     
     <pre class="source-code">
function listTasks () {
  db.query(GET_TASKS_SQL, (err, results) =&gt; {
    if (err) throw err;
    console.log(results.rows);
    db.end();
  });
}</pre>
    </li>
    <li>
     
      Run
     
     <strong class="source-inline">
      
       tasks.js
      
     </strong>
     
      , passing a task as a command-line argument.
     
     
      The task will be inserted into the database and listed out before the
     
     
      
       program ends:
      
     
     <pre class="source-code">
<strong class="bold">$ node tasks.js "Bath the dog."</strong>
[
  { id: 1, task: 'Bath the dog.' }
]</pre>
    </li>
    <li>
     
      We can also run the program without passing a task.
     
     
      When we run
     
     <strong class="source-inline">
      
       tasks.js
      
     </strong>
     
      with no
     
     <strong class="source-inline">
      
       task
      
     </strong>
     
      parameter, the program will output the tasks stored in
     
     
      
       the database:
      
     
     <pre class="source-code">
<strong class="bold">$ node tasks.js</strong>
[
  { id: 1, task: 'Bath the dog.' }
]</pre>
    </li>
   </ol>
   <p>
    
     By following these steps, you’ve gained an understanding of how to integrate PostgreSQL
    
    
     
      with Node.js.
     
    
   </p>
   <h2 id="_idParaDest-217">
    <a id="_idTextAnchor224">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the
    
    <em class="italic">
     
      Getting ready
     
    </em>
    
     section of this recipe, we provisioned a containerized PostgreSQL database using the Docker official image from Docker Hub.
    
    
     The provisioned PostgreSQL database was provisioned in
    
    <a id="_idIndexMarker555">
    </a>
    
     a
    
    <a id="_idIndexMarker556">
    </a>
    
     Docker container named
    
    <strong class="source-inline">
     
      node-postgres
     
    </strong>
    
     .
    
    
     By default, the PostgreSQL Docker image creates a user and database named
    
    <strong class="source-inline">
     
      postgres
     
    </strong>
    
     .
    
    
     The Docker command we used to provision the database instructed the container to make the PostgreSQL database available at
    
    <strong class="source-inline">
     
      localhost:5432
     
    </strong>
    
     with a placeholder password
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       PASSWORD
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The configuration information required for a connection to our PostgreSQL database was specified in the
    
    <strong class="source-inline">
     
      .env
     
    </strong>
    
     file.
    
    
     We used the
    
    <strong class="source-inline">
     
      dotenv
     
    </strong>
    
     module to load this configuration information as environment variables to our
    
    
     
      Node.js process.
     
    
   </p>
   <p>
    
     Notice that we didn’t have to directly pass any of the environment variables to the client.
    
    
     This is because the
    
    <strong class="source-inline">
     
      pg
     
    </strong>
    
     module automatically looks for specifically named variables (
    
    <strong class="source-inline">
     
      PGHOST
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      PGPORT
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      PGUSER
     
    </strong>
    
     ).
    
    
     However, if we wanted, we could specify the values when we create the client,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
const client = new Client({
  host: 'localhost',
  port: 5432,
  user: 'postgres'
});</pre>
   <p>
    
     We use the
    
    <strong class="source-inline">
     
      connect()
     
    </strong>
    
     method to connect to our PostgreSQL database.
    
    
     We provide this method with a callback function to be executed once the connection attempt is complete.
    
    
     We added error handling within our callback function so that if the connection attempt fails, then an error
    
    
     
      is thrown.
     
    
   </p>
   <p>
    
     Throughout the remainder of the program, we use the
    
    <strong class="source-inline">
     
      query()
     
    </strong>
    
     method provided by the
    
    <strong class="source-inline">
     
      pg
     
    </strong>
    
     module to execute SQL queries against the PostgreSQL database.
    
    
     Each of our calls to the
    
    <strong class="source-inline">
     
      query()
     
    </strong>
    
     method
    
    <a id="_idIndexMarker557">
    </a>
    
     is
    
    <a id="_idIndexMarker558">
    </a>
    
     supplied with a callback function to be executed upon completion of
    
    
     
      the query.
     
    
   </p>
   <h2 id="_idParaDest-218">
    <a id="_idTextAnchor225">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     As well as storing traditional relational data, PostgreSQL also provides the ability to store object data.
    
    
     This enables the storing of relational data alongside
    
    
     
      document storage.
     
    
   </p>
   <p>
    
     We can adapt the program we created in the
    
    <em class="italic">
     
      Connecting and persisting to a PostgreSQL database
     
    </em>
    
     recipe to handle both relational and
    
    
     
      object data.
     
    
   </p>
   <ol>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       postgres-app
      
     </strong>
     
      directory to a directory
     
     
      
       called
      
     
     
      <strong class="source-inline">
       
        postgres-object-app
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp -r postgres-app postgres-object-app</strong>
<strong class="bold">$ cd postgres-object-app</strong></pre>
    </li>
    <li>
     
      Now, we’ll edit our SQL queries to create a new table named
     
     <strong class="source-inline">
      
       task_docs
      
     </strong>
     
      that stores document data.
     
     
      Change your SQL query constants to the following in our
     
     
      <strong class="source-inline">
       
        tasks.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
const CREATE_TABLE_SQL = `CREATE TABLE IF NOT EXISTS
  task_docs (id SERIAL, doc jsonb);`;
const INSERT_TASK_SQL = `INSERT INTO task_docs (doc)
  VALUES ($1);`;
const GET_TASKS_SQL = `SELECT * FROM task_docs;`;</pre>
    </li>
    <li>
     
      Now, when we run our application, we can pass it JSON input to represent the task.
     
     
      Note that we will need to wrap the JSON input in single quotes, and then use double quotes for the
     
     
      
       key-value pairs:
      
     
     <pre class="source-code">
<strong class="bold">$ node tasks.js '{"task":"Walk the dog."}'</strong>
[ { id: 1, doc: { task: 'Walk the dog.' } } ]</pre>
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        doc
       
      </strong>
      
       field was created with the
      
      <strong class="source-inline">
       
        jsonb
       
      </strong>
      
       type, which represents the JSON binary type.
      
      
       PostgreSQL provides two JSON data types:
      
      <strong class="source-inline">
       
        json
       
      </strong>
      
       and
      
      <strong class="source-inline">
       
        jsonb
       
      </strong>
      
       .
      
      
       The
      
      <strong class="source-inline">
       
        json
       
      </strong>
      
       data type is like a regular text input field but with the addition that it validates the JSON.
      
      
       The
      
      <strong class="source-inline">
       
        jsonb
       
      </strong>
      
       type is structured and facilitates queries and indexes within the document objects.
      
      
       You’d opt for the
      
      <strong class="source-inline">
       
        jsonb
       
      </strong>
      
       data type over the
      
      <strong class="source-inline">
       
        json
       
      </strong>
      
       data type when you require the ability to query or index
      
      
       
        the data.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     Based on this example, a
    
    <strong class="source-inline">
     
      jsonb
     
    </strong>
    
     query would look
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
SELECT * FROM task_docs WHERE doc -&gt;&gt; task= "Bath the dog."</pre>
   <p>
    
     Note that we’re able
    
    <a id="_idIndexMarker559">
    </a>
    
     to
    
    <a id="_idIndexMarker560">
    </a>
    
     query against the
    
    <strong class="source-inline">
     
      task
     
    </strong>
    
     property within the document object.
    
    
     For more information about the
    
    <strong class="source-inline">
     
      jsonb
     
    </strong>
    
     data type, refer to the official PostgreSQL documentation
    
    
     
      at
     
    
    <a href="https://www.postgresql.org/docs/9.4/datatype-json.html">
     
      
       https://www.postgresql.org/docs/9.4/datatype-json.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-219">
    <a id="_idTextAnchor226">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to a MySQL database
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to MongoDB
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Persisting data with Redis
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-220">
    <a id="_idTextAnchor227">
    </a>
    
     Connecting and persisting to MongoDB
    
   </h1>
   <p>
    
     MongoDB is a
    
    <a id="_idIndexMarker561">
    </a>
    
     NoSQL
    
    <a id="_idIndexMarker562">
    </a>
    
     database management system built around a document-oriented model.
    
    
     Data is stored in flexible, JSON-like documents
    
    <a id="_idIndexMarker563">
    </a>
    
     called
    
    <strong class="bold">
     
      Binary JSON
     
    </strong>
    
     (
    
    <strong class="bold">
     
      BSON
     
    </strong>
    
     ), which are organized
    
    <a id="_idIndexMarker564">
    </a>
    
     into
    
    <strong class="bold">
     
      collections
     
    </strong>
    
     , analogous to tables in relational databases.
    
    
     Each document within a collection can have a different structure, allowing for dynamic schemas and easy modification of
    
    
     
      data models.
     
    
   </p>
   <p>
    
     MongoDB supports powerful querying capabilities using its query language, which includes various operators and methods for filtering, sorting, and
    
    
     
      manipulating data.
     
    
   </p>
   <p>
    
     This recipe will use a book/author example using the MongoDB Node.js driver directly.
    
    
     We’ll write functions to create and find authors and books within our MongoDB database.
    
    
     This script will illustrate basic CRUD operations without the use of a web framework, focusing purely on
    
    
     
      database interactions.
     
    
   </p>
   <h2 id="_idParaDest-221">
    <a id="_idTextAnchor228">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To set up a MongoDB database with Docker and get your project directory ready for the application, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      As with the
     
     <a id="_idIndexMarker565">
     </a>
     
      other
     
     <a id="_idIndexMarker566">
     </a>
     
      databases in this chapter, we will be using Docker to provision a MongoDB database using the MongoDB Docker image available
     
     
      
       at
      
     
     <a href="https://hub.docker.com/_/mongo">
      
       
        https://hub.docker.com/_/mongo
       
      
     </a>
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ docker run --publish 27017:27017 --name node-mongo --detach mongo:7</strong></pre>
     <p class="list-inset">
      
       Assuming you do not have a copy of the MongoDB image locally, expect to see the following output while Docker downloads
      
      
       
        the image:
       
      
     </p>
     <pre class="source-code">Unable to find image 'mongo:7' locally
latest: Pulling from library/mongo
bccd10f490ab: Pull complete
b00c7ff578b0: Pull complete
a1f43ab85151: Pull complete
9e72f6a5998a: Pull complete
8424336879e4: Pull complete
85a6d3c2e6c8: Pull complete
c533c21e5fb8: Pull complete
1fddf702bb73: Pull complete
Digest: sha256:0e145625e78b94224d16222ff2609c4621ff6e2c390300e4e6bf698305596792
Status: Downloaded newer image for mongo:7
9230ee867d2b2272448f2596ddc19a7f4de5112c99e4dd31b2d7746b28fbc674</pre>
    </li>
    <li>
     
      We’ll also create a directory for the MongoDB
     
     
      
       Node.js application:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir mongodb-app</strong>
<strong class="bold">$ cd mongodb-app</strong></pre>
    </li>
    <li>
     
      In this recipe, we will need to install modules from the
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      registry, so we need to initialize our project with
     
     <strong class="source-inline">
      
       $
      
     </strong>
     
      <strong class="source-inline">
       
        npm init
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Create a file named
     
     <strong class="source-inline">
      
       index.js
      
     </strong>
     
      ; this will contain our application code that interacts
     
     
      
       with MongoDB:
      
     
     <pre class="source-code">
<strong class="bold">$ touch index.js</strong></pre>
    </li>
   </ol>
   <p>
    
     Now that we have our
    
    <a id="_idIndexMarker567">
    </a>
    
     database
    
    <a id="_idIndexMarker568">
    </a>
    
     running and the project initialized, we’re ready to move on to
    
    
     
      the recipe.
     
    
   </p>
   <h2 id="_idParaDest-222">
    <a id="_idTextAnchor229">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will be using the
    
    <strong class="source-inline">
     
      mongodb
     
    </strong>
    
     module to demonstrate how we can interact with our
    
    
     
      MongoDB database.
     
    
   </p>
   <ol>
    <li>
     
      Start by installing the
     
     
      <strong class="source-inline">
       
        mongodb
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install mongodb</strong></pre>
    </li>
    <li>
     
      First, we’ll add the logic to the
     
     <strong class="source-inline">
      
       index.js
      
     </strong>
     
      file to establish a connection to our
     
     
      
       MongoDB database:
      
     
     <pre class="source-code">
const { MongoClient } = require('mongodb');
const URI = 'mongodb://localhost:27017';
const client = new MongoClient(URI);
async function connectToMongoDB () {
  try {
    await client.connect();
    console.log('Connected successfully to server');
    return client.db('Library');
  } catch (err) {
    console.error('Connection to MongoDB failed:',
      err);
  }
}</pre>
    </li>
    <li>
     
      Next, we will craft a function
     
     <a id="_idIndexMarker569">
     </a>
     
      to
     
     <a id="_idIndexMarker570">
     </a>
     
      insert an author into the
     
     
      <strong class="source-inline">
       
        authors
       
      </strong>
     
     
      
       collection:
      
     
     <pre class="source-code">
async function createAuthor (db, author) {
  try {
    const result = await
      db.collection('authors').insertOne(author);
    console.log(`Author created with the following id:
      ${result.insertedId}`);
    return result.insertedId;
  } catch (err) {
    console.error('Create author failed:', err);
  }
}</pre>
    </li>
    <li>
     
      Create a function to insert a book into the
     
     
      <strong class="source-inline">
       
        books
       
      </strong>
     
     
      
       collection:
      
     
     <pre class="source-code">
async function createBook (db, book) {
  try {
    const result = await
      db.collection('books').insertOne(book);
    console.log(`Book created with the following id:
      ${result.insertedId}`);
    return result.insertedId;
  } catch (err) {
    console.error('Create book failed:', err);
  }
}</pre>
    </li>
    <li>
     
      Create a function to
     
     <a id="_idIndexMarker571">
     </a>
     
      find
     
     <a id="_idIndexMarker572">
     </a>
     
      all authors in the
     
     
      <strong class="source-inline">
       
        authors
       
      </strong>
     
     
      
       collection:
      
     
     <pre class="source-code">
async function findAllAuthors (db) {
  try {
    const authors = await
      db.collection('authors').find().toArray();
    console.log('Authors:', authors);
    return authors;
  } catch (err) {
    console.error('Find all authors failed:', err);
  }
}</pre>
    </li>
    <li>
     
      Create a function to find all books and populate them with author details using an
     
     
      
       aggregation pipeline:
      
     
     <pre class="source-code">
async function findAllBooksWithAuthors (db) {
  try {
    const books = await
      db.collection('books').aggregate([
      {
        $lookup: {
          from: 'authors',
          localField: 'authorId',
          foreignField: '_id',
          as: 'authorDetails'
        }
      }
    ]).toArray();
    console.log('Books with author details:', books);
    return books;
  } catch (err) {
    console.error('Find all books with authors
      failed:', err);
  }
}</pre>
    </li>
    <li>
     
      Finally, we will
     
     <a id="_idIndexMarker573">
     </a>
     
      use
     
     <a id="_idIndexMarker574">
     </a>
     
      the
     
     <strong class="source-inline">
      
       createAuthor()
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       createBook()
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       findAllAuthors()
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       findAllBooksWithAuthors()
      
     </strong>
     
      functions in the
     
     <strong class="source-inline">
      
       main()
      
     </strong>
     
      function to perform the operations
     
     
      
       in sequence:
      
     
     <pre class="source-code">
async function main () {
  const db = await connectToMongoDB();
  if (!db) return;
  const authorId = await createAuthor(db, { name:
    'Richard Adams' });
  if (!authorId) return;
  await createBook(db, { title: 'Watership Down',
    authorId });
  await findAllAuthors(db);
  await findAllBooksWithAuthors(db);
  client.close();
}
main().catch(console.error);</pre>
    </li>
    <li>
     
      Run
     
     
      
       the script:
      
     
     <pre class="source-code">
<strong class="bold">$ node index.js</strong></pre>
    </li>
   </ol>
   <p>
    
     In this recipe, we built a
    
    <a id="_idIndexMarker575">
    </a>
    
     Node.js
    
    <a id="_idIndexMarker576">
    </a>
    
     script that serves as a functional interface to interact with a
    
    
     
      MongoDB database.
     
    
   </p>
   <h2 id="_idParaDest-223">
    <a id="_idTextAnchor230">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we begin by importing the necessary modules, notably the
    
    <strong class="source-inline">
     
      MongoClient
     
    </strong>
    
     class from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     ’s
    
    <strong class="source-inline">
     
      mongodb
     
    </strong>
    
     module.
    
    
     Setting up the MongoDB connection involves defining a URI to connect to the local MongoDB server and initializing a
    
    <strong class="source-inline">
     
      MongoClient
     
    </strong>
    
     instance with this URI.
    
    
     In our case, our database was hosted on the typical default host and port for
    
    
     
      MongoDB:
     
    
    
     <strong class="source-inline">
      
       mongodb://localhost:27017
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Note that MongoDB does not enable authentication by default when using Docker, so no authentication parameters were needed in the
    
    
     
      connection string.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      connectToMongoDB()
     
    </strong>
    
     function asynchronously attempts to establish a connection to the MongoDB server, logging success or failure messages accordingly and returning a reference to the specified database
    
    
     
      if successful.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      mongodb
     
    </strong>
    
     module from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     exposes a vast range of CRUD methods to interact with the MongoDB collections in your MongoDB database.
    
    
     The term
    
    <em class="italic">
     
      CRUD
     
    </em>
    
     is used to represent the basic functions for persistent storage.
    
    
     In this recipe, we used the
    
    <strong class="source-inline">
     
      find()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      insertOne()
     
    </strong>
    
     CRUD methods.
    
    
     A full list of available methods is defined in the Node.js MongoDB driver API
    
    
     
      documentation (
     
    
    <a href="https://mongodb.github.io/node-mongodb-native/6.5/">
     
      
       https://mongodb.github.io/node-mongodb-native/6.5/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     We also used the
    
    <strong class="source-inline">
     
      aggregate()
     
    </strong>
    
     method in the
    
    <strong class="source-inline">
     
      findAllBooksWithAuthors()
     
    </strong>
    
     function.
    
    
     An aggregation pipeline can contain one or more stages to create a flow of operations that processes, transforms, and
    
    
     
      returns results.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function orchestrates the execution flow, starting with connecting to the MongoDB database.
    
    
     Upon successful connection, it proceeds to create an author document for
    
    <strong class="source-inline">
     
      Richard Adams
     
    </strong>
    
     and a corresponding book document titled
    
    <strong class="source-inline">
     
      Watership Down
     
    </strong>
    
     , associating them together.
    
    
     Subsequently, it retrieves all authors and books with their associated author details using the defined functions.
    
    
     Error handling is implemented throughout the script using
    
    <strong class="source-inline">
     
      try
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     blocks to handle any potential errors that may arise during execution.
    
    
     Finally, the script concludes by closing the MongoDB
    
    
     
      client connection.
     
    
   </p>
   <p>
    
     Overall, this script serves
    
    <a id="_idIndexMarker577">
    </a>
    
     as
    
    <a id="_idIndexMarker578">
    </a>
    
     a practical example of how to utilize Node.js and the
    
    <strong class="source-inline">
     
      mongodb
     
    </strong>
    
     package to perform CRUD operations on a MongoDB database, demonstrating basic functionalities such as connecting to the database, inserting documents, querying collections, and handling
    
    
     
      errors effectively.
     
    
   </p>
   <h2 id="_idParaDest-224">
    <a id="_idTextAnchor231">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to a MySQL database
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to a PostgreSQL database
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Persisting data with Redis
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-225">
    <a id="_idTextAnchor232">
    </a>
    
     Persisting data with Redis
    
   </h1>
   <p>
    
     Redis is an open
    
    <a id="_idIndexMarker579">
    </a>
    
     source in-memory
    
    <a id="_idIndexMarker580">
    </a>
    
     key-value data store.
    
    
     Used in the correct setting, Redis can be a fast-performing data store.
    
    
     It is often used to provide caching in applications but can also be used as
    
    
     
      a database.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Redis
     
    </strong>
    
     , an acronym for
    
    <strong class="bold">
     
      Remote Dictionary Server
     
    </strong>
    
     , is an in-memory data structure store, often used as a database, cache, and message broker.
    
    
     It excels in scenarios requiring high speed and efficiency, such as caching, session management, real-time analytics, and message queuing.
    
    
     Redis’s ability to support various data structures, combined with its atomic operations
    
    <a id="_idIndexMarker581">
    </a>
    
     and
    
    <strong class="bold">
     
      publish/subscribe
     
    </strong>
    
     (
    
    <strong class="bold">
     
      pub/sub
     
    </strong>
    
     ) messaging capabilities, makes it a powerful tool for enhancing the performance and scalability of Node.js applications.
    
    
     Its in-memory nature ensures rapid access to data, significantly reducing latency compared to traditional disk-based databases, making it ideal for applications where speed
    
    
     
      is critical.
     
    
   </p>
   <p>
    
     In the context of Node.js, Redis is particularly valuable for managing session data in web applications, enabling quick data retrieval, and improving user experience.
    
    
     It’s also widely used for implementing caching mechanisms, reducing the load on databases, and speeding up response times.
    
    
     Moreover, its pub/sub messaging system facilitates the development of real-time applications, such as chat applications or live notifications, by allowing efficient communication between clients and servers.
    
    
     Whether you’re looking to optimize your application’s performance, scale efficiently, or build feature-rich real-time interactions, integrating Redis with Node.js offers a robust solution to meet
    
    
     
      these needs.
     
    
   </p>
   <h2 id="_idParaDest-226">
    <a id="_idTextAnchor233">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before diving into Redis module integration, it’s essential to note that we’ll be using ESM for compatibility.
    
    
     For more information on modules, refer to
    
    <a href="B19212_05.xhtml#_idTextAnchor139">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <ol>
    <li>
     
      As with the previous databases in this chapter, we will use Docker to provision a Redis database, based on the Docker image available at
     
     <a href="https://hub.docker.com/_/redis">
      
       https://hub.docker.com/_/redis
      
     </a>
     
      .
     
     
      Run the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ docker run --publish 6379:6379 --name node-redis --detach redis</strong></pre>
     <p class="list-inset">
      
       By default, the containerized Redis database will be available
      
      
       
        at
       
      
      
       <strong class="source-inline">
        
         localhost:6379
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      We will also create a new folder named
     
     <strong class="source-inline">
      
       redis-app
      
     </strong>
     
      containing a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        tasks.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir redis-app</strong>
<strong class="bold">$ cd redis-app</strong>
<strong class="bold">$ touch tasks.mjs</strong></pre>
    </li>
    <li>
     
      In this recipe, we will be making use of third-party
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      modules; therefore, we need to initialize
     
     
      
       our project:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
   </ol>
   <p>
    
     Now that we have Redis running and our project set up, we’re ready to move on to
    
    
     
      the recipe.
     
    
   </p>
   <h2 id="_idParaDest-227">
    <a id="_idTextAnchor234">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will
    
    <a id="_idIndexMarker582">
    </a>
    
     be using the
    
    <strong class="source-inline">
     
      redis
     
    </strong>
    
     module
    
    <a id="_idIndexMarker583">
    </a>
    
     to interact with our Redis
    
    
     
      data store.
     
    
   </p>
   <ol>
    <li>
     
      Start by installing the third-party
     
     
      <strong class="source-inline">
       
        redis
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install redis</strong></pre>
    </li>
    <li>
     
      We now need to import and create a Redis client
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        tasks.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
import { createClient } from 'redis';
const client = createClient();</pre>
    </li>
    <li>
     
      We’ll also accept command-line input for
     
     
      
       our task:
      
     
     <pre class="source-code">
const task = process.argv[2];</pre>
    </li>
    <li>
     
      Next, we’ll add an
     
     <strong class="source-inline">
      
       error
      
     </strong>
     
      event handler to catch any errors that occur on our
     
     
      
       Redis client:
      
     
     <pre class="source-code">
client.on('error', (err) =&gt; {
    console.log('Error:', err);
});</pre>
    </li>
    <li>
     
      We need to initialize
     
     
      
       the connection:
      
     
     <pre class="source-code">
await client.connect();</pre>
    </li>
    <li>
     
      Now, we’ll add a statement that will control the flow of our program.
     
     
      If a task is passed as input to our program, we will add this task and then list the tasks stored in Redis.
     
     
      If no task is supplied, then we will just list the
     
     
      
       stored tasks:
      
     
     <pre class="source-code">
if (!task) {
    listTasks();
} else {
    addTask(task);
}</pre>
    </li>
    <li>
     
      Below this
     
     <strong class="source-inline">
      
       if
      
     </strong>
     
      statement, we
     
     <a id="_idIndexMarker584">
     </a>
     
      will
     
     <a id="_idIndexMarker585">
     </a>
     
      create our
     
     
      <strong class="source-inline">
       
        addTask()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
async function addTask(task) {
    const key =
      `Task:${Math.random().toString(32).replace('.',
        '')}`;
    await client.hSet(key, 'task', task);
    listTasks();
}</pre>
    </li>
    <li>
     
      Finally, after the
     
     <strong class="source-inline">
      
       addTask()
      
     </strong>
     
      function, we’ll add our
     
     
      <strong class="source-inline">
       
        listTasks()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
async function listTasks() {
    const keys = await client.keys('Task:*');
    for (const key of keys) {
        const task = await client.hGetAll(key);
        console.log(task);
    }
    client.quit();
}</pre>
    </li>
    <li>
     
      Now, we can run the program with a task passed as command-line input.
     
     
      The task will be stored in Redis and subsequently printed via the
     
     
      <strong class="source-inline">
       
        listTasks()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
<strong class="bold">$ node tasks.mjs "Walk the dog."</strong>
{ task: 'Walk the dog.' }</pre>
    </li>
   </ol>
   <p>
    
     We’ve now
    
    <a id="_idIndexMarker586">
    </a>
    
     persisted data in our Redis data store
    
    <a id="_idIndexMarker587">
    </a>
    
     using the
    
    
     <strong class="source-inline">
      
       redis
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <h2 id="_idParaDest-228">
    <a id="_idTextAnchor235">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      createClient()
     
    </strong>
    
     method initializes
    
    <a id="_idIndexMarker588">
    </a>
    
     a new client connection.
    
    
     This method will default to configuration for a Redis instance at
    
    <strong class="source-inline">
     
      localhost:6379
     
    </strong>
    
     , where
    
    <strong class="source-inline">
     
      6379
     
    </strong>
    
     is the conventional port for Redis.
    
    
     In previous versions of the
    
    <strong class="source-inline">
     
      redis
     
    </strong>
    
     module from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     , the
    
    <strong class="source-inline">
     
      createClient()
     
    </strong>
    
     method would automatically connect to the server.
    
    
     However, it’s now necessary to explicitly call
    
    <strong class="source-inline">
     
      client.connect()
     
    </strong>
    
     to establish
    
    
     
      a connection.
     
    
   </p>
   <p>
    
     Within our
    
    <strong class="source-inline">
     
      addTask()
     
    </strong>
    
     function, we generate a random string, or hash, to append to our task key.
    
    
     This ensures that each task key is unique, while still having a specifier indicating that it is a task to aid debugging.
    
    
     This is a common convention when
    
    
     
      using Redis.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      hSet()
     
    </strong>
    
     method sets
    
    <a id="_idIndexMarker589">
    </a>
    
     the key and value in Redis; this is what stores our task in Redis.
    
    
     If we supplied a key that already existed, this method would overwrite
    
    
     
      the contents.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The legacy
    
    <strong class="source-inline">
     
      hmset()
     
    </strong>
    
     method is
    
    <a id="_idIndexMarker590">
    </a>
    
     considered deprecated in newer versions of Redis.
    
    
     The
    
    <strong class="source-inline">
     
      hSet()
     
    </strong>
    
     method used in the recipe should be used for setting
    
    
     
      hash values.
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      listTasks()
     
    </strong>
    
     function, we use the
    
    <strong class="source-inline">
     
      keys()
     
    </strong>
    
     method to search for all keys stored in our Redis data store that match the
    
    <strong class="source-inline">
     
      Tasks:*
     
    </strong>
    
     wildcard.
    
    
     We’re leveraging the
    
    <strong class="source-inline">
     
      keys()
     
    </strong>
    
     method to list all tasks we have stored in Redis.
    
    
     Note that the
    
    <strong class="source-inline">
     
      keys()
     
    </strong>
    
     method in real applications should be used with caution.
    
    
     This is because, in applications with many keys, searching could have negative
    
    
     
      performance implications.
     
    
   </p>
   <p>
    
     Once we have all our task keys, we use the
    
    <strong class="source-inline">
     
      hGetAll()
     
    </strong>
    
     method to return the value at each key.
    
    
     Once obtained, we print this value to
    
    <strong class="source-inline">
     
      STDOUT
     
    </strong>
    
     
      using
     
    
    
     <strong class="source-inline">
      
       console.log()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      redis
     
    </strong>
    
     module
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     provides a one-to-one mapping of all available Redis commands.
    
    
     Refer to
    
    <a href="https://redis.io/commands">
     
      https://redis.io/commands
     
    </a>
    
     for a complete list of
    
    
     
      Redis commands.
     
    
   </p>
   <h2 id="_idParaDest-229">
    <a id="_idTextAnchor236">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The Redis instance
    
    <a id="_idIndexMarker591">
    </a>
    
     you’re interacting with may require authentication.
    
    
     Let’s look at how we can connect to a Redis instance that requires
    
    
     
      a password.
     
    
   </p>
   <h3>
    
     Authenticating with Redis
    
   </h3>
   <p>
    
     To connect to a
    
    <a id="_idIndexMarker592">
    </a>
    
     Redis client that requires authentication, we can supply the credentials via the
    
    
     <strong class="source-inline">
      
       createClient()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <ol>
    <li>
     
      We can, again, use Docker to create a password-protected Redis instance.
     
     
      This Redis container will be available
     
     
      
       at
      
     
     
      <strong class="source-inline">
       
        localhost:6380
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ docker run --publish 6380:6379 --name node-redis-pw --detach redis redis-server --requirepass PASSWORD</strong></pre>
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       tasks.mjs
      
     </strong>
     
      file into a new file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        tasks-auth.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp tasks.mjs tasks-auth.mjs</strong></pre>
    </li>
    <li>
     
      Now, we need to pass the new Redis instance’s configuration information to the
     
     
      <strong class="source-inline">
       
        createClient()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
import { createClient } from 'redis';
<strong class="bold">const client = redis.createClient({</strong>
<strong class="bold">    port: 6380,</strong>
<strong class="bold">    password: 'PASSWORD',</strong>
<strong class="bold">});</strong></pre>
    </li>
    <li>
     
      Now, as before, we can run the program with a task passed as
     
     
      
       command-line input:
      
     
     <pre class="source-code">
<strong class="bold">$ node tasks-auth.mjs "Wash the car."</strong>
{ task: 'Wash the car.' }</pre>
    </li>
   </ol>
   <p>
    
     Note that as we’re
    
    <a id="_idIndexMarker593">
    </a>
    
     pointing to a different Redis instance, it will not contain the tasks we added in the
    
    
     
      main recipe.
     
    
   </p>
   <h3>
    
     Transactions with Redis
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      redis
     
    </strong>
    
     module exposes
    
    <a id="_idIndexMarker594">
    </a>
    
     a method named
    
    <strong class="source-inline">
     
      multi()
     
    </strong>
    
     that can
    
    <a id="_idIndexMarker595">
    </a>
    
     be used to create a
    
    <strong class="bold">
     
      transaction
     
    </strong>
    
     .
    
    
     A transaction is a series of commands that are queued and then executed as a
    
    
     
      single unit.
     
    
   </p>
   <p>
    
     For example, we could use the following to update a task as a transaction by executing a
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      set()
     
    </strong>
    
     ,
    
    
     <strong class="source-inline">
      
       get()
      
     </strong>
    
    
     
      sequence:
     
    
   </p>
   <pre class="source-code">
import { createClient } from 'redis';
const client = createClient();
client.on('error', (err) =&gt; {
  console.log('Error:', err);
});
await client.connect();
await client.set('Task:3', 'Write letter.');
<strong class="bold">const resultsArray = await client</strong>
<strong class="bold">  .multi()</strong>
<strong class="bold">  .get('Task:3')</strong>
<strong class="bold">  .set('Task:3', 'Mail letter.')</strong>
<strong class="bold">  .get('Task:3')</strong>
<strong class="bold">  .exec();</strong>
console.log(resultsArray);
// ['Write letter.', 'OK', 'Mail letter.']
client.quit();</pre>
   <p>
    
     Each of the tasks is queued until the
    
    <strong class="source-inline">
     
      exec()
     
    </strong>
    
     method is executed.
    
    
     If any command fails to be queued, none of the commands in the batch are executed.
    
    
     During the
    
    <strong class="source-inline">
     
      exec()
     
    </strong>
    
     method, all
    
    <a id="_idIndexMarker596">
    </a>
    
     commands
    
    <a id="_idIndexMarker597">
    </a>
    
     are executed
    
    
     
      in order.
     
    
   </p>
   <h2 id="_idParaDest-230">
    <a id="_idTextAnchor237">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to a MySQL database
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to a PostgreSQL database
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Connecting and persisting to MongoDB
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-231">
    <a id="_idTextAnchor238">
    </a>
    
     Exploring GraphQL
    
   </h1>
   <p>
    
     GraphQL serves as a
    
    <a id="_idIndexMarker598">
    </a>
    
     query language for APIs and provides a runtime environment for executing queries.
    
    
     Unlike REST, which relies on rigid endpoint structures, GraphQL allows clients to request exactly what they need and nothing more, making it efficient for fetching data.
    
    
     This flexibility reduces the amount of data transferred over the network and allows for more precise and
    
    
     
      optimized queries.
     
    
   </p>
   <p>
    
     In projects where your application deals with complex, interrelated data structures, such as social networks, e-commerce platforms, or
    
    <strong class="bold">
     
      content management systems
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CMSs
     
    </strong>
    
     ), GraphQL’s ability to query deeply nested data in a single request makes it a perfect match
    
    <a id="_idIndexMarker599">
    </a>
    
     with Node.js.
    
    
     This combination reduces the need for multiple REST endpoints and minimizes data over-fetching, optimizing both the network performance and the
    
    
     
      developer experience.
     
    
   </p>
   <h2 id="_idParaDest-232">
    <a id="_idTextAnchor239">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In this tutorial, we will create a simple GraphQL API with a book and author relationship using Fastify and Mercurius (
    
    <a href="http://npmjs.com/package/mercurius">
     
      http://npmjs.com/package/mercurius
     
    </a>
    
     ), a GraphQL adapter for Fastify.
    
    
     This tutorial will guide you through setting up your Node.js project, installing dependencies, defining your GraphQL schema, implementing resolvers, and running your server.
    
    
     We’ll use a simple in-memory data structure to simulate a database for authors
    
    
     
      and books.
     
    
   </p>
   <p>
    
     Before diving into the creation of a GraphQL API using Fastify and Mercurius, you’ll need to set up your
    
    <a id="_idIndexMarker600">
    </a>
    
     
      development environment.
     
    
   </p>
   <ol>
    <li>
     
      Start by creating a new directory for
     
     
      
       your project:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir fastify-graphql</strong>
<strong class="bold">$ cd fastify-graphql</strong></pre>
    </li>
    <li>
     
      Initialize the Node.js project
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
   </ol>
   <p>
    
     With your environment ready and dependencies installed, let’s move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-233">
    <a id="_idTextAnchor240">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We’re now ready to build the core functionality of our Fastify GraphQL API.
    
    
     This part of the process involves defining our data models, setting up a GraphQL schema, writing resolvers to handle data fetching, and finally, starting
    
    
     
      our server.
     
    
   </p>
   <ol>
    <li>
     
      Let’s start by installing the necessary modules.
     
     
      Our GraphQL server will need a few dependencies to run.
     
     
      Specifically, we will be using Fastify as the web framework and Mercurius as the GraphQL adapter.
     
     
      Install these by running the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install fastify mercurius</strong></pre>
    </li>
    <li>
     
      Now, we need to create some mock data to work with.
     
     
      This will help us test our GraphQL API without needing a database.
     
     
      In your project folder, create a file named
     
     <strong class="source-inline">
      
       data.js
      
     </strong>
     
      .
     
     
      This file will contain arrays of authors and books, establishing a simple relationship between them where each book is linked to
     
     
      
       an author:
      
     
     <pre class="source-code">
<strong class="bold">$ touch data.js</strong></pre>
    </li>
    <li>
     
      Then, add the
     
     <a id="_idIndexMarker601">
     </a>
     
      following to
     
     <strong class="source-inline">
      
       data.js
      
     </strong>
     
      to populate some author and
     
     
      
       book data:
      
     
     <pre class="source-code">
const authors = [
  { id: '1', name: 'Richard Adams' },
  { id: '2', name: 'George Orwell' }
];
const books = [
  { id: '1', name: 'Watership Down', authorId: '1' },
  { id: '2', name: 'Animal Farm', authorId: '2' },
  { id: '3', name: 'Nineteen Eighty-four', authorId:
    '2' },
];
module.exports = { authors, books };</pre>
    </li>
    <li>
     
      Next, we need to create a GraphQL schema to represent our author and book relationship and queries.
     
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        schema.graphql
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch schema.graphql</strong></pre>
     <p class="list-inset">
      
       Now, add the following GraphQL schema
      
      
       
        to
       
      
      
       <strong class="source-inline">
        
         schema.graphql
        
       </strong>
      
      
       
        :
       
      
     </p>
     <pre class="source-code">type Query {
  books: [Book]
  authors: [Author]
}
type Book {
  id: ID
  name: String
  author: Author
}
type Author {
  id: ID
  name: String
  books: [Book]
}</pre>
    </li>
    <li>
     
      Now, create
     
     <a id="_idIndexMarker602">
     </a>
     
      a file named
     
     <strong class="source-inline">
      
       resolvers.js
      
     </strong>
     
      .
     
     
      This file will contain functions to handle the logic for fetching
     
     
      
       the data:
      
     
     <pre class="source-code">
<strong class="bold">$ touch resolvers.js</strong></pre>
    </li>
    <li>
     
      To implement our GraphQL resolvers, add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        resolvers.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const { authors, books } = require('./data');
const resolvers = {
  Query: {
    books: () =&gt; books,
    authors: () =&gt; authors,
  },
  Book: {
    author: (parent) =&gt; authors.find(author =&gt;
     author.id === parent.authorId),
  },
  Author: {
    books: (parent) =&gt; books.filter(book =&gt;
      book.authorId === parent.id),
  },
};
module.exports = { resolvers };</pre>
    </li>
    <li>
     
      Finally, we can create our
     
     
      
       Fastify server:
      
     
     <pre class="source-code">
<strong class="bold">$ touch server.js</strong></pre>
     <p class="list-inset">
      
       Add the
      
      <a id="_idIndexMarker603">
      </a>
      
       following
      
      
       
        to
       
      
      
       <strong class="source-inline">
        
         server.js
        
       </strong>
      
      
       
        :
       
      
     </p>
     <pre class="source-code">const fastify = require('fastify')();
const mercurius = require('mercurius');
const { readFileSync } = require('node:fs');
const { resolvers } = require('./resolvers');
const schema = readFileSync('./schema.graphql', 'utf-
  8');
fastify.register(mercurius, {
  schema,
  resolvers,
  graphiql: true
});
fastify.listen({ port: 3000 }, () =&gt; {
  console.log('Server running at
    http://localhost:3000');
});</pre>
    </li>
    <li>
     
      Start your
     
     
      
       Fastify server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      Open your browser and navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000/graphiql
      
     </strong>
     
      to access the
     
     <a id="_idIndexMarker604">
     </a>
     
      GraphiQL interface.
     
     
      You should expect to see an interface
     
     
      
       like this:
      
     
     <div><img alt="Figure 7.1 – GraphiQL interface showing query result" src="img/B19212_07_01.jpg"/>
      
     </div>
    </li>
   </ol>
   <p class="IMG---Figure">
    <a id="_idIndexMarker605">
    </a>
   </p>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.1 – GraphiQL interface showing query result
    
   </p>
   <ol>
    <li value="10">
     
      Try crafting some queries in the GraphiQL interface.
     
     
      For example, try executing the following query to fetch all books with
     
     
      
       their authors:
      
     
     <pre class="source-code">
 query {
  books {
    name
    author {
      name
    }
  }
}</pre>
     <p class="list-inset">
      
       Expect to see
      
      
       
        this
       
      
      
       <a id="_idIndexMarker606">
       </a>
      
      
       
        output:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 7.2 – GraphiQL interface showing query result" src="img/B19212_07_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.2 – GraphiQL interface showing query result
    
   </p>
   <p>
    
     This tutorial provides you with a foundation for creating a GraphQL API using Fastify and Mercurius.
    
    
     From here, you can extend your API by adding more complex types, queries, and mutations or by integrating a database for
    
    
     
      persistent storage.
     
    
   </p>
   <h2 id="_idParaDest-234">
    <a id="_idTextAnchor241">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the tutorial, we explore the creation of a GraphQL API using Fastify and Mercurius by defining data models, establishing a GraphQL schema, implementing resolvers for data fetching, and setting up a
    
    
     
      Fastify server.
     
    
   </p>
   <p>
    
     By creating mock data in
    
    <strong class="source-inline">
     
      data.js
     
    </strong>
    
     , we simulate a backend data store that contains authors and books.
    
    
     This approach allows us to focus on the GraphQL setup without the complexity of integrating an actual database.
    
    
     The data represents a basic relationship between books and their authors, serving as the foundation for our
    
    
     
      GraphQL queries.
     
    
   </p>
   <p>
    
     The GraphQL schema defined in
    
    <strong class="source-inline">
     
      schema.graphql
     
    </strong>
    
     acts as a contract between the server and the client.
    
    
     It specifies the types of queries that can be made, the types of data that can be fetched, and the relationships between different data types.
    
    
     In our case, the schema outlines how to query books and authors and indicates that each book is linked to an author and vice versa.
    
    
     This structure allows clients to understand and predict the shape of the data returned by
    
    
     
      the API.
     
    
   </p>
   <p>
    
     The resolvers in
    
    <strong class="source-inline">
     
      resolvers.js
     
    </strong>
    
     are functions that handle the logic for fetching the data for each type specified in the schema.
    
    
     They connect the GraphQL queries to the underlying data, essentially telling the server where and how to retrieve or modify the data.
    
    
     In the recipe, resolvers
    
    <a id="_idIndexMarker607">
    </a>
    
     fetch books and authors from the mock data and resolve the relationships between them, such as finding an author for a book or listing all books written by
    
    
     
      an author.
     
    
   </p>
   <p>
    
     Finally, setting up the Fastify server and integrating Mercurius allows us to serve our GraphQL API over HTTP.
    
    
     The server listens for requests on a specified port and uses the schema and resolvers to process
    
    
     
      GraphQL queries.
     
    
   </p>
   <p>
    
     Upon running the server, you can navigate to the GraphiQL interface to visually construct and execute queries against your API.
    
    
     This interactive environment is useful for testing and
    
    
     
      debugging queries.
     
    
   </p>
   <p>
    
     Whether GraphQL is the appropriate architecture for your project is a vast topic that goes well beyond the basics covered in this recipe.
    
    
     It involves deep considerations such as optimizing query performance, ensuring security, efficient data loading to avoid over- or under-fetching, and integrating with different databases or APIs.
    
    
     While we’ve laid the groundwork with Fastify
    
    <a id="_idIndexMarker608">
    </a>
    
     and Mercurius, diving into these more complex aspects is essential for developing sophisticated, production-ready
    
    
     
      GraphQL services.
     
    
   </p>
   <h2 id="_idParaDest-235">
    <a id="_idTextAnchor242">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     <a href="B19212_11.xhtml#_idTextAnchor353">
      
       <em class="italic">
        
         Chapter 11
        
       </em>
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>