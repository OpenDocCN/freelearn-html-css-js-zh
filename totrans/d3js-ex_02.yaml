- en: Chapter 2. Selections and Data Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use D3.js to select and manipulate the
    DOM of an HTML page based upon data. Rendering of visuals in D3.js takes a declarative
    approach, where you inform D3.js of how to visualize a piece of data instead of
    imperatively programming exactly how to draw the visual and iterate across the
    data. This process is referred to as **selection** and **data binding** in the
    D3.js nomenclature.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how D3.js can be used to create DOM elements driven by data,
    we will progress through a number of examples that demonstrate creating DIV elements
    to display various arrays of integer values. We will first examine how selection
    can be used to extract the existing DOM elements, and how D3.js is used to associate
    the data to each DOM element. Then we will examine the ways to instruct D3.js
    to create new DOM elements from the data. That will be followed by discussing
    the procedure for updating the existing elements, and for removing visual elements
    when particular data items are removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus purely upon the HTML DOM elements, and will progress to using
    SVG in later chapters. Specifically, we will progress through the following topics
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using D3.js selections to modify DOM elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the style of DOM elements using D3.js selectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding data to the DOM using `.data()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `.enter()` for creating DOM elements from new data items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the existing DOM elements based upon the changes in data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `.exit()` to remove DOM elements when the associated data is no longer
    to be visualized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A laundry list of tips on performing data binding with D3.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3.js selections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, D3.js is about selection, which is a process of finding and creating
    DOM elements that visualize data. At a simple level, a selection can just be a
    means of finding and manipulating elements in the DOM that already exist. However,
    D3.js selections can also be used for explicitly creating new elements in the
    DOM as well as for implicitly creating and removing DOM elements based upon the
    changes in an underlying data model.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with D3.js"), *Getting
    Started with D3.js*, we saw a simple example of selection in which we used selection
    to make a D3.js version of the canonical Hello World application. Now we will
    dive deeper into the power of selections. We will look at two examples of selecting
    a DOM element and changing its style.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the style of a DOM element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this first example, we will create a page with four `div` elements, each
    with a unique ID. We will then use D3.js to find the first `div` tag, and change
    its background color.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.1): [http://goo.gl/EnAQBc](http://goo.gl/EnAQBc)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `body` tag of the document contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the style of a DOM element](img/B04230_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example uses the `d3.select()` function, which returns the first element
    in the DOM that matches the given tag—in this case, `'DIV'`. The result of `d3.select()`
    is a D3.js object representing the DOM element that was identified and the data
    that D3.js has associated with that element.
  prefs: []
  type: TYPE_NORMAL
- en: This concept in D3.js is referred to as a **selector**. The function `d3.select()`
    always represents a single DOM element or a null value if the element is not found.
  prefs: []
  type: TYPE_NORMAL
- en: A selector has methods such as `.style()`, which can be used to change the CSS
    style properties of the underlying element, attributes using `.attr()`, and the
    text property using the `.text()` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we use the `.style()` function to set the `background-color` property
    of the DIV elements style to `lightblue`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the style of multiple items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To select multiple items in the DOM, we can use the `d3.selectAll()` function.
    The result is a selector which can represent multiple DOM elements that match
    the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, we will change the single line of the D3.js code in our previous
    example to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of this, the call to `.selectAll()` will represent each of the
    four `div` elements in the document. The call to `.style()` will be applied to
    each of the DOM element represented, which results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the style of multiple items](img/B04230_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.2): [http://goo.gl/61p8Nv](http://goo.gl/61p8Nv)'
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates one of the advantages of using D3.js for selection. Chained
    function calls will be applied to all DOM elements resulting from a D3.js selection.
    Therefore, we do not need to explicitly iterate through all the items. This saves
    us from excessive coding, and helps in reducing the potential of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, by default, the items in a selector are fixed at the time of the
    creation of the D3.js selector. If we were to add another `div` after the selection,
    then the elements in the existing selector will not have the new `div` tag added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter passed to the functions `d3.select()` and `d3.selectAll()` can
    also include various CSS rules as part of the query. As an example, to select
    all the elements with a specific ID, prepend the parameter with `#`. The following
    example selects only those DOM elements whose id is `div2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the style of multiple items](img/B04230_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.3): [http://goo.gl/TC4Yox](http://goo.gl/TC4Yox)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this selection will return all the DOM elements which have the ID
    `div2`, be they `div` or other types of DOM elements. This example only has `div`
    tags, so that is all that we will retrieve. Moreover, it is bad practice to have
    identical ID values on a page. But the way in which the query functions is viable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to ensure that this query returns only `div` elements, then we can
    use the following query, which places the type of the element before the hash
    symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query has the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the style of multiple items](img/B04230_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.4): [http://goo.gl/xVwV1O](http://goo.gl/xVwV1O)'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's examine the scenario where we would like to apply a different style
    to each DOM element in the selector. To do this, we can pass an accessor function
    to the `.style()` instead of a value. For example, the following code will alternate
    the color of the background of the `div` tags between `lightblue` and `lightgray`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the style of multiple items](img/B04230_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.5): [http://goo.gl/PdohHx](http://goo.gl/PdohHx)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessor functions are commonly used through D3.js. An accessor function has
    two parameters, the first of which represents the datum that has been associated
    by D3.js to the DOM element (we'll come back to this later in the chapter). The
    second parameter represents the 0-based array position of the DOM element in the
    result of the selection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second parameter of an accessor function is optional.
  prefs: []
  type: TYPE_NORMAL
- en: The return value of the selector function is another selector (or the same selector)
    in many cases. This allows us to chain the method calls together. We can do this
    to conveniently set multiple styles on all the DOM elements represented by the
    selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following code first sets the background color, and then
    sets the width of each DIV to an increasing value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the style of multiple items](img/B04230_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.6): [http://goo.gl/ukFFYL](http://goo.gl/ukFFYL)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple style properties can also be set in a single call to `.style()` by
    passing a hash of property names and values. The following has the same result
    as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.7): [http://goo.gl/17FVJs](http://goo.gl/17FVJs). The image of the
    output is omitted as it is a duplicate of the previous bl.ock.'
  prefs: []
  type: TYPE_NORMAL
- en: D3.js and data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in the previous section relied upon the elements that already exist
    in the DOM. Normally, in D3.js we would start with a set of data, and then build
    visualizations based on this data. We would also want to change the visualization
    as the data changes as a result of either adding more data items, removing some
    or all of them, or changing the properties of the existing objects.
  prefs: []
  type: TYPE_NORMAL
- en: This process of managing mapping of data to visual elements is often referred
    to as **binding of data**, and in terms of the D3.js nomenclature, it is referred
    to as a **data join** (do not confuse this with an SQL join). Binding in D3.js
    is performed by using the `.data()` function of a selector.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive in, and examine a few examples of binding data in some detail.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Binding of data can be one of the hardest things for someone new to D3.js to
    get used to. Even for somebody who uses other languages and frameworks that provide
    data binding, the way in which D3.js binds data is a little different, and getting
    to know how it does so will save a lot of time down the road. Therefore, we will
    take the time to examine it in detail as it is essential for creating effective
    D3.js visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: In D3.js, we drive the visualization of data through binding using the following
    functions of a selector.
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.data()` | Specifies the data to be used to drive the visualization |'
  prefs: []
  type: TYPE_TB
- en: '| `.enter()` | Returns a selector representing the new items to be displayed
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.exit()` | Returns a selector representing the items that are no longer
    to be displayed |'
  prefs: []
  type: TYPE_TB
- en: This pattern in which test functions are used is so ingrained in the D3.js code
    that it is often referred to as the **enter**/**update**/**exit** pattern or **general
    update** pattern. It provides a powerful means of declaratively telling D3.js
    how you want the dynamic data to be displayed, and to let D3.js handle the rendering.
  prefs: []
  type: TYPE_NORMAL
- en: We will come back to these details of the specifics of enter/update/exit in
    a little bit. For now, let's start by examining our selection example from earlier
    in the chapter, where we selected all the `div` objects in the document. This
    will help us understand the basis of how a selector facilitates the rendering
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a slight variant on the `d3.selectAll()` function from the previous
    example. Here, we will assign the result to a variable named `selector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.8): [http://goo.gl/etDgJV](http://goo.gl/etDgJV). The output is not
    shown as the code does give results visually different from the previous examples.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two other subtle differences in this preceding statement from the
    previous examples. The first is that we select the body DOM element, and the second
    is that we chain a call to `.selectAll()` for the div tags.
  prefs: []
  type: TYPE_NORMAL
- en: Using this pattern of a function chain, we are instructing D3.js to select all
    the `div` tags that are a child of the `body` tag. This chaining of select function
    calls allows us to navigate through the HTML document to look for tags in specific
    places, and as we will see shortly, specify where to put the new visual elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help conceptualize a selector, I believe that a selector can be thought
    of as a collection of mappings between the DOM elements and the data that D3.js
    has associated with those element(s). I find it useful to mentally picture a selector
    with diagrams such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data binding](img/B04230_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The orange part in the preceding diagram represents the overall selector that
    results from our selection. This selector contains four items represented by white,
    rounded rectangles, one for each `div`, and which we can think of as being numbered
    from 0 through 3.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse a selector with an array—the individual elements in this diagram
    cannot be accessed using `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: The ordering is important as we will see when we update the data. By default,
    the ordering depends on how the identified DOM elements are ordered in the DOM
    at the point of selection (in this case, children of the `body` tag).
  prefs: []
  type: TYPE_NORMAL
- en: Each item in a selector can then be thought of as consisting of two other objects.
    The first is the actual DOM element that was identified by the selection, represented
    by a blue square in the preceding diagram. Inside that square in the image is
    the DOM element type (`div`), and the value of its `id` property.
  prefs: []
  type: TYPE_NORMAL
- en: The second is the datum that D3.js has associated with that DOM element, represented
    by the green square. In this case, there is no data that is bound at this point
    by D3.js, so the data for each is null (or empty in the diagram). This is because
    these DOM elements were created in HTML and not with D3.js, and hence there is
    no associated datum.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change that and bind some data to these `div` tags. We do this by chaining
    a call to `.data()` immediately following the selection functions. This function
    is passed a collection of values or objects, and it informs D3.js that you want
    to associate each datum with a specific visual representation created by the function
    calls that follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s modify the code to the following, binding the array
    of integers to the `div` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.9): [http://goo.gl/h1O1wX](http://goo.gl/h1O1wX). The output is omitted
    from the book as it is not visually different from the previous example.'
  prefs: []
  type: TYPE_NORMAL
- en: The result of chaining the call to `.data()` tells D3.js that for each item
    identified in the selector, the datum at the same index in the data should be
    assigned. In this example, this does not change the visual. It simply assigns
    a datum to each `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check this, let''s examine the result using the developer tools. If you
    right-click on **A** in the browser, and select inspect item, the tools will open.
    Next, open the properties panel, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data binding](img/B04230_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The highlighted red rectangle in the preceding screenshot shows that the `div`
    tag now has a `__data__` property, and its value is `10`. This is how D3.js binds
    data to the visuals, by creating this property on the DOM element and assigning
    the datum. If you examine the three other `div` tags, you will see that they all
    have this property and the associated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the visual for our selector, we get the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data binding](img/B04230_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you might ask what happens if the count of items in the call to `.data()`
    does not equal the amount of items in the selector? Let''s take a look at those
    scenarios, starting with the case of fewer data items than the selected DOM elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.10): [http://goo.gl/89NReN](http://goo.gl/89NReN). The output has
    been omitted again, since the visual did not change.'
  prefs: []
  type: TYPE_NORMAL
- en: If you open the Developer tools after running this example, and examine the
    properties for each of our `div` tags, you will notice that the first three have
    a `__data__` property with the values assigned. The fourth tag does not have the
    property added. This is because D3.js iterates through the items in the data,
    assigning them one by one, and any extra DOM elements in the selector are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, the selector then looks like following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data binding](img/B04230_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s change the code to have more data items than the DOM elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.11): [http://goo.gl/CvuxNJ](http://goo.gl/CvuxNJ). The output has
    been omitted again since the visual did not change.'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the resulting DOM in the Developer tools, you can see that there are
    still only four `div` elements, with `10` through `40` assigned respectively.
    There is no new visual created for the extra data item.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data binding](img/B04230_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why is a visual not created in this case? It is because the call to `.data()`
    assigns data only to the existing visual elements in the selector. Since `.data()`
    iterates the items passed to it, it stops at the last item, and the extra DOM
    elements are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will examine how we add visuals for these stray data items in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more case that I think is worth examining. The examples so far
    for `.data()` have had pre-existing `div` tags in the document. Let''s now try
    binding some data items when there are no existing `div` tags. The body of code
    for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.12): [http://goo.gl/5gsEGe](http://goo.gl/5gsEGe). The output has
    been omitted as there are no visuals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not create any DOM elements, since we do not chain any functions
    to create them after `.data()`. However, the variable selector is a valid selector
    with three items. In our visual, it would look like the following diagram, where
    the blue squares are empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data binding](img/B04230_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you take a look at the output created on the console, you will see that
    this selector indeed has an array of three items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output does not necessarily show the data, but it does demonstrate that
    the selector consists of three items. Our conceptual model shows more, but it
    is only a conceptual model after all, and intended for understanding and not for
    representing the underlying data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we instruct D3.js to create some visuals for the data items
    to fill in those blue squares, and put something on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the entering elements with .enter()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create visuals with D3.js, we need to call the `.enter()` method of the selector
    after the call to `.data()`. Then we chain the other method calls to append one
    or more DOM elements, and normally, also call various functions for setting the
    properties of those DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify the use of `.enter()`, let''s take a look at the last example
    from the previous section, where we started without any `div` tags in the body
    and used D3.js to bind three integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now using the selector variable, we call the `.enter()` function and assign
    it to a variable named `entering`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value of `entering` will represent the new items in the selector that need
    to be created. `selector` did not have any `div` tags selected, and since we bound
    to three items, this variable represents the three new items in the selector that
    need to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the entering value and call functions to specify how to render
    the visuals for each item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.13): [http://goo.gl/HFdspR](http://goo.gl/HFdspR).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After execution, the value of `selector` contains three items, with both values
    assigned and the DOM elements created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying the entering elements with .enter()](img/B04230_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting output on the page will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying the entering elements with .enter()](img/B04230_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Examining the resulting DOM, we see that three `div` tags have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying the entering elements with .enter()](img/B04230_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I will leave it as an exercise for you to examine the properties of these elements
    for verifying the creation of the `__data__` property and assignment of the values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new items using .enter()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created DOM elements from data without any existing visuals,
    let's change the code to update the data by adding a new datum upon the press
    of a button.
  prefs: []
  type: TYPE_NORMAL
- en: In D3.js, data which need new visuals created are said to be in a state referred
    to as *entering*. After calling `.data()`, we can call the `.enter()` method on
    that same resulting selector. This method identifies the items in the selector
    that are entering, and hence require visuals to be created. We then simply chain
    methods on the result of `.enter()` to tell D3.js how each data item should be
    visualized.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change our code a little bit to demonstrate this in action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.14): [http://goo.gl/TuVYQu](http://goo.gl/TuVYQu)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code makes a few modifications to the previous example. First we add a
    button that can be pressed. This button will call a function named `render()`
    and pass an array of four values to it, the first three of which are identical
    in value. There also exists a new datum at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The render function itself does the selection and creation of the new visual
    elements, but it uses the values passed to the function instead of a hard-coded
    array of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the page is first loaded, we call render, telling it to create elements
    in a different array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial page that is loaded will contain the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding new items using .enter()](img/B04230_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we press the button we call render again, but pass it four values. This
    results in the content on the page changing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding new items using .enter()](img/B04230_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This may appear as if the previously existing `div` tags were replaced with
    four new ones, but what happens is actually more subtle. The second time that
    `render()` is called, the call to `.selectAll(''div'')` creates a selector that
    has three items, each of which has DOM elements and their bound data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding new items using .enter()](img/B04230_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, `.data([10, 20, 30, 40])` is executed. D3.js iterates this array, and
    it compares the value of each datum to the item in the selector at the same index.
    In this case, the items at positions 0, 1, and 2 have the values `10`, `20`, and
    `30`, which are each equal to the values at the same position in the data. Therefore,
    D3.js does not do anything to these items. But the fourth value, `40`, does not
    have an associated item in the selector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding new items using .enter()](img/B04230_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, D3.js will create a new item in the selector for the datum 40, and
    then apply the functions for creating the visuals, resulting in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding new items using .enter()](img/B04230_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: D3.js has left the first three items (and their DOM elements) untouched, and
    added new DOM elements for just the `40` datum.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to point out in this example is that I did not set the ID property,
    and hence the conceptual selector does not show the property.
  prefs: []
  type: TYPE_NORMAL
- en: Updating values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's look at an example where we change the value of several of the items
    in our data. In this case, we do not want to remove and insert a new visual in
    the DOM, but to simply update the properties in the DOM to represent a change
    in the underlying values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An example of an update like this could be the price of a stock that needs to
    be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s make a quick change to the previous example, where
    when we click the button, we will now execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.15): [http://goo.gl/nyUrRL](http://goo.gl/nyUrRL)'
  prefs: []
  type: TYPE_NORMAL
- en: 'On pressing the button, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating values](img/B04230_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nothing has changed on the page! Shouldn't the page be displaying 20, 30, and
    50?
  prefs: []
  type: TYPE_NORMAL
- en: 'This gets into some of the subtleties of D3.js data binding. Let''s step through
    this to explain this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `.selectAll(''div'')` identifies the three `div` tags when the
    page was loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating values](img/B04230_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following that, the call to `.data()` binds new values to each item in the
    selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating values](img/B04230_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: D3.js has changed the bound values, but all the items were reused, and hence,
    are not tagged as entering. Therefore, the following statement results in an empty
    set of entering items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the chained methods are not executed, and the DOM elements are
    not updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we fix this? It''s actually quite simple: we need to handle both, the
    case of entering elements and the case of the already existing ones. To do this,
    change the render function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that we have added the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we chain methods to the original selector, the chained functions will
    be applied to all the items in the selector that are neither entering nor exiting
    (we cover exiting in the next section). And the result is what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating values](img/B04230_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Removing items with .exit()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's discuss how visuals change when items are removed from the collection
    of bound data. To handle exit, we simply need to use the `.exit()` function on
    the result of `.data()`. The return value of `.exit()` is a collection of the
    selector items which D3.js has determined need removal from the visualization
    based upon the change in data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the removal of items, we will make a couple of simple modifications
    to the previous example. First, let''s change the button code to render the following
    array upon clicking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the page with this change, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing items with .exit()](img/B04230_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Conceptually, we would have expected the resulted as a page with just 5 and
    15, and not 5, 15, and 30.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this result is again because of the way that D3.js handles data
    binding. When we call `.data()` with the updated data, D3.js attempts to reconcile
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing items with .exit()](img/B04230_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since all that `.data()` does is update the bound value in each item of the
    selector, and since there are fewer values than the selector items, we get the
    following selector as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing items with .exit()](img/B04230_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We then call our code to handle the enter and update states. In this case, there
    are no entering items, whereas items at positions 0 and 1 are scheduled for update.
    Hence, the first two div tags get new text values, and the third div is left unchanged
    in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that we have to do to fix this is make a call to `.exit()`, and use the
    results of this call to remove those items from the DOM. We can modify `render()`
    to the following, which gives us our desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (2.16): [http://goo.gl/IkIjGY](http://goo.gl/IkIjGY)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change is the addition of the last two lines. Now when we press the
    button, we get the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing items with .exit()](img/B04230_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A few notes for the wise about the general update pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To close this chapter, I'd like to emphasize several points about managing visuals
    based upon data using D3.js. I believe these will definitely help you avoid problems
    in learning D3.js. Having come from other development platforms where data binding
    works in a different manner, I definitely struggled with these issues, and I want
    to pass along the insights that have I have learned to save you a lot of stress.
    It's kind of a long list, but I believe it to be very valuable.
  prefs: []
  type: TYPE_NORMAL
- en: A visualization is almost always based upon data, and is not just coded explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, a D3.js application, on page load, will perform a `.selectAll()` on
    the document for the DOM elements that would represent data. Often, the result
    of this selection does not have any elements, as the page was just loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A call is then made to `.data()` to bind data to the selector that results from
    the selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data()` iterates across the datum that are passed to it, and ensures that
    there are items in the selector to correlate the datum to the visuals. The value
    of the datum is copied into this item. DOM elements are not created by the call
    to `.data()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data in many apps changes dynamically over time without reloading the page,
    either by user interaction or through code that updates the data based upon other
    events. You would want to update the visualization when this happens. Therefore,
    you will need to call `.data()` multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number of items in the data is more than the number of items in the selector
    it is applied to, then more selector items will be created at the end of the selector.
    These will be marked as in a state referred to as entering. These will be accessible
    using the `.enter()` function on the selector. You then chain the function calls
    to create DOM elements for each new item in the selector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number of items in the data is less than the number of items in the selector,
    then selector items will be removed from the end of the selector. These will be
    marked as exiting. These selector items will be available through a call to the
    `.exit()` function. These DOM elements will not be removed from the DOM automatically,
    and you will need to make a call to `.remove()` to make this so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To optimize this process, D3.js really only concerns itself with ensuring the
    number of items in the selector matches the number of datum that you specify with
    `.data()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data associated with a selector item is by value and not reference. Hence,
    `.data()` copies data into the `__data__` property on the DOM element. On subsequent
    calls to `.data()`, there is no comparison performed between the datum and the
    value of the `__data__` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To update data, you write code to chain methods for generating DOM on the result
    of a selection, in addition to code that chains on the `.enter()` and `.exit()`
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a new datum has the same value as is already associated to a selector item,
    D3.js does not care. Even though the values have not changed, you will be rendering
    it again, but reusing the DOM elements. You will need to provide your own facilities
    to manage not setting the properties again if the data is the same, so as to optimize
    the browser re-rendering the elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have 1,000,000 data items, and then change just one and call `.data()`
    again, D3.js will inherently force you to loop through all the 1,000,000 items.
    There will likely be visual updates to just one set of visuals, but your application
    will make the effort to iterate through everything every time. However, if you
    have 1,000,000 data items, you probably should be looking at another means of
    summarizing your data before visualizing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3.js optimizes around the reuse of visual elements. The assumption is that
    a visualization will only be periodically making updates to the exiting items,
    and that addition or removal of items will be relatively infrequent. Hence, the
    general update pattern would consist of exit, update, and exit, and not comparing
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, the rule of thumb is that one or two thousand data items and the associated
    visuals are handled pretty effectively by D3.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, that's quite a long list. But as we progress through this book, all the
    examples will follow these guidelines. By the end, these will be second nature.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered many examples to demonstrate how you can create
    data-driven visualizations using D3.js. We started with examples of the D3.js
    concept of selectors, using them to select elements from within the DOM, and discussed
    how selectors are used to map data items to the visuals that D3.js creates. We
    then examined several scenarios of binding new data, updating data, and removing
    data from a D3.js visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, the visuals that we created with D3.js were pure HTML
    objects, primarily `div` tags. Although we changed the size of these `div` tags,
    the background color, and included text within them, the examples are a very basic
    form of graphical representation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to get significantly more graphical by changing
    the focus of the examples towards working with SVG, creating real graphics (not
    just HTML `div` tags), and setting a framework for the rich visualizations that
    we will create later in the book.
  prefs: []
  type: TYPE_NORMAL
