<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Promises and Proxies</h1></div></div></div><p>This chapter introduces the important concept of <strong>asynchronous programming</strong> and how JavaScript is an ideal language to utilize it. The other topic that we will cover in this chapter is meta programming with proxies. These two concepts are introduced in ES6.</p><p>In this chapter, our primary focus is to understand asynchronous programming, before we jump into the language - specific constructs, let's spend time in understanding the concept first.</p><p>The first model-the <strong>synchronous model-</strong>is where it all began. This is the simplest model of programming. Each task is executed one at a time, and only after the first task completes execution can, the next task start. When you program in this model, we expect that all tasks before the current task are complete and there is no error. Take a look at the following figure:</p><p>
</p><div><img src="img/image_09_001.jpg" alt="Promises and Proxies"/></div><p>
</p><p>The <strong>single threaded asynchronous model</strong> is a familiar model we all know. However, this model can be wasteful and optimized. For any nontrivial programs composed of several different tasks, this model can be slow. Consider the following hypothetical scenario as an example:</p><pre class="programlisting">    var result = database.query("SELECT * FROM table");      &#13;
    console.log("After reading from the database"); &#13;
</pre><p>With the synchronous model in mind, two tasks are executed one after the other. This means that the second statement will only be executed once the first has completed execution. Assuming the first statement is a costly one and takes 10 seconds (it is normal to take even more time to read from a remote database), the second statement will be blocked.</p><p>This is a serious problem when you need to write high - performance and scalable systems. There is another problem that manifests when you are writing programs where you need to write interfaces for human interactions like we do on websites that run on a browser. While you are performing a task that may take some time, you cannot block the user. They may be entering something in an input field while the costly task is running; it would be a terrible experience if we block user input while we are busy doing a costly operation. In such scenarios, the costly tasks need to be run in the background while we can happily take input from the user.</p><p>To solve this, one solution is to split each task into its own thread of control. This is called the <strong>multi-threaded</strong> or <strong>threaded model</strong>. Consider the following figure:</p><p>
</p><div><img src="img/image_09_002.jpg" alt="Promises and Proxies"/></div><p>
</p><p>The difference is how the tasks are split. In the threaded model, each task is performed in its own thread of control. Usually, threads are managed by the operating system and can be run in parallel on different CPU cores or on a single core with appropriate thread scheduling done by the CPU. With modern CPUs, the threaded model can be extremely optimal in performance. Several languages support this popular model. Although a popular model, the threaded model can be complex to implement in practice. The threads need to communicate and coordinate with each other. Inter-thread communication can get tricky very quickly. There are variations of the threaded model where the state is immutable. In such cases, the model becomes simpler as each thread is responsible for immutable state and there is no need to manage state between threads.</p><div><div><div><div><h1 class="title"><a id="ch09lvl2sec104"/>Asynchronous programming model</h1></div></div></div><p>The third model is what interests us the most. In this model, tasks are interleaved in a single thread of control. Consider the following figure:</p><p>
</p><div><img src="img/image_09_003.jpg" alt="Asynchronous programming model"/></div><p>
</p><p>The <strong>asynchronous model</strong> is simpler because you have only one thread. When you are executing one task, you are sure that only that task is being executed. This model doesn't require complex mechanism for inter-thread coordination and, hence, is more predictable. There is one more difference between the threaded and the asynchronous models; in the threaded model, you don't have a way to control the thread execution as the thread scheduling is mostly done by the operating system. However, in the asynchronous model, there is no such challenge.</p><p>In which scenarios can the asynchronous model outperform the synchronous model? If we are simply splitting tasks into smaller chunks, intuitively, even the smaller chunks will take quite an amount of time when you add them up in the end.</p><p>There is a significant factor we have not yet considered. When you execute a task, you will end up waiting on something-a disk read, a database query, or a network call; these are blocking operations. When you enter a blocked mode, your task simply waits in the synchronous model. Take a look at the following figure:</p><p>
</p><div><img src="img/image_09_004.jpg" alt="Asynchronous programming model"/></div><p>
</p><p>In the preceding diagram, the black blocks are where a task is waiting on something. What are the typical operations that can cause such a block? A task is performed in a CPU and RAM. A typical CPU and RAM can handle data transfer orders of magnitude faster than a typical disc read or a network call.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>Please refer to a comparison (<a class="ulink" href="https://gist.github.com/jboner/2841832">https://gist.github.com/jboner/2841832</a>) of latencies between CPU, internal memory, and discs.</p></div></div><p>When your tasks wait on an <strong>I</strong>/<strong>O</strong> (<strong>Input</strong>/<strong>Output</strong>) from such sources, the latency is unpredictable. For a synchronous program that does a lot of I/O, this is a recipe for bad performance.</p><p>The most important difference between the synchronous and asynchronous models is the way they handle blocking operations. In the asynchronous model, a program, when faced with a task that encounters a block, executes another task without waiting for the blocking operation to finish. In a program where there are potential blocks, an asynchronous program outperforms an equivalent synchronous program because less time is spent on waiting. A slightly inaccurate visualization of such a model would be as seen in the following figure:</p><p>
</p><div><img src="img/image_09_005.jpg" alt="Asynchronous programming model"/></div><p>
</p><p>With this conceptual background of the asynchronous model with us, we can look at language - specific constructs to support this model.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec74"/>JavaScript call stack</h1></div></div></div><p>In JavaScript, function calls form a stack of frames. Consider the following example:</p><pre class="programlisting">    function c(z2) { &#13;
        console.log(new Error().stack); &#13;
    } &#13;
    function b(z1) { &#13;
        c(z1+ 1); &#13;
    } &#13;
    function a(z) { &#13;
        b(z + 1); &#13;
    } &#13;
    a(1);  &#13;
 &#13;
    //at c (eval at &lt;anonymous&gt;) &#13;
    //at b (eval at &lt;anonymous&gt;) &#13;
    //at a (eval at &lt;anonymous&gt;) &#13;
</pre><p>When we call function <code class="literal">a()</code>, the first frame in the stack is created with arguments to the function and all local variables in the <code class="literal">a()</code>function. When function <code class="literal">a()</code> calls function <code class="literal">b()</code>, a second frame is created and pushed to the top of the stack. This goes on for all function calls. When the <code class="literal">c()</code>function returns, the top frame from the stack is popped out, leaving functions <code class="literal">b()</code> and <code class="literal">a()</code>; this goes on until the entire stack is empty. This is necessary to maintain because once the function finishes execution, JavaScript will need to know where to return.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec105"/>Message queue</h2></div></div></div><p>The JavaScript runtime contains a message queue. This queue contains the list of messages to be processed. These messages are queued in response to events such as <code class="literal">click</code> or an HTTP response received. Each message is associated with a callback function.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec106"/>Event loop</h2></div></div></div><p>A browser tab runs in a single thread-an event loop. This loop continuously picks messages from the message queue and executes the callbacks associated with them. The event loop simply keeps picking tasks from the message queues while other processes add tasks to the message queue. Other processes such as timers and event handlers run in parallel and keep adding tasks to the queue.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec107"/>Timers</h2></div></div></div><p>The <code class="literal">setTimeout()</code>method creates a timer and waits until it fires. When the timer is executed, a task is added to the message queue. The <code class="literal">setTimeOut()</code> method takes two arguments: a callback, and the duration in milliseconds. After the duration, the callback is added to the message queue. Once the callback is added to the message queue, the event loop will eventually pick it up and execute it. There is, however, no guarantee when the callback will be picked up by the event loop.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec54"/>Run to completion</h3></div></div></div><p>When the event loop picks up a message from the queue, the associated callback is run to completion. This means that a message is processed completely before the next message from the queue is processed. This property gives the asynchronous model a sense of predictability. As there is no intervention to preempt any of the messages in between execution, this model is much simpler than other models, where any unit of execution can be halted in between. However, once the message is picked up, even if the execution takes too long, any other interaction on the browser is blocked.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec55"/>Events</h3></div></div></div><p>You can register event handlers for an object and receive results of a method asynchronously. The following example shows how we can set up event handlers for the <code class="literal">XMLHttpRequest</code> API:</p><pre class="programlisting">    var xhr = new XMLHttpRequest(); &#13;
    xhr.open('GET', 'http://babeljs.io', true); &#13;
    xhr.onload = function(e) { &#13;
      if (this.status == 200) { &#13;
        console.log("Works"); &#13;
      } &#13;
    }; &#13;
    xhr.send(); &#13;
</pre><p>In the preceding snippet, we are creating the object of the <code class="literal">XMLHttpRequest</code> class. Once the request object is created, we will register event handlers for it. Event handlers, such as <code class="literal">onload()</code>, are triggered asynchronously when the response is received from the <code class="literal">open()</code> method.</p><p>The <code class="literal">send()</code> method doesn't actually initiate the request, it adds the request to the message queue for the event loop to pick it up and execute necessary callbacks associated with it.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec56"/>Callbacks</h3></div></div></div><p>The Node.js application popularized this style of receiving asynchronous data. A callback is a function passed as the last argument to the asynchronous function call.</p><p>To illustrate the usage, let's use the following example of reading a file in Node.js:</p><pre class="programlisting">    fs.readFile('/etc/passwd', (err, data) =&gt; { &#13;
      if (err) throw err; &#13;
     console.log(data); &#13;
    }); &#13;
</pre><p>Don't worry about a few details here. We are using the filesystem module as an <code class="literal">fs</code> alias. This module has a <code class="literal">readFile</code> method to read a file asynchronously. We will pass the file path and filename as the first argument and a callback function as the last argument of the function. We are using an anonymous function as the callback in the example.</p><p>The callback function has two arguments-error and data. When the <code class="literal">readFile()</code> method is successful, the callback function receives <code class="literal">data</code>, and if it fails, the <code class="literal">error</code> argument will have the error details.</p><p>We can also use a slightly functional style to write the same callback. Consider the following example:</p><pre class="programlisting">    fs.readFile('/etc/passwd',  &#13;
      //success &#13;
      function(data) { &#13;
        console.log(data) &#13;
      }, &#13;
      //error &#13;
      function(error) { &#13;
        console.log(error) &#13;
      } &#13;
    );   &#13;
</pre><p>This style of passing callbacks is also called <strong>continuous-passing style</strong> (<strong>CPS</strong>); the next step of execution or continuation is passed as a parameter. The following example further illustrates the CPS style of callbacks:</p><pre class="programlisting">    console.log("1"); &#13;
    cps("2", function cps_step2(val2){ &#13;
      console.log(val2); &#13;
      cps("3", function cos_step3(val3){ &#13;
        console.log(val3); &#13;
      }) &#13;
      console.log("4"); &#13;
    }); &#13;
    console.log("5"); &#13;
    //1 5 2 4 3 &#13;
 &#13;
    function cps(val, callback) { &#13;
      setTimeout(function () { &#13;
            callback(val); &#13;
      }, 0); &#13;
    } &#13;
</pre><p>We will provide the continuation (the next callback) to each step. This nested callback style also causes a problem sometimes referred to as callback hell.</p><p>Callbacks and the CPS introduce a radically different style of programming. Although it is easier to understand callbacks compared to other constructs, callbacks can create slightly difficult to understand code.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Promises</h1></div></div></div><p>ES6 introduces promises as an alternate to callbacks. Like callbacks, promises are used to retrieve the results of an asynchronous function call. Using promises is easier than callbacks and produces more readable code. However, to implement promises for your asynchronous functions requires more work.</p><p>A promise object represents a value that may be available now or in the future, or possibly never. As the name suggests, a promise may be fulfilled or rejected. A promise acts as a placeholder for the eventual result.</p><p>A promise has three mutually exclusive states, which are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">A promise is <strong>pending</strong> before the result is ready; this is the initial state.</li><li class="listitem">A promise is <strong>fulfilled</strong> when the result is ready.</li><li class="listitem">On an error, a promise is <strong>rejected</strong>.</li></ol></div><p>When a pending promise is either fulfilled or rejected, associated callbacks/handlers that are queued up by the <code class="literal">then()</code> method of the promise are executed.</p><p>The purpose of promises is to provide a better syntax for the CPS callbacks. The typical CPS style asynchronous functions like the following one:</p><pre class="programlisting">    asyncFunction(arg, result =&gt; { &#13;
      //... &#13;
    }) &#13;
</pre><p>The preceding code can be written a bit differently with promises, as shown in the following lines of code:</p><pre class="programlisting">    asyncFunction(arg). &#13;
    then(result=&gt;{ &#13;
      //... &#13;
    }); &#13;
</pre><p>The asynchronous function now returns a promise, which is the placeholder for an eventual result. Callbacks registered with the <code class="literal">then()</code> method are notified when the result is ready.</p><p>You can chain the <code class="literal">then()</code> method. When the <code class="literal">then()</code> method sees that the callback triggered another asynchronous action that returns a promise, it returns that promise. Take a look at the following example:</p><pre class="programlisting">    asyncFunction(arg) &#13;
    .then(resultA=&gt;{ &#13;
      //... &#13;
      return asyncFunctionB(argB); &#13;
    }) &#13;
    .then(resultB=&gt;{ &#13;
      //... &#13;
    }) &#13;
</pre><p>Let's see a real example of how we can use promises. We saw a typical example of asynchronous file reads in Node.js; now let's see what that example will look like when used with promises. To jog our memories, we wrote something like the following:</p><pre class="programlisting">    fs.readFile('text.json', &#13;
      function (error, text) { &#13;
          if (error) { &#13;
              console.error('Error while reading text file'); &#13;
          } else { &#13;
              try { &#13;
                  //... &#13;
              } catch (e) { &#13;
                  console.error('Invalid content'); &#13;
              } &#13;
          } &#13;
      }); &#13;
</pre><p>We see callbacks as continuation here; now let's see how the same function can be written using promises:</p><pre class="programlisting">    readFileWithPromises('text.json') &#13;
    .then(text=&gt;{ &#13;
      //...process text &#13;
    }) &#13;
    .catch(error=&gt;{ &#13;
      console.error('Error while reading text file'); &#13;
    }) &#13;
</pre><p>Now the callbacks are invoked via the result and methods <code class="literal">then()</code> and <code class="literal">catch()</code>. The error handling is much cleaner because we are not writing the <code class="literal">if...else</code> and <code class="literal">try...catch</code> constructs anymore.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec108"/>Creating promises</h2></div></div></div><p>We saw how we can consume promises. Now, let's look at how we can produce them.</p><p>As a producer, you can create a <code class="literal">Promise</code> object and send a result via the <code class="literal">Promise</code>. The construct looks like the following code snippet:</p><pre class="programlisting">    const p = new Promise( &#13;
      function (resolve, reject) { // (1) &#13;
          &#13;
          if (   ) { &#13;
              resolve(value); // success &#13;
          } else { &#13;
              reject(reason); // failure &#13;
          } &#13;
      }); &#13;
</pre><p>The parameter to <code class="literal">Promise</code> is an executor function. The executor handles two states of the promise, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Resolving</strong>: If the result was generated successfully, the executor sends the results back via the <code class="literal">resolve()</code> method. This method usually fulfills the <code class="literal">Promise</code> object.</li><li class="listitem" style="list-style-type: disc"><strong>Rejecting</strong>: If an error happened, the executor notifies the consumer via the <code class="literal">reject()</code> method. If an exception occurs, it is notified via the <code class="literal">reject()</code> method as well.</li></ul></div><p>As a consumer, you are notified of either fulfillment of promise or rejection of promise via the <code class="literal">then()</code> and <code class="literal">catch()</code> methods. Consider the following piece of code as an example:</p><pre class="programlisting">    promise &#13;
    .then(result =&gt; { /* promise fulfilled */ }) &#13;
    .catch(error =&gt; { /* promise rejected */ }); &#13;
</pre><p>Now that we have some background on how to produce promises, let's rewrite our earlier example of the asynchronous file's <code class="literal">read</code> method to produce promises. We will use Node.js's filesystem module and the <code class="literal">readFile()</code> method as we did last time. If you don't understand any Node.js specific construct in the following snippet, please don't worry. Consider the following code:</p><pre class="programlisting">    import {readFile} from 'fs'; &#13;
    function readFileWithPromises(filename) { &#13;
        return new Promise( &#13;
            function (resolve, reject) { &#13;
                readFile(filename,  &#13;
                    (error, data) =&gt; { &#13;
                        if (error) { &#13;
                            reject(error); &#13;
                        } else { &#13;
                            resolve(data); &#13;
                        } &#13;
                    }); &#13;
            }); &#13;
    } &#13;
</pre><p>In the preceding snippet, we are creating a new <code class="literal">Promise</code> object and returning it to the consumer. As we saw earlier, the parameter to the <code class="literal">Promise</code> object is the executor function and the executor function takes care of two states of <code class="literal">Promise</code>-fulfilled and rejected. The executor function takes in two arguments, <code class="literal">resolve</code> and <code class="literal">reject</code>. These are the functions that notify the state of the <code class="literal">Promise</code> object to the consumer.</p><p>Inside the executor function, we will call the actual function-the <code class="literal">readFile()</code> method; if this function is successful, we will return the result using the <code class="literal">resolve()</code> method and if there is an error, we will notify the consumer using the <code class="literal">reject()</code> method.</p><p>If an error happens in one of the <code class="literal">then()</code> reactions, they are caught in the subsequent <code class="literal">catch()</code> block. Take a look at the following code:</p><pre class="programlisting">    readFileWithPromises('file.txt') &#13;
    .then(result=&gt; { 'something causes an exception'}) &#13;
    .catch(error=&gt; {'Something went wrong'}); &#13;
</pre><p>In this case, the <code class="literal">then()</code> reaction causes an exception or error, and the subsequent <code class="literal">catch()</code> block can handle this.</p><p>Similarly, an exception thrown inside a <code class="literal">then()</code> or <code class="literal">catch()</code> handler is passed to the next error handler. Consider the following code snippet:</p><pre class="programlisting">    readFileWithPromises('file.txt') &#13;
    .then(throw new Error()) &#13;
    .catch(error=&gt; {'Something went wrong'}); &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch09lvl3sec57"/>Promise.all()</h3></div></div></div><p>One interesting use case is to create an iterable over promises. Let's assume that you have a list of URLs you want to visit and parse the results. You can create promises for each of the fetch URL calls and use them individually, or you can create an iterator with all the URLs and use the promise in one go. The <code class="literal">Promise.all()</code> method takes the iterable of promises as an argument. When all of the promises are fulfilled, an array is filled with their results. Consider the following code as an example:</p><pre class="programlisting">    Promise.all([ &#13;
        f1(), &#13;
        f2() &#13;
    ]) &#13;
    .then(([r1,r2]) =&gt; { &#13;
        //    &#13;
    }) &#13;
    .catch(err =&gt; { &#13;
        //.. &#13;
    }); &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec109"/>Metaprogramming and proxies</h2></div></div></div><p>Metaprogramming refers to a method of programming where the program is aware of its structure and can manipulate itself. Many languages have support for metaprogramming in the form of macros. Macros are important constructs in functional languages such as <strong>LISP</strong> (<strong>Locator/ID Separation Protocol</strong>). In languages such as Java and C#, reflection is a form of metaprogramming because a program can examine information about itself using reflection.</p><p>In JavaScript, you can say that methods of object allow you to examine the structure and hence, they offer metaprogramming. There are three types of metaprogramming paradigms (<em>The Art of the Metaobject Protocol,</em> Kiczales et al, <a class="ulink" href="https://mitpress.mit.edu/books/art-metaobject-protocol">https://mitpress.mit.edu/books/art-metaobject-protocol</a>):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Introspection</strong>: This gives a read-only access to the internals of a program</li><li class="listitem" style="list-style-type: disc"><strong>Self-modification</strong>: This makes structural changes possible to the program</li><li class="listitem" style="list-style-type: disc"><strong>Intercession</strong>: This changes language semantics</li></ul></div><p>The <code class="literal">Object.keys()</code> method is an example of introspection. In the following example, the program is examining its own structure:</p><pre class="programlisting">    const introspection = { &#13;
      intro() { &#13;
        console.log("I think therefore I am"); &#13;
      } &#13;
    } &#13;
    for (const key of Object.keys(introspection)){ &#13;
      console.log(key);  //intro &#13;
    } &#13;
</pre><p>Self-modification is also possible in JavaScript by mutating the properties of an object.</p><p>However, intercession, or the ability to change language semantics, is something not available in JavaScript till ES6. Proxies are introduced to open up this possibility.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec110"/>Proxy</h2></div></div></div><p>You can use a proxy to determine the behavior of an object, which is called the target, whenever its properties are accessed. A proxy is used to define custom behavior for basic operations on an object, such as looking up a property, function invocation, and assignment.</p><p>A proxy needs two parameters, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Handler</strong>: For each operation you want to customize, you need a <code class="literal">handler</code> method. This method intercepts the operations and is sometimes called a trap.</li><li class="listitem" style="list-style-type: disc"><strong>Target</strong>: When the <code class="literal">handler</code> does not intercept the operation, the <code class="literal">target</code> is used as a fallback.</li></ul></div><p>Let's take a look at the following example to understand this concept better:</p><pre class="programlisting">    var handler = { &#13;
      get: function(target, name){ &#13;
        return name in target ? target[name] :42; &#13;
      } &#13;
    } &#13;
    var p = new Proxy({}, handler); &#13;
    p.a = 100; &#13;
    p.b = undefined; &#13;
    console.log(p.a, p.b); // 100, undefined &#13;
    console.log('c' in p, p.c); // false, 42 &#13;
</pre><p>In this example, we are trapping the operation of getting a property from the object. We return <code class="literal">42</code> as a default property value if the property does not exist. We are using the <code class="literal">get</code> handler to trap this operation.</p><p>You can use proxies to validate values before setting them on an object. For this, we can trap the <code class="literal">set</code> handler as follows:</p><pre class="programlisting">    let ageValidator = { &#13;
      set: function(obj, prop, value) { &#13;
        if (prop === 'age') { &#13;
          if (!Number.isInteger(value)) { &#13;
            throw new TypeError('The age is not an number'); &#13;
          } &#13;
          if (value &gt; 100) { &#13;
            throw new RangeError('You cant be older than 100'); &#13;
          } &#13;
        } &#13;
        // If no error - just store the value in the property &#13;
        obj[prop] = value; &#13;
      } &#13;
    }; &#13;
    let p = new Proxy({}, ageValidator); &#13;
    p.age = 100; &#13;
    console.log(p.age); // 100 &#13;
    p.age = 'Two'; // Exception &#13;
    p.age = 300; // Exception &#13;
</pre><p>In the preceding example, we are trapping the <code class="literal">set</code> handler. When we set a property of the object, we are trapping that operation and introducing validation of values. If the value is valid, we will set the property.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec111"/>Function traps</h2></div></div></div><p>There are two operations that can be trapped if the target is a function: <code class="literal">apply</code> and <code class="literal">construct</code>.</p><p>To intercept function calls, you will need to trap the <code class="literal">get</code> and <code class="literal">apply</code> operations. First get the function and then apply to call the function. So, you <code class="literal">get</code> the function and return the function.</p><p>Let's consider the following example to understand how method interception works:</p><pre class="programlisting">    var car = { &#13;
      name: "Ford", &#13;
      method_1: function(text){ &#13;
        console.log("Method_1 called with "+ text); &#13;
      } &#13;
    } &#13;
    var methodInterceptorProxy = new Proxy(car, { &#13;
     //target is the object being proxied, receiver is the proxy &#13;
     get: function(target, propKey, receiver){ &#13;
      //I only want to intercept method calls, not property access &#13;
      var propValue = target[propKey]; &#13;
      if (typeof propValue != "function"){ &#13;
       return propValue; &#13;
  } &#13;
      else{ &#13;
       return function(){ &#13;
        console.log("intercepting call to " + propKey&#13;
          + " in car " + target.name); &#13;
        //target is the object being proxied &#13;
        return propValue.apply(target, arguments); &#13;
       } &#13;
      } &#13;
     } &#13;
    }); &#13;
    methodInterceptorProxy.method_1("Mercedes"); &#13;
    //"intercepting call to method_1 in car Ford" &#13;
    //"Method_1 called with Mercedes" &#13;
</pre><p>In the preceding example, we are trapping the <code class="literal">get</code> operation. If the type of the property being <code class="literal">get</code> is a function, we will use <code class="literal">apply</code> to invoke that function. If you see the output, we are getting two <code class="literal">console.logs</code>; the first is from the proxy where we trapped the <code class="literal">get</code> operation and the second is from the actual method call.</p><p>Metaprogramming is an interesting construct to use. However, any kind of introspection or reflection comes at the cost of performance. Care should be taken while using proxies as they can be slow.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Summary</h1></div></div></div><p>In this chapter, we looked at two important concepts. ES6 proxies are useful meta programming constructs used to define custom behavior for fundamental operations (for example, property lookup, assignment, enumeration, function invocation, and so on). We looked at how to use handlers, traps, and proxy targets to intercept and modify the default behavior of operations. This gives us very powerful meta programming capabilities earlier lacking in JavaScript.</p><p>The other important construct we discussed in this chapter was ES6 promises. Promises are important because they make asynchronous programming constructs easier to work with. A promise acts as a proxy for a value not necessarily known when the promise is created. This lets asynchronous methods return values like synchronous methods - instead of the final value, the asynchronous method returns a promise for the value at some point in the future.</p><p>These are two very powerful constructs in ES6 that greatly enhance the language's core capabilities.</p><p>In the next chapter, we will look at the fascinating possibilities around browsers and DOM manipulation using JavaScript.</p></div></body></html>