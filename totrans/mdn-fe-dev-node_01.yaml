- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Learning about the Internals of Node.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Node.js 的内部机制
- en: For years, being a frontend developer meant writing a bit of HTML and putting
    some styling with CSS on it. However, since the last decade, this job description
    barely holds true. In contrast, the majority of frontend work is now done using
    **JavaScript**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，成为一名前端开发者意味着写一些 HTML 代码，并在其上添加一些 CSS 样式。然而，自从上个十年以来，这种工作描述几乎已经不再适用。相反，现在大部分的前端工作都是使用
    **JavaScript** 来完成的。
- en: Initially used to make cosmetic enhancements to websites (such as the toggling
    of elements) possible, frontend development is now the glue of the web. Websites
    are no longer just written in HTML and CSS. Instead, in many cases, web pages
    are programmed with JavaScript using modern techniques such as dependency management
    and bundling of resources. The **Node.js** framework provides an ideal foundation
    for this movement. It enables developers to use JavaScript not only inside websites
    running in a browser but also within the tooling to write web pages – outside
    of a browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最初用于使网站（如元素的切换）的微调增强成为可能，前端开发现在已成为网络的粘合剂。网站不再仅仅是使用 HTML 和 CSS 编写的。相反，在许多情况下，网页是通过使用现代技术（如依赖管理和资源打包）用
    JavaScript 编程的。**Node.js** 框架为这一运动提供了一个理想的基础。它使开发者能够在浏览器中运行的网站内部以及编写网页的工具中（在浏览器之外）使用
    JavaScript。
- en: When Node.js was released in May 2009, it did not seem like a big deal. JavaScript
    was working on the server too. However, the cross-platform nature of Node.js and
    the size of the JavaScript community provided the basis for one of the greatest
    disruptions in the history of computing. People started adopting the framework
    so quickly that many existing frameworks either disappeared or had to be reworked
    to stay attractive to developers. Soon, JavaScript was used in the browser and
    on the server and was also part of every frontend developer’s toolbox.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Node.js 在 2009 年 5 月发布时，并没有引起太大的关注。JavaScript 也可以在服务器上运行。然而，Node.js 的跨平台特性和
    JavaScript 社区的规模为计算机历史上最大的颠覆之一奠定了基础。人们如此迅速地采用这个框架，以至于许多现有的框架要么消失了，要么不得不进行重构以吸引开发者。很快，JavaScript
    就被用于浏览器和服务器，并且也成为了每个前端开发者工具箱的一部分。
- en: With the rise of new development frameworks such as **Angular** or **React**,
    the need for attractive frontend tooling became apparent. The new frameworks always
    relied on some build steps – otherwise, websites and applications using these
    frameworks would have been far too inconvenient to write for developers. Since
    the vast Node.js ecosystem seemed to have figured out a suitable approach for
    reusability, these new frameworks adopted it and made it an integral part of their
    development story. This way, using Node.js became the de facto standard for frontend
    projects of any kind.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的开发框架（如 **Angular** 或 **React**）的兴起，对有吸引力的前端工具的需求变得明显。这些新框架总是依赖于某些构建步骤——否则，使用这些框架的网站和应用对开发者来说将非常不便编写。由于庞大的
    Node.js 生态系统似乎已经找到了一种适合重用的合适方法，这些新框架采用了这种方法，并将其作为其开发故事的一个组成部分。这样，使用 Node.js 成为了任何类型的前端项目的既定标准。
- en: Today, it is pretty much impossible to start a frontend development project
    without having Node.js installed. In this book, we’ll take the journey of learning
    about Node.js from the inside out together. We will not be focusing on writing
    server applications or walking over the integrated functionality of Node.js. Instead,
    we’ll look at how we – as frontend developers – can leverage the best that Node.js
    brings to the table.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎不可能开始一个前端开发项目而不安装 Node.js。在这本书中，我们将一起探索从内部学习 Node.js 的旅程。我们不会专注于编写服务器应用程序或探讨
    Node.js 的集成功能。相反，我们将探讨作为前端开发者，我们如何利用 Node.js 带来的最佳功能。
- en: In this first chapter, we discuss the internals of Node.js. This will help you
    understand how Node.js works and how you can actually use it. After this chapter,
    you will be able to run and debug simple scripts using the Node.js command-line
    application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将讨论 Node.js 的内部机制。这将帮助你理解 Node.js 的工作原理以及你如何实际使用它。在本章之后，你将能够使用 Node.js
    命令行应用程序运行和调试简单的脚本。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: Looking at the Node.js architecture in detail
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细了解 Node.js 架构
- en: Understanding the event loop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: Using Node.js from the command line
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行运行 Node.js
- en: CommonJS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the code samples in this book, you need knowledge of JavaScript and
    how to use the command line. You should have Node.js installed using the instructions
    at [https://nodejs.org](https://nodejs.org).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本书中的代码示例，你需要了解 JavaScript 和如何使用命令行。你应该已经按照 [https://nodejs.org](https://nodejs.org)
    上的说明安装了 Node.js。
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在 [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter01)
    获取。
- en: The Code in Action (CiA) videos for this chapter can be accessed at [http://bit.ly/3fPPdtb](http://bit.ly/3fPPdtb).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 Code in Action (CiA) 视频可在 [http://bit.ly/3fPPdtb](http://bit.ly/3fPPdtb)
    访问。
- en: Looking at the Node.js architecture in detail
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仔细查看 Node.js 架构
- en: 'The principal foundations of Node.js have been inspired by a few things:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的主要基础受到了一些事物的影响：
- en: The single worker thread featured in browsers was already quite successful in
    the server space. Here, the popular **nginx** web server showed that the event
    loop pattern (explained later in this chapter) was actually a blessing for performance
    – eliminating the need to use a dedicated thread pool for handling requests.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器中特有的单个工作线程在服务器空间中已经相当成功。在这里，流行的 **nginx** 网络服务器表明，事件循环模式（在本章后面解释）实际上对性能来说是一种祝福——消除了处理请求时需要使用专用线程池的需求。
- en: The idea of packaging everything in a file-centric structure called **modules**.
    This allowed Node.js to avoid many of the pitfalls of other languages and frameworks
    – including JavaScript in the browser.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容打包在一个以文件为中心的结构中称为 **模块** 的想法。这使 Node.js 避免了许多其他语言和框架的陷阱——包括浏览器中的 JavaScript。
- en: The idea of avoiding creating a huge framework and leaving everything extensible
    and easy to get via package managers.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免创建一个庞大的框架，并让所有内容都可通过包管理器扩展和轻松获取的想法。
- en: Threads
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线程
- en: Modern computers offer a lot of computing power. However, for an application
    to really use the available computing power, we need to have multiple things working
    in parallel. Modern operating systems know about different independently running
    tasks via so-called threads. A **thread** is a group of operations running sequentially,
    which means in a given order. The operating system then schedules when threads
    run and where (i.e., on which CPU core) they are placed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机提供了大量的计算能力。然而，为了使应用程序真正使用可用的计算能力，我们需要让多件事情并行工作。现代操作系统通过所谓的线程了解不同独立运行的任务。**线程**是一组按顺序运行的运算，这意味着按照一定的顺序。然后操作系统安排线程何时运行以及它们在哪里（即在哪个
    CPU 核心上）运行。
- en: These principles together form a platform that seems easy to create, but hard
    to replicate. After all, there are plenty of JavaScript engines and useful libraries
    available. For Ryan Dahl, the original creator and maintainer of Node.js, the
    basis of the framework had to be rock solid.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则共同构成一个看似容易创建但难以复制的平台。毕竟，有大量的 JavaScript 引擎和有用的库可用。对于 Node.js 的原始创建者和维护者
    Ryan Dahl 来说，框架的基础必须非常稳固。
- en: Ryan Dahl selected an existing JavaScript engine (**V8**) to take over the responsibility
    of parsing and running the code written in JavaScript. The V8 engine was chosen
    for two good reasons. On the one hand, the engine was available as an open source
    project under a permissive license – usable by projects such as Node.js. On the
    other hand, V8 was also the engine used by Google for its web browser **Chrome**.
    It is very fast, very reliable, and under active development.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Dahl 选择了一个现有的 JavaScript 引擎（**V8**）来接管解析和运行 JavaScript 代码的责任。选择 V8 引擎有两个很好的原因。一方面，该引擎作为一个开源项目，在宽松的许可证下可用——可以被
    Node.js 等项目使用。另一方面，V8 也是 Google 浏览器 **Chrome** 使用的引擎。它非常快，非常可靠，并且正在积极开发中。
- en: One of the drawbacks of using V8 is that it was written in C++ using custom-built
    tooling called **GYP**. While GYP was replaced in V8 years later, the transition
    was not so easy for Node.js. As of today, Node.js is still relying on GYP as a
    build system. The fact that V8 is written in C++ seems like a side note at first,
    but might be pretty important if you ever intend to write so-called **native modules**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 V8 的一个缺点是它是用 C++ 编写的，使用了名为 **GYP** 的自定义构建工具。虽然 GYP 在 V8 几年后被取代，但对于 Node.js
    来说，过渡并不容易。到目前为止，Node.js 仍然依赖于 GYP 作为构建系统。V8 是用 C++ 编写的这个事实最初可能像是一个旁注，但如果你想编写所谓的
    **原生模块**，它可能非常重要。
- en: Native modules allow you to go beyond JavaScript and Node.js – making full use
    of the available hardware and system capabilities. One drawback of native modules
    is that they must be built on each platform. This is against the **cross-platform**
    nature of Node.js.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 原生模块允许您超越 JavaScript 和 Node.js – 充分利用可用的硬件和系统功能。原生模块的一个缺点是它们必须在每个平台上构建。这与 Node.js
    的 **跨平台** 特性相矛盾。
- en: 'Let’s take a step back to arrange the parts mentioned so far in an architecture
    diagram. *Figure 1**.1* shows how Node.js is composed internally:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，将到目前为止提到的部分整理成一个架构图。*图 1.1* 展示了 Node.js 内部是如何组成的：
- en: '![Figure 1.1 – Internal composition of Node.js ](img/Figure_1.1_B18989.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Node.js 的内部组成](img/Figure_1.1_B18989.jpg)'
- en: Figure 1.1 – Internal composition of Node.js
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Node.js 的内部组成
- en: The most important component in Node.js’s architecture – besides the JavaScript
    engine – is the **libuv** library. libuv is a multi-platform, low-level library
    that provides support for asynchronous **input/output** (**I/O**) based on an
    **event loop**. I/O happens in multiple forms, such as writing files or handling
    **HTTP requests**. In general, I/O refers to anything that is handled in a dedicated
    area of the operating system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 的架构中，除了 JavaScript 引擎之外，最重要的组件是 **libuv** 库。libuv 是一个多平台、低级库，它基于 **事件循环**
    提供异步 **输入/输出**（**I/O**）支持。I/O 以多种形式发生，例如写入文件或处理 **HTTP 请求**。通常，I/O 指的是在操作系统的专用区域中处理的所有内容。
- en: Any application running Node.js is written in JavaScript or some flavor of it.
    When Node.js starts running the application, the JavaScript is parsed and evaluated
    by V8\. All the standard objects, such as `console`, expose some bindings that
    are part of the Node.js API. These low-level functions (such as `console.log`
    or `fetch`) make use of libuv. Therefore, some simple script that only works against
    language features such as primitive calculations (*2 + 3*) does not require anything
    from the Node API and will remain independent of libuv. In contrast, once a low-level
    function (for example, a function to access the network) is used, libuv can be
    the workforce behind it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 任何运行在 Node.js 上的应用程序都是用 JavaScript 或其某种变体编写的。当 Node.js 启动应用程序时，JavaScript 会被
    V8 解析和评估。所有标准对象，如 `console`，都暴露了一些作为 Node.js API 部分的绑定。这些底层函数（如 `console.log`
    或 `fetch`）使用了 libuv。因此，仅针对语言特性（如原始计算 *2 + 3*）的简单脚本不需要从 Node API 中获取任何内容，并将保持与
    libuv 独立。相反，一旦使用了底层函数（例如，用于访问网络的函数），libuv 就可能是其背后的劳动力。
- en: 'In *Figure 1**.2*, a block diagram illustrating the various API layers is shown.
    The beauty of this diagram is that it reveals what Node.js actually is: a JavaScript
    runtime allowing access to low-level functionality from state-of-the-art **C/C++**
    libraries. The Node.js API consists of the included Node.js bindings and some
    C/C++ addons:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 1.2* 中，展示了各种 API 层的框图。这个图的优点在于它揭示了 Node.js 实际上是什么：一个允许从最先进的 **C/C++** 库访问底层功能的
    JavaScript 运行时。Node.js API 由包含的 Node.js 绑定和一些 C/C++ 插件组成：
- en: '![Figure 1.2 – Composition of Node.js in terms of building blocks ](img/Figure_1.2_B18989.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 以构建块为单位的 Node.js 组成](img/Figure_1.2_B18989.jpg)'
- en: Figure 1.2 – Composition of Node.js in terms of building blocks
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 以构建块为单位的 Node.js 组成
- en: One thing that would need explanation in the preceding diagram is how the event
    loop is implemented in relation to all the blocks. When talking about Node.js’s
    internal architecture, a broader discussion of what an event loop is and why it
    matters for Node.js is definitely required. So let’s get into these details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中需要解释的一点是事件循环是如何与所有块相关联实现的。在谈论 Node.js 的内部架构时，对事件循环是什么以及为什么它对 Node.js 重要的更广泛讨论是绝对必要的。所以让我们深入了解这些细节。
- en: Understanding the event loop
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: An event loop is a runtime model that enables users to run all operations from
    a single thread – irrespective of whether the operations access long-running external
    resources or not. For this to work, the event loop needs to make requests to an
    event provider, which calls the specified event handlers. In Node.js, the libuv
    library is used for event loop implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是一种运行时模型，它使用户能够从单个线程运行所有操作 – 不论这些操作是否访问长时间运行的外部资源。为了实现这一点，事件循环需要向事件提供者发出请求，该提供者调用指定的事件处理器。在
    Node.js 中，libuv 库用于事件循环的实现。
- en: The reason for giving libuv the most space in *Figure 1**.1* is to highlight
    the importance of this library. Internally, libuv is used for everything regarding
    I/O, which arguably is the most crucial piece of any framework. I/O lets a framework
    communicate with other resources, such as files, servers, or databases. By default,
    dealing with I/O is done in a blocking manner. This means that the sequence of
    operations in our application is essentially stopped, waiting for the I/O operation
    to finish.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在图1.1中给libuv留出最多的空间是为了突出这个库的重要性。内部来说，libuv用于处理所有与I/O相关的事情，这可以说是任何框架中最关键的部分。I/O使框架能够与其他资源通信，例如文件、服务器或数据库。默认情况下，处理I/O是以阻塞方式进行的。这意味着我们应用程序的操作序列本质上被停止，等待I/O操作完成。
- en: Two strategies for mitigating the performance implications of blocking I/O exist.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种策略来减轻阻塞I/O的性能影响。
- en: The first strategy is to create new threads for actually performing these blocking
    I/O operations. Since a thread contains an independent group of operations, it
    can run concurrently, eventually not stopping the operations running in the original
    thread of the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略是为实际执行这些阻塞I/O操作创建新的线程。由于线程包含一个独立的操作组，它可以并发运行，最终不会停止应用程序原始线程中的操作。
- en: The second strategy is to not use **blocking I/O** at all. Instead, use an alternative
    variant, which is usually called non-blocking I/O or asynchronous I/O. **Non-blocking
    I/O** works with callbacks, that is, functions that are called under certain conditions
    – for instance when the I/O operation is finished. Node.js uses libuv to make
    extensive use of this second strategy. This allows Node.js to run all code in
    a single thread, while I/O operations run concurrently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种策略是完全不使用**阻塞I/O**。相反，使用一种替代变体，通常称为非阻塞I/O或异步I/O。**非阻塞I/O**与回调一起工作，即在某些条件下被调用的函数——例如，当I/O操作完成时。Node.js使用libuv来充分利用第二种策略。这允许Node.js在单个线程中运行所有代码，同时I/O操作并发运行。
- en: 'In *Figure 1**.3*, the building blocks of libuv are displayed. The key part
    is that libuv already comes with a lot of functionality to handle network I/O.
    Furthermore, file and DNS operations are also covered well:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在图1.3中，展示了libuv的构建块。关键部分是libuv已经包含了很多处理网络I/O的功能。此外，文件和DNS操作也得到了很好的覆盖：
- en: '![Figure 1.3 – Building blocks of libuv ](img/Figure_1.3_B18989.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – libuv的构建块](img/Figure_1.3_B18989.jpg)'
- en: Figure 1.3 – Building blocks of libuv
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – libuv的构建块
- en: In addition to the different I/O operations, the library comes with a set of
    different options for handling asynchronous user code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不同的I/O操作外，该库还提供了一套处理异步用户代码的不同选项。
- en: 'The event loop itself follows the **reactor design pattern**. Wikipedia describes
    the pattern as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环本身遵循**反应器设计模式**。维基百科对这种模式描述如下：
- en: The reactor design pattern is an event handling pattern for handling service
    requests delivered concurrently to a service handler by one or more inputs. The
    service handler then demultiplexes the incoming requests and dispatches them synchronously
    to the associated request handlers. (https://en.wikipedia.org/wiki/Reactor_pattern)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 反应器设计模式是一种事件处理模式，用于处理一个或多个输入并发地向服务处理程序提交的服务请求。然后，服务处理程序将传入的请求解复用，并将它们同步地调度到相关的请求处理程序。([https://en.wikipedia.org/wiki/Reactor_pattern](https://en.wikipedia.org/wiki/Reactor_pattern))
- en: Importantly, this definition mentions synchronous dispatch. This means that
    code that is run through the event loop is guaranteed to not run into any conflicts.
    The event loop makes sure that code is always run sequentially. Even though the
    I/O operations may concurrently run, our callbacks will never be invoked in parallel.
    From our perspective, even though Node.js will internally (through libuv) use
    multiple threads, the whole application is single-threaded.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这个定义提到了同步调度。这意味着通过事件循环运行的代码保证不会遇到任何冲突。事件循环确保代码总是顺序运行。尽管I/O操作可能并发运行，但我们的回调永远不会并行调用。从我们的角度来看，尽管Node.js会通过libuv内部使用多个线程，但整个应用程序是单线程的。
- en: 'The following is a simple script that shows you the basic behavior of the event
    loop at play – we’ll discuss how to run this in the *Using Node.js from the command*
    *line* section:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的脚本，展示了事件循环的基本行为——我们将在“从命令行使用Node.js”部分讨论如何运行此脚本：
- en: events.js
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: events.js
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will run this script in the next section when we learn about the command
    line usage of Node.js. In the meantime, put some thought into the preceding code
    and write down the order in which you’ll see the `console` output. Do you think
    it will print in an “`A` `B` `C` `D`” order, or something else?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在学习 Node.js 的命令行使用时运行此脚本。在此期间，请思考前面的代码，并写下您将看到的 `console` 输出的顺序。您认为它会按“`A`
    `B` `C` `D`”的顺序打印，还是其他顺序？
- en: 'The algorithm of the implementation of the event loop in libuv is displayed
    in *Figure 1**.4*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: libuv 中事件循环实现的算法显示在 *图 1.4* 中：
- en: '![Figure 1.4 – The implementation of the event loop in libuv ](img/Figure_1.4_B18989.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – libuv 中事件循环的实现](img/Figure_1.4_B18989.jpg)'
- en: Figure 1.4 – The implementation of the event loop in libuv
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – libuv 中事件循环的实现
- en: While the code snippet only deals with JavaScript-related constructs (such as
    `console`, `Promise`, and `setTimeout`), in general, the callbacks are associated
    with resources that go beyond Node.js, such as file system changes or network
    requests. Some of these resources may have an operating system equivalent; others
    only exist in form of blocking I/O.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码片段仅处理与 JavaScript 相关的结构（例如 `console`、`Promise` 和 `setTimeout`），但通常，回调函数与超出
    Node.js 范围的资源相关联，例如文件系统更改或网络请求。其中一些资源可能有操作系统等效项；而另一些则仅以阻塞 I/O 的形式存在。
- en: Consequently, the event loop implementation always considers its thread pool
    and polls for progressed I/O operations. Timers (such as `setTimeout` in the example
    script) are only run in the beginning. To know whether a timer needs to be run,
    its due time is compared with the current time. The current time is synced with
    the system time initially. If there is nothing to be done anymore (that is, no
    active timer, no resource waiting to finish, etc.), then the loop exits.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，事件循环实现始终考虑其线程池并轮询已完成的 I/O 操作。定时器（例如示例脚本中的 `setTimeout`）仅在开始时运行。要确定是否需要运行定时器，需要将其到期时间与当前时间进行比较。最初，当前时间与系统时间同步。如果没有其他事情要做（即没有活跃的定时器、没有等待完成的资源等），则循环退出。
- en: Let’s see how we can run Node.js to solidify our knowledge about the event loop.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何运行 Node.js 以巩固我们对事件循环的了解。
- en: Using Node.js from the command line
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行运行 Node.js
- en: Using JavaScript for a web application just requires you to open the website
    in a browser. The browser will evaluate the included JavaScript and run it. When
    you want to use JavaScript as a scripting language, you need to find a new way
    of running JavaScript. Node.js offers this new way – running JavaScript in a terminal,
    inside our computer, or from a server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 JavaScript 开发 Web 应用程序只需在浏览器中打开网站即可。浏览器将评估包含的 JavaScript 并运行它。当您想将 JavaScript
    作为脚本语言使用时，需要找到运行 JavaScript 的新方法。Node.js 提供了这种方法 – 在计算机终端、服务器上运行 JavaScript。
- en: 'When Node.js is installed, it comes with a set of command-line tools that will
    be available in the terminal of your choice. For this book, you’ll need to know
    about three different executables that we’ll use throughout the chapters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装 Node.js 时，它附带了一套可在您选择的终端中使用的命令行工具。对于本书，您需要了解我们将贯穿章节使用三个不同的可执行文件：
- en: '**node**: The main application to run a Node.js script'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**node**：运行 Node.js 脚本的主要应用程序'
- en: '**npm**: The default package manager – more on that later'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm**：默认的包管理器 – 关于这一点将在后面详细介绍'
- en: '**npx**: A very convenient utility to run npm binaries'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npx**：一个非常方便的实用工具，用于运行 npm 二进制文件'
- en: 'For now, we only need to know about `node`. If we want to run the `events.js`
    script from the previous section, we need to execute the following command in
    the directory in which the script (`events.js`) has been placed. You can place
    it there by just inserting the content from the previous `events.js` listing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要了解 `node`。如果我们想从上一节中运行 `events.js` 脚本，我们需要在放置脚本（`events.js`）的目录中执行以下命令。您可以通过仅插入上一节
    `events.js` 列表中的内容来放置它：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command is shown after the conventional `$` sign indicating the command
    prompt. The output of running the script is shown below the `node` `events.js`
    command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令显示在传统的 `$` 符号之后，表示命令提示符。运行脚本的输出显示在 `node` `events.js` 命令下方。
- en: As you can see, the order is “`A` `D` `C` `B`” – that is, Node.js first handled
    all the sequential operations before the callbacks of the promise were handled.
    Finally, the timeout callback was handled.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，顺序是“`A` `D` `C` `B`” – 即 Node.js 首先处理所有顺序操作，然后再处理 promise 的回调函数。最后，处理超时回调函数。
- en: The reason for handling the promise callback before the timeout callback lies
    in the event loop. In JavaScript, promises spawn so-called micro tasks, which
    are placed in the pending callback section of the libuv event loop from *Figure
    1**.4*. The timeout callback, however, is treated like a full task. The difference
    between them lies within the event loop. Micro tasks are placed in an optimized
    queue that is actually peeked multiple times per event loop iteration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件循环中处理超时回调之前处理承诺回调的原因在于事件循环。在 JavaScript 中，承诺产生所谓的微任务，这些微任务被放置在 libuv 事件循环的挂起回调部分，如图
    1.4* 所示。然而，超时回调被当作一个完整任务处理。它们之间的区别在于事件循环中。微任务被放置在一个优化的队列中，实际上在每个事件循环迭代中都会被多次查看。
- en: According to libuv, the timeout callback can only be run when its timer is due.
    Since we only placed it in the event loop during the idle handles (i.e., main
    section) of the event loop, we need to wait until the next iteration of the event
    loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 libuv，超时回调只能在定时器到期时运行。由于我们只在事件循环的空闲处理（即主部分）中放置了它，我们需要等待事件循环的下一迭代。
- en: 'The `node` command-line application can also receive additional parameters.
    The official documentation goes into all details ([https://nodejs.org/api/cli.html](https://nodejs.org/api/cli.html)).
    A helpful one is `-e` (short version of `--eval`) to just evaluate a script directly
    from the command-line input without requiring a file to run:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`node` 命令行应用程序也可以接收额外的参数。官方文档详细介绍了所有细节（[https://nodejs.org/api/cli.html](https://nodejs.org/api/cli.html)）。其中一个有用的参数是
    `-e`（`--eval` 的简写），可以直接从命令行输入评估脚本，而无需文件运行：'
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another very helpful command line flag is `--inspect`. This opens the standard
    port for graphical inspection, for example, via the Chrome web browser.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的命令行标志是 `--inspect`。这打开了标准端口以进行图形检查，例如，通过 Chrome 网络浏览器。
- en: 'Let’s run an application with a bit of continuous logic to justify an inspection
    session. In the terminal on your machine, run the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个带有一些连续逻辑的应用程序，以证明检查会话的合理性。在您的机器上的终端中运行以下命令：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we can run a graphical application. Let’s use the Chrome web browser. Open
    it and go to [chrome://inspect](https://chrome://inspect). This is a special Chrome-internal
    URL that allows us to see the available targets.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行一个图形应用程序。让我们使用 Chrome 网络浏览器。打开它并转到 [chrome://inspect](https://chrome://inspect)。这是一个特殊的
    Chrome 内部 URL，允许我们查看可用的目标。
- en: 'The following figure (*Figure 1**.5*) shows how inspecting the Node.js application
    in the Chrome web browser may look:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图（*图 1.5*）显示了在 Chrome 网络浏览器中检查 Node.js 应用程序可能的样子：
- en: '![Figure 1.5 – Inspecting the Node.js application in the Chrome web browser
    ](img/Figure_1.5_B18989.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 在 Chrome 网络浏览器中检查 Node.js 应用程序](img/Figure_1.5_B18989.jpg)'
- en: Figure 1.5 – Inspecting the Node.js application in the Chrome web browser
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 在 Chrome 网络浏览器中检查 Node.js 应用程序
- en: In this case, Chrome detected our application with the process ID `3420` running.
    On your machine, the process ID will most likely be different. No filename was
    given, as we started with the `-e` command-line option.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Chrome 识别到我们的应用程序正在以进程 ID `3420` 运行。在你的机器上，进程 ID 很可能不同。没有给出文件名，因为我们是以
    `-e` 命令行选项开始的。
- en: When you click on `console` output that you see in the command line.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行中点击看到的 `console` 输出时。
- en: When you follow the link to the evaluated script from the DevTools console,
    you’ll get the ability to place **breakpoints** or pause the execution. Pausing
    the execution may not work immediately, as an active JavaScript operation is required
    for that.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从 DevTools 控制台跟随到评估脚本的链接时，你将能够放置 **断点** 或暂停执行。暂停执行可能不会立即工作，因为这需要一个活动的 JavaScript
    操作。
- en: 'In *Figure 1**.6*, you see how debugging a Node.js script in the Chrome DevTools
    can look:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 1.6* 中，你可以看到在 Chrome DevTools 中调试 Node.js 脚本的样子：
- en: '![Figure 1.6 – Debugging a Node.js script in the Chrome DevTools ](img/Figure_1.6_B18989.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 在 Chrome DevTools 中调试 Node.js 脚本](img/Figure_1.6_B18989.jpg)'
- en: Figure 1.6 – Debugging a Node.js script in the Chrome DevTools
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 在 Chrome DevTools 中调试 Node.js 脚本
- en: In the preceding example, JavaScript is only run every minute. When the pause
    occurs, you should end up in the `internal/timers.js` part of Node.js itself.
    This is a different JavaScript file, but it’s part of the whole Node.js framework.
    The file can be integrated because it follows certain conventions and rules that
    are known as CommonJS.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，JavaScript 只每分钟运行一次。当发生暂停时，你应该最终进入 Node.js 本身的 `internal/timers.js`
    部分。这是一个不同的 JavaScript 文件，但它属于整个 Node.js 框架的一部分。该文件可以集成，因为它遵循某些称为 CommonJS 的约定和规则。
- en: CommonJS
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS
- en: One thing that Node.js got right from the beginning was to introduce an explicit
    way of obtaining and using functionality. JavaScript in the browser suffered from
    the *global scope* problem, which caused many headaches for developers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 从一开始就做得正确的一件事是引入了一种明确获取和使用功能的方式。浏览器中的 JavaScript 患有 **全局作用域** 问题，这给开发者带来了许多麻烦。
- en: Global scope
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 全局作用域
- en: In JavaScript, the global scope refers to functionality that is accessible from
    every script running in the same application. On a website, the global scope is
    usually the same as the `window` variable. Attaching variables to the global scope
    may be convenient and sometimes even necessary, but it may also lead to conflicts.
    For instance, two independent functions could both try to write and read from
    the same variable. The resulting behavior can then be hard to debug and very tricky
    to resolve. The standard recommendation is to avoid using the global scope as
    much as possible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，全局作用域指的是可以从同一应用程序中运行的任何脚本访问的功能。在一个网站上，全局作用域通常与 `window` 变量相同。将变量附加到全局作用域可能很方便，有时甚至必要，但它也可能导致冲突。例如，两个独立的函数都可能尝试从同一变量中写入和读取。结果的行为可能很难调试，并且非常难以解决。标准建议是尽可能避免使用全局作用域。
- en: The idea that other functionalities are explicitly imported was certainly not
    new when Node.js was introduced. While an import mechanism existed in other programming
    languages or frameworks for quite some time, similar options have also been available
    for JavaScript in the browser – via third-party libraries such as **RequireJS**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Node.js 介绍时，其他功能明确导入的想法当然并不新鲜。虽然其他编程语言或框架中存在导入机制已有很长时间，但类似选项也已在浏览器中的 JavaScript
    中可用——通过第三方库如 **RequireJS**。
- en: Node.js introduced its **module system** with the name **CommonJS**. The basis
    for Node.js’s implementation was actually a project developed at Mozilla. In that
    project, Mozilla worked on a range of proposals that started with non-browser
    use but later on expanded to a generic set of JavaScript specifications for a
    module system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 以 **CommonJS** 的名称引入了其 **模块系统**。Node.js 实现的基础实际上是一个在 Mozilla 开发的项目。在那个项目中，Mozilla
    一直在研究一系列提案，最初是针对非浏览器使用，但后来扩展到了一个通用的 JavaScript 模块系统规范集。
- en: CommonJS implementations
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 实现
- en: Besides the implementation in Node.js, many other runtimes or frameworks use
    CommonJS. As an example, the JavaScript that can be used in the **MongoDB** database
    leverages a module system using the CommonJS specifications. The implementation
    in Node.js is actually only partially fulfilling the full specification.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 Node.js 中的实现，许多其他运行时或框架也使用 CommonJS。例如，可以在 **MongoDB** 数据库中使用的 JavaScript
    利用的是基于 CommonJS 规范的模块系统。Node.js 中的实现实际上只是部分满足完整规范。
- en: 'A module system is crucial for allowing the inclusion of more functionality
    in a very transparent and explicit manner. In addition to a set of more advanced
    functionality, a module system gives us the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统对于以非常透明和明确的方式包含更多功能至关重要。除了更多高级功能之外，模块系统还给我们以下功能：
- en: A way of including more functionality (in CommonJS, via the global `require`
    function)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种包含更多功能的方式（在 CommonJS 中，通过全局 `require` 函数）
- en: A way of exposing functionality, which can then be included somewhere else (in
    CommonJS, via the module-specific `module` or `exports` variables)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种暴露功能的方式，然后可以在其他地方包含它（在 CommonJS 中，通过模块特定的 `module` 或 `exports` 变量）
- en: 'At its core, the way CommonJS works is quite simple. Imagine you have a file
    called `a.js`, which contains the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 的工作方式在本质上非常简单。想象你有一个名为 `a.js` 的文件，其中包含以下代码：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the job of Node.js would be to actually make this work, that is, give the
    `b` variable a value that represents the so-called exports of the module. Right
    now, the script would error out saying that a `b.js` file is missing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Node.js 的任务就是真正使这个工作得以实现，也就是说，给 `b` 变量赋予一个代表模块所谓导出的值。目前，脚本会报错说缺少 `b.js` 文件。
- en: 'The `b.js` file, which should be adjacent to `a.js`, reads as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`b.js` 文件，它应该与 `a.js` 邻近，内容如下：'
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When Node.js evaluates the file, it will remember the defined exports. In this
    case, Node.js will know that `b.js` is actually just an object with a `myValue`
    key with a value of `42`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Node.js 评估文件时，它会记住定义的导出。在这种情况下，Node.js 会知道 `b.js` 实际上只是一个具有 `myValue` 键，值为
    `42` 的对象。
- en: 'From the perspective of `a.js`, the code can therefore be read like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `a.js` 的角度来看，代码可以读作如下：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The advantage of using the module system is that there is no need to write the
    outputs of the module again. The call to `require` does that for us.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块系统的优势是不需要再次编写模块的输出。`require`调用为我们做了这件事。
- en: Side effects
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用
- en: Replacing the call to `require` with the module’s outputs is only meant for
    illustrative purposes. In general, this cannot be done as the module evaluation
    can have some so-called side effects. A `require` call with the imported module’s
    exports, we would not run the side effects, which would miss a crucial aspect
    of the module.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 用模块的输出替换`require`调用只是为了说明目的。通常情况下，这是不可能的，因为模块评估可能会有一些所谓的副作用。如果我们用导入模块的导出进行`require`调用，我们不会运行副作用，这会错过模块的一个关键方面。
- en: 'In the given example, we used the name of the file directly, but importing
    a module can be more subtle than that. Let’s see a refined version of the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的例子中，我们直接使用了文件名，但导入模块可能比这更微妙。让我们看看代码的改进版本：
- en: a.js
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: a.js
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The call to`./b.js` has been replaced by `./b`. This will still work, as Node.js
    will try various combinations for the given import. Not only will it append certain
    known extensions (such as `.js`) but it will also look at whether `b` is actually
    a directory with an `index.js` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`./b.js`的调用已被替换为`./b`。这仍然会工作，因为Node.js会尝试给定的导入的各种组合。它不仅会附加某些已知的扩展名（如`.js`），还会检查`b`是否实际上是一个包含`index.js`文件的目录。'
- en: Therefore, with the preceding code, we could actually move `b.js` from a file
    adjacent to `a.js` to an `index.js` file in the adjacent directory, `b`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据前面的代码，我们实际上可以将`b.js`从`a.js`相邻的文件移动到相邻目录`b`中的`index.js`文件。
- en: The greatest advantage, however, is that this syntax also allows us to import
    functionality from third-party packages. As we will explore later in [*Chapter
    2*](B18989_02.xhtml#_idTextAnchor023), *Dividing Code into Modules and Packages*,
    our code has to be divided into different modules and packages. A **package**
    contains a set of reusable modules.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最大的优势是这种语法还允许我们从第三方包中导入功能。正如我们将在[*第2章*](B18989_02.xhtml#_idTextAnchor023)中探讨的，*将代码划分为模块和包*，我们的代码必须划分为不同的模块和包。一个**包**包含一组可重用的模块。
- en: 'Node.js already comes with a set of packages that don’t even need to be installed.
    Let’s see a simple example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js自带了一组不需要安装的包。让我们看看一个简单的例子：
- en: host.js
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: host.js
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example uses the integrated `os` package to obtain the current
    computer’s network name.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了集成的`os`包来获取当前计算机的网络名称。
- en: 'We can run this script with `node` in the command line:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在命令行中使用`node`运行这个脚本：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This script works on every computer that has Node.js installed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本在安装了Node.js的任何计算机上都能工作。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered Node.js for the first time. You should now have
    a good idea of the core principles (such as event loop, threads, modules, and
    packages) upon which Node.js was built. You have read a bit about Node.js’s history
    and why V8 was chosen as the JavaScript engine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首次了解了Node.js。你现在应该对Node.js构建的核心原则（如事件循环、线程、模块和包）有一个很好的了解。你已经了解了一些关于Node.js的历史以及为什么选择V8作为JavaScript引擎的原因。
- en: One of the key things to take away from this chapter is how the event loop works.
    Note that part of this knowledge is not exclusive to Node.js. The distinction
    between micro tasks and tasks is an integral part of how JavaScript engines, even
    the JavaScript engine of your browser, work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中我们可以学到的一个重要内容是如何事件循环工作。请注意，这部分知识并不局限于Node.js。微任务和任务之间的区别是JavaScript引擎（甚至是你浏览器的JavaScript引擎）工作方式的一个基本组成部分。
- en: Lastly, you are now equipped to use the `node` command-line application, for
    example, to run or debug simple scripts, which can export and import functionality
    using the CommonJS module system. You learned how to use the Chrome web browser
    to inspect Node.js scripts as you can with websites.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你现在已经准备好使用`node`命令行应用程序了，例如，运行或调试简单的脚本，这些脚本可以使用CommonJS模块系统导出和导入功能。你学习了如何使用Chrome网络浏览器检查Node.js脚本，就像检查网站一样。
- en: In the next chapter, we will increase our knowledge about CommonJS by learning
    how we can efficiently divide code into modules and packages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习如何高效地将代码划分为模块和包来增加我们对CommonJS的了解。
