<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Testing React Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Testing React Applications</h1></div></div></div><p>As a web developer, you are familiar with the way most websites are built today. There is usually a web server (in languages such as Java, Ruby, or PHP) that processes user requests and responds with markup (HTML).</p><p>This means that on every request, the web server interprets the user action through the URL and renders the entire page.</p><p>In an attempt to improve the user experience, more and more functionality started to get pushed from the server side to the client side, and JavaScript was no longer simply adding behavior to the page but was rendering it entirely. The biggest advantage was that a user action was no longer triggering a whole page refresh; the JavaScript code could deal with the entire browser document and mutate it accordingly.</p><p>Although this did improve the user experience, it started to add a lot of complexity to the application code, which led to increased maintenance costs and the worst—bugs in the form of inconsistencies between different parts of the screen.</p><p>In an attempt to bring sanity to this scenario, a number of libraries and frameworks were built, but they all failed in the sense that they didn't tackle the root cause of the entire problem—mutability.</p><p>Server-side rendering was easy because there was no mutation to deal with. Given a new application state, the server would simply render everything again. What if we could get benefits from this approach in our client-side JavaScript code?</p><p>That is exactly what <span class="strong"><strong>React</strong></span><a id="id200" class="indexterm"/> proposes to do. You declaratively write the interface code in the form of components and tell React to render. On any change of the application state, you can simply tell React to re-render again; it will then calculate the mutations required to move the DOM to the required state and apply them for you.</p><p>During this chapter, we are going to understand how React works by refactoring the code we've built so far into an SPA.</p><div class="section" title="Project setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Project setup</h1></div></div></div><p>However, before we can dive<a id="id201" class="indexterm"/> into React, first we need a small setup in our project to <a id="id202" class="indexterm"/>allow us to create React components.</p><p>Go to <a class="ulink" href="http://facebook.github.io/react/downloads.html">http://facebook.github.io/react/downloads.html</a> and download the React Starter Kit Version 0.12.2<a id="id203" class="indexterm"/> or higher.</p><p>After the download, you can unpack its contents and move all the files from within the build folder to our application's lib folder. Then, just load the React library onto the <code class="literal">SpecRunner.html</code> file.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;script src="lib/react-with-addons.js"&gt;&lt;/script&gt;</strong></span>
&lt;script src="lib/jquery.js"&gt;&lt;/script&gt;</pre></div><p>With the setup complete, we can move on to writing our very first component.</p></div></div>
<div class="section" title="Our first React component"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Our first React component</h1></div></div></div><p>As stated in the introduction of this chapter, with <a id="id204" class="indexterm"/>React, you declaratively write the interface code through components.</p><p>The concept of a React component is analogous to the component concept presented in <a class="link" href="ch03.html" title="Chapter 3. Testing Frontend Code">Chapter 3</a>, <span class="emphasis"><em>Testing Frontend Code</em></span>, so expect to see some similarities next.</p><p>With that in mind, let's create our very first component. To better understand what a React component is, we are going to use a very simple acceptance criterion and as usual start from the spec.</p><p>Let's implement "InvestmentListItem should render". It's very simple and not really <span class="emphasis"><em>feature oriented</em></span> but is a good example to get us started.</p><p>With what we learned in <a class="link" href="ch03.html" title="Chapter 3. Testing Frontend Code">Chapter 3</a>, <span class="emphasis"><em>Testing Frontend Code</em></span>, we could start coding this spec by creating a new file called <code class="literal">InvestmentListItemSpec.js</code> and save it in the <code class="literal">components</code> folder inside the <code class="literal">spec</code> folder:</p><div class="informalexample"><pre class="programlisting">describe("InvestmentListItem", function() {

  beforeEach(function() {
    // render the React component
  });

<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>it("should render", function() {</strong></span>
<span class="strong"><strong>    expect(component.$el).toEqual('li.investment-list-item');</strong></span>
<span class="strong"><strong>  });</strong></span>
});</pre></div><p>Add the new file to the <code class="literal">SpecRunner.html</code> file, as already demonstrated in previous chapters.</p><p>At the spec, we are basically using the <code class="literal">jasmine-jquery</code> plugin to expect that the encapsulated DOM element of our component is equal to a specific CSS selector.</p><p>How would we change this example to be a test of a React component? The only difference is the API to get the DOM node. Instead of <code class="literal">$element</code> with a jQuery object, React exposes a function called <code class="literal">getDOMNode()</code> that returns what it states—a DOM node.</p><p>With that, we can use the <a id="id205" class="indexterm"/>same assertion as before and have our test ready, as follows:</p><div class="informalexample"><pre class="programlisting">it("should render", function() {
  expect(component.<span class="strong"><strong>getDOMNode()</strong></span>).toEqual('li.investment-list-item');
});</pre></div><p>That was easy! So, the next step is to create the component, render it, and attach it to the document. That is simple as well; take a look at the following gist:</p><div class="informalexample"><pre class="programlisting">describe("InvestmentListItem", function() {
  var component;

  beforeEach(function() {
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong> setFixtures('&lt;div id="application-container"&gt;&lt;/div&gt;');</strong></span>
<span class="strong"><strong>    var container = document.getElementById('application-container');</strong></span>

<span class="strong"><strong>    var element = React.createElement(InvestmentListItem);</strong></span>
<span class="strong"><strong>    component = React.render(element, container);</strong></span>
  });

  it("should render", function() {
    expect(component.getDOMNode()).toEqual('li.investment-list-item');
  });
});</pre></div><p>It might seem like a lot of code, but half of it is just boilerplate to set up a document element fixture that we can render the React component in:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we use the <code class="literal">setFixtures</code> function from <code class="literal">jasmine-jquery</code> to create an element in the document with the <code class="literal">application-container</code> ID. Then, using the <code class="literal">getElementById</code> API, we query for this element and save it in the <code class="literal">container</code> variable. The next two steps are the ones specific to React:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, in order to use a component, we must first create an element from its class; this is done through the <code class="literal">React.createElement</code> function, as follows:<div class="informalexample"><pre class="programlisting">var element = <span class="strong"><strong>React.createElement</strong></span>(InvestmentListItem);</pre></div></li><li class="listitem">Next, with the element instance, we can finally tell React to render it through the <code class="literal">React.render</code> function, as follows:<div class="informalexample"><pre class="programlisting">component = <span class="strong"><strong>React.render</strong></span>(element, container);</pre></div></li><li class="listitem">The <code class="literal">render</code> function accepts the following two parameters:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The React element</li><li class="listitem" style="list-style-type: disc">A DOM node to render the element in</li></ul></div></li></ol></div></li><li class="listitem">As of now, the <a id="id206" class="indexterm"/>spec is complete. You can run it and see it fail, showing the following error:<div class="informalexample"><pre class="programlisting">
<code class="literal">ReferenceError: InvestmentListItem is not defined</code>.</pre></div></li><li class="listitem">The next step is to code the component. So, let's feed the spec, create a new file in the <code class="literal">src</code> folder, name it<code class="literal"> InvestmentListItem.js</code>, and add it to the spec runner. This file should follow the module pattern we've been using until now.</li><li class="listitem">Then, create a new class of component using the <code class="literal">React.createClass</code> method:<div class="informalexample"><pre class="programlisting">(function (React) {
  var InvestmentListItem = <span class="strong"><strong>React.createClass</strong></span>({
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>render</strong></span>: function () {
      return React.createElement('li', { className: 'investment-list-item' }, 'Investment');
    }
  });

  this.InvestmentListItem = InvestmentListItem;
})(React);</pre></div></li><li class="listitem">At the least, the <code class="literal">React.createClass</code> method expects a single <code class="literal">render</code> function that should return a tree of React elements.</li><li class="listitem">We use again the <code class="literal">React.createElement</code> method to create the element that is going to be the root of the rendering tree, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>React.createElement</strong></span>('li', { className: 'investment-list-item' }, 'Investment')</pre></div></li></ol></div><p>The difference from its previous usage in the <code class="literal">beforeEach</code> block is that here, it is also passing a list of <a id="id207" class="indexterm"/>
<span class="strong"><strong>props</strong></span> (with <code class="literal">className</code>) and a single child containing the text <code class="literal">Investment</code>.</p><p>We will get deeper into the meaning of the props parameter, but you can think of it as analogous to the attributes of an HTML DOM element. The <code class="literal">className</code> prop will turn into the class HTML attribute of the <code class="literal">li</code> element.</p><p>The <code class="literal">React.createElement</code> method signature accepts three arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The type of the component that can be either a string representing a real DOM element (such as <code class="literal">div</code>, <code class="literal">h1</code>, <code class="literal">p</code>) or a React component class</li><li class="listitem" style="list-style-type: disc">An object containing the props values</li><li class="listitem" style="list-style-type: disc">And a variable number of children components, which in this case, is just the <code class="literal">Investment</code> string</li></ul></div><p>On rendering this<a id="id208" class="indexterm"/> component (by invoking the <code class="literal">React.render()</code> method), the result will be:</p><div class="informalexample"><pre class="programlisting">&lt;li class="investment-list-item"&gt;Investment&lt;/li&gt;</pre></div><p>This is a direct representation of the JavaScript code that generated it:</p><div class="informalexample"><pre class="programlisting">React.createElement('li', { className: 'investment-list-item' }, 'Investment');</pre></div><p>Congratulations! You've built your first fully tested React component.</p></div>
<div class="section" title="The Virtual DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>The Virtual DOM</h1></div></div></div><p>When you define a component's render<a id="id209" class="indexterm"/> method and invoke the <code class="literal">React.createElement</code> method, you are not actually rendering anything in the document (you are not even creating DOM elements).</p><p>It is only through the <code class="literal">React.render</code> function that the representation created by invoking these <code class="literal">React.createElement</code> calls are effectively converted into real DOM elements and attached to the document.</p><p>This representation, defined by <code class="literal">ReactElements</code>, is what React calls the Virtual DOM. And <code class="literal">ReactElement</code> must not be confused with DOM elements; it is instead a light, stateless, immutable, virtual representation of a DOM element.</p><p>So why did React get into the trouble of creating a new way of representing the DOM? The answer here is <span class="emphasis"><em>performance</em></span>.</p><p>As browsers evolved, JavaScript performance kept getting better and better, and today's application bottlenecks aren't actually JavaScript. You've probably heard that you should try touching the DOM as little as possible, and React allows you to do that by letting you interact with its own version of the DOM.</p><p>However, that is not the only reason. React has built a very powerful diffing algorithm that can compare two distinct representations of the Virtual DOM, compute their differences, and with that information, create mutations that then get applied to the real DOM.</p><p>It allows us to get back to the flow we used to have with server-side rendering. We can basically, on any change of the application state, ask React to re-render everything, and it will then compute the minimal number of changes required and apply only that to the real DOM.</p><p>It frees us developers from<a id="id210" class="indexterm"/> worrying about mutating the DOM and empowers us to write our user interfaces in a declarative way, while reducing bugs and improving productivity.</p></div>
<div class="section" title="JSX"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>JSX</h1></div></div></div><p>If you have any experience writing frontend <a id="id211" class="indexterm"/>JavaScript applications, you might be familiar with a few template languages. At this moment, you might be wondering where can you use your favorite template language (such as Handlebars) with React. And the answer is that you can't.</p><p>React doesn't make any distinction between markup and logic; in a React component, they are effectively the same.</p><p>However, what happens when we start crafting more complicated components? How would the form we built in <a class="link" href="ch03.html" title="Chapter 3. Testing Frontend Code">Chapter 3</a>, <span class="emphasis"><em>Testing Frontend Code</em></span>, translate into a React component?</p><p>To just render it without any other logic, it would take a bunch of <code class="literal">React.createElement</code> calls, as follows:</p><div class="informalexample"><pre class="programlisting">var NewInvestment = React.createClass({
  render: function () {
    return React.createElement("form", {className: "new-investment"},
      React.createElement("h1", null, "New investment"),
      React.createElement("label", null,
        "Symbol:",
        React.createElement("input", {type: "text", className: "new-investment-stock-symbol", maxLength: "4"})
      ),
      React.createElement("label", null,
        "Shares:",
        React.createElement("input", {type: "number", className: "new-investment-shares"})
      ),
      React.createElement("label", null,
        "Share price:",
        React.createElement("input", {type: "number", className: "new-investment-share-price"})
      ),
      React.createElement("input", {type: "submit", className: "new-investment-submit", value: "Add"})
    );
  }
});</pre></div><p>This is very verbose and hard to read. So, given that a React component is both markup and logic, wouldn't it be better if we could write it as a mixture of HTML and JavaScript? Here's how:</p><div class="informalexample"><pre class="programlisting">var NewInvestment = React.createClass({
  render: function () {
    return &lt;form className="new-investment"&gt;
      &lt;h1&gt;New investment&lt;/h1&gt;
      &lt;label&gt;
        Symbol:
        &lt;input type="text" className="new-investment-stock-symbol" maxLength="4" /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Shares:
        &lt;input type="number" className="new-investment-shares" /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Share price:
        &lt;input type="number" className="new-investment-share-price" /&gt;
      &lt;/label&gt;
      &lt;input type="submit" className="new-investment-submit" value="Add" /&gt;
    &lt;/form&gt;;
  }
});</pre></div><p>That is <span class="strong"><strong>JSX</strong></span>, a <a id="id212" class="indexterm"/>JavaScript syntax extension that looks like XML and was built to be used with React.</p><p>It transforms into JavaScript, so given the latter example, it would compile directly to the plain JavaScript code presented before.</p><p>An important feature of the transformation process is that it doesn't change the line numbers; so, <span class="emphasis"><em>line 10</em></span> in the JSX will translate into <span class="emphasis"><em>line 10</em></span> in the transformed JavaScript file. This helps while debugging the code and doing static code analysis.</p><p>For more information about the language, you<a id="id213" class="indexterm"/> can check the official specification at <a class="ulink" href="http://facebook.github.io/jsx/">http://facebook.github.io/jsx/</a>, but for now, you can just follow the next examples as we dive into the features of this language.</p><p>It is important to know that it is not a requirement to use JSX while implementing React components, but it makes the process a lot easier. With that in mind, we are going to keep using it for now.</p><div class="section" title="Using JSX with Jasmine"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec28"/>Using JSX with Jasmine</h2></div></div></div><p>In order for us to use JSX<a id="id214" class="indexterm"/> with our Jasmine runner, there are a few changes we <a id="id215" class="indexterm"/>need to make.</p><p>First, we need to rename the files with which we want to use the JSX syntax to <code class="literal">.jsx</code>. Although this is not a requirement, it allows us to easily identify when a file is using this special syntax.</p><p>Next, on the <code class="literal">SpecRunner.html</code> file, we need to change the script tags to indicate that these are not regular JavaScript files, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="src/components/InvestmentListItem<span class="strong"><strong>.jsx</strong></span>" <span class="strong"><strong>type="text/jsx"</strong></span>&gt;&lt;/script&gt;
&lt;script src="spec/components/InvestmentListItemSpec<span class="strong"><strong>.jsx</strong></span>" <span class="strong"><strong>type="text/jsx"</strong></span>&gt;&lt;/script&gt;</pre></div><p>Unfortunately, these are not the only changes we need to make. The browser doesn't understand JSX syntax, so we need to load a special transformer that will first transform these files into regular JavaScript.</p><p>This transformer comes bundled in the React starter kit, so just load it right after loading React, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="lib/react-with-addons.js"&gt;&lt;/script&gt;
<span class="strong"><strong>&lt;script src="lib/JSXTransformer.js"&gt;&lt;/script&gt;</strong></span>
</pre></div><p>With this setup done, we should be able to run the tests, shouldn't we? Unfortunately, there is one more step.</p><p>If you try to open the <code class="literal">SpecRunner.html</code> file in the browser, you will see that the tests of <code class="literal">InvestmentListItem</code> are not being executed. That is because the transformer works by loading the script files through AJAX, transforming them and finally attaching them to the DOM. By the time this process is complete, Jasmine has already run the tests.</p><p>We need a way to inform Jasmine to wait for these files to load and be transformed.</p><p>The simplest way to do that is to change Jasmine's <code class="literal">boot.js</code> file placed in the <code class="literal">jasmine-2.1.3</code> folder, inside the <code class="literal">lib</code> folder.</p><p>In the original file, you are going to need to find the line that contains the <code class="literal">env.execute();</code> method and comment it out. It should be something like the following code:</p><div class="informalexample"><pre class="programlisting">window.onload = function() {
  if (currentWindowOnload) {
    currentWindowOnload();
  }
  htmlReporter.initialize();

<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>// delays execution so that JSX files can be loaded</strong></span>
<span class="strong"><strong>  // env.execute();</strong></span>
};</pre></div><p>Everything else in the<a id="id216" class="indexterm"/> file should remain the same. After this change, you<a id="id217" class="indexterm"/> will see that the tests are no longer running—none of them.</p><p>The only missing piece is invoking this <code class="literal">execute</code> method once the JSX files are loaded. To do so, we are going to create a new file called <code class="literal">boot-exec.js</code> inside the <code class="literal">jasmine.2.1.3</code> folder with the following content:</p><div class="informalexample"><pre class="programlisting">/**
  Custom boot file that actually runs the tests.
  The code below was extracted and commented out from the original boot.js file.
 */
(function() {

  var env = jasmine.getEnv();
  env.execute();

}());</pre></div><p>As you see, it is only executing the previously commented code from the original boot file.</p><p>To run this custom boot is very simple. We add it to the last line of the <code class="literal">&lt;head&gt;</code> tag of <code class="literal">SpecRunner.html</code> as a JSX type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>&lt;!-- After all JSX files were loaded and processed, the tests can finally run --&gt;</strong></span>
<span class="strong"><strong>  &lt;script src="lib/jasmine-2.1.3/boot-exec.js" type="text/jsx"&gt;&lt;/script&gt;</strong></span>

&lt;/head&gt;</pre></div><p>The <code class="literal">JSXTransformer</code> library guarantees that the scripts are loaded in the order they are declared. So, by the time the <code class="literal">boot-exec.js</code> file is loaded, the source and test files are already loaded.</p><p>With that, our test runner now supports JSX.</p></div></div>
<div class="section" title="Component attributes (props)"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Component attributes (props)</h1></div></div></div><p>Props<a id="id218" class="indexterm"/> are the way to<a id="id219" class="indexterm"/> pass down data from a parent to a child component in <a id="id220" class="indexterm"/>React.</p><p>For this next example, we want to change the <code class="literal">InvestmentListItem</code> component to render the value of the <code class="literal">roi</code> variable formatted in percentage.</p><p>To implement the next specs, we are going to use a few helper methods that React offers through the <code class="literal">React.addons.TestUtils</code> object, as follows:</p><div class="informalexample"><pre class="programlisting">describe("InvestmentListItem", function() {
  var TestUtils = React.addons.TestUtils;

  describe("given an Investment", function() {
    var investment, component;

    beforeEach(function() {
      investment = new Investment({
        stock: new Stock({ symbol: 'peto', sharePrice: 0.25 }),
        shares: 100,
        sharePrice: 0.20
      });

      component = <span class="strong"><strong>TestUtils.renderIntoDocument</strong></span>(
        &lt;InvestmentListItem investment={investment}/&gt;
      );
    });

    it("should render the return of investment as a percentage", function() {
      var roi = <span class="strong"><strong>TestUtils.findRenderedDOMComponentWithClass</strong></span>(component, 'roi');
      expect(roi.getDOMNode()).toHaveText('25%');
    });
  });
});</pre></div><p>As you can see, we are no longer using the <code class="literal">setFixture</code> method from the <code class="literal">jasmine-jquery</code> matcher. Instead, we are using the <code class="literal">TestUtils</code> module to render the component.</p><p>The biggest difference here is that <code class="literal">TestUtils.renderIntoDocument</code> doesn't actually render in the document, but it renders into a detached node.</p><p>The next thing you will notice is that the <code class="literal">InvestmentListItem</code> component has an attribute (actually called <span class="strong"><strong>prop</strong></span>) where we pass down <code class="literal">investment</code>.</p><p>Then, at the spec, we are using another helper method called <code class="literal">findRenderedDOMComponentWithClass</code> to look for a DOM element in our <code class="literal">component</code> variable.</p><p>This method <a id="id221" class="indexterm"/>returns <code class="literal">ReactElement</code>. And again, we will use the <code class="literal">getDOMNode</code> method<a id="id222" class="indexterm"/> to get the actual DOM element and then use the <code class="literal">jasmine-jquery</code> matcher to check for its text value, as follows:</p><div class="informalexample"><pre class="programlisting">var roi = TestUtils.findRenderedDOMComponentWithClass(component, 'roi');
expect(roi.getDOMNode()).<span class="strong"><strong>toHaveText</strong></span>('25%');</pre></div><p>Implementing this behavior in the component is actually very simple:</p><div class="informalexample"><pre class="programlisting">(function (React) {
  var InvestmentListItem = React.createClass({
    render: function () {
      var investment = <span class="strong"><strong>this.props.investment</strong></span>;

      return &lt;li className="investment-list-item"&gt;
        &lt;article&gt;
          &lt;span className="roi"&gt;<span class="strong"><strong>{formatPercentage(investment.roi())}</strong></span>&lt;/span&gt;
        &lt;/article&gt;
      &lt;/li&gt;;
    }
  });

  function formatPercentage (number) {
    return (number * 100).toFixed(0) + '%';
  }

  this.InvestmentListItem = InvestmentListItem;
})(React);</pre></div><p>We can access any props passed to a component through the <code class="literal">this.props</code> object.</p><p>Expanding the original implementation, we've added a <code class="literal">span</code> element with the expected class from the spec.</p><p>To allow the return on investment to be dynamic, JSX has a special syntax. Using <code class="literal">{}</code>, you can invoke any JavaScript code in the middle of the XML. We are invoking the <code class="literal">formatPercentage</code> function while passing the <code class="literal">investment.roi()</code> value, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;span className="roi"&gt;{formatPercentage(investment.roi())}&lt;/span&gt;</pre></div><p>Again, just to make this clear, this JSX transformed into JavaScript would be:</p><div class="informalexample"><pre class="programlisting">React.createElement("span", {className: "roi"}, formatPercentage(investment.roi()))</pre></div><p>It is important to know that a prop should be immutable. It is not the responsibility of a component to change its own prop values. You can consider a React component that has only props as a pure function, in that it always returns the same result value given the same argument values.</p><p>This makes <a id="id223" class="indexterm"/>testing very simple as there are no mutations or changes in the state <a id="id224" class="indexterm"/>to test a component.</p></div>
<div class="section" title="Component events"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Component events</h1></div></div></div><p>UI applications have user<a id="id225" class="indexterm"/> events; in the web, they came in the form of DOM events. As <a id="id226" class="indexterm"/>React wraps each DOM element into React elements, handling them will be a little different yet very familiar.</p><p>For this next example, let's suppose that our application will allow users to delete an investment. We could write this requirement through the following acceptance criterion:</p><p>Given an investment, InvestmentListItem should notify an observer onClickDelete when the delete button is clicked on.</p><p>The idea here is the same as presented in the <span class="emphasis"><em>Integrate Views with observers</em></span> section of <a class="link" href="ch03.html" title="Chapter 3. Testing Frontend Code">Chapter 3</a>, <span class="emphasis"><em>Testing Frontend Code</em></span>.</p><p>So, how should we set the observer in a component? As we've already seen previously, <span class="strong"><strong>props</strong></span> are the way to pass attributes to our component, as follows:</p><div class="informalexample"><pre class="programlisting">describe("InvestmentListItem", function() {
  var TestUtils = React.addons.TestUtils;

  describe("given an Investment", function() {
    var investment, component, onClickDelete;

    beforeEach(function() {
      investment = new Investment({
        stock: new Stock({ symbol: 'peto', sharePrice: 0.25 }),
        shares: 100,
        sharePrice: 0.20
      });

      onClickDelete = jasmine.createSpy('onClickDelete');

      component = TestUtils.renderIntoDocument(
        &lt;InvestmentListItem investment={investment} <span class="strong"><strong>onClickDelete={onClickDelete}</strong></span>/&gt;
      );
    });

    it("should notify an observer onClickDelete when the delete button is clicked", function() {
      var deleteButton = TestUtils.findRenderedDOMComponentWithTag(component, 'button');
      TestUtils.Simulate.click(deleteButton);
      expect(onClickDelete).toHaveBeenCalled();
    });

  });
});</pre></div><p>As you can see, we <a id="id227" class="indexterm"/>passed down another prop to the <code class="literal">onClickDelete</code><a id="id228" class="indexterm"/> component, and as its value, we set a Jasmine spy, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>onClickDelete = jasmine.createSpy('onClickDelete');</strong></span>

component = TestUtils.renderIntoDocument(
  &lt;InvestmentListItem investment={investment} <span class="strong"><strong>onClickDelete={onClickDelete}</strong></span>
<span class="strong"><strong/></span>/&gt;
);</pre></div><p>Then, we found the delete button through its tag and used the <code class="literal">TestUtils</code> module to simulate a click, expecting the previously created spy to be called, as follows:</p><div class="informalexample"><pre class="programlisting">var deleteButton = TestUtils.findRenderedDOMComponentWithTag(component, 'button');
TestUtils.Simulate.click(deleteButton);
expect(onClickDelete).toHaveBeenCalled();</pre></div><p>The <code class="literal">TestUtils.Simulate</code> module contains helper methods to simulate all types of DOM events, as follows:</p><div class="informalexample"><pre class="programlisting">TestUtils.Simulate.<span class="strong"><strong>click</strong></span>(node);
TestUtils.Simulate.<span class="strong"><strong>change</strong></span>(node, {target: {value: 'Hello, world'}});
TestUtils.Simulate.<span class="strong"><strong>keyDown</strong></span>(node, {key: "Enter"});</pre></div><p>Then, we got back to the implementation:</p><div class="informalexample"><pre class="programlisting">(function (React) {
  var InvestmentListItem = React.createClass({
    render: function () {
      var investment = this.props.investment;
      <span class="strong"><strong>var onClickDelete = this.props.onClickDelete;</strong></span>

      return &lt;li className="investment-list-item"&gt;
        &lt;article&gt;
          &lt;span className="roi"&gt;{formatPercentage(investment.roi())}&lt;/span&gt;
          &lt;button className="delete-investment" <span class="strong"><strong>onClick={onClickDelete}</strong></span>&gt;Delete&lt;/button&gt;
        &lt;/article&gt;
      &lt;/li&gt;;
    }
  });

  function formatPercentage (number) {
    return (number * 100).toFixed(0) + '%';
  }

  this.InvestmentListItem = InvestmentListItem;
})(React);</pre></div><p>As you can see, it<a id="id229" class="indexterm"/> was as simple as nesting another <code class="literal">button</code> component and <a id="id230" class="indexterm"/>passing down the <code class="literal">onClickDelete</code> prop value as its <code class="literal">onClick</code> prop.</p><p>React normalizes events so that they have consistent properties across different browsers, but its naming conventions and syntax is similar to inline JavaScript code in HTML. To get a comprehensive list of the supported<a id="id231" class="indexterm"/> events, you can check the official documentation at <a class="ulink" href="http://facebook.github.io/react/docs/events.html">http://facebook.github.io/react/docs/events.html</a>.</p></div>
<div class="section" title="Component state"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Component state</h1></div></div></div><p>Until now, we've <a id="id232" class="indexterm"/>dealt with React as a stateless rendering engine, but as we know, applications<a id="id233" class="indexterm"/> have state, especially when using forms. So, how would we implement the <code class="literal">NewInvestment</code> component in order for it to keep hold of the values of the investment being created and then notify an observer once the user completed the form?</p><p>To help us implement this behavior, we are going to use another component internal API—its <span class="strong"><strong>state</strong></span>.</p><p>Let's take the following acceptance criterion:</p><p>Given that the inputs of the <code class="literal">NewInvestment</code> component are correctly filled, when the form is submitted, it should notify the <code class="literal">onCreate</code> observer with the investment attributes:</p><div class="informalexample"><pre class="programlisting">describe("NewInvestment", function() {
  var TestUtils = React.addons.TestUtils;
  var component, onCreateSpy;

  function findNodeWithClass (className) {
    return TestUtils.findRenderedDOMComponentWithClass(component, className).getDOMNode();
  }

  beforeEach(function() {
    onCreateSpy = jasmine.createSpy('onCreateSpy');
    component = TestUtils.renderIntoDocument(
      &lt;NewInvestment onCreate={onCreateSpy}/&gt;
    );
  });

  describe("with its inputs correctly filled", function() {
    beforeEach(function() {
      var stockSymbol = findNodeWithClass('new-investment-stock-symbol');
      var shares = findNodeWithClass('new-investment-shares');
      var sharePrice = findNodeWithClass('new-investment-share-price');

      TestUtils.Simulate.change(stockSymbol, { target: { value: 'AOUE' }});
      TestUtils.Simulate.change(shares, { target: { value: '100' }});
      TestUtils.Simulate.change(sharePrice, { target: { value: '20' }});
    });

    describe("when its form is submitted", function() {
      beforeEach(function() {
        var form = component.getDOMNode();
        TestUtils.Simulate.submit(form);
      });

      it("should invoke the 'onCreate' callback with the investment attributes", function() {
        var investmentAttributes = { stockSymbol: 'AOUE', shares: '100', sharePrice: '20' };

        expect(onCreateSpy).toHaveBeenCalledWith(investmentAttributes);
      });
    });
  });
});</pre></div><p>This spec is basically using every trick we've learned until now, so without getting into the details, let's dive directly into the component implementation.</p><p>The first thing that<a id="id234" class="indexterm"/> any component with state must declare is its initial state by<a id="id235" class="indexterm"/> defining a <code class="literal">getInitialState</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">var NewInvestment = React.createClass({
<span class="strong"><strong>   getInitialState: function () {</strong></span>
<span class="strong"><strong>    return {</strong></span>
<span class="strong"><strong>      stockSymbol: '',</strong></span>
<span class="strong"><strong>      shares: 0,</strong></span>
<span class="strong"><strong>      sharePrice: 0</strong></span>
<span class="strong"><strong>    };</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>},</strong></span>

  render: function () {
<span class="strong"><strong>    var state = this.state;</strong></span>

    return &lt;form className="new-investment"&gt;
      &lt;h1&gt;New investment&lt;/h1&gt;
      &lt;label&gt;
        Symbol:
        &lt;input type="text" ref="stockSymbol" className="new-investment-stock-symbol" <span class="strong"><strong>value={state.stockSymbol}</strong></span> maxLength="4"/&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Shares:
        &lt;input type="number" className="new-investment-shares" <span class="strong"><strong>value={state.shares}</strong></span>/&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Share price:
        &lt;input type="number" className="new-investment-share-price" <span class="strong"><strong>value={state.sharePrice}</strong></span>/&gt;
      &lt;/label&gt;
      &lt;input type="submit" className="new-investment-submit" value="Add"/&gt;
    &lt;/form&gt;;
  }
});</pre></div><p>As illustrated in the preceding code, we are clearly defining the initial state of our form, and at the render method, we pass the state as <code class="literal">value</code> props to the input components.</p><p>If you run this example in a browser, you will notice that you won't be able to change the values of the inputs. You can focus on the inputs, but trying to type won't change its values, and that is because of the way React works.</p><p>Unlike HTML, React components must represent the state of the view at any point in time and not only at initialization time. If we want to change the value of an input, we need to listen for the <code class="literal">onChange</code> events of the inputs and, with that information, update the state. The change in the state will then trigger a render that will update the value on screen.</p><p>To demonstrate <a id="id236" class="indexterm"/>how <a id="id237" class="indexterm"/>this works, let's implement this behavior at the <code class="literal">stockSymbol</code> input.</p><p>First, we need to change the render method, adding a handler to the <code class="literal">onChange</code> event:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" ref="stockSymbol" className="new-investment-stock-symbol" value={state.stockSymbol} maxLength="4" <span class="strong"><strong>onChange={this._handleStockSymbolChange}</strong></span>/&gt;</pre></div><p>Once the event is triggered, it will invoke the <code class="literal">_handleStockSymbolChange</code> method. Its implementation should update the state by invoking the <code class="literal">this.setState</code> method with the new value of the input, as follows:</p><div class="informalexample"><pre class="programlisting">var NewInvestment = React.createClass({
  getInitialState: function () {
    // ... Method implementation
  },

  render: function () {
    // ... Method implementation
  },

<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>_handleStockSymbolChange: function (event) {</strong></span>
<span class="strong"><strong>    this.setState({ stockSymbol: event.target.value });</strong></span>
<span class="strong"><strong>  }</strong></span>
});</pre></div><p>The event handler is a good place to perform simple validation or transformation in the input data before passing it to the state.</p><p>As you can see, this is a lot of boilerplate code just to handle a single input. Since we are not implementing any custom behavior into our event handlers, we can use a special React feature that implements this "linked state" for us.</p><p>We are going to use a <span class="strong"><strong>Mixin</strong></span><a id="id238" class="indexterm"/> called <code class="literal">LinkedStateMixin</code>; but first, what is a Mixin? It is a way to share common functionality between components, which, in this case, is the "linked state". Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">var NewInvestment = React.createClass({
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>mixins: [React.addons.LinkedStateMixin],</strong></span>

  // ...

  render: function () {
    // ...
    &lt;input type="text" ref="stockSymbol" className="new-investment-stock-symbol" <span class="strong"><strong>valueLink={this.linkState('stockSymbol')}</strong></span> maxLength="4" /&gt;
    // ...
  }
});</pre></div><p><code class="literal">LinkedStateMixin</code> works by<a id="id239" class="indexterm"/> adding the <code class="literal">linkState</code> function to the component, and <a id="id240" class="indexterm"/>instead of setting the <code class="literal">value</code> of the input, we set a special prop called <code class="literal">valueLink</code> with the link object returned by the function <code class="literal">this.linkState</code>.</p><p>The <code class="literal">linkState</code> function expects the name of the attribute of the <span class="strong"><strong>state</strong></span> that it should link to the value of the input.</p></div>
<div class="section" title="Component life cycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Component life cycle</h1></div></div></div><p>As you might have noticed, React<a id="id241" class="indexterm"/> has an opinionated view on a component's API. But it also <a id="id242" class="indexterm"/>has a very strong opinion on its life cycle, allowing us developers to add hooks to create custom behavior and perform cleanup tasks as we develop our components.</p><p>This is one of React's greatest triumphs because it is through this standardization that we can create bigger and better components by composition; through that, we can use not only our components, but other people's components.</p><p>To demonstrate one use case, we are going to implement a very simple behavior: on page load, we want the new investment form stock symbol input to be focused so that a user can start typing right away.</p><p>But, before we can start writing the test, there is just one thing that we will need to do. As mentioned earlier, <code class="literal">TestUtils.renderIntoDocument</code> doesn't actually render anything in the document, but instead on a detached node. So, if we use it to render our component, we won't be able to make the assertion regarding the input's focus.</p><p>So, yet again, we have to use the <code class="literal">setFixtures</code> method to actually render the React component in the document, as follows:</p><div class="informalexample"><pre class="programlisting">/**
  Uses jasmine-jquery fixtures to actually render in the document.
  React.TestUtils.renderIntoDocument renders in a detached node.

  This was required to test the focus behavior.
 */
function actuallyRender (component) {
  setFixtures('&lt;div id="application-container"&gt;&lt;/div&gt;');
  var container = document.getElementById('application-container');
  return React.render(component, container);
}

describe("NewInvestment", function() {
  var TestUtils = React.addons.TestUtils;
  var component, stockSymbol;

  function findNodeWithClass (className) {
    return TestUtils.findRenderedDOMComponentWithClass(component, className).getDOMNode();
  }

  beforeEach(function() {
    component = actuallyRender(&lt;NewInvestment onCreate={onCreateSpy}/&gt;);
    stockSymbol = findNodeWithClass('new-investment-stock-symbol');
  });

  it("should have its stock symbol input on focus", function() {
    expect(stockSymbol).toBeFocused();
  });
});</pre></div><p>With this small change <a id="id243" class="indexterm"/>completed, and the spec written, we can get back to the <a id="id244" class="indexterm"/>implementation.</p><p>React gives a few hooks that we can implement custom code in our component during its life cycle; they are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillMount</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentDidMount</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillReceiveProps</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">shouldComponentUpdate</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillUpdate</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentDidUpdate</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillUnmount</code></li></ul></div><p>To implement our custom behavior, we are going to use the <code class="literal">componentDidMount</code> hook that is called only once, right after the component was rendered and attached into a DOM element.</p><p>So, what we want to do is somehow inside this hook, get access to the input DOM element and trigger its focus. We already know how to get a DOM node; it is through the <code class="literal">getDOMNode</code> API. But, how do we get the input's React element?</p><p>React's other feature for this <a id="id245" class="indexterm"/>problem is called<a id="id246" class="indexterm"/> <span class="strong"><strong>ref</strong></span>. It is basically a <a id="id247" class="indexterm"/>way to give names to a component's children to allow later access.</p><p>Since we want the stock symbol input, we need to add a <code class="literal">ref</code> attribute to it, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" <span class="strong"><strong>ref="stockSymbol"</strong></span> className="new-investment-stock-symbol" valueLink={this.linkState('stockSymbol')} maxLength="4" /&gt;</pre></div><p>Then, at the <code class="literal">componentDidMount</code> hook, we can get the input by its <code class="literal">ref</code> name and then its DOM element and trigger the focus, as follows:</p><div class="informalexample"><pre class="programlisting">var NewInvestment = React.createClass({
  // ...
  
<span class="strong"><strong>componentDidMount: function () {</strong></span>
<span class="strong"><strong>    this.refs.stockSymbol.getDOMNode().focus();</strong></span>
<span class="strong"><strong>  }</strong></span>
<code class="literal">,</code>
  // ...
});</pre></div><p>The other hooks are setup in the same way, by simply defining them on the class definition object as properties. But each is called on different occasions, and has different rules. The official documentation is a great resource on their definition and possible use-cases which can be found at <a class="ulink" href="http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods</a>.</p></div>
<div class="section" title="Composing components"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Composing components</h1></div></div></div><p>We've talked a lot about <a id="id248" class="indexterm"/>
<span class="strong"><strong>composability</strong></span> in the way of creating components by<a id="id249" class="indexterm"/> composing React's default components. However, we haven't showed how to compose custom components into bigger components.</p><p>As you might have guessed, this should be a pretty simple exercise, and to demonstrate how this works, we are going to implement a component to list investments, as follows:</p><div class="informalexample"><pre class="programlisting">var InvestmentList = React.createClass({
  render: function () {
    var onClickDelete = this.props.onClickDelete;

    var listItems = this.props.investments.map(function (investment) {
      return &lt;<span class="strong"><strong>InvestmentListItem</strong></span> investment={investment}
                  onClickDelete={onClickDelete.bind(null, investment)}/&gt;;
    });

    return &lt;ul className="investment-list"&gt;{listItems}&lt;/ul&gt;;
  }
});</pre></div><p>It is as simple as using<a id="id250" class="indexterm"/> the already available <code class="literal">InvestmentListItem</code> global <a id="id251" class="indexterm"/>variable as the root element of the <code class="literal">InvestmentList</code> component.</p><p>The component expects an <code class="literal">investments</code> prop to be an array of investments. It then maps it through creating an <code class="literal">InvestmentListItem</code> element for each investment in the array.</p><p>Finally, it uses the <code class="literal">listItems</code> array as the children of an <code class="literal">ul</code> element, effectively defining how to render the list of investments.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Summary</h1></div></div></div><p>React is a rapidly evolving library that is getting a lot of traction by the JavaScript community; it introduced some interesting patterns and questioned some well-established dogmas as it is continually improving the development of rich web applications.</p><p>This chapter's goal was not to give an in-depth look into the library but an overview of its primary features and philosophies. It demonstrated that it is possible to do test-driven development while coding your interface with React.</p><p>You learned about <span class="strong"><strong>prop</strong></span> and <span class="strong"><strong>state</strong></span> and their differences: A <span class="strong"><strong>prop</strong></span> is not owned by the component, and should, if needed, be changed by its parent. The <span class="strong"><strong>state</strong></span> is the data that the component owns. It can be changed by the component, and by doing so, a new render is triggered.</p><p>The fewer components with state you have in your application, the easier it is going to be to reason about it and test it.</p><p>It is through React's opinionated API and life cycle that we can get the maximum benefit of composability and code reuse.</p><p>As you move into application development with React, it is recommended that you learn about Flux, the recommended architecture to build applications by Facebook, at <a class="ulink" href="http://facebook.github.io/flux/">http://facebook.github.io/flux/</a>.</p></div></body></html>