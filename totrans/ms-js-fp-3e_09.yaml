- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Designing Functions – Recursion
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计函数 – 递归
- en: 'In [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*,
    we considered yet more ways to create new functions out of combining previous
    existing ones. Here, we will get into a different theme: how to design and write
    functions in a typically functional way, by applying recursive techniques.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B19301_08.xhtml#_idTextAnchor148) *连接函数*中，我们考虑了更多从现有函数组合创建新函数的方法。在这里，我们将探讨一个不同的主题：如何通过应用递归技术以典型的函数式方式设计和编写函数。
- en: 'We will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding what recursion is and how to think in order to produce recursive
    solutions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解递归是什么以及如何思考以产生递归解决方案
- en: Applying recursion to some well-known problems, such as making a change or the
    Tower of Hanoi
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将递归应用于一些著名问题，例如找零或汉诺塔问题
- en: Using recursion instead of iteration to re-implement some higher-order functions
    from earlier chapters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归而不是迭代来重新实现前面章节中的一些高阶函数
- en: Writing search and backtrack algorithms with ease
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松编写搜索和回溯算法
- en: Traversing data structures, such as trees, to work with filesystem directories
    or with the browser DOM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数据结构，如树，以处理文件系统目录或浏览器DOM
- en: Understanding mutual recursion and applying it to problems such as correctly
    evaluating arithmetical expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解互递归并将其应用于正确评估算术表达式等问题
- en: Getting around some limitations caused by browser JavaScript engine considerations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决由浏览器JavaScript引擎考虑引起的某些限制
- en: Using recursion
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归
- en: Recursion is a key technique in FP, to the degree that some languages do not
    provide for iterations or loops, and work exclusively with recursion (Haskell,
    which we already mentioned, is a prime example of that). A fundamental fact of
    computer science is that whatever you can do with recursion, you can do with iteration
    (loops), and vice versa. The key concept is that there are many algorithms whose
    definition is far easier if you work recursively. On the other hand, recursion
    is not always taught, and many programmers, even after knowing about it, prefer
    not to use it. Therefore, in this section, we shall see several examples of recursive
    thinking so that you can adapt it for your functional coding.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是函数式编程（FP）的关键技术，以至于某些语言不提供迭代或循环，而完全使用递归（我们之前提到的Haskell就是这样一个典型的例子）。计算机科学的一个基本事实是，你可以用递归做到的事情，你也可以用迭代（循环）做到，反之亦然。关键概念是，有许多算法的定义如果以递归方式工作会更容易。另一方面，递归并不总是被教授，许多程序员，即使知道了递归，也更愿意不使用它。因此，在本节中，我们将看到几个递归思维的例子，以便您可以将它们应用于您的函数式编码。
- en: A typical, oft-quoted, and very old computer joke!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型、经常引用且非常古老的计算机笑话！
- en: 'Dictionary definition: **recursion***: (n)* *see* **recursion**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 词典定义：**递归**： (n) *参见* **递归**
- en: But what is recursion? There are many ways to define what recursion is, but
    the simplest one I’ve seen runs along the lines of *a function calling itself
    again and again until it doesn’t*. A more complex case is mutual recursion, the
    simplest example of which is when we have two functions, `A()` and `B()`, each
    of which calls the other, over and over, until they are done.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但什么是递归？定义递归有很多方法，但我看到的最简单的一种是这样的：*一个函数一次又一次地调用自己，直到不再调用为止*。一个更复杂的情况是互递归，最简单的例子是我们有两个函数，`A()`和`B()`，每个函数都一次又一次地调用另一个，直到它们完成。
- en: 'Recursion is a natural technique for several kinds of problems, such as the
    following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是解决多种问题的自然技术，例如以下问题：
- en: Mathematical definitions, such as the Fibonacci sequence or the factorial of
    a number
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学定义，例如斐波那契数列或一个数的阶乘
- en: Data-structure-related algorithms with recursively defined structures, such
    as lists (a list is either empty or consists of a head node followed by a list
    of nodes) or trees (a tree might be defined as a special node, called the root,
    linked to zero or more trees)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与递归定义的结构相关的数据结构算法，例如列表（一个列表要么是空的，要么由一个头节点后跟一个节点列表组成）或树（树可以定义为称为根的特殊节点，它连接零个或多个树）
- en: Syntax analysis for compilers based on grammar rules, which themselves depend
    on other rules, which also depend on other rules, and so on
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于语法规则的编译器语法分析，这些规则本身又依赖于其他规则，这些规则又依赖于其他规则，如此等等
- en: 'And many more! It even appears in art and humor, as shown in *Figure 9**.1*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以及更多！它甚至出现在艺术和幽默中，如图9**.1**所示：
- en: '![Figure 9.1 – Google itself jokes about it: if you ask about recursion, it
    answers, “Did you mean: recursion”](img/Figure_9.1_B19301.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Google自己也开玩笑说：如果你问及递归，它会回答，“你是指：递归”](img/Figure_9.1_B19301.jpg)'
- en: 'Figure 9.1 – Google itself jokes about it: if you ask about recursion, it answers,
    “Did you mean: recursion”'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Google自己也开玩笑说：如果你问及递归，它会回答，“你是指：递归”
- en: Apart from some easy base cases in which no further computation is required,
    a recursive function must call itself one or more times to perform part of the
    required calculations. This concept may not be very clear at this point, so in
    the following sections, we will see how we can think recursively and solve several
    common problems by applying this technique.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些不需要进一步计算的基本情况外，递归函数必须调用自己一次或多次以执行所需的计算的一部分。这个概念可能在这个阶段不是很清楚，所以在下文中，我们将看到我们如何进行递归思考，并通过应用这种技术解决几个常见问题。
- en: Thinking recursively
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归思考
- en: 'The key to solving problems recursively is assuming that you already have a
    function that does whatever you need and just calling it. (Doesn’t this sound
    weird? Actually, it is quite appropriate: if you want to solve a problem with
    recursion, you must first have solved it before...) On the other hand, if you
    attempt to work out in your head how the recursive calls work and try to follow
    the flow, you’ll probably just get lost. So, what you need to do is the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解决递归问题的关键是假设你已经有一个能够完成你需要的功能的函数，并且只是调用它。（这听起来是不是很奇怪？实际上，这是非常合适的：如果你想用递归解决问题，你必须首先解决它...)
    另一方面，如果你试图在脑海中弄清楚递归调用是如何工作的，并试图跟随流程，你可能会迷失方向。所以，你需要做的是以下：
- en: Assume you already have an appropriate function to solve your problem.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经有一个合适的函数来解决你的问题。
- en: See how the big problem can be solved by solving one (or more) smaller problems.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看如何通过解决一个（或多个）更小的问题来解决大问题。
- en: Solve those problems by using the imagined function from *step 1*.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*步骤1*中想象出的函数来解决这些问题。
- en: Decide what your base cases are. Make sure they are simple enough that they
    are solved directly, without requiring more calls.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定你的基本情况是什么。确保它们足够简单，可以直接解决，而无需更多的调用。
- en: With these points in mind, you can solve problems by recursion because you’ll
    have the basic structure for your recursive solution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些要点，你可以通过递归解决问题，因为你将拥有你的递归解决方案的基本结构。
- en: 'There are three usual methods for solving problems by applying recursion:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用递归解决问题通常有三种常用方法：
- en: '**Decrease and conquer** is the simplest case, in which solving a problem directly
    depends on solving a single, simpler case of itself.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少和征服**是最简单的情况，其中解决问题直接依赖于解决它自己的一个更简单的情况。'
- en: '**Divide and conquer** is a more general approach. The idea is to try to divide
    your problem into two or more smaller versions, solve them recursively, and use
    these solutions to solve the original problem. The only difference between this
    technique and *decrease and conquer* is that you have to solve two or more other
    problems instead of only one.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分而治之**是一种更通用的方法。想法是尝试将你的问题分解为两个或更多更小的版本，递归地解决它们，并使用这些解决方案来解决原始问题。这种技术与*减少和征服*之间的唯一区别是，你必须解决两个或更多其他问题，而不仅仅是解决一个问题。'
- en: '**Dynamic programming** can be seen as a variant of *divide and conquer*: basically,
    you solve a complex problem by breaking it into a set of somewhat simpler versions
    of the same problem and solving each in order; however, a key idea in this strategy
    is to store previously found solutions, so that whenever you find yourself needing
    the solution to a simpler case again, you won’t directly apply recursion but,
    instead, use the stored result and avoid unnecessary repeated calculations.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态规划**可以看作是*分而治之*的一种变体：基本上，你通过将复杂问题分解为一系列相对简单的同一问题的版本，并按顺序解决每个版本来解决问题；然而，这个策略中的关键思想是存储之前找到的解决方案，这样当你再次需要解决更简单的情况的解决方案时，你不会直接应用递归，而是使用存储的结果，避免不必要的重复计算。'
- en: In this section, we shall look at a few problems and solve them by thinking
    recursively. Of course, we shall see more applications of recursion in the rest
    of the chapter; here, we’ll focus on the key decisions and questions needed to
    create such an algorithm.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些问题，并通过递归思考来解决它们。当然，我们将在本章的其余部分看到递归的更多应用；在这里，我们将专注于创建此类算法所需的关键决策和问题。
- en: Decrease and conquer – searching
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少和征服 – 搜索
- en: 'The most usual case of recursion involves just a single, simple case. We have
    already seen some examples of this, such as the ubiquitous factorial calculation:
    to calculate the factorial of *n*, you previously needed to calculate the factorial
    of *n*-1\. (See [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*.)
    Let’s turn now to a non-mathematical example.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 递归最常见的情况只涉及一个简单的情况。我们已经看到了一些这样的例子，比如无处不在的阶乘计算：要计算*n*的阶乘，你之前需要计算*n*-1的阶乘。（参见[*第1章*](B19301_01.xhtml#_idTextAnchor015)，*成为函数式编程者*。）现在让我们转向一个非数学的例子。
- en: 'You would also use this decrease-and-conquer strategy to search for an element
    in an array. If the array is empty, then obviously the searched-for value isn’t
    there; otherwise, the result is in the array if, and only if, it’s the array’s
    first element or if it’s in the rest of the array. The following code does just
    that:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会使用这种减少和征服策略来搜索数组中的元素。如果数组为空，那么显然搜索的值不在那里；否则，如果它是数组的第一个元素或者它在数组的其余部分中，那么结果就在数组中。以下代码正是这样做的：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This implementation directly mirrors our explanation, and verifying its correctness
    is easy.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现直接反映了我们的解释，验证其正确性也很容易。
- en: By the way, just as a precaution, let’s look at two further implementations
    of the same concept. You can shorten the search function a bit—is it still clear?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，作为一个预防措施，让我们看看同一概念的两种进一步实现。你可以稍微缩短搜索函数——它是否仍然清晰？
- en: 'We are using a ternary operator to detect whether the array is empty, and a
    Boolean `||` operator to return `true` if the first element is the sought one
    or else return the result of the recursive search:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三元运算符来检测数组是否为空，并使用布尔`||`运算符在第一个元素是所需元素时返回`true`，否则返回递归搜索的结果：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sparseness can go even further! Using `&&` as a shortcut is a common idiom:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏性可以更进一步！使用`&&`作为快捷方式是一种常见的习语：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I’m not really suggesting that you code the function in this way—instead, consider
    it a warning against the tendency that some FP developers have to try to go for
    the tightest, shortest possible solution and never mind clarity!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是真的建议你以这种方式编写函数——相反，把它当作一个警告，提醒一些FP开发者试图追求最紧密、最短的解决方案，而不考虑清晰度！
- en: Decrease and conquer – doing powers
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少和征服 – 计算幂
- en: 'Another classic example has to do with efficiently calculating powers of numbers.
    If you want to calculate, say, 2 to the 13th power (213), then you can do this
    with 12 multiplications; however, you can do much better by writing 213 as the
    following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经典的例子与高效计算数字的幂有关。如果你想计算，比如说，2的13次幂（2^13），那么你可以用12次乘法来完成；然而，你可以通过将2^13写成以下形式来做得更好：
- en: = 2 times 212
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: = 2 乘以 212
- en: = 2 times 46
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: = 2 乘以 46
- en: = 2 times 163
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: = 2 乘以 163
- en: = 2 times 16 times 162
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: = 2 乘以 16 乘以 162
- en: = 2 times 16 times 2561
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: = 2 乘以 16 乘以 2561
- en: = 8192
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: = 8192
- en: 'This reduction in the total number of multiplications may not look very impressive,
    but in terms of algorithmic complexity, it allows us to bring down the order of
    the calculations from O(*n*) to O(*log n*). In some cryptographic-related methods,
    which have to raise numbers to really high exponents, this makes a significant
    difference. We can implement this recursive algorithm in a few lines of code,
    as shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种总乘法次数的减少可能看起来不太令人印象深刻，但从算法复杂性的角度来看，它使我们能够将计算的阶数从O(*n*)降低到O(*log n*)。在一些需要将数字提高到非常高指数的加密相关方法中，这会带来显著差异。我们可以用几行代码实现这个递归算法，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Extra speed
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的速度
- en: When implemented for production, bit operations are used instead of modulus
    and divisions. Checking whether a number is odd can be written as `power & 1`,
    and division by 2 is achieved with `power >> 1`. These alternative calculations
    are way faster than the replaced operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于生产实现时，使用位运算而不是取模和除法。检查一个数是否为奇数可以写成`power & 1`，而除以2可以通过`power >> 1`实现。这些替代计算比替换操作要快得多。
- en: Calculating a power is simple when the base case is reached (raising something
    to the zeroth power) or based on a previously calculated power for a smaller exponent.
    (If you wanted to, you could add another base case for raising something to the
    power of one.) These observations show that we are seeing a textbook case for
    the decrease and conquer recursive strategy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到基本情况（将某物提高到零次幂）或基于较小指数之前计算出的幂时，计算幂是简单的。（如果你愿意，可以为将某物提高到一次幂添加另一个基本情况。）这些观察表明，我们正在看到减少和征服递归策略的典型教材案例。
- en: Finally, some of our higher-order functions, such as `map()`, `reduce()`, and
    `filter()`, also apply this technique; we’ll look into this later on in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的一些高阶函数，如`map()`、`reduce()`和`filter()`，也应用了这种技术；我们将在本章后面探讨这一点。
- en: Divide and conquer – the Tower of Hanoi
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分而治之 – 汉诺塔
- en: 'With the divide-and-conquer strategy, solving a problem requires two or more
    recursive solutions. For starters, let’s consider a classic puzzle invented by
    a French mathematician, Édouard Lucas, in the 19th century. The puzzle involves
    a temple in India, with 3 posts, the first of them with 64 golden disks of decreasing
    diameter. The priests have to move the disks from the first post to the last one
    following two rules: only one disk can be moved at a time, and a larger disk can
    never be placed on top of a smaller disk. According to the legend, when the 64
    disks are moved, the world will end. This puzzle is usually marketed under the
    *Tower of Hanoi* name (yes, they changed countries!) with fewer than 10 disks.
    See *Figure 9**.2*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分而治之的策略，解决问题需要两个或更多的递归解决方案。首先，让我们考虑一个19世纪由法国数学家Édouard Lucas发明的经典谜题。这个谜题涉及印度的寺庙，有3个柱子，第一个柱子上有64个直径递减的金盘。僧侣们必须按照两个规则将磁盘从第一个柱子移动到最后一个柱子：一次只能移动一个磁盘，较大的磁盘不能放在较小的磁盘上面。根据传说，当64个磁盘被移动时，世界将结束。这个谜题通常以“汉诺塔”的名字（是的，他们改变了国家！）进行营销，磁盘数量少于10个。见图9.2*：
- en: '![Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution](img/Figure_9.2_B19301.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 经典的汉诺塔问题有一个简单的递归解决方案](img/Figure_9.2_B19301.jpg)'
- en: Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 经典的汉诺塔问题有一个简单的递归解决方案
- en: A long, long time…
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 很长，很长的时间…
- en: The solution for *n* disks requires 2n-1 movements. The original puzzle, requiring
    264-1 movements, at one movement per second, would take more than 584 billion
    years to finish – a very long time, considering that the universe’s age is evaluated
    to only be 13.8 billion years!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 解决`n`个磁盘的问题需要2^n-1次移动。原始问题需要264-1次移动，每次移动一秒，需要超过5840亿年才能完成——这是一个非常长的时间，考虑到宇宙的年龄估计只有1380亿年！
- en: 'Suppose we already have a function that solves the problem of moving any number
    of disks from a source post to a destination post using the remaining post as
    an extra aid. Think about solving the general problem if you already had a function
    to solve that problem: `hanoi(disks, from, to, extra)`. If you wanted to move
    several disks from one post to another, then you could solve it using this (still
    unwritten!) function by carrying out the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有了一个函数，该函数可以解决使用剩余柱子作为额外辅助工具，将任意数量的磁盘从源柱子移动到目标柱子的问题。如果你已经有一个函数可以解决这个问题：`hanoi(disks,
    from, to, extra)`，那么考虑解决一般问题：如果你已经有了解决该问题的函数，你会怎么做：通过执行以下步骤来解决这个问题（这个函数仍然是未编写的！）：
- en: Moving all of the disks but the last one to the extra post.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将除了最后一个磁盘之外的所有磁盘移动到额外的柱子。
- en: Moving the last disk to the destination post.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最后一个磁盘移动到目的地柱子。
- en: Moving all the disks from the extra post (where you had placed them earlier)
    to the destination.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有磁盘从额外的柱子（你之前放置它们的地方）移动到目的地。
- en: 'But what about our base cases? We could decide that to move a single disk,
    you don’t need the function; you just go ahead and move the disk. When coded,
    it becomes the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的基本情况又是什么呢？我们可以决定，移动单个磁盘时不需要函数；你只需直接移动磁盘即可。当编码时，它变成了以下这样：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using the `Post` type is possibly not needed, but good practice anyway. We
    can quickly verify that this code works:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Post`类型可能不是必需的，但仍然是好习惯。我们可以快速验证这段代码是否有效：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There’s only a small detail to consider, which can simplify the function further.
    In this code, our base case (the one that needs no further recursion) is when
    `disks` equals one. You could also solve this differently by letting the disks
    go down to zero and simply not doing anything—after all, moving zero disks from
    one post to another is achieved by doing nothing at all! The revised code would
    be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个小细节需要考虑，这可以进一步简化函数。在这段代码中，我们的基本情况（不需要进一步递归的情况）是当`disks`等于一。你也可以通过让磁盘数量下降到零并简单地什么都不做来解决这个问题——毕竟，从一个柱子移动零个磁盘到另一个柱子什么也不做就能完成！修改后的代码如下：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of checking whether there are any disks to move before doing the recursive
    call, we can just skip the check and have the function test, at the next level,
    whether there’s something to be done.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行递归调用之前，我们不必检查是否有磁盘要移动，我们只需跳过检查，让函数在下一级测试是否有事情要做。
- en: Hanoi by hand
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 手动解决汉诺塔问题
- en: 'If you are doing the puzzle by hand, there’s a simple solution for that: on
    odd turns, always move the smaller disk to the next post (if the total number
    of disks is odd) or to the previous post (if the total number of disks is even).
    On even turns, make the only possible move that doesn’t involve the smaller disk.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动解这个谜题，有一个简单的解决方案：在奇数次移动时，总是将较小的磁盘移动到下一个柱子（如果磁盘总数是奇数）或上一个柱子（如果磁盘总数是偶数）。在偶数次移动时，做出唯一可能的移动，不涉及较小的磁盘。
- en: 'So, the principle for recursive algorithm design works: assume you already
    have your desired function and use it to build itself!'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，递归算法设计的原则是有效的：假设你已经有了你想要的功能，然后使用它来构建自己！
- en: Divide and conquer – sorting
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分而治之 – 排序
- en: 'We can see another example of the divide-and-conquer strategy with sorting.
    A way to sort arrays, called Quicksort, is based upon the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用排序来看到分而治之策略的另一个例子。一种排序数组的方法称为快速排序，基于以下步骤：
- en: If your array has 0 or 1 element(s), do nothing; it’s already sorted (this is
    the base case).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的数组有0个或1个元素，则无需操作；它已经排序了（这是基本情况）。
- en: 'Pick an element of the array (called the pivot) and split the rest of the array
    into two subarrays: the elements smaller than your chosen element and the elements
    greater than or equal to your chosen element.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择数组中的一个元素（称为枢轴）并将数组的其余部分分成两个子数组：小于所选元素的元素和大于或等于所选元素的元素。
- en: Recursively sort each subarray.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归排序每个子数组。
- en: To produce the sorted version of the original array, concatenate both sorted
    results, with the pivot in between.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成原始数组的排序版本，将两个排序结果连接起来，中间是枢轴。
- en: 'Let’s see a simple version of this (there are some better-optimized implementations,
    but we are interested in the recursive logic now). Usually, picking a random element
    of the array is suggested to avoid some bad performance border cases, but for
    our example, let’s just take the first one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单版本（有一些更好的优化实现，但我们现在对递归逻辑感兴趣）。通常，建议选择数组中的一个随机元素以避免一些性能边界情况，但为了我们的例子，让我们只取第一个：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see how this works in *Figure 9**.3*: the pivot for each array and subarray
    is underlined. Splitting is shown with dotted arrows and is joined with full lines:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图9**.3*中看到这是如何工作的：每个数组和子数组的枢轴都被下划线标出。分割用虚线箭头表示，并用实线连接：
- en: '![Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer
    strategy to reduce the original problem to smaller ones](img/Figure_9.3_B19301.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 快速排序递归地对数组进行排序，应用分而治之策略将原始问题简化为更小的问题](img/Figure_9.3_B19301.jpg)'
- en: Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer
    strategy to reduce the original problem to smaller ones
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 快速排序递归地对数组进行排序，应用分而治之策略将原始问题简化为更小的问题
- en: Easy-to-get bug!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 容易出现的错误！
- en: Writing Quicksort correctly is not trivial; see *Question 9.8* at the end of
    this chapter for an alternative version that is *almost* right, but not totally
    correct!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正确编写快速排序并非易事；请参阅本章末尾的*问题9.8*，以获取一个几乎正确但并非完全正确的替代版本！
- en: We have already seen the basic strategies to reduce a problem to simpler versions
    of itself. Let’s now look at an important optimization, a key for many algorithms.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了将问题简化为其自身更简单版本的基本策略。现在让我们看看一个重要的优化，这是许多算法的关键。
- en: Dynamic programming – making change
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态规划 – 改变
- en: The third general strategy, *dynamic programming*, assumes that you will have
    to solve many smaller problems, but instead of using recursion every time, it
    depends on you having stored the previously found solutions – *memoization*, in
    other words! In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*,
    and later, in a better fashion, in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we already saw how to optimize the calculations of the
    usual Fibonacci series, avoiding unnecessary repeated calls. Let’s now consider
    another problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种一般策略，*动态规划*，假设你将不得不解决许多更小的问题，但不是每次都使用递归，而是依赖于你存储之前找到的解决方案 – 也就是说，*记忆化*！在[*第4章*](B19301_04.xhtml#_idTextAnchor069)的*行为规范*和后来在更优雅的[*第6章*](B19301_06.xhtml#_idTextAnchor107)的*生成函数*中，我们已经看到了如何优化通常的斐波那契数列的计算，避免不必要的重复调用。现在让我们考虑另一个问题。
- en: 'Given a certain number of dollars and the list of existing bill values, calculate
    how many different ways we can pay that amount of dollars with different combinations
    of bills. It is assumed that you have access to an unlimited number of each bill.
    How can we go about solving this? Let’s start by considering the base cases where
    no further computation is needed. They are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一定数量的美元和现有纸币的面额列表，计算我们可以用不同组合的纸币支付该金额的不同方式有多少种。假设你能够无限制地使用每种面额的纸币。我们该如何解决这个问题呢？让我们先考虑不需要进一步计算的基本情况。它们如下：
- en: Paying negative values is not possible, so in such cases, we should return `0`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付负值是不可能的，所以在这种情况下，我们应该返回 `0`
- en: Paying zero dollars is only possible in a single way (by giving no bills), so
    in this case, we should return `1`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付零美元只有一种方式（不给出任何纸币），所以在这种情况下，我们应该返回 `1`
- en: Paying any positive amount of dollars isn’t possible if no bills are provided,
    so in this case, also return `0`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有提供任何纸币，就无法支付任何正金额，所以在这种情况下，也应该返回 `0`
- en: 'Finally, we can answer the question: in how many ways can we pay *N* dollars
    with a given set of bills? We can consider two cases: we do not use the larger
    bill at all and pay the amount using only smaller denomination bills, or we can
    take one bill of the larger amount and reconsider the question. (Let’s forget
    the avoidance of repeated calculations for now.)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以回答这个问题：使用给定的纸币组合支付 *N* 美元有多少种方式？我们可以考虑两种情况：我们完全不使用大面额纸币，只用小面额纸币支付金额，或者我们可以取一张大面额纸币并重新考虑这个问题。（现在我们先不考虑避免重复计算的问题。）
- en: In the first case, we should invoke our supposedly existing function with the
    same value of *N* but prune the largest bill denomination from the list of available
    bills.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们应该用相同的 *N* 值调用我们假设存在的函数，并从可用纸币列表中删除最大面额的纸币。
- en: 'In the second case, we should invoke our function with *N* minus the largest
    bill denomination, keeping the list of bills the same, as shown in the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们应该用 *N* 减去最大面额的纸币，保持纸币列表不变，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s do some optimization. This algorithm often needs to recalculate
    the same values over and over. (To verify this, add `console.log(n, bills.length)`
    as the first line in `makeChange()`—but be ready for plenty of output!) However,
    we already have a solution for this: memoization! Since we are applying this technique
    to a binary function, we’ll need a version of the memoization algorithm that deals
    with more than one parameter. We saw that in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,*
    *Producing Functions*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一些优化。这个算法经常需要反复重新计算相同的值。（为了验证这一点，在 `makeChange()` 中将 `console.log(n,
    bills.length)` 作为第一行添加——但要做好大量输出的准备！）然而，我们已经有了解决这个问题的解决方案：记忆化！由于我们正在将这种技术应用于二元函数，我们需要一个处理多个参数的记忆化算法版本。我们在
    [*第6章*](B19301_06.xhtml#_idTextAnchor107)*,* *产生函数* 中看到了它：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The memoized version of `makeChange()` is far more efficient, and you can verify
    it with logging. While it is certainly possible to deal with the repetitions by
    yourself (for example, by keeping an array of already computed values), the memoization
    solution is, in my opinion, better because it composes two functions to produce
    a better solution for the given problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeChange()` 的记忆化版本效率更高，你可以通过日志来验证。当然，你可以自己处理重复（例如，通过保留已计算值的数组），但在我看来，记忆化解决方案更好，因为它将两个函数组合起来，为给定的问题产生更好的解决方案。'
- en: Higher-order functions revisited
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Higher-order functions revisited
- en: Classic FP techniques do not use iteration at all but work exclusively with
    recursion as the only way to do some looping. Let’s revisit some of the functions
    that we have already seen in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, such as `map()`, `reduce()`, `find()`, and `filter()`,
    to see how we can make do with just recursion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的函数式编程技术完全不使用迭代，而是仅通过递归作为进行某些循环的唯一方式。让我们回顾一下我们在 [*第5章*](B19301_05.xhtml#_idTextAnchor084)
    *编程声明式* 中已经看到的一些函数，例如 `map()`、`reduce()`、`find()` 和 `filter()`，看看我们如何仅通过递归来完成。
- en: 'We are not planning to exchange the basic JavaScript functions for ours, though:
    it’s likely that performance will be worse for our recursive polyfills, and we
    won’t derive any advantages just from having the functions use recursion. Instead,
    we want to study how iterations are performed in a recursive way so that our efforts
    are more pedagogical than practical, OK?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不打算用我们的函数替换基本的 JavaScript 函数：我们的递归 polyfill 的性能可能会更差，仅仅因为函数使用了递归，我们不会从中获得任何优势。相反，我们想研究如何在递归方式下执行迭代，以便我们的努力更具教育意义而不是实际意义，好吗？
- en: Mapping and filtering
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射和过滤
- en: Mapping and filtering are quite similar insofar as both imply going through
    all the elements in an array and applying a callback to each to produce output.
    Let’s first work out the mapping logic, which will have several points to solve,
    and then we should see that filtering has become almost trivially easy, requiring
    just small changes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和过滤在某种程度上很相似，因为两者都意味着遍历数组中的所有元素并对每个元素应用回调以产生输出。让我们首先制定映射逻辑，这将有几个要点需要解决，然后我们应该看到过滤已经变得几乎易如反掌，只需要做小的改动。
- en: 'For mapping, given how we are developing recursive functions, we need a base
    case. Fortunately, that’s easy: mapping an empty array produces a new empty array.
    Mapping a non-empty array can be done by first applying the mapping function to
    the first element of the array, then recursively mapping the rest of the array,
    and finally, producing a single array accumulating both results.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射，鉴于我们正在开发递归函数，我们需要一个基本情况。幸运的是，这很简单：映射一个空数组会产生一个新的空数组。映射一个非空数组可以通过首先将映射函数应用于数组的第一个元素，然后递归映射数组的其余部分，最后，产生一个累积了两个结果的单一数组来完成。
- en: 'Based on this idea, we can work out a simple initial version: let’s call it
    `mapR()`, just to remember that we are dealing with our own, recursive version
    of `map()`; however, be careful – our polyfill has some bugs! We’ll deal with
    them one at a time. Here’s our first attempt at writing our own mapping code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个想法，我们可以制定一个简单的初始版本：让我们称它为 `mapR()`，只是为了记住我们正在处理自己的、递归版本的 `map()`；然而，请注意——我们的
    polyfill 有一些错误！我们将逐一解决它们。以下是编写我们自己的映射代码的第一次尝试：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s test it out:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Great! Our `mapR()` function seemingly produces the same results as `map()`.
    However, shouldn’t our callback function receive a couple more parameters, specifically
    the index at the array and the original array itself? (Check out the definition
    for the callback function for `map()` at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map).)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的 `mapR()` 函数似乎产生了与 `map()` 相同的结果。然而，我们的回调函数不应该接收一些额外的参数吗，特别是数组中的索引和原始数组本身？（查看
    `map()` 回调函数的定义，请参阅 [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map)。）
- en: 'Our implementation isn’t quite ready yet. Let’s first see how it fails by using
    a simple example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实施方案还没有完全准备好。让我们首先通过一个简单的例子来看看它是如何失败的：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you were working with JavaScript, the last call would produce `[NaN, NaN,
    NaN, NaN, NaN]` – TypeScript detects the error because the type of `timesTenPlusI()`
    is wrong:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 JavaScript，最后的调用将产生 `[NaN, NaN, NaN, NaN, NaN]`——TypeScript 检测到错误，因为 `timesTenPlusI()`
    的类型是错误的：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Generating the appropriate index position will require an extra parameter for
    the recursion. Still, it is basically simple: when we start out, we have `index=0`,
    and when we call our function recursively, it’s with the `index+1` position. Accessing
    the original array requires yet another parameter, which will never change, and
    now we have a better mapping function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 生成适当的索引位置需要为递归添加一个额外的参数。尽管如此，这基本上很简单：当我们开始时，我们有 `index=0`，当我们递归调用我们的函数时，它带有
    `index+1` 位置。访问原始数组还需要另一个参数，这个参数永远不会改变，现在我们有一个更好的映射函数：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Great! When you do recursion instead of iteration, you don’t have access to
    an index, so if you need it (as in our case), you’ll have to generate it on your
    own. This is an often-used technique, so working out our `map()` substitute was
    a good idea.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！当你用递归代替迭代时，你无法访问索引，所以如果你需要它（就像我们的情况一样），你必须自己生成它。这是一个常用的技术，所以制定我们的 `map()`
    替代品是个好主意。
- en: 'However, having extra arguments in the function is not so good; a developer
    might accidentally provide them and the results would be unpredictable. So, using
    another usual technique, let’s define an inner function, `mapLoop()`, to handle
    looping. This is, in fact, the usual way in which looping is achieved when you
    only use recursion; look at the following code, in which the extra function isn’t
    accessible from outside:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，函数中额外的参数并不好；开发者可能会意外地提供它们，结果将不可预测。所以，使用另一种常用的技术，让我们定义一个内部函数 `mapLoop()` 来处理循环。实际上，当你只使用递归时，这是实现循环的常用方法；看看以下代码，其中额外的函数在外部是不可访问的：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There’s only one pending issue: if the original array has some missing elements,
    they should be skipped during the loop. Let’s look at an example, in plain JavaScript:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个悬而未决的问题：如果原始数组有一些缺失的元素，它们应该在循环期间被跳过。让我们看看一个简单的例子，使用纯 JavaScript：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (Why just JavaScript? TypeScript would object because the array to be processed
    had `number | undefined` types, but `timesTen()` expects an array with just `number`
    types. By the way, I also had to disable ESLint’s `no-sparse-array` rule, which
    catches accidental extra commas in arrays.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: （为什么是 JavaScript？TypeScript 会提出异议，因为要处理的数组有 `number | undefined` 类型，但 `timesTen()`
    函数期望的是一个只有 `number` 类型的数组。顺便说一句，我还不得不禁用 ESLint 的 `no-sparse-array` 规则，它会捕获数组中意外的额外逗号。）
- en: Fortunately, fixing this is simple—and be glad that all the experience gained
    here will help us write the other functions in this section! Can you understand
    the fix in the following code, apart from the obvious changes to allow values
    in arrays to be `undefined`, for which I used an auxiliary `Opt<>` type definition?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，解决这个问题很简单——并且很高兴地知道在这里获得的所有经验都将帮助我们编写本节中的其他函数！你能理解以下代码中的修复，除了允许数组中的值是 `undefined`
    的明显变化，我使用了辅助的 `Opt<>` 类型定义吗？
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Wow! This was more than we bargained for, but we saw several techniques: how
    to replace iteration with recursion, how to accumulate a result across iterations,
    and how to generate and provide the index value—good tips! Furthermore, writing
    filtering code will prove much easier since we’ll be able to apply very much the
    same logic as we did for mapping. The main difference is that we use the callback
    function to decide whether an element goes into the output array, so the inner
    loop function is a tad longer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这超出了我们的预期，但我们看到了几种技术：如何用递归代替迭代，如何在迭代中累积结果，以及如何生成和提供索引值——很好的建议！此外，编写过滤代码将会容易得多，因为我们能够应用与映射相同的逻辑。主要区别在于我们使用回调函数来决定一个元素是否进入输出数组，因此内部循环函数会稍微长一些：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Okay, we managed to implement two of our basic higher-order functions with similar
    recursive functions. What about the others?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们成功地实现了两个基本的高阶函数，使用类似的递归函数。那么其他的高阶函数呢？
- en: Other higher-order functions
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他高阶函数
- en: Programming `reduce()` is, from the outset, a bit trickier, since you can decide
    to omit the initial value for the accumulator. Since we mentioned earlier that
    providing that value is generally better, let’s work here under the assumption
    that it will be given; dealing with the other possibility won’t be too hard.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `reduce()` 函数从一开始就有点棘手，因为你可以选择省略累加器的初始值。由于我们之前提到提供该值通常是更好的，让我们假设它会被提供；处理其他可能性不会太难。
- en: 'The base case is simple: if the array is empty, the result is the accumulator;
    otherwise, we must apply the `reduce` function to the current element and the
    accumulator, update the latter, and then continue working with the rest of the
    array. This can be a bit confusing because of the ternary operators, but it should
    be clear enough after all we’ve seen. Look at the following code for the details:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况很简单：如果数组为空，结果是累加器；否则，我们必须将 `reduce` 函数应用于当前元素和累加器，更新后者，然后继续处理数组的其余部分。这可能会因为三元运算符而有些令人困惑，但考虑到我们已经看到的所有内容，应该足够清晰。看看以下代码的细节：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the other hand, `find()` is particularly apt for recursive logic since the
    very definition of how you (attempt to) find something is recursive in itself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`find()` 函数特别适合递归逻辑，因为找到某物的定义本身就是递归的：
- en: You look at the first place you think of, and if you find what you were seeking,
    you are done
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你看看你首先想到的地方，如果你找到了你想要的东西，你就完成了
- en: Alternatively, you look at the other places to see whether what you seek is
    there
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以看看其他地方是否有什么是你想要的
- en: 'We are only missing the base case, but that’s simple, and we already saw this
    earlier in the chapter – if you have no places left to search, then you know you
    won’t be successful in your search:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只缺少基本情况，但这很简单，我们已经在本章前面看到了这一点 – 如果你没有地方可以搜索，那么你知道你的搜索不会成功：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can quickly verify whether this works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速验证这是否有效：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s finish with our pipelining function. The definition of a pipeline lends
    itself to quick implementation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的管道化函数结束。管道的定义适合快速实现：
- en: If we want to pipeline a single function, then that’s the result of the pipeline
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要管道化一个单一函数，那么这就是管道的结果
- en: If we want to pipeline several functions, we must first apply the initial function
    and then pass that result as input to the pipeline of the other functions
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要管道化多个函数，我们必须首先应用初始函数，然后将该结果作为输入传递给其他函数的管道
- en: 'We can directly turn this into code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将其转换为代码：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can verify its correctness with a simple example. Let’s pipeline several
    calls to a couple of functions, one of which just adds 1 to its argument and the
    other of which multiplies by 10:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个简单的例子来验证其正确性。让我们将几个函数调用管道化，其中一个只是将其参数加1，另一个乘以10：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you follow the math, you’ll be able to check that the pipelining is working
    fine. We could have a slightly different recursive call if we take the base case
    to be when no functions are provided:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循数学，你将能够检查管道是否正常工作。如果我们把基本情况设定为没有提供函数，我们可以有一个稍微不同的递归调用：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In any case, these pipelines won’t work in TypeScript because our `Pipeline<>`
    type definition won’t allow for an empty set of functions – can you fix that?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这些管道在 TypeScript 中不会工作，因为我们的 `Pipeline<>` 类型定义不允许空函数集 – 你能修复这个问题吗？
- en: Doing the same for composition is easy, except that you cannot use the spread
    operator to simplify the function definition, and you’ll have to work with array
    indices—work it out!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组合做同样的事情很容易，只是你不能使用扩展运算符来简化函数定义，你将不得不与数组索引一起工作——把它弄清楚！
- en: Searching and backtracking
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索和回溯
- en: 'Searching for solutions to problems, especially when there is no direct algorithm
    and you must resort to trial and error, is particularly appropriate for recursion.
    Many of these algorithms fall into a scheme such as the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索问题的解决方案，尤其是在没有直接算法且必须求助于试错的情况下，尤其适合递归。许多这些算法都落入以下方案：
- en: Out of many choices available, pick one. If no options are available, you’ve
    failed.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多可用的选择中，选择一个。如果没有选项可用，你就失败了。
- en: If you could pick one, apply the same algorithm, but find a solution to the
    rest.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以选择，应用相同的算法，但找到其余问题的解决方案。
- en: If you succeed, you are done. Otherwise, try another choice.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你成功，你就完成了。否则，尝试另一个选择。
- en: You can apply similar logic with minor variations to find a good—or possibly,
    optimum—solution to a given problem. Each time you find a possible solution, you
    match it with previous ones that you might have found and decide which to keep.
    This may continue until all possible solutions are evaluated or until a good enough
    solution has been found.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用类似的逻辑，稍作变化，找到给定问题的良好或可能最优的解决方案。每次你找到一个可能的解决方案，你就将其与之前可能找到的解决方案进行匹配，并决定保留哪一个。这可能会继续进行，直到所有可能的解决方案都被评估或找到一个足够好的解决方案。
- en: 'There are many problems to which this logic applies. They are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多问题都适用于这种逻辑。具体如下：
- en: '*Finding a way out of mazes*—pick any path, mark it as already followed, and
    try to find a way out of the maze that won’t reuse that path: if you succeed,
    you are done, and if you do not, go back to pick a different path'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*找到迷宫的出口*—选择任何路径，将其标记为已走过，并尝试找到一条不会重复该路径的迷宫出口：如果你成功，你就完成了，如果你不成功，就回到选择不同的路径'
- en: '*Filling out Sudoku puzzles*—if an empty cell can contain only a single number,
    then assign it; otherwise, run through all of the possible assignments, and for
    each one, recursively try to see whether the rest of the puzzle can be filled
    out'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*填写数独谜题*—如果一个空单元格只能包含一个数字，那么就分配它；否则，遍历所有可能的分配，并对每个分配，递归地尝试看是否可以填充谜题的其余部分'
- en: '*Playing chess*—where you aren’t likely to be able to follow through all possible
    move sequences, so you opt for the best-estimated position instead'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下棋*—你不太可能能够跟随所有可能的移动序列，所以你选择最佳估计的位置'
- en: 'Let’s apply these techniques to two problems: solving the eight queens puzzle
    and traversing a complete file directory.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些技术应用到两个问题上：解决八皇后问题和遍历完整的文件目录。
- en: The eight queens puzzle
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 八皇后问题
- en: The eight queens puzzle was invented in the 19th century and involves placing
    eight chess queens on a standard chessboard. The restriction is that no queen
    should be able to attack another—implying that no pair of queens may share a row,
    column, or diagonal line. The puzzle may ask for any solution or the total number
    of distinct solutions, which we will attempt to find.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 八皇后问题是在19世纪发明的，涉及在标准棋盘上放置八个国际象棋皇后。限制是没有任何皇后能够攻击另一个皇后——这意味着没有一对皇后可以共享一行、一列或对角线。这个谜题可能要求任何解决方案或不同解决方案的总数，我们将尝试找到。
- en: The *n* queens variation
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* 皇后变体'
- en: 'The puzzle may also be generalized to *n* queens by working on an *n*x*n* square
    board. It is known that there are solutions for all values of *n*, except *n*=2
    (pretty simple to see why: after placing one queen, all of the board is threatened)
    and *n*=3 (if you place a queen in the center, all of the board is threatened,
    and if you place a queen on a side, only two squares are not threatened, but they
    threaten each other, making it impossible to place queens on them).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题也可以通过在一个 *n*x*n* 的方格板上工作来推广到 *n* 皇后问题。已知对于所有 *n* 的值都有解，除了 *n*=2（很容易看出原因：放置一个皇后后，整个棋盘都受到威胁）和
    *n*=3（如果你在中心放置一个皇后，整个棋盘都受到威胁，如果你在一边放置一个皇后，只有两个格子不受威胁，但它们相互威胁，使得无法在这两个格子上放置皇后）。
- en: 'Let’s start our solution with top-level logic. Because of the given rules,
    there will be a single queen in each column, so we use a `places` array to take
    note of each queen’s row within the given column. The `SIZE` constant could be
    modified to solve a more general problem. We’ll count each found distribution
    of queens in the `solutions` variable. Finally, the `finder()` function will perform
    the recursive search for solutions. The basic skeleton for the code would be as
    follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶层逻辑开始我们的解决方案。由于给定的规则，每一列将有一个皇后，所以我们使用一个 `places` 数组来记录每个皇后在给定列中的行。`SIZE`
    常量可以修改以解决更一般的问题。我们将在 `solutions` 变量中计算找到的皇后分布。最后，`finder()` 函数将执行解决方案的递归搜索。代码的基本框架如下：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s get into the required logic. When we want to place a queen in a given
    row and column, we must check whether any of the previously placed queens were
    placed on the same row or in a diagonal leading from the row. See *Figure 9**.4*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究所需的逻辑。当我们想要在给定的行和列中放置一个皇后时，我们必须检查之前放置的皇后是否放置在同一行或从该行延伸出的对角线上。参见 *图 9**.4*：
- en: '![Figure 9.4 – Before placing a queen in a column, we must check the previously
    placed queens’ positions](img/Figure_9.4_B19301.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 在一列中放置皇后之前，我们必须检查之前放置的皇后的位置](img/Figure_9.4_B19301.jpg)'
- en: Figure 9.4 – Before placing a queen in a column, we must check the previously
    placed queens’ positions
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 在一列中放置皇后之前，我们必须检查之前放置的皇后的位置
- en: 'Let’s write a `checkPlace(column, row)` function to verify whether a queen
    can be safely placed in the given square. The most straightforward way is by using
    `every()`, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 `checkPlace(column, row)` 函数来验证是否可以在给定的方格中安全地放置一个皇后。最直接的方法是使用 `every()`，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This declarative fashion seems best: when we place a queen in a position, we
    want to ensure that every other previously placed queen is in a different row
    and diagonal. A recursive solution would have been possible too, so let’s see
    that. How do we know that a square is safe?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明式的方法似乎最好：当我们放置一个皇后在某个位置时，我们想要确保每个之前放置的皇后都在不同的行和对角线上。一个递归解决方案也是可能的，所以让我们看看。我们如何知道一个方格是安全的？
- en: A base case is when there are no more columns to check, the square is safe
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况是没有更多的列需要检查，方格是安全的
- en: If the square is in the same row or diagonal as any other queen, it’s not safe
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方格与任何其他皇后的行或对角线相同，则它不安全
- en: If we have checked a column and found no problem, we can now recursively check
    the following one
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们已经检查了一列并且没有发现问题，我们现在可以递归地检查下一列
- en: 'The required alternative code to check whether a position in a column can be
    occupied by a queen is, therefore, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，检查列中的位置是否可以被皇后占据所需的替代代码如下：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code works, but I wouldn’t use it since the declarative version is clearer.
    Anyway, having worked out this check, we can pay attention to the main `finder()`
    logic, which will do the recursive search. The process proceeds as we described
    at the beginning: try out a possible placement for a queen, and if that is acceptable,
    use the same search procedure to try and place the remaining queens. We start
    at column 0, and our base case is when we reach the last column, meaning that
    all queens have been successfully placed: we can print out the solution, count
    it, and go back to search for a new configuration.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是有效的，但我不会使用它，因为声明式版本更清晰。无论如何，在解决了这个检查之后，我们可以关注主要的 `finder()` 逻辑，这将执行递归搜索。过程按照我们最初描述的方式进行：尝试放置一个皇后的可能位置，如果这是可接受的，使用相同的搜索程序尝试放置剩余的皇后。我们从列0开始，我们的基例是当我们到达最后一列时，这意味着所有皇后都已成功放置：我们可以打印出解决方案，计数它，并返回以寻找新的配置。
- en: Getting nice output
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 获得良好的输出
- en: Check out how we use `map()` and a simple arrow function to print the rows of
    the queens, column by column, as numbers between 1 and 8, instead of 0 and 7\.
    In chess, rows are numbered from 1 to 8 (and columns from a to h, but that doesn’t
    matter here).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们如何使用 `map()` 和一个简单的箭头函数来按列打印皇后的行，数字在1到8之间，而不是0和7。在棋类游戏中，行数从1到8编号（列从a到h，但在这里这不重要）。
- en: 'Check out the following code, which applies the logic that we described previously:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码，它应用了我们之前描述的逻辑：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The inner `testRowsInColumn()` function also fulfills an iterative role, but
    recursively. The idea is to attempt placing a queen in every possible row, starting
    at zero: if the square is safe, `finder()` is called to start searching from the
    next column onward. No matter whether a solution was or wasn’t found, all rows
    in the column are tried out because we are interested in the total number of solutions.
    In other search problems, you might be content with finding any solution, and
    you would stop your search there.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的 `testRowsInColumn()` 函数也扮演了迭代角色，但以递归的方式。想法是尝试在每个可能的行放置一个皇后，从零开始：如果方格是安全的，`finder()`
    被调用以从下一列开始搜索。无论是否找到解决方案，都会尝试列中的所有行，因为我们感兴趣的是解决方案的总数。在其他搜索问题中，你可能只满足于找到任何解决方案，并在那里停止搜索。
- en: We have come this far, so let’s find the answer to our problem!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走到这一步，所以让我们找到我们问题的答案！
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each solution is given as the row positions for the queens, column by column,
    and there are 92 solutions in all.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个解决方案都给出了皇后的行位置，按列逐列给出，总共有92个解决方案。
- en: Traversing a tree structure
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历树结构
- en: 'Data structures, which include recursion in their definition, are naturally
    appropriate for recursive techniques. Let’s consider, for example, how to traverse
    a complete filesystem directory, listing all of its contents. Where’s the recursion?
    The answer is straightforward if you consider that each directory can do either
    of the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中包含递归的数据结构自然适用于递归技术。让我们考虑一下，例如，如何遍历完整的文件系统目录，列出其所有内容。递归在哪里？如果你考虑到每个目录都可以执行以下任一操作，答案就很简单：
- en: Be empty—a base case in which there’s nothing to do
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为空——一个没有要执行的事情的基例
- en: Include one or more entries, each of which is either a file or a directory itself
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个或多个条目，每个条目本身是文件或目录
- en: 'Let’s work out a full recursive directory listing—meaning that when we encounter
    a directory, we also list its contents, and if those include more directories,
    we also list them, and so on. We’ll be using the same node functions as in `getDir()`
    (from the *Building pipelines by hand* section in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,
    Connecting Functions*), plus a few more to test whether a directory entry is a
    symbolic link (which we won’t follow to avoid possible infinite loops), a directory
    (which will require a recursive listing), or a common file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决一个完整的递归目录列表——这意味着当我们遇到一个目录时，我们也会列出其内容，如果这些内容中包含更多目录，我们也会列出它们，依此类推。我们将使用与
    `getDir()`（来自[*第8章*](B19301_08.xhtml#_idTextAnchor148)*，手动构建管道*部分）中相同的节点函数，以及一些额外的函数来测试目录条目是否是符号链接（我们不会跟随它以避免可能的无穷循环），是目录（这将需要递归列表）或普通文件：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The listing is long but correct. I opted to list the `/boot` directory in my
    own openSUSE Linux laptop, and this was produced:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表很长但正确。我选择在我的开源SUSE Linux笔记本电脑上列出 `/boot` 目录，结果如下：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can apply the same structure to a similar problem: traversing a DOM structure.
    We could list all of the tags, starting from a given element, using the same approach:
    we list a node and (by applying the same algorithm) all of its children. The base
    case is the same as before: when a node has no children, no more recursive calls
    are made. You can see this in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的结构应用到类似的问题上：遍历DOM结构。我们可以从给定的元素开始，使用相同的方法列出所有标签：我们列出节点，并通过应用相同的算法列出所有子节点。基本情况与之前相同：当一个节点没有子节点时，不再进行递归调用。你可以在下面的代码中看到这一点：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are using the `depth` variable to know how many levels below the original
    element we are. We could also use it to make the traversing logic stop at a certain
    level; in our case, we are using it only to add some bars and spaces to appropriately
    indent each element according to its place in the DOM hierarchy. The result of
    this function is shown in the following code. It would be easy to list more information
    and not just the element tag, but I wanted to focus on the recursive process:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`depth`变量来知道我们距离原始元素有多少层。我们也可以用它来使遍历逻辑在某个级别停止；在我们的例子中，我们只使用它来添加一些横线和空格，以便根据DOM层次结构中的位置适当地缩进每个元素。这个函数的结果在下面的代码中显示。很容易列出更多信息，而不仅仅是元素标签，但我只想关注递归过程：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, there’s an ugly point there: why are we making a loop to go through
    all of the children? We should know better! The problem is that the structure
    we get from the DOM isn’t really an array. However, there’s a way out – we can
    use `Array.from()` to create a real array out of it and then write a more declarative
    solution. The following code solves the problem in a better way:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个丑陋的点：为什么我们要通过循环遍历所有子节点？我们应该知道得更好！问题在于我们从DOM得到的结构实际上并不是一个数组。然而，有一个解决办法——我们可以使用`Array.from()`从它创建一个真正的数组，然后编写一个更声明性的解决方案。下面的代码以更好的方式解决了这个问题：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Writing `[...node.children].forEach()` would have worked as well but using `Array.from()`
    makes it more apparent to any reader that we are trying to make an array out of
    something that looks like one, but really isn’t.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 写`[...node.children].forEach()`也可以，但使用`Array.from()`会让任何读者更清楚地知道我们正在尝试将看起来像数组的东西转换成数组，但实际上并不是。
- en: We have now seen many ideas about the usage of recursion, and we’ve seen many
    applications of it; however, there are some cases in which you may run into problems,
    so let’s now consider some tweaks that may come in handy for specific problems.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多关于递归使用的方法，我们也看到了它的许多应用；然而，有些情况下你可能会遇到问题，所以现在让我们考虑一些可能对特定问题有帮助的调整。
- en: Mutual recursion
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相互递归
- en: Recursion need not be as “simple” and “direct” as having a function that calls
    itself. We can have more complex situations as a set of functions, each of which
    calls one or more of the others but not necessarily calling itself. (However,
    note that this is also allowed.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 递归不必像有一个调用自身的函数那样“简单”和“直接”。我们可以有更复杂的情况，作为一组函数，每个函数调用一个或多个其他函数，但不一定调用自身。（然而，请注意这也是允许的。）
- en: 'Thinking in terms of mutual recursion is harder. For simple recursion, you
    had to imagine you already had a function to do something, and then you used it
    (in itself!) to do that. In mutual recursion, you have to think of a set of functions,
    each of which does its own part by simultaneously depending on all the set of
    functions: the others, and possibly itself as well.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从相互递归的角度思考更困难。对于简单的递归，你必须想象你已经有一个函数来做某事，然后你使用它（本身！）来做那件事。在相互递归中，你必须考虑一组函数，每个函数通过同时依赖于整个函数集（包括其他函数，以及可能包括自身）来完成自己的部分。
- en: Let’s examine a simple case to get our feet wet, and then go for a “real-life”
    application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考察一个简单的案例，然后尝试一个“实际应用”。
- en: Odds and evens
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奇数和偶数
- en: 'How can you determine whether a (not negative) integer number is odd or even?
    This a trivial problem, to be sure (but see *Question 9.11*) but we can get an
    interesting solution if we realize the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何确定一个（非负）整数是奇数还是偶数？这确实是一个简单的问题（但参见*问题9.11*），如果我们意识到以下事实，我们就可以得到一个有趣的解决方案：
- en: Zero is even
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零是偶数
- en: If a number is even, when you subtract 1 from it, you get an odd number
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个数是偶数，当你从它减去1时，你会得到一个奇数
- en: 'A number is odd if it’s not even:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个数不是偶数，那么它是奇数：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'How does this work? Each function (`isEven()` and `isOdd()`) depends on the
    other to produce a result. How do we know that 9 is odd? The calculations are
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？每个函数（`isEven()`和`isOdd()`）都依赖于另一个函数来产生结果。我们如何知道9是奇数？计算如下：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And after the last call, the whole tower of calls gets resolved; 9 is reported
    to be odd (fortunately!)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后调用之后，整个调用塔都会得到解决；9被报告为奇数（幸运的是！）
- en: 'You could say that this actually isn’t a great example of mutual recursion,
    because you could easily replace the code for `isOdd()` in `isEven()` to get single
    recursion versions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说，这实际上不是一个很好的相互递归的例子，因为你可以轻松地替换`isEven()`中的`isOdd()`代码以获得单递归版本：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, we can go about this in another way that will also include mutual
    recursion:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以用另一种方式来做这件事，这也会包括相互递归：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, don’t get to think that mutual recursion can always be simplified away;
    sometimes, that’s not really possible or practical.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要认为相互递归总能被简化掉；有时，这实际上并不可能或不切实际。
- en: 'Going back to the code, it should be evident that no one would implement a
    parity test this way. Still, this example paves the way to implementing a more
    complex function: parsing and evaluating an arithmetic expression, which will
    involve multiple mutually recursive functions, as we’ll see next.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码，应该很明显，没有人会以这种方式实现奇偶性测试。尽管如此，这个例子为实施更复杂的函数铺平了道路：解析和评估算术表达式，这将涉及多个相互递归的函数，正如我们接下来将要看到的。
- en: Doing arithmetic
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行算术运算
- en: Let’s see a more complete problem, which also happens to (frequently!) appear
    online, with puzzles as in *Figure 9**.5*. We’ll implement a set of mutually recursive
    functions that can correctly evaluate an arithmetic expression according to standard
    precedence rules for operators.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更完整的问题，这个问题也经常（！）在网上出现，如图*图9.5*中的谜题。我们将实现一组相互递归的函数，这些函数可以按照运算符的标准优先级规则正确评估算术表达式。
- en: '![Figure 9.5 – Common puzzles call for evaluating arithmetic expressions](img/Figure_9.5_B19301.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 常见谜题要求评估算术表达式](img/Figure_9.5_B19301.jpg)'
- en: Figure 9.5 – Common puzzles call for evaluating arithmetic expressions
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 常见谜题要求评估算术表达式
- en: 'To solve this, we’ll first see a tool that lets us correctly process operations:
    *railroad diagrams*. We want to evaluate an expression, and we can say that an
    expression is either one single term, or several terms added or subtracted. *Figure
    9**.6* shows this graphically. Imagine the arrows are railroad tracks, and any
    path you follow that starts at the left and eventually ends at the right represents
    a possible expression.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们首先将看到一个工具，它让我们能够正确处理操作：*铁路图*。我们想要评估一个表达式，我们可以这样说，一个表达式要么是一个单独的项，要么是几个项相加或相减。*图9.6*以图形方式展示了这一点。想象箭头是铁路轨道，你遵循的任何从左到右的路径都代表一个可能的表达式。
- en: '![Figure 9.6 – A railroad syntax diagram for arithmetic expressions](img/Figure_9.6_B19301.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 算术表达式的铁路语法图](img/Figure_9.6_B19301.jpg)'
- en: Figure 9.6 – A railroad syntax diagram for arithmetic expressions
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 算术表达式的铁路语法图
- en: Now, what’s a term? A term is either a single factor, or the result of multiplying,
    dividing, or using modulus operations on several factors, as shown in *Figure
    9**.7*. Note that with these two rules, *2*3+5* is correctly evaluated as *(2*3)+5*,
    because *2*3* and *5* are terms.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，什么是项？项要么是一个单一因子，要么是通过对多个因子进行乘法、除法或取模运算的结果，如图*图9.7*所示。注意，根据这两条规则，*2*3+5*被正确地评估为*(2*3)+5*，因为*2*3*和*5*是项。
- en: '![Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus
    are performed before addition or subtraction](img/Figure_9.7_B19301.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 项的铁路语法：乘法、除法和取模运算在加法或减法之前执行](img/Figure_9.7_B19301.jpg)'
- en: 'Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus
    are performed before addition or subtraction'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 项的铁路语法：乘法、除法和取模运算在加法或减法之前执行
- en: We need one more diagram, for factors. A factor can be a single number or an
    expression between parentheses. We’ll allow an optional minus sign at the beginning,
    so -3 is accepted. *Figure 9**.8* shows the needed diagram.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个图，用于因子。因子可以是一个单独的数字或括号内的表达式。我们将在开头允许一个可选的负号，因此-3是被接受的。*图9.8*显示了所需的图。
- en: '![Figure 9.8 – A factor starts with an optional minus sign, and can be a number
    or an expression within parentheses](img/Figure_9.8_B19301.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 因子以可选的负号开头，可以是数字或括号内的表达式](img/Figure_9.8_B19301.jpg)'
- en: Figure 9.8 – A factor starts with an optional minus sign, and can be a number
    or an expression within parentheses
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 因子以可选的负号开头，可以是数字或括号内的表达式
- en: 'We’ll implement the needed evaluation with three functions, one for each diagram.
    In the usual compiler or interpreter code, we have a first phase that reads the
    input and splits it into *tokens*, and a second phase that processes those tokens
    to do whatever’s needed. In our case, the tokens will be numbers (single digits,
    for simplicity), operators, and parentheses. The code we’ll write is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三个函数来实现所需的评估，每个函数对应一个图。在常规的编译器或解释器代码中，我们有一个读取输入并将其拆分为*标记*的第一阶段，以及一个处理这些标记以执行所需操作的第二阶段。在我们的情况下，标记将是数字（单个数字，为了简单起见）、运算符和括号。我们将编写的代码如下：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We define some constants (`PLUS`, `MINUS`, etc.) for clarity. Given a string
    such as `"7+7/7+7*7-7"`, we split it into the tokens array; we take care to evaluate
    digits. Finally, we have a `curr` variable pointing to the token being processed
    right now. The evaluation of the input expression will be done by three functions
    that will use mutual recursion:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一些常量（`PLUS`、`MINUS`等）以提高清晰度。给定一个如`"7+7/7+7*7-7"`的字符串，我们将其拆分为标记数组；我们注意评估数字。最后，我们有一个`curr`变量指向当前正在处理的标记。输入表达式的评估将由三个函数完成，这些函数将使用相互递归：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `expression()` function first calls `term()` to get the value of the first
    term and then loops if an addition or subtraction is found. In our case, this
    means that the function would first evaluate a 7, then add 7/7, then also add
    7*7, and finally subtract the last 7\. (And yes, the result is 50.) After a token
    is processed, `curr` is incremented to continue with the rest of the tokens.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`expression()`函数首先调用`term()`来获取第一个项的值，如果发现加法或减法，则循环。在我们的例子中，这意味着函数首先评估一个7，然后加上7/7，接着也加上7*7，最后减去最后的7。
    (是的，结果是50。)处理完一个标记后，`curr`会增加以继续处理剩余的标记。'
- en: 'The code for `term()` is similar in style; the only difference is how it works
    with multiplication, and so on:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`term()`的代码风格相似；唯一的区别是它如何处理乘法等：'
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This function would be called to evaluate 7, then 7/7, then 7*7, and finally
    another 7.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会被调用以评估7，然后是7/7，接着是7*7，最后再是另一个7。
- en: 'Finally, `factor()` is a tad different:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`factor()`略有不同：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `mult` variable will be `-1` if an initial minus sign was present, or `+1`
    otherwise. We have no loops here, and just an alternative: if a left parenthesis
    is seen, we skip it, recursively evaluate the included expression, skip the right
    parenthesis, and return the value of the expression. The alternative is that we
    have a number, which we return. Whatever we return, we’ll multiply by the `mult`
    value to produce the correct result.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在初始减号，`mult`变量将是`-1`，否则是`+1`。这里没有循环，只有一个选择：如果看到一个左括号，我们跳过它，递归地评估包含的表达式，跳过右括号，并返回表达式的值。另一种情况是我们有一个数字，我们返回它。无论我们返回什么，我们都会乘以`mult`值以产生正确的结果。
- en: If you analyze the recursive calls, we have `expression()` calling `term()`,
    which calls `factor()`, which calls `recursive()` – a cycle of three! Mutual recursion
    is harder to understand and to get right because to plan such code, you must foresee
    what several functions will do. However, for the right problems (as shown here),
    it’s a very powerful technique.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分析递归调用，我们有`expression()`调用`term()`，`term()`调用`factor()`，`factor()`调用`recursive()`——这是一个三重的循环！相互递归更难理解且更难正确实现，因为编写此类代码时，你必须预见几个函数将做什么。然而，对于正确的问题（如这里所示），它是一个非常强大的技术。
- en: Recursion techniques
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归技术
- en: While recursion is a very good technique, you may face some problems because
    of the way it is internally implemented. Each function call, recursive or not,
    requires an entry in the internal JavaScript stack. When you are working with
    recursion, each recursive call itself counts as another call, and you might find
    that there are some situations in which your code will crash and throw an error
    because it ran out of memory, just because of multiple calls. On the other hand,
    with most current JavaScript engines, you can probably have several thousand pending
    recursive calls without a problem – but with earlier browsers and smaller machines,
    the number could drop into the hundreds and feasibly go even lower. Thus, it could
    be argued that, at present, you are not likely to suffer from any particular memory
    problems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然递归是一种非常好的技术，但你可能会因为其内部实现的方式而遇到一些问题。每个函数调用，无论是递归的还是非递归的，都需要在JavaScript的内部栈中有一个条目。当你使用递归时，每个递归调用本身又算作另一个调用，你可能会发现，在某些情况下，你的代码会因为多次调用而崩溃并抛出错误，仅仅是因为内存不足。另一方面，在大多数当前的JavaScript引擎中，你可能有几千个挂起的递归调用而不会出现问题——但在早期的浏览器和较小的机器上，这个数字可能会降到几百，甚至更低。因此，可以认为，目前你不太可能遇到任何特定的内存问题。
- en: 'In any case, let’s review the problem and go over some possible solutions in
    the following sections. Even if you don’t get to actually apply them, they represent
    valid FP ideas for which you may find a place in yet other problems. We will be
    looking at the following solutions:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们在接下来的几节中回顾一下问题，并探讨一些可能的解决方案。即使你实际上无法应用它们，它们也代表了有效的FP（函数式编程）思想，你可能在其他问题中找到它们的应用。我们将探讨以下解决方案：
- en: '**Tail call optimization**, a technique that speeds up recursion **continuation-passing
    style** (**CPS**), an important FP technique that can help with recursion'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾调用优化**，一种加快递归**传递风格**（**CPS**）的技术，是函数式编程中的一个重要技术，可以帮助处理递归'
- en: A couple of interestingly named techniques, **trampolines** and **thunks**,
    which are also standard FP tools
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种有趣命名的技术，**跳板**和**thunks**，它们也是标准的FP工具
- en: '**Recursion elimination**, a technique beyond this book’s scope, but which
    may still be applied'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归消除**，一种超出本书范围的技术，但仍然可以应用'
- en: Tail call optimization
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: 'When is a recursive call not a recursive call? Put this way, the question may
    make little sense, but there’s a common optimization—for other languages, alas,
    but not JavaScript!—that explains the answer. If the recursive call is the very
    last thing a function will do, then the call could be transformed into a simple
    jump to the start of the function without needing to create a new stack entry.
    (Why? The stack entry wouldn’t be required: after the recursive call is done,
    the function would have nothing else to do, so there is no need to further save
    any of the elements that have been pushed into the stack upon entering the function.)
    The original stack entry would then no longer be needed and could be replaced
    by a new one, corresponding to the recent call.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个递归调用不是递归调用时？这样表述，这个问题可能没有太多意义，但有一个常见的优化——对于其他语言来说，遗憾的是，但不是JavaScript！——可以解释答案。如果递归调用是函数将要做的最后一件事，那么这个调用可以转换成一个简单的跳转到函数的开始，而不需要创建一个新的栈条目。（为什么？栈条目是不需要的：递归调用完成后，函数就没有其他事情要做了，因此没有必要进一步保存函数进入时推入栈中的任何元素。）原始的栈条目就不再需要了，可以被一个新的条目所取代，对应于最近的调用。
- en: Implementation irony
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 实现讽刺
- en: The fact that a recursive call, a quintessential FP technique, is being implemented
    by a base imperative `GO` `TO` statement can be considered an ultimate irony!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用，一种典型的FP技术，被一个基本的命令式`GO` `TO`语句实现，这可以被认为是一种终极讽刺！
- en: These calls are known as **tail calls** (for obvious reasons) and have higher
    efficiency, not only because of the saved stack space but also because a jump
    is quite a bit faster than any alternative. If the browser implements this enhancement,
    it uses **tail call optimization** (**TCO**); however, a glance at the compatibility
    tables at [kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    shows that at the time of writing (at the end of 2022), the only browser that
    provides TCO is Safari.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用被称为**尾调用**（出于显而易见的原因）并且效率更高，不仅因为节省了栈空间，而且因为跳转比任何其他替代方案都要快得多。如果浏览器实现了这个增强功能，它将使用**尾调用优化**（**TCO**）；然而，查看[kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)上的兼容性表格，在撰写本文时（2022年底），唯一提供TCO的浏览器是Safari。
- en: '![Figure 9.9 – To understand this joke, you must have previously understood
    it!](img/Figure_9.9_B19301.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 要理解这个笑话，你必须先理解它！](img/Figure_9.9_B19301.jpg)'
- en: Figure 9.9 – To understand this joke, you must have previously understood it!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 要理解这个笑话，你必须先理解它！
- en: 'A simple (though non-standard) test lets you verify whether your browser provides
    TCO. I found this snippet of code in several places on the web, but I’m sorry
    to say, I cannot attest to the original author, although I believe it is Csaba
    Hellinger from Hungary. Calling `detectTCO()` lets you know whether your browser
    does or does not use TCO:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的（尽管是非标准的）测试可以让你验证你的浏览器是否提供 TCO。我在网上找到了这段代码的几个地方，但我很抱歉不能证明原始作者的姓名，尽管我相信它是来自匈牙利的
    Csaba Hellinger。调用 `detectTCO()` 会让你知道你的浏览器是否使用 TCO：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Error().stack` result is not a JavaScript standard, but modern browsers
    support it, albeit in somewhat different ways. (I had to add the “`!`” symbol
    so TypeScript would accept that `stack` would be present.) In any case, the idea
    is that when a function with a long name calls another function with a shorter
    name, the stack trace should do the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error().stack` 的结果不是 JavaScript 标准，但现代浏览器支持它，尽管方式略有不同。（我不得不添加“`!`”符号，这样 TypeScript
    才会接受 `stack` 会存在。）无论如何，想法是当一个具有长名称的函数调用另一个具有短名称的函数时，堆栈跟踪应该执行以下操作：'
- en: It should get shorter if the browser implements TCO, since the old entry for
    the longer-named function would be replaced with the entry for the shorter-named
    one
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果浏览器实现了 TCO，它应该会变得更短，因为较长的函数名称的旧条目将被较短的函数名称的条目所替换
- en: It should get longer without TCO, since a completely new stack entry would be
    created without doing away with the original one
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有尾调用优化（TCO）的情况下，它应该会变得更长，因为没有消除原始的栈条目，就会创建一个新的完全新的栈条目
- en: 'I’m using Chrome on my Linux laptop, and I added a `console.log()` statement
    to show `Error().stack`. You can see that both stack entries (for `inner()` and
    `detectTCO()`) are *live*, so there’s no TCO:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的 Linux 笔记本电脑上使用 Chrome，并添加了一个 `console.log()` 语句来显示 `Error().stack`。你可以看到两个栈条目（`inner()`
    和 `detectTCO()`）都是 *活跃的*，所以没有 TCO：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, there’s another way of learning whether your environment includes
    TCO: try out the following function (which does nothing!) with large enough numbers.
    If you manage to run it with numbers such as, say, 100,000 or 1,000,000, you can
    be reasonably sure that your JavaScript engine is doing TCO! A possible such function
    could be the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有另一种方法来了解你的环境是否包括 TCO：尝试以下（实际上什么也不做！）函数，使用足够大的数字。如果你能够用像 100,000 或 1,000,000
    这样的数字运行它，你可以合理地确信你的 JavaScript 引擎正在执行 TCO！一个可能的函数如下：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let’s finish this section with a very short quiz to ensure we understand what
    tail calls are. Is the recursive call in the factorial function we saw in [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, (but here written
    in TypeScript) a tail call?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简短的测验来结束这一节，以确保我们理解什么是尾调用。我们在 [*第 1 章*](B19301_01.xhtml#_idTextAnchor015)
    “成为函数式程序员”（但在这里用 TypeScript 编写）中看到的阶乘函数中的递归调用是尾调用吗？
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Think about it, because the answer is important! You might be tempted to answer
    in the affirmative, but the correct answer is *no*. There’s a good reason for
    this, and it’s a key point: after the recursive call is done and the value for
    `fact(n-1)` has been calculated, the function still has work to do. (So doing
    the recursive call wasn’t actually the last thing that the function would do.)
    You can see it more clearly if you write the function in this equivalent way:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想，因为答案很重要！你可能倾向于肯定回答，但正确答案是 *否*。这有一个很好的原因，并且是一个关键点：在递归调用完成后，并且已经计算出 `fact(n-1)`
    的值之后，函数仍然有工作要做。（所以递归调用实际上并不是函数要做的最后一件事。）如果你以这种方式写函数，你可以更清楚地看到这一点：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There should be two takeaways from this section: TCO isn’t usually offered
    by browsers, and even if it were, you cannot take advantage of it if your calls
    aren’t actual tail calls. Now that we know what the problem is, let’s see some
    FP ways of working around it!'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一节中应该有两个要点：浏览器通常不提供 TCO，即使提供了，如果你的调用不是实际的尾调用，你也无法利用它。既然我们已经知道了问题是什么，让我们看看一些函数式编程的方法来绕过它！
- en: Continuation-passing style
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Continuation-passing style
- en: We already know that our logic will fail if we have recursive calls stacked
    too high. On the other hand, we know that tail calls should alleviate that problem,
    but they don’t because of browser implementations! However, there’s a way out
    of this. Let’s first consider how we can transform recursive calls into tail calls
    by using a well-known FP concept—**continuations**—and we’ll leave the problem
    of solving TCO limitations for the next section. (We mentioned continuations in
    [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*,
    but we didn’t go into detail.)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，如果我们有堆叠太高的递归调用，我们的逻辑将会失败。另一方面，我们知道尾递归应该减轻这个问题，但由于浏览器的实现，它们并没有这样做！然而，有一种解决办法。让我们首先考虑如何通过使用一个著名的FP概念——**延续**——将递归调用转换为尾递归调用，然后我们将把解决TCO限制的问题留到下一节。（我们在[*第三章*](B19301_03.xhtml#_idTextAnchor054)，*从函数开始*中提到了延续，但没有深入探讨。）
- en: In FP parlance, a continuation represents the state of a process and allows
    processing to continue. This may be too abstract, so let’s see what this means.
    The key idea is that when you call a function, you also provide it with a continuation
    (in reality, a simple function) that will be called at return time.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP术语中，一个表示进程状态的延续允许处理继续。这可能太抽象了，所以让我们看看这意味着什么。关键思想是当你调用一个函数时，你也提供了一个将在返回时被调用的延续（实际上是一个简单的函数）。
- en: 'Let’s look at a trivial example. Suppose you have a function that returns the
    time of the day, and you want to show this on the console. The usual way to do
    this could be as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子。假设你有一个返回一天中时间的函数，并且你想要在控制台上显示这个时间。通常的做法可能是如下所示：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you were doing CPS, you would pass a continuation to the `getTime()` function.
    Instead of returning a calculated value, the function would invoke the continuation,
    giving it the value as a parameter:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在做CPS，你会将一个延续传递给`getTime()`函数。而不是返回一个计算值，函数将调用延续，并将值作为参数传递：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'What’s the difference? The key is that we can apply this mechanism to make
    a recursive call into a tail call because all of the code that comes after will
    be provided in the recursive call itself. To make this clear, let’s revisit the
    factorial function in the version that made it explicit that we weren’t doing
    tail calls:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么区别？关键是我们可以应用这个机制将递归调用转换为尾递归调用，因为所有后续的代码都将由递归调用本身提供。为了使这一点更清楚，让我们回顾一下显式表示我们不是在执行尾递归的阶乘函数版本：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will add a new parameter to the function for the continuation. What do we
    do with the result of the `fact(n-1)` call? We multiply it by `n`, so let’s provide
    a continuation that will do just that. I’ll rename the factorial function as `factC()`
    to make it clear that we are working with continuations, as shown in the following
    code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向函数添加一个新的延续参数。`fact(n-1)`调用的结果我们如何处理？我们将它乘以`n`，所以让我们提供一个将执行这一操作的延续。我将阶乘函数重命名为`factC()`，以清楚地表明我们正在处理延续，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'How would we get the final result? Easy – we can call `factC()` with a continuation
    that will return whatever it’s given:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到最终结果呢？很简单——我们可以调用`factC()`，并传递一个将在返回时返回其给定内容的延续：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Identity combinator
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符组合子
- en: In FP, a function that returns its argument as a result is usually called `identity()`
    for obvious reasons. In combinatory logic (which we won’t be using), we would
    speak of the **I combinator**.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，一个返回其参数作为结果的函数通常被称为`identity()`，这是显而易见的。在组合逻辑（我们不会使用）中，我们会提到**I组合子**。
- en: 'Can you understand how it worked? Then let’s try out a more complex case with
    the Fibonacci function, which has two recursive calls in it, as shown in the following
    highlighted code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你能理解它是如何工作的吗？那么让我们尝试一个更复杂的案例，使用斐波那契函数，它包含两个递归调用，如下所示的高亮代码：
- en: '[PRE53]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is trickier: we call `fibC()` with `n-2` and a continuation that says
    that whatever that call returned, call `fibC()` with `n-1`, and when *that* call
    returns, sum the results of both calls and pass that result to the original continuation.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这更复杂：我们用`n-2`和说无论那个调用返回什么，都调用`fibC()`，并且当*那个*调用返回时，将两个调用的结果相加，并将那个结果传递给原始延续。
- en: Let’s see just one more example, involving a loop with an undefined number of
    recursive calls. By then, you should have some idea about how to apply CPS to
    your code—though I’ll readily admit it can become really complex!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看一个例子，这个例子涉及一个具有未定义递归调用次数的循环。到那时，你应该对如何将CPS应用到你的代码中有所了解——尽管我必须承认这可能会变得非常复杂！
- en: 'Earlier in this chapter, we saw this function in the *Traversing a tree structure*
    section. The idea was to print out the DOM structure, like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的*遍历树结构*部分，我们看到了这个函数。想法是打印出DOM结构，如下所示：
- en: '[PRE54]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The function we ended up designing back then was the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当时设计的函数如下：
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let’s start by making this fully recursive, getting rid of the `forEach()`
    loop. We have seen this technique before, so we can move on to the following result;
    note how the following code forms its loops by using recursion. Also, note we
    added lots of `return` statements, even if they are not really needed; we’ll see
    the reason for this soon:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从使其完全递归开始，去掉`forEach()`循环。我们之前已经见过这种技术，所以我们可以继续到以下结果；注意以下代码是如何通过递归形成循环的。此外，注意我们添加了很多`return`语句，即使它们实际上并不需要；我们很快就会看到这样做的原因：
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we have to add a continuation to `traverseDom3()`. The only difference
    from the previous cases is that the function doesn’t return anything, so we won’t
    pass any arguments to the continuation. It’s also important to remember the implicit
    return at the end of the `traverseChildren()` loop; we must call the continuation:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须向`traverseDom3()`添加一个延续。与之前的情况唯一的不同是，该函数不返回任何内容，所以我们不会向延续传递任何参数。还要记住`traverseChildren()`循环末尾的隐式返回；我们必须调用延续：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We opted to give a default value to `cont`, so we can call `traverseDom3C(document.body)`
    as before. If we try out this logic, it works, but the problem of the potentially
    high number of pending calls hasn’t been solved; let’s look for a solution to
    this in the following section.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择为`cont`提供一个默认值，这样我们就可以像以前一样调用`traverseDom3C(document.body)`。如果我们尝试这个逻辑，它是可行的，但尚未解决潜在的高数量挂起调用的问题；让我们在下一节中寻找这个问题的解决方案。
- en: Trampolines and thunks
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳床和thunks
- en: For the last solution to our problem, we shall have to think about the cause
    of the problem. Each pending recursive call creates a new entry stack. Whenever
    the stack gets too empty, the program crashes, and our algorithm is history. So,
    if we can work out a way to avoid stack growth, we should be free. The solution,
    in this case, is quite imposing and requires *thunks* and a *trampoline*—let’s
    see what these are!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们问题的最后一个解决方案，我们必须考虑问题的原因。每个挂起的递归调用都会创建一个新的栈条目。每当栈变得太空时，程序就会崩溃，我们的算法就结束了。所以，如果我们能想出一个避免栈增长的方法，我们就应该自由了。在这种情况下，解决方案相当强有力，需要*thunks*和*trampoline*——让我们看看它们是什么！
- en: 'First, a `new Date().toISOString()`; however, if you provide a thunk that calculates
    that, you won’t get the value until you actually invoke it:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个`new Date().toISOString()`；然而，如果你提供一个计算这个值的thunk，你只有在实际调用它时才会得到值：
- en: '[PRE58]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: What’s the use of this? The problem with recursion is that a function calls
    itself, and calls itself, and calls itself, and so on until the stack blows over.
    Instead of directly calling itself, we will have the function return a thunk,
    which, when executed, will actually recursively call the function. So, instead
    of having the stack grow more and more, it will actually be quite flat since the
    function will never get to actually call itself; the stack will grow by one position
    when you call the function, and then get back to its size as soon as the function
    returns its thunk.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用？递归的问题在于一个函数会调用自己，然后再次调用自己，然后再次调用自己，如此等等，直到栈溢出。我们不会直接调用自己，而是让函数返回一个thunk，当它执行时，实际上会递归地调用函数。因此，而不是让栈越来越长，它实际上会非常平坦，因为函数永远不会真正调用自己；当你调用函数时，栈会增加一个位置，然后当函数返回其thunk时，它会立即回到其大小。
- en: 'But who gets to do the recursion? That’s where the concept of a **trampoline**
    comes in. A trampoline is just a loop that calls a function, gets its return,
    and if it is a thunk, then it calls it so that recursion will proceed, but in
    a flat, linear way! The loop is exited when the thunk evaluation returns an actual
    value instead of a new function. Look at the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但谁来做递归呢？这就是**trampoline**概念出现的地方。trampoline只是一个循环，它调用一个函数，获取其返回值，如果它是一个thunk，那么它会调用它，以便递归继续，但以一种平坦、线性的方式！当thunk评估返回一个实际值而不是新函数时，循环才会退出。看看以下代码：
- en: '[PRE59]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'How can we apply this to an actual function? Let’s start with a simple one
    that sums all numbers from 1 to *n*, but in a recursive, guaranteed-to-cause-a-stack-crash
    fashion. Our simple `sumAll()` function could be the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个应用到实际函数中？让我们从一个简单的函数开始，该函数从1加到*n*，但以递归、保证导致栈崩溃的方式。我们的简单`sumAll()`函数可能是以下这样：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, if we start trying this function out, we’ll eventually stumble and
    crash, as you can see in the following examples:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们开始尝试这个函数，我们最终会出错并崩溃，如下面的示例所示：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The stack problem will come up sooner or later depending on your machine, its
    memory size, and so on – but it will come, no doubt. Let’s rewrite the function
    in CPS so that it will become tail-recursive. We will apply the same technique
    that we saw earlier, as shown in the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 栈问题迟早会出现，这取决于你的机器、内存大小等因素——但无疑它会出现的。让我们用 CPS（Continuation Passing Style）重写这个函数，使其成为尾递归。我们将应用之前看到的相同技术，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This, however, crashes as before; eventually, the stack grows too much. Let’s
    apply a simple rule to the code: whenever you are going to return from a call,
    instead, return a thunk that will, when executed, do the call that you actually
    wanted to do. The following code implements that change:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然会像之前一样崩溃；最终，栈增长过多。让我们给代码应用一个简单的规则：每当你即将从调用返回时，相反，返回一个 thunk，当它执行时，将执行你实际上想要做的调用。以下代码实现了这个更改：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Whenever there would have been a call to a function, we now return a thunk.
    How do we get to run this function? This is the missing detail. You need an initial
    call that will invoke `sumAllT()` the first time, and (unless the function was
    called with a zero argument) a thunk will be immediately returned. The `trampoline`
    function will call the thunk, and that will cause a new call, and so on until
    we eventually get a thunk that just returns a value, and then the calculation
    will be ended:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每当原本要调用一个函数时，我们现在返回一个 thunk。我们如何运行这个函数呢？这是缺失的细节。你需要一个初始调用，它将第一次调用 `sumAllT()`，并且（除非函数是用零个参数调用的）将立即返回一个
    thunk。`trampoline` 函数将调用这个 thunk，这将导致新的调用，以此类推，直到我们最终得到一个只返回值的 thunk，然后计算将结束：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In fact, you probably wouldn’t want a separate `sumAllT()` function, so you’d
    go for something like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能不希望有一个单独的 `sumAllT()` 函数，所以你会选择类似以下这样的方案：
- en: '[PRE65]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There’s only one problem left: what would we do if the result of our recursive
    function wasn’t a value but rather a function? The problem there would be on the
    `trampoline()` code that, as long as the result of the thunk evaluation is a function,
    goes back again and again to evaluate it. The simplest solution would be to return
    a thunk, but wrapped in an object, as shown in the following code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一问题是：如果我们的递归函数的结果不是一个值而是一个函数，我们会怎么办？问题将出现在 `trampoline()` 代码上，只要 thunk 评估的结果是一个函数，它就会一次又一次地返回去评估它。最简单的解决方案是返回一个
    thunk，但包裹在一个对象中，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The difference now would be that, instead of returning a thunk, you’d return
    a `Thunk` object, so our new trampolining function can now distinguish an actual
    thunk (which is meant to be invoked and executed) from any other kind of result
    (which is meant to be returned).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的区别是，你将返回一个 `Thunk` 对象，而不是返回一个 thunk，这样我们新的 trampolining 函数就可以区分实际的 thunk（它被期望被调用和执行）和任何其他类型的结果（它被期望被返回）。
- en: 'So, if you happen to have a recursive algorithm, but it won’t run because of
    stack limits, you can fix it reasonably by going through the following steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你有一个递归算法，但由于栈限制而无法运行，你可以通过以下步骤合理地修复它：
- en: Change all recursive calls to tail recursion using continuations.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用延续将所有递归调用改为尾递归。
- en: Replace all `return` statements so that they’ll return thunks.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有 `return` 语句替换，使它们返回 thunks。
- en: Replace the call to the original function with a `trampoline` call to start
    the calculations.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对原始函数的调用替换为 `trampoline` 调用来开始计算。
- en: Of course, this doesn’t come for free. You’ll notice that, when using this mechanism,
    there’s extra work involving returning thunks, evaluating them, and so on, so
    you can expect the total time to go up. Nonetheless, this is a low price to pay
    if the alternative is having a non-working solution to a problem!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是免费的。你会注意到，当使用这个机制时，会有额外的开销，包括返回 thunks、评估它们等等，所以你可以预期总时间会增加。尽管如此，如果替代方案是有一个无法解决问题的解决方案，这仍然是一个低廉的代价！
- en: Recursion elimination
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归消除
- en: There’s yet one other possibility that you might want to explore, but that falls
    beyond the realm of FP and into algorithm design. It’s a computer science fact
    that any algorithm implemented using recursion has an equivalent version that
    doesn’t use recursion at all, and instead depends on a stack. There are ways to
    systematically transform recursive algorithms into iterative ones, so if you run
    out of all options (that is, if not even continuations or thunks can help you),
    then you’d have a final opportunity to achieve your goals by replacing all recursion
    with iteration. We won’t be getting into this—as I said, this elimination has
    little to do with FP—but it’s important to know that the tool exists and that
    you might be able to use it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种你可能想要探索的可能性，但它超出了FP（函数式编程）的范畴，进入了算法设计的领域。在计算机科学中，任何使用递归实现的算法都有一个不使用递归的等价版本，而是依赖于栈。有方法可以将递归算法系统地转换为迭代算法，所以如果你已经用尽了所有选项（也就是说，即使延续或thunks也无法帮助你），那么你就有最后一个机会通过将所有递归替换为迭代来实现你的目标。我们不会深入探讨这一点——正如我所说的，这种消除与FP关系不大——但重要的是要知道这个工具存在，你可能能够使用它。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how we can use recursion, a basic tool in FP, as a powerful
    technique to create algorithms for problems that would probably require far more
    complex solutions otherwise. We started by considering what recursion is and how
    to think recursively in order to solve problems, then moved on to see some recursive
    solutions to several problems in different areas, and ended by analyzing potential
    problems with deep recursion and how to solve them.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用递归，这是FP（函数式编程）的一个基本工具，作为一种强大的技术来创建算法，这些算法在其他情况下可能需要更复杂的解决方案。我们首先考虑了递归是什么以及如何以递归的方式思考问题，然后看到了一些不同领域问题的递归解决方案，最后分析了深递归可能存在的问题以及如何解决它们。
- en: In [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, we shall
    get back to a concept we saw earlier in the book, function purity, and see some
    techniques that will help us guarantee that a function won’t have any side effects
    by ensuring the immutability of arguments and data structures.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19301_10.xhtml#_idTextAnchor188) *确保纯净性*中，我们将回到本书中较早出现的一个概念，即函数纯净性，并看到一些技术，这些技术将帮助我们通过确保参数和数据结构的不可变性来保证函数不会产生任何副作用。
- en: Questions
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '9.1 `reverse(str: string)` function but implement it in a recursive fashion?
    The best way to do this would be using the standard string `reverse()` method,
    as detailed in [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse),
    but that wouldn’t do for a question on recursion, would it?'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '9.1 如何以递归方式实现`reverse(str: string)`函数？最好的方法就是使用标准的字符串`reverse()`方法，如[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)中详细说明的那样，但这对于一个关于递归的问题来说是不够的，对吧？'
- en: '9.2 **Climbing steps**: Suppose you want to climb up a ladder with *n* steps.
    Each time you raise your foot, you may climb up one or two rungs. In how many
    different ways can you climb up that ladder? For example, you can climb a four-rung
    ladder in five different ways:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 9.2 **爬楼梯**：假设你想要爬上有*n*个台阶的楼梯。每次你抬起脚，你可以爬上一阶或两阶。你有多少种不同的方式可以爬上那个楼梯？例如，你可以用五种不同的方式爬上四阶楼梯：
- en: Always take one step at a time
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次只迈一步
- en: Always take two steps at a time
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次总是迈两步
- en: Take two steps first, then one, and then one
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先迈两步，然后迈一步，再迈一步
- en: Take one step first, then two, and then one
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先迈一步，然后迈两步，再迈一步
- en: Take one step first, then another one, and finish with two
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先迈一步，然后迈另一步，最后迈两步
- en: '9.3 **Sorting recursively**: Many sorting algorithms can be described with
    recursion; can you implement them?'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 9.3 **递归排序**：许多排序算法可以用递归来描述；你能实现它们吗？
- en: '**Selection sort**: Find the maximum element of the array, remove it, recursively
    sort the rest, and then push the maximum element to the end of the sorted rest'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择排序**：找到数组的最大元素，移除它，递归地对剩余部分进行排序，然后将最大元素推到已排序剩余部分的末尾'
- en: '**Insertion sort**: Take the first element of the array, sort the rest, and
    finish by inserting the removed element into its correct place in the sorted rest'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入排序**：取数组的第一个元素，对剩余的元素进行排序，最后将移除的元素插入到已排序剩余部分的正确位置'
- en: '**Merge sort**: Divide the array into two parts, sort each one, and finish
    by merging the two sorted parts into a sorted list'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归并排序**：将数组分为两部分，对每一部分进行排序，最后将两个已排序的部分合并成一个有序列表'
- en: '9.4 `greaterEqual`. Can you foresee any possible problems with this? The following
    code highlights the changes that the developer made with regard to the original
    version we saw earlier:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 9.4 `greaterEqual`。你能预见任何可能的问题吗？以下代码突出了开发者与我们之前看到的原始版本所做的更改：
- en: '[PRE67]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '9.5 `quicksort()` more efficient by avoiding having to call `filter()` twice.
    Along the lines of what we saw in the *Calculating several values at once* section
    in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    write a `partition(arr, pr)` function that, given an `arr` array and an `fn()`
    predicate, will return two arrays: the values of `arr` for which `fn` is true
    in the first one, and the rest of the values of `arr` in the second one:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 9.5 通过避免两次调用`filter()`来使`quicksort()`更高效。类似于我们在[*第5章*](B19301_05.xhtml#_idTextAnchor084)中看到的“同时计算多个值”部分，*声明式编程*，编写一个`partition(arr,
    pr)`函数，给定一个`arr`数组和一个`fn()`谓词，将返回两个数组：第一个数组包含`arr`中`fn`为真的值，第二个数组包含`arr`中其余的值：
- en: '[PRE68]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 9.6 `findR()` function, we did not provide all possible parameters to the `cb()`
    callback. Can you fix that? Your solution should be along the lines of what we
    did for `map()` and other functions. (And yes, if you can also allow for empty
    places in the array, it would be even better.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 9.6 `findR()`函数，我们没有提供所有可能的参数给`cb()`回调。你能修复这个问题吗？你的解决方案应该类似于我们为`map()`和其他函数所做的那样。（而且，如果你还能允许数组中有空位，那就更好了。）
- en: '9.7 `every()` and `some()` using recursion: can you do that?'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 9.7 使用递归实现`every()`和`some()`：你能做到吗？
- en: '9.8 **Symmetrical queens**: In the eight queens puzzle we previously solved,
    only one solution shows symmetry in the placement of the queens. Can you modify
    your algorithm to find it?'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 9.8 **对称的皇后**：在我们之前解决的八皇后问题中，只有一个解决方案显示了皇后的放置对称性。你能修改你的算法来找到它吗？
- en: 9.9 `INTERNATIONAL` and `CONTRACTOR` is `N...T...R...A...T...O`. Try it out
    with and without memoizing and see the difference!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 9.9 `INTERNATIONAL`和`CONTRACTOR`是`N...T...R...A...T...O`。尝试使用和不用memoizing来运行它，看看有什么区别！
- en: 9.10 `isOdd()`? There are quite a few!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 9.10 `isOdd()`？有很多！
- en: 9.11 `isOdd()` and `isEven()` using a trampoline to avoid stack overflow problems.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 9.11 使用trampoline来避免栈溢出问题实现`isOdd()`和`isEven()`。
- en: 9.12 `isEven()`/`isOdd()` was as follows, but it had a serious bug; can you
    find it?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 9.12 `isEven()`/`isOdd()`如下，但它有一个严重的错误；你能找到它吗？
- en: '[PRE69]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 9.13 `expression()` and `term()`, which don’t use `while`, follow – are they
    correct?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 9.13 `expression()`和`term()`，它们不使用`while`，接下来是——它们正确吗？
- en: '[PRE70]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '9.14 `"^"`, to our arithmetic expression evaluator. (Yes, the exponentiation
    operator in JavaScript is `"**"`, not `"^"`, but I wanted to have single-character
    tokens for simplicity.) Be sure to implement priorities correctly, and also to
    make the operator right-associative: `2^3^4` should be evaluated as `(2^(3^4))`,
    not `((2^3)^4)`.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 9.14 `"^"`，到我们的算术表达式评估器中。（是的，JavaScript中的指数运算符是`"**"`，而不是`"^"`，但我希望为了简单起见使用单字符标记。）务必正确实现优先级，并使运算符具有右结合性：`2^3^4`应该被评估为`(2^(3^4))`，而不是`((2^3)^4)`。
- en: '9.15 **Error-prone evaluation**: Our evaluation algorithm is prone to errors
    because it expects expressions to be syntactically valid. How can you enhance
    it?'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 9.15 **易出错的评估**：我们的评估算法容易出错，因为它期望表达式在语法上是有效的。你如何增强它？
