- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Functions – Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*,
    we considered yet more ways to create new functions out of combining previous
    existing ones. Here, we will get into a different theme: how to design and write
    functions in a typically functional way, by applying recursive techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what recursion is and how to think in order to produce recursive
    solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying recursion to some well-known problems, such as making a change or the
    Tower of Hanoi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using recursion instead of iteration to re-implement some higher-order functions
    from earlier chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing search and backtrack algorithms with ease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversing data structures, such as trees, to work with filesystem directories
    or with the browser DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding mutual recursion and applying it to problems such as correctly
    evaluating arithmetical expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting around some limitations caused by browser JavaScript engine considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is a key technique in FP, to the degree that some languages do not
    provide for iterations or loops, and work exclusively with recursion (Haskell,
    which we already mentioned, is a prime example of that). A fundamental fact of
    computer science is that whatever you can do with recursion, you can do with iteration
    (loops), and vice versa. The key concept is that there are many algorithms whose
    definition is far easier if you work recursively. On the other hand, recursion
    is not always taught, and many programmers, even after knowing about it, prefer
    not to use it. Therefore, in this section, we shall see several examples of recursive
    thinking so that you can adapt it for your functional coding.
  prefs: []
  type: TYPE_NORMAL
- en: A typical, oft-quoted, and very old computer joke!
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary definition: **recursion***: (n)* *see* **recursion**'
  prefs: []
  type: TYPE_NORMAL
- en: But what is recursion? There are many ways to define what recursion is, but
    the simplest one I’ve seen runs along the lines of *a function calling itself
    again and again until it doesn’t*. A more complex case is mutual recursion, the
    simplest example of which is when we have two functions, `A()` and `B()`, each
    of which calls the other, over and over, until they are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion is a natural technique for several kinds of problems, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical definitions, such as the Fibonacci sequence or the factorial of
    a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data-structure-related algorithms with recursively defined structures, such
    as lists (a list is either empty or consists of a head node followed by a list
    of nodes) or trees (a tree might be defined as a special node, called the root,
    linked to zero or more trees)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax analysis for compilers based on grammar rules, which themselves depend
    on other rules, which also depend on other rules, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And many more! It even appears in art and humor, as shown in *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Google itself jokes about it: if you ask about recursion, it
    answers, “Did you mean: recursion”](img/Figure_9.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1 – Google itself jokes about it: if you ask about recursion, it answers,
    “Did you mean: recursion”'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from some easy base cases in which no further computation is required,
    a recursive function must call itself one or more times to perform part of the
    required calculations. This concept may not be very clear at this point, so in
    the following sections, we will see how we can think recursively and solve several
    common problems by applying this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking recursively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to solving problems recursively is assuming that you already have a
    function that does whatever you need and just calling it. (Doesn’t this sound
    weird? Actually, it is quite appropriate: if you want to solve a problem with
    recursion, you must first have solved it before...) On the other hand, if you
    attempt to work out in your head how the recursive calls work and try to follow
    the flow, you’ll probably just get lost. So, what you need to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assume you already have an appropriate function to solve your problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See how the big problem can be solved by solving one (or more) smaller problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve those problems by using the imagined function from *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide what your base cases are. Make sure they are simple enough that they
    are solved directly, without requiring more calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these points in mind, you can solve problems by recursion because you’ll
    have the basic structure for your recursive solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three usual methods for solving problems by applying recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decrease and conquer** is the simplest case, in which solving a problem directly
    depends on solving a single, simpler case of itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Divide and conquer** is a more general approach. The idea is to try to divide
    your problem into two or more smaller versions, solve them recursively, and use
    these solutions to solve the original problem. The only difference between this
    technique and *decrease and conquer* is that you have to solve two or more other
    problems instead of only one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic programming** can be seen as a variant of *divide and conquer*: basically,
    you solve a complex problem by breaking it into a set of somewhat simpler versions
    of the same problem and solving each in order; however, a key idea in this strategy
    is to store previously found solutions, so that whenever you find yourself needing
    the solution to a simpler case again, you won’t directly apply recursion but,
    instead, use the stored result and avoid unnecessary repeated calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we shall look at a few problems and solve them by thinking
    recursively. Of course, we shall see more applications of recursion in the rest
    of the chapter; here, we’ll focus on the key decisions and questions needed to
    create such an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Decrease and conquer – searching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most usual case of recursion involves just a single, simple case. We have
    already seen some examples of this, such as the ubiquitous factorial calculation:
    to calculate the factorial of *n*, you previously needed to calculate the factorial
    of *n*-1\. (See [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*.)
    Let’s turn now to a non-mathematical example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You would also use this decrease-and-conquer strategy to search for an element
    in an array. If the array is empty, then obviously the searched-for value isn’t
    there; otherwise, the result is in the array if, and only if, it’s the array’s
    first element or if it’s in the rest of the array. The following code does just
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This implementation directly mirrors our explanation, and verifying its correctness
    is easy.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, just as a precaution, let’s look at two further implementations
    of the same concept. You can shorten the search function a bit—is it still clear?
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using a ternary operator to detect whether the array is empty, and a
    Boolean `||` operator to return `true` if the first element is the sought one
    or else return the result of the recursive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sparseness can go even further! Using `&&` as a shortcut is a common idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I’m not really suggesting that you code the function in this way—instead, consider
    it a warning against the tendency that some FP developers have to try to go for
    the tightest, shortest possible solution and never mind clarity!
  prefs: []
  type: TYPE_NORMAL
- en: Decrease and conquer – doing powers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another classic example has to do with efficiently calculating powers of numbers.
    If you want to calculate, say, 2 to the 13th power (213), then you can do this
    with 12 multiplications; however, you can do much better by writing 213 as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 212
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 46
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 163
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 16 times 162
  prefs: []
  type: TYPE_NORMAL
- en: = 2 times 16 times 2561
  prefs: []
  type: TYPE_NORMAL
- en: = 8192
  prefs: []
  type: TYPE_NORMAL
- en: 'This reduction in the total number of multiplications may not look very impressive,
    but in terms of algorithmic complexity, it allows us to bring down the order of
    the calculations from O(*n*) to O(*log n*). In some cryptographic-related methods,
    which have to raise numbers to really high exponents, this makes a significant
    difference. We can implement this recursive algorithm in a few lines of code,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Extra speed
  prefs: []
  type: TYPE_NORMAL
- en: When implemented for production, bit operations are used instead of modulus
    and divisions. Checking whether a number is odd can be written as `power & 1`,
    and division by 2 is achieved with `power >> 1`. These alternative calculations
    are way faster than the replaced operations.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a power is simple when the base case is reached (raising something
    to the zeroth power) or based on a previously calculated power for a smaller exponent.
    (If you wanted to, you could add another base case for raising something to the
    power of one.) These observations show that we are seeing a textbook case for
    the decrease and conquer recursive strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some of our higher-order functions, such as `map()`, `reduce()`, and
    `filter()`, also apply this technique; we’ll look into this later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer – the Tower of Hanoi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the divide-and-conquer strategy, solving a problem requires two or more
    recursive solutions. For starters, let’s consider a classic puzzle invented by
    a French mathematician, Édouard Lucas, in the 19th century. The puzzle involves
    a temple in India, with 3 posts, the first of them with 64 golden disks of decreasing
    diameter. The priests have to move the disks from the first post to the last one
    following two rules: only one disk can be moved at a time, and a larger disk can
    never be placed on top of a smaller disk. According to the legend, when the 64
    disks are moved, the world will end. This puzzle is usually marketed under the
    *Tower of Hanoi* name (yes, they changed countries!) with fewer than 10 disks.
    See *Figure 9**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution](img/Figure_9.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The classic Tower of Hanoi puzzle has a simple recursive solution
  prefs: []
  type: TYPE_NORMAL
- en: A long, long time…
  prefs: []
  type: TYPE_NORMAL
- en: The solution for *n* disks requires 2n-1 movements. The original puzzle, requiring
    264-1 movements, at one movement per second, would take more than 584 billion
    years to finish – a very long time, considering that the universe’s age is evaluated
    to only be 13.8 billion years!
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we already have a function that solves the problem of moving any number
    of disks from a source post to a destination post using the remaining post as
    an extra aid. Think about solving the general problem if you already had a function
    to solve that problem: `hanoi(disks, from, to, extra)`. If you wanted to move
    several disks from one post to another, then you could solve it using this (still
    unwritten!) function by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving all of the disks but the last one to the extra post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving the last disk to the destination post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving all the disks from the extra post (where you had placed them earlier)
    to the destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But what about our base cases? We could decide that to move a single disk,
    you don’t need the function; you just go ahead and move the disk. When coded,
    it becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Post` type is possibly not needed, but good practice anyway. We
    can quickly verify that this code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s only a small detail to consider, which can simplify the function further.
    In this code, our base case (the one that needs no further recursion) is when
    `disks` equals one. You could also solve this differently by letting the disks
    go down to zero and simply not doing anything—after all, moving zero disks from
    one post to another is achieved by doing nothing at all! The revised code would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead of checking whether there are any disks to move before doing the recursive
    call, we can just skip the check and have the function test, at the next level,
    whether there’s something to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Hanoi by hand
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are doing the puzzle by hand, there’s a simple solution for that: on
    odd turns, always move the smaller disk to the next post (if the total number
    of disks is odd) or to the previous post (if the total number of disks is even).
    On even turns, make the only possible move that doesn’t involve the smaller disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the principle for recursive algorithm design works: assume you already
    have your desired function and use it to build itself!'
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer – sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can see another example of the divide-and-conquer strategy with sorting.
    A way to sort arrays, called Quicksort, is based upon the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If your array has 0 or 1 element(s), do nothing; it’s already sorted (this is
    the base case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pick an element of the array (called the pivot) and split the rest of the array
    into two subarrays: the elements smaller than your chosen element and the elements
    greater than or equal to your chosen element.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively sort each subarray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To produce the sorted version of the original array, concatenate both sorted
    results, with the pivot in between.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see a simple version of this (there are some better-optimized implementations,
    but we are interested in the recursive logic now). Usually, picking a random element
    of the array is suggested to avoid some bad performance border cases, but for
    our example, let’s just take the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how this works in *Figure 9**.3*: the pivot for each array and subarray
    is underlined. Splitting is shown with dotted arrows and is joined with full lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer
    strategy to reduce the original problem to smaller ones](img/Figure_9.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Quicksort sorts an array recursively, applying the divide-and-conquer
    strategy to reduce the original problem to smaller ones
  prefs: []
  type: TYPE_NORMAL
- en: Easy-to-get bug!
  prefs: []
  type: TYPE_NORMAL
- en: Writing Quicksort correctly is not trivial; see *Question 9.8* at the end of
    this chapter for an alternative version that is *almost* right, but not totally
    correct!
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen the basic strategies to reduce a problem to simpler versions
    of itself. Let’s now look at an important optimization, a key for many algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic programming – making change
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third general strategy, *dynamic programming*, assumes that you will have
    to solve many smaller problems, but instead of using recursion every time, it
    depends on you having stored the previously found solutions – *memoization*, in
    other words! In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*,
    and later, in a better fashion, in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we already saw how to optimize the calculations of the
    usual Fibonacci series, avoiding unnecessary repeated calls. Let’s now consider
    another problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a certain number of dollars and the list of existing bill values, calculate
    how many different ways we can pay that amount of dollars with different combinations
    of bills. It is assumed that you have access to an unlimited number of each bill.
    How can we go about solving this? Let’s start by considering the base cases where
    no further computation is needed. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Paying negative values is not possible, so in such cases, we should return `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paying zero dollars is only possible in a single way (by giving no bills), so
    in this case, we should return `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paying any positive amount of dollars isn’t possible if no bills are provided,
    so in this case, also return `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we can answer the question: in how many ways can we pay *N* dollars
    with a given set of bills? We can consider two cases: we do not use the larger
    bill at all and pay the amount using only smaller denomination bills, or we can
    take one bill of the larger amount and reconsider the question. (Let’s forget
    the avoidance of repeated calculations for now.)'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, we should invoke our supposedly existing function with the
    same value of *N* but prune the largest bill denomination from the list of available
    bills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second case, we should invoke our function with *N* minus the largest
    bill denomination, keeping the list of bills the same, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s do some optimization. This algorithm often needs to recalculate
    the same values over and over. (To verify this, add `console.log(n, bills.length)`
    as the first line in `makeChange()`—but be ready for plenty of output!) However,
    we already have a solution for this: memoization! Since we are applying this technique
    to a binary function, we’ll need a version of the memoization algorithm that deals
    with more than one parameter. We saw that in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,*
    *Producing Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The memoized version of `makeChange()` is far more efficient, and you can verify
    it with logging. While it is certainly possible to deal with the repetitions by
    yourself (for example, by keeping an array of already computed values), the memoization
    solution is, in my opinion, better because it composes two functions to produce
    a better solution for the given problem.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classic FP techniques do not use iteration at all but work exclusively with
    recursion as the only way to do some looping. Let’s revisit some of the functions
    that we have already seen in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, such as `map()`, `reduce()`, `find()`, and `filter()`,
    to see how we can make do with just recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not planning to exchange the basic JavaScript functions for ours, though:
    it’s likely that performance will be worse for our recursive polyfills, and we
    won’t derive any advantages just from having the functions use recursion. Instead,
    we want to study how iterations are performed in a recursive way so that our efforts
    are more pedagogical than practical, OK?'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping and filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mapping and filtering are quite similar insofar as both imply going through
    all the elements in an array and applying a callback to each to produce output.
    Let’s first work out the mapping logic, which will have several points to solve,
    and then we should see that filtering has become almost trivially easy, requiring
    just small changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For mapping, given how we are developing recursive functions, we need a base
    case. Fortunately, that’s easy: mapping an empty array produces a new empty array.
    Mapping a non-empty array can be done by first applying the mapping function to
    the first element of the array, then recursively mapping the rest of the array,
    and finally, producing a single array accumulating both results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this idea, we can work out a simple initial version: let’s call it
    `mapR()`, just to remember that we are dealing with our own, recursive version
    of `map()`; however, be careful – our polyfill has some bugs! We’ll deal with
    them one at a time. Here’s our first attempt at writing our own mapping code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Great! Our `mapR()` function seemingly produces the same results as `map()`.
    However, shouldn’t our callback function receive a couple more parameters, specifically
    the index at the array and the original array itself? (Check out the definition
    for the callback function for `map()` at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation isn’t quite ready yet. Let’s first see how it fails by using
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were working with JavaScript, the last call would produce `[NaN, NaN,
    NaN, NaN, NaN]` – TypeScript detects the error because the type of `timesTenPlusI()`
    is wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating the appropriate index position will require an extra parameter for
    the recursion. Still, it is basically simple: when we start out, we have `index=0`,
    and when we call our function recursively, it’s with the `index+1` position. Accessing
    the original array requires yet another parameter, which will never change, and
    now we have a better mapping function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Great! When you do recursion instead of iteration, you don’t have access to
    an index, so if you need it (as in our case), you’ll have to generate it on your
    own. This is an often-used technique, so working out our `map()` substitute was
    a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, having extra arguments in the function is not so good; a developer
    might accidentally provide them and the results would be unpredictable. So, using
    another usual technique, let’s define an inner function, `mapLoop()`, to handle
    looping. This is, in fact, the usual way in which looping is achieved when you
    only use recursion; look at the following code, in which the extra function isn’t
    accessible from outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s only one pending issue: if the original array has some missing elements,
    they should be skipped during the loop. Let’s look at an example, in plain JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (Why just JavaScript? TypeScript would object because the array to be processed
    had `number | undefined` types, but `timesTen()` expects an array with just `number`
    types. By the way, I also had to disable ESLint’s `no-sparse-array` rule, which
    catches accidental extra commas in arrays.)
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, fixing this is simple—and be glad that all the experience gained
    here will help us write the other functions in this section! Can you understand
    the fix in the following code, apart from the obvious changes to allow values
    in arrays to be `undefined`, for which I used an auxiliary `Opt<>` type definition?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! This was more than we bargained for, but we saw several techniques: how
    to replace iteration with recursion, how to accumulate a result across iterations,
    and how to generate and provide the index value—good tips! Furthermore, writing
    filtering code will prove much easier since we’ll be able to apply very much the
    same logic as we did for mapping. The main difference is that we use the callback
    function to decide whether an element goes into the output array, so the inner
    loop function is a tad longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we managed to implement two of our basic higher-order functions with similar
    recursive functions. What about the others?
  prefs: []
  type: TYPE_NORMAL
- en: Other higher-order functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programming `reduce()` is, from the outset, a bit trickier, since you can decide
    to omit the initial value for the accumulator. Since we mentioned earlier that
    providing that value is generally better, let’s work here under the assumption
    that it will be given; dealing with the other possibility won’t be too hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base case is simple: if the array is empty, the result is the accumulator;
    otherwise, we must apply the `reduce` function to the current element and the
    accumulator, update the latter, and then continue working with the rest of the
    array. This can be a bit confusing because of the ternary operators, but it should
    be clear enough after all we’ve seen. Look at the following code for the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `find()` is particularly apt for recursive logic since the
    very definition of how you (attempt to) find something is recursive in itself:'
  prefs: []
  type: TYPE_NORMAL
- en: You look at the first place you think of, and if you find what you were seeking,
    you are done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you look at the other places to see whether what you seek is
    there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are only missing the base case, but that’s simple, and we already saw this
    earlier in the chapter – if you have no places left to search, then you know you
    won’t be successful in your search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can quickly verify whether this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s finish with our pipelining function. The definition of a pipeline lends
    itself to quick implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to pipeline a single function, then that’s the result of the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to pipeline several functions, we must first apply the initial function
    and then pass that result as input to the pipeline of the other functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can directly turn this into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify its correctness with a simple example. Let’s pipeline several
    calls to a couple of functions, one of which just adds 1 to its argument and the
    other of which multiplies by 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you follow the math, you’ll be able to check that the pipelining is working
    fine. We could have a slightly different recursive call if we take the base case
    to be when no functions are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In any case, these pipelines won’t work in TypeScript because our `Pipeline<>`
    type definition won’t allow for an empty set of functions – can you fix that?
  prefs: []
  type: TYPE_NORMAL
- en: Doing the same for composition is easy, except that you cannot use the spread
    operator to simplify the function definition, and you’ll have to work with array
    indices—work it out!
  prefs: []
  type: TYPE_NORMAL
- en: Searching and backtracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Searching for solutions to problems, especially when there is no direct algorithm
    and you must resort to trial and error, is particularly appropriate for recursion.
    Many of these algorithms fall into a scheme such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Out of many choices available, pick one. If no options are available, you’ve
    failed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you could pick one, apply the same algorithm, but find a solution to the
    rest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you succeed, you are done. Otherwise, try another choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can apply similar logic with minor variations to find a good—or possibly,
    optimum—solution to a given problem. Each time you find a possible solution, you
    match it with previous ones that you might have found and decide which to keep.
    This may continue until all possible solutions are evaluated or until a good enough
    solution has been found.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many problems to which this logic applies. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Finding a way out of mazes*—pick any path, mark it as already followed, and
    try to find a way out of the maze that won’t reuse that path: if you succeed,
    you are done, and if you do not, go back to pick a different path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Filling out Sudoku puzzles*—if an empty cell can contain only a single number,
    then assign it; otherwise, run through all of the possible assignments, and for
    each one, recursively try to see whether the rest of the puzzle can be filled
    out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Playing chess*—where you aren’t likely to be able to follow through all possible
    move sequences, so you opt for the best-estimated position instead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s apply these techniques to two problems: solving the eight queens puzzle
    and traversing a complete file directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The eight queens puzzle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The eight queens puzzle was invented in the 19th century and involves placing
    eight chess queens on a standard chessboard. The restriction is that no queen
    should be able to attack another—implying that no pair of queens may share a row,
    column, or diagonal line. The puzzle may ask for any solution or the total number
    of distinct solutions, which we will attempt to find.
  prefs: []
  type: TYPE_NORMAL
- en: The *n* queens variation
  prefs: []
  type: TYPE_NORMAL
- en: 'The puzzle may also be generalized to *n* queens by working on an *n*x*n* square
    board. It is known that there are solutions for all values of *n*, except *n*=2
    (pretty simple to see why: after placing one queen, all of the board is threatened)
    and *n*=3 (if you place a queen in the center, all of the board is threatened,
    and if you place a queen on a side, only two squares are not threatened, but they
    threaten each other, making it impossible to place queens on them).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start our solution with top-level logic. Because of the given rules,
    there will be a single queen in each column, so we use a `places` array to take
    note of each queen’s row within the given column. The `SIZE` constant could be
    modified to solve a more general problem. We’ll count each found distribution
    of queens in the `solutions` variable. Finally, the `finder()` function will perform
    the recursive search for solutions. The basic skeleton for the code would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s get into the required logic. When we want to place a queen in a given
    row and column, we must check whether any of the previously placed queens were
    placed on the same row or in a diagonal leading from the row. See *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Before placing a queen in a column, we must check the previously
    placed queens’ positions](img/Figure_9.4_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Before placing a queen in a column, we must check the previously
    placed queens’ positions
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a `checkPlace(column, row)` function to verify whether a queen
    can be safely placed in the given square. The most straightforward way is by using
    `every()`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This declarative fashion seems best: when we place a queen in a position, we
    want to ensure that every other previously placed queen is in a different row
    and diagonal. A recursive solution would have been possible too, so let’s see
    that. How do we know that a square is safe?'
  prefs: []
  type: TYPE_NORMAL
- en: A base case is when there are no more columns to check, the square is safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the square is in the same row or diagonal as any other queen, it’s not safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have checked a column and found no problem, we can now recursively check
    the following one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The required alternative code to check whether a position in a column can be
    occupied by a queen is, therefore, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code works, but I wouldn’t use it since the declarative version is clearer.
    Anyway, having worked out this check, we can pay attention to the main `finder()`
    logic, which will do the recursive search. The process proceeds as we described
    at the beginning: try out a possible placement for a queen, and if that is acceptable,
    use the same search procedure to try and place the remaining queens. We start
    at column 0, and our base case is when we reach the last column, meaning that
    all queens have been successfully placed: we can print out the solution, count
    it, and go back to search for a new configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting nice output
  prefs: []
  type: TYPE_NORMAL
- en: Check out how we use `map()` and a simple arrow function to print the rows of
    the queens, column by column, as numbers between 1 and 8, instead of 0 and 7\.
    In chess, rows are numbered from 1 to 8 (and columns from a to h, but that doesn’t
    matter here).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code, which applies the logic that we described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The inner `testRowsInColumn()` function also fulfills an iterative role, but
    recursively. The idea is to attempt placing a queen in every possible row, starting
    at zero: if the square is safe, `finder()` is called to start searching from the
    next column onward. No matter whether a solution was or wasn’t found, all rows
    in the column are tried out because we are interested in the total number of solutions.
    In other search problems, you might be content with finding any solution, and
    you would stop your search there.'
  prefs: []
  type: TYPE_NORMAL
- en: We have come this far, so let’s find the answer to our problem!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each solution is given as the row positions for the queens, column by column,
    and there are 92 solutions in all.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a tree structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Data structures, which include recursion in their definition, are naturally
    appropriate for recursive techniques. Let’s consider, for example, how to traverse
    a complete filesystem directory, listing all of its contents. Where’s the recursion?
    The answer is straightforward if you consider that each directory can do either
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Be empty—a base case in which there’s nothing to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include one or more entries, each of which is either a file or a directory itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s work out a full recursive directory listing—meaning that when we encounter
    a directory, we also list its contents, and if those include more directories,
    we also list them, and so on. We’ll be using the same node functions as in `getDir()`
    (from the *Building pipelines by hand* section in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,
    Connecting Functions*), plus a few more to test whether a directory entry is a
    symbolic link (which we won’t follow to avoid possible infinite loops), a directory
    (which will require a recursive listing), or a common file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The listing is long but correct. I opted to list the `/boot` directory in my
    own openSUSE Linux laptop, and this was produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the same structure to a similar problem: traversing a DOM structure.
    We could list all of the tags, starting from a given element, using the same approach:
    we list a node and (by applying the same algorithm) all of its children. The base
    case is the same as before: when a node has no children, no more recursive calls
    are made. You can see this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `depth` variable to know how many levels below the original
    element we are. We could also use it to make the traversing logic stop at a certain
    level; in our case, we are using it only to add some bars and spaces to appropriately
    indent each element according to its place in the DOM hierarchy. The result of
    this function is shown in the following code. It would be easy to list more information
    and not just the element tag, but I wanted to focus on the recursive process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there’s an ugly point there: why are we making a loop to go through
    all of the children? We should know better! The problem is that the structure
    we get from the DOM isn’t really an array. However, there’s a way out – we can
    use `Array.from()` to create a real array out of it and then write a more declarative
    solution. The following code solves the problem in a better way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Writing `[...node.children].forEach()` would have worked as well but using `Array.from()`
    makes it more apparent to any reader that we are trying to make an array out of
    something that looks like one, but really isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen many ideas about the usage of recursion, and we’ve seen many
    applications of it; however, there are some cases in which you may run into problems,
    so let’s now consider some tweaks that may come in handy for specific problems.
  prefs: []
  type: TYPE_NORMAL
- en: Mutual recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion need not be as “simple” and “direct” as having a function that calls
    itself. We can have more complex situations as a set of functions, each of which
    calls one or more of the others but not necessarily calling itself. (However,
    note that this is also allowed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking in terms of mutual recursion is harder. For simple recursion, you
    had to imagine you already had a function to do something, and then you used it
    (in itself!) to do that. In mutual recursion, you have to think of a set of functions,
    each of which does its own part by simultaneously depending on all the set of
    functions: the others, and possibly itself as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine a simple case to get our feet wet, and then go for a “real-life”
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Odds and evens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How can you determine whether a (not negative) integer number is odd or even?
    This a trivial problem, to be sure (but see *Question 9.11*) but we can get an
    interesting solution if we realize the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero is even
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a number is even, when you subtract 1 from it, you get an odd number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A number is odd if it’s not even:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'How does this work? Each function (`isEven()` and `isOdd()`) depends on the
    other to produce a result. How do we know that 9 is odd? The calculations are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And after the last call, the whole tower of calls gets resolved; 9 is reported
    to be odd (fortunately!)
  prefs: []
  type: TYPE_NORMAL
- en: 'You could say that this actually isn’t a great example of mutual recursion,
    because you could easily replace the code for `isOdd()` in `isEven()` to get single
    recursion versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can go about this in another way that will also include mutual
    recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So, don’t get to think that mutual recursion can always be simplified away;
    sometimes, that’s not really possible or practical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the code, it should be evident that no one would implement a
    parity test this way. Still, this example paves the way to implementing a more
    complex function: parsing and evaluating an arithmetic expression, which will
    involve multiple mutually recursive functions, as we’ll see next.'
  prefs: []
  type: TYPE_NORMAL
- en: Doing arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see a more complete problem, which also happens to (frequently!) appear
    online, with puzzles as in *Figure 9**.5*. We’ll implement a set of mutually recursive
    functions that can correctly evaluate an arithmetic expression according to standard
    precedence rules for operators.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Common puzzles call for evaluating arithmetic expressions](img/Figure_9.5_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Common puzzles call for evaluating arithmetic expressions
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, we’ll first see a tool that lets us correctly process operations:
    *railroad diagrams*. We want to evaluate an expression, and we can say that an
    expression is either one single term, or several terms added or subtracted. *Figure
    9**.6* shows this graphically. Imagine the arrows are railroad tracks, and any
    path you follow that starts at the left and eventually ends at the right represents
    a possible expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – A railroad syntax diagram for arithmetic expressions](img/Figure_9.6_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – A railroad syntax diagram for arithmetic expressions
  prefs: []
  type: TYPE_NORMAL
- en: Now, what’s a term? A term is either a single factor, or the result of multiplying,
    dividing, or using modulus operations on several factors, as shown in *Figure
    9**.7*. Note that with these two rules, *2*3+5* is correctly evaluated as *(2*3)+5*,
    because *2*3* and *5* are terms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus
    are performed before addition or subtraction](img/Figure_9.7_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7 – A railroad syntax for terms: multiplication, division, and modulus
    are performed before addition or subtraction'
  prefs: []
  type: TYPE_NORMAL
- en: We need one more diagram, for factors. A factor can be a single number or an
    expression between parentheses. We’ll allow an optional minus sign at the beginning,
    so -3 is accepted. *Figure 9**.8* shows the needed diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – A factor starts with an optional minus sign, and can be a number
    or an expression within parentheses](img/Figure_9.8_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – A factor starts with an optional minus sign, and can be a number
    or an expression within parentheses
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll implement the needed evaluation with three functions, one for each diagram.
    In the usual compiler or interpreter code, we have a first phase that reads the
    input and splits it into *tokens*, and a second phase that processes those tokens
    to do whatever’s needed. In our case, the tokens will be numbers (single digits,
    for simplicity), operators, and parentheses. The code we’ll write is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We define some constants (`PLUS`, `MINUS`, etc.) for clarity. Given a string
    such as `"7+7/7+7*7-7"`, we split it into the tokens array; we take care to evaluate
    digits. Finally, we have a `curr` variable pointing to the token being processed
    right now. The evaluation of the input expression will be done by three functions
    that will use mutual recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `expression()` function first calls `term()` to get the value of the first
    term and then loops if an addition or subtraction is found. In our case, this
    means that the function would first evaluate a 7, then add 7/7, then also add
    7*7, and finally subtract the last 7\. (And yes, the result is 50.) After a token
    is processed, `curr` is incremented to continue with the rest of the tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `term()` is similar in style; the only difference is how it works
    with multiplication, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This function would be called to evaluate 7, then 7/7, then 7*7, and finally
    another 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `factor()` is a tad different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mult` variable will be `-1` if an initial minus sign was present, or `+1`
    otherwise. We have no loops here, and just an alternative: if a left parenthesis
    is seen, we skip it, recursively evaluate the included expression, skip the right
    parenthesis, and return the value of the expression. The alternative is that we
    have a number, which we return. Whatever we return, we’ll multiply by the `mult`
    value to produce the correct result.'
  prefs: []
  type: TYPE_NORMAL
- en: If you analyze the recursive calls, we have `expression()` calling `term()`,
    which calls `factor()`, which calls `recursive()` – a cycle of three! Mutual recursion
    is harder to understand and to get right because to plan such code, you must foresee
    what several functions will do. However, for the right problems (as shown here),
    it’s a very powerful technique.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While recursion is a very good technique, you may face some problems because
    of the way it is internally implemented. Each function call, recursive or not,
    requires an entry in the internal JavaScript stack. When you are working with
    recursion, each recursive call itself counts as another call, and you might find
    that there are some situations in which your code will crash and throw an error
    because it ran out of memory, just because of multiple calls. On the other hand,
    with most current JavaScript engines, you can probably have several thousand pending
    recursive calls without a problem – but with earlier browsers and smaller machines,
    the number could drop into the hundreds and feasibly go even lower. Thus, it could
    be argued that, at present, you are not likely to suffer from any particular memory
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, let’s review the problem and go over some possible solutions in
    the following sections. Even if you don’t get to actually apply them, they represent
    valid FP ideas for which you may find a place in yet other problems. We will be
    looking at the following solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tail call optimization**, a technique that speeds up recursion **continuation-passing
    style** (**CPS**), an important FP technique that can help with recursion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A couple of interestingly named techniques, **trampolines** and **thunks**,
    which are also standard FP tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursion elimination**, a technique beyond this book’s scope, but which
    may still be applied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tail call optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When is a recursive call not a recursive call? Put this way, the question may
    make little sense, but there’s a common optimization—for other languages, alas,
    but not JavaScript!—that explains the answer. If the recursive call is the very
    last thing a function will do, then the call could be transformed into a simple
    jump to the start of the function without needing to create a new stack entry.
    (Why? The stack entry wouldn’t be required: after the recursive call is done,
    the function would have nothing else to do, so there is no need to further save
    any of the elements that have been pushed into the stack upon entering the function.)
    The original stack entry would then no longer be needed and could be replaced
    by a new one, corresponding to the recent call.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation irony
  prefs: []
  type: TYPE_NORMAL
- en: The fact that a recursive call, a quintessential FP technique, is being implemented
    by a base imperative `GO` `TO` statement can be considered an ultimate irony!
  prefs: []
  type: TYPE_NORMAL
- en: These calls are known as **tail calls** (for obvious reasons) and have higher
    efficiency, not only because of the saved stack space but also because a jump
    is quite a bit faster than any alternative. If the browser implements this enhancement,
    it uses **tail call optimization** (**TCO**); however, a glance at the compatibility
    tables at [kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    shows that at the time of writing (at the end of 2022), the only browser that
    provides TCO is Safari.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – To understand this joke, you must have previously understood
    it!](img/Figure_9.9_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – To understand this joke, you must have previously understood it!
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple (though non-standard) test lets you verify whether your browser provides
    TCO. I found this snippet of code in several places on the web, but I’m sorry
    to say, I cannot attest to the original author, although I believe it is Csaba
    Hellinger from Hungary. Calling `detectTCO()` lets you know whether your browser
    does or does not use TCO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Error().stack` result is not a JavaScript standard, but modern browsers
    support it, albeit in somewhat different ways. (I had to add the “`!`” symbol
    so TypeScript would accept that `stack` would be present.) In any case, the idea
    is that when a function with a long name calls another function with a shorter
    name, the stack trace should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It should get shorter if the browser implements TCO, since the old entry for
    the longer-named function would be replaced with the entry for the shorter-named
    one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should get longer without TCO, since a completely new stack entry would be
    created without doing away with the original one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I’m using Chrome on my Linux laptop, and I added a `console.log()` statement
    to show `Error().stack`. You can see that both stack entries (for `inner()` and
    `detectTCO()`) are *live*, so there’s no TCO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, there’s another way of learning whether your environment includes
    TCO: try out the following function (which does nothing!) with large enough numbers.
    If you manage to run it with numbers such as, say, 100,000 or 1,000,000, you can
    be reasonably sure that your JavaScript engine is doing TCO! A possible such function
    could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Let’s finish this section with a very short quiz to ensure we understand what
    tail calls are. Is the recursive call in the factorial function we saw in [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015), *Becoming Functional*, (but here written
    in TypeScript) a tail call?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about it, because the answer is important! You might be tempted to answer
    in the affirmative, but the correct answer is *no*. There’s a good reason for
    this, and it’s a key point: after the recursive call is done and the value for
    `fact(n-1)` has been calculated, the function still has work to do. (So doing
    the recursive call wasn’t actually the last thing that the function would do.)
    You can see it more clearly if you write the function in this equivalent way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be two takeaways from this section: TCO isn’t usually offered
    by browsers, and even if it were, you cannot take advantage of it if your calls
    aren’t actual tail calls. Now that we know what the problem is, let’s see some
    FP ways of working around it!'
  prefs: []
  type: TYPE_NORMAL
- en: Continuation-passing style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know that our logic will fail if we have recursive calls stacked
    too high. On the other hand, we know that tail calls should alleviate that problem,
    but they don’t because of browser implementations! However, there’s a way out
    of this. Let’s first consider how we can transform recursive calls into tail calls
    by using a well-known FP concept—**continuations**—and we’ll leave the problem
    of solving TCO limitations for the next section. (We mentioned continuations in
    [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*,
    but we didn’t go into detail.)
  prefs: []
  type: TYPE_NORMAL
- en: In FP parlance, a continuation represents the state of a process and allows
    processing to continue. This may be too abstract, so let’s see what this means.
    The key idea is that when you call a function, you also provide it with a continuation
    (in reality, a simple function) that will be called at return time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a trivial example. Suppose you have a function that returns the
    time of the day, and you want to show this on the console. The usual way to do
    this could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were doing CPS, you would pass a continuation to the `getTime()` function.
    Instead of returning a calculated value, the function would invoke the continuation,
    giving it the value as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s the difference? The key is that we can apply this mechanism to make
    a recursive call into a tail call because all of the code that comes after will
    be provided in the recursive call itself. To make this clear, let’s revisit the
    factorial function in the version that made it explicit that we weren’t doing
    tail calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add a new parameter to the function for the continuation. What do we
    do with the result of the `fact(n-1)` call? We multiply it by `n`, so let’s provide
    a continuation that will do just that. I’ll rename the factorial function as `factC()`
    to make it clear that we are working with continuations, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'How would we get the final result? Easy – we can call `factC()` with a continuation
    that will return whatever it’s given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Identity combinator
  prefs: []
  type: TYPE_NORMAL
- en: In FP, a function that returns its argument as a result is usually called `identity()`
    for obvious reasons. In combinatory logic (which we won’t be using), we would
    speak of the **I combinator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you understand how it worked? Then let’s try out a more complex case with
    the Fibonacci function, which has two recursive calls in it, as shown in the following
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is trickier: we call `fibC()` with `n-2` and a continuation that says
    that whatever that call returned, call `fibC()` with `n-1`, and when *that* call
    returns, sum the results of both calls and pass that result to the original continuation.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see just one more example, involving a loop with an undefined number of
    recursive calls. By then, you should have some idea about how to apply CPS to
    your code—though I’ll readily admit it can become really complex!
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we saw this function in the *Traversing a tree structure*
    section. The idea was to print out the DOM structure, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The function we ended up designing back then was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start by making this fully recursive, getting rid of the `forEach()`
    loop. We have seen this technique before, so we can move on to the following result;
    note how the following code forms its loops by using recursion. Also, note we
    added lots of `return` statements, even if they are not really needed; we’ll see
    the reason for this soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to add a continuation to `traverseDom3()`. The only difference
    from the previous cases is that the function doesn’t return anything, so we won’t
    pass any arguments to the continuation. It’s also important to remember the implicit
    return at the end of the `traverseChildren()` loop; we must call the continuation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We opted to give a default value to `cont`, so we can call `traverseDom3C(document.body)`
    as before. If we try out this logic, it works, but the problem of the potentially
    high number of pending calls hasn’t been solved; let’s look for a solution to
    this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Trampolines and thunks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the last solution to our problem, we shall have to think about the cause
    of the problem. Each pending recursive call creates a new entry stack. Whenever
    the stack gets too empty, the program crashes, and our algorithm is history. So,
    if we can work out a way to avoid stack growth, we should be free. The solution,
    in this case, is quite imposing and requires *thunks* and a *trampoline*—let’s
    see what these are!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a `new Date().toISOString()`; however, if you provide a thunk that calculates
    that, you won’t get the value until you actually invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: What’s the use of this? The problem with recursion is that a function calls
    itself, and calls itself, and calls itself, and so on until the stack blows over.
    Instead of directly calling itself, we will have the function return a thunk,
    which, when executed, will actually recursively call the function. So, instead
    of having the stack grow more and more, it will actually be quite flat since the
    function will never get to actually call itself; the stack will grow by one position
    when you call the function, and then get back to its size as soon as the function
    returns its thunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'But who gets to do the recursion? That’s where the concept of a **trampoline**
    comes in. A trampoline is just a loop that calls a function, gets its return,
    and if it is a thunk, then it calls it so that recursion will proceed, but in
    a flat, linear way! The loop is exited when the thunk evaluation returns an actual
    value instead of a new function. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we apply this to an actual function? Let’s start with a simple one
    that sums all numbers from 1 to *n*, but in a recursive, guaranteed-to-cause-a-stack-crash
    fashion. Our simple `sumAll()` function could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we start trying this function out, we’ll eventually stumble and
    crash, as you can see in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack problem will come up sooner or later depending on your machine, its
    memory size, and so on – but it will come, no doubt. Let’s rewrite the function
    in CPS so that it will become tail-recursive. We will apply the same technique
    that we saw earlier, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, crashes as before; eventually, the stack grows too much. Let’s
    apply a simple rule to the code: whenever you are going to return from a call,
    instead, return a thunk that will, when executed, do the call that you actually
    wanted to do. The following code implements that change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever there would have been a call to a function, we now return a thunk.
    How do we get to run this function? This is the missing detail. You need an initial
    call that will invoke `sumAllT()` the first time, and (unless the function was
    called with a zero argument) a thunk will be immediately returned. The `trampoline`
    function will call the thunk, and that will cause a new call, and so on until
    we eventually get a thunk that just returns a value, and then the calculation
    will be ended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, you probably wouldn’t want a separate `sumAllT()` function, so you’d
    go for something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s only one problem left: what would we do if the result of our recursive
    function wasn’t a value but rather a function? The problem there would be on the
    `trampoline()` code that, as long as the result of the thunk evaluation is a function,
    goes back again and again to evaluate it. The simplest solution would be to return
    a thunk, but wrapped in an object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The difference now would be that, instead of returning a thunk, you’d return
    a `Thunk` object, so our new trampolining function can now distinguish an actual
    thunk (which is meant to be invoked and executed) from any other kind of result
    (which is meant to be returned).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you happen to have a recursive algorithm, but it won’t run because of
    stack limits, you can fix it reasonably by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Change all recursive calls to tail recursion using continuations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace all `return` statements so that they’ll return thunks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the call to the original function with a `trampoline` call to start
    the calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, this doesn’t come for free. You’ll notice that, when using this mechanism,
    there’s extra work involving returning thunks, evaluating them, and so on, so
    you can expect the total time to go up. Nonetheless, this is a low price to pay
    if the alternative is having a non-working solution to a problem!
  prefs: []
  type: TYPE_NORMAL
- en: Recursion elimination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s yet one other possibility that you might want to explore, but that falls
    beyond the realm of FP and into algorithm design. It’s a computer science fact
    that any algorithm implemented using recursion has an equivalent version that
    doesn’t use recursion at all, and instead depends on a stack. There are ways to
    systematically transform recursive algorithms into iterative ones, so if you run
    out of all options (that is, if not even continuations or thunks can help you),
    then you’d have a final opportunity to achieve your goals by replacing all recursion
    with iteration. We won’t be getting into this—as I said, this elimination has
    little to do with FP—but it’s important to know that the tool exists and that
    you might be able to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can use recursion, a basic tool in FP, as a powerful
    technique to create algorithms for problems that would probably require far more
    complex solutions otherwise. We started by considering what recursion is and how
    to think recursively in order to solve problems, then moved on to see some recursive
    solutions to several problems in different areas, and ended by analyzing potential
    problems with deep recursion and how to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, we shall
    get back to a concept we saw earlier in the book, function purity, and see some
    techniques that will help us guarantee that a function won’t have any side effects
    by ensuring the immutability of arguments and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '9.1 `reverse(str: string)` function but implement it in a recursive fashion?
    The best way to do this would be using the standard string `reverse()` method,
    as detailed in [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse),
    but that wouldn’t do for a question on recursion, would it?'
  prefs: []
  type: TYPE_NORMAL
- en: '9.2 **Climbing steps**: Suppose you want to climb up a ladder with *n* steps.
    Each time you raise your foot, you may climb up one or two rungs. In how many
    different ways can you climb up that ladder? For example, you can climb a four-rung
    ladder in five different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Always take one step at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always take two steps at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take two steps first, then one, and then one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take one step first, then two, and then one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take one step first, then another one, and finish with two
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '9.3 **Sorting recursively**: Many sorting algorithms can be described with
    recursion; can you implement them?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection sort**: Find the maximum element of the array, remove it, recursively
    sort the rest, and then push the maximum element to the end of the sorted rest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insertion sort**: Take the first element of the array, sort the rest, and
    finish by inserting the removed element into its correct place in the sorted rest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merge sort**: Divide the array into two parts, sort each one, and finish
    by merging the two sorted parts into a sorted list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '9.4 `greaterEqual`. Can you foresee any possible problems with this? The following
    code highlights the changes that the developer made with regard to the original
    version we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '9.5 `quicksort()` more efficient by avoiding having to call `filter()` twice.
    Along the lines of what we saw in the *Calculating several values at once* section
    in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    write a `partition(arr, pr)` function that, given an `arr` array and an `fn()`
    predicate, will return two arrays: the values of `arr` for which `fn` is true
    in the first one, and the rest of the values of `arr` in the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 9.6 `findR()` function, we did not provide all possible parameters to the `cb()`
    callback. Can you fix that? Your solution should be along the lines of what we
    did for `map()` and other functions. (And yes, if you can also allow for empty
    places in the array, it would be even better.)
  prefs: []
  type: TYPE_NORMAL
- en: '9.7 `every()` and `some()` using recursion: can you do that?'
  prefs: []
  type: TYPE_NORMAL
- en: '9.8 **Symmetrical queens**: In the eight queens puzzle we previously solved,
    only one solution shows symmetry in the placement of the queens. Can you modify
    your algorithm to find it?'
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 `INTERNATIONAL` and `CONTRACTOR` is `N...T...R...A...T...O`. Try it out
    with and without memoizing and see the difference!
  prefs: []
  type: TYPE_NORMAL
- en: 9.10 `isOdd()`? There are quite a few!
  prefs: []
  type: TYPE_NORMAL
- en: 9.11 `isOdd()` and `isEven()` using a trampoline to avoid stack overflow problems.
  prefs: []
  type: TYPE_NORMAL
- en: 9.12 `isEven()`/`isOdd()` was as follows, but it had a serious bug; can you
    find it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 9.13 `expression()` and `term()`, which don’t use `while`, follow – are they
    correct?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '9.14 `"^"`, to our arithmetic expression evaluator. (Yes, the exponentiation
    operator in JavaScript is `"**"`, not `"^"`, but I wanted to have single-character
    tokens for simplicity.) Be sure to implement priorities correctly, and also to
    make the operator right-associative: `2^3^4` should be evaluated as `(2^(3^4))`,
    not `((2^3)^4)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '9.15 **Error-prone evaluation**: Our evaluation algorithm is prone to errors
    because it expects expressions to be syntactically valid. How can you enhance
    it?'
  prefs: []
  type: TYPE_NORMAL
