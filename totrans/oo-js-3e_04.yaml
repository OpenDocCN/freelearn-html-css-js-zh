- en: Chapter 4. Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章 对象
- en: Now that you've mastered JavaScript's primitive data types, arrays, and functions,
    it's time to stay true to the promise of the book title and talk about objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了 JavaScript 的原始数据类型、数组和函数，是时候履行书名所承诺的内容，谈谈对象了。
- en: JavaScript has an eccentric take on the classical Object-oriented programming.
    Object-oriented programming is one of the most popular programming paradigms and
    has been a mainstay in most of programming languages like Java and C++. There
    are well defined ideas proposed by classical OOP that most of these languages
    adopt. JavaScript, however, has a different take on it. We will look JavaScript's
    way of supporting OOP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对经典面向对象编程有独特的看法。面向对象编程是最受欢迎的编程范式之一，并且在大多数编程语言（如 Java 和 C++）中都是主流。这些语言都采纳了经典
    OOP 提出的明确理念。然而，JavaScript 对此有不同的看法。我们将探讨 JavaScript 支持面向对象编程的方式。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: How to create and use objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用对象
- en: What are the constructor functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数函数有哪些
- en: What types of built-in JavaScript objects exist and what they can do for you
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在哪些内置 JavaScript 对象类型，以及它们能为您做什么
- en: From arrays to objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数组到对象
- en: 'As you already know from [Chapter 2](ch02.html "Chapter 2. Primitive Data Types,
    Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*,
    an array is just a list of values. Each value has an index (a numeric key) that
    starts from zero and increments by one for each value. Consider the following
    example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[第 2 章](ch02.html "第 2 章。原始数据类型、数组、循环和条件"), *原始数据类型、数组、循环和条件* 中所知，数组只是一个值列表。每个值都有一个索引（一个数字键），它从零开始，并为每个值递增。考虑以下示例：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you put the indexes in one column and the values in another, you''ll end
    up with a table of key/value pairs shown as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将索引放在一列，将值放在另一列，您将得到以下所示的关键字/值对表：
- en: '| **Key** | **Value** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **值** |'
- en: '| 0 | red |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 0 | red |'
- en: '| 1 | blue |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 1 | blue |'
- en: '| 2 | yellow |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 2 | yellow |'
- en: '| 3 | purple |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 3 | purple |'
- en: An object is similar to an array, but the difference is that you define the
    keys yourself. You're not limited to using only numeric indexes, and you can use
    friendlier keys such as `first_name`, `age`, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类似于数组，但不同之处在于您自己定义键。您不仅限于使用仅数字索引，还可以使用更友好的键，如 `first_name`、`age` 等。
- en: 'Let''s take a look at a simple object and examine its parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的对象，并检查其各个部分：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到：
- en: The name of the variable that refers to the object is `hero`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向对象的变量的名称是 `hero`
- en: Instead of `[` and `]`, which you use to define an array, you use `{` and `}`
    for objects
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与您用来定义数组的 `[` 和 `]` 不同，您使用 `{` 和 `}` 来定义对象
- en: You separate the elements (called properties) contained in the object with commas
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用逗号分隔对象中包含的元素（称为属性）
- en: The key/value pairs are divided by colons, as in `key:value`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键/值对由冒号分隔，如 `key:value`
- en: 'The keys (names of the properties) can optionally be placed in quotation marks.
    For example, these keys are all the same:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 键（属性的名称）可以可选地放在引号内。例如，这些键都是相同的：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s recommended that you don''t quote the names of the properties (it''s
    less typing), but there are cases when you must use quotes. Some of the cases
    are stated here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您不要引用属性的名称（这样可以减少输入），但在某些情况下您必须使用引号。以下是一些情况：
- en: If the property name is one of the reserved words in JavaScript (see [Appendix
    A](apa.html "Appendix A. Reserved Words"), *Reserved Words*)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性名称是 JavaScript 的保留字之一（见[附录 A](apa.html "附录 A. 保留字"), *保留字*）
- en: If it contains spaces or special characters (anything other than letters, numbers,
    and the `_` and `$` characters)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它包含空格或特殊字符（除字母、数字以及 `_` 和 `$` 字符之外的其他任何字符）
- en: If it starts with a number
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它以数字开头
- en: In other words, if the name you have chosen for a property is not a valid name
    for a variable in JavaScript, then you need to wrap it in quotes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果您为属性选择的名称不是 JavaScript 中变量的有效名称，那么您需要将其用引号括起来。
- en: 'Have a look at this bizarre-looking object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个看起来很奇怪的对象：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a valid object. The quotes are required for the second and the third
    properties; otherwise, you'll get an error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的对象。第二个和第三个属性的引号是必需的；否则，您将得到一个错误。
- en: Later in this chapter, you'll see other ways to define objects and arrays, in
    addition to `[]` and `{}`. However, first, let's introduce this bit of terminology
    - defining an array with `[]` is called **array literal notation**, and defining
    an object using curly braces `{}` is called **object literal notation**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将看到除了 `[]` 和 `{}` 之外，还有其他定义对象和数组的方法。然而，首先，让我们介绍一些术语——使用 `[]` 定义数组称为
    **数组字面量表示法**，使用花括号 `{}` 定义对象称为 **对象字面量表示法**。
- en: Elements, properties, methods, and members
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素、属性、方法和成员
- en: When talking about arrays, you say that they contain elements. When talking
    about objects, you say that they contain properties. There isn't any significant
    difference in JavaScript; it's just the terminology that people are used to, probably
    from other programming languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论数组时，你说它们包含元素。当谈论对象时，你说它们包含属性。在 JavaScript 中，这之间没有显著的区别；这只是人们习惯的术语，可能来自其他编程语言。
- en: 'A property of an object can point to a function, because functions are just
    data. Properties that point to functions are also called methods. In the following
    example, `talk` is a method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的属性可以指向一个函数，因为函数只是数据。指向函数的属性也称为方法。在以下示例中，`talk` 是一个方法：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you have seen in the previous chapter, it''s also possible to store functions
    as array elements and invoke them, but you''ll not see much code like this in
    practice:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，将函数作为数组元素存储并调用也是可能的，但在实际中你不会看到很多这样的代码：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can also see people using the word members to refer to the properties of
    an object, most often when it doesn't matter if the property is a function or
    not.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到人们使用单词 members 来指代对象的属性，通常在属性是函数与否并不重要时。
- en: Hashes and associative arrays
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散列和关联数组
- en: 'In some programming languages, there is a distinction between:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编程语言中，存在以下区别：
- en: A regular array, also called an **indexed** or **enumerated** array (the keys
    are numbers)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正规数组，也称为 **索引** 或 **枚举** 数组（键是数字）
- en: An associative array, also called a **hash** or a **dictionary** (the keys are
    strings)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联数组，也称为 **散列** 或 **字典**（键是字符串）
- en: JavaScript uses arrays to represent indexed arrays and objects to represent
    associative arrays. If you want a hash in JavaScript, you use an object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用数组来表示索引数组，使用对象来表示关联数组。如果你想在 JavaScript 中使用散列，你可以使用对象。
- en: Accessing an object's properties
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问对象的属性
- en: 'There are two ways to access the property of an object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 访问对象属性有两种方式：
- en: Using the square bracket notation, for example, `hero['occupation']`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方括号表示法，例如，`hero['occupation']`
- en: Using the dot notation, for example, `hero.occupation`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，使用点表示法，`hero.occupation`
- en: The dot notation is easier to read and write, but it cannot always be used.
    The same rules apply for quoting property names. If the name of the property is
    not a valid variable name, you cannot use the dot notation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 点表示法更容易阅读和编写，但并不总是可以使用。引用属性名称的规则也适用。如果属性名称不是一个有效的变量名，则不能使用点表示法。
- en: 'Let''s take the `hero` object again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看 `hero` 对象：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Following is an example for accessing a property with the dot notation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用点表示法访问属性示例：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s see an example for accessing a property with the bracket notation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用方括号表示法访问属性的一个示例：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Consider the following example for accessing a non-existing property returns
    `undefined`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，访问一个不存在的属性返回 `undefined`：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Objects can contain any data, including other objects:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以包含任何数据，包括其他对象：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get to the `firstname` property of the object contained in the `author`
    property of the `book` object, you can use the following lines of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问包含在 `book` 对象的 `author` 属性中的对象的 `firstname` 属性，你可以使用以下代码行：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let see an example using the square brackets notation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用方括号表示法的示例：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It works even if you mix both:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使混合使用也有效：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another case where you need square brackets is when the name of the property
    you need to access is not known beforehand. During runtime, it''s dynamically
    stored in a variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用方括号的其他情况是，当你需要访问的属性名称事先未知时。在运行时，它被动态地存储在一个变量中：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Calling an object's methods
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用对象的方法
- en: 'You know a method is just a property that happens to be a function, so you
    access methods in the same way in which you would access properties-using the
    dot notation or using square brackets. Calling (invoking) a method is the same
    as calling any other function - you just add parentheses after the method name,
    which effectively says Execute!:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道一个方法只是碰巧是函数的属性，所以你访问方法的方式与访问属性的方式相同——使用点符号或使用方括号。调用（调用）方法与调用任何其他函数相同——你只需在方法名后添加括号，这实际上是在说执行！：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If there are any parameters that you want to pass to a method, you would proceed
    as you would with normal functions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要传递任何参数给一个方法，你可以像处理普通函数一样进行：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can use the array-like square brackets to access a property, it means
    you can also use brackets to access and invoke methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以使用类似数组的方括号来访问属性，这意味着你也可以使用方括号来访问和调用方法：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is not a common practice, unless the method name is not known at the time
    of writing code, but it is instead defined at runtime:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一种常见的做法，除非在编写代码时不知道方法名，而是在运行时定义：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: No quotes unless you have to use the dot notation to access methods and properties,
    and don't quote properties in your object literals.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你需要使用点符号来访问方法和属性，否则不要加引号，也不要在对象字面量中加引号属性。
- en: Altering properties/methods
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改属性/方法
- en: JavaScript allows you to alter the properties and methods of existing objects
    at any time. This includes adding new properties or deleting them. You can start
    with a blank object and add properties later. Let's see how you can go about doing
    this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许你在任何时间更改现有对象的属性和方法。这包括添加新属性或删除它们。你可以从一个空白对象开始，然后添加属性。让我们看看你如何做到这一点。
- en: 'An object without properties is shown as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 没有属性的对象如下所示：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A "blank" object**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**“空白”对象**'
- en: In this section, you started with a "blank" object, `var hero = {}`. Blank is
    in quotes because this object is not really empty and useless. Although at this
    stage it has no properties of its own, it has already inherited some.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你从一个“空白”对象开始，`var hero = {}`。空白加引号是因为这个对象并不是真的空和无用。尽管在这个阶段它没有自己的属性，但它已经继承了一些。
- en: You'll learn more about own versus inherited properties later. So, an object
    in ES3 is never really blank or empty. In ES5 though, there is a way to create
    a completely blank object that doesn't inherit anything, but let's not get ahead
    too much.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在后面学习关于自有属性与继承属性的知识。所以，在ES3中，一个对象永远不会真正是空白或空的。然而，在ES5中，有一种方法可以创建一个完全不继承任何内容的完全空白对象，但让我们不要走得太远。
- en: 'Following is the code to access an non-existing property:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是如何访问一个不存在的属性的代码：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Adding two properties and a method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个属性和一个方法：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Calling the method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Deleting a property:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除属性：
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you call the method again, it will no longer find the deleted `name` property:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次调用该方法，它将不再找到已删除的`name`属性：
- en: '[PRE24]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Malleable objects**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**可塑对象**'
- en: You can always change any object at any time, such as adding and removing properties
    and changing their values. However, there are exceptions to this rule. A few properties
    of some built-in objects are not changeable (for example, `Math.PI`, as you'll
    see later). Also, ES5 allows you to prevent changes to objects. You'll learn more
    about it in [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时更改任何对象，例如添加和删除属性以及更改它们的值。然而，这个规则有一些例外。一些内置对象的某些属性是不可更改的（例如，`Math.PI`，你将在后面看到）。此外，ES5
    允许你防止对象的变化。你将在[附录C](apc.html "附录 C. 内置对象")*内置对象*中了解更多。
- en: Using the this value
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用this值
- en: 'In the previous example, the `sayName()` method used `hero.name` to access
    the `name` property of the `hero` object. When you''re inside a method though,
    there is another way to access the object the method belongs to. This method is
    using the special value `this`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`sayName()`方法使用`hero.name`来访问`hero`对象的`name`属性。但是当你在一个方法内部时，还有另一种方法可以访问该方法所属的对象。这种方法是使用特殊值`this`：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, when you say `this`, you're actually saying-this object or the current object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当你说`this`时，你实际上是在说——这个对象或当前对象。
- en: Constructor functions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'There is another way to create objects-using constructor functions. Let''s
    look at an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种创建对象的方法——使用构造函数。让我们看一个例子：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order to create an object using this function, you can use the `new` operator
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用此函数创建对象，你可以使用`new`运算符如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A benefit of using constructor functions is that they accept parameters, which
    can be used when creating new objects. Let''s modify the constructor to accept
    one parameter and assign it to the `name` property:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数的一个好处是它们可以接受参数，这些参数可以在创建新对象时使用。让我们修改构造函数以接受一个参数并将其分配给`name`属性：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you can create different objects using the same constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用相同的构造函数创建不同的对象：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, you should capitalize the first letter of your constructor functions
    so that you have a visual clue that they are not intended to be called as regular
    functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，你应该将构造函数的第一个字母大写，以便有一个视觉提示，表明它们不应该被当作常规函数调用。
- en: 'If you call a function that is designed to be a constructor but you omit the
    `new` operator, it is not an error. However, it doesn''t give you the expected
    result:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用一个设计为构造函数的函数但省略了`new`运算符，这不是一个错误。然而，它不会给你预期的结果：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What happened here? There is no `new` operator, so a new object was not created.
    The function was called like any other function, so the variable `h` contains
    the value that the function returns. The function does not return anything (there's
    no `return` function), so it actually returns `undefined`, which gets assigned
    to the variable `h`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？没有`new`运算符，所以没有创建新的对象。函数像任何其他函数一样被调用，所以变量`h`包含函数返回的值。该函数没有返回任何内容（没有`return`语句），所以实际上返回`undefined`，并将其分配给变量`h`。
- en: In this case, what does `this` refer to? It refers to the global object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`this`指的是什么？它指的是全局对象。
- en: The global object
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局对象
- en: You have already learned a bit about global variables (and how you should avoid
    them). You also know that JavaScript programs run inside a host environment (the
    browser, for example). Now that you know about objects, it's time for the whole
    truth, the host environment provides a global object, and all global variables
    are accessible as properties of the global object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了一些关于全局变量的知识（以及你应该如何避免它们）。你还知道JavaScript程序在宿主环境中运行（例如，浏览器）。现在，你已经了解了对象，是时候了解整个真相了，宿主环境提供了一个全局对象，所有全局变量都可以作为全局对象属性的访问。
- en: If your host environment is the web browser, the global object is called **window**.
    Another way to access the global object (and this is also true in most other environments)
    is to use `this` keyword outside a constructor function, for example in the global
    program code outside any function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宿主环境是网页浏览器，全局对象被称为**window**。另一种访问全局对象的方法（这在大多数其他环境中也是正确的）是在构造函数外部使用`this`关键字，例如在任何函数之外的全球程序代码中。
- en: 'As an illustration, you can declare a global variable outside any function
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，你可以在任何函数外部声明一个全局变量，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you can access this global variable in various ways:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过各种方式访问这个全局变量：
- en: As a variable `a`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为变量`a`
- en: As a property of the global object, for example, `window['a']` or `window.a`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为全局对象的一个属性，例如，`window['a']`或`window.a`
- en: 'As a property of the global object referred to as `this`:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为称为`this`的全局对象的一个属性：
- en: '[PRE32]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's go back to the case where you define a constructor function and call it
    without the `new` operator. In such cases, `this` refers to the global object
    and all the properties set to `this` become properties of `window`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到你定义一个构造函数并使用`new`运算符调用它的例子。在这种情况下，`this`指向全局对象，并且设置到`this`上的所有属性都成为`window`的属性。
- en: 'Declaring a constructor function and calling it without new returns `"undefined"`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个构造函数并使用`new`运算符调用它返回`"undefined"`：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you had `this` keyword inside the function `Hero`, a global variable (a
    property of the global object) called `name` was created:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在`Hero`函数内部有`this`关键字，所以创建了一个全局变量（全局对象的一个属性）名为`name`：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you call the same constructor function using `new`, then a new object is
    returned, and `this` refers to it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`new`调用相同的构造函数，则返回一个新的对象，并且`this`指向它：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The built-in global functions you have seen in [Chapter 3](ch03.html "Chapter 3. Functions"),
    *Functions*, can also be invoked as methods of the `window` object. So, the following
    two calls have the same result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第3章](ch03.html "第3章。函数")“函数”中看到的内置全局函数也可以作为`window`对象的方法来调用。因此，以下两个调用具有相同的结果：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The constructor property
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数属性
- en: When an object is created, a special property is assigned to it behind the scenes-the
    `constructor` property. It contains a reference to the constructor function used
    to create `this` object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个对象时，幕后会分配一个特殊属性给它——`constructor`属性。它包含一个指向用于创建`this`对象的构造函数的引用。
- en: 'Continuing from the previous example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个例子：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As the `constructor` property contains a reference to a function, you might
    as well call this function to produce a new object. The following code is like
    saying, "I don''t care how object `h2` was created, but I want another one just
    like it":'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `constructor` 属性包含对函数的引用，你不妨调用这个函数来生成一个新的对象。以下代码就像说，“我不关心对象 `h2` 是如何创建的，但我想要另一个完全一样的”：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If an object was created using the object literal notation, its constructor
    is the built-in `Object()` constructor function (there is more about this later
    in this chapter):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象是使用对象字面量表示法创建的，其构造函数是内置的 `Object()` 构造函数（关于这一点，本章后面会详细介绍）：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The instanceof operator
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: instanceof 操作符
- en: 'With the `instanceof` operator, you can test whether an object was created
    with a specific `constructor` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `instanceof` 操作符，你可以测试一个对象是否是由特定的 `constructor` 函数创建的：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that you don't put parentheses after the function name (you don't use `h
    instanceof Hero()`). This is because you're not invoking this function, but just
    referring to it by name, as with any other variable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不需要在函数名后加括号（你不需要使用 `h instanceof Hero()`）。这是因为你并没有调用这个函数，而是像任何其他变量一样通过名称引用它。
- en: Functions that return objects
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回对象的函数
- en: In addition to using `constructor` functions and the `new` operator to create
    objects, you can also use a normal function to create objects without the `new`
    operator. You can have a function that does a bit of preparatory work and has
    an object as a return value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `constructor` 函数和 `new` 操作符来创建对象外，你还可以使用一个普通函数来创建对象，而不使用 `new` 操作符。你可以有一个执行一些准备工作并返回对象的函数。
- en: 'For example, here''s a simple `factory()` function that produces objects:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个简单的 `factory()` 函数，它可以生成对象：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Consider the following example using the `factory()` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用 `factory()` 函数的例子：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In fact, you can also use `constructor` functions and `return` objects different
    from `this` keyword. This means you can modify the default behavior of the `constructor`
    function. Let's see how.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你也可以使用与 `this` 关键字不同的 `constructor` 函数和返回对象。这意味着你可以修改 `constructor` 函数的默认行为。让我们看看如何。
- en: 'Here''s the normal constructor scenario:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是正常的构造函数场景：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, now, look at this scenario:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，看看这个场景：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What happened here? Instead of returning the `this` object, which contains the
    property `a`, the constructor returned another object that contains the property
    `b`. This is possible only if the return value is an object. Otherwise, if you
    try to return anything that is not an object, the constructor will proceed with
    its usual behavior and return `this`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？不是返回包含属性 `a` 的 `this` 对象，而是构造函数返回了另一个包含属性 `b` 的对象。只有当返回值是对象时，这才能实现。否则，如果你尝试返回任何非对象，构造函数将按照其常规行为继续执行并返回
    `this`。
- en: 'If you think about how objects are created inside constructor functions, you
    can imagine that a variable called `this` is defined at the top of the function
    and then returned at the end. Consider the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑构造函数内部对象的创建方式，你可以想象在函数顶部定义了一个名为 `this` 的变量，然后在函数末尾返回它。考虑以下代码：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Passing objects
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递对象
- en: When you assign an object to a different variable or pass it to a function,
    you only pass a reference to that object. Consequently, if you make a change to
    the reference, you're actually modifying the original object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个对象分配给另一个变量或将其传递给函数时，你实际上只传递了该对象的引用。因此，如果你修改了引用，你实际上是在修改原始对象。
- en: 'Here''s an example of how you can assign an object to another variable and
    then make a change to the copy. As a result, the original object is also changed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，说明你可以将一个对象分配给另一个变量，然后对副本进行修改。结果，原始对象也被修改了：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The same thing applies when passing objects to functions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当将对象传递给函数时，同样适用：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Comparing objects
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较对象
- en: When you compare objects, you'll get `true` only if you compare two references
    to the same object. If you compare two distinct objects that happen to have the
    exact same methods and properties, the result would be `false`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你比较对象时，只有当你比较两个指向同一对象的引用时，你才会得到 `true`。如果你比较两个恰好具有完全相同方法和属性的独立对象，结果将是 `false`。
- en: 'Let''s create two objects that look the same:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个看起来相同的对象：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Comparing them returns `false`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 比较它们返回 `false`：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can create a new variable, `mydog`, and assign one of the objects to it.
    This way, the variable `mydog` actually points to the same object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个新的变量，`mydog`，并将其中一个对象分配给它。这样，变量 `mydog` 实际上指向的是同一个对象：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, `benji` is `mydog` because they are the same object (changing
    the `mydog` variable''s properties will change the `benji` variable''s properties).
    The comparison returns `true`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`benji` 是 `mydog`，因为它们是同一个对象（改变 `mydog` 变量的属性将改变 `benji` 变量的属性）。比较的结果返回
    `true`：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As `fido` is a different object, it does not compare to `mydog`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `fido` 是一个不同的对象，它不与 `mydog` 相等：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Objects in the WebKit console
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebKit 控制台中的对象
- en: Before diving into the built-in objects in JavaScript, let's quickly say a few
    words about working with objects in the WebKit console.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨 JavaScript 的内置对象之前，让我们简要地谈谈在 WebKit 控制台中与对象一起工作的方法。
- en: After playing around with the examples in this chapter, you might have already
    noticed how objects are displayed in the console. If you create an object and
    type its name, you'll get an arrow pointing to the word object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中尝试一番后，你可能已经注意到了对象在控制台中的显示方式。如果你创建了一个对象并输入它的名称，你会得到一个指向“对象”一词的箭头。
- en: 'The object is clickable and expands to show you a list of all of the properties
    of the object. If a property is also an object, there is an arrow next to it too,
    so you can expand this as well. This is handy as it gives you an insight into
    exactly what this object contains. Consider the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是可点击的，并且可以展开以显示对象的所有属性列表。如果一个属性也是一个对象，那么它旁边也会有箭头，这样你也可以展开它。这很方便，因为它让你可以深入了解这个对象包含的内容。考虑以下示例：
- en: '![Objects in the WebKit console](img/image_04_001-e1482749176512.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![WebKit 控制台中的对象](img/image_04_001-e1482749176512.jpg)'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can ignore `__proto__` for now; there's more about it in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以忽略 `__proto__`；关于它的更多内容将在下一章中介绍。
- en: Logging using the console.log method
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 console.log 方法进行记录
- en: The console also offers you an object called `console` and a few methods, such
    as `console.log()` and `console.error()`, which you can use to display any value
    you want in the console.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台还提供了一个名为 `console` 的对象和一些方法，例如 `console.log()` 和 `console.error()`，你可以使用它们在控制台中显示任何你想要的内容。
- en: '![Logging using the console.log method](img/image_04_002-e1482749557416.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![使用 console.log 方法进行记录](img/image_04_002-e1482749557416.jpg)'
- en: 'The `console.log()` method is convenient when you want to quickly test something,
    as well as when you want to dump some intermediate debugging information in your
    real scripts. Here''s how you can experiment with loops, for example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想快速测试某些内容，或者想在真实脚本中输出一些中间调试信息时，`console.log()` 方法非常方便。例如，你可以这样进行实验：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ES6 object literals
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES6 对象字面量
- en: 'ES6 introduces a much succinct syntax while using object literals. ES6 offers
    several shorthands for property initialization and function definitions. ES6 shorthands
    closely resemble a familiar JSON syntax. Consider the following code fragment:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 在使用对象字面量时引入了一种更简洁的语法。ES6 为属性初始化和函数定义提供了几个简写。ES6 的简写与熟悉的 JSON 语法非常相似。考虑以下代码片段：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is a typical way to assign property values. If the name of the variable
    and the property key is the same, ES6 allows you to use shorthand syntax. The
    preceding code can be written as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种典型的分配属性值的方式。如果变量的名称和属性键名相同，ES6 允许你使用简写语法。前面的代码可以写成如下形式：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Similar syntax is available for method definitions as well. As we have discussed,
    methods are simply properties of an object whose values are functions. Consider
    the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的语法也适用于方法定义。正如我们讨论过的，方法只是对象的属性，其值是函数。考虑以下示例：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There is a compact way to define methods in ES6\. You simply drop the `function`
    keyword and `:`. The equivalent code in ES6 would look like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中定义方法有一种紧凑的方式。你只需省略 `function` 关键字和 `:`。在 ES6 中的等效代码如下所示：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'ES6 allows you to compute the key of a property. Until ES6, you could only
    use fixed property names. Here is an example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 允许你计算属性的键。在 ES6 之前，你只能使用固定的属性名。以下是一个示例：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see, we are limited to using fixed key names: `prop` and `modifier`
    in this case. However, ES6 allows you to use computed property keys. It is possible
    to create property keys dynamically using values returned by a function as well:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们限制使用固定的键名：在这种情况下是 `prop` 和 `modifier`。然而，ES6 允许你使用计算属性键。你可以使用函数返回的值动态创建属性键：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We are using the value of variable `vehicle` to concatenate with a fixed string
    to derive the property key while creating the `car` object. In the second snippet,
    we are creating a property by concatenating a fixed string with the value returned
    by a function. This way of computing property keys provides great flexibility
    while creating objects, and a lot of boilerplate and repetitive code can be eliminated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用变量 `vehicle` 的值与一个固定字符串连接来推导出 `car` 对象的属性键。在第二个片段中，我们通过将固定字符串与函数返回的值连接来创建属性。这种方式计算属性键在创建对象时提供了极大的灵活性，并且可以消除大量的样板和重复代码。
- en: 'This syntax is applicable to method definition as well:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法也适用于方法定义：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Object properties and attributes
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象属性和属性
- en: 'Each object has a few properties. Each property, in turn, has a key and attributes.
    A property''s state is stored in these attributes. All properties have the following
    attributes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一些属性。每个属性又包含一个键和属性。属性的状态存储在这些属性中。所有属性都具有以下属性：
- en: '**Enumerable (boolean)**: This indicates if you can enumerate the properties
    of the object. System properties are non-enumerable while user properties are
    enumerable. Unless there is a strong reason, this property should remain untouched.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可枚举（布尔值）**：这表示你是否可以枚举对象的属性。系统属性是不可枚举的，而用户属性是可枚举的。除非有充分的理由，否则这个属性应该保持不变。'
- en: '**Configurable(boolean)**: If this attribute is `false`, the property cannot
    be deleted or edited (it cannot change any of its attribute).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置（布尔值）**：如果此属性为 `false`，则属性不能被删除或编辑（它不能更改其任何属性）。'
- en: 'You can use the `Object.getOwnPropertyDescriptor()` method to retrieve an object''s
    own properties:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Object.getOwnPropertyDescriptor()` 方法来检索对象的自身属性：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Meanwhile, the property can be defined using the `Object.defineProperty() method`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，可以使用 `Object.defineProperty()` 方法来定义属性：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Though you would never use these methods, it is important to understand object
    properties and attributes. In the next section, we will discuss how some of the
    `object` methods are used in context of some of these properties.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您永远不会使用这些方法，但了解对象属性和属性很重要。在下一节中，我们将讨论一些 `object` 方法是如何在涉及这些属性的情况下使用的。
- en: ES6 object methods
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6 对象方法
- en: ES6 introduces a few static helper methods for objects. `Object.assign` is a
    helper method that replaces popular mixins to perform a shallow copy of an object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了一些针对对象的静态辅助方法。`Object.assign` 是一个辅助方法，它取代了流行的混入来执行对象的浅拷贝。
- en: Copy properties using Object.assign
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Object.assign` 复制属性
- en: 'This method is used to copy properties of the target object into the source
    object. In other words, this method merges the source object with the target object
    and modifies the target object:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将目标对象的属性复制到源对象中。换句话说，此方法将源对象与目标对象合并，并修改目标对象：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first parameter to `Object.assign` is the target on which source properties
    are copied. The same target object is returned to the caller. Existing properties
    are overwritten, while properties that aren''t part of the source object are ignored:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign` 的第一个参数是要复制源属性的目标对象。返回给调用者的对象是相同的。现有属性会被覆盖，而源对象中不存在的属性会被忽略：'
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Object.assign` can take multiple source objects. You can write `Object.assign(target,
    source1, source2)`. Here is an example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign` 可以接受多个源对象。您可以写 `Object.assign(target, source1, source2)`。以下是一个示例：'
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this snippet, we are assigning properties from multiple source objects. Also,
    notice how `Object.assign()` returns the target object, which we in turn use inside
    `console.log()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们正在从多个源对象中分配属性。同时，请注意 `Object.assign()` 返回的目标对象，我们随后在 `console.log()`
    中使用它。
- en: One point to note is that only enumerable own (non-inherited) properties can
    be copied using `Object.assign()`. Properties from the prototype chain (will be
    discussed later in this chapter when we talk about Inheritance) are not considered.
    Our earlier discussion of enumerable properties will help you understand this
    distinction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，只有可枚举的自身（非继承的）属性才能使用 `Object.assign()` 进行复制。原型链上的属性（将在本章后面讨论继承时讨论）不被考虑。我们之前关于可枚举属性的讨论将帮助您理解这种区别。
- en: 'In the following example, we will create a non-enumerable property using `defineProperty()`
    and validate the fact that `Object.assign()` ignores that property:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用 `defineProperty()` 创建一个不可枚举的属性，并验证 `Object.assign()` 忽略该属性的事实：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The property defined as `superpowers` has the enumerable attribute set to `false`.
    While copying properties, this property is ignored.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 被定义为 `superpowers` 的属性将可枚举属性设置为 `false`。在复制属性时，此属性将被忽略。
- en: Compare values with Object.is
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Object.is 比较值
- en: 'ES6 provides a slightly precise way of comparing values. We have discussed
    the strict equality operator `===`. However, for `NaN` and `-0` and `+0`, the
    strict equality operator behaves inconsistently. Here is an example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了一种稍微精确的比较值的方法。我们已经讨论了严格相等操作符 `===`。然而，对于 `NaN`、`-0` 和 `+0`，严格相等操作符的行为不一致。以下是一个例子：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Apart from these two cases, `Object.is()` can safely be replaced with the `===`
    operator.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两种情况，`Object.is()` 可以安全地替换为 `===` 操作符。
- en: Destructuring
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: 'You will be working with objects and arrays all the time when you code. JavaScript
    object and array notations resemble the JSON format. You will define objects and
    arrays, and then retrieve elements from them. ES6 gives a convenient syntax that
    significantly improves the way we access properties/members from objects and arrays.
    Let''s consider a typical code you would often write:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编码时，你将始终与对象和数组打交道。JavaScript 对象和数组表示法类似于 JSON 格式。你将定义对象和数组，然后从它们中检索元素。ES6
    提供了一种方便的语法，显著改进了我们访问对象和数组属性/成员的方式。让我们考虑你经常会编写的典型代码：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we extracted values of server and port from the `config` object and assigned
    them to local variables. Pretty straightforward! However, when this object has
    a bunch of properties, some of them nested, this simple operation can get very
    tedious to write.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从 `config` 对象中提取了 `server` 和 `port` 的值，并将它们分配给局部变量。非常直接！然而，当这个对象有很多属性，其中一些是嵌套的，这个简单的操作可能会变得非常繁琐。
- en: 'ES6 destructuring syntax allows an object literal on the left-hand side of
    an assignment statement. In the following example, we will define an object `config`
    with a few properties. Later, we will use destructuring to assign the object `config`
    to assign values to individual properties on the left-hand side of the assignment
    statement:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 解构语法允许在赋值语句的左侧使用对象字面量。在下面的例子中，我们将定义一个具有几个属性的 `config` 对象。稍后，我们将使用解构将对象 `config`
    分配给赋值语句左侧的单独属性：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you can see `server` and `port` are local variables that got assigned properties
    from the `config` object because the name of the properties were the same as that
    of the local variables. You can also pick particular properties while you assign
    them to local variables. Here is an example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`server` 和 `port` 是从 `config` 对象中获取属性值的局部变量，因为它们的属性名与局部变量的名称相同。你还可以在将属性分配给局部变量时选择特定的属性。以下是一个例子：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we are only picking `timeout` from the `config` object and assign it to
    a local variable `t`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只从 `config` 对象中选取 `timeout` 并将其分配给局部变量 `t`。
- en: 'You can also use the destructuring syntax to assign values to already declared
    variables. In this case, you have to put parentheses around the assignment:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用解构语法将值分配给已经声明的变量。在这种情况下，你必须将赋值表达式放在括号内：
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As the destructuring expression evaluates to the right-hand side of the expression,
    it''s possible to use it anywhere you would expect a value. For example, in a
    function call, as shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解构表达式计算结果为表达式的右侧，因此它可以在任何期望值的地方使用。例如，在函数调用中，如下所示：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you specify a local variable with a property name that does not exist in
    the object, the local variable gets an `undefined` value. However, while using
    variables in the destructuring assignment, you can optionally specify default
    values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了一个具有对象中不存在属性名的局部变量，该局部变量将获得一个 `undefined` 值。然而，在使用解构赋值中的变量时，你可以选择性地指定默认值：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, for a non-existent property timeout, we provided a default
    value to prevent getting `undefined` values assigned to local variables.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对于不存在的属性 `timeout`，我们提供了一个默认值以防止将 `undefined` 值分配给局部变量。
- en: 'Destructuring works on arrays as well, and the syntax is also very similar
    to that of the objects. We just need to replace object literal syntax with `array:literals`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 解构同样适用于数组，其语法与对象也非常相似。我们只需将对象字面量语法替换为 `array:literals`：
- en: '[PRE74]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As you can see, this is the exact same syntax we saw earlier. We defined an
    array `arr` and later used the destructuring syntax to assign elements of that
    array to two local variables, `x` and `y`. Here, the assignment happens based
    on the order of elements in the array. As you only care about the position of
    elements, you can skip some of them if you want to. Here is an example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这正是我们之前看到的相同语法。我们定义了一个数组`arr`，后来使用解构语法将数组的元素分配给两个局部变量`x`和`y`。在这里，赋值是基于数组中元素的顺序进行的。既然你只关心元素的顺序，如果你想的话，可以跳过一些元素。以下是一个示例：
- en: '[PRE75]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here, we know that we need elements from positions 2 and 3 (an array''s index
    starts from 0), and hence, we ignore elements at positions 0 and 1\. Array destructuring
    can eliminate the use of a `temp` variable while swapping values of two variables.
    Consider the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们知道我们需要从位置2和3获取元素（数组的索引从0开始），因此，我们忽略位置0和1的元素。数组解构可以消除交换两个变量值时使用`temp`变量的需求。考虑以下示例：
- en: '[PRE76]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can use the rest operator (`...`) to extract remaining elements and assign
    them to an array. The rest operator can only be used as the last operator during
    destructuring:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用剩余操作符（`...`）提取剩余元素并将它们分配给一个数组。剩余操作符只能在解构时作为最后一个操作符使用：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Built-in objects
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置对象
- en: Earlier in this chapter, you came across the `Object()` constructor function.
    It's returned when you create objects with the object literal notation and access
    their `constructor` property. `Object()` is one of the built-in constructors;
    there are a few others, and in the rest of this chapter you'll see all of them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你遇到了`Object()`构造函数。当你使用对象字面量表示法创建对象并访问它们的`constructor`属性时，它会返回。`Object()`是内置构造函数之一；还有几个其他的，在本章的其余部分你将看到所有这些。
- en: 'The built-in objects can be divided into three groups:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 内置对象可以分为三组：
- en: '**Data wrapper objects**: These are `Object`, `Array`, `Function`, `Boolean`,
    `Number`, and `String`. These objects correspond to the different data types in
    JavaScript. There is a data wrapper object for every different value returned
    by `typeof` (discussed in [Chapter 2](ch02.html "Chapter 2. Primitive Data Types,
    Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*),
    with the exception of `undefined` and `null`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据包装对象**：这些是`Object`、`Array`、`Function`、`Boolean`、`Number`和`String`。这些对象对应于JavaScript中的不同数据类型。对于`typeof`（在[第2章](ch02.html
    "第2章. 原始数据类型、数组、循环和条件")中讨论）返回的每个不同值都有一个数据包装对象，除了`undefined`和`null`。'
- en: '**Utility objects**: These are `Math`, `Date`, and `RegExp`, and can come in
    handy.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用对象**：这些是`Math`、`Date`和`RegExp`，它们可能会很有用。'
- en: '**Error objects**: These include the generic `Error` object as well as other
    more specific objects that can help your program recover its working state when
    something unexpected happens.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误对象**：这些包括通用的`Error`对象以及其他更具体的对象，可以帮助你的程序在发生意外情况时恢复其工作状态。'
- en: Only a handful of methods of the built-in objects will be discussed in this
    chapter. For a full reference, see [Appendix C](apc.html "Appendix C. Built-in
    Objects"), *Built-in Objects*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论内置对象的一小部分方法。对于完整参考，请参阅[附录C](apc.html "附录 C. 内置对象")，*内置对象*。
- en: If you're confused about what a built-in object is and what a built-in constructor
    is, well, they are the same thing. In a moment, you'll see how functions and,
    therefore, constructor functions, are also objects.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于什么是内置对象和什么是内置构造函数感到困惑，那么，它们是同一件事。稍后，你会看到函数以及因此构造函数也是对象。
- en: Object
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'Object is the parent of all JavaScript objects, which means that every object
    you create inherits from it. To create a new empty object, you can use the literal
    notation or the `Object()` constructor function. The following two lines are equivalent:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是所有JavaScript对象的父对象，这意味着你创建的每个对象都继承自它。要创建一个新的空对象，你可以使用字面量表示法或`Object()`构造函数。以下两行是等价的：
- en: '[PRE78]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As mentioned before, an empty (or blank) object is not completely useless,
    because it already contains several inherited methods and properties. In this
    book, empty means an object like `{}` that has no properties of its own, other
    than the ones it automatically gets. Let''s look at a few of the properties that
    even blank objects already have:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个空（或空白）对象并不是完全没有用，因为它已经包含了一些继承的方法和属性。在这本书中，空指的是像`{}`这样的对象，它没有任何自己的属性，除了它自动获取的属性。让我们看看一些即使空白对象也已有的属性：
- en: The `o.constructor` property returns a reference to the constructor function
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o.constructor` 属性返回对构造函数的引用'
- en: The `o.toString()` is a method that returns a string representation of the object
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o.toString()` 是一个返回对象字符串表示形式的方法'
- en: The `o.valueOf()` returns a single-value representation of the object; often,
    this is the object itself
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o.valueOf()` 返回对象的单值表示形式；通常情况下，这就是对象本身'
- en: 'Let''s see these methods in action. First, create an object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些方法在实际中的应用。首先，创建一个对象：
- en: '[PRE79]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Calling `toString()` returns a string representation of the object:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `toString()` 返回对象的字符串表示形式：
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `toString()` method will be called internally by JavaScript when an object
    is used in a string context. For example, `alert()` works only with strings, so
    if you call the `alert()` function passing an object, the `toString()`method will
    be called behind the scenes. These two lines produce the same result:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象在字符串上下文中使用时，JavaScript 会内部调用 `toString()` 方法。例如，`alert()` 只能处理字符串，所以如果你调用
    `alert()` 函数并传递一个对象，后台会调用 `toString()` 方法。这两行代码会产生相同的结果：
- en: '[PRE81]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Another type of string context is the string concatenation. If you try to concatenate
    an object with a string, the object''s `toString()` method is called first:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种字符串上下文是字符串连接。如果你尝试将一个对象与一个字符串连接，首先会调用对象的 `toString()` 方法：
- en: '[PRE82]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `valueOf()` method is another method that all objects provide. For the
    simple objects (whose constructor is `Object()`), the `valueOf()` method returns
    the object itself:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf()` 方法是所有对象都提供的一个方法。对于简单对象（其构造函数为 `Object()`），`valueOf()` 方法返回对象本身：'
- en: '[PRE83]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To summarize:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 总结如下：
- en: You can create objects either with `var o = {};` (object literal notation, the
    preferred method) or with `var o = new Object();`
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过 `var o = {};`（对象字面量表示法，推荐的方法）或 `var o = new Object();` 来创建对象
- en: Any object, no matter how complex, inherits from the `Object` object and therefore,
    offers methods such as `toString()` and properties such as a constructor
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对象，无论多么复杂，都继承自 `Object` 对象，因此提供了如 `toString()` 这样的方法和如构造函数这样的属性
- en: Array
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array
- en: '`Array()` is a built-in function that you can use as a constructor to create
    arrays:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array()` 是一个内置函数，你可以将其用作构造函数来创建数组：'
- en: '[PRE84]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This is equivalent to the array literal notation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这与数组字面量表示法等价：
- en: '[PRE85]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'No matter how the array is created, you can add elements to it as usual:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数组是如何创建的，你都可以像往常一样向其中添加元素：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'When using the `Array()` constructor, you can also pass values that will be
    assigned to the new array''s elements:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Array()` 构造函数时，你也可以传递将被分配给新数组元素的值：
- en: '[PRE87]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'An exception to this is when you pass a single number to the constructor. In
    this case, the number is considered to be the length of the array:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是当你向构造函数传递一个单个数字时。在这种情况下，这个数字被认为是数组的长度：
- en: '[PRE88]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As arrays are created with a constructor, does this mean that arrays are in
    fact objects? Yes, and you can verify this using the `typeof` operator:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是通过构造函数创建的，这意味着数组实际上也是对象？是的，你可以使用 `typeof` 操作符来验证这一点：
- en: '[PRE89]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As arrays are objects, this means that they inherit the properties and methods
    of the parent object:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是对象，这意味着它们继承了父对象的属性和方法：
- en: '[PRE90]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Arrays are objects, but of a special type because:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是对象，但属于特殊类型，因为：
- en: The names of their properties are automatically assigned using numbers starting
    from 0.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的属性名会自动使用从 0 开始的数字进行分配。
- en: They have a `length` property that contains the number of elements in the array.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个包含数组中元素数量的 `length` 属性。
- en: They have more built-in methods in addition to those inherited from the parent
    object.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了从父对象继承的方法之外，它们还有更多内置方法。
- en: 'Let''s examine the differences between an array and an object, starting by
    creating the empty array `a` and the empty object `o`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建空数组 `a` 和空对象 `o` 来检查数组和对象之间的差异：
- en: '[PRE91]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Array objects have a `length` property automatically defined for them, while
    normal objects do not:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象自动定义了一个 `length` 属性，而普通对象则没有：
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'It''s ok to add both numeric and non-numeric properties to both arrays and
    objects:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组和对象中添加数字和非数字属性都是可以的：
- en: '[PRE93]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `length` property is always up to date with the number of numeric properties,
    while it ignores the non-numeric ones:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 属性始终与数字属性的数量保持一致，而忽略非数字属性：'
- en: '[PRE94]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `length` property can also be set by you. Setting it to a greater value
    than the current number of items in the array makes room for additional elements.
    If you try to access these non-existing elements, you''ll get the value `undefined`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 属性也可以由你设置。将其设置为大于数组当前项目数量的值，可以为额外的元素腾出空间。如果你尝试访问这些不存在的元素，你会得到值 `undefined`：'
- en: '[PRE95]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Setting the `length` property to a lower value removes the trailing elements:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `length` 属性设置为较小的值会移除尾部元素：
- en: '[PRE96]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: A few array methods
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 几种数组方法
- en: In addition to the methods inherited from the parent object, array objects also
    have specialized methods for working with arrays, such as `sort()`, `join()`,
    and `slice()`, among others (see [Appendix C](apc.html "Appendix C. Built-in Objects"),
    *Built-in Objects*, for the complete list).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从父对象继承的方法外，数组对象还有专门用于处理数组的特定方法，例如 `sort()`、`join()` 和 `slice()` 等（有关完整列表，请参阅
    [附录 C](apc.html "附录 C. 内置对象")，*内置对象*）。
- en: 'Let''s take an array and experiment with some of these methods:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿一个数组并实验一些这些方法：
- en: '[PRE97]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `push()` method appends a new element to the end of the array. The `pop()`
    method removes the last element. The `a.push('new')` method works like `a[a.length]
    = 'new'`, and `a.pop()` is like `a.length-`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 方法将新元素追加到数组的末尾。`pop()` 方法移除最后一个元素。`a.push(''new'')` 方法类似于 `a[a.length]
    = ''new''`，而 `a.pop()` 则类似于 `a.length-`。'
- en: 'The `push()` method returns the length of the changed array, whereas `pop()`
    returns the removed element:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 方法返回更改后数组的长度，而 `pop()` 返回被移除的元素：'
- en: '[PRE98]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `sort()` method sorts the array and returns it. In the next example, after
    sort, both `a` and `b` point to the same array:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 方法对数组进行排序并返回它。在下一个示例中，排序后，`a` 和 `b` 都指向同一个数组：'
- en: '[PRE99]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `join()` method returns a string containing the values of all the elements
    in the array glued together using the string parameter passed to `join()`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法返回一个字符串，其中包含数组中所有元素的值，这些值使用传递给 `join()` 的字符串参数粘合在一起：'
- en: '[PRE100]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `slice()` method returns a piece of the array without modifying the source
    array. The first parameter to `slice()` is the start index (zero-based), and the
    second is the end index (both indices are zero-based). Start index is included,
    while the end index is not. Take a look at the following example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice()` 方法返回数组的部分，而不修改源数组。`slice()` 的第一个参数是起始索引（基于零），第二个参数是结束索引（两个索引都是基于零的）。起始索引包含在内，而结束索引不包含。请看以下示例：'
- en: '[PRE101]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'After all the slicing, the source array is still the same:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有切片之后，源数组仍然是相同的：
- en: '[PRE102]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `splice()` method modifies the source array. It removes a slice, returns
    it, and optionally fills the gap with new elements. The first two parameters define
    the start index and length (number of elements) of the slice to be removed; the
    other parameters pass the new values:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice()` 方法修改源数组。它移除一个片段，返回它，并可选择用新元素填充空缺。前两个参数定义要移除的片段的起始索引和长度（元素数量）；其他参数传递新值：'
- en: '[PRE103]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Filling the gap with new elements is optional, so you can skip it:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新元素填充空缺是可选的，因此你可以跳过它：
- en: '[PRE104]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: ES6 array methods
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6 数组方法
- en: Arrays get a bunch of useful methods. Libraries such as **lodash** and **underscore**
    provided features missing in the language so far. With the new helper methods,
    array creation and manipulation is much more functional and easy to code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 数组获得了一组有用的方法。例如 **lodash** 和 **underscore** 这样的库提供了语言之前所缺少的功能。有了这些新的辅助方法，数组的创建和操作变得更加功能化和易于编码。
- en: Array.from
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.from
- en: Converting array-like values to arrays has always been a bit of a challenge
    in JavaScript. People have employed several hacks and written libraries to just
    let you handle arrays effectively.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，将类似数组的值转换为数组一直是一个挑战。人们已经使用了几种技巧并编写了库，以便有效地处理数组。
- en: 'ES6 introduces a very helpful method to convert array-like objects and iterable
    values into arrays. Array-like values are objects that have a length property
    and indexed elements. Every function has an implicit arguments variable that contains
    a list of all arguments passed to the function. This variable is an array-like
    object. Before ES6, the only way we could convert the `arguments` object to an
    array was to iterate through it and copy the values over to a new array:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了一种非常有用的方法，可以将类似数组的对象和可迭代值转换为数组。类似数组的值是具有长度属性和索引元素的对象。每个函数都有一个隐含的 `arguments`
    变量，它包含传递给函数的所有参数的列表。这个变量是一个类似数组的对象。在 ES6 之前，我们只能通过迭代它并将值复制到一个新数组中来将 `arguments`
    对象转换为数组：
- en: '[PRE105]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Here, we are creating a new array to copy over all elements of the `arguments`
    object. This is wasteful and needs a lot of unnecessary coding. `Array.from()`
    is a concise way to convert array-like objects into arrays. We can convert this
    example to a more succinct one using `Array.from()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个新的数组来复制 `arguments` 对象的所有元素。这是浪费的，并且需要大量的不必要的编码。`Array.from()` 是将类似数组的对象转换为数组的一种简洁方式。我们可以使用
    `Array.from()` 将此示例转换为更简洁的一个：
- en: '[PRE106]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You can provide your own mapping scheme while calling `Array.from()` by providing
    a mapping function. This function is invoked on all the elements of the object
    and converts it. This is a useful construct for many common usecases, for example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `Array.from()` 时，你可以通过提供一个映射函数来提供自己的映射方案。这个函数会在对象的所有元素上被调用，并将它们转换。这对于许多常见用例非常有用，例如：
- en: '[PRE107]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In this example, we are deconstructing the `arguments` object using `Array.from`
    and for each element in `arguments` object, we are calling a function.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在使用 `Array.from` 解构 `arguments` 对象，并对 `arguments` 对象中的每个元素调用一个函数。
- en: Creating arrays using Array.of
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Array.of 创建数组
- en: 'Creating an array using the `Array()` constructor causes a bit of a problem.
    The constructor behaves differently based on the number and type of arguments.
    When you pass a single numeric value to the `Array()` constructor, an array of
    undefined elements is created, with the value of the length assigned to the value
    of the argument:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Array()` 构造函数创建数组会导致一些问题。构造函数的行为根据参数的数量和类型而有所不同。当你向 `Array()` 构造函数传递单个数值时，会创建一个包含未定义元素的数组，其长度值被分配给参数值：
- en: '[PRE108]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'On the other hand, if you pass only one non-numeric value, it becomes the only
    item in the array:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你只传递一个非数值，它将成为数组中的唯一项：
- en: '[PRE109]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This is not all. If you pass multiple values, they become elements of the array:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不算完。如果你传递多个值，它们将成为数组的元素：
- en: '[PRE110]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'So, clearly, there needs to be a better way to create arrays to avoid such
    confusion. ES6 introduces the `Array.of` method that works like the `Array()`
    constructor, but guarantees one standard behavior. `Array.of` creates an array
    from its arguments, regardless of their number and type:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显然需要一个更好的方法来创建数组，以避免这种混淆。ES6 引入了 `Array.of` 方法，它的工作方式类似于 `Array()` 构造函数，但保证了统一的行为。`Array.of`
    从其参数创建一个数组，无论它们的数量和类型如何：
- en: '[PRE111]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Array.prototype methods
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组原型方法
- en: ES6 introduces several interesting methods as part of array instances. These
    methods help with array iteration and searching elements in the array, both of
    which are very frequent and useful operations.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 在数组实例中引入了几个有趣的方法。这些方法有助于数组迭代和在数组中搜索元素，这两者都是非常频繁且有用的操作。
- en: 'Here are the methods used for iterating over arrays:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于遍历数组的几种方法：
- en: '`Array.prototype.entries()`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.entries()`'
- en: '`Array.prototype.values()`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.values()`'
- en: '`Array.prorotype.keys()`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.keys()`'
- en: 'All three methods return an iterator. This iterator can be used to create arrays
    using `Array.from()` and can be used in for loops for iteration:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种方法都返回一个迭代器。这个迭代器可以用来使用 `Array.from()` 创建数组，也可以在循环中用于迭代：
- en: '[PRE112]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Similarly, there are new methods for searching within arrays. Looking for an
    element in an array usually involved iterating through the entire list and comparing
    them with a value, as there were no built-in methods for this. Though `indexOf()`
    and `lastIndexOf()` helped find a single value, there was no way to find elements
    based on complex conditions. With ES6, the following build-in methods help with
    `this` keyword.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有用于在数组中搜索的新方法。在数组中查找一个元素通常涉及遍历整个列表并将它们与一个值进行比较，因为没有内置的方法来做这件事。尽管 `indexOf()`
    和 `lastIndexOf()` 有助于找到单个值，但没有方法可以根据复杂条件找到元素。随着 ES6 的到来，以下内置方法帮助使用 `this` 关键字。
- en: '`Array.prototype.find`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.find`'
- en: '`Array.prototype.findIndex`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.findIndex`'
- en: 'Both these methods accept two arguments-first is the `callback` function(which
    contains the predicate condition) and the second is an optional `this` keyword.
    The `callback` accepts three arguments: the array element, index of that element,
    and the array. The `callback` returns `true` if the element matches the predicate:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法接受两个参数——第一个是 `callback` 函数（包含谓词条件），第二个是可选的 `this` 关键字。`callback` 接受三个参数：数组元素、该元素的索引和数组。如果元素匹配谓词，则
    `callback` 返回 `true`：
- en: '[PRE113]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Function
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'You already know that functions are a special data type. However, it turns
    out that there''s more to it than that: functions are actually objects. There
    is a built-in `constructor` function called `Function()` that allows for an alternative
    (but not necessarily recommended) way to create a function.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道函数是一种特殊的数据类型。然而，实际上还有更多：函数实际上是对象。存在一个内置的 `constructor` 函数称为 `Function()`，它允许以另一种（但不一定推荐）方式创建函数。
- en: 'The following example shows three ways to define a function:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了定义函数的三个方法：
- en: '[PRE114]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: When using the `Function()` constructor, you pass the parameter names first
    (as strings) and then the source code for the body of the function (again as a
    string). The JavaScript engine needs to evaluate the source code you pass and
    create the new function for you. This source code evaluation suffers from the
    same drawbacks as the `eval()` function, so defining functions using the `Function()`
    constructor should be avoided when possible.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Function()` 构造函数时，你首先传递参数名称（作为字符串），然后是函数主体的源代码（再次作为字符串）。JavaScript 引擎需要评估你传递的源代码并为你创建新函数。这种源代码评估与
    `eval()` 函数具有相同的缺点，因此当可能时，应避免使用 `Function()` 构造函数定义函数。
- en: 'If you use the `Function()` constructor to create functions that have lots
    of parameters, bear in mind that the parameters can be passed as a single comma-delimited
    list; so, for example, these are the same:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `Function()` 构造函数创建具有许多参数的函数，请记住参数可以作为一个逗号分隔的单个列表传递；例如，这些是相同的：
- en: '[PRE115]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use the `Function()` constructor. As with `eval()` and `setTimeout()`
    (discussed later in the book), always try to stay away from passing JavaScript
    code as a string.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `Function()` 构造函数。就像 `eval()` 和 `setTimeout()`（本书后面将讨论）一样，始终尝试避免将 JavaScript
    代码作为字符串传递。
- en: Properties of function objects
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数对象的属性
- en: 'Like any other object, functions have a `constructor` property that contains
    a reference to the `Function()` constructor function. This is true no matter which
    syntax you used to create the function:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他对象一样，函数有一个 `constructor` 属性，它包含对 `Function()` 构造函数的引用。这适用于你创建函数时使用的任何语法：
- en: '[PRE116]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Functions also have a `length` property, which contains the number of formal
    parameters the function expects:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还有一个 `length` 属性，它包含函数期望的正式参数数量：
- en: '[PRE117]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Using the prototype property
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用原型属性
- en: 'One of the most widely used properties of function objects is the `prototype`
    property. You''ll see this property discussed in detail in the next chapter, but
    for now, let''s just say:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象最广泛使用的属性之一是 `prototype` 属性。你将在下一章中详细讨论这个属性，但现在是这样的：
- en: The `prototype` property of a `function` object points to another object
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象的 `prototype` 属性指向另一个对象
- en: Its benefits shine only when you use this `function` as a constructor
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的好处只有在将此 `function` 用作构造函数时才会显现
- en: All objects created with this `function` keep a reference to the `prototype`
    property and can use its properties as their own
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这个 `function` 创建的所有对象都保留了对 `prototype` 属性的引用，并且可以使用其属性作为自己的属性
- en: 'Let''s look at a quick example to demonstrate the `prototype` property. Take
    a simple object that has a property name and a method `say()` method:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来演示 `prototype` 属性。考虑一个简单的对象，它有一个属性名和一个 `say()` 方法：
- en: '[PRE118]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'When you create a function (even one without a body), you can verify that it
    automatically has a `prototype` property that points to a new object:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个函数（即使是没有主体的函数），你可以验证它自动具有一个指向新对象的 `prototype` 属性：
- en: '[PRE119]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'It gets interesting when you modify the `prototype` property. You can add properties
    to it, or you can replace the default object with any other object. Let''s assign
    `ninja` to the `prototype`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改 `prototype` 属性时，事情变得有趣。你可以向其中添加属性，或者用任何其他对象替换默认对象。让我们将 `ninja` 赋值给 `prototype`：
- en: '[PRE120]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, and here''s where the magic happens, using the `F()`function as a `constructor`
    function, you can create a new object, `baby_ninja`, which will have access to
    the properties of `F.prototype` (which points to `ninja`) as if it were its own:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里发生魔法的地方，使用 `F()` 函数作为构造函数，你可以创建一个新的对象 `baby_ninja`，它将能够访问 `F.prototype`（指向
    `ninja`）的属性，就像它们是自己的属性一样：
- en: '[PRE121]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: There will be much more on this topic later. In fact, the next chapter is all
    about the `prototype` property.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题将有更多内容。实际上，下一章全部都是关于 `prototype` 属性的。
- en: Methods of function objects
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数对象的属性
- en: 'Function objects, being a descendant of the top parent object, get the default
    methods such as `toString()`. When invoked on a function, the `toString()` method
    returns the source code of the function:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象作为顶级父对象的子类，继承了默认方法，如`toString()`。当在函数上调用时，`toString()`方法返回函数的源代码：
- en: '[PRE122]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'If you try to peek into the source code of the built-in functions, you''ll
    get the `[native code]` string instead of the body of the function:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试查看内置函数的源代码，你会得到`[native code]`字符串而不是函数体：
- en: '[PRE123]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: As you can see, you can use `toString()` to differentiate between native methods
    and developer-defined ones.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以使用`toString()`来区分原生方法和开发者定义的方法。
- en: Note
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The behavior of the function's `toString()` is environment dependent, and it
    differs among browsers in terms of spacing and new lines.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的`toString()`行为与环境相关，在空格和换行符方面，不同浏览器之间有所不同。
- en: Call and apply
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用和应用
- en: Function objects have `call()` and `apply()` methods. You can use them to invoke
    a function and pass any arguments to it.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象有`call()`和`apply()`方法。你可以使用它们来调用函数并传递任何参数。
- en: These methods also allow your objects to borrow methods from other objects and
    invoke them as their own. This is an easy and powerful way to reuse code.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法还允许你的对象从其他对象借用方法并作为自己的方法调用。这是一种简单而强大的代码重用方式。
- en: 'Let''s say you have a `some_obj` object, which contains the `say()` method:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含`say()`方法的`some_obj`对象：
- en: '[PRE124]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You can call the `say()` method, which internally uses `this.name` to gain
    access to its own name property:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用`say()`方法，它内部使用`this.name`来访问其自身的名称属性：
- en: '[PRE125]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, let''s create a simple object, `my_obj`, which only has a name property:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的对象`my_obj`，它只有一个名称属性：
- en: '[PRE126]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `my_obj` likes the `some_obj` object''s `say()` method so much that it
    wants to invoke it as its own. This is possible using the `call()` method of the
    `say()` function object:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_obj`非常喜欢`some_obj`对象的`say()`方法，以至于它想将其作为自己的方法调用。这可以通过使用`say()`函数对象的`call()`方法来实现：'
- en: '[PRE127]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: It worked! But what happened here? You invoked the `call()` method of the `say()`
    function object by passing two parameters-the `my_obj` object and the `Dude` string.
    The result is that when `say()` is invoked, the references to the this value that
    it contains point to `my_obj`. This way, `this.name` doesn't return `Ninja`, but
    `Scripting guru` instead.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这成功了！但这里发生了什么？你通过传递两个参数（`my_obj`对象和`Dude`字符串）调用了`say()`函数对象的`call()`方法。结果是，当`say()`被调用时，它包含的`this`值引用指向`my_obj`。这样，`this.name`就不返回`Ninja`，而是返回`Scripting
    guru`。
- en: 'If you have more parameters to pass when invoking the `call()` method, you
    just keep adding them:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用`call()`方法时还有更多参数要传递，你只需继续添加它们：
- en: '[PRE128]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: If you don't pass an object as a first parameter to `call()` or you pass `null`,
    the global object is assumed.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有将对象作为`call()`的第一个参数传递，或者传递了`null`，则假定全局对象。
- en: 'The method `apply()` works the same way as `call()`, but with the difference
    that all parameters you want to pass to the method of the other object are passed
    as an array. The following two lines are equivalent:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`apply()`与`call()`的工作方式相同，但不同之处在于，你想要传递给其他对象方法的全部参数都作为数组传递。以下两行是等效的：
- en: '[PRE129]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Continuing the previous example, you can use the following line of code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个例子，你可以使用以下代码行：
- en: '[PRE130]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The arguments object revisited
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再次审视`arguments`对象
- en: 'In the previous chapter, you have seen how, from inside a function, you have
    access to something called `arguments`, which contains the values of all the parameters
    passed to the function:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经看到，从函数内部，你可以访问一个名为`arguments`的东西，它包含传递给函数的所有参数的值：
- en: '[PRE131]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `arguments` looks like an array, but it is actually an array-like object.
    It resembles an array because it contains indexed elements and a `length` property.
    However, the similarity ends there, as arguments doesn't provide any of the array
    methods, such as `sort()` or `slice()`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`看起来像数组，但实际上是一个类似数组的对象。它之所以像数组，是因为它包含索引元素和`length`属性。然而，相似之处到此为止，因为`arguments`不提供任何数组方法，如`sort()`或`slice()`。'
- en: 'However, you can convert `arguments` to an array and benefit from all the array
    goodies. Here''s what you can do, practicing your newly-learned `call()` method:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以将`arguments`转换为数组，并从中受益所有数组的好处。以下是你能做的事情，练习你刚刚学到的`call()`方法：
- en: '[PRE132]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: As you can see, you can borrow `slice()` using `[].slice` or the more verbose
    `Array.prototype.slice`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以使用`[].slice`或更冗长的`Array.prototype.slice`来借用`slice()`。
- en: Lexical this in arrow functions
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数中的词法`this`
- en: We discussed ES6 arrow functions and the syntax in detail in the last chapter.
    However, an important aspect of arrow functions is that they behave differently
    from normal functions. The difference is subtle but important. Arrow functions
    do not have their own value of `this`. The value of `this` in an arrow function
    is inherited from the enclosing (lexical) scope.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上章详细讨论了 ES6 箭头函数和其语法。然而，箭头函数的一个重要特性是它们的行为与普通函数不同。这种差异微妙但很重要。箭头函数没有自己的 `this`
    值。箭头函数中的 `this` 值是从封闭（词法）作用域继承的。
- en: Functions have a special variable `this` that refers to the object via which
    the method was invoked. As the value of `this` is dynamically given based on the
    function invocation, it is sometimes called dynamic `this`. A function is executed
    in two scopes-lexical and dynamic. A lexical scope is a scope that surrounds the
    function scope, and the dynamic scope is the scope that called the function (usually
    an object)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有一个特殊的变量 `this`，它通过调用方法的对象来引用。由于 `this` 的值是基于函数调用的动态给出的，它有时被称为动态 `this`。函数在两个作用域中执行——词法和动态。词法作用域是围绕函数作用域的作用域，动态作用域是调用函数的作用域（通常是对象）。
- en: 'In JavaScript, traditional functions play several roles. They are non-method
    functions (aka subroutines or functions), methods (part of an object), and constructors.
    When functions do the duty of a subroutine, there is a small problem due to dynamic
    `this`. As subroutines are not called on an object, the value of `this` is undefined
    in a strict mode and set to the global scope otherwise. This makes writing `callbacks`
    difficult. Consider the following example:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，传统函数扮演着几个角色。它们是非方法函数（也称为子程序或函数）、方法（对象的一部分）和构造函数。当函数执行子程序的任务时，由于动态
    `this` 而存在一个小问题。由于子程序不是在对象上调用，因此在严格模式下 `this` 的值未定义，否则设置为全局作用域。这使得编写 `callbacks`
    变得困难。考虑以下示例：
- en: '[PRE133]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We are passing a subroutine to the `forEach()` function on the `names` array.
    This subroutine has an undefined value of `this`, and unfortunately, it does not
    have access to `this` of the outer method `greet`. Clearly, this subroutine needs
    a lexical `this`,derive `this` from the surrounding scope of the `greet` method.
    Traditionally, to fix this limitation, we assign the lexical `this` into a variable,
    which is then accessible to the subroutine via closure.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将子程序传递给 `names` 数组上的 `forEach()` 函数。这个子程序有一个未定义的 `this` 值，并且不幸的是，它无法访问外部方法
    `greet` 的 `this`。显然，这个子程序需要一个词法 `this`，从 `greet` 方法的周围作用域中派生 `this`。传统上，为了修复这种限制，我们将词法
    `this` 赋值给一个变量，然后通过闭包使子程序可以访问它。
- en: 'We can fix the earlier example as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式修复前面的示例：
- en: '[PRE134]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This is a reasonable hack to simulate lexical `this`. However, the problem with
    such hacks is that it creates too much noise for the person writing or reviewing
    `this` code. First, you have to understand the quirk of the behavior of `this`.
    Even if you understand `this` behavior well, you will need to continuously remain
    on the lookout for such hacks in your code.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模拟词法 `this` 的合理技巧。然而，这种技巧的问题在于它为编写或审查此类代码的人带来了太多的噪音。首先，你必须理解 `this` 行为的怪癖。即使你很好地理解了
    `this` 的行为，你也需要持续关注代码中的此类技巧。
- en: 'Arrow functions have lexical `this` and do not require such a hack. They are
    more suited as subroutines because of `this`. We can covert the preceding example
    to use lexical `this` using the arrow function:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数具有词法 `this` 并且不需要此类技巧。由于 `this`，它们更适合作为子程序。我们可以使用箭头函数将前面的示例转换为使用词法 `this`：
- en: '[PRE135]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Inferring object types
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推断对象类型
- en: You can see that you have this array-like arguments object looking so much like
    an array object. How can you reliably tell the difference between the two? Additionally,
    `typeof` returns an object when used with arrays. Therefore, how can you tell
    the difference between an object and an array?
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个类似数组的 arguments 对象看起来非常像数组对象。你如何可靠地区分这两个对象？此外，当与数组一起使用时，`typeof` 返回对象。因此，你如何区分对象和数组？
- en: 'The silver bullet is the `Object` object''s `toString()` method. It gives you
    the internal class name used to create a given object:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 火箭弹是 `Object` 对象的 `toString()` 方法。它提供了创建给定对象所使用的内部类名：
- en: '[PRE136]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'You have to call the original `toString()` method as defined in the prototype
    of the `Object` constructor. Otherwise, if you call the `Array` function''s `toString()`,
    it will give you a different result, as it''s been overridden for the specific
    purposes of the array objects:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须调用在 `Object` 构造函数的原型中定义的原始 `toString()` 方法。否则，如果您调用 `Array` 函数的 `toString()`，它将给出不同的结果，因为已经针对数组对象的具体目的进行了覆盖：
- en: '[PRE137]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The preceding code is same as:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与以下代码相同：
- en: '[PRE138]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Let''s have some more fun with `toString()`. Make a handy reference to save
    typing:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来一些关于 `toString()` 的有趣操作。创建一个方便的参考以节省输入：
- en: '[PRE139]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The following example shows how we can differentiate between an array and the
    array-like object `arguments`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了我们可以如何区分数组与类似数组的对象 `arguments`：
- en: '[PRE140]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You can even inspect DOM elements:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以检查 DOM 元素：
- en: '[PRE141]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Boolean
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boolean
- en: Your journey through the built-in objects in JavaScript continues, and the next
    three are fairly straightforward. They are Boolean, number, and string. They merely
    wrap the primitive data types.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 JavaScript 内置对象中的旅程仍在继续，接下来的三个对象相当直接。它们是布尔值、数字和字符串。它们只是包装了原始数据类型。
- en: 'You already know a lot about Booleans from [Chapter 2](ch02.html "Chapter 2. Primitive
    Data Types, Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops,
    and Conditions*. Now, let''s meet the `Boolean()` constructor:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经从 [第 2 章](ch02.html "第 2 章. 原始数据类型、数组、循环和条件"), *原始数据类型、数组、循环和条件* 中了解了大量关于布尔值的知识。现在，让我们来认识
    `Boolean()` 构造函数：
- en: '[PRE142]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'It''s important to note that this creates a new object, `b`, and not a primitive
    Boolean value. To get the primitive value, you can call the `valueOf()` method
    (inherited from `Object` class and customized):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这会创建一个新的对象 `b`，而不是原始布尔值。要获取原始值，您可以调用 `valueOf()` 方法（从 `Object` 类继承并进行了自定义）：
- en: '[PRE143]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Overall, objects created with the `Boolean()` constructor are not too useful,
    as they don't provide any methods or properties other than the inherited ones.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，使用 `Boolean()` 构造函数创建的对象并不太有用，因为它们除了继承的属性和方法之外，不提供任何其他方法或属性。
- en: 'The `Boolean()` function, when called as a normal function without `new`, converts
    non-Booleans to Booleans (which is like using a double negation `!!`value):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为普通函数调用而不使用 `new` 时，`Boolean()` 函数将非布尔值转换为布尔值（这类似于使用双重否定 `!!` 值）：
- en: '[PRE144]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Apart from the six `false` values, everything else is `true` in JavaScript,
    including all objects. This also means that all Boolean objects created with `new
    Boolean()` are also `true`, as they are objects:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 除了六个 `false` 值之外，JavaScript 中的一切都是 `true`，包括所有对象。这也意味着使用 `new Boolean()` 创建的所有布尔对象也是
    `true`，因为它们是对象：
- en: '[PRE145]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This can be confusing, and since Boolean objects don't offer any special methods,
    it's best to just stick with regular primitive Boolean values.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会令人困惑，并且由于布尔对象不提供任何特殊方法，最好只坚持使用常规的原始布尔值。
- en: Number
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Number
- en: 'Similar to `Boolean()`, the `Number()` function can be used as:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Boolean()` 类似，`Number()` 函数也可以用作：
- en: A `constructor` function (with `new`) to create objects.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 `new` 的 `constructor` 函数来创建对象。
- en: 'A normal function in order to try to convert any value to a number. This is
    similar to the use of `parseInt()` or `parseFloat()`:'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个普通函数，旨在尝试将任何值转换为数字。这与 `parseInt()` 或 `parseFloat()` 的使用类似：
- en: '[PRE146]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'As functions are objects, they can also have properties. The `Number()` function
    has constant built-in properties that you cannot modify:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是对象，它们也可以有属性。`Number()` 函数具有不可修改的内置常量属性：
- en: '[PRE147]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The number objects provide three methods-`toFixed()`, `toPrecision()`, and
    `toExponential()`(see [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in
    Objects*, for more details):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 数字对象提供了三种方法 - `toFixed()`、`toPrecision()` 和 `toExponential()`（有关更多详细信息，请参阅 [附录
    C](apc.html "附录 C. 内置对象"), *内置对象*）：
- en: '[PRE148]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Note that you can use these methods without explicitly creating a `Number`
    object first. In such cases, the `Number` object is created (and destroyed) for
    you behind the scenes:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以在不首先显式创建 `Number` 对象的情况下使用这些方法。在这种情况下，`Number` 对象会在幕后为您创建（并销毁）：
- en: '[PRE149]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Like all objects, the `Number` object also provide the `toString()` method.
    When used with `Number` object, this method accepts an optional radix parameter
    (10 being the default):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有对象一样，`Number` 对象也提供了 `toString()` 方法。当与 `Number` 对象一起使用时，此方法接受一个可选的基数参数（默认为
    10）：
- en: '[PRE150]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: String
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: String
- en: You can use the `String()` constructor function to create string objects. String
    objects provide convenient methods for text manipulation.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `String()` 构造函数来创建字符串对象。字符串对象提供了方便的文本操作方法。
- en: 'Here''s an example that shows the difference between a `String` object and
    a `primitive` string data type:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了`String`对象和原始字符串数据类型之间的区别：
- en: '[PRE151]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: A `String` object is similar to an array of characters. String objects have
    an indexed property for each character (introduced in ES5, but long supported
    in many browsers, except old IEs), and they also have a `length` property.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象类似于字符数组。字符串对象为每个字符都有一个索引属性（在ES5中引入，但在许多浏览器中已经长期支持，除了旧版的IE），它们还有一个`length`属性。'
- en: '[PRE152]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'To extract the `primitive` value from the `String` object, you can use the
    `valueOf()` or `toString()` method inherited from `Object`. You''ll probably never
    need to do this, as `toString()` is called behind the scenes if you use an object
    in a `primitive` string context:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`String`对象中提取原始值，你可以使用从`Object`继承的`valueOf()`或`toString()`方法。你可能永远不需要这样做，因为如果你在原始字符串上下文中使用对象，`toString()`会在幕后被调用：
- en: '[PRE153]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The `primitive` strings are not objects, so they don't have any methods or properties.
    However, JavaScript also offers you the syntax to treat `primitive` strings as
    objects (just like you already saw with primitive numbers).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串不是对象，因此它们没有任何方法或属性。然而，JavaScript也提供了将原始字符串作为对象处理的语法（就像你已经看到原始数字那样）：
- en: 'In the following example, `String` objects are being created (and then destroyed)
    behind the scenes every time you treat a `primitive` string as if it were an object:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，每次将原始字符串作为对象处理时，都会在幕后创建（然后销毁）`String`对象：
- en: '[PRE154]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Here is one final example to illustrate the difference between a `primitive`
    string and a `String` object. In this example, we are converting them to Boolean.
    The empty string is a falsy value, but any string object is truthy (because all
    objects are truthy):'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个最终的例子来说明原始字符串和`String`对象之间的区别。在这个例子中，我们将它们转换为布尔值。空字符串是一个假值，但任何字符串对象都是真值（因为所有对象都是真值）：
- en: '[PRE155]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Similar to `Number()` and `Boolean()`, if you use the `String()` function without
    `new`, it converts the parameter to a primitive:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Number()`和`Boolean()`类似，如果你使用不带`new`的`String()`函数，它将参数转换为原始值：
- en: '[PRE156]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'If you pass an object to `String()`, this object''s `toString()` method will
    be called first:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个对象传递给`String()`，这个对象的`toString()`方法将会首先被调用：
- en: '[PRE157]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: A few methods of string objects
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串对象的一些方法
- en: Let's experiment with a few of the methods you can call on string objects (see
    [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*, for
    the complete list).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实验一下可以在字符串对象上调用的一些方法（有关完整列表，请参阅[附录C](apc.html "附录 C. 内置对象"), *内置对象*）：
- en: 'Start off by creating a string object:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个字符串对象：
- en: '[PRE158]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The `toUpperCase()` and `toLowerCase()` methods transform the capitalization
    of the string:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`toUpperCase()`和`toLowerCase()`方法转换字符串的大小写：'
- en: '[PRE159]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The `charAt()` method tells you the character found at the position you specify,
    which is the same as using square brackets (treating a string as an array of characters):'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`charAt()`方法告诉你指定位置上找到的字符，这与使用方括号（将字符串视为字符数组）相同：'
- en: '[PRE160]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'If you pass a non-existent position to `charAt()`, you get an empty string:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向`charAt()`传递一个不存在的位置，你将得到一个空字符串：
- en: '[PRE161]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The `indexOf()` method allows you to search within a string. If there is a
    match, the method returns the position at which the first match is found. The
    position count starts at 0, so the second character in `Couch` is `o` at position
    1:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf()`方法允许你在字符串中进行搜索。如果有匹配项，该方法返回第一个匹配项的位置。位置计数从0开始，所以`Couch`中的第二个字符`o`位于位置1：'
- en: '[PRE162]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You can optionally specify where (at what position) to start the search. The
    following finds the second `o`, because `indexOf()` is instructed to start the
    search at position 2:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以可选地指定搜索的起始位置（即位置）。以下示例找到第二个`o`，因为`indexOf()`被指示从位置2开始搜索：
- en: '[PRE163]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The `lastIndexOf()`starts the search from the end of the string (but the position
    of the match is still counted from the beginning):'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastIndexOf()`方法从字符串的末尾开始搜索（但匹配的位置仍然从开头计算）：'
- en: '[PRE164]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'You can search , not only for characters, but also for strings, and the search
    is case sensitive:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以搜索字符，还可以搜索字符串，并且搜索是区分大小写的：
- en: '[PRE165]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'If there is no match, the function returns position `-1`:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配项，函数返回位置`-1`：
- en: '[PRE166]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'For a case-insensitive search, you can transform the string to lowercase first
    and then search:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不区分大小写的搜索，你可以先将字符串转换为小写，然后再进行搜索：
- en: '[PRE167]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If you get `0`, this means that the matching part of the string starts at position
    `0`. This can cause confusion when you check with `if`, because `if` converts
    the position `0` to a Boolean `false` value. So, while this is syntactically correct,
    it is logically wrong:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到 `0`，这意味着字符串匹配的部分从位置 `0` 开始。当你用 `if` 检查时，这可能会引起混淆，因为 `if` 将位置 `0` 转换为布尔值
    `false`。所以，虽然这在语法上是正确的，但在逻辑上是错误的：
- en: '[PRE168]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The proper way to check whether a string contains another string is to compare
    the result of `indexOf()` to the number `-1`:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个字符串是否包含另一个字符串的正确方法是将 `indexOf()` 的结果与数字 `-1` 进行比较：
- en: '[PRE169]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The `slice()`and `substring()` return a piece of the string when you specify
    the start and end positions:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice()` 和 `substring()` 方法在你指定起始和结束位置时返回字符串的一部分：'
- en: '[PRE170]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Note that the second parameter you pass is the end position, not the length
    of the piece. The difference between these two methods is how they treat negative
    arguments. `substring()` treats them as zeros, while `slice()` adds them to the
    length of the string. So, if you pass parameters `(1, -1)` to both methods, it''s
    the same as `substring(1,0)` and `slice(1,s.length-1)`:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你传递的第二个参数是子串的结束位置，而不是长度。这两种方法之间的区别在于它们如何处理负参数。`substring()` 将它们视为零，而 `slice()`
    将它们加到字符串的长度上。所以，如果你向这两个方法传递参数 `(1, -1)`，它等同于 `substring(1,0)` 和 `slice(1,s.length-1)`：
- en: '[PRE171]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: There's also the non-standard method `substr()`, but you should try to avoid
    it in favor of `substring()`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有非标准的 `substr()` 方法，但你应该尽量避免使用它，转而使用 `substring()`。
- en: 'The `split()` method creates an array from the string using another string
    that you pass as a separator:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法使用你传递的另一个字符串作为分隔符，从字符串创建一个数组：'
- en: '[PRE172]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The `split()` method is the opposite of the `join()` method, which creates
    a string from an array:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法是 `join()` 方法的反义词，它从数组创建一个字符串：'
- en: '[PRE173]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `concat()` glues strings together, in the same way in which the `+` operator
    does for `primitive` strings:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()` 方法将字符串粘合在一起，这与 `+` 运算符对 `primitive` 字符串所做的方式相同：'
- en: '[PRE174]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Note that while some of the preceding methods discussed return new `primitive`
    strings, none of them modify the source string. After all the method calls listed
    previously, the initial string is still the same:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然前面讨论的一些方法返回新的 `primitive` 字符串，但它们都没有修改原始字符串。在调用前面列出的所有方法之后，原始字符串仍然是相同的：
- en: '[PRE175]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: You have seen how to use `indexOf()` and `lastIndexOf()` to search within strings,
    but there are more powerful methods (`search()`, `match()`, and `replace()`) that
    take regular expressions as parameters. You'll see these later in the `RegExp()`
    constructor function.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用 `indexOf()` 和 `lastIndexOf()` 在字符串中搜索，但还有一些更强大的方法（`search()`、`match()`
    和 `replace()`），它们接受正则表达式作为参数。你将在 `RegExp()` 构造函数中稍后看到这些方法。
- en: At this point, you're done with all of the data wrapper objects, so let's move
    on to the utility objects `Math`, `Date`, and `RegExp`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你已经处理完了所有的数据包装对象，所以让我们继续到实用对象 `Math`、`Date` 和 `RegExp`。
- en: Math
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Math
- en: '`Math` is a little different from the other built-in global objects you have
    seen previously. It''s not a function, and, therefore, cannot be used with `new`
    to create objects. `Math` is a built-in global object that provides a number of
    methods and properties for mathematical operations.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 与你之前看到的其他内置全局对象略有不同。它不是一个函数，因此不能使用 `new` 来创建对象。`Math` 是一个内置的全局对象，它提供了一系列用于数学运算的方法和属性。'
- en: 'The `Math` object''s properties are constants, so you can''t change their values.
    Their names are all in uppercase to emphasize the difference between them and
    a normal property (similar to the constant properties of the `Number()` constructor).
    Let''s see a few of these constant properties:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 对象的属性是常量，所以你不能改变它们的值。它们的名称全部为大写，以强调它们与普通属性之间的区别（类似于 `Number()` 构造函数的常量属性）。让我们看看这些常量属性中的几个：'
- en: 'The constant PI:'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量 PI：
- en: '[PRE176]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Square root of 2:'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 的平方根：
- en: '[PRE177]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Euler''s constant:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧拉常数：
- en: '[PRE178]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Natural logarithm of 2:'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 的自然对数：
- en: '[PRE179]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Natural logarithm of 10:'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 的自然对数：
- en: '[PRE180]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Now, you know how to impress your friends the next time they (for whatever reason)
    start wondering, "What was the value of *e*? I can't remember." Just type `Math.E`
    in the console and you have the answer.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道了如何在朋友下次（无论出于什么原因）开始好奇，“*e* 的值是多少？我记不清了。”时，给他们留下深刻印象。只需在控制台中输入 `Math.E`，你就有答案了。
- en: Let's take a look at some of the methods the `Math` object provides (the full
    list is in [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Math` 对象提供的一些方法（完整列表见 [附录 C](apc.html "附录 C. Built-in Objects")，*内置对象*）。
- en: 'Generating random numbers:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数：
- en: '[PRE181]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The `random()` function returns a number between `0` and `1`, so if you want
    a number between, let''s say, `0` and `100`, you can use the following line of
    code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`random()` 函数返回 `0` 到 `1` 之间的数字，所以如果你想得到一个介于，比如说 `0` 和 `100` 之间的数字，可以使用以下代码行：'
- en: '[PRE182]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'For numbers between any two values, use the formula `((max-min) * Math.random())+min`.
    For example, a random number between 2 and 10 can be obtained using the formula
    as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意两个值之间的数字，使用公式 `((max-min) * Math.random())+min`。例如，可以使用以下公式获取2到10之间的随机数：
- en: '[PRE183]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'If you only need an integer, you can use one of the following rounding methods:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个整数，可以使用以下舍入方法之一：
- en: '`floor()` to round down'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floor()` 用于向下舍入'
- en: '`ceil()` to round up'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ceil()` 用于向上舍入'
- en: '`round()` to round to the nearest'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round()` 用于四舍五入到最接近的'
- en: 'For example, to get either `0` or `1`, you can use the following line of code:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要得到 `0` 或 `1`，可以使用以下代码行：
- en: '[PRE184]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'If you need the lowest or the highest among a set of numbers, you have the
    `min()` and `max()` methods. So, if you have a form on a page that asks for a
    valid month, you can make sure that you always work with sane data (a value between
    `1` and `12`):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一组数字中的最小值或最大值，你有 `min()` 和 `max()` 方法。所以，如果你有一个页面上的表单要求有效的月份，你可以确保你始终处理合理的数据（一个介于
    `1` 和 `12` 之间的值）：
- en: '[PRE185]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The `Math` object also provides the ability to perform mathematical operations
    for which you don't have a designated operator. This means that you can raise
    to a power using `pow()`, find the square root using `sqrt()`, and perform all
    the trigonometric operations-`sin()`, `cos()`, `atan()`, and so on.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 对象还提供了执行没有指定运算符的数学运算的能力。这意味着你可以使用 `pow()` 进行幂运算，使用 `sqrt()` 进行平方根运算，以及执行所有三角运算
    - `sin()`、`cos()`、`atan()` 等等。'
- en: 'For example, to calculate `2` to the power of `8`, you can use the following
    line of code:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要计算 `2` 的 `8` 次方，可以使用以下代码行：
- en: '[PRE186]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'To calculate the square root of `9`, you can use the following line of code:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 `9` 的平方根，可以使用以下代码行：
- en: '[PRE187]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Date
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期
- en: '`Date()` is a constructor function that creates date objects. You can create
    a new object by passing:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date()` 是一个构造函数，用于创建日期对象。你可以通过传递以下内容来创建一个新的对象：'
- en: Nothing (defaults to today's date)
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无（默认为今天的日期）
- en: A date-like string
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类似日期的字符串
- en: Separate values for day, month, time, and so on
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别为日、月、时间等设置值
- en: A timestamp
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时间戳
- en: 'Here is an object instantiated with today''s date/time (using the browser''s
    timezone):'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用今天的日期和时间（使用浏览器的时区）实例化的对象：
- en: '[PRE188]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The console displays the result of the `toString()` method called on the `Date`
    object, so you get this long string `Wed Feb 27 2013 23:49:28 GMT-0800 (PST)`
    as a representation of the date object.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示了在 `Date` 对象上调用 `toString()` 方法的结果，因此你得到一个表示日期对象的字符串 `Wed Feb 27 2013 23:49:28
    GMT-0800 (PST)`。
- en: 'Here are a few examples of using strings to initialize a `Date` object. Note
    how many different formats you can use to specify the date:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用字符串初始化 `Date` 对象的例子。注意你可以使用多少种不同的格式来指定日期：
- en: '[PRE189]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The `Date` constructor can figure out a date from different strings, but this
    is not really a reliable way of defining a precise date, for example, when passing
    user input to the constructor. A better way is to pass numeric values to the `Date()`
    constructor representing:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date` 构造函数可以从不同的字符串中解析出日期，但这并不是定义精确日期的可靠方式，例如，当将用户输入传递给构造函数时。更好的方法是向 `Date()`
    构造函数传递表示以下内容的数值：'
- en: Year
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年份
- en: Month - 0 (January) to 11 (December)
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份 - 0（一月）到 11（十二月）
- en: Day - 1 to 31
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天 - 1 到 31
- en: Hour - 0 to 23
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时 - 0 到 23
- en: Minutes - 0 to 59
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟 - 0 到 59
- en: Seconds - 0 to 59
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秒 - 0 到 59
- en: Milliseconds - 0 to 999
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毫秒 - 0 到 999
- en: Let's look at some examples.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子。
- en: 'Passing all the parameters by writing the following line of code:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码行来传递所有参数：
- en: '[PRE190]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Passing date and hour by writing the following line of code:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码行来传递日期和时间：
- en: '[PRE191]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Watch out for the fact that the month starts from 0, so 1 is February:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 注意月份从0开始，所以1是二月：
- en: '[PRE192]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'If you pass a value greater than the one allowed, your date overflows forward.
    As there''s no February 30 in 2016, this means it has to be March 1 (2016 is a
    leap year):'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递的值超过了允许的范围，你的日期会向前溢出。由于2016年没有2月30日，这意味着它必须是3月1日（2016年是闰年）：
- en: '[PRE193]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Similarly, December 32 becomes January 1 of the next year:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，12月32日变成下一年的一月1日：
- en: '[PRE194]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Finally, a date object can be initialized with a timestamp (the number of milliseconds
    since the UNIX epoch, where 0 milliseconds is January 1, 1970):'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用时间戳（自UNIX纪元以来的毫秒数，其中0毫秒是1970年1月1日）初始化日期对象：
- en: '[PRE195]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'If you call `Date()` without `new`, you get a string representing the current
    date, whether or not you pass any parameters. The following example gives the
    current time (current when this example was run):'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用不带 `new` 的 `Date()`，你会得到一个表示当前日期的字符串，无论你是否传递任何参数。以下示例给出了当前时间（当此示例运行时的当前时间）：
- en: '[PRE196]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Methods to work with date objects
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期对象的工作方法
- en: Once you've created a date object, there are lots of methods you can call on
    that object. Most of the methods can be divided into `set*()` and `get*()` methods,
    for example, `getMonth()`, `setMonth()`, `getHours()`, `setHours()`, and so on.
    Let's see some examples.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了日期对象，你就可以在该对象上调用很多方法。大多数方法可以分为 `set*()` 和 `get*()` 方法，例如，`getMonth()`、`setMonth()`、`getHours()`、`setHours()`
    等。让我们看看一些示例。
- en: 'Creating a date object by writing the following code:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码来创建日期对象：
- en: '[PRE197]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Setting the month to March (months start from 0):'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 将月份设置为三月（月份从 0 开始）：
- en: '[PRE198]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Getting the month by writing the following code:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码来获取月份：
- en: '[PRE199]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: In addition to all the methods of date objects, there are also two methods (plus
    one more added in ES5) that are properties of the `Date()` function/object. These
    do not need a `date` object; they work just like the `Math` object methods. In
    class-based languages, such methods would be called static because they don't
    require an instance.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日期对象的所有方法之外，还有两个方法（ES5 中添加了一个）是 `Date()` 函数/对象的属性。这些不需要 `date` 对象；它们的工作方式就像
    `Math` 对象的方法一样。在基于类的语言中，这样的方法会被称为静态，因为它们不需要实例。
- en: 'The `Date.parse()` method takes a string and returns a timestamp:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.parse()` 方法接受一个字符串并返回一个时间戳：'
- en: '[PRE200]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The `Date.UTC()` method takes all the parameters for year, month, day, and
    so on, and produces a timestamp in **Universal Time** (**UT**):'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.UTC()` 方法接受年、月、日等所有参数，并生成一个通用时间（UTC）的时间戳：'
- en: '[PRE201]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'As the `new Date()` constructor can accept timestamps, you can pass the result
    of `Date.UTC()` to it. Using the following example, you can see how `UTC()` works
    with Universal Time, while `new Date()` works with local time:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `new Date()` 构造函数可以接受时间戳，你可以传递 `Date.UTC()` 的结果。使用以下示例，你可以看到 `UTC()` 如何与通用时间（UTC）一起工作，而
    `new Date()` 则与本地时间一起工作：
- en: '[PRE202]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The ES5 addition to the `Date` constructor is the `now()`method, which returns
    the current timestamp. It provides a more convenient way to get the timestamp
    instead of using the `getTime()` method on a `Date` object as you would in ES3:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date` 构造函数的 ES5 扩展是 `now()` 方法，它返回当前时间戳。它提供了一种更方便的方法来获取时间戳，而不是像在 ES3 中那样在
    `Date` 对象上使用 `getTime()` 方法：'
- en: '[PRE203]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'You can think of the internal representation of the date being an integer timestamp
    and all other methods being sugar on top of it. So, it makes sense that `valueOf()`
    is a timestamp:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将日期的内部表示想象成一个整数时间戳，所有其他方法都是其上的糖衣。因此，`valueOf()` 是一个时间戳是有意义的：
- en: '[PRE204]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Also, dates cast to integers with the `+` operator:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 `+` 操作符将日期转换为整数：
- en: '[PRE205]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Calculating birthdays
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算生日
- en: 'Let''s look at one final example of working with `Date` objects. I was curious
    about which day my birthday falls on in 2016:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `Date` 对象的一个最终示例。我对 2016 年我的生日是哪一天很感兴趣：
- en: '[PRE206]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Starting the count from 0 (Sunday), 1 means Monday. Is that so?
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 从 0（星期日）开始计数，1 表示星期一。是这样吗？
- en: '[PRE207]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: ok, good to know, but Monday is not necessarily the best day for a party. So,
    how about a loop that shows how many times June 20 is a Friday from year 2016
    to year 3016, or better yet, let's see the distribution of all the days of the
    week. After all, with all the progress in DNA hacking, we're all going to be alive
    and kicking in 3016.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，知道了这些很好，但星期一不一定是最适合派对的日期。那么，一个循环可以显示从 2016 年到 3016 年 6 月 20 日是星期几的次数，或者更好的是，让我们看看一周中所有日期的分布。毕竟，随着
    DNA 破解的所有进步，我们都会在 3016 年还活着并充满活力。
- en: 'First, let''s initialize an array with seven elements, one for each day of
    the week. These will be used as counters. Then, as a loop goes up to 3016, let''s
    increment the counters:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们初始化一个包含七个元素的数组，每个元素代表一周中的每一天。这些将用作计数器。然后，当循环增加到 3016 时，让我们增加计数器：
- en: '[PRE208]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Here is the loop:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是循环：
- en: '[PRE209]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Here is the result:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '[PRE210]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 142 Fridays and 145 Saturdays. Woo-hoo!
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 142 个星期五和 145 个星期六。哇哦！
- en: RegExp
  id: totrans-646
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegExp
- en: Regular expressions provide a powerful way to search and manipulate text. Different
    languages have different implementations (think dialects) of the regular expression
    syntax. JavaScript uses the Perl 5 syntax.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供了一种强大的方式来搜索和操作文本。不同的语言有不同的正则表达式语法实现（想想方言）。JavaScript 使用 Perl 5 语法。
- en: Instead of saying regular expression, people often shorten it to regex or regexp.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常不会直接说正则表达式，而是简称为 regex 或 regexp。
- en: 'A regular expression consists of:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由以下组成：
- en: A pattern you use to match text
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你用来匹配文本的模式
- en: Zero or more modifiers (also called flags) that provide more instructions on
    how the pattern should be used
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个修饰符（也称为标志），提供有关如何使用模式的更多说明
- en: The pattern can be as simple as literal text to be matched verbatim, but that's
    rare, and in such cases you're better off using `indexOf()`. Most of the time,
    the pattern is more complex and could be difficult to understand. Mastering regular
    expressions' patterns is a large topic, which won't be discussed in full detail
    here. Instead, you'll see what JavaScript provides in terms of syntax, objects,
    and methods in order to support the use of regular expressions. You can also refer
    to [Appendix D](apd.html "Appendix D. Regular Expressions"), *Regular Expressions*,
    to help you when you're writing patterns.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以是简单的文本，但要逐字匹配，这种情况很少见，在这种情况下，你最好使用 `indexOf()`。大多数情况下，模式更复杂，可能难以理解。掌握正则表达式的模式是一个大主题，这里不会详细讨论。相反，你会看到
    JavaScript 在语法、对象和方法方面提供了什么，以支持正则表达式的使用。你还可以参考 [附录 D](apd.html "附录 D. 正则表达式")，*正则表达式*，以帮助你编写模式。
- en: 'JavaScript provides the `RegExp()` constructor, which allows you to create
    regular expression objects:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了 `RegExp()` 构造函数，允许你创建正则表达式对象：
- en: '[PRE211]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'There is also the more convenient **regexp literal notation**:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更方便的 **正则表达式字面量表示法**：
- en: '[PRE212]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: In the preceding example, `j.*t` is the regular expression pattern. It means
    `"` matches any string that starts with `j`, ends with `t`, and has zero or more
    characters in between `"`. The asterisk (`*`) means `"` zero or more of the preceding,
    `"` and the dot (`.`) means `"` any character `"`. The pattern needs to be quoted
    when passed to a `RegExp()` constructor.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`j.*t` 是正则表达式模式。这意味着 `"` 匹配以 `j` 开头、以 `t` 结尾，并且在两者之间有零个或多个字符的任何字符串。星号
    (`*`) 表示 `"` 前一个字符的零个或多个实例，点 (`.`) 表示 `"` 任何字符。当传递给 `RegExp()` 构造函数时，模式需要被引号引用。
- en: Properties of RegExp objects
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RegExp 对象的属性
- en: 'Regular expression objects have the following properties:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对象具有以下属性：
- en: '`global`: If this property is `false`, which is the default, the search stops
    when the first match is found. Set this to `true` if you want all matches.'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`global`: 如果此属性为 `false`，这是默认值，则搜索会在找到第一个匹配项时停止。如果你想找到所有匹配项，请将其设置为 `true`。'
- en: '`ignoreCase`: When the match is case insensitive, this property defaults to
    `false` (meaning the default is a case-sensitive match).'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreCase`: 当匹配不区分大小写时，此属性默认为 `false`（意味着默认是区分大小写的匹配）。'
- en: '`multiline`: Search matches that may span over more than one line default to
    `false`.'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiline`: 如果搜索匹配可能跨越多行，则默认为 `false`。'
- en: '`lastIndex`: The position at which to start the search; this defaults to `0`.'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndex`: 搜索的起始位置；默认为 `0`。'
- en: '`source`: This contains the `RegExp` pattern.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`: 这包含 `RegExp` 模式。'
- en: None of these properties, except for `lastIndex`, can be changed once the object
    has been created.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `lastIndex` 以外，这些属性一旦对象创建后就不能更改。
- en: 'The first three items in the preceding list represent the regex modifiers.
    If you create a regex object using the constructor, you can pass any combination
    of the following characters as a second parameter:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表中的前三个项目代表正则表达式修饰符。如果你使用构造函数创建正则表达式对象，你可以将以下字符的任何组合作为第二个参数传递：
- en: '`g` for `global`'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g` 代表 `global`'
- en: '`i` for `ignoreCase`'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 代表 `ignoreCase`'
- en: '`m` for `multiline`'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m` 代表 `multiline`'
- en: 'These letters can be in any order. If a letter is passed, the corresponding
    modifier property is set to `true`. In the following example, all modifiers are
    set to `true`:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字母可以以任何顺序出现。如果传递了字母，则相应的修饰符属性被设置为 `true`。在以下示例中，所有修饰符都被设置为 `true`：
- en: '[PRE213]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Let''s verify:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证：
- en: '[PRE214]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Once set, the modifier cannot be changed:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置，修饰符就不能更改：
- en: '[PRE215]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'To set any modifiers using the regex literal, you add them after the closing
    slash:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用正则表达式字面量设置任何修饰符，你需要在关闭斜杠后添加它们：
- en: '[PRE216]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Methods of RegExp objects
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RegExp 对象的方法
- en: Regex objects provide two methods you can use to find matches-`test()` and `exec()`.
    They both accept a string parameter. The `test()` method returns a Boolean (`true`
    when there's a match, `false` otherwise), while `exec()` returns an array of matched
    strings. Obviously, `exec()` is doing more work, so use `test()` only if you really
    need to do something with the matches. People often use regular expressions to
    validate data. In this case, `test()` should be enough.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对象提供了两个你可以用来查找匹配的方法 - `test()` 和 `exec()`。它们都接受一个字符串参数。`test()` 方法返回一个布尔值（匹配时为
    `true`，否则为 `false`），而 `exec()` 返回一个匹配字符串的数组。显然，`exec()` 做了更多的工作，所以只有当你真的需要处理匹配项时才使用
    `test()`。人们经常使用正则表达式来验证数据。在这种情况下，`test()` 应该足够了。
- en: 'In the following example, there is no match because of the capital `J`:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，由于大写字母 `J`，没有匹配：
- en: '[PRE217]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'A case-insensitive test gives a positive result:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 不区分大小写的测试给出一个正面的结果：
- en: '[PRE218]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The same test using `exec()` returns an array, and you can access the first
    element as shown here:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exec()` 的相同测试返回一个数组，你可以像下面这样访问第一个元素：
- en: '[PRE219]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: String methods that accept regular expressions as arguments
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受正则表达式作为参数的字符串方法
- en: Previously in this chapter, you learned about string objects and how you can
    use the `indexOf()` and `lastIndexOf()` methods to search within text. Using these
    methods, you can only specify literal string patterns to search. A more powerful
    solution would be to use regular expressions to find text. String objects offer
    you this ability.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你学习了字符串对象以及如何使用 `indexOf()` 和 `lastIndexOf()` 方法在文本中进行搜索。使用这些方法，你只能指定字面字符串模式进行搜索。一个更强大的解决方案是使用正则表达式来查找文本。字符串对象为你提供了这种能力。
- en: 'String objects provide the following methods that accept regular expression
    objects as parameters:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象提供了以下方法，这些方法接受正则表达式对象作为参数：
- en: '`match()`: Returns an array of matches'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match()`：返回匹配项的数组'
- en: '`search()`: Returns the position of the first match'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`：返回第一个匹配的位置'
- en: '`replace()`: Allows you to substitute matched text with another string'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace()`：允许你用另一个字符串替换匹配的文本'
- en: '`split()`: Accepts a regexp when splitting a string into array elements'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split()`：在分割字符串为数组元素时接受正则表达式'
- en: search() and match()
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`search()` 和 `match()`'
- en: 'Let''s look at some examples of using the `search()`and `match()` methods.
    First, you create a string object:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `search()` 和 `match()` 方法的几个例子。首先，你创建一个字符串对象：
- en: '[PRE220]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Using `match()`, you get an array containing only the first match:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `match()`，你得到一个只包含第一个匹配项的数组：
- en: '[PRE221]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Using the `g` modifier, you perform a global search, so the result array contains
    two elements:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `g` 修饰符，你执行全局搜索，因此结果数组包含两个元素：
- en: '[PRE222]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'A case-insensitive match is as follows:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 不区分大小写的匹配如下：
- en: '[PRE223]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'The `search()` method gives you the position of the matching string:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()` 方法会给出匹配字符串的位置：'
- en: '[PRE224]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: replace()
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`replace()`'
- en: 'The `replace()` method allows you to replace the matched text with some other
    string. The following example removes all capital letters (it replaces them with
    blank strings):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()` 方法允许你用其他字符串替换匹配的文本。以下示例移除了所有大写字母（它们被替换为空字符串）：'
- en: '[PRE225]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'If you omit the `g` modifier, you''re only going to replace the first match:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了 `g` 修饰符，你只会替换第一个匹配项：
- en: '[PRE226]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'When a match is found, if you want to include the matched text in the replacement
    string, you can access it using `$&`. Here''s how to add an underscore before
    the match while keeping the match:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到匹配时，如果你想将匹配的文本包含在替换字符串中，你可以使用 `$&` 来访问它。以下是如何在匹配前添加下划线同时保留匹配内容：
- en: '[PRE227]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'When the regular expression contains groups (denoted by parentheses), the matches
    of each group are available as `$1` for the first group, `$2` the second, and
    so on:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当正则表达式包含组（由括号表示）时，每个组的匹配可用作第一个组的 `$1`，第二个组的 `$2`，依此类推：
- en: '[PRE228]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Imagine you have a registration form on your web page that asks for an e-mail
    address, username, and password. The user enters their e-mail IDs, and then, your
    JavaScript kicks in and suggests the username, taking it from the e-mail address:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在你的网页上有一个注册表单，要求用户输入电子邮件地址、用户名和密码。用户输入他们的电子邮件 ID，然后你的 JavaScript 开始工作，并建议用户名，从电子邮件地址中获取：
- en: '[PRE229]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Replace callbacks
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换回调
- en: 'When specifying the replacement, you can also pass a function that returns
    a string. This gives you the ability to implement any special logic you may need
    before specifying the replacements:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定替换时，你也可以传递一个返回字符串的函数。这让你能够在指定替换之前实现任何可能需要的特殊逻辑：
- en: '[PRE230]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'The callback function receives a number of parameters (the previous example
    ignores all but the first one):'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收多个参数（前一个示例忽略了除了第一个以外的所有参数）：
- en: The first parameter is the `match`
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是 `match`
- en: The last is the string being searched
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个是正在搜索的字符串
- en: The one before last is the position of the `match`
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个之前的是 `match` 的位置
- en: The rest of the parameters contain any strings matched by any groups in your
    regex pattern
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的参数包含由你的正则表达式模式中任何分组匹配的任何字符串
- en: 'Let''s test this. First, let''s create a variable to store the entire arguments
    array passed to the callback function:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。首先，让我们创建一个变量来存储传递给回调函数的整个参数数组：
- en: '[PRE231]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Next, define a regular expression that has three groups and matches e-mail
    addresses in the format `something@something.something`:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个有三个分组并匹配格式为 `something@something.something` 的电子邮件地址的正则表达式：
- en: '[PRE232]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Finally, let''s define a callback function that stores the arguments in `glob`
    and then returns the replacement:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义一个回调函数，它将参数存储在 `glob` 中，然后返回替换内容：
- en: '[PRE233]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Now, perform a test:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进行一个测试：
- en: '[PRE234]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Here''s what the callback function received as arguments:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 这是回调函数接收到的参数：
- en: '[PRE235]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: split()
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: split()
- en: 'You already know about the `split()` method, which creates an array from an
    input string and a delimiter string. Let''s take a string of comma-separated values
    and split it:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了 `split()` 方法，它可以从输入字符串和分隔符字符串创建一个数组。让我们用一个以逗号分隔的值字符串为例，并将其拆分：
- en: '[PRE236]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Because the input string happens to have random inconsistent spaces before
    and after the commas, the array result has spaces too. With a regular expression,
    you can fix this using `\s*`, which means zero or more spaces:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输入字符串在逗号前后恰好有随机不一致的空格，所以数组结果也有空格。使用正则表达式，你可以使用`\s*`来修复这个问题，它表示零个或多个空格：
- en: '[PRE237]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Passing a string when a RegExp is expected
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当期望正则表达式时传递字符串
- en: One last thing to note is that the four methods that you have just seen (`split()`,
    `match()`, `search()`, and `replace()`) can also take strings as opposed to regular
    expressions. In this case, the string argument is used to produce a new regex
    as if it were passed to `new RegExp()`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，你刚才看到的四个方法（`split()`、`match()`、`search()` 和 `replace()`）也可以接受字符串，而不是正则表达式。在这种情况下，字符串参数被用作产生一个新的正则表达式，就像它被传递给
    `new RegExp()` 一样。
- en: 'An example of passing a string to `replace` is shown as follows:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将字符串传递给 `replace` 的一个示例：
- en: '[PRE238]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'The preceding lines of code are the same as the following one:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行与以下一行相同：
- en: '[PRE239]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'When you pass a string, you cannot set modifiers the way you do with a normal
    constructor or regex literal. There''s a common source of errors when using a
    string instead of a regular expression object for string replacements, and it''s
    due to the fact that the `g` modifier is `false` by default. The outcome is that
    only the first string is replaced, which is inconsistent with most other languages
    and a little confusing. Here is an example:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递一个字符串时，你不能像使用正常构造函数或正则表达式字面量那样设置修饰符。使用字符串而不是正则表达式对象进行字符串替换时，有一个常见的错误来源，这归因于
    `g` 修饰符默认为 `false`。结果是只替换第一个字符串，这与大多数其他语言不一致，并且有点令人困惑。以下是一个示例：
- en: '[PRE240]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Most likely, you want to replace all occurrences:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你想要替换所有出现：
- en: '[PRE241]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Error objects
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误对象
- en: Errors happen, and it's good to have the mechanisms in place so that your code
    can realize that there has been an error condition and can recover from it in
    a graceful manner. JavaScript provides the `try`, `catch`, and `finally` statements
    to help you deal with errors. If an error occurs, an error object is thrown. Error
    objects are created using one of these built-in constructors-`EvalError`, `RangeError`,
    `ReferenceError`, `SyntaxError`, `TypeError`, and `URIError`. All these constructors
    inherit from `Error`.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 错误会发生，并且有机制在位是好的，这样你的代码就可以意识到已经发生了错误条件，并且可以优雅地从中恢复。JavaScript 提供了 `try`、`catch`
    和 `finally` 语句来帮助你处理错误。如果发生错误，会抛出一个错误对象。错误对象是通过以下内置构造函数之一创建的-`EvalError`、`RangeError`、`ReferenceError`、`SyntaxError`、`TypeError`
    和 `URIError`。所有这些构造函数都继承自 `Error`。
- en: 'Let''s just cause an error and see what happens. What''s a simple way to cause
    an error? Just call a function that doesn''t exist. Type this into the console:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们故意引发一个错误并看看会发生什么。引发错误的一个简单方法是什么？只需调用一个不存在的函数。在控制台中输入以下内容：
- en: '[PRE242]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'You''ll get something like the following:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下类似的内容：
- en: '![Error objects](img/image_04_003-e1482749061350.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![错误对象](img/image_04_003-e1482749061350.jpg)'
- en: The display of errors can vary greatly between browsers and other host environments.
    In fact, most recent browsers tend to hide the errors from the users. However,
    you cannot assume that all of your users have disabled the display of errors,
    and it is your responsibility to ensure an error-free experience for them. The
    previous error propagated to the user, because the code didn't try to trap (catch)
    this error. The code didn't expect the error and was not prepared to handle it.
    Fortunately, it's trivial to trap the error. All you need is the `try` statement
    followed by a `catch` statement.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的显示在浏览器和其他宿主环境之间可能会有很大的差异。实际上，大多数最新的浏览器倾向于隐藏错误给用户。然而，你不能假设所有用户都禁用了错误的显示，确保他们有一个无错误的体验是你的责任。之前的错误传播给了用户，因为代码没有尝试捕获（捕获）这个错误。代码没有预料到错误，也没有准备好处理它。幸运的是，捕获错误非常简单。你所需要的是
    `try` 语句后面跟着一个 `catch` 语句。
- en: 'This code hides the error from the user:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码隐藏了错误给用户：
- en: '[PRE243]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Here you have:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是：
- en: The `try` statement followed by a block of code.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try` 语句后面跟着一个代码块。'
- en: The `catch` statement followed by a variable name in parentheses and another
    block of code.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch` 语句后面跟着一个括号内的变量名和另一段代码块。'
- en: There can be an optional `finally` statement (not used in this example) followed
    by a block of code, which is executed regardless of whether there was an error
    or not.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有一个可选的 `finally` 语句（在这个例子中没有使用）后面跟着一个代码块，无论是否有错误都会执行。
- en: In the previous example, the code block that follows the `catch` statement didn't
    do anything. However, this is the place where you put the code that can help recover
    from the error, or at least give feedback to the user that your application is
    aware that there was a special condition.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，跟在 `catch` 语句后面的代码块没有做任何事情。然而，这是你放置可以帮助从错误中恢复的代码或至少向用户反馈你的应用程序意识到有特殊条件的地方。
- en: The variable `e` in the parentheses after the `catch` statement contains an
    error object. Like any other object, it contains properties and methods. Unfortunately,
    different browsers implement these methods and properties differently, but there
    are two properties that are consistently implemented-`e.name` and `e.message`.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 语句后面的括号中的变量 `e` 包含一个错误对象。像任何其他对象一样，它包含属性和方法。不幸的是，不同的浏览器以不同的方式实现这些方法和属性，但有两个属性是一直得到实现的
    - `e.name` 和 `e.message`。'
- en: 'Let''s try this code now:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试这段代码：
- en: '[PRE244]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: This will present an `alert()` showing `e.name` and `e.message` and then another
    `alert()` saying `Finally!`.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个 `alert()`，显示 `e.name` 和 `e.message`，然后另一个 `alert()` 说 `Finally!`。
- en: 'In Firefox and Chrome, the first alert will say **ReferenceError: iDontExist
    is not defined**. In Internet Explorer, it will be **TypeError: Object expected**.
    This tells us two things:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Firefox 和 Chrome 中，第一个警告将显示 **ReferenceError: iDontExist is not defined**。在
    Internet Explorer 中，它将是 **TypeError: Object expected**。这告诉我们两件事：'
- en: The `e.name` method contains the name of the constructor that was used to create
    the error object
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e.name` 方法包含用于创建错误对象的构造函数名称'
- en: As the error objects are not consistent across host environments (browsers),
    it would be somewhat tricky to have your code act differently depending on the
    type of error (the value of `e.name`)
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于错误对象在不同的宿主环境（浏览器）中并不一致，根据错误类型（`e.name` 的值）让你的代码以不同的方式执行可能会有些棘手。
- en: You can also create error objects yourself using `new Error()` or any of the
    other error constructors and then let the JavaScript engine know that there's
    an erroneous condition using the `throw` statement.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `new Error()` 或其他任何错误构造函数自己创建错误对象，然后使用 `throw` 语句让 JavaScript 引擎知道存在一个错误条件。
- en: 'For example, imagine a scenario where you call the `maybeExists()` function
    and after that make calculations. You want to trap all errors in a consistent
    way, no matter whether the error is that `maybeExists()` doesn''t exist or that
    your calculations found a problem. Consider the following code:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个场景，你调用 `maybeExists()` 函数，然后进行计算。你希望以一致的方式捕获所有错误，无论错误是 `maybeExists()`
    不存在，还是你的计算发现了问题。考虑以下代码：
- en: '[PRE245]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'This code will alert different messages depending on whether or not `maybeExists()`
    is defined and the values it returns:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将根据 `maybeExists()` 是否定义以及它返回的值显示不同的消息：
- en: 'If `maybeExists()` doesn''t exist, you get **ReferenceError: maybeExists()
    is not defined** in Firefox and **TypeError: Object expected** in IE'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果 `maybeExists()` 不存在，在 Firefox 中你会得到 **ReferenceError: maybeExists() is not
    defined**，在 IE 中则是 **TypeError: Object expected**。'
- en: 'If `maybeExists()` returns `0`, you get **Error: Division by zero!**'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`maybeExists()`返回`0`，你会得到**错误：除以零！**
- en: If `maybeExists()` returns `2`, you get an alert that says **25**
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`maybeExists()`返回`2`，你会得到一个显示**25**的警报。
- en: In all cases, there will be a second alert that says **Finally!**.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，都会有一个第二警报，显示**Finally!**。
- en: 'Instead of throwing a generic error, `thrownewError(''Divisionbyzero!'')`,
    you can be more specific if you choose to, for example, throw `thrownewRangeError(''Divisionbyzero!'')`.
    Alternatively, you don''t need a constructor; you can simply throw a normal object:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 与抛出通用错误`thrownewError('Divisionbyzero!')`相比，如果你选择的话，可以更具体，例如，抛出`thrownewRangeError('Divisionbyzero!')`。或者，你不需要构造函数；你可以简单地抛出一个普通对象：
- en: '[PRE246]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: This gives you cross-browser control over the error name.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了对错误名称的跨浏览器控制。
- en: Exercises
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Lets solve the following exercise:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决以下练习：
- en: 'Look at the following code:'
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE247]'
  id: totrans-783
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Does the value of `this` refer to the global object or the object `o`?
  id: totrans-784
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`this`的值是指全局对象还是对象`o`？'
- en: What's the result of executing this piece of code?
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此代码块的结果是什么？
- en: '[PRE248]'
  id: totrans-786
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: What's the result of executing the following piece of code?
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码块的结果是什么？
- en: '[PRE249]'
  id: totrans-788
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Imagine the `String()` constructor didn''t exist. Create a constructor function,
    `MyString()`, that acts like `String()` as closely as possible. You''re not allowed
    to use any built-in string methods or properties, and remember that the `String()`
    doesn''t exist. You can use this code to test your constructor:'
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`String()`构造函数不存在。创建一个构造函数`MyString()`，使其尽可能像`String()`一样工作。不允许使用任何内置的字符串方法或属性，并记住`String()`不存在。你可以使用以下代码来测试你的构造函数：
- en: '[PRE250]'
  id: totrans-790
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Note
  id: totrans-791
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use a `for` loop to loop through the input string, treating it as an
    array.
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`for`循环遍历输入字符串，将其视为一个数组。
- en: Update your `MyString()` constructor to include a `reverse()` method.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`MyString()`构造函数以包含一个`reverse()`方法。
- en: Note
  id: totrans-794
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Try to leverage the fact that arrays have a `reverse()` method.
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试利用数组有`reverse()`方法的事实。
- en: 'Imagine that `Array()`and the array literal notation don''t exist. Create a
    constructor called `MyArray()` that behaves as close to `Array()` as possible.
    Test it with the following code:'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`Array()`和数组字面量表示法不存在。创建一个名为`MyArray()`的构造函数，使其尽可能接近`Array()`的行为。用以下代码测试它：
- en: '[PRE251]'
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: If you found this exercise amusing, don't stop with the `join()` method; go
    on with as many methods as possible.
  id: totrans-798
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你觉得这个练习很有趣，不要只停留在`join()`方法上；尽可能多地继续使用其他方法。
- en: 'Imagine `Math` didn''t exist. Create a `MyMath` object that also provides the
    following additional methods:'
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`Math`不存在。创建一个`MyMath`对象，它也提供以下附加方法：
- en: '`MyMath.rand(min, max, inclusive)`: This generates a random number between
    `min` and `max`, inclusive if `inclusive` is `true` (default)'
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyMath.rand(min, max, inclusive)`：这生成一个介于`min`和`max`之间的随机数，如果`inclusive`为`true`（默认），则包含`max`'
- en: '`MyMath.min(array)`: This returns the smallest number in a given array'
  id: totrans-801
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyMath.min(array)`：这返回给定数组中的最小数字'
- en: '`MyMath.max(array)`: This returns the largest number in a given array'
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyMath.max(array)`：这返回给定数组中的最大数字'
- en: Summary
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops, and
    Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, you saw that
    there are five primitive data types (`number`, `string`, `Boolean`, `null`, and
    `undefined`), and we also said that everything that is not a primitive piece of
    data is an object. Now, you also know that:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。基本数据类型、数组、循环和条件")*基本数据类型、数组、循环和条件*中，你看到有五种基本数据类型（`number`、`string`、`Boolean`、`null`和`undefined`），我们也说过，所有不是原始数据片段的东西都是对象。现在，你也知道：
- en: Objects are like arrays, but you specify the keys
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象就像数组，但你可以指定键
- en: Objects contain properties
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象包含属性
- en: Properties can be functions (functions are data; remember `var f = function
    () {};`). Properties that are functions are also called methods
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性可以是函数（函数是数据；记住`var f = function () {};`）。属性是函数的也被称为方法
- en: Arrays are actually objects with predefined numeric properties and an auto-incrementing
    `length` property
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组实际上是具有预定义的数字属性和自动递增的`length`属性的**对象**。
- en: Array objects have a number of convenient methods (such as `sort()` or `slice()`)
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组对象有许多方便的方法（例如`sort()`或`slice()`）
- en: Functions are also objects, and they have properties (such as `length` and `prototype`)
    and methods (such as `call()` and `apply()`)
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数也是对象，并且它们有属性（如`length`和`prototype`）和方法（如`call()`和`apply()`）
- en: Regarding the five primitive data types, apart from `undefined` and `null`,
    the other three have the corresponding constructor functions-`Number()`, `String()`,
    and `Boolean()`. Using these, you can create objects, called wrapper objects,
    which contain methods for working with primitive data elements.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 关于五种原始数据类型，除了 `undefined` 和 `null` 之外，其他三种都有相应的构造函数 - `Number()`, `String()`
    和 `Boolean()`。使用这些构造函数，你可以创建对象，称为包装对象，它们包含用于处理原始数据元素的方法。
- en: '`Number()`, `String()`, and `Boolean()` can be invoked:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用 `Number()`, `String()` 和 `Boolean()`：
- en: With the `new` operator, to create new objects.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `new` 操作符来创建新对象。
- en: Without the `new` operator, to convert any value to the corresponding primitive
    data type.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用 `new` 操作符，可以将任何值转换为相应的原始数据类型。
- en: Other built-in constructor functions you're now familiar with include `Object()`,
    `Array()`, `Function()`, `Date()`, `RegExp()`, and `Error()`. You're also familiar
    with `Math`-a global object that is not a constructor.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在所熟悉的其它内置构造函数包括 `Object()`, `Array()`, `Function()`, `Date()`, `RegExp()`
    和 `Error()`。你也熟悉 `Math` - 这是一个全局对象，但它不是一个构造函数。
- en: Now, you can see how objects have a central role in JavaScript programming,
    as pretty much everything is an object or can be wrapped by an object.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到对象在 JavaScript 编程中扮演着核心角色，因为几乎一切都是对象或者可以被对象封装。
- en: 'Finally, let''s wrap up the literal notations you''re now familiar with:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们总结一下你现在所熟悉的字面量表示法：
- en: '| **Name** | **Literal** | **Constructor** | **Example** |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **字面量** | **构造函数** | **示例** |'
- en: '| Object | `{}` | `new Object()` | `{prop: 1}` |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | `{}` | `new Object()` | `{prop: 1}` |'
- en: '| Array | `[]` | `new Array()` | `[1,2,3,''test'']` |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | `[]` | `new Array()` | `[1,2,3,''test'']` |'
- en: '| Regular expression | `/pattern/modifiers` | `new RegExp(''pattern'', ''modifiers'')`
    | `/java.*/img` |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | `/pattern/modifiers` | `new RegExp(''pattern'', ''modifiers'')` |
    `/java.*/img` |'
