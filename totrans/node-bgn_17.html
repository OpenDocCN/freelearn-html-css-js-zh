<html><head></head><body>
		<div><h1 id="_idParaDest-428" class="chapter-number"><a id="_idTextAnchor436"/>17</h1>
			<h1 id="_idParaDest-429"><a id="_idTextAnchor437"/>Dockerizing a Node.js Application</h1>
			<p>In this chapter, we will learn how to deploy our application to the public internet using Docker. We will explore how we can use GitHub Actions to ensure that our Docker images are <a id="_idIndexMarker1016"/>working well in the <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) pipeline.</p>
			<p>We will learn how to Dockerize the application and publish the image to Docker Hub for better portability so we can download our images in different environments.</p>
			<p>Finally, we will <a id="_idIndexMarker1017"/>discuss how to do a proper domain setup and how to add a <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificate to the application using Cloudflare. We will also explore the Twelve-Factor App principles.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>How to use GitHub Actions for CI</li>
				<li>How to use DigitalOcean Droplet to host the Docker application</li>
				<li>How to use Docker to build the application and publish the image to Docker Hub</li>
				<li>How to do a proper domain setup and add an SSL certificate to the application using Cloudflare</li>
				<li>What are the Twelve-Factor App principles and how can they help you grow?</li>
			</ul>
			<h1 id="_idParaDest-430"><a id="_idTextAnchor438"/>Technical requirements</h1>
			<p>To start working on this chapter, we need to continue with the code that we uploaded to GitHub in the previous chapter. If you haven’t completed the previous chapter you can download the project from <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a> and access the <code>step5</code> folder as a reference.</p>
			<p>You will need to create accounts with the following providers in order to follow the examples in this chapter:</p>
			<ul>
				<li>Docker Hub: <a href="https://hub.docker.com/signup">https://hub.docker.com/signup</a><a href="https://hub.docker.com/signup&#13;"/></li>
				<li>Cloudflare: <a href="https://www.cloudflare.com/">https://www.cloudflare.com/</a> (optional)</li>
			</ul>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<p>Checkout the code in action video for this chapter on <a href="https://youtu.be/VWBuF_Q3KPY">https://youtu.be/VWBuF_Q3KPY</a></p>
			<h1 id="_idParaDest-431"><a id="_idTextAnchor439"/>Containers and cloud-native solutions with Docker</h1>
			<p>While using a VM is a good option, it is not the best option for many applications. Currently, containers <a id="_idIndexMarker1018"/>are the most popular way to deploy applications. Containers are lightweight, portable, and easy to use. In this section, we will learn how to deploy a Node.js application using Docker.</p>
			<p>We covered <a id="_idIndexMarker1019"/>the basics of Docker in previous chapters <a id="_idIndexMarker1020"/>and we have been using Docker and Docker Compose to run the MongoDB database. We now need to learn how to create a Docker image for our application and how to deploy it.</p>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor440"/>Docker lifecycle</h2>
			<p>We need to <a id="_idIndexMarker1021"/>have a clear understanding of the Docker lifecycle to use it properly. Let’s start with a brief introduction. In the following figure, we can see the Docker lifecycle:</p>
			<div><div><img src="img/B21678_17_ForCEing_FS_1.jpg" alt="Figure 17.1 – Docker lifecycle diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – Docker lifecycle diagram</p>
			<p>We need to start with a <code>Dockerfile,</code> which is a file that contains the instructions to build the image. Then, we can build the image with the <code>docker build</code> command. We can then run the container with the <code>docker </code><code>run</code> command.</p>
			<p>If we want to share the image with other people, we can push the image to a registry with the <code>docker push</code> command. Then, other people can pull the image from the registry with the <code>docker pull</code> command. This last step is quite similar to <code>npm publish</code> but, instead of sharing the code, we are sharing the image.</p>
			<p>Now that we are clear on the theory, let’s Dockerize our application in the next section.</p>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor441"/>Dockerizing the application</h2>
			<p>In your local machine, using Docker Desktop 1.18, you can run <code>docker init</code> in the project root <a id="_idIndexMarker1022"/>folder (where <code>package.json</code> is located) to create a <code>Dockerfile</code> (see <a href="https://docs.docker.com/engine/reference/commandline/init/">https://docs.docker.com/engine/reference/commandline/init/</a>). So, we can create the files automatically with an interactive process:</p>
			<pre class="source-code">
Let's get started!
? What application platform does your project use? Node
? What version of Node do you want to use? 20.11.0
? Which package manager do you want to use? npm
? What command do you want to use to start the app? npm start
? What port does your server listen on? 3000
CREATED: .dockerignore
CREATED: Dockerfile
CREATED: compose.yaml
✔ Your Docker files are ready!</pre>			<p>This tool will create the following files: <code>.dockerignore</code>, <code>dockerfile</code>, and <code>compose.yaml</code>. We will use <code>dockerfile</code> to build the image and we will use <code>compose.yaml</code> to run the container.</p>
			<p>The Dockerfile will look like this:</p>
			<pre class="source-code">
# syntax=docker/dockerfile:1
ARG NODE_VERSION=20.11.0
FROM node:${NODE_VERSION}-alpine
ENV NODE_ENV production
WORKDIR /usr/src/app
RUN --mount=type=bind,source=package.json,target=package.json \
    --mount=type=bind,source=package-lock.json,target=package-lock.json \
    --mount=type=cache,target=/root/.npm \
    npm ci --omit=dev
USER node
COPY . .
EXPOSE 3000
CMD npm start</pre>			<p>This is a <code>Dockerfile</code> that sets up a Node.js environment inside a Docker container. It starts by specifying the Node.js version to use (<code>20.11.0</code>) and uses the Alpine version of the Node.js <a id="_idIndexMarker1023"/>image for a smaller footprint. It sets the <code>NODE_ENV</code> environment variable to <code>production</code>. It then sets the working directory inside the container to <code>/usr/src/app</code>. The <code>RUN</code> command mounts the <code>package.json</code> and <code>package-lock.json</code> files from the host to the container and also sets up a cache for <code>npm</code> modules. It then runs <code>npm ci --omit=dev</code> to install the <code>production</code> dependencies only. It changes the user to <code>node</code> for security reasons, copies all files from the current directory on the host to the current directory in the container, exposes port <code>3000</code> for the application to be accessible, and finally, sets the command to start the application to <code>npm start</code>.</p>
			<p>For our current application, we can remove the <code>compose.yaml</code> file as we don’t need it. It is important to review the content in the <code>.dockerignore</code> file as it excludes some files from the build process when we execute the <code>COPY . .</code> command in the Dockerfile.</p>
			<p>We have all the files needed to properly use Docker to manage our application, so in the next section, we will cover that in detail.</p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor442"/>Managing the application with Docker</h2>
			<p>In the previous chapter, we used PM2 to manage the application. This time, we will use Docker. We can <a id="_idIndexMarker1024"/>build the image with the following:</p>
			<pre class="console">
docker build -t nodejs-for-beginners .</pre>			<p>Then, we can run the container with the following command, which will expose port <code>3000</code> and will use specific environment variables:</p>
			<pre class="console">
docker run \
-e MONGODB_URI='mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority' \
-e PORT='3000' \
-e SALT_ROUNDS='10' \
-e JWT_SECRET='Tu1fo0mO0PcAvjq^q3wQ24BXNI8$9R' \
-p 3000:3000 \
nodejs-for-beginners</pre>			<p>You will need to replace <code>mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority</code> with the connection string of your MongoDB Atlas cluster.</p>
			<p>If you open the browser and access <a href="http://localhost:3000">http://localhost:3000</a>, you will see the application running as expected.</p>
			<p>Now that we know that the Dockerized application is working fine, we can add a step in the CI to ensure that the Docker image is properly generated.</p>
			<h2 id="_idParaDest-435"><a id="_idTextAnchor443"/>Adding docker build to the CI</h2>
			<p>We can <a id="_idIndexMarker1025"/>add the <code>docker build</code> step to the CI process to ensure that the image is built correctly. We can add the following step to the CI process in <code>.github/workflows/ci.yml</code>:</p>
			<pre class="source-code">
- name: Build Docker image
  run: docker build -t nodejs-for-beginners .</pre>			<p>Once you commit these changes, you can check the status of the workflow in the <code>Build Docker </code><code>image</code> step:</p>
			<div><div><img src="img/B21678_17_ForCEing_FS_2.jpg" alt="Figure 17.2 – Checking the workflow status"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – Checking the workflow status</p>
			<p>As you <a id="_idIndexMarker1026"/>can see in <em class="italic">Figure 17</em><em class="italic">.2</em>, we successfully built the Docker image. In the next section, we will learn how to make this image public.</p>
			<h2 id="_idParaDest-436"><a id="_idTextAnchor444"/>Pushing the image to Docker Hub</h2>
			<p>You need <a id="_idIndexMarker1027"/>to create a new repository in Docker Hub: <a href="https://hub.docker.com/repositories/new">https://hub.docker.com/repositories/new</a>. In <a id="_idIndexMarker1028"/>my case, I created a private repository called <code>nodejs-for-beginners</code>, as you can see in the following figure:</p>
			<div><div><img src="img/B21678_17_ForCEing_FS_3.jpg" alt="Figure 17.3 – Creating a new repository"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3 – Creating a new repository</p>
			<p>I recommend <a id="_idIndexMarker1029"/>you create a <strong class="bold">Public</strong> image but if you want to <a id="_idIndexMarker1030"/>create a <strong class="bold">Private</strong> image, then you will need to log in to Docker Hub using the Docker CLI in your target machine (DigitalOcean Droplet or an alternative).</p>
			<p>Then, from your local machine, you need to log in to Docker Hub using the following command:</p>
			<pre class="console">
docker login</pre>			<p>You can then build the image with the name of the repository with the following command:</p>
			<pre class="console">
docker build -t YOUR-USER/YOUR-PROJECT:latest .</pre>			<p>You will need to replace <code>YOUR-USER/YOUR-PROJECT</code> with your user and project name. In my case, I used <code>ulisesgascon/nodejs-for-beginners</code>.</p>
			<p>This command will print a lot of logs but, at the end, you should not see any errors.</p>
			<p>Then, you need <a id="_idIndexMarker1031"/>to push the image to Docker Hub with the <a id="_idIndexMarker1032"/>following command:</p>
			<pre class="console">
docker push YOUR-USER/YOUR-PROJECT</pre>			<p>The output should be something like this, using the default <code>latest</code> tag:</p>
			<pre class="console">
The push refers to repository [docker.io/ulisesgascon/nodejs-for-beginners]
204442a0fb02: Pushed
c797ca72cc32: Pushed
c2f374546252: Pushed
9841711cc266: Mounted from library/node
b748d0576055: Mounted from library/node
f866f7afbf16: Mounted from library/node
4693057ce236: Mounted from library/node
latest: digest: sha256:b82d23e398cf03165e89b8d1661125eda0f7b930e21 eef8c62281acd427e2d06 size: 1787</pre>			<p>If you go to the Docker Hub repository, you will see that the image has been pushed and is ready to be used in other machines with the <code>docker pull </code><code>YOUR-USER/YOUR-PROJECT:latest</code> command.</p>
			<p>As you can see in the following figure, the image is available in the Docker Hub repository:</p>
			<div><div><img src="img/B21678_17_ForCEing_FS_4.jpg" alt="Figure 17.4 – The image in the Docker Hub repository"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.4 – The image in the Docker Hub repository</p>
			<h2 id="_idParaDest-437"><a id="_idTextAnchor445"/>Publishing the image with GitHub Actions</h2>
			<p>As an alternative way to push the image to Docker Hub, we can publish the image directly <a id="_idIndexMarker1033"/>with GitHub Actions. This is a great way to automate the process, avoiding the need to install Docker on our local machine and ensuring <a id="_idIndexMarker1034"/>that the image is built correctly.</p>
			<p>I invite you to achieve this by yourself as the last challenge of this book. Here are some hints to help you:</p>
			<ul>
				<li>GitHub guide to publishing Docker images: <a href="https://docs.github.com/en/actions/guides/publishing-docker-images">https://docs.github.com/en/actions/guides/publishing-docker-images</a><a href="https://docs.github.com/en/actions/guides/publishing-docker-images&#13;"/></li>
				<li>A pipeline reference from the <code>simple-api</code> project: <a href="https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58">https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58</a><a href="https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58&#13;"/></li>
			</ul>
			<p>In the next section, we will learn how to use Docker to run the project in the DigitalOcean Droplet.</p>
			<h1 id="_idParaDest-438"><a id="_idTextAnchor446"/>Running the containers</h1>
			<p>In the previous chapter, we used PM2 to manage the lifecycle of our application. This time, we will do it differently: we will use Docker directly.</p>
			<p>Our first <a id="_idIndexMarker1035"/>step will be to install Docker on our target machine using SSH. Follow the installation guide (<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a>) and then run <code>docker run hello-world</code>. The command will run without generating any error, this was a simple test to check whether the Docker engine was properly set up and running.</p>
			<p>Please check that you stopped the PM2 application before we move to the next step as only one service can control port <code>3000</code>. Then, our last step will be to run the container but, this time, we won’t need to build the container as we are pulling directly the image from Docker Hub:</p>
			<pre class="console">
docker run \
-e MONGODB_URI='mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority' \
-e PORT='3000' \
-e SALT_ROUNDS='10' \
-e JWT_SECRET='Tu1fo0mO0PcAvjq^q3wQ24BXNI8$9R' \
-p 3000:3000 \
YOUR-USER/YOUR-PROJECT</pre>			<p>You will need to replace <code>mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority</code> with the connection string of your MongoDB Atlas cluster, and <code>YOUR-USER/YOUR-PROJECT</code> with your user and project name. In my case, I used <code>ulisesgascon/nodejs-for-beginners</code>.</p>
			<p>We can see the application running as expected using the same IP address and port as when running PM2:</p>
			<div><div><img src="img/B21678_17_ForCEing_FS_5.jpg" alt="Figure 17.5 – Application running using the Droplet external IP"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.5 – Application running using the Droplet external IP</p>
			<p>In the next section, we will learn how to use Cloudflare to handle domains and certificates so your users won’t need to remember your server’s IP address to access it. If you are using <a id="_idIndexMarker1036"/>a local machine, then your setup will be different as you probably won’t have a static IP address so I suggest you follow this tutorial: <a href="https://www.youtube.com/watch?v=DCxt9SAnkyc">https://www.youtube.com/watch?v=DCxt9SAnkyc</a>. That way, your project will be accessible from the internet using ngrok (<a href="https://ngrok.com/">https://ngrok.com/</a>). This will generate a connection tunnel to your machine and will expose your service as <code>https://xxxxsxx.ngrok.io</code> without worrying about network setup. Take into account that self-hosting applications that are open to internet traffic require a solid knowledge of security (<a href="https://www.youtube.com/watch?v=URWlY3Qr9l8">https://www.youtube.com/watch?v=URWlY3Qr9l8</a>), especially if you plan to use this approach for a long time.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <code>step6</code> folder from the source code that you downloaded at the beginning of the chapter to compare and fix possible bugs more easily.</p>
			<p>In the <a id="_idIndexMarker1037"/>next section, we will discuss how to do a proper domain setup and how to add an SSL certificate to the application.</p>
			<h1 id="_idParaDest-439"><a id="_idTextAnchor447"/>Using Cloudflare</h1>
			<p>The application is running in the DigitalOcean Droplet but is accessible only by IP address and port. So, we need to do a proper domain setup and add an SSL certificate to the application. Acquiring a domain has a financial cost associated with it. Depending on the domain <a id="_idIndexMarker1038"/>register, this cost may vary, and some domains are more expensive than others. SSL, together with <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>), acts as a <a id="_idIndexMarker1039"/>mechanism that we can add to our web project that will allow encryption between the clients and the server. In plain English, this will be the difference between accessing your website using http: //myproject. com or https: //myproject. com.</p>
			<p>Many browsers today will prevent access to websites that are not using <code>https://</code>. We can use Cloudflare to enable both (<code>http</code> and <code>https</code>) and it is free for the basic features, so these are the steps to follow:</p>
			<ol>
				<li>Add a new domain in Cloudflare: <a href="https://www.youtube.com/watch?v=7hY3gp_-9EU">https://www.youtube.com/watch?v=7hY3gp_-9EU</a>.</li>
				<li>Add a new DNS record in Cloudflare: <a href="https://www.youtube.com/watch?v=PYSIt3fEEoI">https://www.youtube.com/watch?v=PYSIt3fEEoI</a>. In our case, we will add an <code>A</code> record with the domain name or subdomain and the IP address of the Droplet.<p class="list-inset">You need to wait for the DNS propagation; this can take a while.</p></li>
				<li>When the DNS propagation is finished, you can access the application using the domain name. In my case, I can access the application using the domain name <code>https://demo.ulisesgascon.com</code>. In the following figure, you can see the domain set up in Cloudflare:</li>
			</ol>
			<div><div><img src="img/B21678_17_ForCEing_FS_6.jpg" alt="Figure 17.6 – Domain settings in Cloudflare"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.6 – Domain settings in Cloudflare</p>
			<p>If you don’t <a id="_idIndexMarker1040"/>want to specify the port in the URL, you can run the application in port <code>443</code> (the default for <code>https</code>) or <code>80</code> (the default for <code>http</code>) instead of port <code>3000</code>.</p>
			<p>Now that we have finished with the domain setup, we can think of more advanced topics. In the next section, we will explore the Twelve-Factor App principles.</p>
			<h1 id="_idParaDest-440"><a id="_idTextAnchor448"/>Next level – Twelve-Factor App principles</h1>
			<p>A great way to continue learning is to follow the Twelve-Factor App principles. This is a methodology <a id="_idIndexMarker1041"/>to build modern, scalable, maintainable, and portable applications, and it is structured in 12 principles. The following are <a id="_idIndexMarker1042"/>the 12 principles along with their definitions, taken from <a href="https://12factor.net">https://12factor.net</a>:</p>
			<ul>
				<li><em class="italic">Codebase</em>: One codebase tracked in revision control, many deploys</li>
				<li><em class="italic">Dependencies</em>: Explicitly declare and isolate dependencies</li>
				<li><em class="italic">Config</em>: Store config in the environment</li>
				<li><em class="italic">Backing services</em>: Treat backing services as attached resources</li>
				<li><em class="italic">Build, release, run</em>: Strictly separate build and run stages</li>
				<li><em class="italic">Processes</em>: Execute the app as one or more stateless processes</li>
				<li><em class="italic">Port binding</em>: Export services via port binding</li>
				<li><em class="italic">Concurrency</em>: Scale out <a id="_idIndexMarker1043"/>via the process model</li>
				<li><em class="italic">Disposability</em>: Maximize robustness with fast startup and graceful shutdown</li>
				<li><em class="italic">Dev/prod parity</em>: Keep development, staging, and production as similar as possible</li>
				<li><em class="italic">Logs</em>: Treat logs as event streams</li>
				<li><em class="italic">Admin processes</em>: Run admin/management tasks as one-off processes</li>
			</ul>
			<p>There are many principles that we already covered in this book, such as configuration management, but there are some that we haven’t covered yet. As an example, we don’t have a staging environment and we haven’t covered the admin processes. We built and deployed a simple app that is not designed to be used by real users or to handle real traffic, but if you want to build and deploy actual projects, it is highly recommended to follow these principles.</p>
			<p>Overall, this is a great way to continue learning and getting a deeper understanding of the topic while improving the application that we just built together in this book.</p>
			<p>In the next section, we will review the steps to clean up the resources that we used in this chapter just in case you don’t need them<a id="_idTextAnchor449"/> anymore.</p>
			<h1 id="_idParaDest-441"><a id="_idTextAnchor450"/>Cleaning up</h1>
			<p>Once we are done with the application, we can clean up the resources that we used in this chapter as we won’t need them in the near future. Most of the resources are free but I highly recommend deleting the resources that you don’t need anymore, especially if you are paying for any of those.</p>
			<p>These are the resources that you can delete:</p>
			<ul>
				<li>DigitalOcean Droplet(s) created in this chapter</li>
				<li>MongoDB Atlas cluster</li>
				<li>Docker Hub repository</li>
				<li>Cloudflare domain</li>
				<li>GitHub repository (although I recommend you keep it as you can use it as a reference in the future)</li>
			</ul>
			<p class="callout-heading">Information</p>
			<p class="callout">You can get additional hard drive space in your local environment by deleting the Docker images that you don’t need anymore or the <code>node_modules</code> folders that you created while following along with the book.</p>
			<p>This cleaning-up process was the last step for us in this journey. Before you move to the final section, I recommend you organize the notes you have taken during this journey and properly store them so you can access them in the future. In the next section, we will summarize this chapter.</p>
			<h1 id="_idParaDest-442"><a id="_idTextAnchor451"/>Summary</h1>
			<p>In this chapter, we learned how to deploy our application to the public internet using Docker and how to use GitHub Actions for CI with our Docker images.</p>
			<p>We learned how to use Docker to build the application and how to publish the image to Docker Hub, and we discussed how to do a proper domain setup and how to add an SSL certificate to the application using Cloudflare. We looked at the Twelve-Factor App principles and we reviewed the steps to clean up the resources that we used in this chapter.</p>
			<p>Congratulations, you made it! This is the end of the journey. I hope that you enjoyed it and that you learned a lot. I hope that you will continue learning and improving your skills and that you will continue building amazing applications with Node.js. I will be very happy to hear from you and to know what you think about the book. You can reach me on X/Twitter (<a href="https://twitter.com/kom_256">https://twitter.com/kom_256</a>) or LinkedIn (<a href="https://www.linkedin.com/in/ulisesgascon/">https://www.linkedin.com/in/ulisesgascon/</a>).</p>
			<h1 id="_idParaDest-443"><a id="_idTextAnchor452"/>Further reading</h1>
			<ul>
				<li>Twelve-Factor App principles: <a href="https://12factor.net/">https://12factor.net/</a><a href="https://12factor.net/&#13;"/></li>
				<li>So what is Cloudflare?: <a href="https://www.cloudflare.com/learning/what-is-cloudflare/">https://www.cloudflare.com/learning/what-is-cloudflare/</a><a href="https://www.cloudflare.com/learning/what-is-cloudflare/&#13;"/></li>
				<li><em class="italic">What 19th century railroad wars can teach us about building a future-ready </em><em class="italic">cloud</em>: <a href="https://cloud.google.com/blog/transform/what-19th-century-railroad-wars-can-teach-us-about-cloud-containers">https://cloud.google.com/blog/transform/what-19th-century-railroad-wars-can-teach-us-about-cloud-containers</a></li>
			</ul>
		</div>
	</body></html>