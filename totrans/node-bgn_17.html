<html><head></head><body>
		<div id="_idContainer119">
			<h1 id="_idParaDest-428" class="chapter-number"><a id="_idTextAnchor436"/>17</h1>
			<h1 id="_idParaDest-429"><a id="_idTextAnchor437"/>Dockerizing a Node.js Application</h1>
			<p>In this chapter, we will learn how to deploy our application to the public internet using Docker. We will explore how we can use GitHub Actions to ensure that our Docker images are <a id="_idIndexMarker1016"/>working well in the <strong class="bold">continuous integration</strong> (<span class="No-Break"><strong class="bold">CI</strong></span><span class="No-Break">) pipeline.</span></p>
			<p>We will learn how to Dockerize the application and publish the image to Docker Hub for better portability so we can download our images in <span class="No-Break">different environments.</span></p>
			<p>Finally, we will <a id="_idIndexMarker1017"/>discuss how to do a proper domain setup and how to add a <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificate to the application using Cloudflare. We will also explore the Twelve-Factor <span class="No-Break">App principles.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How to use GitHub Actions <span class="No-Break">for CI</span></li>
				<li>How to use DigitalOcean Droplet to host the <span class="No-Break">Docker application</span></li>
				<li>How to use Docker to build the application and publish the image to <span class="No-Break">Docker Hub</span></li>
				<li>How to do a proper domain setup and add an SSL certificate to the application <span class="No-Break">using Cloudflare</span></li>
				<li>What are the Twelve-Factor App principles and how can they help <span class="No-Break">you grow?</span></li>
			</ul>
			<h1 id="_idParaDest-430"><a id="_idTextAnchor438"/>Technical requirements</h1>
			<p>To start working on this chapter, we need to continue with the code that we uploaded to GitHub in the previous chapter. If you haven’t completed the previous chapter you can download the project from <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a> and access the <strong class="source-inline">step5</strong> folder as <span class="No-Break">a reference.</span></p>
			<p>You will need to create accounts with the following providers in order to follow the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Docker <span class="No-Break">Hub: </span><a href="https://hub.docker.com/signup"><span class="No-Break">https://hub.docker.com/signup</span></a><a href="https://hub.docker.com/signup&#13;"/></li>
				<li>Cloudflare: <a href="https://www.cloudflare.com/"><span class="No-Break">https://www.cloudflare.com/</span></a><span class="No-Break"> (optional)</span></li>
			</ul>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<p>Checkout the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/VWBuF_Q3KPY"><span class="No-Break">https://youtu.be/VWBuF_Q3KPY</span></a></p>
			<h1 id="_idParaDest-431"><a id="_idTextAnchor439"/>Containers and cloud-native solutions with Docker</h1>
			<p>While using a VM is a good option, it is not the best option for many applications. Currently, containers <a id="_idIndexMarker1018"/>are the most popular way to deploy applications. Containers are lightweight, portable, and easy to use. In this section, we will learn how to deploy a Node.js application <span class="No-Break">using Docker.</span></p>
			<p>We covered <a id="_idIndexMarker1019"/>the basics of Docker in previous chapters <a id="_idIndexMarker1020"/>and we have been using Docker and Docker Compose to run the MongoDB database. We now need to learn how to create a Docker image for our application and how to <span class="No-Break">deploy it.</span></p>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor440"/>Docker lifecycle</h2>
			<p>We need to <a id="_idIndexMarker1021"/>have a clear understanding of the Docker lifecycle to use it properly. Let’s start with a brief introduction. In the following figure, we can see the <span class="No-Break">Docker lifecycle:</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B21678_17_ForCEing_FS_1.jpg" alt="Figure 17.1 – Docker lifecycle diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – Docker lifecycle diagram</p>
			<p>We need to start with a <strong class="source-inline">Dockerfile,</strong> which is a file that contains the instructions to build the image. Then, we can build the image with the <strong class="source-inline">docker build</strong> command. We can then run the container with the <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command.</span></p>
			<p>If we want to share the image with other people, we can push the image to a registry with the <strong class="source-inline">docker push</strong> command. Then, other people can pull the image from the registry with the <strong class="source-inline">docker pull</strong> command. This last step is quite similar to <strong class="source-inline">npm publish</strong> but, instead of sharing the code, we are sharing <span class="No-Break">the image.</span></p>
			<p>Now that we are clear on the theory, let’s Dockerize our application in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor441"/>Dockerizing the application</h2>
			<p>In your local machine, using Docker Desktop 1.18, you can run <strong class="source-inline">docker init</strong> in the project root <a id="_idIndexMarker1022"/>folder (where <strong class="source-inline">package.json</strong> is located) to create a <strong class="source-inline">Dockerfile</strong> (see <a href="https://docs.docker.com/engine/reference/commandline/init/">https://docs.docker.com/engine/reference/commandline/init/</a>). So, we can create the files automatically with an <span class="No-Break">interactive process:</span></p>
			<pre class="source-code">
Let's get started!
? What application platform does your project use? Node
? What version of Node do you want to use? 20.11.0
? Which package manager do you want to use? npm
? What command do you want to use to start the app? npm start
? What port does your server listen on? 3000
CREATED: .dockerignore
CREATED: Dockerfile
CREATED: compose.yaml
✔ Your Docker files are ready!</pre>			<p>This tool will create the following files: <strong class="source-inline">.dockerignore</strong>, <strong class="source-inline">dockerfile</strong>, and <strong class="source-inline">compose.yaml</strong>. We will use <strong class="source-inline">dockerfile</strong> to build the image and we will use <strong class="source-inline">compose.yaml</strong> to run <span class="No-Break">the container.</span></p>
			<p>The Dockerfile will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
# syntax=docker/dockerfile:1
ARG NODE_VERSION=20.11.0
FROM node:${NODE_VERSION}-alpine
ENV NODE_ENV production
WORKDIR /usr/src/app
RUN --mount=type=bind,source=package.json,target=package.json \
    --mount=type=bind,source=package-lock.json,target=package-lock.json \
    --mount=type=cache,target=/root/.npm \
    npm ci --omit=dev
USER node
COPY . .
EXPOSE 3000
CMD npm start</pre>			<p>This is a <strong class="source-inline">Dockerfile</strong> that sets up a Node.js environment inside a Docker container. It starts by specifying the Node.js version to use (<strong class="source-inline">20.11.0</strong>) and uses the Alpine version of the Node.js <a id="_idIndexMarker1023"/>image for a smaller footprint. It sets the <strong class="source-inline">NODE_ENV</strong> environment variable to <strong class="source-inline">production</strong>. It then sets the working directory inside the container to <strong class="source-inline">/usr/src/app</strong>. The <strong class="source-inline">RUN</strong> command mounts the <strong class="source-inline">package.json</strong> and <strong class="source-inline">package-lock.json</strong> files from the host to the container and also sets up a cache for <strong class="source-inline">npm</strong> modules. It then runs <strong class="source-inline">npm ci --omit=dev</strong> to install the <strong class="source-inline">production</strong> dependencies only. It changes the user to <strong class="source-inline">node</strong> for security reasons, copies all files from the current directory on the host to the current directory in the container, exposes port <strong class="source-inline">3000</strong> for the application to be accessible, and finally, sets the command to start the application to <span class="No-Break"><strong class="source-inline">npm start</strong></span><span class="No-Break">.</span></p>
			<p>For our current application, we can remove the <strong class="source-inline">compose.yaml</strong> file as we don’t need it. It is important to review the content in the <strong class="source-inline">.dockerignore</strong> file as it excludes some files from the build process when we execute the <strong class="source-inline">COPY . .</strong> command in <span class="No-Break">the Dockerfile.</span></p>
			<p>We have all the files needed to properly use Docker to manage our application, so in the next section, we will cover that <span class="No-Break">in detail.</span></p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor442"/>Managing the application with Docker</h2>
			<p>In the previous chapter, we used PM2 to manage the application. This time, we will use Docker. We can <a id="_idIndexMarker1024"/>build the image with <span class="No-Break">the following:</span></p>
			<pre class="console">
docker build -t nodejs-for-beginners .</pre>			<p>Then, we can run the container with the following command, which will expose port <strong class="source-inline">3000</strong> and will use specific <span class="No-Break">environment variables:</span></p>
			<pre class="console">
docker run \
-e MONGODB_URI='mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority' \
-e PORT='3000' \
-e SALT_ROUNDS='10' \
-e JWT_SECRET='Tu1fo0mO0PcAvjq^q3wQ24BXNI8$9R' \
-p 3000:3000 \
nodejs-for-beginners</pre>			<p>You will need to replace <strong class="source-inline">mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority</strong> with the connection string of your MongoDB <span class="No-Break">Atlas cluster.</span></p>
			<p>If you open the browser and access <a href="http://localhost:3000">http://localhost:3000</a>, you will see the application running <span class="No-Break">as expected.</span></p>
			<p>Now that we know that the Dockerized application is working fine, we can add a step in the CI to ensure that the Docker image is <span class="No-Break">properly generated.</span></p>
			<h2 id="_idParaDest-435"><a id="_idTextAnchor443"/>Adding docker build to the CI</h2>
			<p>We can <a id="_idIndexMarker1025"/>add the <strong class="source-inline">docker build</strong> step to the CI process to ensure that the image is built correctly. We can add the following step to the CI process <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">.github/workflows/ci.yml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
- name: Build Docker image
  run: docker build -t nodejs-for-beginners .</pre>			<p>Once you commit these changes, you can check the status of the workflow in the <strong class="bold">Actions</strong> tab. You will see that the workflow is passing, including the new <strong class="source-inline">Build Docker </strong><span class="No-Break"><strong class="source-inline">image</strong></span><span class="No-Break"> step:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B21678_17_ForCEing_FS_2.jpg" alt="Figure 17.2 – Checking the workflow status"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – Checking the workflow status</p>
			<p>As you <a id="_idIndexMarker1026"/>can see in <span class="No-Break"><em class="italic">Figure 17</em></span><em class="italic">.2</em>, we successfully built the Docker image. In the next section, we will learn how to make this <span class="No-Break">image public.</span></p>
			<h2 id="_idParaDest-436"><a id="_idTextAnchor444"/>Pushing the image to Docker Hub</h2>
			<p>You need <a id="_idIndexMarker1027"/>to create a new repository in Docker Hub: <a href="https://hub.docker.com/repositories/new">https://hub.docker.com/repositories/new</a>. In <a id="_idIndexMarker1028"/>my case, I created a private repository called <strong class="source-inline">nodejs-for-beginners</strong>, as you can see in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B21678_17_ForCEing_FS_3.jpg" alt="Figure 17.3 – Creating a new repository"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3 – Creating a new repository</p>
			<p>I recommend <a id="_idIndexMarker1029"/>you create a <strong class="bold">Public</strong> image but if you want to <a id="_idIndexMarker1030"/>create a <strong class="bold">Private</strong> image, then you will need to log in to Docker Hub using the Docker CLI in your target machine (DigitalOcean Droplet or <span class="No-Break">an alternative).</span></p>
			<p>Then, from your local machine, you need to log in to Docker Hub using the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker login</pre>			<p>You can then build the image with the name of the repository with the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker build -t YOUR-USER/YOUR-PROJECT:latest .</pre>			<p>You will need to replace <strong class="source-inline">YOUR-USER/YOUR-PROJECT</strong> with your user and project name. In my case, I <span class="No-Break">used </span><span class="No-Break"><strong class="source-inline">ulisesgascon/nodejs-for-beginners</strong></span><span class="No-Break">.</span></p>
			<p>This command will print a lot of logs but, at the end, you should not see <span class="No-Break">any errors.</span></p>
			<p>Then, you need <a id="_idIndexMarker1031"/>to push the image to Docker Hub with the <a id="_idIndexMarker1032"/><span class="No-Break">following command:</span></p>
			<pre class="console">
docker push YOUR-USER/YOUR-PROJECT</pre>			<p>The output should be something like this, using the default <span class="No-Break"><strong class="source-inline">latest</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="console">
The push refers to repository [docker.io/ulisesgascon/nodejs-for-beginners]
204442a0fb02: Pushed
c797ca72cc32: Pushed
c2f374546252: Pushed
9841711cc266: Mounted from library/node
b748d0576055: Mounted from library/node
f866f7afbf16: Mounted from library/node
4693057ce236: Mounted from library/node
latest: digest: sha256:b82d23e398cf03165e89b8d1661125eda0f7b930e21 eef8c62281acd427e2d06 size: 1787</pre>			<p>If you go to the Docker Hub repository, you will see that the image has been pushed and is ready to be used in other machines with the <strong class="source-inline">docker pull </strong><span class="No-Break"><strong class="source-inline">YOUR-USER/YOUR-PROJECT:latest</strong></span><span class="No-Break"> command.</span></p>
			<p>As you can see in the following figure, the image is available in the Docker <span class="No-Break">Hub repository:</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B21678_17_ForCEing_FS_4.jpg" alt="Figure 17.4 – The image in the Docker Hub repository"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.4 – The image in the Docker Hub repository</p>
			<h2 id="_idParaDest-437"><a id="_idTextAnchor445"/>Publishing the image with GitHub Actions</h2>
			<p>As an alternative way to push the image to Docker Hub, we can publish the image directly <a id="_idIndexMarker1033"/>with GitHub Actions. This is a great way to automate the process, avoiding the need to install Docker on our local machine and ensuring <a id="_idIndexMarker1034"/>that the image is <span class="No-Break">built correctly.</span></p>
			<p>I invite you to achieve this by yourself as the last challenge of this book. Here are some hints to <span class="No-Break">help you:</span></p>
			<ul>
				<li>GitHub guide to publishing Docker <span class="No-Break">images: </span><a href="https://docs.github.com/en/actions/guides/publishing-docker-images"><span class="No-Break">https://docs.github.com/en/actions/guides/publishing-docker-images</span></a><a href="https://docs.github.com/en/actions/guides/publishing-docker-images&#13;"/></li>
				<li>A pipeline reference from the <strong class="source-inline">simple-api</strong> <span class="No-Break">project: </span><a href="https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58"><span class="No-Break">https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58</span></a><a href="https://github.com/UlisesGascon/simple-api/blob/main/.github/workflows/release.yml#L58&#13;"/></li>
			</ul>
			<p>In the next section, we will learn how to use Docker to run the project in the <span class="No-Break">DigitalOcean Droplet.</span></p>
			<h1 id="_idParaDest-438"><a id="_idTextAnchor446"/>Running the containers</h1>
			<p>In the previous chapter, we used PM2 to manage the lifecycle of our application. This time, we will do it differently: we will use <span class="No-Break">Docker directly.</span></p>
			<p>Our first <a id="_idIndexMarker1035"/>step will be to install Docker on our target machine using SSH. Follow the installation guide (<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a>) and then run <strong class="source-inline">docker run hello-world</strong>. The command will run without generating any error, this was a simple test to check whether the Docker engine was properly set up <span class="No-Break">and running.</span></p>
			<p>Please check that you stopped the PM2 application before we move to the next step as only one service can control port <strong class="source-inline">3000</strong>. Then, our last step will be to run the container but, this time, we won’t need to build the container as we are pulling directly the image from <span class="No-Break">Docker Hub:</span></p>
			<pre class="console">
docker run \
-e MONGODB_URI='mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority' \
-e PORT='3000' \
-e SALT_ROUNDS='10' \
-e JWT_SECRET='Tu1fo0mO0PcAvjq^q3wQ24BXNI8$9R' \
-p 3000:3000 \
YOUR-USER/YOUR-PROJECT</pre>			<p>You will need to replace <strong class="source-inline">mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority</strong> with the connection string of your MongoDB Atlas cluster, and <strong class="source-inline">YOUR-USER/YOUR-PROJECT</strong> with your user and project name. In my case, I <span class="No-Break">used </span><span class="No-Break"><strong class="source-inline">ulisesgascon/nodejs-for-beginners</strong></span><span class="No-Break">.</span></p>
			<p>We can see the application running as expected using the same IP address and port as when <span class="No-Break">running PM2:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B21678_17_ForCEing_FS_5.jpg" alt="Figure 17.5 – Application running using the Droplet external IP"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.5 – Application running using the Droplet external IP</p>
			<p>In the next section, we will learn how to use Cloudflare to handle domains and certificates so your users won’t need to remember your server’s IP address to access it. If you are using <a id="_idIndexMarker1036"/>a local machine, then your setup will be different as you probably won’t have a static IP address so I suggest you follow this tutorial: <a href="https://www.youtube.com/watch?v=DCxt9SAnkyc">https://www.youtube.com/watch?v=DCxt9SAnkyc</a>. That way, your project will be accessible from the internet using ngrok (<a href="https://ngrok.com/">https://ngrok.com/</a>). This will generate a connection tunnel to your machine and will expose your service as <strong class="source-inline">https://xxxxsxx.ngrok.io</strong> without worrying about network setup. Take into account that self-hosting applications that are open to internet traffic require a solid knowledge of security (<a href="https://www.youtube.com/watch?v=URWlY3Qr9l8">https://www.youtube.com/watch?v=URWlY3Qr9l8</a>), especially if you plan to use this approach for a <span class="No-Break">long time.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <strong class="source-inline">step6</strong> folder from the source code that you downloaded at the beginning of the chapter to compare and fix possible bugs <span class="No-Break">more easily.</span></p>
			<p>In the <a id="_idIndexMarker1037"/>next section, we will discuss how to do a proper domain setup and how to add an SSL certificate to <span class="No-Break">the application.</span></p>
			<h1 id="_idParaDest-439"><a id="_idTextAnchor447"/>Using Cloudflare</h1>
			<p>The application is running in the DigitalOcean Droplet but is accessible only by IP address and port. So, we need to do a proper domain setup and add an SSL certificate to the application. Acquiring a domain has a financial cost associated with it. Depending on the domain <a id="_idIndexMarker1038"/>register, this cost may vary, and some domains are more expensive than others. SSL, together with <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>), acts as a <a id="_idIndexMarker1039"/>mechanism that we can add to our web project that will allow encryption between the clients and the server. In plain English, this will be the difference between accessing your website using http: //myproject. com or https: //<span class="No-Break">myproject. com.</span></p>
			<p>Many browsers today will prevent access to websites that are not using <strong class="source-inline">https://</strong>. We can use Cloudflare to enable both (<strong class="source-inline">http</strong> and <strong class="source-inline">https</strong>) and it is free for the basic features, so these are the steps <span class="No-Break">to follow:</span></p>
			<ol>
				<li>Add a new domain in <span class="No-Break">Cloudflare: </span><a href="https://www.youtube.com/watch?v=7hY3gp_-9EU"><span class="No-Break">https://www.youtube.com/watch?v=7hY3gp_-9EU</span></a><span class="No-Break">.</span></li>
				<li>Add a new DNS record in Cloudflare: <a href="https://www.youtube.com/watch?v=PYSIt3fEEoI">https://www.youtube.com/watch?v=PYSIt3fEEoI</a>. In our case, we will add an <strong class="source-inline">A</strong> record with the domain name or subdomain and the IP address of <span class="No-Break">the Droplet.</span><p class="list-inset">You need to wait for the DNS propagation; this can take <span class="No-Break">a while.</span></p></li>
				<li>When the DNS propagation is finished, you can access the application using the domain name. In my case, I can access the application using the domain name <strong class="source-inline">https://demo.ulisesgascon.com</strong>. In the following figure, you can see the domain set up <span class="No-Break">in Cloudflare:</span></li>
			</ol>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B21678_17_ForCEing_FS_6.jpg" alt="Figure 17.6 – Domain settings in Cloudflare"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.6 – Domain settings in Cloudflare</p>
			<p>If you don’t <a id="_idIndexMarker1040"/>want to specify the port in the URL, you can run the application in port <strong class="source-inline">443</strong> (the default for <strong class="source-inline">https</strong>) or <strong class="source-inline">80</strong> (the default for <strong class="source-inline">http</strong>) instead of <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">3000</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have finished with the domain setup, we can think of more advanced topics. In the next section, we will explore the Twelve-Factor <span class="No-Break">App principles.</span></p>
			<h1 id="_idParaDest-440"><a id="_idTextAnchor448"/>Next level – Twelve-Factor App principles</h1>
			<p>A great way to continue learning is to follow the Twelve-Factor App principles. This is a methodology <a id="_idIndexMarker1041"/>to build modern, scalable, maintainable, and portable applications, and it is structured in 12 principles. The following are <a id="_idIndexMarker1042"/>the 12 principles along with their definitions, taken <span class="No-Break">from </span><a href="https://12factor.net"><span class="No-Break">https://12factor.net</span></a><span class="No-Break">:</span></p>
			<ul>
				<li><em class="italic">Codebase</em>: One codebase tracked in revision control, <span class="No-Break">many deploys</span></li>
				<li><em class="italic">Dependencies</em>: Explicitly declare and <span class="No-Break">isolate dependencies</span></li>
				<li><em class="italic">Config</em>: Store config in <span class="No-Break">the environment</span></li>
				<li><em class="italic">Backing services</em>: Treat backing services as <span class="No-Break">attached resources</span></li>
				<li><em class="italic">Build, release, run</em>: Strictly separate build and <span class="No-Break">run stages</span></li>
				<li><em class="italic">Processes</em>: Execute the app as one or more <span class="No-Break">stateless processes</span></li>
				<li><em class="italic">Port binding</em>: Export services via <span class="No-Break">port binding</span></li>
				<li><em class="italic">Concurrency</em>: Scale out <a id="_idIndexMarker1043"/>via the <span class="No-Break">process model</span></li>
				<li><em class="italic">Disposability</em>: Maximize robustness with fast startup and <span class="No-Break">graceful shutdown</span></li>
				<li><em class="italic">Dev/prod parity</em>: Keep development, staging, and production as similar <span class="No-Break">as possible</span></li>
				<li><em class="italic">Logs</em>: Treat logs as <span class="No-Break">event streams</span></li>
				<li><em class="italic">Admin processes</em>: Run admin/management tasks as <span class="No-Break">one-off processes</span></li>
			</ul>
			<p>There are many principles that we already covered in this book, such as configuration management, but there are some that we haven’t covered yet. As an example, we don’t have a staging environment and we haven’t covered the admin processes. We built and deployed a simple app that is not designed to be used by real users or to handle real traffic, but if you want to build and deploy actual projects, it is highly recommended to follow <span class="No-Break">these principles.</span></p>
			<p>Overall, this is a great way to continue learning and getting a deeper understanding of the topic while improving the application that we just built together in <span class="No-Break">this book.</span></p>
			<p>In the next section, we will review the steps to clean up the resources that we used in this chapter just in case you don’t need <span class="No-Break">them<a id="_idTextAnchor449"/> anymore.</span></p>
			<h1 id="_idParaDest-441"><a id="_idTextAnchor450"/>Cleaning up</h1>
			<p>Once we are done with the application, we can clean up the resources that we used in this chapter as we won’t need them in the near future. Most of the resources are free but I highly recommend deleting the resources that you don’t need anymore, especially if you are paying for any <span class="No-Break">of those.</span></p>
			<p>These are the resources that you <span class="No-Break">can delete:</span></p>
			<ul>
				<li>DigitalOcean Droplet(s) created in <span class="No-Break">this chapter</span></li>
				<li>MongoDB <span class="No-Break">Atlas cluster</span></li>
				<li>Docker <span class="No-Break">Hub repository</span></li>
				<li><span class="No-Break">Cloudflare domain</span></li>
				<li>GitHub repository (although I recommend you keep it as you can use it as a reference in <span class="No-Break">the future)</span></li>
			</ul>
			<p class="callout-heading">Information</p>
			<p class="callout">You can get additional hard drive space in your local environment by deleting the Docker images that you don’t need anymore or the <strong class="source-inline">node_modules</strong> folders that you created while following along with <span class="No-Break">the book.</span></p>
			<p>This cleaning-up process was the last step for us in this journey. Before you move to the final section, I recommend you organize the notes you have taken during this journey and properly store them so you can access them in the future. In the next section, we will summarize <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-442"><a id="_idTextAnchor451"/>Summary</h1>
			<p>In this chapter, we learned how to deploy our application to the public internet using Docker and how to use GitHub Actions for CI with our <span class="No-Break">Docker images.</span></p>
			<p>We learned how to use Docker to build the application and how to publish the image to Docker Hub, and we discussed how to do a proper domain setup and how to add an SSL certificate to the application using Cloudflare. We looked at the Twelve-Factor App principles and we reviewed the steps to clean up the resources that we used in <span class="No-Break">this chapter.</span></p>
			<p>Congratulations, you made it! This is the end of the journey. I hope that you enjoyed it and that you learned a lot. I hope that you will continue learning and improving your skills and that you will continue building amazing applications with Node.js. I will be very happy to hear from you and to know what you think about the book. You can reach me on X/Twitter (<a href="https://twitter.com/kom_256">https://twitter.com/kom_256</a>) or <span class="No-Break">LinkedIn (</span><a href="https://www.linkedin.com/in/ulisesgascon/"><span class="No-Break">https://www.linkedin.com/in/ulisesgascon/</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-443"><a id="_idTextAnchor452"/>Further reading</h1>
			<ul>
				<li>Twelve-Factor App <span class="No-Break">principles: </span><a href="https://12factor.net/"><span class="No-Break">https://12factor.net/</span></a><a href="https://12factor.net/&#13;"/></li>
				<li>So what is <span class="No-Break">Cloudflare?: </span><a href="https://www.cloudflare.com/learning/what-is-cloudflare/"><span class="No-Break">https://www.cloudflare.com/learning/what-is-cloudflare/</span></a><a href="https://www.cloudflare.com/learning/what-is-cloudflare/&#13;"/></li>
				<li><em class="italic">What 19th century railroad wars can teach us about building a future-ready </em><span class="No-Break"><em class="italic">cloud</em></span><span class="No-Break">: </span><a href="https://cloud.google.com/blog/transform/what-19th-century-railroad-wars-can-teach-us-about-cloud-containers"><span class="No-Break">https://cloud.google.com/blog/transform/what-19th-century-railroad-wars-can-teach-us-about-cloud-containers</span></a></li>
			</ul>
		</div>
	</body></html>