- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Effective Routing Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效的路由技术
- en: We’ve spent a lot of time covering background information. I know those topics
    aren’t always the most exciting, but now that we’ve covered them, we can get to
    the real fun. Up until now, we’ve only briefly touched on adding new routes by
    creating a directory inside `src/routes/` with the desired route name and adding
    a `+page.svelte` file inside of it. We also briefly looked into creating server
    pages. But, of course, routing isn’t always so simple. How do we build out an
    **application programming interface** (**API**)? How do we create a consistent
    **user interface** (**UI**) throughout our application without duplicating styles
    on each page? What happens when our application throws an error?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经花费了很多时间来介绍背景信息。我知道这些主题并不总是最令人兴奋的，但现在我们已经介绍了它们，我们可以进入真正的乐趣。到目前为止，我们只是简要地提到了通过在`src/routes/`内部创建一个名为所需路由名的目录来添加新路由，并在其中添加一个`+page.svelte`文件。我们还简要地探讨了创建服务器页面。但是，当然，路由并不总是这么简单。我们如何构建**应用程序编程接口**（**API**）？我们如何在不重复每个页面的样式的情况下，在整个应用程序中创建一个一致的**用户界面**（**UI**）？当我们的应用程序抛出错误时会发生什么？
- en: In this chapter, we will answer some of those questions by discussing some core
    points about routing within the context of SvelteKit. First, we’ll look at how
    we can create new pages with dynamic content. Then, we’ll take a closer look at
    how the `+page.server.js` files work. We’ll then show how to go about creating
    API endpoints that can accept various types of HTTP requests. And finally, we’ll
    cover how to build a consistent UI throughout an application using layouts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过讨论SvelteKit路由的某些核心点来回答这些问题。首先，我们将看看我们如何创建具有动态内容的新页面。然后，我们将更详细地研究`+page.server.js`文件的工作方式。然后，我们将展示如何创建可以接受各种类型HTTP请求的API端点。最后，我们将介绍如何使用布局在整个应用程序中构建一个一致的UI。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating Dynamic Pages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态页面
- en: Creating Server Pages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务器页面
- en: Creating API Endpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建API端点
- en: Creating Layouts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建布局
- en: By the end of this chapter, you should have a comfortable understanding of routing
    concepts for SvelteKit’s file-based routing mechanism.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对SvelteKit的基于文件的路由机制的路由概念有一个舒适的理解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter04](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter04).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter04](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter04)。
- en: Creating Dynamic Pages
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态页面
- en: 'In previous chapters, we’ve covered the process of creating a new page. To
    refresh your memory, it is as simple as creating a new directory inside `src/routes/`
    with the desired route name. Inside that directory, we create `+page.svelte`,
    which is simply a Svelte component that is then rendered as the page shown in
    the browser. An embarrassingly simple **About** page might look like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经介绍了创建新页面的过程。为了刷新你的记忆，它就像在`src/routes/`内部创建一个名为所需路由名的新目录一样简单。在那个目录内部，我们创建`+page.svelte`，它只是一个Svelte组件，然后作为在浏览器中显示的页面进行渲染。一个令人尴尬的简单的**关于**页面可能看起来像这样：
- en: src/routes/about/+page.svelte
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/about/+page.svelte
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example illustrates just how simple adding a new page is. In it, we see
    a `div`, an `h1` title tag, and a paragraph `p` tag with the `lorem ipsum` sample
    text. Of course, in a real-world scenario, it would have much more content as
    well as some styles. This example exists only to show how simple it is to add
    a new, static page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子仅仅说明了添加新页面是多么简单。在其中，我们看到一个`div`，一个`h1`标题标签，和一个带有`lorem ipsum`样本文本的段落`p`标签。当然，在现实世界的场景中，它会有更多内容以及一些样式。这个例子只存在是为了展示添加新静态页面是多么简单。
- en: But what if you needed to create a page where you didn’t know what the content
    was? What if we wanted to create a page with a dynamic URL? For instance, when
    viewing news articles online, users can typically share a link directly to the
    article. This means each article has its own unique URL. If we wanted to create
    a single template that showed articles pulled from a database, we would need to
    find a way to manage the URL to each as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '但如果你需要创建一个你不知道内容是什么的页面呢？如果我们想创建一个具有动态URL的页面呢？例如，当在线查看新闻文章时，用户通常可以直接分享到文章的链接。这意味着每篇文章都有自己的独特URL。如果我们想创建一个显示从数据库中提取的文章的单个模板，我们就需要找到一种方法来管理每个URL。 '
- en: In instances such as these, SvelteKit’s file-based routing mechanism has a special
    syntax to use. When creating the template showing the content, we create it in
    a directory with the dynamic portion of the route surrounded by square brackets
    (`[ ]`). The name given inside the brackets will then become a parameter that
    will allow us to load data dynamically. To make this parameter optional, use double
    square brackets (`[[ ]]`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，SvelteKit的基于文件的路由机制有一个特殊的语法可以使用。当创建显示内容的模板时，我们在一个目录中创建它，其中路由的动态部分被方括号`[
    ]`包围。方括号内的名称将成为一个参数，允许我们动态加载数据。为了使此参数可选，请使用双方括号`[[ ]]`。
- en: 'That may sound confusing at first, so let’s take a look at an example showcasing
    how you might manage news articles or blog posts. We’ll need to create a few files
    within this example. Instead of connecting to an actual database, we’ll use a
    JSON file to store some sample data and pull directly from that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始听起来有些令人困惑，所以让我们看看一个示例，展示您如何管理新闻文章或博客文章。在这个示例中，我们需要创建一些文件。我们不会连接到实际的数据库，而是使用JSON文件来存储一些示例数据并直接从该文件中提取：
- en: src/lib/articles.json
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib/articles.json
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file is essentially a single object containing two objects, each of which
    has the `title`, `slug`, and `content` properties. You can tweak this file however
    you like or add as many entries as you’d like to see. Its purpose is to act as
    a placeholder database to illustrate the following example.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件基本上是一个包含两个对象的单一对象，每个对象都具有`title`、`slug`和`content`属性。您可以随意调整此文件或添加您想看到的条目。其目的是作为一个占位符数据库来展示以下示例。
- en: 'Next, a news page usually has a landing page where users can scroll and view
    the most recent articles. In accordance with established practices, we’ll create
    a `+page.server.js` file to load our data and make it available to the `+page.svelte`
    template that will function as the page rendering the data:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，新闻页面通常有一个着陆页，用户可以滚动查看最新的文章。根据既定惯例，我们将创建一个`+page.server.js`文件来加载数据并将其提供给作为页面渲染数据的`+page.svelte`模板：
- en: src/routes/news/+page.server.js
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/news/+page.server.js
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because it doesn’t contain any environment variables or secrets or make a call
    to a real database, this file could just as well be a `+page.js` file. It works
    only to load data from the JSON example file. Essentially, it imports that file
    and then returns it as an object in the exported `load()` function, making it
    available to the Svelte template shown next. In reality, something so trivial
    could also be done in the `<script>` tag of the Svelte template but remember that
    this example aims to function as a stand-in for a real database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它不包含任何环境变量或秘密，也不调用真实的数据库，这个文件也可以是一个`+page.js`文件。它仅用于从JSON示例文件加载数据。本质上，它导入该文件，然后在导出的`load()`函数中将其作为对象返回，使其对下一个显示的Svelte模板可用。实际上，这样的事情也可以在Svelte模板的`<script>`标签中完成，但请记住，这个示例旨在作为一个真实数据库的替代品。
- en: 'Now that we’ve loaded our articles, we’ll need somewhere to show them, so let’s
    do that now and create a landing page for our news. For the sake of brevity, styles
    have been omitted:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了我们的文章，我们需要一个地方来展示它们，所以现在让我们创建一个用于新闻的着陆页。为了简洁起见，省略了样式：
- en: src/routes/news/+page.svelte
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/news/+page.svelte
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This Svelte component exports the `data` variable, giving us access to the data
    we previously returned from our faked database in `load()`. It then adds an `h1`
    title tag, followed by an unordered list of each of the entries from our fake
    data. After which, it makes use of the `{#each}` Svelte template syntax to iterate
    over each of the entries in the array returned from `Object.entries(data.json)`.
    For each of the entries (our two sample objects), we surround them with list item
    tags and show the `title` property inside a `<a>` tag linking to the article via
    the `slug` property.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Svelte组件导出`data`变量，使我们能够访问从我们的模拟数据库在`load()`中返回的数据。然后它添加一个`h1`标题标签，接着是一个无序列表，列出我们模拟数据中的每个条目。之后，它使用`{#each}`
    Svelte模板语法遍历从`Object.entries(data.json)`返回的数组中的每个条目。对于每个条目（我们的两个示例对象），我们用列表项标签将其包围，并在`<a>`标签中显示`title`属性，通过`slug`属性链接到文章。
- en: 'Next, we’ll need to create a page to show the article content but keep in mind
    we want the route to have a parameter within it, so we’ll use the `[ ]` square
    brackets to surround the article slug:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个页面来显示文章内容，但请注意，我们希望路由中包含一个参数，所以我们将使用方括号`[ ]`来包围文章的slug：
- en: src/routes/news/[slug]/+page.svelte
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/news/[slug]/+page.svelte
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This file exports the `data` variable so that we may access information about
    our article. It then shows `News` inside a `<h1>` title tag, followed by a `<h2>`
    title tag with the article title, a `div` containing the article content, and
    a link back to the news page. All of the article information is loaded by making
    another call to our *database* in the next file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件导出`data`变量，以便我们可以访问关于我们的文章的信息。然后，它在一个`<h1>`标题标签内显示`News`，接着是一个带有文章标题的`<h2>`标题标签，一个包含文章内容的`div`，以及一个返回新闻页面的链接。所有文章信息都是通过在下一个文件中对我们的*数据库*进行另一次调用而加载的：
- en: src/routes/news/[slug]/+page.server.js
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/news/[slug]/+page.server.js
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just as before, we’ve imported our fake database to access the full article
    content. This code also imports the `error` module from SvelteKit, which will
    come in handy later on. We’ve then exported the `load()` function so that we can
    return the loaded data to the rendered page. Inside the `load()` function, the
    code initializes an empty variable labeled `found`, and then begins to iterate
    over each object inside of the JSON data. In the loop, it checks whether any of
    the slugs in our data match the given slug in the URL. If a match is found, it
    is then assigned to the `found` variable. After finishing the loop, we check that
    `found` is not an empty object. If it is not empty, we return an object containing
    the `found` variable. If it is empty, we throw a **404 Not** **Found** error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们已经导入我们的模拟数据库来访问完整的文章内容。此代码还导入了SvelteKit的`error`模块，这将在稍后很有用。然后我们导出了`load()`函数，以便我们可以将加载的数据返回到渲染的页面。在`load()`函数内部，代码初始化一个名为`found`的空变量，然后开始遍历JSON数据中的每个对象。在循环中，它检查我们数据中的任何slugs是否与URL中给出的slug匹配。如果找到匹配项，它将被分配给`found`变量。循环结束后，我们检查`found`不是一个空对象。如果不是空的，我们返回一个包含`found`变量的对象。如果是空的，我们抛出一个**404
    Not Found**错误。
- en: 'Upon opening your development site in your browser and navigating to `/news`,
    you should see two article titles listed. When clicked, they will redirect users
    to the respective article. This example illustrates routing with parameters in
    a simple way that works for the most part. But what do we do about the times when
    it doesn’t work? Have you tried navigating to an article that doesn’t exist yet?
    Go ahead and try it now; I’ll wait right here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中打开你的开发站点并导航到`/news`时，你应该看到列出两个文章标题。点击它们将使用户重定向到相应的文章。这个例子以简单的方式说明了参数化路由，这在大多数情况下是有效的。但是，当它不起作用时我们该怎么办？你尝试导航到一个不存在的文章了吗？现在就试试看；我会在这里等着：
- en: '![](img/B19024_04_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19024_04_01.jpg)'
- en: Figure 4.1 – A generic error page is shown when throwing an error in SvelteKit
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 在SvelteKit中抛出错误时显示一个通用错误页面
- en: 'The article doesn’t exist, and the user is shown a generic error page. If we
    didn’t throw an error at all, the page would be rendered showing the `undefined`
    values. Instead, we should show the user a proper error page. Just as SvelteKit
    provides us with the `+page.svelte`, `+page.js`, and `+page.server.js` files,
    we can also create an `+error.svelte` template, which can be used when errors
    are thrown from the application. By specifying it in the `src/routes/news/[slug]/`
    directory, the error page template will be localized to that particular route.
    If we wanted to build a generic error page to be used across the entire application,
    we could do so by placing an `+error.svelte` template at the root route of the
    application (`src/routes/+error.svelte`). Let’s create a template in `src/routes/news/[slug]/`
    so users aren’t confused by our lack of clear communication:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文章不存在，用户会看到一个通用的错误页面。如果我们完全不抛出错误，页面将渲染显示`undefined`值。相反，我们应该向用户展示一个合适的错误页面。正如SvelteKit为我们提供了`+page.svelte`、`+page.js`和`+page.server.js`文件，我们也可以创建一个`+error.svelte`模板，当应用程序抛出错误时可以使用。通过在`src/routes/news/[slug]/`目录中指定它，错误页面模板将被本地化到该特定路由。如果我们想构建一个在整个应用程序中通用的错误页面，我们可以在应用程序的根路由（`src/routes/+error.svelte`）放置一个`+error.svelte`模板。让我们在`src/routes/news/[slug]/`中创建一个模板，这样用户就不会因为我们的沟通不清而感到困惑：
- en: src/routes/news/[slug]/+error.svelte
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/news/[slug]/+error.svelte
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For this error template, we import the `page` store module to access information
    about this particular request. This module, as well as many others, is available
    to use throughout the application. As this one makes use of Svelte’s stores, we
    can access the values it contains about the page by prefacing it with a dollar
    sign (`$`). The rest of this template is fairly straightforward. It includes the
    `<h1>` title tag labeled `News`, followed by the status code and error message
    we passed when we threw our error in `+page.server.js`. Some styles have been
    included to show how this template is different from the default template shown
    throughout SvelteKit. Compare *Figure 4**.1* of the generic SvelteKit error template
    to *Figure 4**.2*, our custom version:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个错误模板，我们导入`page`存储模块来访问有关此特定请求的信息。该模块以及许多其他模块在整个应用程序中都可以使用。由于这个模块使用了Svelte的存储，我们可以通过在前面加上美元符号（`$`）来访问它包含的关于页面的值。这个模板的其余部分相当直接。它包括标记为`News`的`<h1>`标题标签，后面跟着我们在`+page.server.js`中抛出错误时传递的状态码和错误消息。一些样式被包括进来，以显示这个模板与SvelteKit中显示的默认模板的不同。将通用SvelteKit错误模板的*图4.1*与我们的自定义版本*图4.2*进行比较：
- en: '![](img/B19024_04_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19024_04_02.jpg)'
- en: Figure 4.2 – A customized error page template
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 定制的错误页面模板
- en: By now, you should feel comfortable creating essential routes for your application,
    whether they are static or dynamic. You should also be able to show error pages
    based on the route. There will be more about advanced routing later on, but for
    now, let’s take a closer look at how the `+page.server.js` files work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够舒适地创建应用程序的基本路由，无论是静态的还是动态的。你也应该能够根据路由显示错误页面。关于高级路由的内容将在稍后介绍，但现在，让我们更仔细地看看`+page.server.js`文件是如何工作的。
- en: Creating Server Pages
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器页面
- en: 'In previous examples, we’ve used the `+page.js` and `+page.server.js` files
    for loading data. Often, they can be used interchangeably, but when is the best
    time to use which? In this section, we’ll break down some of the differences between
    the two and also discuss various features available in the `+page.server.js` files.
    We’ll break it down into these topics:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用了`+page.js`和`+page.server.js`文件来加载数据。通常，它们可以互换使用，但何时使用哪一个才是最佳时机？在本节中，我们将分析这两个文件之间的部分差异，并讨论`+page.server.js`文件中可用的各种功能。我们将将其分解为以下主题：
- en: '`load()`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()`'
- en: Page options
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面选项
- en: Actions
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: load()
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: load()
- en: As we’ve seen in previous examples, data can be loaded into a `+page.svelte`
    component by exporting the `data` property on that page. Both `+page.js` and `+page.server.js`
    can then be used for loading data to that page template as they can both export
    a `load()` function. When to use which file depends on how you plan to load that
    data. When run in a `+page.js` file, `load()` will run on *both the client and
    the server*. It is recommended to load data here if you are able, as SvelteKit
    can manage grabbing data from calls with `fetch()`. This becomes particularly
    useful when preloading data (anticipating what the user may do and starting the
    process milliseconds before they actually do it).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中所见，数据可以通过在页面中导出`data`属性来加载到`+page.svelte`组件中。`+page.js`和`+page.server.js`都可以用来将数据加载到该页面模板中，因为它们都可以导出`load()`函数。何时使用哪个文件取决于你计划如何加载数据。当在`+page.js`文件中运行时，`load()`将在**客户端和服务器**上同时运行。如果你能够在这里加载数据，这是推荐的，因为SvelteKit可以管理通过`fetch()`调用获取数据。当预加载数据（预测用户可能的行为并在他们实际操作前开始处理）时，这尤其有用。
- en: However, there are times this isn’t possible. For instance, if you need to make
    a call to an API that requires authentication or a database, you likely don’t
    want your connection secrets exposed to the client. That would allow anyone with
    access to your application to then download your secrets and make requests to
    said API or database on your behalf. In these cases, you’ll need to store the
    secrets on your server. And since those secrets are on your server, you’ll need
    access to the server’s filesystem. The server will need to make the calls to obtain
    the appropriate data and pass that data to the client. In instances such as these,
    it is best to use the `+page.server.js` files for data loading requirements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时这是不可能的。例如，如果你需要调用需要身份验证或数据库的API，你很可能不希望你的连接秘密暴露给客户端。这样，任何有权访问你的应用程序的人都可以下载你的秘密并代表你向该API或数据库发出请求。在这些情况下，你需要在服务器上存储这些秘密。由于这些秘密在服务器上，你需要访问服务器的文件系统。服务器需要调用以获取适当的数据，并将这些数据传递给客户端。在这些情况下，最好使用`+page.server.js`文件来满足数据加载需求。
- en: Page options
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面选项
- en: '`+page.js` and `+page.server.js` files are not just used for loading data.
    They can also export various options specific to their sibling page. Some options
    allow you to configure functionality related to the rendering of pages. These
    particular options are Boolean values, which means they can be enabled by setting
    them to `true` or disabled by setting them to `false`. They are the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`+page.js`和`+page.server.js`文件不仅用于加载数据。它们还可以导出针对其同级页面的特定选项。某些选项允许您配置与页面渲染相关的功能。这些特定的选项是布尔值，这意味着可以通过将它们设置为`true`来启用，或通过将它们设置为`false`来禁用。它们如下所示：'
- en: '`prerender`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预渲染
- en: '`ssr`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ssr
- en: '`csr`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: csr
- en: prerender
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预渲染
- en: While prerendering can be customized in a `svelte.config.js` project, you may
    find yourself needing to explicitly enable or disable it on a per-page basis.
    To enable it on a page, you can set `export const prerender = true;`. Conversely,
    setting its value to `false` will disable prerendering for that page. When to
    prerender a page should be determined by whether or not the HTML content of the
    page is static. If the HTML shown on the page should be the same no matter who
    is viewing it, then a page is considered safe to prerender. By prerendering a
    page, the HTML will be generated at build time, and static HTML will be shipped
    to the client for each request to that particular route. This results in faster
    load times for end users, which makes for a better experience.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在`svelte.config.js`项目中自定义预渲染，但您可能会发现自己需要根据页面逐个显式启用或禁用它。要在页面上启用预渲染，您可以设置`export
    const prerender = true;`。相反，将其值设置为`false`将禁用该页面的预渲染。何时预渲染页面应根据页面的HTML内容是否静态来决定。如果页面上显示的HTML应该对任何查看者都相同，则该页面被认为是安全的预渲染。通过预渲染页面，HTML将在构建时生成，并且对于每个特定路由的请求，将静态HTML发送到客户端。这导致最终用户的加载时间更快，从而提供更好的体验。
- en: Server-side rendering
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: '`export const ssr = true;` in the `+page.js` file or `+page.server.js`. SvelteKit
    enables this option by default, so if you need to change it, you’ll likely find
    yourself disabling it by setting the value to `false`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`+page.js`文件或`+page.server.js`文件中，`export const ssr = true;`。SvelteKit默认启用此选项，因此如果您需要更改它，您可能会发现自己通过将其值设置为`false`来禁用它。
- en: Client Side Rendering
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端渲染
- en: Instead of rendering the page on the server, and sending that to the client,
    enabling `export const csr = false;` just as you would with other available page
    options.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在服务器上渲染页面并将其发送到客户端，通过启用`export const csr = false;`，就像您对其他可用的页面选项所做的那样。
- en: You’ll likely find these rendering-related options useful should you find yourself
    building an SPA, a static HTML site, or if you’re attempting to render static
    content on the client end.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己正在构建一个SPA、一个静态HTML网站，或者尝试在客户端渲染静态内容，您可能会发现这些渲染相关的选项很有用。
- en: Actions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: Because `+page.js` files are also run in the client, they cannot export actions.
    Actions allow you to receive data submitted by the `form` elements sent via the
    POST HTTP method. We saw an example of this in [*Chapter 3*](B19024_03_Final_AM.xhtml#_idTextAnchor051),
    where we discussed the `FormData` API compatibility with SvelteKit. In that example,
    we exported a default action. A default action will be triggered by submitting
    a form element that has not specified an `action` property. However, we are not
    limited to only default actions, as SvelteKit also enables us to create named
    actions. Named actions will all work on the same route but are differentiated
    from each other by providing the route followed by the action name in a query
    string. A default action may not exist alongside named actions, so you must remove
    it or change its name and set the `action` property on the `form` elements that
    utilize it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`+page.js`文件也在客户端运行，所以它们不能导出行为。行为允许您接收通过POST HTTP方法发送的`form`元素提交的数据。我们在[*第3章*](B19024_03_Final_AM.xhtml#_idTextAnchor051)中看到了一个例子，我们讨论了SvelteKit与`FormData`
    API的兼容性。在那个例子中，我们导出了一个默认行为。默认行为将由未指定`action`属性的表单元素提交时触发。然而，我们不仅限于只有默认行为，因为SvelteKit还允许我们创建命名行为。命名行为将在相同的路由上工作，但通过在查询字符串中提供路由后跟行为名称来区分彼此。默认行为可能不会与命名行为共存，因此您必须删除它或更改其名称，并在使用它的`form`元素上设置`action`属性。
- en: 'Building from our previous example, let’s look at how we might implement a
    few more actions related to comments online. Some additional functionality we
    may want to create would be allowing users to `star` a comment or reply. Since
    we’ll be adding more named actions, we’ll change the `default` action to `create`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们之前的示例，让我们看看我们如何实现一些与在线评论相关的更多操作。我们可能想要创建的一些附加功能包括允许用户对评论进行`star`或回复。由于我们将添加更多命名操作，我们将`default`操作更改为`create`：
- en: src/routes/comment/+page.server.js
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/comment/+page.server.js
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how the `default` action was changed to `create`. The code within `create`
    has been omitted as it has not changed since our last example. We’ve also added
    the `star` and `reply` actions. For now, they don’t do much except return an object
    that will output our message, showcasing that they are both called when the respective
    button is clicked. In a real-world scenario, these would likely make calls to
    a database, increasing the “star count,” or saving the reply comment content and
    a unique identifier of the comment being replied to.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`default`操作已被更改为`create`。`create`中的代码已被省略，因为自上次示例以来它没有变化。我们还添加了`star`和`reply`操作。目前，它们除了返回一个对象，该对象将输出我们的消息，展示当点击相应的按钮时它们都会被调用。在现实世界的场景中，这些操作可能会调用数据库，增加“star
    count”，或保存回复评论的内容和被回复评论的唯一标识符。
- en: 'As for the form itself, we could create separate forms and specify the `POST`
    method as well as the `action` property for each new feature. However, a more
    intuitive user experience would consolidate the features and keep them all in
    one cohesive component. Instead of creating multiple forms, we’ll create a button
    for the new features and specify a `formaction` property for each. Doing this
    will keep the HTTP method specified in the parent form but allow sending the requests
    to different actions based on the button clicked:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 关于表单本身，我们可以为每个新功能创建单独的表单，并指定`POST`方法和每个新功能的`action`属性。然而，一个更直观的用户体验会将功能整合在一起，并将它们都保留在一个统一的组件中。我们不会创建多个表单，而是为新的功能创建一个按钮，并为每个按钮指定一个`formaction`属性。这样做将保持父表单中指定的HTTP方法，但允许根据点击的按钮发送到不同的操作：
- en: src/routes/comment/+page.svelte
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/comment/+page.svelte
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first change to notice from our previous encounter with this example is
    that we’ve added `import { enhance } from '$app/forms';`. This addition will allow
    us to progressively enhance our form with JavaScript. The page will then not need
    to be reloaded after each form submission. This module is utilized in the `<form>`
    element further down with the Svelte `use:` directive. Try running the example
    without it and observe how the URL will now contain query strings based on which
    button is clicked.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们上次遇到这个示例时，首先要注意的变化是我们添加了`import { enhance } from '$app/forms';`。这个添加将允许我们使用JavaScript逐步增强我们的表单。然后，在每次表单提交后，页面将不需要重新加载。这个模块在下面的`<form>`元素中使用Svelte的`use:`指令。尝试运行没有它的示例，并观察现在URL将根据点击的哪个按钮包含查询字符串。
- en: Speaking of buttons, we’ve added two in this example. Each has the `formaction`
    property set, which allows us to specify which of our named actions we would like
    called from `+page.server.js`. Take note that we *must* call these actions by
    specifying a query parameter followed by a `/` character. We’ve also set the form
    action to `?/create`. Since we have exported named actions, we can no longer have
    an action named `default` and must specify the action to be called on the `form`
    element. If we wanted to call an action located at another route, we could do
    so easily by setting `formaction` to the desired route name followed by `?/`,
    and the action name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 说到按钮，我们在本例中添加了两个。每个按钮都设置了`formaction`属性，这允许我们指定从`+page.server.js`中调用哪个命名操作。请注意，我们必须通过指定一个查询参数后跟一个`/`字符来调用这些操作。我们还设置了表单操作为`?/create`。由于我们导出了命名操作，我们不能再有名为`default`的操作，必须在`form`元素上指定要调用的操作。如果我们想调用位于另一个路由的操作，我们可以通过将`formaction`设置为所需的路由名称后跟`?/`，然后是操作名称来轻松实现。
- en: You should now be confident in knowing when to use `+page.server.js` over `+page.js`,
    how to customize the rendering of pages, and how you can easily accept data from
    the `form` elements. In the next section, we’ll cover how you can create API endpoints
    that accept more than just POST requests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对何时使用`+page.server.js`而不是`+page.js`、如何自定义页面渲染以及如何轻松地从`form`元素接受数据有信心。在下一节中，我们将介绍如何创建接受不仅仅是POST请求的API端点。
- en: API Endpoints
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API端点
- en: We’ve covered the `+page.svelte`, `+page.js`, and `+page.server.js` files but
    we have yet to discuss `+server.js` files. These files enable us to accept more
    than just `POST` requests. As web application developers, we may be expected to
    support various platforms. Having an API simplifies the transmission of data between
    our server and these other platforms. Many APIs can accept GET and POST requests
    as well as PUT, PATCH, DELETE, or OPTIONS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了`+page.svelte`、`+page.js`和`+page.server.js`文件，但我们还没有讨论`+server.js`文件。这些文件使我们能够接受不仅仅是`POST`请求。作为网络应用开发者，我们可能需要支持各种平台。拥有一个API简化了我们服务器与其他平台之间数据的传输。许多API可以接受GET和POST请求，以及PUT、PATCH、DELETE或OPTIONS。
- en: 'A `+server.js` file creates an API endpoint by exporting a function with the
    name of the HTTP request method you would like for it to accept. The functions
    exported will take a SvelteKit-specific `RequestEvent` parameter and return a
    `Response` object. As an example, we can create a simple endpoint that would allow
    us to create posts for a blog. This could be useful if we used a mobile app to
    write and post from. Note that a `+server.js` file should not exist alongside
    page files as it is intended to handle all HTTP request types:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`+server.js`文件通过导出一个函数来创建一个API端点，该函数的名称是你希望它接受的HTTP请求方法。导出的函数将接受SvelteKit特定的`RequestEvent`参数，并返回一个`Response`对象。例如，我们可以创建一个简单的端点，允许我们为博客创建帖子。如果我们使用移动应用来撰写和发布，这可能很有用。请注意，`+server.js`文件不应与页面文件一起存在，因为它旨在处理所有HTTP请求类型：
- en: src/routes/api/post/+server.js
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/api/post/+server.js
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This file imports the `json` module from the `@sveltejs/kit` package, which
    is useful for sending JSON-formatted `Response` objects. We then export functions
    named for both POST and GET methods, each of which only outputs the `Request`
    object to the console and then returns a `Response` JSON. If we were so inclined,
    we could also export functions for other HTTP verbs such as PUT, PATCH, or DELETE.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件从`@sveltejs/kit`包中导入`json`模块，这对于发送JSON格式的`Response`对象很有用。然后我们导出名为POST和GET方法的函数，每个函数都只将`Request`对象输出到控制台，然后返回一个JSON格式的`Response`。如果我们愿意，我们还可以导出其他HTTP动词（如PUT、PATCH或DELETE）的函数。
- en: You should demo this example by navigating to the `api/post/` route in your
    browser. After opening the page, observe the rest of the properties available
    in the `Request` object output to your development server. If you don’t understand
    what you’re looking at, that’s okay because we’ll look into it more in the next
    chapter. Back in your browser, open the `method` property set to POST returned
    in a JSON formatted object. If your browser doesn’t allow you to edit requests,
    proxy tools such as OWASP ZAP, Burp Suite, Postman, or Telerik Fiddler will let
    you customize HTTP requests. See the resources at the end of this chapter for
    links.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该通过在浏览器中导航到`api/post/`路由来演示这个示例。打开页面后，观察输出到你的开发服务器的`Request`对象中可用的其他属性。如果你不理解你看到的内容，那没关系，因为我们在下一章中会更深入地探讨它。回到你的浏览器，打开返回的JSON格式对象中设置为POST的`method`属性。如果你的浏览器不允许你编辑请求，OWASP
    ZAP、Burp Suite、Postman或Telerik Fiddler等代理工具将允许你自定义HTTP请求。请参阅本章末尾的资源链接。
- en: Now that you know how to go about creating your very own API, let’s look at
    how you can unify the user experience of your application with a layout.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建你自己的API，让我们看看如何通过布局来统一你应用程序的用户体验。
- en: Creating Layouts
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建布局
- en: 'We''ve covered a lot so far in this chapter, but we’ve still only added styles
    and markup to each specific page. This is repetitive and not a practical use of
    our time. To reduce repetition, we can utilize layouts. A `+layout.svelte` component
    can unify the user experience by leveraging Svelte’s `<slot>` directive. The layout
    file will nest any sibling page components and child routes within itself, allowing
    us to show persistent markup across the application. Just like `+page.svelte`,
    we can include a `+layout.svelte` component at any level in our route hierarchy,
    allowing the nesting of layouts within layouts. Because each layout is also a
    Svelte component, the styles will be localized to that particular component and
    will not cascade to those nested within. Let’s look at how we might use layouts
    to create a consistent layout and navigation menu for our existing code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在本章中介绍了很多内容，但我们仍然只为每个特定页面添加了样式和标记。这是重复的，并且不是我们时间的高效利用。为了减少重复，我们可以利用布局。一个`+layout.svelte`组件可以通过利用Svelte的`<slot>`指令来统一用户体验。布局文件将任何兄弟页面组件和子路由嵌套在其中，使我们能够在整个应用程序中显示持久标记。就像`+page.svelte`一样，我们可以在我们的路由层次结构的任何级别包含`+layout.svelte`组件，允许布局嵌套在布局中。因为每个布局也是一个Svelte组件，样式将局部化到该特定组件，并且不会传播到嵌套在其内的组件。让我们看看我们如何使用布局来为现有的代码创建一个一致的布局和导航菜单：
- en: src/routes/+layout.svelte
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/+layout.svelte
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because this `+layout.svelte` component is at the root level of our routes,
    it will be applied across all child routes. The very first thing our component
    does is import our custom navigation component (shown next). Secondly, it creates
    the markup that will house the rest of our application, including this file’s
    sibling `+page.svelte`. Its markup consists of several `<div>` elements with varying
    class names indicating functionality. The `.wrapper` `<div>` element wraps all
    others so that we may apply the sticky footer styles found in the `<style>` section
    of this component. The div with the `.nav` class contains our custom `Nav` component,
    the `.content` div contains our Svelte `<slot>` directive, and `.footer` is where
    we would put our site footer information. Now let’s take a look at the custom
    `Nav` component we imported in our root layout:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此`+layout.svelte`组件位于我们路由的根级别，它将应用于所有子路由。我们的组件首先做的事情是导入我们的自定义导航组件（如下所示）。其次，它创建将容纳我们应用程序其余部分的标记，包括此文件的兄弟`+page.svelte`。其标记由几个具有不同类名的`<div>`元素组成，这些元素表示功能。具有`.wrapper`类的`<div>`元素包裹了所有其他元素，这样我们就可以应用在组件的`<style>`部分中找到的粘性页脚样式。具有`.nav`类的`<div>`包含我们的自定义`Nav`组件，`.content`
    `<div>`包含我们的Svelte `<slot>`指令，而`.footer`是我们放置网站页脚信息的地方。现在让我们看看我们在根布局中导入的自定义`Nav`组件：
- en: src/lib/Nav.svelte
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib/Nav.svelte
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This component merely contains HTML with links to all of the routes we’ve already
    created and some rudimentary styling. It consists of the `<a>` elements with the
    `href` properties set to the relative routes we’ve created up to this point. They
    are all nested within list items of an unordered list, contained within a `<nav>`
    element. Again, this example is overly simple, but for our purposes, it works.
    Now, you can add any new routes we create later on in the book to the navigation
    menu so they may be easily accessed when testing in the browser.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件仅包含HTML，其中包含指向我们已创建的所有路由的链接和一些基本的样式。它由具有`href`属性设置为相对路由的`<a>`元素组成，这些元素嵌套在一个无序列表的列表项中，该列表项位于`<nav>`元素内。再次强调，这个例子过于简单，但就我们的目的而言，它是有效的。现在，您可以将本书后面创建的任何新路由添加到导航菜单中，以便在浏览器中测试时可以轻松访问。
- en: Relative routes
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路由
- en: Notice how the routes provided are relative and are not prefaced by a domain
    name. If we were to deploy our production application to a subdirectory; rather
    than the root folder of our domain, these routes would fail. Instead, we can set
    the base path of our application in `svelte.config.js`. Specifically, we’d set
    `config.kit.paths.base` to our subdirectory path, starting with a `/`. Then in
    components and routes, we could use `import { base } from $app/paths` and preface
    all routes with `{base}/`. In this way, our application would know it exists within
    a subdirectory. Try doing it in your development project and observe how Vite
    and SvelteKit automatically serve the project from that directory!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意提供的路由是相对的，并且不以域名开头。如果我们要将我们的生产应用程序部署到子目录，而不是域名的根目录，这些路由将失败。相反，我们可以在 `svelte.config.js`
    中设置应用程序的基本路径。具体来说，我们将设置 `config.kit.paths.base` 为我们的子目录路径，以 `/` 开头。然后在组件和路由中，我们可以使用
    `import { base } from $app/paths` 并在所有路由前加上 `{base}/`。这样，我们的应用程序就会知道它存在于一个子目录中。尝试在你的开发项目中这样做，并观察
    Vite 和 SvelteKit 如何自动从这个目录中提供服务！
- en: To practice the concepts surrounding layouts further, try creating `src/routes/news/[slug]/+layout.svelte`
    to give the articles a consistent appearance. Just as we saw with the `+page.svelte`
    files, the `+layout.svelte` files can be accompanied by the `+layout.js` or `+layout.server.js`
    files. Their functionality is identical to their page counterparts, but the data
    returned from them will be available in `+layout.svelte` as well as any `+page.svelte`
    pages that exist in parallel. Page options can also be set in layout files, and
    those options will “trickle down” to nested components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步练习与布局相关的概念，尝试创建 `src/routes/news/[slug]/+layout.svelte` 以使文章具有一致的外观。就像我们看到的
    `+page.svelte` 文件一样，`+layout.svelte` 文件可以与 `+layout.js` 或 `+layout.server.js`
    文件一起使用。它们的功能与页面对应文件相同，但它们返回的数据将可用于 `+layout.svelte` 以及任何并存的 `+page.svelte` 页面。页面选项也可以在布局文件中设置，并且这些选项将“渗透”到嵌套组件中。
- en: With the information provided, you should now have the skills necessary to produce
    consistent and robust UIs for your SvelteKit applications. Layouts come in handy
    when creating all sorts of UI elements, but especially those that must remain
    consistent across various portions of the app.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的信息，你现在应该具备为你的 SvelteKit 应用程序生产一致且健壮的 UI 所需的技能。布局在创建各种 UI 元素时非常有用，尤其是那些需要在应用程序的各个部分保持一致性的元素。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to create static and dynamic routes as well
    as manage custom error templates for those routes. We also saw how developers
    can accept data submitted via the `<form>` elements with multiple named actions
    that can be called from a single form. We learned how to leverage SvelteKit’s
    routing mechanism to build out an API, which is particularly useful when an application
    needs to be accessed from platforms other than web browsers. We then unified the
    UI of our application with layouts. With those layouts, we saw how they can be
    leveraged to keep navigation elements in a predictable location across the app.
    That’s a lot of information to absorb in these few pages so we’ll take a closer
    look at some of these concepts in the next few chapters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何创建静态和动态路由以及管理这些路由的自定义错误模板。我们还看到了开发者如何通过单个表单调用多个命名操作来接受通过 `<form>`
    元素提交的数据。我们学习了如何利用 SvelteKit 的路由机制构建 API，这对于需要从除网络浏览器以外的平台访问应用程序尤其有用。然后我们通过布局统一了应用程序的
    UI。有了这些布局，我们看到了它们如何被利用来在应用程序的各个部分保持导航元素的可预测位置。在这几页中要吸收这么多信息确实很多，所以我们将在这接下来的几章中更详细地探讨一些这些概念。
- en: In the next chapter, we will learn more about managing the data we’re loading
    onto our pages. We’ll also cover more advanced methods for loading that data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于管理我们加载到页面上的数据的方法。我们还将介绍更多高级的数据加载方法。
- en: Resources
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: '**HTTP** **Proxy/Sending Tools**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP** **代理/发送工具**:'
- en: 'OWASP ZAP (Web App Penetration Testing and Proxy): [https://www.zaproxy.org/](https://www.zaproxy.org/).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OWASP ZAP (Web 应用渗透测试和代理): [https://www.zaproxy.org/](https://www.zaproxy.org/).'
- en: 'Burp Suite (Web App Penetration Testing and Proxy): [https://portswigger.net/burp](https://portswigger.net/burp).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Burp Suite (Web 应用渗透测试和代理): [https://portswigger.net/burp](https://portswigger.net/burp).'
- en: 'Postman (API Testing Tool): [https://www.postman.com/](https://www.postman.com/)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Postman (API 测试工具): [https://www.postman.com/](https://www.postman.com/)'
- en: 'Telerik Fiddler (Web Debugging and Proxy Tool): [https://www.telerik.com/fiddler](https://www.telerik.com/fiddler).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Telerik Fiddler (Web 调试和代理工具): [https://www.telerik.com/fiddler](https://www.telerik.com/fiddler).'
