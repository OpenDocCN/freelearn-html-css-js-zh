["```js\nfunction isIndexPage() { \n   return window.location.pathname === \"/\"; \n }\n```", "```js\nfunction isIndexPage(pathname: string) { \n   return pathname === \"/\"; \n }\n```", "```js\nfunction shouldReturnTrueWhenPathIsIndex(){ \n    let expected = true; \n    let result = isIndexPage(\"/\"); \n    if (expected !== result) { \n        throw new Error(`Expected ${expected} to equals ${result}`); \n    } \n} \n\nfunction shouldReturnFalseWhenPathIsNotIndex() { \n    let expected = false; \n    let result = isIndexPage(\"/someotherpage\"); \n    if (expected !== result) { \n        throw new Error(`Expected ${expected} to equals ${result}`); \n    } \n} \n```", "```js\nconst log = function(arg: any) { console.log(arg); }; \n```", "```js\nconst log = (arg: any) => console.log(arg); \n```", "```js\nfunction isNull<T>(a: T|null) { \n    return (a === null); \n} \n```", "```js\nfunction add(a: number, b: number) { \n    return a + b; \n} \n```", "```js\nfunction addMany(...numbers: number[]) { \n    numbers.reduce((p, c) => p + c, 0); \n} \n```", "```js\nfunction addDelay(msg: string, ms: number) { \n    return () => { \n        setTimeout(() => { \n            console.log(msg); \n        }, ms); \n    }; \n} \n\nconst delayedSayHello = addDelay(\"Hello world!\", 500); \ndelayedSayHello(); // Prints \"Hello world!\" (after 500 ms) \n```", "```js\nfunction addDelay(func: () => void, ms: number) {\n    setTimeout(() => { \n        func(); \n    }, ms); \n} \n\nfunction sayHello() { \n    console.log(\"Hello world!\"); \n} \n\naddDelay(sayHello, 500); // Prints \"Hello world!\" (after 500 ms) \n```", "```js\nfunction addDelay(func: () => void, ms: number) {\n    return () => { \n        setTimeout(() => { \n            func(); \n        }, ms); \n    }; \n} \n\nfunction sayHello() { \n    console.log(\"Hello world!\"); \n} \n\nconst delayedSayHello = addDelay(sayHello, 500); \ndelayedSayHello(); // Prints \"Hello world!\" (after 500 ms) \n```", "```js\nconst trim = (s: string) => s.trim();\nconst capitalize = (s: string) => s.toUpperCase(); \n```", "```js\n    const trimAndCapitalize = (s: string) => capitalize(trim(s));\n```", "```js\ntrimAndCapitalize(\"   hello world   \"); // \"HELLO WORLD\" \n```", "```js\n    const compose = <T>(f: (x: T) => T, g: (x: T) => T) => (x: T) => f(g(x));\n```", "```js\n    const trimAndCapitalize = compose(trim, capitalize);\n```", "```js\ntrimAndCapitalize(\"   hello world   \"); // \"HELLO WORLD\" \n```", "```js\nconst compose = <T1, T2, T3>(\n    f: (x: T2) => T3, \n    g: (x: T1) => T2 \n) => (x: T1) => f(g(x)); \n```", "```js\nconst composed1 = compose(func1, func2); \nconst composed2 = compose(func1, func2); \nconst composed3 = compose(composed1, composed2); \n```", "```js\nconst compose3 = <T1, T2, T3, T4>( \n    f: (x: T3) => T4, \n    g: (x: T2) => T3, \n    h: (x: T1) => T2 \n) => (x: T1) => f(g(h(x))); \n```", "```js\nconst compose = (...functions: Array<(arg: any) => any>) =>\n    (arg: any) => \n        functions.reduce((prev, curr) => { \n            return curr(prev); \n        }, arg); \n```", "```js\nfunction add(a: number, b: number) { \n    return a + b; \n} \n\nconst result = add(5, 5); // All arguments are provided at the same time \nconsole.log(result); // 10 \n```", "```js\nfunction add(a: number) {\n    return (b: number) => { \n        return a + b; \n    }; \n} \n\nconst add5 = add(5); // The 1st argument is provided \nconst result = add5(5); // The 2nd argument is provided later \nconsole.log(result); // 10 \n```", "```js\nfunction add(a: number, b?: number) {\n    if (b !== undefined) { \n        return a + b; \n    } else { \n        return (b2: number) => { \n            return a + b2; \n        }; \n    } \n} \n\nconst result1 = add(5, 5); // All arguments are  \nconsole.log(result1); // 10 \n\nconst add5 = add(5) as (b: number) => number; // The 1st passed \nconst result2 = add5(5); // The 2nd argument is passed later \nconsole.log(result2); // 10 \n```", "```js\nconst trim = (s: string) => s.trim();\nconst capitalize = (s: string) => s.toUpperCase(); \nconst trimAndCapitalize = compose(trim, capitalize);\n```", "```js\nconst replace = (s: string, f: string, r: string) => s.split(f).join(r); \n```", "```js\nconst trimCapitalizeAndReplace = compose(trimAndCapitalize, replace); // Error \n```", "```js\nconst replace = (f: string, r: string) =>\n(s: string) => \ns.split(f).join(r);  \n```", "```js\nconst trimCapitalizeAndReplace = compose( \n    trimAndCapitalize, \n    replace(\"/\", \"-\") \n); \ntrimCapitalizeAndReplace(\" 13/feb/1989 \"); <// \"13-FEB-1989\" \n```", "```js\nfunction curry2<T1, T2, T3>(fn: (a: T1, b: T2) => T3) {\n    return (a: T1) => (b: T2) => fn(a, b); \n} \n```", "```js\nfunction add(a: number, b: number) { \n    return a + b; \n} \n\nconst curriedAdd = curry2(add); \nconst add5 = curriedAdd(5); \nconst addResult = add5(5); \nconsole.log(addResult); // 10 \n```", "```js\nfunction multiply(a: number, b: number) {\n    return a * b; \n} \n\nconst curriedMultiply = curry2(multiply);\nconst multiplyBy5 = curriedMultiply(5); \nconst multiplyResult = multiplyBy5(5); \nconsole.log(multiplyResult); // 25 \n```", "```js\nconst replace = (f: string, r: string) => \n    (s: string) => \n        s.split(f).join(r); \n\nconst trimCapitalizeAndReplace = compose( \n    trimAndCapitalize, \n    replace(\"/\", \"-\") \n); \n```", "```js\nfunction curry3<T1, T2, T3, T4>(fn: (a: T1, b: T2, c: T3) => T4) { \n    return (a: T1) => (b: T2) => (c: T3) => fn(a, b, c); \n} \n```", "```js\nconst replace = (s: string, f: string, r: string) => \n    s.split(f).join(r); \n\nconst curriedReplace = curry3(replace);\n\nconst trimCapitalizeAndReplace = compose( \n    trimAndCapitalize, \n    curriedReplace(\"/\")(\"-\") \n); \n```", "```js\nconst pipe = <T>(...fns: Array<(arg: T) => T>) =>\n    (value: T) => fns.reduce((acc, fn) => fn(acc), value); \n```", "```js\nconst trim = (s: string) => s.trim(); \nconst capitalize = (s: string) => s.toUpperCase(); \n\nconst replace = curry3( \n    (s: string, f: string, r: string) => s.split(f).join(r) \n); \n```", "```js\nconst trimCapitalizeAndReplace = pipe( \n    trim, \n    capitalize, \n    replace(\"/\")(\"-\") \n); \ntrimCapitalizeAndReplace(\"   13/feb/1989   \"); // \"13-FEB-1989\" \n```", "```js\nconst result = \"   13/feb/1989   \" \n  |> trim \n  |> capitalize \n  |> replace(\"/\")(\"-\"); \n```", "```js\ninterface Person { \n    age: number; \n    birthCountry: string; \n    naturalizationDate: Date; \n} \n\nconst OUR_COUNTRY = \"Ireland\"; \n\nconst wasBornInCountry = (person: Person) => \n    person.birthCountry === OUR_COUNTRY; \n\nconst wasNaturalized = (person: Person) => \n    Boolean(person.naturalizationDate); \n\nconst isOver18 = (person: Person) => \n    person.age >= 18; \n\nconst isCitizen = (person: Person) => \n    wasBornInCountry(person) || wasNaturalized(person); \n\nconst isEligibleToVote = (person: Person) => \n    isOver18(person) && isCitizen(person); \n\nisEligibleToVote({ \n    age: 27, \n    birthCountry: \"Ireland\", \n    naturalizationDate: new Date(), \n}); \n```", "```js\nconst either = <T1>(\n    funcA: (a: T1) => boolean, \n    funcB: (a: T1) => boolean \n) => (arg: T1) => funcA(arg) || funcB(arg); \n\nconst both = <T1>( \n    funcA: (a: T1) => boolean, \n    funcB: (a: T1) => boolean \n) => (arg: T1) => funcA(arg) && funcB(arg); \n\ninterface Person { \n    age: number; \n    birthCountry: string; \n    naturalizationDate: Date; \n} \n\nconst OUR_COUNTRY = \"Ireland\";\n\nconst wasBornInCountry = (person: Person) => \n    person.birthCountry === OUR_COUNTRY; \n\nconst wasNaturalized = (person: Person) => \n    Boolean(person.naturalizationDate); \n\nconst isOver18 = (person: Person) => \n    person.age >= 18; \n\n// Pointfree style \nconst isCitizen = either(wasBornInCountry, wasNaturalized); \nconst isEligibleToVote = both(isOver18, isCitizen); \n\nisEligibleToVote({ \n    age: 27, \n    birthCountry: \"Ireland\", \n    naturalizationDate: new Date(), \n}); \n```", "```js\nconst isCitizen = (person: Person) => \n    wasBornInCountry(person) || wasNaturalized(person); \n```", "```js\nconst isEligibleToVote = both(isOver18, isCitizen); \n```", "```js\nconst factorial = (n: number): number => \n(n === 0) ? 1 : (n * factorial(n - 1)); \n```", "```js\nfactorial(5); // 120 \n```", "```js\nclass Container<T> { \n    private _value: T; \n    public constructor(val: T) { \n        this._value = val; \n    } \n    public map<TMap>(fn: (val: T) => TMap) { \n        return new Container<TMap>(fn(this._value)); \n    } \n} \n```", "```js\nlet double = (x: number) => x + x;\nlet container = new Container(3); \nlet container2 = container.map(double); \nconsole.log(container2); // { _value: 6 } \n```", "```js\nclass Container<T> {\n    public static of<TVal>(val: TVal) { \n        return new Container(val); \n    } \n    private _value!: T; \n    public constructor(val: T) { \n        this._value = val; \n    } \n    public map<TMap>(fn: (val: T) => TMap) { \n        return new Container<TMap>(fn(this._value)); \n    } \n} \n```", "```js\nlet double = (x: number) => x + x; \nlet container = Container.of(3); \nlet container2 = container.map(double); \nconsole.log(container2); // { _value: 6 } \n```", "```js\nclass MayBe<T> { \n    public static of<TVal>(val?: TVal) { \n        return new MayBe(val); \n    } \n    private _value!: T; \n    public constructor(val?: T) { \n        if (val) { \n            this._value = val; \n        } \n    } \n    public isNothing() { \n        return (this._value === null || this._value === undefined); \n    } \n    public map<TMap>(fn: (val: T) => TMap) { \n        if (this.isNothing()) { \n            return new MayBe<TMap>(); \n        } else { \n            return new MayBe<TMap>(fn(this._value)); \n        } \n    } \n} \n```", "```js\ninterface New {\n    subreddit: string; \n    id: string; \n    title: string; \n    score: number; \n    over_18: boolean; \n    url: string; \n    author: string; \n    ups: number; \n    num_comments: number; \n    created_utc: number; \n} \n\ninterface Response { \n    kind: string; \n    data: { \n        modhash: string; \n        whitelist_status: boolean|null; \n        children: Array<{ kind: string, data: New }>; \n        after: string|null; \n        before: string|null; \n    }; \n} \n\nasync function fetchNews() { \n    return new Promise<MayBe<Response>>((resolve, reject) => { \n        const url = \"https://www.reddit.com/r/typescript/new.json\"; \n        fetch(url) \n            .then((response) => { \n                return response.json(); \n            }).then((json) => { \n                resolve(new MayBe(json)); \n            }).catch(() => { \n                resolve(new MayBe()); \n            }); \n    }); \n} \n```", "```js\n(async () => {\n\n    const maybeOfResponse = await fetchNews(); \n\n    const maybeOfNews = maybeOfResponse \n        .map(r => r.data) \n        .map(d => d.children) \n        .map(children => children.map(c => c.data)); \n\n    maybeOfNews.map((news) => { \n        news.forEach((n) => console.log(`${n.title} - ${n.url}`)); \n        return news; \n    }); \n\n})(); \n```", "```js\n    type Either<T1, T2> = Just<T1> | Nothing<T2>;\n```", "```js\nclass Nothing<T> { \n    public static of<TVal>(val?: TVal) { \n        return new Nothing(val); \n    } \n    private _value: T|undefined; \n    public constructor(val?: T) { \n        this._value = val; \n    } \n    public map<TMap>(fn: (val: T) => TMap) { \n        if (this._value !== undefined) { \n            return new Nothing<TMap>(fn(this._value)); \n        } else { \n            return new Nothing<TMap>(this._value as any); \n        } \n    } \n} \n```", "```js\nclass Just<T> { \n    public static of<TVal>(val: TVal) { \n        return new Just(val); \n    } \n    private _value: T; \n    public constructor(val: T) { \n        this._value = val; \n    } \n    public map<TMap>(fn: (val: T) => TMap) { \n        return new Just<TMap>(fn(this._value)); \n    } \n} \n```", "```js\ninterface New {\n    subreddit: string; \n    id: string; \n    title: string; \n    score: number; \n    over_18: boolean; \n    url: string; \n    author: string; \n    ups: number; \n    num_comments: number; \n    created_utc: number; \n} \n\ninterface Response { \n    kind: string; \n    data: { \n        modhash: string; \n        whitelist_status: boolean|null; \n        children: Array<{ kind: string, data: New }>; \n        after: string|null; \n        before: string|null; \n    }; \n} \n\nasync function fetchNews() { \n    return new Promise<Either<Response, Error>>((resolve, reject) => { \n        const url = \"https://www.reddit.com/r/typescript/new.json\"; \n        fetch(url) \n            .then((response) => { \n                return response.json(); \n            }).then((json) => { \n                resolve(new Just(json)); \n            }).catch((e) => { \n                resolve(new Nothing(e)); \n            }); \n    }); \n} \n```", "```js\n(async () => {\n\n    const maybeOfResponse = await fetchNews(); \n\n    maybeOfResponse.map(r => r.message) \n    // Error: \n    // Cannot invoke an expression whose type lacks a call signature. \n    // Type \n    // (<TMap>(fn: (val: Response) => TMap) => Just<TMap>) | \n    // (<TMap>(fn: (val: Error) => TMap) => Nothin<TMap>' \n    // has no compatible call signatures. \n\n})(); \n```", "```js\n(async () => { \n\n    const maybeOfResponse = await fetchNews(); \n\n    if (maybeOfResponse instanceof Nothing) { \n\n        maybeOfResponse \n            .map(r => r.message) \n            .map(msg => { \n                console.log(`Error: ${msg}`); \n                return msg; \n            }); \n\n    } else { \n\n        const maybeOfNews = maybeOfResponse.map(r => r.data) \n            .map(d => d.children) \n            .map(children => children.map(c => c.data)); \n\n        maybeOfNews.map((news) => { \n            news.forEach((n) => console.log(`${n.title} - ${n.url}`)); \n            return news; \n        }); \n    } \n\n})(); \n```", "```js\nclass MayBe<T> { \n    public static of<TVal>(val?: TVal) { \n        return new MayBe(val); \n    } \n    private _value!: T; \n    public constructor(val?: T) { \n        if (val) { \n            this._value = val; \n        } \n    } \n    public isNothing() { \n        return (this._value === null || this._value === undefined); \n    } \n    public map<TMap>(fn: (val: T) => TMap) { \n        if (this.isNothing()) { \n            return new MayBe<TMap>(); \n        } else { \n            return new MayBe<TMap>(fn(this._value)); \n        } \n    } \n    public join() { \n        return this.isNothing() ? Nothing.of(this._value) : this._value; \n    } \n    public chain<TMap>(fn: (val: T) => TMap) { \n        return this.map(fn).join(); \n    } \n} \n```", "```js\nlet maybeOfNumber = MayBe.of(5); \n\nmaybeOfNumber.map((a) => a * 2); \n// MayBe { value: 10 } \n\nmaybeOfNumber.join(); \n// 5 \n\nmaybeOfNumber.chain((a) => a * 2); \n// 10 \n\nlet maybeOfMaybeOfNumber = MayBe.of(MayBe.of(5)); \n// MayBe { value: MayBe { value: 5 } } \n\nmaybeOfMaybeOfNumber.map((a) => a.map(v => v * 2)); \n// MayBe { value: MayBe { value: 10 } } \n\nmaybeOfMaybeOfNumber.join(); \n// MayBe { value: 5 } \n\nmaybeOfMaybeOfNumber.chain((a) => a.map(v => v * 2)); \n// MayBe { value: 10 } \n```", "```js\nfunction sort(arr: number[]) { \n    return arr.sort((a, b) => b - a); \n} \n```", "```js\nnpm install --save immutable \n```", "```js\nImport * as immutable from \"immutable\";\n\nconst map1 = immutable.Map({ a: 1, b: 2, c: 3 }); \nconst map2 = map1.set(\"b\", 50); \nconsole.log(`${map1.get(\"b\")} vs.${map2.get(\"b\")}`); \n// 2 vs. 50 \n\nconst nested = immutable.fromJS({ a: { b: { c: [ 3, 4, 5 ] } } }); \n\nconst nested2 = nested.mergeDeep({ a: { b: { d: 6 } } }); \n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } } \n\nconsole.log(nested2.getIn([ \"a\", \"b\", \"d\" ])); \n// 6 \n\nconst nested3 = nested2.updateIn( \n    [ \"a\", \"b\", \"d\" ], \n    (value: string) => value + 1 \n); \n\nconsole.log(nested3); \n// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } } \n\nconst nested4 = nested3.updateIn( \n    [ \"a\", \"b\", \"c\" ], \n    (list: number[]) => list.push(6) \n); \n\nconsole.log(nested4); \n// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } } \n```", "```js\nnpm install --save ramda \nnpm install --save-dev @types/ramda \n```", "```js\nimport * as R from \"ramda\";const trim = (s: string) => s.trim();\nconst capitalize = (s: string) => s.toUpperCase(); \nconst trimAndCapitalize = R.compose(trim, capitalize); \n\nconst replace = (s: string, f: string, r: string) => \n    s.split(f).join(r); \n\nconst curriedReplace = R.curry(replace); \nconst trimCapitalizeAndReplace = R.compose( \n    trimAndCapitalize, \n    curriedReplace(\"/\")(\"-\") \n); \n\ntrimAndCapitalizeReplace(\"   13/feb/1989   \"); // \"13-FEB-1989\" \n```"]