- en: Chapter 3. Twitter as a Flight Information Agent
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：Twitter作为航班信息代理
- en: '**Twitter** is an online social networking service that enables users to send
    and read short 140 character messages called *tweets*, and has become one of the
    most prominent ways for people to exchange news and information all over the world.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Twitter**是一个在线社交网络服务，允许用户发送和阅读称为*tweets*的短140字符消息，并已成为人们在全球范围内交换新闻和信息最显著的方式之一。'
- en: Twitter's popularity has exploded since its creation, and now it is used for
    all sorts of things, such as customer service, marketing, news coverage, and many
    others. It is one of the most popular websites that exist, and it is considered
    to be the *SMS gateway* of the Internet.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Twitter创建以来，其受欢迎程度已经爆炸式增长，现在它被用于各种事情，如客户服务、营销、新闻报道等。它是现存最受欢迎的网站之一，被认为是互联网的*短信网关*。
- en: One of Twitter's main uses is for companies to communicate information to their
    followers. For example, airlines usually tweet about events that are related to
    the company, as well as those that could affect passengers or their plans.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter的主要用途之一是公司向其关注者传达信息。例如，航空公司通常会发布与公司相关的事件，以及可能影响乘客或其计划的事件。
- en: In this chapter, we'll focus our attention on creating a Twitter bot that is
    able to provide flight information to passengers, acting like an automated flight
    information agent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于创建一个能够为乘客提供航班信息的Twitter机器人，它将充当自动化的航班信息代理。
- en: The examples should be a lot of fun, as well as easy to follow, so let's not
    wait any longer and get started!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例应该非常有趣，同时也容易跟随，所以我们不再等待，开始吧！
- en: How a Twitter bot works
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter机器人的工作原理
- en: Just like any other bot, a Twitter bot is, in essence, just another Twitter
    user account-the difference is that, instead of being manned by another person,
    the account is controlled by an automated process that knows how to reply to the
    input you provide. This is possible because Twitter provides an API that allows
    you to interact programmatically with the service through code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他机器人一样，Twitter机器人在本质上只是另一个Twitter用户账户——区别在于，它不是由另一个人操作，而是由一个知道如何回复您提供的输入的自动化过程控制。这是因为Twitter提供了一个API，允许您通过代码以编程方式与服务进行交互。
- en: In essence, anything that can be turned into a service could be converted into
    an automated conversation by using a bot, and Twitter is no different. Bots can
    have interactive conversations on nearly every platform, at any time, and from
    anywhere.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，任何可以转化为服务的东西都可以通过使用机器人转化为自动对话，Twitter也不例外。机器人几乎可以在任何平台上进行交互式对话，在任何时间，从任何地方。
- en: A Twitter bot is typically an application that you write that listens for something
    to happen on Twitter and then does something in response. In our case, we'll be
    listening for someone to tweet with a certain hashtag and then tweeting something
    when that happens. That hashtag will be a flight number, and the bot will be able
    to provide some feedback based on it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter机器人通常是一个您编写的应用程序，它会监听Twitter上发生的事情，然后做出响应。在我们的案例中，我们将监听有人使用特定标签发推文，然后当这种情况发生时发推文。这个标签将是航班号，机器人将能够根据它提供一些反馈。
- en: So, let's get our feet on the ground and get started in building our Twitter
    bot.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们脚踏实地，开始构建我们的Twitter机器人。
- en: Creating a Twitter app
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Twitter应用程序
- en: The first and foremost step in creating a Twitter bot is to actually create
    a Twitter application. The bot is just a designation we'll be using, but in reality
    it's really a Twitter application behind the scenes that is able to interact with
    the Twitter API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Twitter机器人的首要步骤是实际上创建一个Twitter应用程序。机器人只是一个我们将使用的名称，但实际上它是一个后台的Twitter应用程序，能够与Twitter
    API进行交互。
- en: In order to be able to interact with the Twitter API, it is necessary to have
    a registered Twitter account. Go to the Twitter web page and sign up if you don't
    have an account. If you have one, sign in.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够与Twitter API进行交互，必须拥有一个注册的Twitter账户。如果您还没有账户，请访问Twitter网页并注册。如果您已经有了账户，请登录。
- en: Once you are signed in, navigate to [https://apps.twitter.com/](https://apps.twitter.com/)
    . This is where we will register our Twitter application. You'll then see the
    Twitter **Application Management** welcome page which has a button to create a
    new application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，导航到[https://apps.twitter.com/](https://apps.twitter.com/)。这是我们注册Twitter应用程序的地方。您将看到Twitter**应用程序管理**欢迎页面，上面有一个创建新应用程序的按钮。
- en: 'To create the Twitter bot, click on the **Create New App** button. Refer to
    the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Twitter 机器人，请点击**创建新应用**按钮。参考以下截图：
- en: '![ Creating a Twitter app](img/image00213.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00213.jpeg)'
- en: 'Having done that, the following screen will appear:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述操作后，以下屏幕将出现：
- en: '![ Creating a Twitter app](img/image00214.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00214.jpeg)'
- en: 'Fill in the required information. Give the application a distinctive name and
    a description. You are also required to enter a website that will be used as the
    bot''s publicly accessible home page. Once you have entered this data, scroll
    down and accept the Twitter **Developer Agreement**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 填写所需信息。为应用程序起一个独特的名字和描述。你还需要输入一个将用作机器人公开可访问主页的网站。一旦输入了这些数据，向下滚动并接受 Twitter **开发者协议**：
- en: '![ Creating a Twitter app](img/image00215.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00215.jpeg)'
- en: 'Once you''ve read the developer agreement, you can click on the **Create your
    Twitter application** in order to proceed. This will allow Twitter to create your
    application, and you''ll be presented with the following screen once the creation
    process has finalized:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 读取开发者协议后，你可以点击**创建你的 Twitter 应用**以继续。这将允许 Twitter 创建你的应用程序，一旦创建过程完成，你将看到以下屏幕：
- en: '![ Creating a Twitter app](img/image00216.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00216.jpeg)'
- en: If you scroll a bit, there are also application settings provided that will
    be needed as soon as we start coding. With the Twitter app created, let's focus
    on writing some code. So far throughout this book we've been using the Atom editor;
    however, you are free to use any other editor that you might be comfortable with.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动一点，还有提供了一些应用程序设置，一旦我们开始编码就需要使用。Twitter 应用创建后，让我们专注于编写一些代码。到目前为止，我们一直在使用
    Atom 编辑器；然而，你可以自由使用任何你可能更熟悉的编辑器。
- en: 'Open the editor and create a new `app.js` file inside a `FlightBot` folder
    anywhere on your drive. For now, simply add this instruction:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开编辑器，在你的驱动器上的任何位置创建一个名为 `FlightBot` 的文件夹内的新 `app.js` 文件。现在，只需添加以下指令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assuming we have Node.js and npm installed (if not, please refer to the steps
    in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. The Rise of Bots – Getting
    the Message Across"), *The Rise of Bots – Getting the Message Across*), let's
    get some necessary dependencies installed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经安装了 Node.js 和 npm（如果没有，请参阅第 1 章[第 1. 机器人的崛起 – 传递信息]中的步骤），让我们安装一些必要的依赖项。
- en: 'Now let''s copy the `package.json` (that we used in the previous chapter) and
    place it in the `FlightBot` folder. Then let''s modify it as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们复制上一章中使用的 `package.json` 并将其放置在 `FlightBot` 文件夹中。然后让我们按以下方式修改它：
- en: '![ Creating a Twitter app](img/image00217.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00217.jpeg)'
- en: 'Now let''s get the dependencies installed, so we can start coding within the
    `app.js` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装必要的依赖项，以便我们可以在 `app.js` 文件中开始编码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will install the Twitter Node.js SDK, which we will be using to write
    our app. This will be installed on the `FlightBot` folder as shown in the following
    screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Twitter Node.js SDK，我们将使用它来编写我们的应用程序。这将安装在与以下截图所示的 `FlightBot` 文件夹中：
- en: '![ Creating a Twitter app](img/image00218.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00218.jpeg)'
- en: 'You''ll see the updated `package.json` file in your project folder:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在你的项目文件夹中看到更新的 `package.json` 文件：
- en: '![ Creating a Twitter app](img/image00219.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00219.jpeg)'
- en: 'We are now ready to start adding some code in our `app.js` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好在我们的 `app.js` 文件中添加一些代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What we''ve done here is to load and import the Twitter package. First, let''s
    get these consumer keys and tokens from the Twitter **Application Management**
    screen:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是加载并导入 Twitter 包。首先，让我们从 Twitter **应用管理**屏幕获取这些消费者密钥和令牌：
- en: '![ Creating a Twitter app](img/image00220.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00220.jpeg)'
- en: Note how the **Consumer Key** and **Consumer Secret** are available by default,
    but not the **Your Access Tokens**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意默认情况下**消费者密钥**和**消费者密钥**是可用的，但**你的访问令牌**不可用。
- en: 'In order to get the **Your Access Tokens**, click on the **Create my access
    token** button at the bottom of the screen. Once you''ve done that, you''ll see
    the following screen:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取**你的访问令牌**，点击屏幕底部的**创建我的访问令牌**按钮。一旦完成，你将看到以下屏幕：
- en: '![ Creating a Twitter app](img/image00221.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Twitter 应用](img/image00221.jpeg)'
- en: With this done, you can now add the consumer and access tokens to the secret
    object variable in the code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，你现在可以将消费者和访问令牌添加到代码中的秘密对象变量中。
- en: 'We can do this by defining an object variable that will contain the consumer
    key and secret object, along with the access tokens, as shown in the following
    code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个包含消费者密钥和密钥对象以及访问令牌的对象变量来完成这项工作，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Later, we'll store these in a separate `.json` file, but for now let's keep
    them within our `app.js` file. These will be required in order to authenticate
    to Twitter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将它们存储在单独的`.json`文件中，但现在是让我们将它们保持在`app.js`文件中。这些将用于验证Twitter。
- en: So at this point, we've pretty much created the app on Twitter and have a very
    basic structure with tokens and access codes that we can use to authenticate to
    the Twitter service and start using the API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们已经在Twitter上基本创建了这个应用，并有一个非常基本的带有令牌和访问代码的结构，我们可以使用这些代码来验证Twitter服务并开始使用API。
- en: With this out of the way, let's move on and start adding some logic to our application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们继续添加一些逻辑到我们的应用中。
- en: Posting to Twitter
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布到Twitter
- en: In order to add our own custom logic, we'll need to make use of Twitter's `REST`
    API, which will allow us to do several things. One of the things it can do is
    allow us to post a tweet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加我们自己的自定义逻辑，我们需要使用Twitter的`REST` API，这将允许我们做很多事情。它可以做的事情之一是允许我们发布一条推文。
- en: 'This can be achieved as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式实现：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So let's take a moment to examine this. `Twitter.post` means that we are calling
    the `post` function in the Twitter object. We pass the `post` function several
    things-`'statuses/update'` means we want to post a status update (a tweet).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来检查这个。`Twitter.post`意味着我们正在调用Twitter对象中的`post`函数。我们向`post`函数传递了几件事情 -
    `'statuses/update'`意味着我们想要发布一个状态更新（一条推文）。
- en: '`{status: ''This is a sample automated Tweet''}` is a JavaScript object that
    we are passing in to this function where we set the status of the tweet being
    sent out.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`{status: ''这是一条示例自动推文''}`是我们传递给这个函数的JavaScript对象，我们在这个对象中设置了要发送的推文的状态。'
- en: Although this contains just the text of the tweet we want to send, there are
    a whole bunch of other options to set depending on what we want to post to Twitter
    (such as images, location, and so on). In this case, we are just interested in
    posting a simple status just so we are familiar with setting the status property.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这仅仅包含了我们想要发送的推文文本，但还有许多其他选项可以设置，具体取决于我们想要发布到Twitter的内容（例如图片、位置等）。在这种情况下，我们只是对设置状态属性有所了解。
- en: The last thing we pass in is a function. In JavaScript, you can actually pass
    functions in to other functions; it is one of the things that makes JavaScript
    a functional programming language.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们传递一个函数。在JavaScript中，你实际上可以将函数传递给其他函数；这是JavaScript作为函数式编程语言的特点之一。
- en: 'In the `Twitter.post` function, you''re expected to pass a function in that
    will be executed after Twitter tries to post the tweet. This is what is known
    as a callback function. In that function, you''ll notice three parameters:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Twitter.post`函数中，你被期望传递一个函数，该函数将在Twitter尝试发布推文后被执行。这被称为回调函数。在这个函数中，你会注意到三个参数：
- en: '`error`: This indicates whether there''s an error in the process of posting
    the tweet, in which case this variable will contain an object with information
    about the error that occurred'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：这表示在发布推文的过程中是否有错误，如果有，这个变量将包含有关发生错误的信息的对象'
- en: '`tweet`: An object that contains all the tweet data'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tweet`：一个包含所有推文数据的对象'
- en: '`response`: An object of the actual response Twitter sends back when you post
    a tweet'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`：Twitter在发布推文时发送的实际响应的对象'
- en: In our code, we'll just post our tweet and then print it out in the console.
    Now go ahead and remove the `'Hi, this is FlightBot'` line. We don't need it any
    longer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们只需发布我们的推文，然后在控制台打印出来。现在，请删除`'Hi, this is FlightBot'`这一行。我们不再需要它了。
- en: 'Now, save the modified `app.js` file. It should look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存修改后的`app.js`文件。它应该看起来像这样：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s go and run the app:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们去运行这个应用：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will produce the following result on the command line console:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行控制台产生以下结果：
- en: '![Posting to Twitter](img/image00222.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![发布到Twitter](img/image00222.jpeg)'
- en: 'If we then inspect Twitter itself, we can see the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查Twitter本身，我们可以看到以下内容：
- en: '![Posting to Twitter](img/image00223.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![发布到Twitter](img/image00223.jpeg)'
- en: Really cool! We now have a way to send automatic tweets. However, we don't have
    a full blown bot yet. Let's explore how we can achieve that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很酷！我们现在有了一种发送自动推文的方法。然而，我们还没有一个完整的机器人。让我们探索如何实现这一点。
- en: Listening to tweets
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听推文
- en: In order to create a functional Twitter bot, it is not enough to be able to
    simply post something to Twitter. We also need to be able to listen to what gets
    posted on Twitter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个功能齐全的 Twitter 机器人，仅仅能够向 Twitter 发布内容是不够的。我们还需要能够监听 Twitter 上发布的内容。
- en: Twitter has a very useful API called `Streaming` which gives us information
    about tweets in real time. In other words, when someone tweets something that
    we care about, we get all the data about that tweet. This is both really useful
    and really awesome.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter 有一个非常有用的 API，称为 `Streaming`，它为我们提供了关于推文的实时信息。换句话说，当有人发布我们关心的内容时，我们就会得到关于那条推文的全部数据。这既非常实用，又非常酷。
- en: 'So let''s re-implement a bit of our code as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们重新实现一部分代码，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s analyze this. The `Twitter.stream` function takes in three parameters:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下。`Twitter.stream` 函数接受三个参数：
- en: The first parameter is a string that tells Twitter that we want to listen for
    statuses with a certain filter. In this case, we are filtering by using a hashtag.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个字符串，告诉 Twitter 我们想监听具有特定过滤器的状态。在这种情况下，我们正在使用标签进行过滤。
- en: The second parameter is where we define that filter with an object. That object
    contains the property `track` which lets us define a word, hashtag, or phrase
    that we care to listen for. For this, we will be tracking when someone tweets
    with the hashtag `'#FlightBot'`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是我们定义过滤器的位置。该对象包含一个名为 `track` 的属性，它允许我们定义我们想要监听的一个单词、标签或短语。为此，我们将跟踪有人使用
    `'#FlightBot'` 标签发推文的情况。
- en: The last parameter is a function that gets called when Twitter is done setting
    up our stream. When it's done setting up our stream, it then passes that stream
    object in to the function. Within this function, we can set up what happens when
    we receive a tweet, along with other things, such as error handling, and so on.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数是一个函数，当 Twitter 完成设置我们的流时被调用。当它完成设置流后，它将流对象传递给该函数。在这个函数中，我们可以设置当我们收到推文时会发生什么，以及其他事情，例如错误处理等。
- en: 'Now let''s take a closer look at what happens when we receive data:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看看当我们接收数据时会发生什么：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, using the `stream` object, it calls the `on` function. Now, with the `on`
    function, you pass in a string and a function. This means that when a tweet occurs,
    we call this function with that data. At the moment, we just print out `tweet.text`,
    which is how you access the actual text of the tweet that was received that used
    the hashtag `'#FlightBot'`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `stream` 对象，它调用 `on` 函数。现在，使用 `on` 函数，你传递一个字符串和一个函数。这意味着当发生推文时，我们用这些数据调用这个函数。目前，我们只是打印出
    `tweet.text`，这是访问接收到的使用 `'#FlightBot'` 标签的推文实际文本的方式。
- en: Let's now go ahead and comment the `Twitter.post` code so we don't post the
    same tweet twice. Then, if we save the `app.js` file and then call `node app.js`
    in the command line, you'll notice that the command line no longer shows you a
    prompt.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来注释掉 `Twitter.post` 代码，这样我们就不会两次发布相同的推文。然后，如果我们保存 `app.js` 文件，并在命令行中调用 `node
    app.js`，您会注意到命令行不再显示提示符。
- en: This is because it's running and listening for some sort of data to come in
    from that stream. If you need to stop it, press ***Ctrl*** + ***C*** a few times
    to return to the prompt.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它在运行并监听从该流中传入的一些数据。如果您需要停止它，请多次按下 ***Ctrl*** + ***C*** 返回到提示符。
- en: 'In order to test this, go to Twitter and tweet something with `''#FlightBot''`,
    as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，请转到 Twitter 并发布一条带有 `'#FlightBot'` 的推文，如下面的截图所示：
- en: '![Listening to tweets](img/image00224.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![监听推文](img/image00224.jpeg)'
- en: 'Now check your running command line. You should see the text of your tweet
    printed out:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查您的运行命令行。您应该看到打印出您的推文文本：
- en: '![Listening to tweets](img/image00225.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![监听推文](img/image00225.jpeg)'
- en: Awesome! We've now implemented a mechanism that can listen to tweets.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在实现了一个可以监听推文的机制。
- en: 'The update `app.js` code now looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的 `app.js` 代码现在看起来是这样的：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Replying to who tweeted
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回复谁发的推文
- en: So far, we've managed to write some code that posts a tweet and we've also written
    code that acts on tweets that have been written. So what's next?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了一些代码来发布推文，我们也编写了处理已发布推文的代码。那么接下来是什么？
- en: The next thing to do is to basically combine both parts together into a single
    code base, as this will be the basic layer of our bot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要做的事情是将这两部分基本合并成一个单一的代码库，因为这将是我们机器人的基本层。
- en: One of the things you might want to do is to give the bot the ability to reply
    to the person who tweeted with your hashtag. To do this, the bot needs to mention
    them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要做的事情之一是让机器人能够回复使用你的标签推文的人。为了做到这一点，机器人需要提及他们。
- en: You can access the username of the person who tweeted with your hashtag by using
     `tweet.user.screen_name`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`tweet.user.screen_name`来访问使用你的标签推文的人的用户名。
- en: 'In order to mention them, concatenate a `''@''` symbol at the beginning by
    doing this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提及它们，通过这样做在开头添加一个`'@'`符号：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then just concatenate that to the string you want to tweet out. We're now replying
    to the person who tweeted. Cool!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它连接到你想推文的字符串中。我们现在正在回复推文的人。酷！
- en: 'So, let''s now look at the complete source code to get a full picture:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们看看完整的源代码，以获得全面的了解：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we now execute the app with `node app.js`, we should be able to pick up
    any hashtags with the keyword `''#FlightBot''`. Let''s have a look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在用`node app.js`执行应用程序，我们应该能够抓取任何包含关键词`'#FlightBot'`的标签。让我们看看：
- en: '![Replying to who tweeted](img/image00226.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![回复推文的人](img/image00226.jpeg)'
- en: 'We now get the following result:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在得到以下结果：
- en: '![Replying to who tweeted](img/image00227.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![回复推文的人](img/image00227.jpeg)'
- en: This is really awesome. With just a few lines of code we were able to create
    a simple Twitter bot. But we are still not done. We haven't added any logic on
    how to provide basic flight details or data yet .
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很棒。仅仅用几行代码，我们就能够创建一个简单的Twitter机器人。但我们还没有完成。我们还没有添加任何关于如何提供基本的航班详情或数据的逻辑。
- en: But before we do that, let's put the `secret` variable object into a `secret.json`
    file, so we can avoid having the access codes and tokens within our code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，让我们将`secret`变量对象放入一个`secret.json`文件中，这样我们就可以避免在代码中包含访问代码和令牌。
- en: 'Create a new `secret.json` file and save it in the same folder as the `app.js`
    file. The `secret.json` file should now look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`secret.json`文件，并将其保存在与`app.js`文件相同的文件夹中。`secret.json`文件现在应该看起来像这样：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This `secret.json` file is then referenced from the code, and it now looks
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`secret.json`文件随后被代码引用，现在看起来如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have the updated code, let's add the necessary logic to send information
    about flights statuses and information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更新的代码，让我们添加必要的逻辑来发送有关航班状态和信息的消息。
- en: Flight APIs
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 航班API
- en: In order to get some flight information, we'll have to rely on a flight API.
    One that is free and really useful is the one from **Air France-KLM**, which is
    available at [https://developer.airfranceklm.com/](https://developer.airfranceklm.com/)
    .
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取一些航班信息，我们将不得不依赖航班API。一个免费且非常有用的是来自**Air France-KLM**的API，它可在[https://developer.airfranceklm.com/](https://developer.airfranceklm.com/)找到。
- en: '![Flight APIs](img/image00228.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![航班API](img/image00228.jpeg)'
- en: So let's sign up and register an account. There are several APIs (found at [https://developer.airfranceklm.com/Our_Apis](https://developer.airfranceklm.com/Our_Apis)
    ) provided by Air France-KLM such as Reservations, Order, Flight Offer, Flight
    Status, Location, Contact Information, Ancillary Shop, and Check-in.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们注册并创建一个账户。Air France-KLM提供了几个API（可在[https://developer.airfranceklm.com/Our_Apis](https://developer.airfranceklm.com/Our_Apis)找到），例如预订、订单、航班优惠、航班状态、位置、联系方式、附属商店和登机。
- en: We are interested in using the **Flight Status API** ( [https://developer.airfranceklm.com/page/Flight_status_API](https://developer.airfranceklm.com/page/Flight_status_API)
    ), which will provided up-to-date and accurate information about specific flight
    numbers. Let's explore this API a bit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对使用**Flight Status API**（[https://developer.airfranceklm.com/page/Flight_status_API](https://developer.airfranceklm.com/page/Flight_status_API)）感兴趣，它将提供关于特定航班号的最新和准确信息。让我们来探索一下这个API。
- en: The Flight Status API provides flight status information-such as scheduled and
    actual arrival and departure times-of KLM-operated flights, or Delta and Air France-operated
    flights with a KLM codeshare, flying to and from the Air France-KLM hub in Amsterdam.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 航班状态API提供由KLM运营的航班或与KLM代码共享的Delta和Air France运营的航班的状态信息，包括飞往和离开阿姆斯特丹的Air France-KLM枢纽的航班，如预定和实际到达和出发时间。
- en: The API supports operational decision making, such as notification in case of
    exceptional situations, like extreme weather conditions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该API支持运营决策，例如在极端天气条件等异常情况下发出通知。
- en: The great thing about this API is that it doesn't require API keys, and it is
    available for free. The catch is that it only returns data from the day that you
    execute the query-that is, it only returns today's data and doesn't return any
    past flight status information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 的好处是它不需要 API 密钥，并且免费提供。但是，它只返回你执行查询当天的数据——也就是说，它只返回今天的数据，不会返回任何过去的航班状态信息。
- en: There are two ways to search with this API. One is to search using a flight
    number and the other is to use a route.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 API 有两种搜索方式。一种是通过航班号搜索，另一种是使用路线。
- en: Flight status API
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 航班状态 API
- en: 'When searching using a flight number, the `REST` endpoint will provide the
    flight status for a given flight, and you must specify the day''s date; for example,
    flight KL1699 on  September 16, 2016\. The request would look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用航班号搜索时，REST 端点将提供给定航班的航班状态，并且你必须指定日期；例如，2016 年 9 月 16 日的 KL1699 航班。请求看起来像这样：
- en: '[http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16](http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16](http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16)'
- en: 'This would return the following JSON response:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下 JSON 响应：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That was easy and fun! Now let's explore the route search API.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，也很有趣！现在让我们探索路线搜索 API。
- en: Route search API
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路线搜索 API
- en: The Route Search REST endpoint provides a summary of flight statuses for all
    applicable flights in a given route, such as Amsterdam (AMS) and Paris Charles
    de Gaulle (CDG).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 路线搜索 REST 端点提供了给定路线（例如阿姆斯特丹（AMS）和巴黎查尔斯·戴高乐（CDG））中所有适用航班的航班状态摘要。
- en: 'The request would look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请求看起来像这样：
- en: '[http://fox.klm.com/fox/json/flightstatuses?originAirportCode=AMS&destinationAirportCode=CDG](http://fox.klm.com/fox/json/flightstatuses?originAirportCode=AMS&destinationAirportCode=CDG)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://fox.klm.com/fox/json/flightstatuses?originAirportCode=AMS&destinationAirportCode=CDG](http://fox.klm.com/fox/json/flightstatuses?originAirportCode=AMS&destinationAirportCode=CDG)'
- en: The JSON result would be as follows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 结果如下。
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The response includes the following information--Scheduled Departure Date Time,
    Scheduled Arrival Date Time, Flight Status, Marketing Flights, Remaining Fly Time,
    Arrival, and Departure information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包括以下信息——计划出发日期时间、计划到达日期时间、航班状态、营销航班、剩余飞行时间、到达和出发信息。
- en: So now that we have an API to query, let's make our bot a bit smarter and allow
    it to retrieve flight status and route details.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了查询 API，那么让我们让我们的机器人变得更聪明一些，允许它检索航班状态和路线详情。
- en: Adding a REST client library
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 REST 客户端库
- en: Using the code we already have, which is able to respond back to the person
    that actually tweeted the `'#FlightBot'` hashtag, let's make some modifications
    so that it can provide status details about flights and routes using the Air France-KLM
    APIs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们已有的代码，它能够响应实际使用了 `'#FlightBot'` 标签的人，让我们做一些修改，以便它可以使用 Air France-KLM API
    提供航班和路线的状态详情。
- en: The first thing that we need to do in order to communicate to the Air France-KLM
    endpoints is to include a `REST` client library for Node.js in our app.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 Air France-KLM 端点通信，我们需要做的第一件事是在我们的应用程序中包含一个 Node.js 的 REST 客户端库。
- en: There are various Node.js REST client libraries out there, and you can choose
    whichever makes you feel more comfortable. For our example, however, we'll be
    using the library found at [https://www.npmjs.com/package/request](https://www.npmjs.com/package/request)
    .
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有各种 Node.js REST 客户端库，你可以选择让你感觉更舒适的任何一个。然而，在我们的例子中，我们将使用位于 [https://www.npmjs.com/package/request](https://www.npmjs.com/package/request)
    的库。
- en: 'The first thing we need to do is to install it. We can do this from the command
    line by executing this instruction:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装它。我们可以通过在命令行中执行以下指令来完成：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After doing this, our `package.json` file will be updated as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们的 `package.json` 文件将更新如下：
- en: '![Adding a REST client library](img/image00229.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![添加 REST 客户端库](img/image00229.jpeg)'
- en: Note how a reference to `request` has been added. This is because we have used
    the save option when executing the previous instruction.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们添加了对 `request` 的引用。这是因为我们在执行前面的指令时使用了保存选项。
- en: Making the bot a bit smarter
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让机器人变得更聪明
- en: Now that we have added a `REST` client library, it's time to add some logic
    to our application in order to interact with the Air France-KLM APIs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 REST 客户端库，是时候在我们的应用程序中添加一些逻辑，以便与 Air France-KLM API 进行交互。
- en: Our bot should be able to provide feedback about flights and routes using the
    API endpoints previously described.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人应该能够使用之前描述的API端点提供有关航班和路线的反馈。
- en: Let's make some changes to our code to accommodate this. In order to do that,
    let's add some logic to make sure that the bot is able to process not only the
    Twitter hashtag but also a flight number.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的代码进行一些修改以适应这一点。为了做到这一点，让我们添加一些逻辑以确保机器人能够处理Twitter标签以及航班号。
- en: So we will essentially automate the call to this REST endpoint and parse the
    response associated with it, returning just some essential bits of that data,
    but not all of it. Sounds exciting, so let's get started.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将基本上自动化对REST端点的调用并解析与之相关的响应，只返回一些基本的数据，而不是全部。听起来很令人兴奋，所以让我们开始吧。
- en: 'We need to automate this endpoint through a `REST` call. We need to make sure
    that, besides the hashtag, a flight number is also passed as part of the message:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过`REST`调用自动化此端点。我们需要确保除了标签之外，消息中还应传递航班号：
- en: '[http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16](http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16](http://fox.klm.com/fox/json/flightstatuses?flightNumber=KL1699&departureDate=2016-09-16)'
- en: 'Here''s the full updated code. Let''s have a complete look at it and then dissect
    it bit by bit to understand the changes that were made:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的更新后的代码。让我们完整地看看它，然后逐个分析所做的更改：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, so there are some changes. The first one is that we have added a reference
    to the `request` library which we will be using to make the requests to the REST
    API:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以有一些更改。第一个更改是我们添加了对`request`库的引用，我们将使用它来向REST API发出请求：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Following that, we''ve added a `GetDate` function which will return today''s
    date so it can be passed onto the `REST` endpoint as the `departureDate` parameter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们添加了一个`GetDate`函数，该函数将返回今天的日期，以便将其作为`departureDate`参数传递到`REST`端点：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This `GetDate` function uses a `padLeft` function that is responsible for correctly
    formatting each of the parts of the date as shown in the following code snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`GetDate`函数使用一个`padLeft`函数，该函数负责正确格式化以下代码片段中显示的日期的每个部分：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These two functions cover the `departureDate` part of the REST endpoint. So
    now let's focus on the `flightNumber` part.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数涵盖了REST端点的`departureDate`部分。因此，现在让我们专注于`flightNumber`部分。
- en: 'For this, we''ve written a function called `FlightNumberOk`, which does a quick
    check to ensure that the flight number is correct:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们编写了一个名为`FlightNumberOk`的函数，它进行快速检查以确保航班号是正确的：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the flight number correct, we can then use another function called `GetFlightDetails`
    to actually perform the call to the `REST` endpoint. The JSON response is represented
    by the variable `body`, which is then assigned to the `fd` variable, which is
    later used to tweet a response back to the user. Refer to the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 航班号正确后，我们可以使用另一个名为`GetFlightDetails`的函数来实际调用`REST`端点。JSON响应由变量`body`表示，然后分配给`fd`变量，该变量随后用于向用户发送推文响应。请参考以下代码：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because the `GetFlightDetails` uses the request library to perform an asynchronous
    request to the `REST` endpoint, we cannot tweet the response until the JSON response
    is obtained, and to ensure that, the tweet response is executed within a `setTimeout`
    JavaScript function 1,500 milliseconds after the execution of the `GetFlightDetails`
    takes place.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GetFlightDetails`使用请求库对`REST`端点执行异步请求，我们无法在获得JSON响应之前发送推文，并且为了确保这一点，推文响应在`GetFlightDetails`执行后1,500毫秒内在`setTimeout`JavaScript函数中执行。
- en: 'So basically our `Twitter.stream` function now looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上我们的`Twitter.stream`函数现在看起来是这样的：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note how `FlightNumberOk` and `GetFlightDetails` are called before the `Twitter.Post`
    is called by the `setTimeout` function. This is done to ensure that the flight
    number is OK, and that the JSON response containing the flight details exists,
    before sending out the tweet to the user.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`setTimeout`函数调用`Twitter.Post`之前，如何调用`FlightNumberOk`和`GetFlightDetails`。这是为了确保航班号是正确的，并且包含航班详细信息的JSON响应存在，然后再向用户发送推文。
- en: 'The tweet response basically sends out `scheduledArrivalDateTime`, which is
    obtained by parsing the JSON response using `JSON.parse`. This is accessed as
    follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 推文响应基本上会发送`scheduledArrivalDateTime`，这是通过使用`JSON.parse`解析JSON响应获得的。它可以通过以下方式访问：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we execute the program now and tweet `#FlightBot KL1699`, we''ll get the
    following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序并推文`#FlightBot KL1699`，我们会得到以下结果：
- en: '![Making the bot a bit smarter](img/image00230.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![让机器人变得更聪明](img/image00230.jpeg)'
- en: So that's cool, isn't it? Really cool!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这很酷，不是吗？真的很酷！
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we've seen how to interact with Twitter and also how
    to query the Air France-KLM API in order to retrieve flight details and respond
    to tweets.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何与Twitter互动，以及如何查询法航-荷兰航空API以检索航班详情和回复推文。
- en: We've barely scratched the surface of what can be done with these APIs; the
    possibilities are, frankly, quite endless. All you need is time and a good dose
    of imagination!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对使用这些API可以做到的事情只是触及了皮毛；坦白说，可能性几乎是无限的。您需要的只是时间和丰富的想象力！
- en: You are encouraged to keep exploring both the Twitter and also the Air France-KLM
    APIs, as well as other flight data APIs out there. It's definitely an interesting
    area, and one worth exploring further.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您继续探索Twitter、法航-荷兰航空API以及其他可用的航班数据API。这绝对是一个有趣且值得进一步探索的领域。
- en: I hope you have enjoyed following these examples. The next chapters will look
    at other fascinating topics. Have fun!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢跟随这些示例。接下来的章节将探讨其他有趣的主题。祝您玩得开心！
