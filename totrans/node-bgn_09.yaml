- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling HTTP and REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the internet from both a historical point
    of view and a practical understanding of the infrastructure behind the internet
    that we know and use every day.
  prefs: []
  type: TYPE_NORMAL
- en: We will deep dive into the protocols and architectures that make it possible
    to create web projects and will explore the RFCs that are the backbone of the
    current web browsing experience.
  prefs: []
  type: TYPE_NORMAL
- en: We will master all the components and theoretical concepts around HTTP, URLs,
    and REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The history of the internet and how the internet infrastructure works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What **Requests for Comments** (**RFCs**) are and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP communications between the server and clients (**Single-Page Applications**
    (**SPAs**) versus server-side rendering)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering HTTP (headers, status codes, payloads, verbs, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tools to debug HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How REST APIs are structured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the JSON spec works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the modern web works under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a clear idea of all the pieces in
    place that constitute the current internet and how you should build your web projects
    by applying this knowledge learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/GleRpaaR2PQ](https://youtu.be/GleRpaaR2PQ)
  prefs: []
  type: TYPE_NORMAL
- en: How the internet works under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the internet every day, but do we know how it works? Wikipedia defines
    the internet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “The Internet (or internet) is the global system of interconnected computer
    networks that uses the Internet protocol suite (TCP/IP) to communicate between
    networks and devices. It is a network of networks that consists of private, public,
    academic, business, and government networks of local to global scope, linked by
    a broad array of electronic, wireless, and optical networking technologies. The
    Internet carries a vast range of information resources and services, such as the
    interlinked hypertext documents and applications of the World Wide Web (WWW),
    electronic mail, telephony, and file sharing.”
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the internet is a global system that connects computers together
    through networks and employs certain protocols and techniques to enable that communication
    in a resilient way. The internet is used by all kinds of entities and people to
    share information resources and services using tools such as electronic mail,
    file sharing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: But to be honest, this definition is just scratching the surface. To understand
    how the internet works, we need to go back in time and understand how it started.
  prefs: []
  type: TYPE_NORMAL
- en: History of the internet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The internet as we know it today was not created by a single person or specific
    group of people. The internet is the product of the work of many people who contributed
    to the creation of different technologies and ideas that, over time, became what
    we know today as the modern internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main concepts that we need to keep in mind when we try to understand
    how the internet works from the engineering perspective. These concepts are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access to information**: While the computer world was stuck in the mainframe
    era, user terminals had to be connected to a mainframe. The idea of remote access
    started to grow. Over time, humanity discovered that if we connect computers together,
    we can share information and resources between them. Basically, we can segment
    and distribute information and computer resources. We can connect with other people
    and share information with them faster than ever before in the history of humanity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: In the 1960s, the US government was concerned about the possibility
    of a nuclear attack that could destroy the communication infrastructure. This
    concern was the seed of the idea of a distributed network without a single point
    of failure that could survive a nuclear attack, and that is the reason why the
    internet is very often referred to as a network of networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many more things needed to happen since the 20th century to make the internet
    a reality, but these two concepts remain strong in the architecture of the internet
    today.
  prefs: []
  type: TYPE_NORMAL
- en: Important info
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a great video that explains the history of the internet in a very
    simple way. You can watch it here: [https://www.youtube.com/watch?v=9hIQjrMHTv4](https://www.youtube.com/watch?v=9hIQjrMHTv4).'
  prefs: []
  type: TYPE_NORMAL
- en: Internet Infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just to give you an idea of the dependency that we all have on the internet,
    there are hundreds of optic fiber cables connecting the world across the oceans
    and seas to make internet connectivity possible. Here is a map of the submarine
    cables that connect the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Our world is connected by dozens of fiber optic cables across
    the oceans. Screenshot from (https://www.submarinecablemap.com/) CC BY-SA 4.0.](img/B21678_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Our world is connected by dozens of fiber optic cables across the
    oceans. Screenshot from ([https://www.submarinecablemap.com/](https://www.submarinecablemap.com/))
    CC BY-SA 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Optic fiber cables are not the only way to connect to the internet. Other ways
    include satellites and radio waves. Over the years, the speed of the internet
    has increased and the cost of a connection has decreased thanks to endless research
    and innovation in the field of telecommunications.
  prefs: []
  type: TYPE_NORMAL
- en: Request for Comments (RFC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will focus a lot on the specifications, protocols, and standards
    that we need to get familiar with in order to make our applications work.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time that you’re exploring such exotic topics, you may
    feel overwhelmed by the amount of information that you need to digest. But don’t
    worry, we will explore all these topics in a very simple and functional way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Internet Engineering Task Force (IETF) defines an Request for Comments
    (RFC) as follows ([https://www.ietf.org/standards/rfcs/](https://www.ietf.org/standards/rfcs/)):'
  prefs: []
  type: TYPE_NORMAL
- en: “ RFC documents contain technical specifications and organizational notes for
    the Internet.”
  prefs: []
  type: TYPE_NORMAL
- en: Basically, RFC is a document that describes some kind of specification/protocol/standard
    to be designed as part of the internet architecture. Any person can submit an
    RFC to the IETF and if the RFC is approved, it becomes a standard while this sounds
    simple, this process can take a long time as the refinement and review process
    is exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple extract from RFC 2616 ([https://www.rfc-editor.org/rfc/rfc2616.txt](https://www.rfc-editor.org/rfc/rfc2616.txt))
    that describes the **Hypertext Transfer Protocol – HTTP/1.1** in 175 pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, I know… this is not an easy read. I don’t expect you to read the whole
    RFC but we will explore some parts of it in this chapter in a practical way.
  prefs: []
  type: TYPE_NORMAL
- en: The best aspect of RFCs is that they are free and you can read them online.
    You can find lots of quality information that can help you understand specific
    parts of the internet architecture when you need it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other RFCs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just to get rid of that overwhelming feeling, I would like to share with you
    other RFCs that are more fun to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RFC 2324** ([https://tools.ietf.org/html/rfc2324](https://tools.ietf.org/html/rfc2324)):
    Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RFC 1149** ([https://tools.ietf.org/html/rfc1149](https://tools.ietf.org/html/rfc1149)):
    A Standard for the Transmission of IP Datagrams on Avian Carriers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And my favorite one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RFC 2549** ([https://datatracker.ietf.org/doc/html/rfc2549](https://datatracker.ietf.org/doc/html/rfc2549)):
    IP over Avian Carriers with Quality of Service; an iteration of RFC 1149'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These funny RFCs can give you familiarity and an idea of the power of the RFC
    discussion format. Basically, if you want to create a new protocol, you can submit
    an RFC to the IETF and if the RFC is approved, it becomes a standard. You can
    read more about the RFC process here: [https://www.rfc-editor.org/about/independent/](https://www.rfc-editor.org/about/independent/).'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important protocols that you will need to know as a web developer
    is HTTP. In the next section, we will explore this protocol in detail and will
    learn the different architectures and components it involves and that are in use
    today as the backbone of the internet as we know it.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP – server and client relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While web development can be a very complex topic, we can simplify it by understanding
    the relationship between the server and the client in the typical web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two main actors, the server and the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**: The server is the computer that is running the application, dealing
    with the database queries, and many other things. This server is often called
    the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The client is the piece of software that the end user executes
    on the local machine in the case of web applications. The user employs a web browser
    to execute the software (HTML, CSS, JS, etc.). The client is often called the
    frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication between the server and the client is done through HTTP. The
    client sends a request to the server and the server replies with a response. This
    is the typical request/response cycle
  prefs: []
  type: TYPE_NORMAL
- en: Request and response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The request and response are the two main parts of HTTP. The request is sent
    by the client to the server and the server returns a response. The request and
    response are composed of different parts that we will explore in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The relationship between the server, internet, and multiple
    clients](img/B21678_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The relationship between the server, internet, and multiple clients
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding diagram, one server can handle multiple clients
    at the same time. This is the typical architecture of a web application. The server
    handles the requests from clients and responds with the corresponding response.
  prefs: []
  type: TYPE_NORMAL
- en: 'But very often, one client will send multiple requests to a single server or
    multiple servers. Let’s take a look at the following HTML snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the client sends three requests to three different servers (`server1.com`,
    `server2.com`, and `server3.com`) asking for specific resources. Each server will
    eventually respond with the requested resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, let’s go to [https://packtpub.com](https://packtpub.com)
    and open the developer tools in our browser. In the **Network** tab, we can see
    all the requests that the browser is sending to the server and the responses from
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Web browser screenshot](img/B21678_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Web browser screenshot
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pay attention to the bottom part of *Figure 9**.3*, you can easily see
    that this page is sending more than 60 requests targeting different servers to
    render the page. This is a very common scenario in web applications: the client
    sends multiple requests to the server(s) to get key resources including favicons,
    CSS files, JS files, images, videos, and raw data. If we look at the table, we
    can see each item that is loaded, and can debug and explore each request that
    was made. This can be intimidating at the beginning, but once you know how the
    filter works and you spend some hours working with it you will feel more comfortable.'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the beginning, web applications were very simple, and JavaScript was very
    limited in its usage. Web applications were rendered on the server and the client
    just received the HTML, CSS, and JS files. This is called server-side rendering,
    and it is still used in many applications.
  prefs: []
  type: TYPE_NORMAL
- en: While this model is still used today, there are some clear disadvantages. Any
    time the user wants to interact with the application, the server needs to render
    the page again and send it to the client. This generates a lot of traffic and
    the user experience is not the best, as there are moments where the website appears
    blank between refreshes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The relationship between the server and client in the server-side
    rendering approach](img/B21678_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The relationship between the server and client in the server-side
    rendering approach
  prefs: []
  type: TYPE_NORMAL
- en: This pattern was especially bad in the early days of smartphones, when mobile
    devices were not powerful enough to render the pages and the connection was not
    very good. The user experience was very bad. The solution was to move the rendering
    to the client side, this is called client-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Page Applications (SPAs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In client-side rendering, the server sends the initial HTML, CSS, and JS files
    to the client. Then, JavaScript takes control of the application and renders the
    views on the client side. Thus, the server only sends the data to the client and
    the client renders the page. This is called a **Single-Page Application** (**SPA**)
    and it is the most common pattern today.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The relationship between the server in the AJAX approach](img/B21678_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The relationship between the server in the AJAX approach
  prefs: []
  type: TYPE_NORMAL
- en: At first, this pattern was very complicated to implement, but with the evolution
    of JavaScript frameworks, this pattern has become very popular. Today, we have
    a lot of frameworks that can help us to build SPAs easily. Some of the most popular
    frameworks are Angular, React, and Vue.js. The SPA pattern uses the same HTTP
    but in a different way via **Asynchronous JavaScript and XML** (**AJAX**) requests.
  prefs: []
  type: TYPE_NORMAL
- en: This new technique introduced a lot of changes and innovations in the way we
    build the backend applications. Backend applications became more like an **Application
    Programming Interface** (**API**) that responds with data to the client, and not
    only to the typical web clients, but now even servers can also use this API to
    exchange information with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear idea of the components and possible web architectures,
    it is time to deep dive into HTTP so we can build solid projects using standardized
    communication between the server and the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the HTTP concept, let’s take a look
    at the different parts of HTTP that we need to understand in order to build a
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen the request and response, but let’s take a deeper look
    at the different parts that compose the request and the response (headers, payloads,
    versions, and methods).
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each request and response has a set of headers. These are key-value pairs and
    provide additional information about the request or the response.
  prefs: []
  type: TYPE_NORMAL
- en: While both the request and response headers may look similar, they are not the
    same, although they do share common key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Request headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by analyzing in *Figure 9**.6* what is included in the request
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Attributions and copyright licensing by Mozilla Contributors
    is licensed under CC-BY-SA 2.5](img/B21678_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Attributions and copyright licensing by Mozilla Contributors is
    licensed under CC-BY-SA 2.5
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s group the different header properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representation headers: `content-type` and `content-length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General headers: `keep-alive` and `upgrade-insecure-requests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Request headers: `accept`, `accept-encoding`, `accept-language`, `host`, and
    `user-agent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just by looking at the headers, we can understand many things about a request,
    such as the type of content the client is expecting, the language, and the browser
    used. The server can use this information to provide a better response to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Important info
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just a small list of the possible headers. There are many more headers
    that we can use to provide more information about the request or response. We
    can even create our own key-value pairs. You can find the list of the HTTP headers
    here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).'
  prefs: []
  type: TYPE_NORMAL
- en: Response headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will finish by analyzing in the *Figure 9**.7* what is included in the response
    header
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Attributions and copyright licensing by Mozilla Contributors
    is licensed under CC-BY-SA 2.5](img/B21678_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Attributions and copyright licensing by Mozilla Contributors is
    licensed under CC-BY-SA 2.5
  prefs: []
  type: TYPE_NORMAL
- en: 'The response headers are very similar to the request headers, but they are
    not the same. They can be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representation headers: `content-type`, `content-encoding`, and `last-modified`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General headers: `connection`, `date`, `keep-alive`, and `transfer-encoding`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Response headers: `access-control-allow-origin`, `etag`, `server`, `set-cookie`,
    `vary`, and `x-frame-options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the response headers, we can also provide additional information that will
    help the browsers and the web applications to digest and render the information
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: The response headers are very important for the security of the application,
    as there are many headers that can prevent certain attacks in the web browser
    environment. For example, we can use `x-frame-options` to prevent the application
    from being loaded in an `iframe`, or use `feature-policy` to prevent the application
    from using features such as the camera or microphone. We will explore this in
    [*Chapter 15*](B21678_15.xhtml#_idTextAnchor394).
  prefs: []
  type: TYPE_NORMAL
- en: Status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overall, one of the most important pieces of information that we can find in
    the response is the status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The status code allows us to understand whether the request was successful
    or not and can even provide more granular feedback. We can classify status codes
    into the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '1xx: Informational'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2xx: Success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3xx: Redirection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4xx: Client Error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5xx: Server Error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most common status codes are `200 OK`, `201 Created`, `301 Moved Permanently`,
    `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `429
    Too Many Requests`, `500 Internal Server Error`, and `503 Service Unavailable`.
    You can find the complete list of the status codes here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if you know the given status code, you can understand what happened
    with your request. For example, a `429` error code occurs when the client has
    sent too many requests in a given amount of time (“rate limiting”), but if you
    receive a `401` then the error is related to your authentication. Finally, if
    in the same scenario you receive `403`, you are correctly authenticated but you
    don’t have enough permission to perform the given operation, such as deleting
    another user account.
  prefs: []
  type: TYPE_NORMAL
- en: We all have experienced the `404` error code, which is very common when we try
    to access a resource that doesn’t exist. For example, if we try to access the
    following URL, `https://www.google.com/invented-resource`, we will receive a `404`
    error code.
  prefs: []
  type: TYPE_NORMAL
- en: 418 I’m a teapot
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a strong culture on the internet to build fancy 404 pages. You can
    find a lot of examples online, but not many people know that there is a special
    error code `418` that RFC 2324 ([https://tools.ietf.org/html/rfc2324](https://tools.ietf.org/html/rfc2324))
    describes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “Any attempt to brew coffee with a teapot should result in the error code “418
    I’m a teapot”. The resulting entity body MAY be short and stout.”
  prefs: []
  type: TYPE_NORMAL
- en: While this might seem just like a running joke, it is actually supported by
    many entities including Node ([https://github.com/nodejs/node/issues/14644](https://github.com/nodejs/node/issues/14644))
    and Google.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Web browser screenshot of google.com/teapot](img/B21678_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Web browser screenshot of google.com/teapot
  prefs: []
  type: TYPE_NORMAL
- en: 'As Shane Brunswick said on the Save 418 Movement website ([https://save418.com/](https://save418.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: “It’s a reminder that the underlying processes of computers are still made by
    humans. It’d be a real shame to see 418 go.”
  prefs: []
  type: TYPE_NORMAL
- en: 'And I do agree with him: behind these complex systems there are humans, and
    we should not forget that, in the same way that we should not forget that the
    internet could not exist without the open source movement and the hacker culture.'
  prefs: []
  type: TYPE_NORMAL
- en: Request methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as status codes are very important to understand responses, the request
    methods are essential to understand requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many request methods, but the most common are the following: `GET`,
    `POST`, `PUT`, `PATCH`, and `DELETE`. You can find the complete list of the request
    methods here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that we backend developers use them can differ a bit, but the most
    common way is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Retrieve a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Create a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Update a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Partially update a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Delete a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore them in detail in [*Chapter 11*](B21678_11.xhtml#_idTextAnchor300)*,*
    when we create an actual REST API with all the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the early days of the internet, we used forms to send data to the server
    and specified the given method in the form. See the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code was a common way to send data to a server in order to create
    a new user, but nowadays we use JavaScript to send data to the server. For example,
    we can use the `fetch` API to send data to the server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And then we would use the response to inform the user whether the request was
    successful or not. While using JavaScript to send data to the server is more complex,
    it gives us more flexibility and control over the request.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When you enter a URL in the browser, the browser sends a `GET` request to the
    server. This is the default method that the browser uses. You have been using
    HTTP methods for a long time without knowing it.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP payloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP messages can carry a payload, which means that we can send data to the
    server, and servers likewise can send data to their clients. This is often done
    with `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Payloads can be in many formats, but the most common are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/json`: Used when sharing JSON data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/x-www-form-urlencoded`: Used when sending simple texts in ASCII,
    sending data in the URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipart/form-data`: Used when sending binary data (such as files) or non-ASCII
    texts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/plain`: Used when sending plain text, such as a log file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the complete list of the content types here: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP has evolved over the years, and we have different versions of the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Version** | **Year** | **Status** |'
  prefs: []
  type: TYPE_TB
- en: '| `HTTP/0.9` | 1991 | Obsolete |'
  prefs: []
  type: TYPE_TB
- en: '| `HTTP/1.0` | 1996 | Obsolete |'
  prefs: []
  type: TYPE_TB
- en: '| `HTTP/1.1` | 1997 | Standard |'
  prefs: []
  type: TYPE_TB
- en: '| `HTTP/2` | 2015 | Standard |'
  prefs: []
  type: TYPE_TB
- en: '| `HTTP/3` | 2022 | Standard |'
  prefs: []
  type: TYPE_TB
- en: Currently, the most used version of the protocol is the `HTTP/1.1` version,
    but the `HTTP/2` version is gaining popularity. The `HTTP/3` version is quite
    new and not widely supported yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, Node supports the `HTTP/1.1` and `HTTP/2` versions, but it doesn’t
    support the `HTTP/3` version yet. There is an ongoing strategic initiative to
    support it: [https://github.com/nodejs/node/issues/38478](https://github.com/nodejs/node/issues/38478).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how important **Uniform Resource Locators**
    (**URLs**) are and how we can use them to structure access to resources in our
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using URLs in web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following table, made by Node.js, that describes the
    different parts of a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – URL structure from the Node.js Official Documentation. Attributions
    and copyright licensing by Node.js Contributors is licensed under MIT](img/B21678_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – URL structure from the Node.js Official Documentation. Attributions
    and copyright licensing by Node.js Contributors is licensed under MIT
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following chapters, we will use the URL parts a lot, so keep this table
    handy. There are many ways to parse a URL, but the most common way is to use the
    `URL` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This class is available in Node.js and in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Important info
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js 20 introduced one of the most performant URL parsers available, called
    Ada 2.0: [https://www.yagiz.co/announcing-ada-url-parser-v2-0](https://www.yagiz.co/announcing-ada-url-parser-v2-0).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how flexible URLs are, let’s explore in the next section how
    we can build a standard layer on top of our web services. This layer is the foundation
    of many online services and SaaS products. We will learn the basics of creating
    web application interfaces (APIs).
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** stands for **Representational State Transfer**, and is an architectural
    style for building APIs. It was introduced by Roy Fielding in his PhD dissertation
    ([https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm))
    in 2000.'
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, the idea is to define a set of resources that can be accessed
    by the client using HTTP, as we explored in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Each resource is identified by a unique URL, and the client can perform operations
    on it using the HTTP methods. The server will respond with a status code and a
    payload when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say that we have a REST API to manage a database of movies.
    We can define the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/movies`: This resource represents the collection of movies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/movies/:id`: This resource represents a single movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: The `:id` part of the URL is a placeholder for the user ID. This is called a
    URL parameter, and takes the form of `/movies/1` or `/movies/12345`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client can perform the following operations on these resources using the
    aforementioned HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /movies:` Get all the movies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /movies/:id`: Get a single movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /movies`: Create a new movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /movies/:id`: Update a movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /movies/:id`: Delete a movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, the server will respond with a JSON payload, but it can also
    respond with other formats such as XML or HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example of a REST API in action. We will use simple-api ([https://www.npmjs.com/package/@ulisesgascon/simple-api](https://www.npmjs.com/package/@ulisesgascon/simple-api)),
    which is a very simple HTTP API to build fast prototypes. This API includes Swagger
    documentation that can be used to explore the API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Web browser screenshot of the API documentation generated with
    Swagger](img/B21678_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Web browser screenshot of the API documentation generated with
    Swagger
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the API is quite intuitive and easy to use because it follows
    the REST principles. So, you intuitively know how to use it. We can use Swagger
    to explore more details of the payload expected by the API when we create a new
    todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Web browser screenshot of the API documentation generated with
    Swagger](img/B21678_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Web browser screenshot of the API documentation generated with
    Swagger
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to explore the potential responses that the API can return
    for any specific endpoint that is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Web browser screenshot of the API documentation generated with
    Swagger](img/B21678_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Web browser screenshot of the API documentation generated with
    Swagger
  prefs: []
  type: TYPE_NORMAL
- en: If you understand how RESTful APIs work, you will be able to use any API based
    on HTTP. For example, the GitHub API [https://docs.github.com/en/rest](https://docs.github.com/en/rest)
    is a REST API that uses HTTP to expose its services.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a world full of APIs out there, waiting for you to use them to build
    amazing projects. Here is a great list of public APIs: [https://apilist.fun/](https://apilist.fun/)'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the previous chapters, we have mentioned JSON, but we haven’t explained
    it in detail, so in the next section we will deep dive into it, as it is the most
    common format to exchange data in modern APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the JSON specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**, and is a lightweight data-interchange
    format. It is easy for humans to read and write, and it is easy for machines to
    parse and generate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily convert a JavaScript object to a JSON string using the `JSON.stringify()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can convert a JSON string to a JavaScript object using the `JSON.parse()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While the JSON name includes the world JavaScript, it is a language-independent
    data format. Many programming languages have libraries to parse and generate JSON.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is the most common format used to exchange data between clients and servers,
    such as when we use or build a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The JSON specification is quite simple, and I strongly suggest you read it.
    You can find it at [https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf](https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to debug HTTP requests so that we can
    build complex projects easily.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to debug HTTP requests. The most common way is to use the
    developer tools, as these are easily accessible in most web browsers. It is also
    quite helpful when you are developing a website to keep these tools open and navigate
    between the tabs to debug UI components and network requests.
  prefs: []
  type: TYPE_NORMAL
- en: But there are also other tools that you can use, such as Postman ([https://www.postman.com/](https://www.postman.com/))
    or Insomnia ([https://insomnia.rest/](https://insomnia.rest/)), which were designed
    specifically for this purpose and offer many features out of the box (collections,
    authentication, etc.). These tools are the best option if you don’t have a website
    and you are just testing API endpoints directly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will use the developer tools of the browser to debug
    our HTTP transactions and will use Jest to test and debug our HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Other developers use more advanced tools such as Charles ([https://www.charlesproxy.com/](https://www.charlesproxy.com/))
    or Wireshark ([https://www.wireshark.org/](https://www.wireshark.org/)), but they
    are not necessary for the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with the developer tools of your browser, you can read
    more about it in [*Chapter 2*](B21678_02.xhtml#_idTextAnchor036).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned a lot about the technologies that we will use
    to build our applications and that constitute the foundation of the modern internet.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we have learned how RFC documents are used to define the standards
    of the internet and how we can use them to learn more about the technologies that
    we use.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we learned how the server-client architecture works and how HTTP is
    used to exchange data between the client and the server in detail, including HTTP
    methods and status codes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored the URL parts and learned how to use them to build RESTful
    APIs. We also learned about the JSON specification in more detail and how to debug
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how we can use databases to store data
    and how we can interact with them. This is the last piece of the puzzle before
    we can start building our final web application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Wikipedia* | *IP over Avian* *Carriers*: [https://en.wikipedia.org/wiki/IP_over_Avian_Carriers](https://en.wikipedia.org/wiki/IP_over_Avian_Carriers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wikipedia* | *HTTP*: [https://en.wikipedia.org/wiki/HTTP](https://en.wikipedia.org/wiki/HTTP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*History of the* *Internet*: [https://www.youtube.com/watch?v=9hIQjrMHTv4](https://www.youtube.com/watch?v=9hIQjrMHTv4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How the Internet Works in 5* *Minutes*: [https://www.youtube.com/watch?v=7_LPdttKXPc](https://www.youtube.com/watch?v=7_LPdttKXPc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An overview of HTTP: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Project Code Rush - The Beginnings of Netscape / Mozilla* *Documentary*: [https://www.youtube.com/watch?v=4Q7FTjhvZ7Y](https://www.youtube.com/watch?v=4Q7FTjhvZ7Y)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How The Internet Travels Across* *Oceans*: [https://www.youtube.com/watch?v=yd1JhZzoS6A](https://www.youtube.com/watch?v=yd1JhZzoS6A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*There is a Reason Why Underwater Power Cables are So* *Expensive*: [https://www.youtube.com/watch?v=bkgvqC3M1Tw](https://www.youtube.com/watch?v=bkgvqC3M1Tw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jeff Geerling* | *Testing one of the oldest internet* *myths*: [https://www.youtube.com/watch?v=4pz2kMxCu8I](https://www.youtube.com/watch?v=4pz2kMxCu8I)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
