- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Composing Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: As your application grows, cramming all the logic into a single component becomes
    impractical. You’ll need to split your app into smaller, modular components and
    assemble them to form a more complex application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序的增长，将所有逻辑都塞入单个组件变得不切实际。您需要将应用程序拆分为更小的、模块化的组件，并将它们组装成更复杂的应用程序。
- en: In this chapter, we’ll explore various techniques to combine components effectively.
    We’ll start by examining how to inject custom content into a component using slots.
    Then, we’ll discuss how to conditionally render different HTML elements within
    a component. We’ll also delve into recursive components, useful for displaying
    nested or hierarchical data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索各种有效组合组件的技术。我们将首先检查如何使用插槽向组件注入自定义内容。然后，我们将讨论如何在组件内条件性地渲染不同的HTML元素。我们还将深入研究递归组件，这对于显示嵌套或分层数据非常有用。
- en: We’ll guide you through each topic with hands-on examples, ensuring the techniques
    you learn are both practical and applicable in real-world scenarios. By the end
    of this chapter, you’ll have a richer set of strategies to compose components
    in your Svelte applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实际示例引导您了解每个主题，确保您学习的技巧既实用又适用于现实世界的场景。到本章结束时，您将拥有一套更丰富的策略来构建您的Svelte应用程序中的组件。
- en: 'In this chapter, you will learn the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Manipulating how a child component looks from the perspective of its parent
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从父组件的角度操纵子组件的外观
- en: Passing dynamic content through slots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过插槽传递动态内容
- en: Rendering different HTML element and component types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染不同的HTML元素和组件类型
- en: Creating recursive components for recursive data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为递归数据创建递归组件
- en: The Container/Presentational pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器/表现模式
- en: Let’s kick things off by exploring the various ways we can manipulate and control
    the content of a child component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索我们可以操纵和控制子组件内容的各种方式开始。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code in this chapter can be found at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码都可以在[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04)找到。
- en: Manipulating how a child component looks
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵子组件的外观
- en: When you’re combining multiple components, you’ll need to manage how each child
    component appears and behaves. Even though a child component handles its own display
    and logic, it still offers controls to tweak its appearance and behavior. From
    the perspective of the parent component, you’ll want to coordinate these child
    components to achieve the desired overall functionality.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当您组合多个组件时，您需要管理每个子组件的外观和行为。尽管子组件处理自己的显示和逻辑，但它仍然提供了一些控件来调整其外观和行为。从父组件的角度来看，您将想要协调这些子组件以实现所需的总体功能。
- en: In this section, we’ll explore various ways to control the look of child components,
    ranging from the most to the least commonly used methods. Understanding these
    options will equip you with the tools to make your components both versatile and
    effective.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索控制子组件外观的各种方法，从最常用到最不常用的方法。了解这些选项将使您拥有制作既灵活又有效的组件的工具。
- en: 'The list of options to control how the child component looks includes the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 控制子组件外观的选项列表包括以下内容：
- en: '**Controlling through props**: This is perhaps the most straightforward way
    to influence the behavior and appearance of a child component. By passing props
    from a parent component to a child, you can make your child component highly dynamic
    and responsive to external changes.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过props控制**：这可能是在子组件的行为和外观上产生影响的最直接方式。通过从父组件传递props到子组件，您可以使子组件高度动态并对外部变化做出响应。'
- en: 'To demonstrate how a parent component can control content using props in Svelte,
    consider the following code example:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了演示父组件如何使用props在Svelte中控制内容，请考虑以下代码示例：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the parent component has the ability to dictate the text shown
    in the `Child` component by modifying the `message` prop’s value. Controlling
    props is a simple yet effective way to manipulate a child component’s content.
    If you’re interested in learning more about props, we covered the topic extensively
    in [*Chapter 3*](B18887_03.xhtml#_idTextAnchor051).
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所见，父组件可以通过修改`message`属性值的值来指定`Child`组件中显示的文本。控制属性是一种简单而有效的方式来操纵子组件的内容。如果你对属性感兴趣，我们在[*第3章*](B18887_03.xhtml#_idTextAnchor051)中对此进行了广泛讨论。
- en: '`parent` component:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`组件：'
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, we established a context named `message` with the `'Hello
    from parent'` value, using `setContext`. Then, we imported and used the `Child`
    component without sending any props to it.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用`setContext`创建了一个名为`message`的上下文，其值为`'Hello from parent'`，然后导入并使用了`Child`组件，而没有向其发送任何属性。
- en: 'The following is the code for the `Child` component:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是为`Child`组件的代码：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `getContext` is used to read the `message` context value, which is then
    displayed within a `<p>` element. As demonstrated, the parent component can influence
    the text in the child component’s `<p>` element by changing the context value.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，使用`getContext`读取`message`上下文值，然后在一个`<p>`元素中显示。如所示，父组件可以通过更改上下文值来影响子组件的`<p>`元素中的文本。
- en: For a deeper dive into Svelte’s context feature, you can refer to [*Chapter
    8*](B18887_08.xhtml#_idTextAnchor121), where we will explore the topic in greater
    detail.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要深入了解Svelte的上下文功能，你可以参考[*第8章*](B18887_08.xhtml#_idTextAnchor121)，我们将更详细地探讨这个主题。
- en: '**Controlling the styles**: Manipulating a child component’s appearance isn’t
    solely about controlling the data passed to it. It also involves tweaking or modifying
    its styles.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制样式**：操纵子组件的外观并不仅仅是控制传递给它的数据。它还涉及到调整或修改其样式。'
- en: You can modify a component style through CSS custom properties. This approach
    allows for greater design flexibility, and it ensures that child components can
    adapt to various contexts or themes within the parent component or the broader
    application.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过CSS自定义属性来修改组件样式。这种方法提供了更大的设计灵活性，并确保子组件能够适应父组件或更广泛应用程序中的各种上下文或主题。
- en: For an in-depth discussion on how to alter a component’s style using CSS custom
    properties, feel free to refer to [*Chapter 2*](B18887_02.xhtml#_idTextAnchor032).
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要深入了解如何使用CSS自定义属性来更改组件样式，请参阅[*第2章*](B18887_02.xhtml#_idTextAnchor032)。
- en: '**Passing dynamic content through slot**: Svelte’s slot feature allows you
    to insert custom content into specific areas of a child component. This provides
    a flexible way to have greater control over a component’s content without modifying
    its internal behavior.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过插槽传递动态内容**：Svelte的插槽功能允许你将自定义内容插入子组件的特定区域。这提供了一种灵活的方式来更好地控制组件的内容，而无需修改其内部行为。'
- en: We will talk about slots and how to use them in the following section.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论插槽及其使用方法。
- en: As you can see, there are various ways to shape a child component’s appearance
    and behavior. When we compose different components within a parent component,
    the goal is to make them work together in a coordinated way. You can use a combination
    of the approaches discussed to achieve this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有各种方式来塑造子组件的外观和行为。当我们在一个父组件内组合不同的组件时，目标是使它们以协调的方式协同工作。你可以使用所讨论的方法的组合来实现这一点。
- en: Most of these methods will be covered in separate chapters, and in the following
    section, we’ll focus on how to dynamically alter a child component’s look by passing
    content through slots.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些方法将在单独的章节中介绍，在下一节中，我们将关注如何通过传递内容通过插槽来动态改变子组件的外观。
- en: Passing dynamic content through slots
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过插槽传递动态内容
- en: When building complex applications, one size doesn’t always fit all. Balancing
    between a component’s modularity and a component’s flexibility for customization
    is crucial.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建复杂应用程序时，一种大小并不总是适合所有情况。在组件的模块化和定制灵活性之间取得平衡是至关重要的。
- en: Take a generic `Card` component, for example. You might sometimes want to include
    special headlines, unique lists, or custom footers for specific use cases. It’s
    nearly impossible to anticipate every requirement, so it’s essential to design
    components that are both modular and maintainable, yet still open to customization.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个通用的`Card`组件为例。有时你可能希望为特定用例包含特殊的标题、独特的列表或自定义页脚。几乎不可能预见所有需求，因此设计既模块化又可维护的组件，同时仍然允许定制，是至关重要的。
- en: This is where Svelte’s slot feature shines. `Card` component that tries to include
    every possible feature, aim for a simple, clean base that can be enhanced through
    composition. This approach allows you to piece together more complex, customized
    components as your needs evolve.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Svelte 槽位功能大放异彩的地方。`Card` 组件旨在包含所有可能的功能，目标是简单、干净的基座，可以通过组合进行增强。这种方法允许您根据需求的变化，拼凑出更复杂、定制的组件。
- en: 'In a Svelte component, a `<slot>` element is a placeholder within your component
    where you can inject any type of content from a parent component. Here’s how you
    can define a slot inside a Svelte component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Svelte 组件中，一个 `<slot>` 元素是组件内的一个占位符，您可以在其中注入来自父组件的任何类型的内容。以下是您如何在 Svelte 组件中定义槽位的方法：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code snippet, we defined a `<slot>` element inside a `<div>`
    element. Any dynamic content from the parent component will be inserted into the
    `<``div>` element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在 `<div>` 元素内部定义了一个 `<slot>` 元素。任何来自父组件的动态内容都将插入到 `<div>` 元素中。
- en: 'Now, to pass dynamic content from a parent component into the slot of a child
    component, you need to place that content between the opening and closing tags
    of the child component:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将父组件中的动态内容传递到子组件的槽位中，您需要将该内容放置在子组件的开闭标签之间：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code snippet, we passed in a `<h1>` element between the opening and
    closing tags of the `<Card>` component. This effectively replaces the `<slot>`
    element in the `Card` component with the `<h1>` element we provide.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们在 `<Card>` 组件的开闭标签之间传递了一个 `<h1>` 元素。这实际上用我们提供的 `<h1>` 元素替换了 `Card`
    组件中的 `<slot>` 元素。
- en: There may be instances where you don’t need to pass dynamic content from a parent
    component to a child component’s slot. For these cases, Svelte allows you to define
    default content within the `<slot>` element, providing a fallback when no custom
    content is supplied by the parent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在不需要从父组件将动态内容传递到子组件槽位的情况。对于这些情况，Svelte 允许您在 `<slot>` 元素内定义默认内容，当父组件没有提供自定义内容时提供回退选项。
- en: Providing default slot content
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供默认槽位内容
- en: 'To provide default content for your `<slot>` element, you can place them inside
    the `<slot>` element, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的 `<slot>` 元素提供默认内容，您可以将它们放置在 `<slot>` 元素内部，如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, we defined `<div>`, containing the text `This
    is the default content` within the `<slot>` element. This serves as the default
    content for the slot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了 `<div>`，其中包含 `<slot>` 元素内的文本 `This is the default content`。这作为槽位的默认内容。
- en: 'When you use this `Card` component in a parent component and don’t provide
    content for the slot, as shown in the following code snippet, the default text
    will automatically appear:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在父组件中使用此 `Card` 组件且不提供槽位内容时，如以下代码片段所示，默认文本将自动出现：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By utilizing the default content in slots, you can create more flexible Svelte
    components that offer sensible fallbacks when no custom content is provided.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用槽位的默认内容，您可以创建更灵活的 Svelte 组件，当没有提供自定义内容时，提供合理的回退选项。
- en: In the examples we’ve seen so far, we’ve been limited to inserting dynamic content
    from the parent component into just one spot. But what if we wanted multiple insertion
    points for dynamic content? Let’s explore how to achieve that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止看到的示例中，我们被限制为仅将来自父组件的动态内容插入到一个位置。但如果我们想要多个动态内容插入点怎么办？让我们探索如何实现这一点。
- en: Having multiple slots with named slots
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有多个带有命名槽位的槽位
- en: Slots are amazing, and you are not limited to a single slot either. You can
    define multiple slots in a component and name them to target specific areas for
    dynamic content.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 槽位非常出色，您也不限于单个槽位。您可以在组件中定义多个槽位并为它们命名，以针对特定的动态内容区域。
- en: 'You can use the `name` attribute on the `<slot>` element to give the slot a
    name, as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `<slot>` 元素上的 `name` 属性来为槽位命名，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous code snippet, we defined two named slots, one named `"header"`
    and another named `"footer"`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了两个命名槽位，一个命名为 `"header"`，另一个命名为 `"footer"`。
- en: 'To target the dynamic content into these named slots, you will need to use
    the `<svelte:fragment>` element in the parent component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要将动态内容针对这些命名槽位，您需要在父组件中使用 `<svelte:fragment>` 元素：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we pass two `<svelte:fragment>` elements into the `Card` component. The
    first has a slot attribute set to `"header"`, and the second slot attribute is
    set to `"footer"`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向 `Card` 组件传递了两个 `<svelte:fragment>` 元素。第一个具有槽位属性设置为 `"header"`，第二个槽位属性设置为
    `"footer"`。
- en: The name specified in the `slot` attribute will correspond with the named slots
    within the `Card` component. The content within `<svelte:fragment slot="header">`
    replaces the `<slot name="header">` in the `Card` component. Similarly, the content
    within `<svelte:fragment slot="footer">` takes the place of `<slot name="footer">`
    in the component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`slot`属性中指定的名称将与`Card`组件内的命名插槽相对应。在`<svelte:fragment slot="header">`内的内容替换了`Card`组件中的`<slot
    name="header">`。同样，在`<svelte:fragment slot="footer">`内的内容取代了组件中的`<slot name="footer">`。
- en: Sometimes, you will want the dynamic content from the parent component to be
    aware of the data within the child component. To handle this scenario, Svelte
    offers a feature known as slot props, which allows you to pass data from the child
    component to the content in the slot. Let’s explore how this works.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望父组件的动态内容了解子组件中的数据。为了处理这种情况，Svelte提供了一个称为插槽属性的功能，允许你从子组件将数据传递到插槽中的内容。让我们看看它是如何工作的。
- en: Passing data through slot props
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过插槽属性传递数据
- en: 'You can pass data from the child component back to the dynamic content in the
    parent component using slot props, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用插槽属性，如下所示，从子组件将数据传递回父组件中的动态内容：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code example, we passed in two additional attributes to the `<slot>`
    element besides the `name` attribute, which is used to name the slot. These additional
    attributes, `width` and `height`, serve as slot props; their values can be accessed
    in the parent component when you create dynamic content.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们除了传递了用于命名插槽的`name`属性外，还向`<slot>`元素传递了两个额外的属性。这些额外的属性，`width`和`height`，作为插槽属性；它们的值可以在创建动态内容时在父组件中访问。
- en: 'Here is an example of how you can use these slot prop values when using `<svelte:fragment>`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，说明你如何在使用`<svelte:fragment>`时使用这些插槽属性值：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, you can see that we use `let:width` and `let:height`
    within the `<svelte:fragment>` element. These are called `let:` bindings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到我们在`<svelte:fragment>`元素内部使用了`let:width`和`let:height`。这些被称为`let:`绑定。
- en: The `let:` bindings allow us to access the `width` and `height` slot props provided
    by the child `Card` component. The values for the width and height are then used
    within an `<h1>` element to display the dimensions. This way, we can dynamically
    adjust content in the parent component, based on data originating from the child
    component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`let:`绑定使我们能够访问由子`Card`组件提供的`width`和`height`插槽属性。然后，这些宽度和高度的值在`<h1>`元素中使用，以显示尺寸。这样，我们可以根据来自子组件的数据动态调整父组件中的内容。'
- en: Now that we have covered how to pass dynamic content through slots, how to define
    multiple-named slots, and how to pass data from a child component to the dynamic
    slot content in a parent component, you are well equipped to create more versatile
    and reusable Svelte components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了如何通过插槽传递动态内容、如何定义多个命名的插槽以及如何将子组件中的数据传递给父组件中的动态插槽内容，你现在已经具备了创建更灵活和可重用Svelte组件的能力。
- en: Renderless component
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 无渲染组件
- en: One of many common patterns to compose components using slots is the Renderless
    component pattern. This technique allows you to build components that are purely
    functional, leaving the presentation details to the parent component. We have
    dedicated [*Chapter 11*](B18887_11.xhtml#_idTextAnchor163) to delving into this
    fascinating topic.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插槽组合组件的许多常见模式之一是无渲染组件模式。这种技术允许你构建纯函数组件，将展示细节留给父组件。我们专门在[*第11章*](B18887_11.xhtml#_idTextAnchor163)中深入探讨了这一迷人的主题。
- en: Now that we’ve explored how to pass dynamic content through slots, let’s dive
    into another exciting feature of Svelte that lets you dynamically render different
    element or component types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何通过插槽传递动态内容，接下来让我们深入了解Svelte的另一个令人兴奋的特性，它允许你动态渲染不同的元素或组件类型。
- en: Rendering different HTML element or component types
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染不同的HTML元素或组件类型
- en: In any dynamic application, there comes a time when you need even more flexibility
    than what static components or elements offer. What if you don’t know the type
    of element or component you’ll need to render until runtime?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何动态应用程序中，都会有一个时刻你需要比静态组件或元素提供的更多灵活性。假设你在运行时才知道需要渲染的元素或组件的类型呢？
- en: Let’s imagine that you’re building a form generator, and the type of form field
    – whether it’s `<Input>`, `<Checkbox>`, or `<Select>` – is determined by dynamic
    data. How could you switch between these components seamlessly, especially when
    they share the same set of props?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设您正在构建一个表单生成器，表单字段的类型——无论是 `<Input>`、`<Checkbox>` 还是 `<Select>`——由动态数据决定。您如何在这些组件之间无缝切换，尤其是当它们共享同一组属性时？
- en: 'One straightforward approach is to use Svelte’s `{#if}` blocks to conditionally
    render the component you need. Here is an example code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是使用 Svelte 的 `{#if}` 块有条件地渲染所需的组件。以下是一个示例代码片段：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the code snippet, we use the `{#if}` blocks to choose among three different
    component types, passing the same prop values to each. If you find yourself needing
    to manage more component types, this could lead to a lengthy and hard-to-maintain
    series of conditional blocks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们使用 `{#if}` 块来选择三种不同的组件类型，并将相同的属性值传递给每个组件。如果您发现自己需要管理更多组件类型，这可能导致一系列冗长且难以维护的条件块。
- en: Is there a more efficient way to handle this?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有更有效的方法来处理这个问题？
- en: Svelte provides two specialized elements, `<svelte:element>` and `<svelte:component>`,
    precisely for this. The `<svelte:element>` element lets you create different HTML
    element types dynamically, based on variable data, whereas the `<svelte:component>`
    element lets you dynamically render different Svelte component types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 提供了两个专用元素，`<svelte:element>` 和 `<svelte:component>`，正是为了这个目的。`<svelte:element>`
    元素允许您根据变量数据动态创建不同的 HTML 元素类型，而 `<svelte:component>` 元素允许您动态渲染不同的 Svelte 组件类型。
- en: 'Here’s how you can rewrite the previous example using `<svelte:component>`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用 `<svelte:component>` 重新编写上一个示例的：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <Select value={value} onChange={onChange} />
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <Select value={value} onChange={onChange} />
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <script>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: let type = 'button'; // could be 'div', 'p', 'a', etc.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: let type = 'button'; // 可能是 'div', 'p', 'a' 等。
- en: </script>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: <svelte:element this={type}>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:element this={type}>
- en: Click Me
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 点击我
- en: </svelte:element>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: </svelte:element>
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: const folder = [
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: const folder = [
- en: '{ type: ''file'', name: ''a.js'' },'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '{ type: ''file'', name: ''a.js'' },'
- en: '{ type: ''file'', name: ''b.js'' },'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '{ type: ''file'', name: ''b.js'' },'
- en: '{ type: ''folder'', name: ''c'', children: ['
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '{ type: ''folder'', name: ''c'', children: ['
- en: '{ type: ''file'', name: ''d.js'' },'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '{ type: ''file'', name: ''d.js'' },'
- en: ']},'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ']},'
- en: '];'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '];'
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <script>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: export let folder;
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: export let folder;
- en: </script>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: <ul>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <ul>
- en: '{#each folder as item}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '{#each folder as item}'
- en: <li>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <li>
- en: '{#if item.type === ''file''}'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '{#if item.type === ''file''}'
- en: '<div>File: {item.name}</div>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>文件: {item.name}</div>'
- en: '{:else}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '{:else}'
- en: '<div>Folder: {item.name}</div>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>文件夹: {item.name}</div>'
- en: <ul>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <ul>
- en: '{#each item.children as child}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '{#each item.children as child}'
- en: <li>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <li>
- en: '{#if child.type === ''file''}'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '{#if child.type === ''file''}'
- en: '<div>File: {child.name}</div>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>文件: {child.name}</div>'
- en: '{:else}'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '{:else}'
- en: '...'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '{/if}'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '{/if}'
- en: </li>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: </li>
- en: '{/each}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each}'
- en: </ul>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: </ul>
- en: '{/if}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '{/if}'
- en: </li>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: </li>
- en: '{/each}'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each}'
- en: </ul>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <script>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: export let folder;
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: export let folder;
- en: </script>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: <ul>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <ul>
- en: '{#each folder as item}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each folder as item}'
- en: <li>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <li>
- en: '{#if item.type === ''file''}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '{#if item.type === ''file''}'
- en: '<div>File: {item.name}</div>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>文件: {item.name}</div>'
- en: '{:else}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '{:else}'
- en: '<div>Folder: {item.name}</div>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '<div>文件夹: {item.name}</div>'
- en: <svelte:self folder={item.children} />
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:self folder={item.children} />
- en: '{/if}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '{/if}'
- en: </li>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: </li>
- en: '{/each}'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each}'
- en: </ul>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<!-- filename: JsonTree.svelte -->'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '<!-- filename: JsonTree.svelte -->'
- en: <script>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: export let data;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: export let data;
- en: </script>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: <ul>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <ul>
- en: '{#each Object.entries(data) as [key, value]}'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '{#each Object.entries(data) as [key, value]}'
- en: '<li>{key}: {value}<li>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '<li>{key}: {value}<li>'
- en: '{/each}'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each}'
- en: </ul>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: data = {
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: data = {
- en: 'name: ''John Doe'','
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: ''John Doe'','
- en: 'address: {'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'address: {'
- en: 'street: ''123 Main St'''
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'street: ''123 Main St'''
- en: '},'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<!-- filename: JsonTree.svelte -->'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '<!-- filename: JsonTree.svelte -->'
- en: <script>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: export let data;
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: export let data;
- en: </script>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: <ul>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <ul>
- en: '{#each Object.entries(data) as [key, value]}'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '{#each Object.entries(data) as [key, value]}'
- en: <li>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <li>
- en: '{key}:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '{key}:'
- en: '{#if typeof value === ''object''}'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '{#if typeof value === ''object''}'
- en: <svelte:self data={value} />
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:self data={value} />
- en: '{:else}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '{:else}'
- en: '{value}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '{value}'
- en: '{/if}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '{/if}'
- en: <li>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <li>
- en: '{/each}'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each}'
- en: </ul>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <script>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <script>
- en: import StringValue from './StringValue.svelte';
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: import StringValue from './StringValue.svelte';
- en: import NumberValue from './NumberValue.svelte';
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: import NumberValue from './NumberValue.svelte';
- en: import JsonValue from './JsonValue.svelte';
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: import JsonValue from './JsonValue.svelte';
- en: export let data;
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: export let data;
- en: function getComponent(type) {
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: function getComponent(type) {
- en: if (type === 'string') return StringValue;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: if (type === 'string') return StringValue;
- en: if (type === 'number') return NumberValue;
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: if (type === 'number') return NumberValue;
- en: return JsonValue;
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: return JsonValue;
- en: '}'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: </script>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: </script>
- en: <ul>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <ul>
- en: '{#each Object.entries(data) as [key, value]}'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '{#each Object.entries(data) as [key, value]}'
- en: <li>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <li>
- en: '{key}:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '{key}:'
- en: '{#if typeof value === ''object''}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '{#if typeof value === ''object''}'
- en: <svelte:self data={value} />
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:self data={value} />
- en: '{:else}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '{:else}'
- en: <svelte:component this={getComponent(typeof value)} value={value} />
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:component this={getComponent(typeof value)} value={value} />
- en: '{/if}'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '{/if}'
- en: </li>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: </li>
- en: '{/each}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each}'
- en: </ul>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <ul>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <ul>
- en: '{#each Object.entries(data) as [key, value]}'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '{#each Object.entries(data) as [key, value]}'
- en: <li>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <li>
- en: <slot name="obj-key" key={key}>{key}:<slot>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <slot name="obj-key" key={key}>{key}:<slot>
- en: '{#if typeof value === ''object''}'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '{#if typeof value === ''object''}'
- en: <svelte:self data={value} />
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:self data={value} />
- en: '{:else}'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '{:else}'
- en: <slot name="obj-value" value={value}>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <slot name="obj-value" value={value}>
- en: <svelte:component this={getComponent(typeof value)} value={value} />
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:component this={getComponent(typeof value)} value={value} />
- en: </slot>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: </slot>
- en: '{/if}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '{/if}'
- en: </li>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: </li>
- en: '{/each}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '{/each}'
- en: </ul>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<JsonTree data={{a: 1, b: 2}}>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '<JsonTree data={{a: 1, b: 2}}>'
- en: <svelte:fragment slot="obj-key" let:key>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:fragment slot="obj-key" let:key>
- en: <em>{key}</em>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <em>{key}</em>
- en: </svelte:fragment>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: </svelte:fragment>
- en: <svelte:fragment slot="obj-value" let:value>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <svelte:fragment slot="obj-value" let:value>
- en: <u>{value}</u>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <u>{value}</u>
- en: </svelte:fragment>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: </svelte:fragment>
- en: </JsonTree>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: </JsonTree>
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Part 2: Actions'
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：动作
- en: In this part, we embark on a journey to learn about Svelte actions. Across three
    chapters, we will delve into three different use cases of Svelte actions. Starting
    with the creation of custom events using actions, we’ll progress to integrating
    third-party JavaScript libraries with Svelte via actions. Finally, we’ll unveil
    techniques to progressively enhance our applications, harnessing the power of
    Svelte actions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将开始学习Svelte动作。在三个章节中，我们将深入研究Svelte动作的三个不同用例。从使用动作创建自定义事件开始，我们将逐步过渡到通过动作将第三方JavaScript库与Svelte整合。最后，我们将揭示利用Svelte动作的力量来渐进式增强我们应用程序的技术。
- en: 'This part has the following chapters:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B18887_05.xhtml#_idTextAnchor080), *Custom Events with Actions*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18887_05.xhtml#_idTextAnchor080), *使用动作创建自定义事件*'
- en: '[*Chapter 6*](B18887_06.xhtml#_idTextAnchor091), *Integrating Libraries with
    Actions*'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18887_06.xhtml#_idTextAnchor091), *使用动作整合库*'
- en: '[*Chapter 7*](B18887_07.xhtml#_idTextAnchor108), *Progressive Enhancements
    with Svelte Actions*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18887_07.xhtml#_idTextAnchor108), *使用Svelte动作进行渐进式增强*'
