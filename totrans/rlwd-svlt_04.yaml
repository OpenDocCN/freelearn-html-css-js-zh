- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your application grows, cramming all the logic into a single component becomes
    impractical. You’ll need to split your app into smaller, modular components and
    assemble them to form a more complex application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore various techniques to combine components effectively.
    We’ll start by examining how to inject custom content into a component using slots.
    Then, we’ll discuss how to conditionally render different HTML elements within
    a component. We’ll also delve into recursive components, useful for displaying
    nested or hierarchical data.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll guide you through each topic with hands-on examples, ensuring the techniques
    you learn are both practical and applicable in real-world scenarios. By the end
    of this chapter, you’ll have a richer set of strategies to compose components
    in your Svelte applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating how a child component looks from the perspective of its parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing dynamic content through slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering different HTML element and component types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating recursive components for recursive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Container/Presentational pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s kick things off by exploring the various ways we can manipulate and control
    the content of a child component.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code in this chapter can be found at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating how a child component looks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re combining multiple components, you’ll need to manage how each child
    component appears and behaves. Even though a child component handles its own display
    and logic, it still offers controls to tweak its appearance and behavior. From
    the perspective of the parent component, you’ll want to coordinate these child
    components to achieve the desired overall functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore various ways to control the look of child components,
    ranging from the most to the least commonly used methods. Understanding these
    options will equip you with the tools to make your components both versatile and
    effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of options to control how the child component looks includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling through props**: This is perhaps the most straightforward way
    to influence the behavior and appearance of a child component. By passing props
    from a parent component to a child, you can make your child component highly dynamic
    and responsive to external changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate how a parent component can control content using props in Svelte,
    consider the following code example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the parent component has the ability to dictate the text shown
    in the `Child` component by modifying the `message` prop’s value. Controlling
    props is a simple yet effective way to manipulate a child component’s content.
    If you’re interested in learning more about props, we covered the topic extensively
    in [*Chapter 3*](B18887_03.xhtml#_idTextAnchor051).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`parent` component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code, we established a context named `message` with the `'Hello
    from parent'` value, using `setContext`. Then, we imported and used the `Child`
    component without sending any props to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is the code for the `Child` component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `getContext` is used to read the `message` context value, which is then
    displayed within a `<p>` element. As demonstrated, the parent component can influence
    the text in the child component’s `<p>` element by changing the context value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a deeper dive into Svelte’s context feature, you can refer to [*Chapter
    8*](B18887_08.xhtml#_idTextAnchor121), where we will explore the topic in greater
    detail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Controlling the styles**: Manipulating a child component’s appearance isn’t
    solely about controlling the data passed to it. It also involves tweaking or modifying
    its styles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can modify a component style through CSS custom properties. This approach
    allows for greater design flexibility, and it ensures that child components can
    adapt to various contexts or themes within the parent component or the broader
    application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For an in-depth discussion on how to alter a component’s style using CSS custom
    properties, feel free to refer to [*Chapter 2*](B18887_02.xhtml#_idTextAnchor032).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Passing dynamic content through slot**: Svelte’s slot feature allows you
    to insert custom content into specific areas of a child component. This provides
    a flexible way to have greater control over a component’s content without modifying
    its internal behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk about slots and how to use them in the following section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, there are various ways to shape a child component’s appearance
    and behavior. When we compose different components within a parent component,
    the goal is to make them work together in a coordinated way. You can use a combination
    of the approaches discussed to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these methods will be covered in separate chapters, and in the following
    section, we’ll focus on how to dynamically alter a child component’s look by passing
    content through slots.
  prefs: []
  type: TYPE_NORMAL
- en: Passing dynamic content through slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building complex applications, one size doesn’t always fit all. Balancing
    between a component’s modularity and a component’s flexibility for customization
    is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Take a generic `Card` component, for example. You might sometimes want to include
    special headlines, unique lists, or custom footers for specific use cases. It’s
    nearly impossible to anticipate every requirement, so it’s essential to design
    components that are both modular and maintainable, yet still open to customization.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Svelte’s slot feature shines. `Card` component that tries to include
    every possible feature, aim for a simple, clean base that can be enhanced through
    composition. This approach allows you to piece together more complex, customized
    components as your needs evolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Svelte component, a `<slot>` element is a placeholder within your component
    where you can inject any type of content from a parent component. Here’s how you
    can define a slot inside a Svelte component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we defined a `<slot>` element inside a `<div>`
    element. Any dynamic content from the parent component will be inserted into the
    `<``div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to pass dynamic content from a parent component into the slot of a child
    component, you need to place that content between the opening and closing tags
    of the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we passed in a `<h1>` element between the opening and
    closing tags of the `<Card>` component. This effectively replaces the `<slot>`
    element in the `Card` component with the `<h1>` element we provide.
  prefs: []
  type: TYPE_NORMAL
- en: There may be instances where you don’t need to pass dynamic content from a parent
    component to a child component’s slot. For these cases, Svelte allows you to define
    default content within the `<slot>` element, providing a fallback when no custom
    content is supplied by the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Providing default slot content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To provide default content for your `<slot>` element, you can place them inside
    the `<slot>` element, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we defined `<div>`, containing the text `This
    is the default content` within the `<slot>` element. This serves as the default
    content for the slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use this `Card` component in a parent component and don’t provide
    content for the slot, as shown in the following code snippet, the default text
    will automatically appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By utilizing the default content in slots, you can create more flexible Svelte
    components that offer sensible fallbacks when no custom content is provided.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples we’ve seen so far, we’ve been limited to inserting dynamic content
    from the parent component into just one spot. But what if we wanted multiple insertion
    points for dynamic content? Let’s explore how to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Having multiple slots with named slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slots are amazing, and you are not limited to a single slot either. You can
    define multiple slots in a component and name them to target specific areas for
    dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `name` attribute on the `<slot>` element to give the slot a
    name, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, we defined two named slots, one named `"header"`
    and another named `"footer"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To target the dynamic content into these named slots, you will need to use
    the `<svelte:fragment>` element in the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass two `<svelte:fragment>` elements into the `Card` component. The
    first has a slot attribute set to `"header"`, and the second slot attribute is
    set to `"footer"`.
  prefs: []
  type: TYPE_NORMAL
- en: The name specified in the `slot` attribute will correspond with the named slots
    within the `Card` component. The content within `<svelte:fragment slot="header">`
    replaces the `<slot name="header">` in the `Card` component. Similarly, the content
    within `<svelte:fragment slot="footer">` takes the place of `<slot name="footer">`
    in the component.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will want the dynamic content from the parent component to be
    aware of the data within the child component. To handle this scenario, Svelte
    offers a feature known as slot props, which allows you to pass data from the child
    component to the content in the slot. Let’s explore how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data through slot props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can pass data from the child component back to the dynamic content in the
    parent component using slot props, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the code example, we passed in two additional attributes to the `<slot>`
    element besides the `name` attribute, which is used to name the slot. These additional
    attributes, `width` and `height`, serve as slot props; their values can be accessed
    in the parent component when you create dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you can use these slot prop values when using `<svelte:fragment>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see that we use `let:width` and `let:height`
    within the `<svelte:fragment>` element. These are called `let:` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: The `let:` bindings allow us to access the `width` and `height` slot props provided
    by the child `Card` component. The values for the width and height are then used
    within an `<h1>` element to display the dimensions. This way, we can dynamically
    adjust content in the parent component, based on data originating from the child
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered how to pass dynamic content through slots, how to define
    multiple-named slots, and how to pass data from a child component to the dynamic
    slot content in a parent component, you are well equipped to create more versatile
    and reusable Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: Renderless component
  prefs: []
  type: TYPE_NORMAL
- en: One of many common patterns to compose components using slots is the Renderless
    component pattern. This technique allows you to build components that are purely
    functional, leaving the presentation details to the parent component. We have
    dedicated [*Chapter 11*](B18887_11.xhtml#_idTextAnchor163) to delving into this
    fascinating topic.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored how to pass dynamic content through slots, let’s dive
    into another exciting feature of Svelte that lets you dynamically render different
    element or component types.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering different HTML element or component types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any dynamic application, there comes a time when you need even more flexibility
    than what static components or elements offer. What if you don’t know the type
    of element or component you’ll need to render until runtime?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that you’re building a form generator, and the type of form field
    – whether it’s `<Input>`, `<Checkbox>`, or `<Select>` – is determined by dynamic
    data. How could you switch between these components seamlessly, especially when
    they share the same set of props?
  prefs: []
  type: TYPE_NORMAL
- en: 'One straightforward approach is to use Svelte’s `{#if}` blocks to conditionally
    render the component you need. Here is an example code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, we use the `{#if}` blocks to choose among three different
    component types, passing the same prop values to each. If you find yourself needing
    to manage more component types, this could lead to a lengthy and hard-to-maintain
    series of conditional blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a more efficient way to handle this?
  prefs: []
  type: TYPE_NORMAL
- en: Svelte provides two specialized elements, `<svelte:element>` and `<svelte:component>`,
    precisely for this. The `<svelte:element>` element lets you create different HTML
    element types dynamically, based on variable data, whereas the `<svelte:component>`
    element lets you dynamically render different Svelte component types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can rewrite the previous example using `<svelte:component>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <Select value={value} onChange={onChange} />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: let type = 'button'; // could be 'div', 'p', 'a', etc.
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:element this={type}>
  prefs: []
  type: TYPE_NORMAL
- en: Click Me
  prefs: []
  type: TYPE_NORMAL
- en: </svelte:element>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: const folder = [
  prefs: []
  type: TYPE_NORMAL
- en: '{ type: ''file'', name: ''a.js'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ type: ''file'', name: ''b.js'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ type: ''folder'', name: ''c'', children: ['
  prefs: []
  type: TYPE_NORMAL
- en: '{ type: ''file'', name: ''d.js'' },'
  prefs: []
  type: TYPE_NORMAL
- en: ']},'
  prefs: []
  type: TYPE_NORMAL
- en: '];'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let folder;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{#each folder as item}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>
  prefs: []
  type: TYPE_NORMAL
- en: '{#if item.type === ''file''}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>File: {item.name}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '{:else}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>Folder: {item.name}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{#each item.children as child}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>
  prefs: []
  type: TYPE_NORMAL
- en: '{#if child.type === ''file''}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>File: {child.name}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '{:else}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '{/if}'
  prefs: []
  type: TYPE_NORMAL
- en: </li>
  prefs: []
  type: TYPE_NORMAL
- en: '{/each}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{/if}'
  prefs: []
  type: TYPE_NORMAL
- en: </li>
  prefs: []
  type: TYPE_NORMAL
- en: '{/each}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let folder;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{#each folder as item}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>
  prefs: []
  type: TYPE_NORMAL
- en: '{#if item.type === ''file''}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>File: {item.name}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: '{:else}'
  prefs: []
  type: TYPE_NORMAL
- en: '<div>Folder: {item.name}</div>'
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:self folder={item.children} />
  prefs: []
  type: TYPE_NORMAL
- en: '{/if}'
  prefs: []
  type: TYPE_NORMAL
- en: </li>
  prefs: []
  type: TYPE_NORMAL
- en: '{/each}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: JsonTree.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let data;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{#each Object.entries(data) as [key, value]}'
  prefs: []
  type: TYPE_NORMAL
- en: '<li>{key}: {value}<li>'
  prefs: []
  type: TYPE_NORMAL
- en: '{/each}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: data = {
  prefs: []
  type: TYPE_NORMAL
- en: 'name: ''John Doe'','
  prefs: []
  type: TYPE_NORMAL
- en: 'address: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'street: ''123 Main St'''
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<!-- filename: JsonTree.svelte -->'
  prefs: []
  type: TYPE_NORMAL
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: export let data;
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{#each Object.entries(data) as [key, value]}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>
  prefs: []
  type: TYPE_NORMAL
- en: '{key}:'
  prefs: []
  type: TYPE_NORMAL
- en: '{#if typeof value === ''object''}'
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:self data={value} />
  prefs: []
  type: TYPE_NORMAL
- en: '{:else}'
  prefs: []
  type: TYPE_NORMAL
- en: '{value}'
  prefs: []
  type: TYPE_NORMAL
- en: '{/if}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>
  prefs: []
  type: TYPE_NORMAL
- en: '{/each}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <script>
  prefs: []
  type: TYPE_NORMAL
- en: import StringValue from './StringValue.svelte';
  prefs: []
  type: TYPE_NORMAL
- en: import NumberValue from './NumberValue.svelte';
  prefs: []
  type: TYPE_NORMAL
- en: import JsonValue from './JsonValue.svelte';
  prefs: []
  type: TYPE_NORMAL
- en: export let data;
  prefs: []
  type: TYPE_NORMAL
- en: function getComponent(type) {
  prefs: []
  type: TYPE_NORMAL
- en: if (type === 'string') return StringValue;
  prefs: []
  type: TYPE_NORMAL
- en: if (type === 'number') return NumberValue;
  prefs: []
  type: TYPE_NORMAL
- en: return JsonValue;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: </script>
  prefs: []
  type: TYPE_NORMAL
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{#each Object.entries(data) as [key, value]}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>
  prefs: []
  type: TYPE_NORMAL
- en: '{key}:'
  prefs: []
  type: TYPE_NORMAL
- en: '{#if typeof value === ''object''}'
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:self data={value} />
  prefs: []
  type: TYPE_NORMAL
- en: '{:else}'
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:component this={getComponent(typeof value)} value={value} />
  prefs: []
  type: TYPE_NORMAL
- en: '{/if}'
  prefs: []
  type: TYPE_NORMAL
- en: </li>
  prefs: []
  type: TYPE_NORMAL
- en: '{/each}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <ul>
  prefs: []
  type: TYPE_NORMAL
- en: '{#each Object.entries(data) as [key, value]}'
  prefs: []
  type: TYPE_NORMAL
- en: <li>
  prefs: []
  type: TYPE_NORMAL
- en: <slot name="obj-key" key={key}>{key}:<slot>
  prefs: []
  type: TYPE_NORMAL
- en: '{#if typeof value === ''object''}'
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:self data={value} />
  prefs: []
  type: TYPE_NORMAL
- en: '{:else}'
  prefs: []
  type: TYPE_NORMAL
- en: <slot name="obj-value" value={value}>
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:component this={getComponent(typeof value)} value={value} />
  prefs: []
  type: TYPE_NORMAL
- en: </slot>
  prefs: []
  type: TYPE_NORMAL
- en: '{/if}'
  prefs: []
  type: TYPE_NORMAL
- en: </li>
  prefs: []
  type: TYPE_NORMAL
- en: '{/each}'
  prefs: []
  type: TYPE_NORMAL
- en: </ul>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<JsonTree data={{a: 1, b: 2}}>'
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:fragment slot="obj-key" let:key>
  prefs: []
  type: TYPE_NORMAL
- en: <em>{key}</em>
  prefs: []
  type: TYPE_NORMAL
- en: </svelte:fragment>
  prefs: []
  type: TYPE_NORMAL
- en: <svelte:fragment slot="obj-value" let:value>
  prefs: []
  type: TYPE_NORMAL
- en: <u>{value}</u>
  prefs: []
  type: TYPE_NORMAL
- en: </svelte:fragment>
  prefs: []
  type: TYPE_NORMAL
- en: </JsonTree>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Part 2: Actions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we embark on a journey to learn about Svelte actions. Across three
    chapters, we will delve into three different use cases of Svelte actions. Starting
    with the creation of custom events using actions, we’ll progress to integrating
    third-party JavaScript libraries with Svelte via actions. Finally, we’ll unveil
    techniques to progressively enhance our applications, harnessing the power of
    Svelte actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18887_05.xhtml#_idTextAnchor080), *Custom Events with Actions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18887_06.xhtml#_idTextAnchor091), *Integrating Libraries with
    Actions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18887_07.xhtml#_idTextAnchor108), *Progressive Enhancements
    with Svelte Actions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
