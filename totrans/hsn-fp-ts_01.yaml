- en: Functional Programming Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been a multi-paradigm programming language since its inception
    back in 1995\. It allows us to take advantage of an **object-oriented programming**
    (**OOP**) style along with a functional programming style. The same can be said
    of TypeScript. However, for functional programming, TypeScript is even better
    suited than JavaScript because, as we will learn in this chapter, static type
    systems and type inference are both very important features in functional programming
    languages such as the ML family of programming languages, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript and TypeScript ecosystems have experienced a significant increase
    in interest in functional programming over the last few years. I believe that
    this increase in interest can be attributed to the success of React. React is
    a library developed by Facebook for building user interfaces, and it is highly
    influenced by some core functional programming concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on learning some of the most basic functional
    programming concepts and principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The main characteristics of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main benefits of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: side-effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laziness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is TypeScript a functional programming language?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answer to this question is yes, but only in part. TypeScript is a multi-paradigm
    programming language and, as a result, it includes many influences from both OOP
    languages and functional programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we focus on TypeScript as a functional programming language, we
    can observe that it is not a purely functional programming language because, for
    example, the TypeScript compiler doesn't force our code to be free of side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: Not being a purely functional programming language should not be interpreted
    as something negative. TypeScript provides us with an extensive set of features
    that allow us to take advantage of some of the best features of the world of OOP
    languages and the world of functional programming languages. This has allowed
    TypeScript-type systems to attain a very good compromise between productivity
    and formality.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing TypeScript code using a functional programming style has many benefits,
    among which we can highlight the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Our code is testable:** If we try to write our functions as pure functions,
    we will be able to write unit tests extremely easily. We will learn more about
    pure functions later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Our code is easy to reason about:** Functional programming can seem hard
    to understand for developers with a lack of experience in functional programming.
    However, when an application is implemented correctly using the functional programming
    paradigm, the results are very small functions (often one-line functions) and
    very declarative APIs that can be reasoned about with ease. Also, pure functions
    only work with their arguments, which means that when we want to understand what
    a function does, we only need to examine the function itself and we don''t need
    to be concerned about any other external variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency: **Most of our functions are stateless, and our code is mostly
    stateless. We push state out of the core of our application, which makes our applications
    much more likely to be able to support many concurrent operations and it will
    be more scalable. We will learn more about stateless code later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simpler caching:** Caching strategies to cache results become much simpler
    when we can predict the output of a function given its arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional programming** (**FP**) is a programming paradigm that receives
    its name from the way we build applications when we use it. In a programming paradigm
    such as OOP, the main building blocks that we use to create an application are
    objects (objects are declared using classes). However, in FP, we use functions
    as the main building block in our applications**.**'
  prefs: []
  type: TYPE_NORMAL
- en: Each new programming paradigm introduces a series of concepts and ideas associated
    with it. Some of these concepts are universal and are also of interest while learning
    a different programming paradigm. In OOP, we have concepts such as inheritance,
    encapsulation, and polymorphism. In functional programming, concepts include higher-order
    functions, function partial application, immutability, and referential transparency.
    We are going to examine some of these concepts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Michael Feathers**, the author of the SOLID acronym and many other well-known
    software engineering principles, once wrote the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Object-oriented programming makes code understandable by encapsulating moving
    parts. Functional programming makes code understandable by minimizing moving parts."'
  prefs: []
  type: TYPE_NORMAL
- en: – *Michael Feathers*
  prefs: []
  type: TYPE_NORMAL
- en: The preceding quote mentions moving parts. We should understand these moving
    parts as **state changes** (also known as **state mutations**). In OOP, we use
    encapsulation to prevent objects from being aware of the state mutations of other
    objects. In functional programming, we try to avoid dealing with state mutations
    instead of encapsulating them.
  prefs: []
  type: TYPE_NORMAL
- en: FP reduces the number of places in which state changes take place within an
    application and tries to move these places into the boundaries of the application
    to try to keep the application's core stateless.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mutable state is bad because it makes the behavior of our code harder to
    predict. Take the following function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet declared a function named `isIndexPage`. This function
    can be used to check whether the current page is the root page in a web application
    based on the current path.
  prefs: []
  type: TYPE_NORMAL
- en: The path is some data that changes all the time, so we can consider it a piece
    of state. If we try to predict the result of invoking the `isIndexPage`, we will
    need to know the current state. The problem is that we could wrongly assume that
    the state has not changed since the last known state. We can solve this problem
    by transforming the preceding function into what is known in FP as a **pure function**,
    as we will learn in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FP introduces a number of concepts and principles that will help us to improve
    the predictability of our code. In this section, we are going to learn about one
    of these core concepts—pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: A function can be considered pure when it returns a value that is computed using
    only the arguments passed to it. Also, a pure function avoids mutating its arguments
    or any other external variables. As a result, a pure function always returns the
    same value given the same arguments, independently of when it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isIndexPage` function declared in the preceding section is not a pure
    function because it accesses the `pathname` variable, which has not been passed
    as an argument to the function. We can transform the preceding function into a
    pure function by rewriting it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Even though this is a basic example, we can easily perceive that the newer version
    is much easier to predict. Pure functions help us to make our code easier to understand,
    maintain, and test.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we wanted to write a unit test for the impure version of the `isIndexPage`
    function. We would encounter some problems when trying to write a test because
    the function uses the `window.location` object. We could overcome this issue by
    using a mocking framework, but it would add a lot of complexity to our unit tests
    just because we didn't use a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, testing the pure version of the `isIndexPage` function would
    be straightforward, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how functional programming helps us to write better code
    by avoiding state mutations, we can learn about side-effects and referential transparency.
  prefs: []
  type: TYPE_NORMAL
- en: side-effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we learned that a pure function returns a value that
    can be computed using only the arguments passed to it. A pure function also avoids
    mutating its arguments or any other external variable that is not passed to the
    function as an argument. In FP terminology, it is common to say that a pure function
    is a function that has no side-effects, which means that, when we invoke a pure
    function, we can expect that the function is not going to interfere (through a
    state mutation) with any other component in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Certain programming languages, such as Haskell, can ensure that an application
    is free of side-effects using their type system. TypeScript has fantastic interoperability
    with JavaScript, but the downside of this, compared to a more isolated language
    such as Haskell, is that the type system is not able to guarantee that our application
    is free from side-effects. However, we can use some FP techniques to improve the
    type safety of our TypeScript applications. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function returns a `number`. The code compiles without issues.
    The problem is that the function does not always return a `number`. As a result,
    we can consume the function as follows and our code will compile and throw an
    exception at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example showcases a new implementation of the preceding function.
    This time, instead of returning a number, we will explicitly return a promise.
    The promise forces us to then use the handler. This handler is only executed if
    the promise is fulfilled, which means that if the function returns an error, we
    will never try to convert the age to years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Promise` type helps us to prevent errors because it expresses potential
    errors in an explicit way. In programming languages such as Haskell, this is the
    default behavior of the type system, but, in programming languages such as TypeScript,
    it is up to us to use types in a safer way.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about Promises in [Chapter 3](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml),
    *Mastering Asynchronous Programming*. We will also learn more about how we can
    use a number of libraries to reduce the chances of side-effects in our TypeScript
    applications in [Chapter 8](ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml), *Category
    Theory*.
  prefs: []
  type: TYPE_NORMAL
- en: If you find the idea of your JavaScript applications being free of side-effects
    attractive, you can try open-source projects such as [https://github.com/bodil/eslint-config-cleanjs](https://github.com/bodil/eslint-config-cleanjs).
    This project is an ESLint configuration that aims to restrict you to a subset
    of JavaScript, which would be as close to an idealized pure functional language
    as possible. Unfortunately, at the time of publication, no similar tools are available
    that are specifically designed for TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Referential transparency is another concept closely related to pure functions
    and side-effects. A function is pure when it is free from side-effects. An expression
    is said to be referentially transparent when it can be replaced with its corresponding
    value without changing the application''s behavior. For example, if we are using
    the following in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the `isIndexPage` function is referentially transparent because
    it would be safe to substitute it for its return type. In this case, we know that
    when we invoke the `isIndexPage` function with `/` as an argument, the function
    will always return `true`, which means that it would be safe to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A pure function is a referentially transparent expression. An expression that
    is not referentially transparent is known as referentially opaque.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless versus stateful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions and referentially transparent expressions are stateless. A piece
    of code is stateless when its outcomes are not influenced by previous events.
    For example, the results of the `isIndexPage` function will not be influenced
    by the number of times that we invoke it, or by the moment in time when we invoke
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of stateless code is stateful code. Stateless code is very difficult
    to test and becomes a problem when we are trying to implement scalable and resilient
    systems. Resilient systems are systems that can handle server failures; there
    is usually more than one instance of a service, and if one of them crashes, others
    can continue handling traffic. Also, new instances are created automatically after
    one of the instances has crashed. This becomes very difficult if our servers are
    stateful because we need to save the current state before a crash and restore
    the state before we spin up a new instance. The whole process becomes much simpler
    when we design our servers to be stateless.
  prefs: []
  type: TYPE_NORMAL
- en: With the arrival of the cloud computing revolution, these kinds of system have
    become more common, and this has led to an interest in functional programming
    languages and design principles because functional programming encourages us to
    write stateless code. The opposite can be said of OOP because classes are the
    main construct in OOP applications. Classes encapsulate state properties that
    are then modified by methods, which encourages methods to be stateful and not
    pure.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative versus imperative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advocates of the FP paradigm often use declarative programming as one of
    its main benefits. Declarative programming is not necessarily exclusive to functional
    programming, but FP certainly encourages or facilitates this programming style.
    Before we take a look at some examples, we are going to define declarative programming
    and imperative programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative programming** is a programming paradigm that uses statements that
    change a program''s state. In much the same way that the imperative mood in natural
    languages expresses commands, an imperative program consists of commands for the
    computer to perform. Imperative programming focuses on describing how a program
    operates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative programming** is a programming paradigm that expresses the logic
    of a computation without describing its control flow. Many languages that apply
    this style attempt to minimize or eliminate side-effects by describing what the
    program must accomplish in terms of the problem domain, rather than describing
    how to accomplish it as a sequence of steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example calculates the average result of an exam given a collection
    of objects that contains an ID and a result for a list of students. This example
    uses an imperative programming style because, as we can see, it uses control flow
    statements (`for`). The example is also clearly imperative because it mutates
    a state. The `total` variable is declared using the `let` keyword because it is
    mutated as many times as results are contained in the `results` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following example is declarative because there are no
    control flow statements and there are no state mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the previous example is declarative, it is not as declarative as it could
    be. The following example takes the declarative style one step further so we can
    get an idea of how a piece of declarative code may appear. Don''t worry if you
    don''t understand everything in this example right now. We will be able to understand
    it once we learn more about functional programming techniques later in this book.
    Note how the program is now defined as a set of very small functions that don''t
    mutate the state and that also don''t use control flow statements. These functions
    are reusable because they are independent of the problem that we are trying to
    solve. For example, the `avg` function can calculate an average, but it doesn''t
    need to be an average of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual code that is specific to the problem that we are trying to solve
    is very small:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code is not reusable, but the `add`, `addMany`, `div`, `mapProp`, and `avg`
    functions are reusable. This demonstrates how declarative programming can lead
    to more reusable code than imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutability refers to the inability to change the value of a variable after
    a value has been assigned to it. Purely functional programming languages include
    immutable implementations of common data structures. For example, when we add
    an element to an array, we are mutating the original array. However, if we use
    an immutable array and we try to add a new element to it, the original array will
    not be mutated, and we will add the new item to a copy of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a class named `ImmutableList` that demonstrates
    how it is possible to implement an immutable array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we add an item to, or remove it from, the immutable array, we create
    a new instance of the immutable array. This implementation is very inefficient,
    but it demonstrates the basic idea. We are going to create a quick test to demonstrate
    how the preceding class works. We are going to use some data regarding superheroes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the preceding data to create a new immutable list instance.
    When we add a new superhero to the list, a new immutable list is created. If we
    try to search for the superhero `Hulk` in the two immutable lists, we will observe
    that only the second list contains it. We can also compare both lists to observe
    that they are two different objects, demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating our own immutable data structures is, in most cases, not necessary.
    In a real-world application, we can use libraries such as `Immutable.js` to enjoy
    immutable data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class citizens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is common to find mentions of functions as **first-class citizens** in the
    FP literature. We say that a function is a first-class citizen when it can do
    everything that a variable can do, which means that functions can be passed to
    other functions as an argument. For example, the following function takes a function
    as its second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it is returned by another function. For example, the following function
    takes a function as its only argument and returns a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can also be assigned to variables. For example, in the preceding
    code snippet, we assigned the function returned by the find function to a variable
    named `findSpiderman`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both JavaScript and TypeScript treat functions as first-class citizens.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda expressions are just expressions that can be used to declare anonymous
    functions (functions without a name). Before the ES6 specification, the only way
    to assign a function as a value to a variable was to use a function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The ES6 specification introduced the arrow function syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 2](5c1a8b07-e106-4ea8-a5e5-909e641eb271.xhtml), *Mastering
    Functions*, [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml), *The Runtime –
    The Event Loop and the this Operator*, and [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml),
    *The Runtime – Closures and Prototypes*, to learn more about arrow functions and
    function expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Function arity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **arity** of a function is the number of arguments that the function takes.
    A unary function is a function that only takes a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Unary functions are very important in functional programming because they facilitate
    utilization of the function composition pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about function composition patterns later in [Chapter 6](b9229d02-8eca-4ff7-a88f-e4ccb019270f.xhtml),
    *Functional Programming Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary function is a function that takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Functions with two or more arguments are also important because some of the
    most common FP patterns and techniques (for example, partial application and currying)
    have been designed to transform functions that allow multiple arguments into unary
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also functions with three (**ternary functions**) or more arguments.
    However, functions that accept a variable number of arguments, known as **variadic
    functions**, are particularly interesting in functional programming, as demonstrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A higher-order function is a function that does at least one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes one or more functions as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a function as its result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions are some of the most powerful tools that we can use to
    write JavaScript in a functional programming style. Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that waits for a given number of milliseconds before printing
    a message in the console. The function is considered a higher-order function because
    it returns a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that adds a delay in milliseconds to the execution of another
    function that is passed as an argument. The function is considered a higher-order
    function because it takes a function as an argument and returns a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Higher-order functions are an effective technique for abstracting a solution
    for a common problem. The preceding example demonstrates how we can use a higher-order
    function (`addDelay`) to add a delay to another function (`sayHello`). This technique
    allows us to abstract the delay functionality and keeps the `sayHello` function,
    or other functions, agnostic of the implementation details of the delay functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many functional programming languages feature lazy-evaluated APIs. The idea
    behind lazy evaluation is that operations are not computed until doing so can
    no longer be postponed. The following example declares a function that allows
    us to find an element in an array. When the function is invoked, we don''t filter
    the array. Instead, we declare a `proxy` and a `handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is only later, when one of the properties in the result is accessed, that
    the `proxy handler` is invoked and filtering takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we examine the console output, we will be able to see that the Filtering... message
    is not logged into the console until we access the property `name` of the `result` object.
    The preceding implementation is a very rudimentary implementation, but it can
    help us to understand how lazy evaluation works. Laziness can sometimes improve
    the overall performance of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about function composition patterns later in [Chapter 9](6a03c916-f7a5-439a-bea6-6facecef0347.xhtml),
    *Functional-Reactive Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored some of the most fundamental principles and concepts
    of the functional programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next four chapters, we are going to deviate a little bit from functional
    programming because we are going to take an extensive look at functions, asynchronous
    programming, and certain aspects of the TypeScript/JavaScript runtime, such as
    closures and prototypes. We need to explore these topics before we can learn more
    about the implementation of functional programming techniques. However, if you
    are already very confident with using functions, closures, the `this` operator,
    and prototypes, then you should be able to skip the next four chapters.
  prefs: []
  type: TYPE_NORMAL
