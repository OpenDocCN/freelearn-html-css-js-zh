<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Inheritance</h1></div></div></div><p>If you go back to <a class="link" href="ch01.html" title="Chapter 1. Object-Oriented JavaScript">Chapter 1</a>, <em>Object-Oriented JavaScript</em>, and review the <em>Object-oriented programming</em> section, you'll see that you already know how to apply most of them to JavaScript. You know what objects, methods, and properties are. You know that there are no classes in ES5, although you can achieve them using constructor functions. ES6 introduces the notion of classes; we will take a detailed look at how ES6 classes work in the next chapter. Encapsulation? Yes, the objects encapsulate both the data and the means (methods) to do something with the data. Aggregation? Sure, an object can contain other objects. In fact, this is almost always the case since methods are functions and functions are also objects.</p><p>Now, let's focus on the inheritance part. This is one of the most interesting features, as it allows you to reuse existing code, thus promoting laziness, which is likely to be what brought human species to computer programming in the first place.</p><p>JavaScript is a dynamic language, and there is usually more than one way to achieve any given task. Inheritance is not an exception. In this chapter, you'll see some common patterns for implementing inheritance. Having a good understanding of these patterns will help you pick the right one, or the right mix, depending on your task, project, or style.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Prototype chaining</h1></div></div></div><p>Let's start with the default way of implementing inheritance - inheritance chaining through the prototype.</p><p>As you already know, every function has a <code class="literal">prototype</code> property, which points to an object. When a function is invoked using the <code class="literal">new</code> operator, an object is created and returned. This new object has a secret link to the <code class="literal">prototype</code> object. The secret link (called <code class="literal">__proto__</code> in some environments) allows methods and properties of the <code class="literal">prototype</code> object to be used as if they belonged to the newly created object.</p><p>The <code class="literal">prototype</code> object is just a regular object and, therefore, it also has the secret link to its prototype. And so, a chain called a prototype chain is created:</p><p>
</p><div><img src="img/proto.jpg" alt="Prototype chaining"/></div><p>
</p><p>In this illustration, an object <strong>A</strong> contains a number of properties. One of the properties is the hidden <code class="literal">__proto__</code> property, which points to another object, <strong>B</strong>. <strong>B</strong>'s <code class="literal">__proto__</code> property points to <strong>C</strong>. This chain ends with the <code class="literal">Object.prototype</code> object, the grandparent, and every object inherits from it.</p><p>This is all good to know, but how does it help you? The practical side is that when object <strong>A</strong> lacks a property but <strong>B</strong> has it, <strong>A</strong> can still access this property as its own. The same applies if <strong>B</strong> also doesn't have the required property, but <strong>C</strong> does. This is how inheritance takes place - an object can access any property found somewhere down the inheritance chain.</p><p>Throughout this chapter, you'll see different examples that use the following hierarchy - a generic <code class="literal">Shape</code> parent is inherited by a <code class="literal">2D shape</code>, which in turn is inherited by any number of specific two-dimensional shapes such as a triangle, rectangle, and so on.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Prototype chaining example</h2></div></div></div><p>Prototype chaining is the default way to implement inheritance. In order to implement the hierarchy, let's define three constructor functions:</p><pre class="programlisting">    function Shape(){ &#13;
    this.name = 'Shape'; &#13;
    this.toString = function () { &#13;
        return this.name; &#13;
      }; &#13;
    } &#13;
 &#13;
    function TwoDShape(){ &#13;
      this.name = '2D shape'; &#13;
    } &#13;
 &#13;
    function Triangle(side, height){ &#13;
      this.name = 'Triangle'; &#13;
      this.side = side; &#13;
      this.height = height; &#13;
      this.getArea = function () { &#13;
        return this.side * this.height / 2; &#13;
      }; &#13;
    } &#13;
</pre><p>The code that performs the inheritance magic is as follows:</p><pre class="programlisting">    TwoDShape.prototype = new Shape(); &#13;
    Triangle.prototype = new TwoDShape(); &#13;
</pre><p>What's happening here? You take the object contained in the <code class="literal">prototype</code> property of <code class="literal">TwoDShape</code>, and instead of augmenting it with individual properties, you completely overwrite it with another object, created by invoking the <code class="literal">Shape()</code> constructor with <code class="literal">new</code>. The same process can be followed for <code class="literal">Triangle</code>-its prototype is replaced by an object created by <code class="literal">new TwoDShape()</code>. It's important to remember that JavaScript works with objects, not classes. You need to create an instance using the <code class="literal">new Shape()</code> constructor, and after that, you can inherit its properties; you don't inherit from <code class="literal">Shape()</code> directly. Additionally, after inheriting, you can modify the <code class="literal">Shape()</code> constructor, overwrite it, or even delete it, and this will have no effect on <code class="literal">TwoDShape</code>, because all you needed is one instance to inherit from.</p><p>As you know from the previous chapter, overwriting the prototype (as opposed to just adding properties to it), has side effects on the <code class="literal">constructor</code> property. Therefore, it's a good idea to reset the <code class="literal">constructor</code> property after inheriting. Consider the following example:</p><pre class="programlisting">    TwoDShape.prototype.constructor = TwoDShape; &#13;
    Triangle.prototype.constructor = Triangle; &#13;
</pre><p>Now, let's test what has happened so far. Creating a <code class="literal">Triangle</code> object and calling its own <code class="literal">getArea()</code> method works as expected:</p><pre class="programlisting">    &gt;var my = new Triangle(5, 10); &#13;
    &gt;my.getArea(); &#13;
    25 &#13;
</pre><p>Although the <code class="literal">my</code> object doesn't have its own <code class="literal">toString()</code> method, it inherited one and you can call it. Note how the inherited method <code class="literal">toString()</code> binds the <code class="literal">this</code> object to <code class="literal">my</code>:</p><pre class="programlisting">    &gt;my.toString(); &#13;
    "Triangle" &#13;
</pre><p>It's fascinating to consider what the JavaScript engine does when you call <code class="literal">my.toString()</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It loops through all of the properties of <code class="literal">my</code> and doesn't find a method called <code class="literal">toString()</code>.</li><li class="listitem" style="list-style-type: disc">It looks at the object that <code class="literal">my.__proto__</code> points to <code class="literal">this</code> object is the instance <code class="literal">new TwoDShape()</code> created during the inheritance process.</li><li class="listitem" style="list-style-type: disc">Now, the JavaScript engine loops through the instance of <code class="literal">TwoDShape</code> and doesn't find a <code class="literal">toString()</code> method. It then checks <code class="literal">__proto__</code> of that object. This time, <code class="literal">__proto__</code> points to the instance created by <code class="literal">new Shape()</code>.</li><li class="listitem" style="list-style-type: disc">The instance of <code class="literal">new Shape()</code> is examined, and <code class="literal">toString()</code> is finally found.</li><li class="listitem" style="list-style-type: disc">This method is invoked in the context of <code class="literal">my</code>, meaning that <code class="literal">this</code> points to <code class="literal">my</code>.</li></ul></div><p>If you ask <code class="literal">my</code>, Who's your constructor?, it reports it correctly because of the reset of the <code class="literal">constructor</code> property after the inheritance:</p><pre class="programlisting">    &gt;my.constructor === Triangle; &#13;
    true &#13;
</pre><p>Using the <code class="literal">instanceof</code> operator, you can validate that <code class="literal">my</code> is an instance of all three constructors:</p><pre class="programlisting">    &gt; my instanceof Shape; &#13;
    true &#13;
    &gt; my instanceofTwoDShape; &#13;
    true &#13;
    &gt; my instanceof Triangle; &#13;
    true &#13;
    &gt; my instanceof Array; &#13;
    false &#13;
</pre><p>The same happens when you call <code class="literal">isPrototypeOf()</code>on the constructors by passing <code class="literal">my</code>:</p><pre class="programlisting">    &gt;Shape.prototype.isPrototypeOf(my); &#13;
    true &#13;
    &gt;TwoDShape.prototype.isPrototypeOf(my); &#13;
    true &#13;
    &gt;Triangle.prototype.isPrototypeOf(my); &#13;
    true &#13;
    &gt;String.prototype.isPrototypeOf(my); &#13;
    false &#13;
</pre><p>You can also create objects using the other two constructors. Objects created with <code class="literal">new TwoDShape()</code> also get the <code class="literal">toString()</code>method inherited from <code class="literal">Shape()</code>:</p><pre class="programlisting">    &gt;var td = new TwoDShape(); &#13;
    &gt;td.constructor === TwoDShape; &#13;
    true &#13;
    &gt;td.toString(); &#13;
    "2D shape" &#13;
    &gt;var s = new Shape(); &#13;
    &gt;s.constructor === Shape; &#13;
    true &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Moving shared properties to the prototype</h2></div></div></div><p>When you create objects using a constructor function, own properties are added using <code class="literal">this</code>. This could be inefficient in cases where properties don't change across instances. In the previous example, <code class="literal">Shape()</code> was defined as follows:</p><pre class="programlisting">    function Shape(){ &#13;
    this.name = 'Shape'; &#13;
    } &#13;
</pre><p>This means that every time you create a new object using <code class="literal">new Shape()</code>, a new <code class="literal">name</code> property is created and stored somewhere in the memory. The other option is to have the <code class="literal">name</code> property added to the prototype and shared among all the instances:</p><pre class="programlisting">    function Shape() {} &#13;
    Shape.prototype.name = 'Shape'; &#13;
</pre><p>Now, every time you create an object using <code class="literal">new Shape()</code>, this object doesn't get its own property <code class="literal">name</code>, but uses the one added to the prototype. This is more efficient, but you should only use it for properties that don't change from one instance to another. Methods are ideal for this type of sharing.</p><p>Let's improve the preceding example by adding all methods and suitable properties to <code class="literal">prototype</code>. In the case of <code class="literal">Shape()</code> and <code class="literal">TwoDShape()</code>, everything is meant to be shared:</p><pre class="programlisting">    // constructor &#13;
    function Shape() {} &#13;
 &#13;
    // augment prototype &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
      return this.name; &#13;
    }; &#13;
 &#13;
    // another constructor &#13;
    function TwoDShape() {} &#13;
 &#13;
    // take care of inheritance &#13;
    TwoDShape.prototype = new Shape(); &#13;
    TwoDShape.prototype.constructor = TwoDShape; &#13;
 &#13;
    // augment prototype &#13;
    TwoDShape.prototype.name = '2D shape'; &#13;
</pre><p>As you can see, you have to take care of inheritance first before augmenting the prototype. Otherwise, anything you add to <code class="literal">TwoDShape.prototype</code> gets wiped out when you inherit.</p><p>The <code class="literal">Triangle</code> constructor is a little different, because every object it creates is a new triangle, which is likely to have different dimensions. So, it's good to keep <code class="literal">side</code> and <code class="literal">height</code> as own properties and share the rest. The <code class="literal">getArea()</code> method, for example, is the same, regardless of the actual dimensions of each triangle. Again, you do the inheritance bit first and then augment the prototype:</p><pre class="programlisting">    function Triangle(side, height) { &#13;
    this.side = side; &#13;
    this.height = height; &#13;
    } &#13;
    // take care of inheritance &#13;
    Triangle.prototype = new TwoDShape(); &#13;
    Triangle.prototype.constructor = Triangle; &#13;
 &#13;
    // augment prototype &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
    Triangle.prototype.getArea = function () { &#13;
    return this.side * this.height / 2; &#13;
    }; &#13;
</pre><p>All the preceding test code works exactly the same. Here is an example:</p><pre class="programlisting">    &gt;var my = new Triangle(5, 10); &#13;
    &gt;my.getArea(); &#13;
    25 &#13;
    &gt;my.toString(); &#13;
    "Triangle" &#13;
</pre><p>There is only a slight behind-the-scenes difference when calling <code class="literal">my.toString()</code>. The difference is that there is one more lookup to be done before the method is found in <code class="literal">Shape.prototype</code>, as opposed to in the <code class="literal">new Shape()</code> instance, like it was in the previous example.</p><p>You can also play with <code class="literal">hasOwnProperty()</code> to see the difference between the own property versus a property coming down the prototype chain:</p><pre class="programlisting">    &gt;my.hasOwnProperty('side'); &#13;
    true &#13;
    &gt;my.hasOwnProperty('name'); &#13;
    false &#13;
</pre><p>The calls to <code class="literal">isPrototypeOf()</code> and the <code class="literal">instanceof</code> operator from the previous example work in exactly the same way:</p><pre class="programlisting">    &gt;TwoDShape.prototype.isPrototypeOf(my); &#13;
    true &#13;
    &gt; my instanceof Shape; &#13;
    true &#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Inheriting the prototype only</h1></div></div></div><p>As explained earlier, for reasons of efficiency, you should add the reusable properties and methods to the prototype. If you do so, then it's a good idea to inherit only the prototype, because all the reusable code is there. This means that inheriting the <code class="literal">Shape.prototype</code> object is better than inheriting the object created with <code class="literal">new Shape()</code>. After all, <code class="literal">new Shape()</code> only gives you own shape properties that are not meant to be reused (otherwise, they would be in the prototype). You gain a little more efficiency by:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Not creating a new object for the sake of inheritance alone</li><li class="listitem" style="list-style-type: disc">Having fewer lookups during runtime (when it comes to searching for <code class="literal">toString()</code>)</li></ul></div><p>For example, here's the updated code; the changes are highlighted:</p><pre class="programlisting">    function Shape() {} &#13;
    // augment prototype &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
      return this.name; &#13;
    }; &#13;
 &#13;
    function TwoDShape() {} &#13;
    // take care of inheritance &#13;
    TwoDShape.prototype = Shape.prototype; &#13;
    TwoDShape.prototype.constructor = TwoDShape; &#13;
    // augment prototype &#13;
    TwoDShape.prototype.name = '2D shape'; &#13;
 &#13;
    function Triangle(side, height) { &#13;
      this.side = side; &#13;
      this.height = height; &#13;
    } &#13;
 &#13;
    // take care of inheritance &#13;
    Triangle.prototype = TwoDShape.prototype; &#13;
    Triangle.prototype.constructor = Triangle; &#13;
    // augment prototype &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
    Triangle.prototype.getArea = function () { &#13;
      return this.side * this.height / 2; &#13;
    }; &#13;
</pre><p>The test code gives you the same result:</p><pre class="programlisting">    &gt;var my = new Triangle(5, 10); &#13;
    &gt;my.getArea(); &#13;
    25 &#13;
    &gt;my.toString(); &#13;
    "Triangle" &#13;
</pre><p>What's the difference in the lookups when calling <code class="literal">my.toString()</code>? First, as usual, the JavaScript engine looks for a <code class="literal">toString()</code>method of the <code class="literal">my</code> object itself. The engine doesn't find such a method, so it inspects the prototype. The prototype turns out to be pointing to the same object that the prototype of <code class="literal">TwoDShape</code> points to and also the same object that <code class="literal">Shape.prototype</code> points to. Remember that objects are not copied by value, but only by reference. So, the lookup is only a two-step process as opposed to four (in the previous example) or three (in the first example).</p><p>Simply copying the prototype is more efficient, but it has a side effect because, all the prototypes of the children and parents point to the same object, when a child modifies the prototype, the parents get the changes and so do the siblings.</p><p>Look at the following line:</p><pre class="programlisting">    Triangle.prototype.name = 'Triangle'; &#13;
</pre><p>It changes the <code class="literal">name</code> property, so it effectively changes <code class="literal">Shape.prototype.name</code> too. If you create an instance using <code class="literal">new Shape()</code>, its <code class="literal">name</code> property says <code class="literal">"Triangle"</code>:</p><pre class="programlisting">    &gt;var s = new Shape(); &#13;
    &gt;s.name; &#13;
    "Triangle" &#13;
</pre><p>This method is more efficient, but may not suit all your use cases.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec91"/>A temporary constructor - new F()</h2></div></div></div><p>A solution to the previously outlined problem, where all prototypes point to the same object and the parents get children's properties, is to use an intermediary to break the chain. The intermediary is in the form of a temporary constructor function. Creating an empty function <code class="literal">F()</code> and setting its <code class="literal">prototype</code> to the prototype of the parent constructor allows you to call <code class="literal">new F()</code>and create objects that have no properties of their own, but inherit everything from the parent's <code class="literal">prototype</code>.</p><p>Let's take a look at the modified code:</p><pre class="programlisting">    function Shape() {} &#13;
    // augment prototype &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
    return this.name; &#13;
    }; &#13;
 &#13;
    function TwoDShape() {} &#13;
    // take care of inheritance &#13;
    var F = function () {}; &#13;
    F.prototype = Shape.prototype; &#13;
    TwoDShape.prototype = new F(); &#13;
    TwoDShape.prototype.constructor = TwoDShape; &#13;
    // augment prototype &#13;
    TwoDShape.prototype.name = '2D shape'; &#13;
 &#13;
    function Triangle(side, height) { &#13;
    this.side = side; &#13;
    this.height = height; &#13;
    } &#13;
 &#13;
    // take care of inheritance &#13;
    var F = function () {}; &#13;
    F.prototype = TwoDShape.prototype; &#13;
    Triangle.prototype = new F(); &#13;
    Triangle.prototype.constructor = Triangle; &#13;
    // augment prototype &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
    Triangle.prototype.getArea = function () { &#13;
    return this.side * this.height / 2; &#13;
    }; &#13;
</pre><p>Creating <code class="literal">my</code> triangle and testing the methods:</p><pre class="programlisting">    &gt;var my = new Triangle(5, 10); &#13;
    &gt;my.getArea(); &#13;
    25 &#13;
    &gt;my.toString(); &#13;
    "Triangle" &#13;
</pre><p>Using this approach, the prototype chain stays in place:</p><pre class="programlisting">    &gt;my.__proto__ === Triangle.prototype; &#13;
    true &#13;
    &gt;my.__proto__.constructor === Triangle; &#13;
    true &#13;
    &gt;my.__proto__.__proto__ === TwoDShape.prototype; &#13;
    true &#13;
    &gt;my.__proto__.__proto__.__proto__.constructor === Shape; &#13;
    true &#13;
</pre><p>Also, the parents' properties are not overwritten by the children:</p><pre class="programlisting">    &gt;var s = new Shape(); &#13;
    &gt;s.name; &#13;
    "Shape" &#13;
    &gt;"I am a " + new TwoDShape(); // calling toString() &#13;
    "I am a 2D shape" &#13;
</pre><p>At the same time, this approach supports the idea that only properties and methods added to the prototype should be inherited and own properties should not. The rationale behind this is that own properties are likely to be too specific to be reusable.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Uber - access to the parent from a child object</h1></div></div></div><p>Classical OO languages usually have a special syntax that gives you access to the parent class, also referred to the superclass. This could be convenient when a child wants to have a method that does everything the parent's method does, plus something in addition to it. In such cases, the child calls the parent's method with the same name and works with the result.</p><p>In JavaScript, there is no such special syntax, but it's trivial to achieve the same functionality. Let's rewrite the last example, and while taking care of inheritance, also create an <code class="literal">uber</code> property that points to the parent's <code class="literal">prototype</code> object:</p><pre class="programlisting">    function Shape() {} &#13;
    // augment prototype &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
    var const = this.constructor; &#13;
    returnconst.uber &#13;
        ? this.const.uber.toString() + ', ' + this.name &#13;
        : this.name; &#13;
    }; &#13;
 &#13;
    function TwoDShape() {} &#13;
    // take care of inheritance &#13;
    var F = function () {}; &#13;
    F.prototype = Shape.prototype; &#13;
    TwoDShape.prototype = new F(); &#13;
    TwoDShape.prototype.constructor = TwoDShape; &#13;
    TwoDShape.uber = Shape.prototype; &#13;
    // augment prototype &#13;
    TwoDShape.prototype.name = '2D shape'; &#13;
 &#13;
    function Triangle(side, height) { &#13;
    this.side = side; &#13;
    this.height = height; &#13;
    } &#13;
 &#13;
    // take care of inheritance &#13;
    var F = function () {}; &#13;
    F.prototype = TwoDShape.prototype; &#13;
    Triangle.prototype = new F(); &#13;
    Triangle.prototype.constructor = Triangle; &#13;
    Triangle.uber = TwoDShape.prototype; &#13;
    // augment prototype &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
    Triangle.prototype.getArea = function () { &#13;
    return this.side * this.height / 2; &#13;
    }; &#13;
</pre><p>The new things here are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A new <code class="literal">uber</code> property points to the parent's <code class="literal">prototype</code></li><li class="listitem" style="list-style-type: disc">The updated <code class="literal">toString()</code>method</li></ul></div><p>Previously, <code class="literal">toString()</code> only returned <code class="literal">this.name</code>. Now, in addition to this, there is a check to see whether <code class="literal">this.constructor.uber</code> exists and, if it does, call its <code class="literal">toString()</code> first. The <code class="literal">this.constructor</code> is the function itself, and <code class="literal">this.constructor.uber</code> points to the parent's <code class="literal">prototype</code>. The result is that when you call <code class="literal">toString()</code> for a <code class="literal">Triangle</code> instance, all <code class="literal">toString()</code> methods up the prototype chain are called:</p><pre class="programlisting">    &gt;var my = new Triangle(5, 10); &#13;
    &gt;my.toString(); &#13;
    "Shape, 2D shape, Triangle" &#13;
</pre><p>The name of the <code class="literal">uber</code> property could've been superclass, but this would suggest that JavaScript has classes. Ideally, it could've been super (as in Java), but super is a reserved word in JavaScript. The German word uber suggested by Douglas Crockford means more or less the same as super, and you have to admit, it sounds uber cool.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Isolating the inheritance part into a function</h1></div></div></div><p>Let's move the code that takes care of all the inheritance details from the last example into a reusable <code class="literal">extend()</code> function:</p><pre class="programlisting">    function extend(Child, Parent) { &#13;
    var F = function () {}; &#13;
    F.prototype = Parent.prototype; &#13;
    Child.prototype = new F(); &#13;
    Child.prototype.constructor = Child; &#13;
    Child.uber = Parent.prototype; &#13;
    } &#13;
</pre><p>Using this function (or your own custom version of it) helps you keep your code clean with regard to the repetitive inheritance-related tasks. This way, you can inherit by simply using the following two lines of code:</p><pre class="programlisting">    extend(TwoDShape, Shape); &#13;
    extend(Triangle, TwoDShape); &#13;
</pre><p>Let's see a complete example:</p><pre class="programlisting">    // inheritance helper &#13;
    function extend(Child, Parent) { &#13;
      var F = function () {}; &#13;
      F.prototype = Parent.prototype; &#13;
      Child.prototype = new F(); &#13;
      Child.prototype.constructor = Child; &#13;
      Child.uber = Parent.prototype; &#13;
    } &#13;
 &#13;
    // define -&gt; augment &#13;
    function Shape() {} &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
      return this.constructor.uber &#13;
        ? this.constructor.uber.toString() + ', ' + this.name &#13;
        : this.name; &#13;
    }; &#13;
 &#13;
    // define -&gt; inherit -&gt; augment &#13;
    function TwoDShape() {} &#13;
    extend(TwoDShape, Shape); &#13;
    TwoDShape.prototype.name = '2D shape'; &#13;
 &#13;
 &#13;
    // define &#13;
    function Triangle(side, height) { &#13;
      this.side = side; &#13;
      this.height = height; &#13;
    } &#13;
    // inherit &#13;
    extend(Triangle, TwoDShape); &#13;
    // augment &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
    Triangle.prototype.getArea = function () { &#13;
      return this.side * this.height / 2; &#13;
    }; &#13;
</pre><p>Lets test the following code:</p><pre class="programlisting">    &gt; new Triangle().toString(); &#13;
    "Shape, 2D shape, Triangle" &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Copying properties</h1></div></div></div><p>Now, let's try a slightly different approach. Since inheritance is all about reusing code, can you simply copy the properties you like from one object to another? Or from a parent to a child? Keeping the same interface as the preceding <code class="literal">extend()</code> function, you can create a <code class="literal">extend2()</code>function, which takes two constructor functions and copies all the properties from the parent's <code class="literal">prototype</code> to the child's <code class="literal">prototype</code>. This will, of course, carry over methods too, as methods are just properties that happen to be functions:</p><pre class="programlisting">    function extend2(Child, Parent) { &#13;
      var p = Parent.prototype; &#13;
      var c = Child.prototype; &#13;
      for (var i in p) { &#13;
        c[i] = p[i]; &#13;
      } &#13;
      c.uber = p; &#13;
    } &#13;
</pre><p>As you can see, a simple loop through the properties is all it takes. As with the previous example, you can set an <code class="literal">uber</code> property if you want to have handy access to parent's methods from the child. Unlike the previous example though, it's not necessary to reset <code class="literal">Child.prototype.constructor</code> because here, the child <code class="literal">prototype</code> is augmented, not overwritten completely. So, the <code class="literal">constructor</code> property points to the initial value.</p><p>This method is a little inefficient compared to the previous method because properties of the child <code class="literal">prototype</code> are being duplicated instead of simply being looked up via the prototype chain during execution. Bear in mind that this is only true for properties containing primitive types. All objects (including functions and arrays) are not duplicated, because these are passed by reference only.</p><p>Let's see an example of using two constructor functions, <code class="literal">Shape()</code> and <code class="literal">TwoDShape()</code>. The <code class="literal">Shape()</code> function's <code class="literal">prototype</code> object contains a primitive property, <code class="literal">name</code>, and a non-primitive one, the <code class="literal">toString()</code>method:</p><pre class="programlisting">    var Shape = function () {}; &#13;
    var TwoDShape = function () {}; &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
      return this.uber &#13;
        ? this.uber.toString() + ', ' + this.name &#13;
        : this.name; &#13;
    }; &#13;
</pre><p>If you inherit with <code class="literal">extend()</code>, neither the objects created with <code class="literal">TwoDShape()</code> nor its prototype get an own <code class="literal">name</code> property, but they have access to the one they inherit:</p><pre class="programlisting">    &gt; extend(TwoDShape, Shape); &#13;
    &gt;var td = new TwoDShape(); &#13;
    &gt;td.name; &#13;
    "Shape" &#13;
    &gt;TwoDShape.prototype.name; &#13;
    "Shape" &#13;
    &gt;td.__proto__.name; &#13;
    "Shape" &#13;
    &gt;td.hasOwnProperty('name'); &#13;
    false &#13;
    &gt; td.__proto__.hasOwnProperty('name'); &#13;
    false &#13;
</pre><p>However, if you inherit with <code class="literal">extend2()</code>, the prototype of <code class="literal">TwoDShape()</code>gets its own copy of the <code class="literal">name</code> property. It also gets its own copy of <code class="literal">toString()</code>, but it's a reference only, so the function will not be recreated a second time:</p><pre class="programlisting">    &gt;extend2(TwoDShape, Shape); &#13;
    &gt;var td = new TwoDShape(); &#13;
    &gt; td.__proto__.hasOwnProperty('name'); &#13;
    true &#13;
    &gt; td.__proto__.hasOwnProperty('toString'); &#13;
    true &#13;
    &gt; td.__proto__.toString === Shape.prototype.toString; &#13;
    true &#13;
</pre><p>As you can see, the two <code class="literal">toString()</code> methods are the same function object. This is good because it means that no unnecessary duplicates of the methods are created.</p><p>So, you can say that <code class="literal">extend2()</code> is less efficient than <code class="literal">extend()</code> because it recreates the properties of the prototype. However, this is not so bad because only the primitive data types are duplicated. Additionally, this is beneficial during the prototype chain lookups as there are fewer chain links to follow before finding the property.</p><p>Take a look at the <code class="literal">uber</code> property again. This time, for a change, it's set on the <code class="literal">Parent</code> object's prototype <code class="literal">p</code>, not on the <code class="literal">Parent</code> constructor. This is why <code class="literal">toString()</code> uses it as <code class="literal">this.uber</code> as opposed to <code class="literal">this.constructor.uber</code>. This is just an illustration that you can shape your favorite inheritance pattern in any way you see fit. Let's test it out:</p><pre class="programlisting">    &gt;td.toString(); &#13;
    "Shape, Shape" &#13;
</pre><p>
<code class="literal">TwoDShape</code> didn't redefine the <code class="literal">name</code> property, hence the repetition. It can do that at any time, and (the prototype chain being live) all the instances see the update:</p><pre class="programlisting">    &gt;TwoDShape.prototype.name = "2D shape"; &#13;
    &gt;td.toString(); &#13;
    "Shape, 2D shape" &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Heads-up when copying by reference</h1></div></div></div><p>The fact that objects (including functions and arrays) are copied by reference could sometimes lead to results you don't expect.</p><p>Let's create two constructor functions and add properties to the prototype of the first one:</p><pre class="programlisting">    &gt; function Papa() {} &#13;
    &gt;function Wee() {} &#13;
    &gt;Papa.prototype.name = 'Bear';  &#13;
    &gt;Papa.prototype.owns = ["porridge", "chair", "bed"]; &#13;
</pre><p>Now, let's have <code class="literal">Wee</code> inherit from <code class="literal">Papa</code> (either <code class="literal">extend()</code> or <code class="literal">extend2()</code> will do):</p><pre class="programlisting">    &gt;extend2(Wee, Papa); &#13;
</pre><p>Using <code class="literal">extend2()</code>, the <code class="literal">Wee</code> function's prototype inherited the properties of <code class="literal">Papa.prototype</code> as its own:</p><pre class="programlisting">    &gt;Wee.prototype.hasOwnProperty('name'); &#13;
    true &#13;
    &gt;Wee.prototype.hasOwnProperty('owns'); &#13;
    true &#13;
</pre><p>The <code class="literal">name</code> property is primitive, so a new copy of it is created. The <code class="literal">owns</code> property is an array object, so it's copied by reference:</p><pre class="programlisting">    &gt;Wee.prototype.owns; &#13;
    ["porridge", "chair", "bed"] &#13;
    &gt;Wee.prototype.owns=== Papa.prototype.owns; &#13;
    true &#13;
</pre><p>Changing the <code class="literal">Wee</code> function's copy of <code class="literal">name</code> doesn't affect <code class="literal">Papa</code>:</p><pre class="programlisting">    &gt;Wee.prototype.name += ', Little Bear'; &#13;
    "Bear, Little Bear" &#13;
    &gt;Papa.prototype.name; &#13;
    "Bear" &#13;
</pre><p>Changing the <code class="literal">Wee</code> function's <code class="literal">owns</code> property, however, affects <code class="literal">Papa</code>, because both properties point to the same array in memory:</p><pre class="programlisting">    &gt;Wee.prototype.owns.pop(); &#13;
    "bed" &#13;
    &gt;Papa.prototype.owns; &#13;
    ["porridge", "chair"] &#13;
</pre><p>It's a different story when you completely overwrite the <code class="literal">Wee</code> function's copy of <code class="literal">owns </code>with another object (as opposed to modifying the existing one). In this case, <code class="literal">Papa.owns</code> keeps pointing to the old object, while <code class="literal">Wee.owns</code> points to a new one:</p><pre class="programlisting">    &gt;Wee.prototype.owns= ["empty bowl", "broken chair"]; &#13;
    &gt;Papa.prototype.owns.push('bed'); &#13;
    &gt;Papa.prototype.owns; &#13;
    ["porridge", "chair", "bed"] &#13;
</pre><p>Think of an object as something that is created and stored in a physical location in memory. Variables and properties merely point to this location, so when you assign a brand new object to <code class="literal">Wee.prototype.owns</code>, you essentially say-Hey, forget about this other old object, move your pointer to this new one instead.</p><p>The following diagram illustrates what happens if you imagine the memory being a heap of objects (like a wall of bricks) and you point to (refer to) some of these objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A new object is created, and <strong>A</strong> points to it.</li><li class="listitem" style="list-style-type: disc">A new variable <strong>B</strong> is created and made equal to <strong>A</strong>, meaning it now points to the same place <strong>A</strong> is pointing to.</li><li class="listitem" style="list-style-type: disc">A property color is changed using the <strong>B</strong> handle (pointer). The brick is now white. <strong>A</strong> check for <code class="literal">A.color === "white"</code> would be true.</li><li class="listitem" style="list-style-type: disc">A new object is created, and the <strong>B</strong> variable/pointer is recycled to point to that new object. <strong>A</strong> and <strong>B</strong> are now pointing to different parts of the memory pile. They have nothing in common and changes to one of them don't affect the other:</li></ul></div><p>
</p><div><img src="img/image_07_002.jpg" alt="Heads-up when copying by reference"/></div><p>
</p><p>If you want to address the problem that objects are copied by reference, consider a deep copy, described later in the chapter.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Objects inherit from objects</h1></div></div></div><p>All the examples so far in this chapter assume that you create your objects with constructor functions, and you want objects created with one constructor to inherit properties that come from another constructor. However, you can also create objects without the help of a constructor function, just using the object literal, and this is, in fact, less typing. So, how about inheriting those?</p><p>In Java or PHP, you define classes and have them inherit from other classes. That's why you'll see the term classical, because the OO functionality comes from the use of classes. In JavaScript, there are no classes, so programmers that come from a classical background resort to constructor functions, because constructors are the closest to what they are used to. In addition, JavaScript provides the <code class="literal">new</code> operator, which can further suggest that JavaScript is like Java. The truth is that, in the end, it all comes down to objects. The first example in this chapter used this syntax:</p><pre class="programlisting">    Child.prototype = new Parent(); &#13;
</pre><p>Here, the <code class="literal">Child</code> constructor (or class, if you will) inherits from <code class="literal">Parent</code>. However, this is done by creating an object using <code class="literal">new Parent()</code> and inheriting from it. That's why this is also referred to as a <strong>pseudo-classical inheritance pattern</strong>, because it resembles classical inheritance, although it isn't (no classes are involved).</p><p>So, why not get rid of the middleman (the constructor/class) and just have objects inherit from objects? In <code class="literal">extend2()</code>, the properties of the parent <code class="literal">prototype</code> object were copied as properties of the child <code class="literal">prototype</code> object. The two prototypes are, in essence, just objects. Forgetting about prototypes and constructor functions, you can simply take an object and copy all of its properties into another object.</p><p>You already know that objects can start as a blank canvas without any own properties, using <code class="literal">var o = {};</code>, and then get properties later. However, instead of starting fresh, you can start by copying all of the properties of an existing object. Here's a function that does exactly this: it takes an object and returns a new copy of it:</p><pre class="programlisting">    function extendCopy(p) { &#13;
      var c = {}; &#13;
      for (var i in p) { &#13;
        c[i] = p[i]; &#13;
      } &#13;
      c.uber = p; &#13;
      return c; &#13;
    } &#13;
</pre><p>Simply copying all the properties is a straightforward pattern, and it's widely used. Let's see this function in action. You start by having a base object:</p><pre class="programlisting">    var shape = { &#13;
    name: 'Shape', &#13;
    toString: function () { &#13;
    return this.name; &#13;
    } &#13;
    }; &#13;
</pre><p>In order to create a new object that builds upon the old one, you can call the <code class="literal">extendCopy()</code> function, which returns a new object. Then, you can augment the new object with additional functionality:</p><pre class="programlisting">    var twoDee = extendCopy(shape); &#13;
    twoDee.name = '2D shape'; &#13;
    twoDee.toString = function () { &#13;
    return this.uber.toString() + ', ' + this.name; &#13;
    }; &#13;
</pre><p>Here is a triangle object that inherits the <code class="literal">2D shape</code> object:</p><pre class="programlisting">    var triangle = extendCopy(twoDee); &#13;
    triangle.name = 'Triangle'; &#13;
    triangle.getArea = function () { &#13;
    return this.side * this.height / 2; &#13;
    }; &#13;
</pre><p>Using the triangle, for example:</p><pre class="programlisting">    &gt;triangle.side = 5; &#13;
    &gt;triangle.height = 10; &#13;
    &gt;triangle.getArea(); &#13;
    25 &#13;
    &gt;triangle.toString(); &#13;
    "Shape, 2D shape, Triangle" &#13;
</pre><p>A possible drawback of this method is the somewhat verbose way of initializing the new <code class="literal">triangle</code> object, where you manually set values for <code class="literal">side</code> and <code class="literal">height</code>, as opposed to passing them as values to a constructor. However, this is easily resolved by having a function, for example, called <code class="literal">init()</code> (or <code class="literal">__construct()</code> if you come from PHP) that acts as a constructor and accepts initialization parameters. Alternatively, have <code class="literal">extendCopy()</code> accept two parameters, an object to inherit from and another object literal of properties to add to the copy before it's returned. In other words, just merge two objects.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Deep copy</h1></div></div></div><p>The <code class="literal">extendCopy()</code> function discussed previously creates what is called a shallow copy of an object, just like <code class="literal">extend2()</code> before that. The opposite of a shallow copy would be, naturally, a deep copy. As discussed previously (in the <em>Heads-up when copying by reference</em> section of this chapter), when you copy objects, you only copy pointers to the location in memory where the object is stored. This is what happens in a shallow copy. If you modify an object in the copy, you also modify the original. The deep copy avoids this problem.</p><p>The deep copy is implemented in the same way as the shallow copy-you loop through the properties and copy them one by one. However, when you encounter a property that points to an object, you call the <code class="literal">deepcopy</code> function again:</p><pre class="programlisting">    function deepCopy(p, c) { &#13;
      c = c || {}; &#13;
      for (var i in p) { &#13;
        if (p.hasOwnProperty(i)) { &#13;
          if (typeof p[i] === 'object') { &#13;
            c[i] = Array.isArray(p[i]) ? [] : {}; &#13;
    deepCopy(p[i], c[i]); &#13;
          } else { &#13;
            c[i] = p[i]; &#13;
          } &#13;
        } &#13;
      } &#13;
      return c; &#13;
    } &#13;
</pre><p>Let's create an object that has arrays and a subobject as properties:</p><pre class="programlisting">    var parent = { &#13;
      numbers: [1, 2, 3], &#13;
      letters: ['a', 'b', 'c'], &#13;
      obj: { &#13;
        prop: 1 &#13;
      }, &#13;
      bool: true &#13;
    }; &#13;
</pre><p>Let's test this by creating a deep copy and a shallow copy. Unlike the shallow copy, when you update the <code class="literal">numbers</code> property of a deep copy, the original is not affected:</p><pre class="programlisting">    &gt;var mydeep = deepCopy(parent); &#13;
    &gt;var myshallow = extendCopy(parent); &#13;
    &gt;mydeep.numbers.push(4,5,6); &#13;
    6 &#13;
    &gt;mydeep.numbers; &#13;
    [1, 2, 3, 4, 5, 6] &#13;
    &gt;parent.numbers; &#13;
    [1, 2, 3] &#13;
    &gt;myshallow.numbers.push(10); &#13;
    4 &#13;
    &gt;myshallow.numbers; &#13;
    [1, 2, 3, 10] &#13;
    &gt;parent.numbers; &#13;
    [1, 2, 3, 10] &#13;
    &gt;mydeep.numbers; &#13;
    [1, 2, 3, 4, 5, 6] &#13;
</pre><p>Two side notes about the <code class="literal">deepCopy()</code> function:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Filtering out non-own properties with <code class="literal">hasOwnProperty()</code> is always a good idea to make sure you don't carry over someone's additions to the core prototypes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Array.isArray()</code> exists since ES5 because it's surprisingly hard otherwise to tell real arrays from objects. The best cross-browser solution (if you need to define <code class="literal">isArray()</code> in ES3 browsers) looks a little hacky, but it works:<pre class="programlisting">    if (Array.isArray !== "function") { &#13;
    Array.isArray = function (candidate) { &#13;
        return  &#13;
    Object.prototype.toString.call(candidate) ===  &#13;
    '[object Array]'; &#13;
    }; &#13;
    } &#13;
</pre></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Using object() method</h1></div></div></div><p>Based on the idea that objects inherit from objects, Douglas Crockford advocates the use of an <code class="literal">object()</code> function that accepts an object and returns a new one that has the parent as a prototype:</p><pre class="programlisting">    function object(o) { &#13;
    function F() {} &#13;
    F.prototype = o; &#13;
    return new F(); &#13;
    } &#13;
</pre><p>If you need access to an <code class="literal">uber</code> property, you can modify the <code class="literal">object()</code> function as follows:</p><pre class="programlisting">    function object(o) { &#13;
    var n; &#13;
    function F() {} &#13;
    F.prototype = o; &#13;
    n = new F(); &#13;
    n.uber = o; &#13;
    return n; &#13;
    } &#13;
</pre><p>Using <code class="literal">this</code> function is the same as using <code class="literal">extendCopy()</code>, you take an object such as <code class="literal">twoDee</code>, create a new object from it, and then proceed to augmenting the new object:</p><pre class="programlisting">    var triangle = object(twoDee); &#13;
    triangle.name = 'Triangle'; &#13;
    triangle.getArea = function () { &#13;
    return this.side * this.height / 2; &#13;
    }; &#13;
</pre><p>The new triangle still behaves the same way:</p><pre class="programlisting">    &gt;triangle.toString(); &#13;
    "Shape, 2D shape, Triangle" &#13;
</pre><p>This pattern is also referred to as <strong>prototypal inheritance</strong>, because you use a parent object as the prototype of a child object. It's also adopted and built upon in ES5 and called <code class="literal">Object.create()</code>. Here is an example:</p><pre class="programlisting">    &gt;var square = Object.create(triangle); &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Using a mix of prototypal inheritance and copying properties</h1></div></div></div><p>When you use inheritance, you will most likely want to take an already existing functionality and then build upon it. This means creating a new object by inheriting from an existing object and then adding additional methods and properties. You can do this with one function call using a combination of the last two approaches just discussed.</p><p>You can:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use prototypal inheritance to use an existing object as a prototype of a new one</li><li class="listitem" style="list-style-type: disc">Copy all the properties of another object into the newly created one:<pre class="programlisting">    function objectPlus(o, stuff) { &#13;
      var n; &#13;
      function F() {} &#13;
      F.prototype = o; &#13;
      n = new F(); &#13;
      n.uber = o; &#13;
   &#13;
     for (var i in stuff) { &#13;
        n[i] = stuff[i]; &#13;
        } &#13;
      return n; &#13;
    } &#13;
</pre></li></ul></div><p>This function takes an object <code class="literal">o</code> to inherit from and another object <code class="literal">stuff</code> that has the additional methods and properties that are to be copied. Let's see this in action.</p><p>Start with the base <code class="literal">shape</code> object:</p><pre class="programlisting">    var shape = { &#13;
    name: 'Shape', &#13;
    toString: function () { &#13;
    return this.name; &#13;
    } &#13;
    }; &#13;
</pre><p>Create a 2D object by inheriting shape and adding more properties. The additional properties are simply created with an object literal:</p><pre class="programlisting">    var twoDee = objectPlus(shape, { &#13;
      name: '2D shape', &#13;
      toString: function () { &#13;
        return this.uber.toString() + ', ' + this.name; &#13;
      } &#13;
    }); &#13;
</pre><p>Now, let's create a <code class="literal">triangle</code> object that inherits from 2D and adds more properties:</p><pre class="programlisting">    var triangle = objectPlus(twoDee, { &#13;
      name: 'Triangle', &#13;
      getArea: function () { return this.side * this.height / 2; &#13;
     }, &#13;
      side: 0, &#13;
      height: 0 &#13;
    }); &#13;
</pre><p>You can test how it all works by creating a concrete triangle <code class="literal">my</code> with defined <code class="literal">side</code> and <code class="literal">height</code>:</p><pre class="programlisting">    var my = objectPlus(triangle, { &#13;
      side: 4, height: 4 &#13;
    }); &#13;
    &gt;my.getArea(); &#13;
    8 &#13;
    &gt;my.toString(); &#13;
    "Shape, 2D shape, Triangle, Triangle" &#13;
</pre><p>The difference here, when executing <code class="literal">toString()</code>, is that the <code class="literal">Triangle</code> name is repeated twice. That's because the concrete instance was created by inheriting <code class="literal">triangle</code>, so there was one more level of inheritance. You could give the new instance a name:</p><pre class="programlisting">    &gt;objectPlus(triangle, { &#13;
      side: 4,  &#13;
      height: 4, &#13;
      name: 'My 4x4' &#13;
    }).toString(); &#13;
    "Shape, 2D shape, Triangle, My 4x4" &#13;
</pre><p>This <code class="literal">objectPlus()</code> is even closer to ES5's <code class="literal">Object.create();</code> only the ES5 one takes the additional properties (the second argument) using something called property descriptors (discussed in <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <em>Built-In Objects</em>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Multiple inheritance</h1></div></div></div><p>Multiple inheritance is where a child inherits from more than one parent. Some OO languages support multiple inheritance out of the box and some don't. You can argue both ways, that multiple inheritance is convenient or that it's unnecessary, complicates application design, and it's better to use an inheritance chain instead. Leaving the discussion of multiple inheritance's pros and cons for the long, cold winter nights, let's see how you can do it in practice in JavaScript.</p><p>The implementation can be as simple as taking the idea of inheritance by copying properties and expanding it so that it takes an unlimited number of input objects to inherit from.</p><p>Let's create a <code class="literal">multi()</code> function that accepts any number of input objects. You can wrap the loop that copies properties in another loop that goes through all the objects passed as <code class="literal">arguments</code> to the function:</p><pre class="programlisting">    function multi() { &#13;
      var n = {}, stuff, j = 0, len = arguments.length; &#13;
      for (j = 0; j &lt;len; j++) { &#13;
        stuff = arguments[j]; &#13;
        for (var i in stuff) { &#13;
          if (stuff.hasOwnProperty(i)) { &#13;
            n[i] = stuff[i]; &#13;
          } &#13;
        } &#13;
      } &#13;
      return n; &#13;
    } &#13;
</pre><p>Let's test this by creating three objects-<code class="literal">shape</code>, <code class="literal">twoDee</code>, and a third, unnamed object. Then, creating a <code class="literal">triangle</code> object means calling <code class="literal">multi()</code> and passing all three objects:</p><pre class="programlisting">    var shape = { &#13;
      name: 'Shape', &#13;
      toString: function () { &#13;
        return this.name; &#13;
      } &#13;
    }; &#13;
 &#13;
    var twoDee = { &#13;
      name: '2D shape', &#13;
      dimensions: 2 &#13;
    }; &#13;
 &#13;
    var triangle = multi(shape, twoDee, { &#13;
      name: 'Triangle', &#13;
      getArea: function () { &#13;
        return this.side * this.height / 2; &#13;
      }, &#13;
      side: 5, &#13;
      height: 10 &#13;
    }); &#13;
</pre><p>Does this work? Let's see. The <code class="literal">getArea()</code> method should be an own property, <code class="literal">dimensions</code> should come from <code class="literal">twoDee</code>, and <code class="literal">toString()</code> should come from <code class="literal">shape</code>:</p><pre class="programlisting">    &gt;triangle.getArea(); &#13;
    25 &#13;
    &gt;triangle.dimensions; &#13;
    2 &#13;
    &gt;triangle.toString(); &#13;
    "Triangle" &#13;
</pre><p>Bear in mind that <code class="literal">multi()</code> loops through the input objects in the order they appear and if it happens that two of them have the same property, the last one wins.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Mixins</h2></div></div></div><p>You might come across the term mixin. Think of a mixin as an object that provides some useful functionality but is not meant to be inherited and extended by subobjects. The approach to multiple inheritance outlined previously can be considered an implementation of the mixins idea. When you create a new object, you can pick and choose any other objects to mix into your new object. By passing them all to <code class="literal">multi()</code>, you get all their functionality without making them part of the inheritance tree.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Parasitic inheritance</h1></div></div></div><p>If you like the fact that you can have all kinds of different ways to implement inheritance in JavaScript and you're hungry for more, here's another one. This pattern, courtesy of Douglas Crockford, is called parasitic inheritance. It's about a function that creates objects by taking all the functionality from another object into a new one, augmenting the new object, and returning it, pretending that it has done all the work.</p><p>Here's an ordinary object, defined with an object literal, and unaware of the fact that it's soon going to fall victim to parasitism:</p><pre class="programlisting">    var twoD = { &#13;
      name: '2D shape', &#13;
      dimensions: 2 &#13;
    }; &#13;
</pre><p>A function that creates <code class="literal">triangle</code> objects could:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the <code class="literal">twoD</code> object as a prototype of an object called that (similar to this for convenience). This can be done in any way you saw previously, for example, using the <code class="literal">object()</code> function or copying all the properties.</li><li class="listitem" style="list-style-type: disc">Augment that with more properties.</li><li class="listitem" style="list-style-type: disc">Return <code class="literal">that</code>:<pre class="programlisting">        function triangle(s, h) { &#13;
          var that = object(twoD); &#13;
          that.name ='Triangle'; &#13;
          that.getArea = function () { &#13;
            return this.side * this.height / 2; &#13;
          }; &#13;
          that.side = s; &#13;
          that.height = h; &#13;
          return that; &#13;
        } &#13;
</pre></li></ul></div><p>Because <code class="literal">triangle()</code> is a normal function, not a constructor, it doesn't require the <code class="literal">new</code> operator. However, because it returns an object, calling it with <code class="literal">new</code> by mistake works too:</p><pre class="programlisting">    &gt;var t = triangle(5, 10); &#13;
   &gt;t.dimensions; &#13;
    2 &#13;
    &gt;var t2 = new triangle(5,5); &#13;
    &gt;t2.getArea(); &#13;
    12.5 &#13;
</pre><p>Note that <code class="literal">that</code> is just a name, it doesn't have a special meaning, the way <code class="literal">this</code> does.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Borrowing a constructor</h1></div></div></div><p>One more way of implementing inheritance (the last one in the chapter, I promise) has to do again with constructor functions and not the objects directly. In this pattern, the constructor of the child calls the constructor of the parent using either the <code class="literal">call()</code> or <code class="literal">apply()</code> method. This can be called <strong>stealing a constructor</strong> or <strong>inheritance by borrowing a constructor</strong> if you want to be more subtle about it.</p><p>The <code class="literal">call()</code> and <code class="literal">apply()</code> methods were discussed in <a class="link" href="ch04.html" title="Chapter 4. Objects">Chapter 4</a>, <em>Objects</em>, but here's a refresher; they allow you to call a function and pass an object that the function should bind to its <code class="literal">this</code> value. So for inheritance purposes, the child constructor calls the parent's constructor and binds the child's newly created <code class="literal">this</code> object as the parent's <code class="literal">this</code>.</p><p>Let's have this parent constructor <code class="literal">Shape()</code>:</p><pre class="programlisting">    function Shape(id) { &#13;
      this.id = id; &#13;
    } &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
      return this.name; &#13;
    }; &#13;
</pre><p>Now, let's define <code class="literal">Triangle()</code>, which uses <code class="literal">apply()</code> to call the <code class="literal">Shape()</code> constructor, passing <code class="literal">this</code> (an instance created with <code class="literal">new Triangle()</code>) and any additional arguments:</p><pre class="programlisting">   function Triangle() { &#13;
    Shape.apply(this, arguments); &#13;
    } &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
</pre><p>Note that both <code class="literal">Triangle()</code> and <code class="literal">Shape()</code>have added some extra properties to their prototypes.</p><p>Now, let's test this by creating a new <code class="literal">triangle</code> object:</p><pre class="programlisting">    &gt;var t = new Triangle(101); &#13;
    &gt;t.name; &#13;
    "Triangle" &#13;
</pre><p>The new <code class="literal">triangle</code> object inherits the <code class="literal">id</code> property from the parent, but it doesn't inherit anything added to the parent's <code class="literal">prototype</code>:</p><pre class="programlisting">    &gt;t.id; &#13;
    101 &#13;
    &gt;t.toString(); &#13;
    "[object Object]" &#13;
</pre><p>The triangle failed to get the <code class="literal">Shape</code> function's prototype properties because there was never a <code class="literal">new Shape()</code> instance created, so the prototype was never used. However, you saw how to do this at the beginning of this chapter. You can redefine <code class="literal">Triangle</code> as follows:</p><pre class="programlisting">    function Triangle() { &#13;
      Shape.apply(this, arguments); &#13;
    } &#13;
    Triangle.prototype = new Shape(); &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
</pre><p>In this inheritance pattern, the parent's own properties are recreated as the child's own properties. If a child inherits an array or other object, it's a completely new value (not a reference), and modifying it won't affect the parent.</p><p>The drawback is that the parent's constructor gets called twice-once with <code class="literal">apply()</code> to inherit own properties and once with <code class="literal">new</code> to inherit the prototype. In fact, the own properties of the parent are inherited twice. Let's take this simplified scenario:</p><pre class="programlisting">    function Shape(id) { &#13;
      this.id = id; &#13;
    } &#13;
    function Triangle() { &#13;
      Shape.apply(this, arguments); &#13;
    } &#13;
    Triangle.prototype = new Shape(101); &#13;
</pre><p>Here, we will create a new instance:</p><pre class="programlisting">    &gt;var t = new Triangle(202); &#13;
    &gt;t.id; &#13;
    202 &#13;
</pre><p>There's an own property <code class="literal">id,</code> but there's also one that comes down the prototype chain, ready to shine through:</p><pre class="programlisting">    &gt;t.__proto__.id; &#13;
    101 &#13;
    &gt; delete t.id; &#13;
    true &#13;
    &gt;t.id; &#13;
    101 &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Borrowing a constructor and copying its prototype</h2></div></div></div><p>The problem of the double work performed by calling the constructor twice can easily be corrected. You can call <code class="literal">apply()</code> on the parent constructor to get all own properties and then copy the prototype's properties using a simple iteration (or <code class="literal">extend2()</code> as discussed previously):</p><pre class="programlisting">    function Shape(id) { &#13;
      this.id = id; &#13;
    } &#13;
    Shape.prototype.name = 'Shape'; &#13;
    Shape.prototype.toString = function () { &#13;
      return this.name; &#13;
    }; &#13;
 &#13;
    function Triangle() { &#13;
      Shape.apply(this, arguments); &#13;
    } &#13;
    extend2(Triangle, Shape); &#13;
    Triangle.prototype.name = 'Triangle'; &#13;
</pre><p>Lets test the following code:</p><pre class="programlisting">   &gt;var t = new Triangle(101); &#13;
    &gt;t.toString(); &#13;
    "Triangle" &#13;
    &gt;t.id; &#13;
    101 &#13;
</pre><p>No double inheritance:</p><pre class="programlisting">    &gt;typeoft.__proto__.id; &#13;
    "undefined" &#13;
</pre><p>The <code class="literal">extend2()</code> method also gives access to <code class="literal">uber</code> if needed:</p><pre class="programlisting">    &gt;t.uber.name; &#13;
    "Shape" &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Case study - drawing shapes</h1></div></div></div><p>Let's finish off this chapter with a more practical example of using inheritance. The task is to be able to calculate the area and the perimeter of different shapes, as well as to draw them, while reusing as much code as possible.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Analysis</h2></div></div></div><p>Let's have one <code class="literal">Shape</code> constructor that contains all the common parts. From there, let's have <code class="literal">Triangle</code>, <code class="literal">Rectangle</code>, and <code class="literal">Square</code> constructors, all inheriting from <code class="literal">Shape</code>. A square is really a rectangle with the same length sides, so let's reuse <code class="literal">Rectangle</code> when building <code class="literal">Square</code>.</p><p>In order to define a shape, you'll need points with <code class="literal">x</code> and <code class="literal">y</code> coordinates. A generic shape can have any number of points. A triangle is defined with three points, a rectangle (to keep it simpler) with one point and the lengths of the sides. The perimeter of any shape is the sum of its side's lengths. Calculating the area is shape specific and will be implemented by each shape.</p><p>The common functionality in <code class="literal">Shape</code> would be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">draw()</code> method that can draw any shape given the points</li><li class="listitem" style="list-style-type: disc">A <code class="literal">getParameter()</code> method</li><li class="listitem" style="list-style-type: disc">A property that contains an array of <code class="literal">points</code></li><li class="listitem" style="list-style-type: disc">Other methods and properties as needed</li></ul></div><p>For the drawing part, let's use a <code class="literal">&lt;canvas&gt;</code> tag. It's not supported in early IEs, but hey, this is just an exercise.</p><p>Let's have two other helper constructors-<code class="literal">Point</code> and <code class="literal">Line</code>. <code class="literal">Point</code> will help when defining shapes. <code class="literal">Line</code> will make calculations easier, as it can give the length of the line connecting any two given points.</p><p>You can play with a working example at <a class="ulink" href="http://www.phpied.com/files/canvas/">http://www.phpied.com/files/canvas/</a>. Just open your console and start creating new shapes as you'll see in a moment.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Implementation</h2></div></div></div><p>Let's start by adding a <code class="literal">canvas</code> tag to a blank HTML page:</p><pre class="programlisting">    &lt;canvas height="600" width="800" id="canvas" /&gt; &#13;
</pre><p>Then, put the JavaScript code inside <code class="literal">&lt;script&gt;</code> tags:</p><pre class="programlisting">    &lt;script&gt; &#13;
    // ... code goes here &#13;
    &lt;/script&gt; &#13;
</pre><p>Now, let's take a look at what's in the JavaScript part. First is the helper <code class="literal">Point</code> constructor. It just can't get any simpler than the following:</p><pre class="programlisting">    function Point(x, y) { &#13;
      this.x = x; &#13;
      this.y = y; &#13;
    } &#13;
</pre><p>Bear in mind that the coordinates of the points on the <code class="literal">canvas</code> start from <code class="literal">x=0</code>, <code class="literal">y=0</code>, which is the top left. The bottom right will be <code class="literal">x = 800</code>, <code class="literal">y = 600</code>:</p><p>
</p><div><img src="img/image_07_003.jpg" alt="Implementation"/></div><p>
</p><p>Next comes the <code class="literal">Line</code> constructor. It takes two points and calculates the length of the line between them, using the Pythagorean theorem <em>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></em> (imagine a right-angled triangle where the hypotenuse connects the two given points):</p><pre class="programlisting">    function Line(p1, p2) { &#13;
      this.p1 = p1; &#13;
      this.p2 = p2; &#13;
      this.length = Math.sqrt( &#13;
      Math.pow(p1.x - p2.x, 2) + &#13;
      Math.pow(p1.y - p2.y, 2) &#13;
      ); &#13;
    } &#13;
</pre><p>Next comes the <code class="literal">Shape</code> constructor. The shapes will have their points (and the lines that connect them) as own properties. The constructor also invokes an initialization method, <code class="literal">init()</code>, that will be defined in the prototype:</p><pre class="programlisting">    function Shape() { &#13;
      this.points = []; &#13;
      this.lines= []; &#13;
      this.init(); &#13;
    } &#13;
</pre><p>Now, the big part-the methods of <code class="literal">Shape.prototype</code>. Let's define all these methods using the object literal notation. Refer to the comments for guidelines as to what each method does:</p><pre class="programlisting">    Shape.prototype = { &#13;
      // reset pointer to constructor &#13;
      constructor: Shape, &#13;
 &#13;
      // initialization, sets this.context to point &#13;
      // to the context if the canvas object &#13;
      init: function () { &#13;
        if (this.context === undefined) { &#13;
          var canvas = document.getElementById('canvas'); &#13;
          Shape.prototype.context = canvas.getContext('2d'); &#13;
        } &#13;
      }, &#13;
 &#13;
      // method that draws a shape by looping through this.points &#13;
      draw: function () { &#13;
        var i, ctx = this.context; &#13;
        ctx.strokeStyle = this.getColor(); &#13;
        ctx.beginPath(); &#13;
        ctx.moveTo(this.points[0].x, this.points[0].y); &#13;
        for (i = 1; i&lt;this.points.length; i++) { &#13;
          ctx.lineTo(this.points[i].x, this.points[i].y); &#13;
        } &#13;
        ctx.closePath(); &#13;
        ctx.stroke(); &#13;
      }, &#13;
 &#13;
      // method that generates a random color &#13;
      getColor: function () { &#13;
        var i, rgb = []; &#13;
        for (i = 0; i&lt; 3; i++) { &#13;
          rgb[i] = Math.round(255 * Math.random()); &#13;
        } &#13;
        return 'rgb(' + rgb.join(',') + ')'; &#13;
      }, &#13;
 &#13;
      // method that loops through the points array, &#13;
      // creates Line instances and adds them to this.lines &#13;
     getLines: function () { &#13;
        if (this.lines.length&gt; 0) { &#13;
          return this.lines; &#13;
        } &#13;
        var i, lines = []; &#13;
        for (i = 0; i&lt;this.points.length; i++) { &#13;
          lines[i] = new Line(this.points[i],  &#13;
          this.points[i + 1] || this.points[0]); &#13;
        } &#13;
        this.lines = lines; &#13;
        return lines; &#13;
      }, &#13;
 &#13;
     // shell method, to be implemented by children &#13;
      getArea: function () {}, &#13;
   &#13;
      // sums the lengths of all lines &#13;
      getPerimeter: function () { &#13;
        var i, perim = 0, lines = this.getLines(); &#13;
        for (i = 0; i&lt;lines.length; i++) { &#13;
          perim += lines[i].length; &#13;
        } &#13;
        return perim; &#13;
      } &#13;
    }; &#13;
</pre><p>Now, the children constructor functions. <code class="literal">Triangle</code> comes first:</p><pre class="programlisting">    function Triangle(a, b, c) { &#13;
      this.points = [a, b, c]; &#13;
   &#13;
      this.getArea = function () { &#13;
        var p = this.getPerimeter(), &#13;
        s = p / 2; &#13;
        return Math.sqrt( s * (s - this.lines[0].length) * &#13;
          (s - this.lines[1].length) * (s - this.lines[2].length)); &#13;
      }; &#13;
    } &#13;
</pre><p>The <code class="literal">Triangle</code> constructor takes three point objects and assigns them to <code class="literal">this.points</code> (its own collection of points). Then, it implements the <code class="literal">getArea()</code> method, using Heron's formula:</p><pre class="programlisting">    Area = s(s-a)(s-b)(s-c) &#13;
</pre><p>
<code class="literal">s</code> is the semi-perimeter (perimeter divided by two).</p><p>Next comes the <code class="literal">Rectangle</code> constructor. It receives one point (the upper-left point) and the lengths of the two sides. Then, it populates its <code class="literal">points</code> array starting from that one point:</p><pre class="programlisting">    function Rectangle(p, side_a, side_b){ &#13;
    this.points = [ &#13;
    p, &#13;
    new Point(p.x + side_a, p.y),// top right &#13;
    new Point(p.x + side_a, p.y + side_b), // bottom right &#13;
    new Point(p.x, p.y + side_b)// bottom left &#13;
    ]; &#13;
    this.getArea = function () { &#13;
    return side_a * side_b; &#13;
    }; &#13;
    } &#13;
</pre><p>The last child constructor is <code class="literal">Square</code>. A square is a special case of a rectangle, so it makes sense to reuse <code class="literal">Rectangle</code>. The easiest thing to do here is to borrow the constructor:</p><pre class="programlisting">    function Square(p, side){ &#13;
      Rectangle.call(this, p, side, side); &#13;
    } &#13;
</pre><p>Now that all constructors are done, let's take care of inheritance. Any pseudo-classical pattern (one that works with constructors as opposed to objects) will do. Let's try using a modified and simplified version of the prototype-chaining pattern (the first method described in this chapter). This pattern calls for creating a new instance of the parent and setting it as the child's prototype. In this case, it's not necessary to have a new instance for each child-they can all share it:</p><pre class="programlisting">    (function () { &#13;
    var s = new Shape(); &#13;
    Triangle.prototype = s; &#13;
    Rectangle.prototype = s; &#13;
    Square.prototype = s; &#13;
    })(); &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Testing</h2></div></div></div><p>Let's test this by drawing shapes. First, define three points for a triangle:</p><pre class="programlisting">    &gt;var p1 = new Point(100, 100); &#13;
    &gt;var p2 = new Point(300, 100); &#13;
    &gt;var p3 = new Point(200, 0); &#13;
</pre><p>Now you can create a triangle by passing the three points to the <code class="literal">Triangle</code> constructor:</p><pre class="programlisting">    &gt;var t = new Triangle(p1, p2, p3); &#13;
</pre><p>You can call the methods to draw the triangle on the <code class="literal">canvas</code> and get its area and perimeter:</p><pre class="programlisting">    &gt;t.draw(); &#13;
    &gt;t.getPerimeter(); &#13;
    482.842712474619 &#13;
    &gt;t.getArea(); &#13;
    10000.000000000002 &#13;
</pre><p>Now let's play with a rectangle instance:</p><pre class="programlisting">    &gt;var r = new Rectangle(new Point(200, 200), 50, 100); &#13;
    &gt;r.draw(); &#13;
    &gt;r.getArea(); &#13;
    5000 &#13;
    &gt;r.getPerimeter(); &#13;
    300 &#13;
</pre><p>And finally, let's play with a square:</p><pre class="programlisting">    &gt;var s = new Square(new Point(130, 130), 50); &#13;
    &gt;s.draw(); &#13;
    &gt;s.getArea(); &#13;
    2500 &#13;
    &gt;s.getPerimeter(); &#13;
    200 &#13;
</pre><p>It's fun to draw these shapes. You can also be as lazy as the following example, which draws another square, reusing a triangle's point:</p><pre class="programlisting">    &gt; new Square(p1, 200).draw(); &#13;
</pre><p>The result of the tests will be something like the following:</p><p>
</p><div><img src="img/image_07_004.jpg" alt="Testing"/></div><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Exercises</h1></div></div></div><p>Lets do the following exercise:</p><div><ol class="orderedlist arabic"><li class="listitem">Implement multiple inheritance but with a prototypal inheritance pattern, not property copying. Here is an example:<pre class="programlisting">        var my = objectMulti(obj, another_obj, a_third, { &#13;
        additional: "properties" &#13;
        }); &#13;
</pre><p>The <code class="literal">additional</code> property should be an own property; all the rest should be mixed into the prototype.</p></li><li class="listitem">Use the <code class="literal">canvas</code> example to practice. Try out different things. Here are some examples:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Draw a few triangles, squares, and rectangles.</li><li class="listitem" style="list-style-type: disc">Add constructors for more shapes, such as <code class="literal">Trapezoid</code>, <code class="literal">Rhombus</code>, <code class="literal">Kite</code>, and <code class="literal">Pentagon</code>. If you want to learn more about the <code class="literal">canvas</code> tag, create a <code class="literal">Circle</code> constructor too. It will need to overwrite the <code class="literal">draw()</code> method of the parent.</li><li class="listitem" style="list-style-type: disc">Can you think of another way to approach the problem and use another type of inheritance?</li><li class="listitem" style="list-style-type: disc">Pick one of the methods that uses <code class="literal">uber</code> as a way for a child to access its parent. Add functionality where the parents can keep track of who their children are, perhaps using a property that contains a <code class="literal">children</code> array?</li></ul></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Summary</h1></div></div></div><p>In this chapter, you learned quite a few ways (patterns) of implementing inheritance, and the following table summarizes them. The different types can roughly be divided into the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Patterns that work with constructors</li><li class="listitem" style="list-style-type: disc">Patterns that work with objects</li></ul></div><p>You can also classify the patterns based on whether they:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the prototype</li><li class="listitem" style="list-style-type: disc">Copy properties</li><li class="listitem" style="list-style-type: disc">Do both (copy properties of the prototype):</li></ul></div><div><table border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>
<p>
<strong>#</strong>
</p>
</th><th>
<p>
<strong>Name</strong>
</p>
</th><th>
<p>
<strong>Example</strong>
</p>
</th><th>
<p>
<strong>Classification</strong>
</p>
</th><th>
<p>
<strong>Notes</strong>
</p>
</th></tr></thead><tbody><tr><td>
<p>1</p>
</td><td>
<p>
</p><p>Prototype chaining</p><p>
</p><p>(pseudo-classical)</p><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">Child.prototype = new Parent();   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with constructors</li><li class="listitem" style="list-style-type: disc">Uses the prototype chain</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The default mechanism</li><li class="listitem" style="list-style-type: disc">Tip - move all properties/methods that are meant to be reused to the prototype, and add the non-reusable as own properties</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>2</p>
</td><td>
<p>Inherit only the prototype</p>
</td><td>
<p>
</p><pre class="programlisting">Child.prototype = Parent.prototype;   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with constructors</li><li class="listitem" style="list-style-type: disc">Copies the prototype (no prototype chain, as all share the same prototype object)</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More efficient; no new instances are created just for the sake of inheritance</li><li class="listitem" style="list-style-type: disc">Prototype chain lookup during runtime; it is fast, since there's no chain</li><li class="listitem" style="list-style-type: disc">Drawback: children can modify parents' functionality</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>3</p>
</td><td>
<p>Temporary constructor</p>
</td><td>
<p>
</p><pre class="programlisting">function extend(Child, Parent) {   &#13;
 var F = function(){};   &#13;
 F.prototype = Parent.prototype;   &#13;
Child.prototype = new F();   &#13;
Child.prototype.constructor = Child;   &#13;
Child.uber = Parent.prototype;   &#13;
}   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with constructors</li><li class="listitem" style="list-style-type: disc">Uses the prototype chain</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unlike #1, it only inherits properties of the prototype; own properties (created with this inside the constructor) are not inherited.</li><li class="listitem" style="list-style-type: disc">Provides convenient access to the parent (through <code class="literal">uber</code>)</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>4</p>
</td><td>
<p>Copying the <code class="literal">prototype</code> properties</p>
</td><td>
<p>
</p><pre class="programlisting">function extend2(Child, Parent) {   &#13;
var p = Parent.prototype;   &#13;
var c = Child.prototype;   &#13;
 for (var i in p) {   &#13;
 c[i] = p[i];   &#13;
 }   &#13;
c.uber = p;   &#13;
}   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with constructors</li><li class="listitem" style="list-style-type: disc">Copies properties</li><li class="listitem" style="list-style-type: disc">Uses the prototype chain</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All properties of the parent prototype become properties of the child prototype</li><li class="listitem" style="list-style-type: disc">No need to create a new object only for inheritance purposes</li><li class="listitem" style="list-style-type: disc">Shorter prototype chains</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>5</p>
</td><td>
<p>
</p><p>Copy all properties</p><p>
</p><p>(shallow copy)</p><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">function extendCopy(p) {   &#13;
var c = {};    &#13;
 for (var i in p) {   &#13;
 c[i] = p[i];   &#13;
 }   &#13;
c.uber = p;   &#13;
 return c;   &#13;
}   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with objects</li><li class="listitem" style="list-style-type: disc">Copies properties</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simple</li><li class="listitem" style="list-style-type: disc">Doesn't use prototypes</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>6</p>
</td><td>
<p>Deep copy</p>
</td><td>
<p>Same as the previous one, but recurse into objects</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with objects</li><li class="listitem" style="list-style-type: disc">Copies properties</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Same as #5, but clones objects and arrays</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>7</p>
</td><td>
<p>Prototypal inheritance</p>
</td><td>
<p>
</p><pre class="programlisting">function object(o){   &#13;
 function F() {}   &#13;
F.prototype = o;   &#13;
 return new F();   &#13;
}   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with objects</li><li class="listitem" style="list-style-type: disc">Uses the prototype chain</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No pseudo-classes, objects inherit from objects</li><li class="listitem" style="list-style-type: disc">Leverages the benefits of the prototype</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>8</p>
</td><td>
<p>Extend and augment</p>
</td><td>
<p>
</p><pre class="programlisting">function objectPlus(o, stuff) {   &#13;
var n;   &#13;
 function F() {}   &#13;
F.prototype = o;   &#13;
 n = new F();   &#13;
n.uber = o;   &#13;
 for (var i in stuff) {   &#13;
 n[i] = stuff[i];   &#13;
 }   &#13;
 return n;   &#13;
}   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with objects</li><li class="listitem" style="list-style-type: disc">Uses the prototype chain</li><li class="listitem" style="list-style-type: disc">Copies properties</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mix of prototypal inheritance (#7) and copying properties (#5)</li><li class="listitem" style="list-style-type: disc">One function call to inherit and extend at the same time</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>9</p>
</td><td>
<p>Multiple inheritance</p>
</td><td>
<p>
</p><pre class="programlisting">function multi() {   &#13;
var n = {}, stuff, j = 0,   &#13;
len = arguments.length;   &#13;
 for (j = 0; j &lt;len; j++) {   &#13;
 stuff = arguments[j];   &#13;
 for (var i in stuff) {   &#13;
 n[i] = stuff[i];   &#13;
 }   &#13;
 }   &#13;
 return n;   &#13;
}    &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with objects</li><li class="listitem" style="list-style-type: disc">Copies properties</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A mixin-style implementation</li><li class="listitem" style="list-style-type: disc">Copies all the properties of all the parent objects in the order of appearance</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>10</p>
</td><td>
<p>Parasitic inheritance</p>
</td><td>
<p>
</p><pre class="programlisting">function parasite(victim) {   &#13;
var that = object(victim);   &#13;
that.more = 1;   &#13;
 return that;   &#13;
}   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with objects</li><li class="listitem" style="list-style-type: disc">Uses the prototype chain</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Constructor-like function creates objects</li><li class="listitem" style="list-style-type: disc">Copies an object, and augments and returns the copy</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>11</p>
</td><td>
<p>Borrowing constructors</p>
</td><td>
<p>
</p><pre class="programlisting">function Child() {   &#13;
Parent.apply(this, arguments);   &#13;
}   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with constructors</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inherits only own properties</li><li class="listitem" style="list-style-type: disc">Can be combined with #1 to inherit the prototype too</li><li class="listitem" style="list-style-type: disc">Convenient way to deal with the issues when a child inherits a property that is an object (and therefore, passed by reference)</li></ul></div><p>
</p>
</td></tr><tr><td>
<p>12</p>
</td><td>
<p>Borrow a constructor and copy the prototype</p>
</td><td>
<p>
</p><pre class="programlisting">function Child() {   &#13;
Parent.apply(this, arguments);   &#13;
}   &#13;
   &#13;
extend2(Child, Parent);   &#13;
</pre><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Works with constructors</li><li class="listitem" style="list-style-type: disc">Uses the prototype chain</li><li class="listitem" style="list-style-type: disc">Copies properties</li></ul></div><p>
</p>
</td><td>
<p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Combination of #11 and #4</li><li class="listitem" style="list-style-type: disc">Allows you to inherit both own properties and prototype properties without calling the parent constructor twice</li></ul></div><p>
</p>
</td></tr></tbody></table></div><p>Given so many options, you must be wondering which is the right one. That depends on your style and preferences, your project, task, and team. Are you more comfortable thinking in terms of classes? Then pick one of the methods that work with constructors. Are you going to need just one or a few instances of your class? Then choose an object-based pattern.</p><p>Are these the only ways of implementing inheritance? No. You can choose a pattern from the preceding table, you can mix them, or you can think of your own. The important thing is to understand and be comfortable with objects, prototypes, and constructors; the rest is just pure joy.</p></div></body></html>