<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using NoSQL Databases</h1>
                </header>
            
            <article>
                
<p><span>In the last chapter, w</span>e implemented a sample application exposing a read-only service that provided catalog data. For the sake of simplicity, we introduced a performance bottleneck in this implementation by using file storage. This storage is not suitable for web applications. It relies on 33 physical files, preventing our application from servicing heavy loads, as file storage lacks multitenant support due to disc I/O operations. In other words, we definitely need to look for a better storage solution, which scales easily, when needed, following the demands of our REST-enabled application. NoSQL databases are now heavily used in web and in cloud environments, ensuring zero downtime and high availability. They have the following advantages over traditional transactional SQL databases:</p>
<ul>
<li>They <strong>support schema versions</strong>; that is, they can work with object representations rather than filling the object state based on definitions of one or several tables.</li>
<li>They are <strong>extensible</strong>, because they store an actual object. Data evolution is supported implicitly, so all you need to do is call the operation that stores the modified object.</li>
<li>They are designed to be <strong>highly distributed</strong> and <strong>scalable</strong>.</li>
</ul>
<p>Nearly all modern NoSQL solutions out there support clustering and can scale further, along with the load of your application. Additionally, most of them have REST-enabled interfaces over HTTP, which eases their usage over a load balancer in high-availability scenarios. Classical database drivers are usually not available for traditional client-side languages, such as JavaScript, because they require native libraries or drivers. However, the idea of NoSQL originated from using document data stores. Thus, most of them support the JSON format, which is native to JavaScript. Last but not least, most NoSQL solutions are open source and are available for free, with all the benefits that open source projects offer: community, examples, and freedom!</p>
<p>In this chapter, we will take a look at the MongoDB NoSQL database and the Mongoose module that interacts with it. We will see how to design and implement automated tests for the database models. Finally, at the end of the chapter, we will remove the file storage bottleneck and will move our application to an almost ready for production state.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">MongoDB – a document store database</h1>
                </header>
            
            <article>
                
<p>MongoDB is an open source document database with built-in support for the JSON format. It provides a full index support, based on any of the available attributes in a document. It is ideal for high-availability scenarios due to its scalability features. MongoDB, available at <span class="URLPACKT"><a href="https://mms.mongodb.com/">https://mms.mongodb.com</a></span>, is cloud-ready with its management services, <strong>MongoDB Management Services</strong> (<strong>MMS</strong>). They utilize and automate most development operations that need to be carried out to keep your cloud database in good shape, taking care of upgrades, further scaling, backups, recovery, performance, and security alerts.</p>
<p>Let's move forward and install MongoDB. Installers for Windows, Linux, macOS, and Solaris are available at <span class="URLPACKT"><a href="http://www.mongodb.org/downloads">http://www.mongodb.org/downloads</a></span>. Linux users can find MongoDB in all popular distribution repositories, while Windows users can make use of a user-friendly wizard which will guide you through the installation steps, where, for a typical installation, all you need to do is accept the license agreement and provide an installation path.</p>
<p>After a successful installation, execute the following command to start MongoDB. If you want to specify a custom location for your data, you have to use the <kbd>--dbpath</kbd> argument. Optionally, you can start the MongoDB HTTP console via the <kbd>--rest</kbd> argument:</p>
<pre><strong>mongod --dbpath ./data --rest</strong></pre>
<p>The default port for communicating with MongoDB is <kbd>27017</kbd>, and its HTTP console is implicitly configured to use a port higher than the data port by a value of 1,000. Therefore, the default port of the console will be <kbd>28017</kbd>. The HTTP console provides useful information about the database, such as logs, health status, available databases, and so on. I strongly advise you to spend some time with it. The console can also be used as a RESTful health check service of the database, because it provides JSON-encoded information about the running database services and the last error that occurred:</p>
<pre><strong>GET /replSetGetStatus?text=1 HTTP/1.1</strong>
<strong>Host: localhost:28017</strong>
<strong>Connection: Keep-Alive</strong>
<strong>User-Agent: RestClient-Tool</strong>
    
<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Length: 56</strong>
<strong>Connection: close</strong>
<strong>Content-Type: text/plain;charset=utf-8</strong>
    
<strong>{</strong>
<strong>"ok": 0,</strong>
<strong>"errmsg": "not running with --replSet"</strong>
<strong>}</strong></pre>
<p>This REST interface can be used in a script or an application to automate altering notifications providing the current state of the database engine and so on.</p>
<p>The log section of the console shows that your server is running successfully (if it is). Now we are ready to move further and see how to connect Node.js to MongoDB.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Database modeling with Mongoose</h1>
                </header>
            
            <article>
                
<p><strong>Mongoose</strong> is a module that connects Node.js to MongoDB in an <strong>object document mapper</strong> (<strong>ODM</strong>) style. It offers the <strong>Create, Read, Update, and Delete</strong> (also known as <strong>CRUD</strong>) functionalities for documents stored in the database. Mongoose defines the structure of the used documents using schemas. The schema is the smallest unit of data definition in Mongoose. A model is built out of a schema definition. It is a constructor-like function that can be used to create or query documents. Documents are instances of a model and represent one-to-one mapping to the documents stored in MongoDB. The schema-model-document hierarchy provides a self-descriptive way of defining objects and allows easy data validation.</p>
<p>Let's start by installing Mongoose with <kbd>npm</kbd>:</p>
<pre><strong>npm install mongoose</strong></pre>
<p>Now that we have the Mongoose module installed, our first step will be to define a schema that will represent an item in the catalog:</p>
<pre>var mongoose = require('mongoose'); 
var Schema = mongoose.Schema;<br/>var itemSchema = new Schema ({<br/>    "itemId" : {type: String, index: {unique: true}},<br/>    "itemName": String,<br/>    "price": Number,<br/>    "currency" : String,<br/>    "categories": [String]
}); </pre>
<p>The preceding code snippet creates a schema definition of an item. Defining a schema is straightforward and is quite similar to JSON schema definition; you have to describe and attribute with its type and optionally provide additional properties for each key. In the case of the catalog application, we need to use the <kbd>itemId</kbd> as a unique index in order to avoid having two different items with the same ID. Thus, apart from defining its type as <kbd>String</kbd>, we also use the <kbd>index</kbd> attribute to describe that the value of the <kbd>itemId</kbd> field must be unique for each individual item.</p>
<p>Mongoose introduces the term <strong>model</strong>. A model is a constructor-like function compiled out of a schema definition. An instance of a model represents a document that can be saved to or read from the database. Creating a model instance is done by calling the <kbd>model</kbd> function of a <kbd>mongoose</kbd> instance and passing the schema that the model should use:</p>
<pre>var CatalogItem = mongoose.model('Item', itemSchema);</pre>
<p>A model also exposes functions for querying and data manipulations. Assuming that we have initialized a schema and created a model, storing a new item to MongoDB is as simple as creating a new <kbd>model</kbd> instance and invoking its <kbd>save</kbd> function:</p>
<pre>var mongoose = require('mongoose');<br/><br/>mongoose.connect('mongodb://localhost/catalog');<br/>var db = mongoose.connection;<br/><br/>db.on('error', console.error.bind(console, 'connection error:'));<br/>db.once('open', function() {<br/>  var watch = new CatalogItem({<br/>    itemId: 9 ,<br/>    itemName: "Sports Watch1",<br/>    brand: 'А1',<br/>    price: 100,<br/>    currency: "EUR",<br/>    categories: ["Watches", "Sports Watches"]<br/>  });<br/><br/>  watch.save((error, item, affectedNo)=&gt; {<br/>    if (!error) {<br/>      console.log('Item added successfully to the catalog');<br/>    } else {<br/>      console.log('Cannot add item to the catlog');<br/>    }<br/>  });<br/>});<br/><br/>db.once('open', function() {<br/>  var filter = {<br/>    'itemName' : 'Sports Watch1',<br/>    'price': 100<br/>  }<br/><br/>  CatalogItem.find(filter, (error, result) =&gt; {<br/>    if (error) {<br/>      consoloe.log('Error occured');<br/>    } else {<br/>      console.log('Results found:'+ result.length);<br/>      console.log(result);<br/>    }<br/>  });<br/>});<br/><br/><br/></pre>
<p>Here is how to use the model in order to query for documents representing a sports watch belonging to the <kbd>Watches</kbd> group named <kbd>Sports Watches</kbd>:</p>
<pre>db.once('open', function() {<br/>  var filter = {<br/>    'itemName' : 'Sports Watch1',<br/>    'price': 100<br/>  }<br/>  CatalogItem.findOne(filter, (error, result) =&gt; {<br/>    if (error) {<br/>      consoloe.log('Error occurred');<br/>    } else {<br/>      console.log(result);<br/>    }<br/>  });<br/>});</pre>
<p>The model also exposes a <kbd>findOne</kbd> function, a convenient way of finding an object by its unique index and then performing some data manipulation on it, that is, for delete or update operations. The following example deletes an item:</p>
<pre>CatalogItem.findOne({itemId: 1 }, (error, data) =&gt; { 
  if (error) {  
    console.log(error); 
    return; 
  } else { 
    if (!data) { 
    console.log('not found'); 
      return; 
    } else { 
      data.remove(function(error){ 
        if (!error) { data.remove();} 
        else { console.log(error);} 
        }); 
      } 
    } 
 });</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing a Mongoose model with Mocha</h1>
                </header>
            
            <article>
                
<p>Mocha is one of the most popular testing frameworks for JavaScript; its main goal is to provide an easy way to test asynchronous JavaScript code. Let's install Mocha globally so that we can make it available to any Node.js application that we may develop in the future:</p>
<pre><strong>npm install -g mocha</strong></pre>
<p>We will also need an assertion library that can be used together with Mocha. The assertion library provides functions for validating actual values, against expected ones, when they are not equal, the assertion library will cause test failure.  <kbd>Should.js</kbd> assertion library module is easy to use and it will be our choice, so let's install it globally too:</p>
<pre><strong>npm install -g should</strong></pre>
<p>Now that we have our testing modules installed, we need to specify our <kbd>testcase</kbd> file path in the <kbd>package.json</kbd> file. Let's modify it by adding a <kbd>test</kbd> element pointing to Mocha and the <kbd>testcase</kbd> file in the script node:</p>
<pre>{ 
"name": "chapter4", 
"version": "0.0.0", 
"private": true, 
"scripts": { 
"start": "node ./bin/www", 
"test": "mocha test/model-test.js" 
 }, 
"dependencies": { 
"body-parser": "~1.13.2", 
"cookie-parser": "~1.3.5", 
"debug": "~2.2.0", 
"express": "~4.16.0", 
"jade": "~1.11.0", 
"morgan": "~1.6.1", 
"serve-favicon": "~2.3.0" 
 } 
} </pre>
<p>This will tell the npm package manager to trigger Mocha when the <kbd>npm</kbd> test is executed.</p>
<p>Automation of Mongoose tests must not be affected by the current state of the database. To ensure that the results are predictable at each test run, we need to ensure that the database state is exactly as we would expect it. We will implement a module called <kbd>prepare.js</kbd> in the <kbd>test</kbd> directory. It will clear the database before each test run:</p>
<pre>var mongoose = require('mongoose');
beforeEach(function (done) {
  function clearDatabase() {
    for (var i in mongoose.connection.collections) {
      mongoose.connection.collections[i].remove(function() 
      {});
    }
    return done();
  }
  if (mongoose.connection.readyState === 0) {
    mongoose.connect(config.db.test, function (err) {
      if (err) {
        throw err;
      }
      return clearDatabase();
    });
  } else {
    return clearDatabase();
  }
});
afterEach(function (done) {
  mongoose.disconnect();
  return done();
});</pre>
<p>Next, we will implement a Mocha test, which creates a new item:</p>
<pre>var mongoose = require('mongoose');<br/>var should = require('should');<br/>var prepare = require('./prepare');<br/><br/>const model = require('../model/item.js');<br/>const CatalogItem = model.CatalogItem;<br/><br/>mongoose.createConnection('mongodb://localhost/catalog');<br/><br/>describe('CatalogItem: models', function () {<br/>  describe('#create()', function () {<br/>    it('Should create a new CatalogItem', function (done) {<br/><br/>      var item = {<br/>        "itemId": "1",<br/>        "itemName": "Sports Watch",<br/>        "price": 100,<br/>        "currency": "EUR",<br/>        "categories": [<br/>          "Watches",<br/>          "Sports Watches"<br/>        ]<br/><br/>      };<br/><br/>      CatalogItem.create(item, function (err, createdItem) {<br/>        // Check that no error occured<br/>        should.not.exist(err);<br/>        // Assert that the returned item has is what we expect<br/><br/>        createdItem.itemId.should.equal('1');<br/>        createdItem.itemName.should.equal('Sports Watch');<br/>        createdItem.price.should.equal(100);<br/>        createdItem.currency.should.equal('EUR');<br/>        createdItem.categories[0].should.equal('Watches');<br/>        createdItem.categories[1].should.equal('Sports Watches');<br/>        //Notify mocha that the test has completed<br/>        done();<br/>      });<br/>    });<br/>  });<br/>});</pre>
<p>Executing the <kbd>npm test</kbd> now results in a call against the MongoDB database creating an item out of the passed JSON object. After insertion, the assert callback will be executing, ensuring that values passed to by Mongoose are the same as the returned ones from the database. Give it a try and break the test—simply change the expected value in the assert with an invalid one—you will see the test failing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a user-defined model around a Mongoose model</h1>
                </header>
            
            <article>
                
<p>After seeing how a model works, it is time to create a user-defined module that wraps all CRUD operations for the catalog. Since we intend to use that module in a RESTful web application, it seems logical to leave the schema definition and the model creation outside the module and have them provided as arguments of each module function. The same schema definition is used in the unit tests, ensuring stability of the module. Now let's add an implementation for each CRUD function, starting with a <kbd>remove()</kbd> function. It looks up an item based on its <kbd>id</kbd> and deletes it from the database, if it exists:</p>
<pre>exports.remove = function (request, response) {<br/>  console.log('Deleting item with id: '    + request.body.itemId);<br/>  CatalogItem.findOne({itemId: request.params.itemId}, function(error, data) {<br/>      if (error) {<br/>          console.log(error);<br/>          if (response != null) {<br/>              response.writeHead(500, contentTypePlainText);<br/>              response.end('Internal server error');<br/>          }<br/>          return;<br/>      } else {<br/>          if (!data) {<br/>              console.log('Item not found');<br/>              if (response != null) {<br/>                  response.writeHead(404, contentTypePlainText);<br/>                  response.end('Not Found');<br/>              }<br/>              return;<br/>          } else {<br/>              data.remove(function(error){<br/>                  if (!error) {<br/>                      data.remove();<br/>                      response.json({'Status': 'Successfully deleted'});<br/>                  }<br/>                  else {<br/>                      console.log(error);<br/>                      response.writeHead(500, contentTypePlainText);<br/>                      response.end('Internal Server Error');<br/>                  }<br/>              });<br/>          }</pre>
<pre>      }<br/>  });<br/>}</pre>
<p>The <kbd>saveItem()</kbd> function takes the request body payload as an argument. A valid update request will contain the new state of an <kbd>item</kbd> object, represented in JSON format. First, the <kbd>itemId</kbd> is parsed out of the JSON object. Next, lookup is done. If an item exists, it gets updated. Otherwise, a new one gets created:</p>
<pre>exports.saveItem = function(request, response)<br/>{<br/>  var item = toItem(request.body);<br/>  item.save((error) =&gt; {<br/>    if (!error) {<br/>      item.save();<br/>      response.writeHead(201, contentTypeJson);<br/>      response.end(JSON.stringify(request.body));<br/>    } else {<br/>      console.log(error);<br/>      CatalogItem.findOne({itemId : item.itemId    },<br/>      (error, result) =&gt; {<br/>        console.log('Check if such an item exists');<br/>            if (error) {<br/>                console.log(error);<br/>                response.writeHead(500, contentTypePlainText);<br/>                response.end('Internal Server Error');<br/>            } else {<br/>                if (!result) {<br/>                    console.log('Item does not exist. Creating a new one');<br/>                    item.save();<br/>                    response.writeHead(201, contentTypeJson);<br/>                    response.<br/>                    response.end(JSON.stringify(request.body));<br/>                } else {<br/>                    console.log('Updating existing item');<br/>                    result.itemId = item.itemId;<br/>                    result.itemName = item.itemName;<br/>                    result.price = item.price;<br/>                    result.currency = item.currency;<br/>                    result.categories = item.categories;<br/>                    result.save();<br/>                    response.json(JSON.stringify(result));<br/>                }<br/>           }<br/>      });</pre>
<pre>    }<br/>  });<br/>};</pre>
<p>The <kbd>toItem()</kbd> function converts the JSON payload to a <kbd>CatalogItem</kbd> model instance, that is, an item document:</p>
<pre>function toItem(body) {<br/>    return new CatalogItem({<br/>        itemId: body.itemId,<br/>        itemName: body.itemName,<br/>        price: body.price,<br/>        currency: body.currency,<br/>        categories: body.categories<br/>    });<br/>}</pre>
<p>We will also need to provide a means of querying data, so let's implement a function that queries for all items in a category:</p>
<pre>exports.findItemsByCategory = function (category, response) {<br/>    CatalogItem.find({categories: category}, function(error, result) {<br/>        if (error) {<br/>            console.error(error);<br/>            response.writeHead(500, { 'Content-Type': 'text/plain' });<br/>            return;<br/>        } else {<br/>            if (!result) {<br/>                if (response != null) {<br/>                    response.writeHead(404, contentTypePlainText);<br/>                    response.end('Not Found');<br/>                }<br/>                return;<br/>            }<br/><br/>            if (response != null){<br/>                response.setHeader('Content-Type', 'application/json');<br/>                response.send(result);<br/>            }<br/>            console.log(result);<br/>        }<br/>    });<br/>}</pre>
<p>Similar to <kbd>findItemsByCategory</kbd>, the following is a function that finds an item by its ID:</p>
<pre>exports.findItemById = function (itemId, response) {<br/>    CatalogItem.findOne({itemId: itemId}, function(error, result) {<br/>        if (error) {<br/>            console.error(error);<br/>            response.writeHead(500, contentTypePlainText);<br/>            return;<br/>        } else {<br/>            if (!result) {<br/>                if (response != null) {<br/>                    response.writeHead(404, contentTypePlainText);<br/>                    response.end('Not Found');<br/>                }<br/>                return;<br/>            }<br/><br/>            if (response != null){<br/>                response.setHeader('Content-Type', 'application/json');<br/>                response.send(result);<br/>            }<br/>            console.log(result);<br/>        }<br/>    });<br/>}</pre>
<p>Finally, there's a function that lists all the catalog items stored in the database. It uses the Mongoose model <kbd>find</kbd> function that looks for all documents of the model, and uses its first arguments as a filter. We want a function that returns all existing documents; that's why we provide an empty object. This will return all available items. The results are available in the <kbd>callback</kbd> function, which is the second argument of the model's <kbd>find</kbd> function:</p>
<pre>exports.findAllItems = function (response) {<br/>    CatalogItem.find({}, (error, result) =&gt; {<br/>        if (error) {<br/>            console.error(error);<br/>            return null;<br/>        }<br/>        if (result != null) {<br/>            response.json(result);<br/>        } else {</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre>      response.json({});<br/>    }<br/>    });<br/>};</pre>
<p>The <kbd>catalog</kbd> module will be the foundation of our RESTful service. It is responsible for all data manipulation operations, as well as for different kinds of queries. It encapsulates all operations in a reusable way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Wiring up a NoSQL database module to Express</h1>
                </header>
            
            <article>
                
<p>Now we have automated tests for the model and a user-defined module which makes use of them. This ensures the stability of the module and makes it ready for wider adoption.</p>
<p>It is time to build a new Express-based application and add a route, exposing the new module to it:</p>
<pre>const express = require('express');<br/>const router = express.Router();<br/><br/>const catalog = require('../modules/catalog');<br/>const model = require('../model/item.js');<br/><br/>router.get('/', function(request, response, next) {<br/>  catalog.findAllItems(response);<br/>});<br/><br/>router.get('/item/:itemId', function(request, response, next) {<br/>  console.log(request.url + ' : querying for ' + request.params.itemId);<br/>  catalog.findItemById(request.params.itemId, response);<br/>});</pre>
<pre>router.get('/:categoryId', function(request, response, next) {<br/>  console.log(request.url + ' : querying for ' + request.params.categoryId);<br/>  catalog.findItemsByCategory(request.params.categoryId, response);<br/>});<br/><br/>router.post('/', function(request, response, next) {<br/>  console.log('Saving item using POST method);<br/>  catalog.saveItem(request, response);<br/>});<br/><br/>router.put('/', function(request, response, next) {<br/>  console.log('Saving item using PUT method');<br/>  catalog.saveItem(request, response);<br/>});<br/><br/>router.delete('/item/:itemId', function(request, response, next) {<br/>  console.log('Deleting item with id: request.params.itemId);<br/>  catalog.remove(request, response);<br/>});<br/><br/>module.exports = router;</pre>
<p>To sum up, we routed each function of the catalog data service module to an operation of a RESTful service:</p>
<ul>
<li><kbd>GET /catalog/item/:itemId</kbd>: This calls <kbd>catalog.findItemById()</kbd></li>
<li><kbd>POST /catalog</kbd>: This calls <kbd>catalog.saveItem()</kbd></li>
<li><kbd>PUT /catalog</kbd>: This calls <kbd>catalog.saveItem()</kbd></li>
<li><kbd>DELETE / catalog/item/:id</kbd>: This calls <kbd>catalog.remove()</kbd></li>
<li><kbd>GET /catalog/:category</kbd>: This calls <kbd>catalog.findItemsByCategory()</kbd></li>
<li><kbd>GET /catalog/</kbd>: This calls <kbd>catalog.findAllItems()</kbd></li>
</ul>
<p>As we have our operations exposed, we are ready to perform some more serious REST testing. Let's start Postman and test the newly exposed endpoints:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/fa808c10-b5e3-43d7-9733-d6811b64510e.png" style="width:44.08em;height:28.75em;" width="1500" height="979"/></div>
<p>Spend some time testing each operation thoroughly. This will help you gain confidence that the catalog data service module really works, and also will make you more comfortable with how HTTP responses are served and read. As a RESTful API developer, you should be able to read HTTP dumps<span>, which show different request payloads and status codes, </span><span>fluently</span><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Self-test questions</h1>
                </header>
            
            <article>
                
<p>Go through the following questions:</p>
<ul>
<li>How would you perform a query with Mongoose for a single value of a multivalued attribute?</li>
<li>Define a strategy for testing a Node.js module manipulating a NoSQL database.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at MongoDB, a powerful document-oriented database. We utilized it and made use of Mocha to implement an automated test for the database layer. Now it is time to build a fully-fledged RESTful web service. In the next chapter, we will extend the user-defined module by including support for searching via document attributes, and add filtering and pagination capabilities that will finally evolve into full-fledged RESTful service implementation.</p>


            </article>

            
        </section>
    </div>



  </body></html>