<html><head></head><body>
		<div id="_idContainer119">
			<h1 id="_idParaDest-217" class="chapter-number"><a id="_idTextAnchor218"/>12</h1>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor219"/>Ensuring Data Security with the Saga Pattern, Encryption, and Security Measures</h1>
			<p>When working with microservices architecture and Node.js, you need to have a better understanding of data security with the Saga pattern and learn about encryption and <span class="No-Break">security measures.</span></p>
			<p>We’ll start this chapter by understanding better how to ensure data security with the Saga pattern, encryption, and security measures in microservices with Node.js. The Saga pattern, data encryption, and security are essential aspects to consider when designing and implementing microservices. The Saga pattern is a technique used to manage distributed transactions across <span class="No-Break">multiple microservices.</span></p>
			<p>By the end of this chapter, you will have learned how to ensure data security with the Saga pattern, encryption, and security measures <span class="No-Break">in Node.js.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Compensating actions and <span class="No-Break">Saga orchestration</span></li>
				<li>Event-driven communication and Sagas <span class="No-Break">and state</span></li>
				<li>Transport layer security (TLS) and data encryption <span class="No-Break">at rest</span></li>
				<li>Encryption algorithms and <span class="No-Break">key management</span></li>
				<li>Authentication, authorization, input validation, secure coding practices, and API <span class="No-Break">rate limiting</span></li>
			</ul>
			<p>In the following section, we’re going to learn how to work with compensating actions and Saga orchestration. Compensating actions and Saga orchestration are both concepts used in <span class="No-Break">microservices architecture.</span></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor220"/>Compensating actions and Saga orchestration</h1>
			<p>Microservices often need to have transactional behavior across multiple services. Compensating actions and Saga orchestration are two concepts related to the Saga pattern, which is a way to manage data consistency across microservices in distributed <span class="No-Break">transaction scenarios.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor221"/>Compensating actions</h2>
			<p><strong class="bold">Compensating actions</strong> are used to undo the effects<a id="_idIndexMarker942"/> of a failed operation in a microservices architecture. They are often needed when an operation consists of multiple steps that are eventually consistent, meaning that the system might be in an inconsistent state until all steps are completed. If one or more of the steps fail, the system should revert to a consistent state by applying compensating actions that revert changes made by the previous steps. For example, if an operation involves reserving a hotel room, booking a flight, and charging a credit card, and the flight booking fails, the compensating actions would be to cancel the hotel reservation and refund the credit card. Compensating actions are usually implemented as separate transactions triggered by an error or a timeout. They can also be idempotent, meaning that they can be executed multiple times without changing <span class="No-Break">the outcome.</span></p>
			<p>Unlike in a monolithic system where traditional database transactions can be used, this is not possible in a distributed system where each microservice can have its <span class="No-Break">own database.</span></p>
			<p>Let’s take a look at one of the most common use cases of compensating actions. In microservices, compensating actions are crucial when a complex transaction involves multiple steps across different services, and a failure occurs at any point. Instead of rolling back the entire transaction, compensating actions are triggered to revert changes made during <span class="No-Break">the transaction.</span></p>
			<p>For example, consider an e-commerce system where a user places an order and several microservices are involved (order creation, inventory deduction, payment processing). If payment fails, compensating actions might involve canceling the order, adding inventory back, and refunding <span class="No-Break">the user.</span></p>
			<p>The following are some key considerations<a id="_idIndexMarker943"/> for <span class="No-Break">compensating actions:</span></p>
			<ul>
				<li><strong class="bold">Idempotency</strong>: Compensating actions must be designed to be idempotent, ensuring that executing them multiple times has the same effect as executing <span class="No-Break">them once.</span></li>
				<li><strong class="bold">Atomicity</strong>: Each compensating action should be atomic and independent of others to ensure <span class="No-Break">proper</span><span class="No-Break"><a id="_idIndexMarker944"/></span><span class="No-Break"> handling.</span></li>
			</ul>
			<p><strong class="bold">Failure scenarios</strong> for compensating actions in microservices<a id="_idIndexMarker945"/> are situations where<a id="_idIndexMarker946"/> the compensating actions themselves fail or are not executed properly. This can lead to data inconsistency, resource leakage, or business logic errors. Some examples<a id="_idIndexMarker947"/> of failure scenarios are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Network failures</strong>: If the network connection between the services is unreliable or slow, compensating actions might not be able to reach the target services or might be delayed. This can result in partial or duplicate execution of the compensating actions, causing data corruption <span class="No-Break">or inconsistency.</span></li>
				<li><strong class="bold">Service failures</strong>: If the target service is unavailable or crashes during the execution of the compensating action, the compensating action might not be completed or might be rolled back. This can leave the system in an inconsistent state or cause <span class="No-Break">resource leakage.</span></li>
				<li><strong class="bold">Business logic failures</strong>: If the compensating action violates some business rules or constraints, the compensating action might fail or cause unwanted side effects. For example, if the compensating action tries to cancel a hotel reservation that has already been checked in, the compensating action might fail or incur a <span class="No-Break">penalty fee.</span></li>
				<li><strong class="bold">Data conflicts</strong>: If the data that the compensating action tries to modify has been changed by another concurrent operation, the compensating action might fail or overwrite the new data. This can cause data loss <span class="No-Break">or inconsistency.</span></li>
			</ul>
			<p>To handle these failure scenarios, some possible solutions<a id="_idIndexMarker948"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Retry mechanism</strong>: The compensating action can be retried a certain number of times or until a timeout is reached, in case of transient failures or network delays. The retry mechanism should also handle idempotency and concurrency issues, such as using unique identifiers or version numbers to avoid duplicate or <span class="No-Break">conflicting updates.</span></li>
				<li><strong class="bold">Fallback mechanism</strong>: The compensating action can have a fallback option that provides an alternative way to undo the original operation, in case of permanent failures or service unavailability. The fallback mechanism should also ensure data consistency and business logic correctness, such as using a manual process or a third-party service to perform the <span class="No-Break">compensating action.</span></li>
				<li><strong class="bold">Compensation chain</strong>: The compensating action can trigger another compensating action in case of failure, forming a chain of compensations that eventually restores the system to a consistent state. The compensation chain should also avoid circular dependencies and infinite loops, such as using a termination condition or a maximum <a id="_idIndexMarker949"/>depth limit to stop <span class="No-Break">the chain.</span></li>
			</ul>
			<p>Compensating transactions come to the rescue in such situations. They are a way to undo the previous operations in case of a failure. For example, if you’re creating an order and you’ve deducted an item from inventory, but the payment service fails due to some reason, you would want to compensate for the deducted item and add it back to the inventory. This undo operation is the <span class="No-Break">compensating action.</span></p>
			<p>We have learned the basics of compensating actions, so now, let’s move on to <span class="No-Break">Saga orchestration.</span></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor222"/>Saga orchestration</h2>
			<p><strong class="bold">Saga</strong> is a design pattern to manage transactions<a id="_idIndexMarker950"/> across multiple microservices. <strong class="bold">Saga orchestration</strong> is a specific way to implement the Saga pattern. In this approach, a central service (the “orchestrator”) manages the sequence of steps for the transaction and tells each service what to do and when. It also handles failures and triggers compensating actions when necessary. The advantage is that this simplifies error handling as Saga orchestration is centralized and provides consistency across transactions. However, it also creates a dependency on the orchestrator service, which can become <span class="No-Break">a bottleneck.</span></p>
			<p>The most common use case of Saga orchestration is in scenarios where a business process spans multiple microservices, whereby a Saga ensures that each step in the process is either fully completed or compensated for in case <span class="No-Break">of failure.</span></p>
			<p>For example, in the context of an e-commerce system, a Saga might involve multiple steps: creating an order, deducting inventory, processing payment, and shipping. If any step fails, compensating actions<a id="_idIndexMarker951"/> are triggered to revert changes made during the <span class="No-Break">preceding steps.</span></p>
			<p>The two types of Saga patterns are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Choreography</strong>: In choreography-based Sagas, each microservice<a id="_idIndexMarker952"/> involved knows<a id="_idIndexMarker953"/> how to initiate its part of the Saga and communicate with others to achieve the overall <span class="No-Break">business process.</span></li>
				<li><strong class="bold">Orchestration</strong>: In orchestration-based Sagas, there is a central<a id="_idIndexMarker954"/> component (orchestrator) that coordinates the sequence of steps<a id="_idIndexMarker955"/> in the Saga, instructing microservices when to execute <span class="No-Break">their parts.</span></li>
			</ul>
			<p>Both approaches have their advantages and disadvantages, depending on the complexity, reliability, and scalability of <span class="No-Break">the system.</span></p>
			<p>The following are some key considerations<a id="_idIndexMarker956"/> for <span class="No-Break">Saga orchestration:</span></p>
			<ul>
				<li><strong class="bold">Sagas versus transactions</strong>: Sagas are different from traditional <strong class="bold">ACID</strong> (<strong class="bold">Atomicity</strong>, <strong class="bold">Consistency</strong>, <strong class="bold">Isolation</strong>, <strong class="bold">Durability</strong>) transactions as they focus on distributed<a id="_idIndexMarker957"/> and long-running processes rather than short-lived, <span class="No-Break">isolated transactions.</span></li>
				<li><strong class="bold">Compensating transactions</strong>: The ability to compensate for failures is a critical aspect of Sagas, ensuring that the system remains consistent even if individual <span class="No-Break">steps fail.</span></li>
			</ul>
			<p>Saga orchestration is a technique to manage data consistency across microservices in distributed transaction scenarios. It uses a central coordinator to execute and <span class="No-Break">compensate transactions.</span></p>
			<p>A Saga may face the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker958"/></span><span class="No-Break"> challenges:</span></p>
			<ul>
				<li><strong class="bold">Consistency</strong>: Ensuring that the system remains consistent even in the presence of failures. To solve this, the Saga can use techniques such as versioning, locking, or timestamps to prevent or resolve <span class="No-Break">data conflicts.</span></li>
				<li><strong class="bold">Durability</strong>: Handling scenarios where the system fails at different points in the Saga and ensuring that the state is recoverable. To solve this, the Saga can use techniques such as retries, timeouts, circuit breakers, or compensating transactions to recover<a id="_idIndexMarker959"/> from failures and restore data <span class="No-Break">consistency (</span><a href="https://research.aimultiple.com/facial-recognition-challenges/"><span class="No-Break">https://research.aimultiple.com/facial-recognition-challenges/</span></a><span class="No-Break">).</span></li>
				<li><strong class="bold">Complexity</strong>: Implementing and managing Sagas introduces complexity, and proper tooling and patterns are needed. To solve this, the Saga can use tools and frameworks that support the Saga pattern, such as Axon, Eventuate, <span class="No-Break">or Camunda.</span></li>
			</ul>
			<p>In general, both concepts serve to ensure data consistency and handle failures in a distributed system environment. It’s also important to note that choosing an approach depends on the specific needs of your application and team capacity. Both have their advantages <span class="No-Break">and trade-offs.</span></p>
			<p>Here is some sample Saga orchestration<a id="_idIndexMarker960"/> code for e-commerce in Node.js (divided into <span class="No-Break">code blocks).</span></p>
			<p>Let us go step by step, starting with the initiation of a service with default dependencies <span class="No-Break">and constants:</span></p>
			<pre class="source-code">
// Orchestator service
const express = require('express');
const KafkaBroker = require('./kafkaHandler/kafkaBroker');
const app = express();
const port = 3000;
// Kafka producer and consumer
const kafkaBroker = new KafkaBroker();
const producer = kafkaBroker.getProducer();
const consumer = kafkaBroker.getConsumer();
// Order state
const orderState = {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};
// Order database (mock)
const orders = {};</pre>
			<p>Next, we’ll create API endpoints<a id="_idIndexMarker961"/> with <span class="No-Break">their functionalities:</span></p>
			<pre class="source-code">
// Create a new order
app.post('/order', (req, res) =&gt; {
  // Generate a random order ID and get the order details
  const orderId = Math.floor(Math.random() * 10000);
  const order = req.body;
  // Set the order status to pending and save it
  order.status = orderState.PENDING;
  orders[orderId] = order;
  // Send a message to the order service to start the saga
  producer.send([{
    topic: 'order',
    messages: JSON.stringify({
      type: 'ORDER_CREATED',
      payload: {
        orderId: orderId,
        order: order
      }
    })
  }]);
  // Return the order ID and status
  res.json({
    orderId: orderId,
    status: order.status
  });
});</pre>
			<p>With the following code block, we can<a id="_idIndexMarker962"/> handle messages from the <span class="No-Break">order service:</span></p>
			<pre class="source-code">
// Handle the messages from the order service
consumer.on('message', (message) =&gt; {
  // Parse the message value and get the event type and payload
  const event = JSON.parse(message.value);
  const { type, payload } = event;
  // Get the order ID and order from the payload
  const { orderId, order } = payload;
  // Find the order in the database
  const currentOrder = orders[orderId];
  // Check if the order exists and is not already cancelled
  if (currentOrder &amp;&amp; currentOrder.status !== orderState.CANCELLED) {
    // Handle the event type
    switch (type) {
      // The order service has approved the order
      case 'ORDER_APPROVED':
        // Set the order status to approved and send a message to the payment service
        currentOrder.status = orderState.APPROVED;
        producer.send([{
          topic: 'payment',
          messages: JSON.stringify({
            type: 'PAYMENT_REQUESTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      // The order service has rejected the order
      case 'ORDER_REJECTED':
        // Set the order status to rejected
        currentOrder.status = orderState.REJECTED;
        break;
      // The payment service has charged the payment
      case 'PAYMENT_APPROVED':
        // Send a message to the stock service to reserve the items
        producer.send([{
          topic: 'stock',
          messages: JSON.stringify({
            type: 'STOCK_REQUESTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      // The payment service has failed to charge the payment
      case 'PAYMENT_REJECTED':
        // Send a message to the order service to reject the order
        producer.send([{
          topic: 'order',
          messages: JSON.stringify({
            type: 'ORDER_REJECTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      // The stock service has reserved the items
      case 'STOCK_APPROVED':
        // The saga is completed successfully
        console.log('Saga completed successfully');
        break;
      // The stock service has failed to reserve the items
      case 'STOCK_REJECTED':
        // Send a message to the payment service to refund the payment
        producer.send([{
          topic: 'payment',
          messages: JSON.stringify({
            type: 'PAYMENT_REFUNDED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        // Send a message to the order service to reject the order
        producer.send([{
          topic: 'order',
          messages: JSON.stringify({
            type: 'ORDER_REJECTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      default:
        // Unknown event type
        console.error('Unknown event type:', type);
    }
  } else {
    // The order is not found or already cancelled
    console.error('Order not found or already cancelled:', orderId);
  }
});</pre>
			<p>Finally, we’ll start the server<a id="_idIndexMarker963"/> on the <span class="No-Break">selected port:</span></p>
			<pre class="source-code">
// Start the server
app.listen(port, () =&gt; {
  console.log(`Orchestrator service listening at http://localhost:${port}`);
});</pre>
			<p>The output of this code depends<a id="_idIndexMarker964"/> on the input and the events that occur in the order processing saga. The code is an example of an orchestrator service in Node.js that uses Kafka as a message broker to coordinate order, payment, and stock services. The code defines the <span class="No-Break">following steps:</span></p>
			<ul>
				<li>When a new order is created, the orchestrator service assigns a random order ID, sets the order status to <strong class="source-inline">pending</strong>, saves it in a mock database, and sends a message to the order service to start <span class="No-Break">the Saga.</span></li>
				<li>When the orchestrator service receives a message from the order service, it checks the event type and the order ID and finds the corresponding order in the database. If the order exists and is not already cancelled, it performs the following actions based on the <span class="No-Break">event type:</span><ul><li>If the order service has approved the order, the orchestrator service sets the order status to <strong class="source-inline">approved</strong> and sends a message to the payment service to request <span class="No-Break">the payment.</span></li><li>If the order service has rejected the order, the orchestrator service sets the order status to <strong class="source-inline">rejected</strong> and does <span class="No-Break">nothing else.</span></li><li>If the payment service has charged the payment, the orchestrator service sends a message to the stock service to reserve <span class="No-Break">the items.</span></li><li>If the payment service has failed to charge the payment, the orchestrator service sends a message to the order service to reject <span class="No-Break">the order.</span></li><li>If the stock service has reserved the items, the orchestrator service logs that the saga is completed successfully and does <span class="No-Break">nothing else.</span></li><li>If the stock service has failed to reserve the items, the orchestrator service sends a message to the payment service to refund the payment and a message to the order service to reject <span class="No-Break">the order.</span></li></ul></li>
				<li>If the event type is unknown, the orchestrator service logs an error and does <span class="No-Break">nothing else.</span></li>
				<li>If the order is not found or already cancelled, the orchestrator service logs an error and does <span class="No-Break">nothing else.</span></li>
			</ul>
			<p>The code also defines a route to create a new order and a listener to start the server. This code’s output would be the console<a id="_idIndexMarker965"/> logs and the JSON responses sent or received by the <span class="No-Break">orchestrator service.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.1</em> illustrates <span class="No-Break">Saga orchestration:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B14980_12_01.jpg" alt="Figure 12.1: Saga orchestration (image by Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Saga orchestration (image by Freepik)</p>
			<p>In summary, compensating actions and Saga orchestration are essential patterns in microservices architecture, enabling the design of robust and resilient distributed systems. They provide mechanisms to handle failures and maintain data consistency in scenarios where traditional ACID<a id="_idIndexMarker966"/> transactions are <span class="No-Break">not applicable.</span></p>
			<p>With an understanding of these concepts, let’s now move to event-driven communication and Sagas <span class="No-Break">and state.</span></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor223"/>Event-driven communication and Sagas with state</h1>
			<p>Event-driven communication and Sagas and state refer to software and system development concepts, particularly within the realm of <span class="No-Break">microservices architecture.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor224"/>Event-driven communication</h2>
			<p><strong class="bold">Event-driven communication</strong> is a communication<a id="_idIndexMarker967"/> paradigm between software components where one component changes its state and emits an event to notify other components. The advantage of this communication model is that it helps reduce system connectivity and enhances reactivity, scalability, <span class="No-Break">and flexibility.</span></p>
			<p>A use case of event-driven communication is that in a distributed system of microservices, event-driven communication is valuable for loosely coupling services and enabling asynchronous, <span class="No-Break">real-time interactions.</span></p>
			<p>For instance, in an e-commerce<a id="_idIndexMarker968"/> system, when a user places an order, the <strong class="bold">order service</strong> might publish an <strong class="source-inline">OrderPlaced</strong> event. The <strong class="bold">inventory service and payment service</strong>, which are interested parties, can subscribe<a id="_idIndexMarker969"/> to this event and take <span class="No-Break">appropriate actions.</span></p>
			<p>The following are key characteristics<a id="_idIndexMarker970"/> of <span class="No-Break">event-driven communication:</span></p>
			<ul>
				<li><strong class="bold">Publishers and subscribers</strong>: Microservices act as publishers when generating events and as subscribers when reacting to events <span class="No-Break">of interest.</span></li>
				<li><strong class="bold">Decoupling</strong>: Event-driven communication promotes loose coupling between microservices, allowing them to <span class="No-Break">evolve independently.</span></li>
			</ul>
			<p>Event-driven communication is a way of exchanging data between microservices or clients based on events, which are discrete messages that represent changes in the state of <span class="No-Break">the system.</span></p>
			<p>Challenges with event-driven communication<a id="_idIndexMarker971"/> are <span class="No-Break">illustrated here:</span></p>
			<ul>
				<li><strong class="bold">Eventual consistency</strong>: As events are processed asynchronously, ensuring eventual consistency across microservices can be challenging. To solve this, event-driven communication can use techniques such as versioning, locking, or timestamps to prevent or resolve <span class="No-Break">data conflicts.</span></li>
				<li><strong class="bold">Message ordering</strong>: Maintaining the correct order of events is crucial in <span class="No-Break">certain scenarios.</span></li>
			</ul>
			<p>Here is a simple example of event-driven communication in Node.js, using the built-in <strong class="source-inline">http</strong> module and the <span class="No-Break"><strong class="source-inline">EventEmitter</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
// Import the http and events modules
const http = require('http');
const EventEmitter = require('events');
// Create a custom event emitter class
class MyEmitter extends EventEmitter {}
// Create an instance of the custom event emitter
const myEmitter = new MyEmitter();
// Define an event listener for the 'hello' event
myEmitter.on('hello', (name) =&gt; {
  console.log('Hello, ' + name);
});
// Create a simple web server
const server = http.createServer((req, res) =&gt; {
  // Get the query parameter from the request URL
  const url = new URL(req.url, 'http://localhost:3000');
  const name = url.searchParams.get('name');
  // Emit the 'hello' event with the query parameter as the argument
  myEmitter.emit('hello', name);
  // Send a response to the client
  res.end('Event emitted');
});
// Start the server on port 3000
server.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</pre>
			<p>Event-driven communication is a paradigm<a id="_idIndexMarker972"/> where microservices communicate with each other through the generation and consumption of events. Events represent state changes or occurrences within a <span class="No-Break">microservices ecosystem.</span></p>
			<p>With these concepts learned, we can continue with Sagas <span class="No-Break">and state.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor225"/>Sagas with state</h2>
			<p>In the context of microservices, a <strong class="bold">Saga</strong><strong class="bold"><a id="_idIndexMarker973"/></strong><strong class="bold"> with state</strong> refers to a long-running business process (Saga) that involves a sequence of steps, each with its associated state. The state of the Saga determines the next steps to <span class="No-Break">be taken.</span></p>
			<p>A common use case of Sagas and state is in complex business processes that span multiple microservices and involve multiple steps with an <span class="No-Break">associated state.</span></p>
			<p>An example of Sagas and state is as follows. Consider the process of booking a flight. The Saga may involve steps such as seat selection, payment, and confirmation. The state of the Saga (e.g., <strong class="source-inline">SeatSelected</strong>, <strong class="source-inline">PaymentProcessed</strong>) determines the next steps in <span class="No-Break">the process.</span></p>
			<p>Some of its key characteristics <a id="_idIndexMarker974"/>are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Stateful steps</strong>: Each step in the Saga maintains its state, and the overall Saga progresses based on the combination of <span class="No-Break">these states.</span></li>
				<li><strong class="bold">Compensating actions</strong>: If there is a failure, compensating actions are executed to revert the effects of the <span class="No-Break">preceding steps.</span></li>
				<li><strong class="bold">Coordination</strong>: There is a need for coordination<a id="_idIndexMarker975"/> to ensure that steps are executed in the <span class="No-Break">correct sequence.</span></li>
			</ul>
			<p>Saga and state are two important concepts in <span class="No-Break">microservices architecture.</span></p>
			<p>The following are challenges<a id="_idIndexMarker976"/> for Sagas <span class="No-Break">and state:</span></p>
			<ul>
				<li><strong class="bold">State management</strong>: Managing and persisting the state of Sagas becomes crucial <span class="No-Break">for reliability.</span></li>
				<li><strong class="bold">Compensation logic</strong>: Designing and implementing compensating actions for each step requires <span class="No-Break">careful consideration.</span></li>
			</ul>
			<p>In summary, in microservices architecture, Sagas are used to manage transactions that span multiple services. Each Saga represents a high-level business transaction, which involves steps that need to be performed in multiple services. It manages and oversees these processes, ensuring they either all succeed or undergo a compensating transaction in case of failure, maintaining data consistency<a id="_idIndexMarker977"/> across services. State usually refers to the information maintained by software components during their life cycle. This can involve user info, system configurations, or other <span class="No-Break">operation-critical data.</span></p>
			<p>Now, we can continue to the next section, in which we will talk about TLS and data encryption <span class="No-Break">at rest.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor226"/>Transport layer security (TLS) and data encryption at rest</h1>
			<p><strong class="bold">Transport layer security</strong> (<strong class="bold">TLS</strong>) is a protocol that provides privacy<a id="_idIndexMarker978"/> and data integrity between two communicating applications. Data encryption at rest is the process of encoding and securing data stored in databases, filesystems, or disk storage. In contrast, data in motion is generally protected by networking protocols, such <span class="No-Break">as TLS.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor227"/>TLS</h2>
			<p><strong class="bold">TLS</strong> is a cryptographic protocol that ensures <a id="_idIndexMarker979"/>secure communication over a computer network. It is widely used to secure data transmission between a client and a server, protecting it from eavesdropping, tampering, <span class="No-Break">and forgery.</span></p>
			<p>One important use case of TLS is in microservices, where TLS is crucial for securing communication between services over the network. It establishes a secure channel by encrypting data <span class="No-Break">during transmission.</span></p>
			<p>To implement TLS, each microservice<a id="_idIndexMarker980"/> can be configured to support <strong class="bold">HTTPS</strong>, the secure version of HTTP. TLS certificates are used to encrypt the communication channel, and <strong class="bold">mutual TLS</strong> (<strong class="bold">mTLS</strong>) can be implemented for <span class="No-Break">service-to-service</span><span class="No-Break"><a id="_idIndexMarker981"/></span><span class="No-Break"> authentication.</span></p>
			<p>The following are key considerations<a id="_idIndexMarker982"/> <span class="No-Break">for TLS:</span></p>
			<ul>
				<li><strong class="bold">Encryption</strong>: TLS ensures that data transmitted between microservices is encrypted, preventing <span class="No-Break">unauthorized access.</span></li>
				<li><strong class="bold">Authentication</strong>: mTLS adds an extra layer of security by requiring both parties to authenticate each other, enhancing the overall <span class="No-Break">security posture.</span></li>
				<li><strong class="bold">Certificates and public key infrastructure (PKI)</strong>: Certificates and PK) are related concepts that enable secure and authenticated communication over the internet. A certificate is a digital document that contains information about the identity of a user, device, or service, as well as a public key that can be used for encryption and digital signatures. A PKI is a system that manages the creation, distribution, verification, and revocation<a id="_idIndexMarker983"/> of certificates, using trusted entities called <strong class="bold">certificate authorities</strong> (<strong class="bold">CAs</strong>). A PKI ensures that the certificates are valid and trustworthy and that the public keys are linked to the <span class="No-Break">correct owners.</span></li>
				<li><strong class="bold">TLS handshake</strong>: A TLS handshake is a process that establishes a secure and encrypted connection between a client and a server over <span class="No-Break">the internet.</span></li>
			</ul>
			<p>TLS is a protocol that provides secure and reliable communication over <span class="No-Break">the internet.</span></p>
			<p>Some challenges<a id="_idIndexMarker984"/> to TLS are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Certificate management</strong>: Proper management of TLS certificates, including issuance, renewal, and revocation, is crucial. Some solutions are to use a centralized and automated certificate management solution that can discover, inventory, monitor, renew, and revoke certificates across <span class="No-Break">your network.</span></li>
				<li><strong class="bold">Performance overhead</strong>: While the overhead is minimal, the encryption and decryption process in TLS introduces some computational load. One solution is to use the latest version of TLS (TLS 1.3), which offers faster and more secure connections than <span class="No-Break">previous versions.</span></li>
				<li><strong class="bold">Algorithm agility</strong>: Algorithm agility is the ability to change or replace cryptographic algorithms without affecting the functionality or security of a system. It is an important aspect of crypto-agility, which is the broader concept of adapting to changes in the cryptographic landscape. Algorithm agility can help mitigate the challenges of TLS, which is a protocol that provides secure and authenticated communication over <span class="No-Break">the internet.</span></li>
				<li><strong class="bold">Security of private keys</strong>: The security of private keys on TLS is a topic that concerns how to protect cryptographic keys that are used to establish and secure TLS connections. Private keys are secret keys that are used to decrypt data that is encrypted with the corresponding public keys. If the private keys are compromised, an attacker can intercept, modify, or impersonate<a id="_idIndexMarker985"/> the TLS traffic, leading to data breaches, identity theft, or <strong class="bold">man-in-the-middle</strong> (<span class="No-Break"><strong class="bold">MitM</strong></span><span class="No-Break">) attacks.</span></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.2</em> <span class="No-Break">illustrates</span><span class="No-Break"><a id="_idIndexMarker986"/></span><span class="No-Break"> TLS:</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B14980_12_02.jpg" alt="Figure 12.2: TLS (image by Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: TLS (image by Freepik)</p>
			<p>TLS is used to create a secure environment for web browsing, e-commerce, and other types of internet traffic. It does this by encrypting the data being sent between the client and server, thus preventing potential eavesdroppers from gaining access to <span class="No-Break">sensitive information.</span></p>
			<p>We can continue now with data encryption <span class="No-Break">at rest.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor228"/>Data encryption at rest</h2>
			<p>Data encryption at rest involves securing<a id="_idIndexMarker987"/> data when it is stored in databases, filesystems, or any other persistent storage. It prevents unauthorized access to data even if physical storage media <span class="No-Break">are compromised.</span></p>
			<p>In microservices, data encryption at rest is vital for protecting sensitive information stored in databases or other persistent <span class="No-Break">storage solutions.</span></p>
			<p>To implement data encryption at rest, use encryption algorithms to encrypt data before it is stored. This can be done at the application level or by utilizing features provided by the database or <span class="No-Break">storage system.</span></p>
			<p>Here are some key considerations<a id="_idIndexMarker988"/> for data encryption <span class="No-Break">at rest:</span></p>
			<ul>
				<li><strong class="bold">Key management</strong>: Proper key management is essential to ensure that encryption keys are securely stored <span class="No-Break">and managed.</span></li>
				<li><strong class="bold">Granular encryption</strong>: Depending on sensitivity, consider encrypting specific fields or columns rather than entire datasets for <span class="No-Break">better performance.</span></li>
			</ul>
			<p>Data encryption at rest is the process of protecting data that is stored on physical media, such as disks or tapes, from unauthorized access <span class="No-Break">or theft.</span></p>
			<p>The following are challenges<a id="_idIndexMarker989"/> to data encryption <span class="No-Break">at rest:</span></p>
			<ul>
				<li><strong class="bold">Key life-cycle management</strong>: Managing the life cycle of encryption keys, including generation, rotation, and disposal, can be complex. A solution is to use a centralized and automated certificate management solution that can discover, inventory, monitor, renew, and revoke certificates across <span class="No-Break">your network.</span></li>
				<li><strong class="bold">Performance impact</strong>: Encrypting and decrypting data at rest can introduce some performance overhead, which needs to be considered. A solution is to use the latest version of TLS (TLS 1.3), which offers faster and more secure connections than <span class="No-Break">previous versions.</span></li>
			</ul>
			<p>With data at rest encryption, even if an unauthorized party were to gain access to the physical storage, the data would be unreadable without the encryption keys. This process is crucial in ensuring the protection of personal or sensitive information when stored digitally. Combining these techniques allows for comprehensive security both in the transmission and storage of <span class="No-Break">sensitive data.</span></p>
			<p>In summary, implementing both TLS <a id="_idIndexMarker990"/>for data in transit and encryption at rest provides a layered security approach, safeguarding data throughout its life cycle in a microservices architecture. It is essential to stay updated on security best practices and continuously monitor and adapt security measures based on evolving threats <span class="No-Break">and technologies.</span></p>
			<p>In the next section, we will learn about encryption algorithms and <span class="No-Break">key management.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor229"/>Encryption algorithms and key management</h1>
			<p>Encryption algorithms and key management are crucial components of <span class="No-Break">information security.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor230"/>Encryption algorithms</h2>
			<p><strong class="bold">Encryption algorithms</strong> are methods of transforming<a id="_idIndexMarker991"/> data into a secret code that can only be deciphered by <span class="No-Break">authorized parties.</span></p>
			<p>There are several types<a id="_idIndexMarker992"/> of encryption algorithms, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Symmetric algorithms</strong>: The same key is used to encrypt<a id="_idIndexMarker993"/> and decrypt<a id="_idIndexMarker994"/> data. Examples include <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>), <strong class="bold">Data Encryption Standard</strong> (<strong class="bold">DES</strong>), <strong class="bold">Triple DES</strong> (<strong class="bold">3DES</strong>), Blowfish, and <strong class="bold">Rivest Cipher 4</strong> (<strong class="bold">RC4</strong>). Here is a brief<a id="_idIndexMarker995"/> summary of <span class="No-Break">each</span><span class="No-Break"><a id="_idIndexMarker996"/></span><span class="No-Break"> algorithm:</span><ul><li><strong class="bold">AES</strong> is the current standard for symmetric<a id="_idIndexMarker997"/> encryption, which means that the same key is used to encrypt and decrypt the data. AES can use different key sizes, such as 128, 192, or 256 bits, and operates on 128-bit blocks of data. AES is considered to be very secure and efficient and is widely used in various applications and protocols, such as HTTPS, VPN, <span class="No-Break">and Wi-Fi.</span></li><li><strong class="bold">DES</strong> is the predecessor of AES and <a id="_idIndexMarker998"/>was the first standard for symmetric encryption. DES uses a 56-bit key and operates on 64-bit blocks of data. DES is no longer considered secure as its key size is too small and can be cracked by brute-force attacks. DES was officially withdrawn as a standard <span class="No-Break">in 2005.</span></li><li><strong class="bold">3DES</strong> is a variation of DES that applies<a id="_idIndexMarker999"/> the DES algorithm three times with different keys, effectively increasing the key size to 112 or 168 bits. 3DES is more secure than DES but still suffers from some vulnerabilities, such as its small block size and its slow performance. 3DES is still used in some legacy systems but is not recommended for <span class="No-Break">new applications.</span></li><li><strong class="bold">Blowfish</strong> is a symmetric encryption algorithm<a id="_idIndexMarker1000"/> that was designed by Bruce Schneier as an alternative to DES. Blowfish can use variable key sizes, up to 448 bits, and operates on 64-bit blocks of data. Blowfish is considered to be secure and fast but has not been widely adopted as a standard. Blowfish is mostly used in some software applications, such as password managers and file <span class="No-Break">encryption tools.</span></li><li><strong class="bold">RC4</strong> is a symmetric encryption algorithm<a id="_idIndexMarker1001"/> that was designed by Ron Rivest as a stream cipher, which means that it encrypts data 1 bit or byte at a time, rather than in blocks. RC4 can use variable key sizes, up to 256 bits, and is very simple and fast. However, RC4 has been found to have several weaknesses<a id="_idIndexMarker1002"/> and vulnerabilities and is no longer considered secure. RC4 was widely used in some protocols, such as <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>), TLS, and <strong class="bold">Wired Equivalent Privacy</strong> (<strong class="bold">WEP</strong>), but has been deprecated or replaced <a id="_idIndexMarker1003"/>by <span class="No-Break">newer algorithms.</span></li></ul></li>
				<li><strong class="bold">Asymmetric algorithms</strong>: Different keys are used to encrypt<a id="_idIndexMarker1004"/> and <span class="No-Break">decrypt data.</span></li>
			</ul>
			<p>Encryption algorithms are widely <a id="_idIndexMarker1005"/>used to protect data in transit and at rest, such as online communications, web transactions, and cloud storage. Let’s take a closer look <span class="No-Break">at these:</span></p>
			<ul>
				<li><strong class="bold">Symmetric encryption</strong>: Symmetric encryption uses a single key<a id="_idIndexMarker1006"/> for both encryption and decryption. It is fast and suitable for bulk data.<span class="Annotation-reference"> </span>A use case and example algorithm are <span class="No-Break">as follows:</span><ul><li><em class="italic">Use case</em>: Protecting data in transit within a <span class="No-Break">microservices architecture.</span></li><li><em class="italic">Example </em><span class="No-Break"><em class="italic">algorithm</em></span><span class="No-Break">: AES.</span></li></ul></li>
				<li><strong class="bold">Asymmetric encryption</strong>: Asymmetric encryption uses a pair of public<a id="_idIndexMarker1007"/> and private keys. Data encrypted with one key can only be decrypted by the other key in the pair.<span class="Annotation-reference"> </span>A use case and example algorithm are <span class="No-Break">as follows:</span><ul><li><em class="italic">Use case</em>: Securely exchanging secret<a id="_idIndexMarker1008"/> keys for <span class="No-Break">symmetric encryption.</span></li><li><em class="italic">Example algorithm</em>: <span class="No-Break"><strong class="bold">Rivest-Shamir-Adleman</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">RSA</strong></span><span class="No-Break">).</span></li></ul></li>
				<li><strong class="bold">Hash functions</strong>: Hash functions create a fixed-size<a id="_idIndexMarker1009"/> output (hash) from variable-size input. They are used for integrity verification.<span class="Annotation-reference"> </span>A use case and example algorithm are <span class="No-Break">as follows:</span><ul><li><em class="italic">Use case</em>: Verifying the integrity of data<a id="_idIndexMarker1010"/> or creating <span class="No-Break">digital signatures.</span></li><li><em class="italic">Example algorithm</em>: <strong class="bold">Secure Hash Algorithm </strong><span class="No-Break"><strong class="bold">256-bit</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SHA-256</strong></span><span class="No-Break">).</span></li></ul></li>
				<li><strong class="bold">Elliptic-curve cryptography (ECC)</strong>: ECC uses the mathematics of elliptic<a id="_idIndexMarker1011"/> curves to provide strong security with shorter key lengths compared to traditional asymmetric algorithms.<span class="Annotation-reference"> </span>A use case and example algorithm are <span class="No-Break">as follows:</span><ul><li><em class="italic">Use case</em>: Efficient asymmetric<a id="_idIndexMarker1012"/> encryption for <span class="No-Break">resource-constrained environments.</span></li><li><em class="italic">Example algorithm</em>: <strong class="bold">Elliptic Curve </strong><span class="No-Break"><strong class="bold">Diffie-Hellman</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ECDH</strong></span><span class="No-Break">).</span></li></ul></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.3</em> illustrates <span class="No-Break">encryption algorithms:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B14980_12_03.jpg" alt="Figure 12.3: Encryption (image by macrovector on Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: Encryption (image by macrovector on Freepik)</p>
			<p>You need to master these<a id="_idIndexMarker1013"/> concepts for better <span class="No-Break">data encryption.</span></p>
			<p>Now, we can continue with <span class="No-Break">key management.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor231"/>Key management</h2>
			<p><strong class="bold">Key management</strong> involves the entire life cycle<a id="_idIndexMarker1014"/> of cryptographic keys and other key-related materials. Key management in microservices is the process of generating, storing, rotating, and revoking encryption keys that are used to protect data and communication among microservices. Let’s look at this in more detail, along with some examples of best practices <span class="No-Break">and considerations:</span></p>
			<ul>
				<li><strong class="bold">Key generation</strong>: Key generation is the process<a id="_idIndexMarker1015"/> of creating keys for cryptography. Keys are used to encrypt and decrypt data so that only authorized parties can <span class="No-Break">access it.</span><ul><li><em class="italic">Best practice</em>: Use cryptographically secure random number generators to create <span class="No-Break">strong keys.</span></li><li><em class="italic">Considerations</em>: Key length and algorithm choice impact security. Longer keys generally provide <span class="No-Break">stronger security.</span></li></ul></li>
				<li><strong class="bold">Key storage</strong>: Key storage is the process of keeping encryption keys safe and accessible for authorized parties. Encryption keys are used to protect data and communication from unauthorized access <span class="No-Break">or theft.</span><ul><li><em class="italic">Best practice</em>: Store encryption keys<a id="_idIndexMarker1016"/> securely, avoiding hardcoding them in source code or <span class="No-Break">configuration files.</span></li><li><em class="italic">Considerations</em>: Utilize <strong class="bold">hardware security modules</strong> (<strong class="bold">HSMs</strong>) for enhanced <span class="No-Break">key protection.</span></li></ul></li>
				<li><strong class="bold">Key distribution</strong>: Key distribution is the process of delivering encryption keys to parties who wish to exchange secure encrypted data. Encryption keys are used to protect data and communication from unauthorized access <span class="No-Break">or theft.</span><ul><li><em class="italic">Best practice</em>: Securely distribute keys in asymmetric<a id="_idIndexMarker1017"/> encryption scenarios. Use key exchange protocols such <span class="No-Break">as </span><span class="No-Break"><strong class="bold">Diffie-Hellman</strong></span><span class="No-Break">.</span></li><li><em class="italic">Considerations</em>: Protect against MitM attacks during key exchange. A MitM attack is a type of cyberattack where an attacker secretly intercepts and modifies the communication between<a id="_idIndexMarker1018"/> two parties who think they are directly talking to <span class="No-Break">each other.</span></li></ul></li>
				<li><strong class="bold">Key rotation</strong>: Key rotation is the process of changing encryption keys periodically to reduce the risk of compromise <span class="No-Break">or exposure.</span><ul><li><em class="italic">Best practice</em>: Regularly rotate keys to minimize the impact of a <span class="No-Break">compromised key.</span></li><li><em class="italic">Considerations</em>: Coordinate key rotation across microservices to <span class="No-Break">avoid disruption.</span></li></ul></li>
				<li><strong class="bold">Key revocation</strong>: Key revocation is the process of declaring that an encryption key is no longer valid and should not be used for encryption <span class="No-Break">or decryption.</span><ul><li><em class="italic">Best practice</em>: Implement processes for revoking <span class="No-Break">compromised keys.</span></li><li><em class="italic">Considerations</em>: Rapidly revoke and replace keys if a compromise <span class="No-Break">is suspected.</span></li></ul></li>
				<li><strong class="bold">Secrets management</strong>: Secrets management is the process of securely and efficiently managing the creation, rotation, revocation, and storage of digital <span class="No-Break">authorization credentials.</span><ul><li><em class="italic">Best practice</em>: Use dedicated secrets management solutions for secure storage, retrieval, and rotation of keys and other <span class="No-Break">sensitive information.</span></li><li><em class="italic">Considerations</em>: Integrate with solutions that support key <span class="No-Break">life-cycle management.</span></li></ul></li>
				<li><strong class="bold">Monitoring and auditing</strong>: Monitoring and auditing are two related but distinct processes that are essential for ensuring the effectiveness and compliance of an organization’s operations, systems, <span class="No-Break">and data.</span><ul><li><em class="italic">Best practice</em>: Implement robust monitoring and auditing of <span class="No-Break">key usage.</span></li><li><em class="italic">Considerations</em>: Detect and respond to unusual or unauthorized <span class="No-Break">key access.</span></li></ul></li>
				<li><strong class="bold">Crypto-agility</strong>: Crypto-agility is the ability of a system to switch between different cryptographic algorithms, keys, and parameters without disrupting the system’s functionality <span class="No-Break">or security.</span><ul><li><em class="italic">Best practice</em>: Design systems with crypto-agility to facilitate the adoption of new algorithms or <span class="No-Break">key lengths.</span></li><li><em class="italic">Considerations</em>: Stay informed about developments in cryptography and be prepared to transition<a id="_idIndexMarker1019"/> to <span class="No-Break">stronger algorithms.</span></li></ul></li>
			</ul>
			<p>Key management is important because if keys are<a id="_idIndexMarker1020"/> compromised, the data protected by those keys is also compromised. Therefore, <strong class="bold">key management systems</strong> (<strong class="bold">KMSs</strong>) are designed to protect against <span class="No-Break">key compromises.</span></p>
			<p>In summary, encryption algorithms<a id="_idIndexMarker1021"/> and key management<a id="_idIndexMarker1022"/> are foundational elements of microservices security. Choosing appropriate algorithms and implementing sound key management practices are critical for protecting sensitive information and ensuring the overall security of a <span class="No-Break">microservices architecture.</span></p>
			<p>Now, let’s move on to the next section, in which we will discuss authentication and authorization, input validation, secure coding practices, and API <span class="No-Break">rate limiting.</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor232"/>Authentication, authorization, input validation, secure coding practices, and API rate limiting</h1>
			<p>In this section, we will discuss some of the core principles of secure software development and <span class="No-Break">API management.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor233"/>Authentication</h2>
			<p><strong class="bold">Authentication</strong> is the process of verifying the identity <a id="_idIndexMarker1023"/>of a user, device, or system. It often involves a username and password but can include any other method of demonstrating identity, such <span class="No-Break">as biometrics.</span></p>
			<p>Best practices for authentication<a id="_idIndexMarker1024"/> are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Use strong<a id="_idIndexMarker1025"/> authentication<a id="_idIndexMarker1026"/> mechanisms such as <strong class="bold">Open Authorization 2.0</strong> (<strong class="bold">OAuth 2.0</strong>) or <strong class="bold">JSON Web </strong><span class="No-Break"><strong class="bold">Token</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JWT</strong></span><span class="No-Break">).</span></li>
				<li>Implement <strong class="bold">multi-factor authentication</strong> (<strong class="bold">MFA</strong>) for <span class="No-Break">added </span><span class="No-Break"><a id="_idIndexMarker1027"/></span><span class="No-Break">security.</span></li>
				<li>Centralize authentication to a dedicated service <span class="No-Break">when possible.</span></li>
			</ul>
			<p>The following are some key considerations<a id="_idIndexMarker1028"/> <span class="No-Break">for authentication:</span></p>
			<ul>
				<li>Ensure secure transmission <span class="No-Break">of credentials.</span></li>
				<li>Regularly audit and monitor <span class="No-Break">authentication logs.</span></li>
			</ul>
			<p>Authentication is the process of verifying the identity of a user or a process before granting access to confidential data <span class="No-Break">or systems.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.4</em> illustrates authentication <span class="No-Break">and authorization:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B14980_12_04.jpg" alt="Figure 12.4: Authorization and authentication (image by vectorjuice on Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: Authorization and authentication (image by vectorjuice on Freepik)</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor234"/>Authorization</h2>
			<p>Once a user’s identity is verified, <strong class="bold">authorization</strong> determines what permissions<a id="_idIndexMarker1029"/> the user has—that is, what they are allowed to do. This could include access to certain files, the ability to perform certain functions, and <span class="No-Break">so on.</span></p>
			<p>The following <a id="_idIndexMarker1030"/>are best practices<a id="_idIndexMarker1031"/> <span class="No-Break">for authorization:</span></p>
			<ul>
				<li>Adopt the <strong class="bold">principle of least </strong><span class="No-Break"><strong class="bold">privilege</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">PoLP</strong></span><span class="No-Break">).</span></li>
				<li>Use <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) for <span class="No-Break">fine-grained</span><span class="No-Break"><a id="_idIndexMarker1032"/></span><span class="No-Break"> authorization.</span></li>
				<li>Regularly review and <a id="_idIndexMarker1033"/>update <span class="No-Break">access permissions.</span></li>
			</ul>
			<p>Some key considerations<a id="_idIndexMarker1034"/> for authorization are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Implement proper <span class="No-Break">session management.</span></li>
				<li>Use <strong class="bold">attribute-based access control</strong> (<strong class="bold">ABAC</strong>) for more <span class="No-Break">dynamic</span><span class="No-Break"><a id="_idIndexMarker1035"/></span><span class="No-Break"> authorization.</span></li>
			</ul>
			<p>Authorization is the process of granting or denying access to resources, based on the identity and privileges of the requester. Authorization can be applied to different types of resources, such as files, databases, networks, <span class="No-Break">or applications.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor235"/>Input validation</h2>
			<p>This is a process used<a id="_idIndexMarker1036"/> to ensure that data being input into an application or API is valid and secure before it is processed. This can help prevent things such as SQL injection attacks or <span class="No-Break">data corruption.</span></p>
			<p>The following are best practices<a id="_idIndexMarker1037"/> for <span class="No-Break">input validation:</span></p>
			<ul>
				<li>Validate and sanitize all user inputs, both on the client and <span class="No-Break">server sides.</span></li>
				<li>Use parameterized queries to prevent <span class="No-Break">SQL injection.</span></li>
				<li>Apply input validation on both frontend and <span class="No-Break">backend components.</span></li>
			</ul>
			<p>Some key considerations<a id="_idIndexMarker1038"/> for input validation are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Implement whitelist validation to accept only known and <span class="No-Break">expected inputs.</span></li>
				<li>Regularly update and patch components to address <span class="No-Break">known vulnerabilities.</span></li>
			</ul>
			<p>Input validation is the process of checking data that users enter into a website or an application, to make sure that it is correct, complete, <span class="No-Break">and secure.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor236"/>Secure coding practices</h2>
			<p>These are guidelines or standards for writing<a id="_idIndexMarker1039"/> code in a manner that avoids common security vulnerabilities. This could include things such as proper error handling, strong encryption usage, <span class="No-Break">and more.</span></p>
			<p>Best practices for secure coding practices<a id="_idIndexMarker1040"/> are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Follow PoLP when assigning permissions <span class="No-Break">to services.</span></li>
				<li>Use secure coding frameworks <span class="No-Break">and libraries.</span></li>
				<li>Conduct regular security <span class="No-Break">code reviews.</span></li>
			</ul>
			<p>The following are some key considerations<a id="_idIndexMarker1041"/> for secure <span class="No-Break">coding practices:</span></p>
			<ul>
				<li>Train developers in secure <span class="No-Break">coding practices.</span></li>
				<li>Implement secure coding guidelines and <span class="No-Break">enforce them.</span></li>
			</ul>
			<p>Secure coding practices are guidelines and standards that help developers write code that is secure, reliable, and resistant to common vulnerabilities <span class="No-Break">and attacks.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor237"/>API rate limiting</h2>
			<p><strong class="bold">API rate limiting</strong> is the process of limiting the number <a id="_idIndexMarker1042"/>of requests that a client (user or system) can make to an API in a certain amount of time. This helps protect the API from being overloaded and can also be a method of security to prevent things such as <span class="No-Break">brute-force attacks.</span></p>
			<p>Best practices for API rate limiting<a id="_idIndexMarker1043"/> are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Implement rate limiting<a id="_idIndexMarker1044"/> to prevent abuse and protect against <strong class="bold">distributed denial-of-service</strong> (<span class="No-Break"><strong class="bold">DDoS</strong></span><span class="No-Break">) attacks.</span></li>
				<li>Use token buckets or sliding window algorithms (for <span class="No-Break">rate limiting).</span></li>
			</ul>
			<p class="callout-heading">The Sliding Window technique</p>
			<p class="callout">The <strong class="bold">Sliding Window</strong> technique is a computational approach<a id="_idIndexMarker1045"/> used to optimize certain problems involving arrays, strings, or other data structures. It aims to reduce the use of nested loops and replace them with a single loop, thereby improving <span class="No-Break">time complexity.)</span></p>
			<ul>
				<li>Provide clear error<a id="_idIndexMarker1046"/> messages when rate limits <span class="No-Break">are exceeded.</span></li>
			</ul>
			<p>The following are some<a id="_idIndexMarker1047"/> key considerations for API <span class="No-Break">rate limiting:</span></p>
			<ul>
				<li>Differentiate rate limits based on user roles or <span class="No-Break">API endpoints.</span></li>
				<li>Implement adaptive rate limiting to respond dynamically to <span class="No-Break">traffic patterns.</span></li>
			</ul>
			<p>All these practices help improve the reliability and security of software applications and <span class="No-Break">web services.</span></p>
			<p>In summary, by integrating<a id="_idIndexMarker1048"/> these security practices<a id="_idIndexMarker1049"/> into the development life cycle of microservices, organizations can significantly enhance the security posture of their systems. Regular security assessments, training, and a proactive approach to addressing emerging threats are key components of a robust microservices <span class="No-Break">security strategy.</span></p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor238"/>Summary</h1>
			<p>In this chapter, we have learned a lot about microservices and how to ensure data security in a microservices architecture involves implementing various measures, including the use of the Saga pattern, encryption, and additional <span class="No-Break">security measures.</span></p>
			<p>In summary, by combining the Saga pattern, encryption, and additional security measures, you create a robust defense against various security threats in a microservices environment. Regularly reassess and update security practices to stay ahead of <span class="No-Break">emerging threats.</span></p>
			<p>Data security is of paramount significance, especially in our modern, data-driven era. Protecting sensitive information from unauthorized access, use, disclosure, disruption, modification, or destruction requires strategic measures. We looked at three ways to ensure data security—by implementing the Saga pattern, encryption, and additional <span class="No-Break">security measures.</span></p>
			<p>In the next chapter, we are going to learn about monitoring microservices <span class="No-Break">in Node.js.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor239"/>Quiz time</h1>
			<ul>
				<li>What are some key considerations for <span class="No-Break">compensating actions?</span></li>
				<li>What is a <span class="No-Break">saga orchestration?</span></li>
				<li>What is <span class="No-Break">event-driven communication?</span></li>
				<li>What are <span class="No-Break">encryption algorithms?</span></li>
			</ul>
		</div>
	

		<div id="_idContainer120" class="Content">
			<h1 id="_idParaDest-239" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor240"/>Part 4: Monitoring and Logging in Microservices with Node.js</h1>
			<p>In this part, we will talk about monitoring and logging in microservices and how to interpret and analyze logging data in microservices <span class="No-Break">in Node.js.</span></p>
			<p>The part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B14980_13.xhtml#_idTextAnchor241"><em class="italic">Chapter 13</em></a>, <em class="italic">Monitoring Microservices in Node.js</em></li>
				<li><a href="B14980_14.xhtml#_idTextAnchor261"><em class="italic">Chapter 14</em></a>, <em class="italic">Logging in Microservices with Node.js</em></li>
				<li><a href="B14980_15.xhtml#_idTextAnchor276"><em class="italic">Chapter 15</em></a>, <em class="italic">Interpreting Monitoring Data in Microservices</em></li>
				<li><a href="B14980_16.xhtml#_idTextAnchor285"><em class="italic">Chapter 16</em></a>, <em class="italic">Analyzing Log Data in Microservices with Node.js</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer121">
			</div>
		</div>
		<div>
			<div id="_idContainer122">
			</div>
		</div>
		<div>
			<div id="_idContainer123">
			</div>
		</div>
		<div>
			<div id="_idContainer124">
			</div>
		</div>
		<div>
			<div id="_idContainer125">
			</div>
		</div>
		<div>
			<div id="_idContainer126" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer127" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer128">
			</div>
		</div>
		<div>
			<div id="_idContainer129">
			</div>
		</div>
		<div>
			<div id="_idContainer130" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>