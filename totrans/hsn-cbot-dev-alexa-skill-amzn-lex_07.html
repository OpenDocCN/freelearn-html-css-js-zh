<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Publishing Your Chatbot to Facebook, Slack, Twilio, and HTTP</h1>
                </header>
            
            <article>
                
<p>We've learned how to build a range of chatbots using Amazon Lex, but currently, no one else can access them. In this chapter, we're going to learn how we can deploy our chatbots onto Facebook, Slack, and Twilio. We'll also learn how to integrate Lex with our own frontend and also create an HTTP endpoint, allowing more flexible integrations.</p>
<p class="mce-root">The following topics will be covered in this chapter:</p>
<ul>
<li class="mce-root">Deploying Lex chatbots to Facebook Messenger, Slack, and Twilio</li>
<li class="mce-root">Creating an HTTP endpoint to allow more flexible integrations</li>
<li class="mce-root">Building a frontend for our chatbot</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will be creating a Lambda function to power our HTTP endpoint, and we'll be creating and deploying it using the local development setup that we created in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>.</p>
<p class="mce-root">We'll also be using Facebook and Slack, so you need to have an account. If you don't already, you can create accounts for free.</p>
<p class="mce-root">All of the code and data required for this chapter can be found at <a href="http://bit.ly/chatbot-ch7">bit.ly/chatbot-ch7</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrations</h1>
                </header>
            
            <article>
                
<p class="mce-root">Having built a chatbot, you want users to be able to find it and use it. A lot of your users will already have Facebook or Slack, and they'll definitely have a mobile number. Being able to use our chatbots through these existing communication methods makes it a lot easier and more natural for our users.</p>
<p class="mce-root">To allow chatbots onto their systems, Facebook, Slack, and Twilio have created integration methods. This allows messages that are sent through each of those platforms to reach our chatbot, making our chatbot appear to be part of the system.</p>
<p class="mce-root">Amazon Lex makes it very easy for us to integrate with Facebook, Slack, Twilio, and Kik, hiding a lot of complex data formatting behind the scenes. To access the integrations that Lex has, click on the <span class="packt_screen">Channels</span> tab, and you'll have the choice to configure Facebook, Kik, Slack, or Twilio SMS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Facebook Messenger</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Facebook Messenger had 1.3 billion monthly users as of April 2018, and that number has been growing month on month. This is a huge user base that we can tap into.</p>
<p class="mce-root">As well as the massive user base, there's another great feature for chatbot developers. When you create a Facebook page for a company, organization, or anything else, it has a Messenger account. This is so that users can message the company, but this means that every company on Facebook could benefit from having a chatbot. That's a massive target market.</p>
<p>To access these channels, we can click on<span> </span><span class="packt_screen">Channels</span><span> in the Lex editor. </span>We can start by selecting Facebook as the channel and then giving this channel a name and description. Next, we can select the alias that we want to deploy. Make sure that you've published your chatbot to an alias and then we can select one of them in the dropdown:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a493bdc1-c852-4758-b444-ac10612aefc8.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Channels in Lex console</div>
<p class="mce-root">The last thing we can do right now is choose a <span class="packt_screen">Verify Token</span>. This is a string that we will use later to help connect Facebook to our Lex chatbot. This can be any string of letters and numbers you like.</p>
<p class="mce-root">The <span class="packt_screen">Page Access Token</span> and <span class="packt_screen">App Secret Key</span> are two values that we'll get once we've created a Facebook app, so we'll do this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and connecting a Facebook Messenger app</h1>
                </header>
            
            <article>
                
<p class="mce-root">To integrate a chatbot into Facebook Messenger, we need to first create a Facebook app. To get started, go to <a href="https://developers.facebook.com/">https://developers.facebook.com/</a> and click <span class="packt_screen">Log In</span>. If this is your first Facebook app, then you'll need to link this developer account to your personal account. Once you've logged in, you can create your first app. Click <span class="packt_screen">My Apps</span> and then select <span class="packt_screen">Create New App</span>. This will open a popup where we can name the app.</p>
<p class="mce-root">This app name won't be displayed to users; it is only ever seen by Facebook page admins:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1b1cac0c-7c25-4273-bcd6-ebae052f7fe0.png" style=""/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Creating your Facebook app</div>
<p class="mce-root">Facebook apps can be used to do a huge range of things, but we're wanting to build a Messenger chatbot, so we need to click <span class="packt_screen">Set Up</span> under <span class="packt_screen">Messenger</span>.</p>
<p class="mce-root">You should now be on a page titled <span class="packt_screen">Messenger Platform,</span> and, on the left, you should see <span class="packt_screen">Messenger</span> under <span class="packt_screen">PRODUCTS</span>. The first thing we need to do is to create a token so that Lex can get access to this app. To generate the token, we can go to the <span class="packt_screen">Token Generation</span> section and click the <span class="packt_screen">Select a Page</span> dropdown:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/45a5d082-1aec-4c57-91e7-680af185a5d5.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Generating your page token</div>
<p class="mce-root">If you're not an admin on any Facebook pages, then you're going to have to create one. On Facebook itself, you can quickly and easily make a page for the fake shop or just a page for yourself as a developer.</p>
<p class="mce-root">When you select the page, a token will be generated. <span>This can be copied and pasted into the <span class="packt_screen">Page Access Token</span> field in our Lex channel configuration.</span></p>
<p class="mce-root">The last thing we need to get is the <span class="packt_screen">App Secret</span> key, which we can find in our app page under <span class="packt_screen">Settings</span> | <span class="packt_screen">Basic</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-423 image-border" src="assets/827b2000-acba-4c28-b41c-2695c319a152.png" style=""/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Getting app credentials</div>
<p class="mce-root">With all of the details of the channel now done, we can click <span class="packt_screen">Activate,</span> and we'll be given a new <span class="packt_screen">Callback URL</span>. Copy this URL and go back to our Facebook app screen. Go back to the Messenger config <span class="packt_screen">Messenger</span> | <span class="packt_screen">Settings</span> in the left-hand menu, and scroll down to <span class="packt_screen">Webhooks</span>. Webhooks are how Facebook is going to send messages through to our Lex chatbot.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Click <span class="packt_screen">Setup Webhook</span><span class="packt_screen">s</span> to open a popup where we can paste the URL we got from Lex as the <span class="packt_screen">Callback URL</span> and then the <span class="packt_screen">Verify Token</span> that we specified in the setup of the Lex channel. We also need to subscribe to <em><span class="packt_screen">messages</span></em>, <em><span class="packt_screen">messaging_postbacks</span></em>, and <span class="packt_screen">messaging_optins</span>. These options are selecting which types of messages Facebook will send to Lex<span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c2b1c735-f2d1-476d-8d88-986fc66cb6e9.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Facebook Webhook options</div>
<p class="mce-root">Clicking <span class="packt_screen">Verify and Save</span> will send a request to Lex and will expect the correct verify token to be sent back. Normally, you would have to set up that endpoint, but Lex handles all of this.</p>
<p class="mce-root">The last Webhook setup that we need to do is to select the page we can subscribe to. In the <span class="packt_screen">Webhooks</span> section, there's a <span class="packt_screen">Select a Page</span> dropdown, which you need to set and then click <span class="packt_screen">Subscribe</span>.</p>
<p class="mce-root">Now the chatbot should be on your page, but it'll only be accessible by yourself and other people who you've added to the app. Adding more people to test or work on the app can be done in the <span class="packt_screen">Roles</span> menu on the left.</p>
<p class="mce-root">At this point, you can test out your chatbot by going to your Facebook page and sending it a message. Lex should receive the message and send the correct response as it did in the Lex console.</p>
<p class="mce-root">Before you can set your new app live, you need to ask Facebook to allow you to do page messaging. This is done by scrolling to the bottom of the <span class="packt_screen">Messenger</span> settings page and adding <span class="packt_screen">pages_messaging</span> to the submission. At this point, you will probably be asked to complete a few more things such as adding an app icon and setting a privacy policy URL and category:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-434 image-border" src="assets/0b5ed283-93f4-42c4-9b25-772d8464e696.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Submission requirements</div>
<p class="mce-root">Once you've completed these, you can submit your app for review. You'll be asked to provide example commands and their automated responses. Make sure that you've tested the commands before submitting as it can take up to a week to get an app verified, so getting it right the first time is key.</p>
<p>Facebook has recently updated its policies so that to activate your chatbot you need to have an approved Facebook business account. This involves registering your business details and providing a few pieces of evidence.</p>
<p class="mce-root">Once your app and the connected business account are verified, you get the joy of switching it from <span class="packt_screen">OFF</span> to <span class="packt_screen">ON</span> and allowing everyone to start messaging your chatbot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Slack</h1>
                </header>
            
            <article>
                
<p class="mce-root">Slack is a messaging platform massively popular with software developers and tech companies, and it fully supports chatbots.</p>
<p class="mce-root">As we did with Facebook, we need to choose a <span class="packt_screen">Channel Name</span> and <span class="packt_screen">Alias,</span> and you can provide a <span class="packt_screen">Channel Description</span> if you want to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and connecting a Slack app</h1>
                </header>
            
            <article>
                
<p class="mce-root">To start setting up our Slack app, we need to log in to the Slack API (<a href="https://api.slack.com/">https://api.slack.com/</a>). Once we're logged in, we can create a new app:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cb593330-99b7-47a8-9ea3-5b3f3dc20330.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Create Slack app</div>
<p class="mce-root">Next, we can set up the features for the app, which for us is configuring the bots feature. We need to give our app a <strong>Display name</strong> and a <strong>Default username</strong><em>,</em> and sett the <span class="packt_screen">Always On</span> toggle to <em><span class="packt_screen">On</span></em>. This means that the bot will always appear to be online.</p>
<p class="mce-root">With this set up, we can now go to <span class="packt_screen">Basic Information</span> in the left-hand menu, where we can get the <span class="packt_screen">Client ID</span>, <span class="packt_screen">Client Secret</span>, and <span class="packt_screen">Verification Token, </span>which we can paste into our Lex channel configuration.</p>
<p class="mce-root">When you <span class="packt_screen">Activate</span> the Lex channel, you should get a <span class="packt_screen">Postback URL</span> and <span class="packt_screen">OAuth URL</span>. The <span class="packt_screen">Postback URL</span> is the URL that listens for messages from Slack and the <span class="packt_screen">OAuth URL</span> is used to authenticate your bot.</p>
<p class="mce-root">With the <span class="packt_screen">OAuth URL</span>, we can go back to <a href="https://api.slack.com/">api.Slack.com</a> and navigate into our app. From here, we can navigate to <span class="packt_screen">OAuth &amp; Permissions</span> in the left-hand menu and click <span class="packt_screen">Add New Redirect URL</span>. We can now paste the <span class="packt_screen">OAuth URL</span> that we got from Lex.</p>
<p class="mce-root">We also need to set the scope of permissions that this app will get. In the <span class="packt_screen">Scopes</span> section, we can add permissions by selecting from the <span class="packt_screen">Select Permission Scopes</span> dropdown. We need to add <span class="packt_screen">Send messages as ... (chat:write:bot)</span> and <span class="packt_screen">Access information about your workspace (team: read)</span> and then save the changes:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-427 image-border" src="assets/735fac30-f6ba-4c42-a3e3-14d58a900c66.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Slack permissions</div>
<p class="mce-root">The next step is to allow Lex to interact with our Slack app by clicking on <span class="packt_screen">Interactive Components</span> in the left-hand menu and turning <strong>Interactivity</strong> on. We can then set the <span class="packt_screen">Request URL</span> to the <span class="packt_screen">Postback URL</span> that we got from a Lex activation.</p>
<p class="mce-root">The last step is to enable <span class="packt_screen">Event Subscriptions,</span> which can be found in the menu on the left. Turn it <span class="packt_screen">On,</span> and paste our <span class="packt_screen">Postback URL</span> as the <span class="packt_screen">Request URL,</span> and click <span class="packt_screen">Add Workspace Event</span>. Scroll down until you see <span class="packt_screen">message.im</span>, and add it, before saving changes.</p>
<p class="mce-root">To install our app onto your Slack channel, we need to go to <span class="packt_screen">Manage Distribution</span> and click <span class="packt_screen">Add to Slack</span>. You should be redirected to your Slack team, and you should see our chatbot in the <span class="packt_screen">Direct Messages</span>. If you don't see it, you can search for it using the <strong>+</strong> icon.</p>
<p class="mce-root">You can now send messages to the chatbot through Slack and you should receive the same responses as we got when we tested in the Lex console.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Twilio</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Twilio</strong> is a platform that allows you to use SMS, calls, and video calls to interact with users. We're going to be using it to allow users to interact with our bot over SMS text messages.</p>
<p class="mce-root">As we did with the two previous integrations, we can give the channel a <em>name</em> and <em>choose an alias</em>. The<span> </span><span class="packt_screen">Account SID</span> and<span> </span><span class="packt_screen">Authentication Token</span> need to be got from Twilio, so that's what we'll do now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and connecting Twilio</h1>
                </header>
            
            <article>
                
<p class="mce-root">To get started, we need to go to <a href="https://www.twilio.com/">www.twilio.com</a> and sign up or log in. Once you've signed in, go to <span class="packt_screen">Settings</span> in the left-hand menu and, under <span class="packt_screen">API Credentials,</span> you will see <span class="packt_screen">ACCOUNT SID</span> and <span class="packt_screen">AUTH TOKEN</span>. These can be copied and pasted into the Lex channel setup, and then we can click <span class="packt_screen">Activate</span>. Copy the <span class="packt_screen">Endpoint UR</span><span class="packt_screen">L</span> that is generated and go back to the Twilio console.</p>
<p class="mce-root">In the console, we need to go to <span class="packt_screen">Programmable SMS</span> and we start by getting a number from which we can text:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-424 image-border" src="assets/c68e942d-c728-48cf-9a34-9b4f467de72c.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Getting a number</div>
<p class="mce-root"><span>We'll be given a random phone number, and we can either <span class="packt_screen">Choose this Number</span></span> or<span> </span><span class="packt_screen">Search for a different number:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5ebbf1a3-4d66-47a3-9dda-d4b0e6890601.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Choosing a number</div>
<p><span>Now that we have a phone number to use, we can select <span class="packt_screen">Messaging Services</span> from the menu on the left. We can then add a service for our Lex chatbot. This service will allow us to receive text messages and pass them through to our Lex chatbot before replying with the Lex response. Give the service a name and make sure to set the use case to <span class="packt_screen">Chat Bot/Interactive 2-Wa</span><span class="packt_screen">y</span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-431 image-border" src="assets/06a66916-8dcd-4972-b6e4-6afc64c8ca7c.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Creating a new service</div>
<p class="mce-root">You should be sent to the <span class="packt_screen">Numbers</span> sub-menu, where we can <span class="packt_screen">Add an Existing Number</span> to this service. This selects the number that our chatbot will use. Select the number that we chose earlier and add this to the service.</p>
<p class="mce-root">With the number set on the service, we can go to <span class="packt_screen">Configure</span> to add the Endpoint URL that we get from Lex. We want to be able to receive inbound messages, so click the <span class="packt_screen">PROCESS INBOUND MESSAGES</span> tickbox and paste our URL in the <span class="packt_screen">REQUEST URL</span> box. Save this service, and we have just one thing left to do to: get our SMS chatbot working:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-420 image-border" src="assets/509cf560-3306-438e-ac96-c495e6a0abc1.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Inbound settings</div>
<p class="mce-root">The last thing we need to do is to allow our Twilio to send SMS messages to numbers in our region. Inside the <span class="packt_screen">Messaging Services,</span> go to <span class="packt_screen">Settings</span> and then <span class="packt_screen">Geo Permissions</span>. This is a list of all of the country locations that are available; we need to activate our regions to allow us to test it.</p>
<p>Search for your country and activate it by ticking the checkbox. You can activate as many regions as you like.</p>
<p>You can now test out your chatbot by sending a text to the number you chose for this service:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/c37f30cf-bc0e-491f-bf4a-91f48da36eef.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Texting chatbot</div>
<p>If you want to get rid of the<span> </span><span class="packt_screen">Sent from your Twilio trial account</span><span> message, then you'll need to upgrade. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP endpoint</h1>
                </header>
            
            <article>
                
<p class="mce-root">It's great that Lex makes it so easy to integrate our chatbot into Facebook, Slack, and Twilio, but we might also want to have our chatbot integrate into other services that don't have built-in integrations. For this, we can create an API endpoint for sending messages to our Lex chatbot.</p>
<p class="mce-root">With AWS, we are lucky that they let you create an API with Lambdas and API Gateway. This means that we don't need to run a server, which means less work for us.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Lambda</h1>
                </header>
            
            <article>
                
<p class="mce-root">We start by creating a new folder in our Lambdas repository called <kbd>lex-shopping-api</kbd> with an <kbd>index.js</kbd> file inside. In this file, we can start by exporting a handler that checks that the event was a <kbd>POST</kbd> request and calls <kbd>sendToLex</kbd> to generate a reply. This reply then gets passed to <kbd>done</kbd> which formats the data, so it can be returned to API Gateway:</p>
<pre class="mce-root">exports.handler = async (event) =&gt; {<br/>    if (event.httpMethod === "POST") {<br/>        let reply = await sendToLex(event);<br/>        return done(reply);<br/>    }<br/>};</pre>
<p class="mce-root">We now need to create the <kbd>sendToLex</kbd> function. The first thing that this function needs to do is to map the event body into the format that Lex requires. We'll create this <kbd>mapMessageToLex</kbd> function later:</p>
<pre class="mce-root">const sendToLex = async event =&gt; {<br/>    console.log('event', event);<br/>    let messageForLex = mapMessageToLex(JSON.parse(event.body));<br/>}</pre>
<p class="mce-root">This message now needs to be sent to Lex. Amazon has made this easy by creating the Lex runtime, which allows you to send messages to your Lex chatbots. To access the Lex runtime, we need to install the <kbd>aws-sdk</kbd> by running <kbd>npm init</kbd> and <kbd>npm install --save aws-sdk</kbd> inside our <kbd>lex-shopping-api</kbd> folder. We can then require it in and create a new instance of the Lex runtime class by adding this code at the top of our file:</p>
<pre class="mce-root">const AWS = require('aws-sdk');<br/>const lexruntime = new AWS.LexRuntime();</pre>
<p class="mce-root">To post a message to Lex, we need to call <kbd>lexruntime.postText()</kbd>, passing in the <kbd>messageForLex</kbd> and a handler callback. We can wrap the whole thing in a <kbd>new Promise</kbd> to allow us to control the <kbd>async</kbd> flow better:</p>
<pre class="mce-root">let lexPromise = new Promise((resolve, reject) =&gt; {<br/>    lexruntime.postText(messageForLex, (err, data) =&gt; {<br/>        if (err) {<br/>            reject(err);<br/>        } else {<br/>            resolve(data);<br/>        }<br/>    })<br/>});</pre>
<p class="mce-root"/>
<p class="mce-root">We can now <kbd>await</kbd> the <kbd>lexPromise</kbd> using our error handler to get either the response or an error. If there is an error, then we can return that error, and if we get a response, we can set the <kbd>res</kbd> to be an object containing the message:</p>
<pre class="mce-root">let [err, res] = await to(lexPromise);<br/>if (err) {<br/>    return { err }<br/>}<br/>console.log('lex response', res);<br/>return { res: { message: res.message } }</pre>
<p class="mce-root">These returned values will flow all the way back to populate the reply variable in our handler. This gets passed to <kbd>done</kbd>, so we now need to create that function. API Gateway expects to get a response in a specific format so this function is returning that format:</p>
<pre class="mce-root">const done = ({ err, res }) =&gt; {<br/>    console.log('res', res);<br/>    console.log('error', err);<br/>    return {<br/>        statusCode: err ? '404' : '200',<br/>        body: err ? JSON.stringify({ error: err }) : JSON.stringify(res),<br/>        headers: {<br/>            'Content-Type': 'application/json',<br/>            'Access-Control-Allow-Methods': '*',<br/>            'Access-Control-Allow-Origin': '*'<br/>        },<br/>    };<br/>}</pre>
<p class="mce-root">The last function that we need to create is <kbd>mapMessageToLex</kbd>. Lex runtime requires that it gets an object with <kbd>botAlias</kbd>, <kbd>botName</kbd>, <kbd>inputText</kbd>, <kbd>userId</kbd>, and <kbd>sessionAttributes</kbd> so we map the message into this format. If you want to create an API for a different bot, then all you need to do is to change the <kbd>botName</kbd> and <kbd>botAlias</kbd>:</p>
<pre class="mce-root">const mapMessageToLex = message =&gt; {<br/>    return {<br/>        botAlias: 'prod',<br/>        botName: 'shoppingBot',<br/>        inputText: message.text,<br/>        userId: message.sessionID,<br/>        sessionAttributes: {}<br/>    };<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p class="mce-root">To test that this Lambda works properly, we can run some tests on it. The only values that need to be passed into this Lambda are the <kbd>body</kbd> and <kbd>httpMethod</kbd>. Because the <kbd>body</kbd> is a string, we need to escape the quotation marks:</p>
<pre class="mce-root">{<br/>    "body": "{\"text\":\"I want to buy a shirt\", \"sessionID\": \"abc123\"}",<br/>    "httpMethod": "POST"<br/>}</pre>
<p class="mce-root">Running this test should result in this response, which is in the format that API Gateway expects:</p>
<pre class="mce-root">{<br/>    "statusCode": "200",<br/>    "body": "{\"message\":\"What size of shirt are you looking for?\"}",<br/>    "headers": {<br/>        "Content-Type": "application/json",<br/>        "Access-Control-Allow-Methods": "*",<br/>        "Access-Control-Allow-Origin": "*"<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting API Gateway</h1>
                </header>
            
            <article>
                
<p class="mce-root">API Gateway is a service that allows us to create URLs that can accept all of the normal API request methods. Start by going to the API Gateway service in AWS and clicking <span class="packt_screen">Get Started</span>.</p>
<p class="mce-root">When creating our first API, we should select <span class="packt_screen">New API</span> and then we can give this API a name and <span class="packt_screen">Description</span>, and click <span class="packt_screen">Create API</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-421 image-border" src="assets/543102dc-9a66-4fb1-a561-902c6608f28b.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">New API</div>
<p class="mce-root">You should now be on the configuration page for your API, but there are currently no endpoints created. Click on the <span class="packt_screen">Actions</span> dropdown and select <span class="packt_screen">Create Resource</span>. Doing this allows you to have the APIs for all of your Lex chatbots on a similar URL:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-432 image-border" src="assets/2ecb5089-fd69-4916-a4ff-941828ff82a7.png" style=""/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Creating a resource</div>
<p><span>Name the</span> resource <span><kbd>shopping-bot</kbd> and click <span class="packt_screen">Create Resource</span></span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-270 image-border" src="assets/48f70655-e9d9-4596-8749-3d44cb4f9cb7.png" style=""/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">New resource</div>
<p class="mce-root">Now that we have a resource created, we can attach a method to it. In our Lambda, we check that the <kbd>httpMethod</kbd> is <kbd>POST</kbd> so we need to create a <kbd>POST</kbd> method. Click on our <kbd>shopping-bot</kbd> resource and click <span class="packt_screen">Actions</span> | <span class="packt_screen">Create Method</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-425 image-border" src="assets/5d8ee865-703f-43cb-830f-5a4cd035e4bd.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">New method</div>
<p class="mce-root">This will open the method setup window, and there are a lot of ways to configure your method, but we're going to call our API Lambda. Make sure the integration type is <span class="packt_screen">Lambda Function</span> and that <span class="packt_screen">Use Lambda Proxy integration</span> is ticked. This makes sure that all of the request data is proxied through to the Lambda.</p>
<p class="mce-root">The next thing in the method setup is to select our <kbd>lex-shopping-api</kbd> as the Lambda function and to <span class="packt_screen">Save</span> the method:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fd0b461b-c40d-4e95-9a06-5899d47a191a.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Method setup</div>
<p class="mce-root">Finally, we need to add <strong>cross-origin resource sharing</strong> (<strong>CORS</strong>) to our API. This allows us to access our API from different internet browsers. This will be important when we build a frontend for this API in the next section. Select our <span class="packt_screen">shopping-bot</span> resource, and then we can click <span class="packt_screen">Actions</span> | <span class="packt_screen">Enable CORS</span>. We can leave all of the settings as default and click <span class="packt_screen">Enable CORS and replace existing CORS headers</span>, confirming that we want to replace existing values:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/ff23ddda-abcc-4207-9814-f6bcd707b262.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Adding CORS</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p class="mce-root">We can now test that our Lambda is being called properly by selecting the <span class="packt_screen">POST</span> method and clicking on <span class="packt_screen">TEST</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-422 image-border" src="assets/b8150dd5-b5f9-4076-8f57-45010bf319ba.png" style=""/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Method TEST</div>
<p class="mce-root">In this screen, we can set query strings, headers, and the request body. We don't need to send any query strings or headers, so we can scroll straight down to the request body section. As we should remember from the testing of the Lambda, all we need to pass through in the body is the <kbd>text</kbd> and a <kbd>sessionID</kbd>, so this is what we can put as the request body:</p>
<pre class="mce-root">{<br/>    "text":"I want to buy a shirt",<br/>    "sessionID": "abc123"<br/>}</pre>
<p class="mce-root">When we hit <span class="packt_screen">Test</span>, API Gateway will send our request through to our Lambda. Our Lambda will send it to our Lex chatbot and will send back the response. Our response body should come back like this:</p>
<pre class="mce-root">{<br/>    "message": "What size of shirt are you looking for?"<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the API</h1>
                </header>
            
            <article>
                
<p class="mce-root">The last thing to do is to build our API. While on our API, we can select <span class="packt_screen">Actions</span> | <span class="packt_screen">Deploy API</span>. As this is the first time we are deploying this API, we need to create a new stage. Give your stage a name and description, and you can also add a deployment description before clicking <span class="packt_screen">Deploy</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-433 image-border" src="assets/6327ffc6-b6fc-4071-9158-8db8908066b1.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Creating a stage</div>
<p class="mce-root">When your API deploys, you'll be given a URL for it, which will be <kbd>https://{unique-code}.execute-api.eu-west-1.amazonaws.com/{stage-name}</kbd>. To access the endpoint that we made, we need to add <kbd>/shopping-bot</kbd> to the end. For example, <kbd>https://acffds-4fnf8x-se54fws-s34d.execute-api.eu-west-1.amazonaws.com/production<span>/shopping-bot</span></kbd>. This now means you can use this API to integrate Lex into a wider range of systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web user interface</h1>
                </header>
            
            <article>
                
<p class="mce-root">Having our own chatbot interface allows users to access it by going to a web page, but we can also integrate that into other websites, or even create mobile apps for our chatbot. We can use the API that we created to easily access the chatbot without making our AWS credentials public.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTML</h1>
                </header>
            
            <article>
                
<p class="mce-root">To start, we need an HTML page to build upon. The three components that we need to start are a message area, a typing input box, and a send button. Create a folder with an <kbd>index.html</kbd> file inside and we can add this code to that file:</p>
<pre class="mce-root">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;link rel="stylesheet" href="./style.css"&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div id="messageArea"&gt;&lt;/div&gt;<br/>    &lt;div id="inputDivs"&gt;<br/>        &lt;input type="text" id="textInput"&gt;<br/>        &lt;button id="sendButton"&gt;Send&lt;/button&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;<br/>&lt;script src="./script.js"&gt;&lt;/script&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">This is a simple HTML file that has a CSS link in the header so we can style our page, the message area, input box and button, and two scripts. The first of these scripts imports <kbd>axios</kbd> so we can easily make requests, and the second is our own script. </p>
<p class="mce-root">As we've included the <kbd>style.css</kbd> and <kbd>script.js</kbd> files, we should create these files in our folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our script</h1>
                </header>
            
            <article>
                
<p class="mce-root">All of the functionality of this UI needs to be handled in this script file. When all of the HTML has loaded, we need to listen for the user clicking the <span class="packt_screen">Send</span> button. When that happens, we need to get the text from the input box and write it as a sent message before sending it to our API. When our API replies, we can add the response as a received message.</p>
<p class="mce-root">To start, we need to make sure that the document has fully loaded. We can check if the document is ready, and if not, then we wait for the <kbd>DOMContentLoaded</kbd> event:</p>
<pre class="mce-root">if (document.readyState === 'complete') {<br/>    start();<br/>} else {<br/>    document.addEventListener("DOMContentLoaded", start())<br/>}</pre>
<p class="mce-root">We can now create the <kbd>start</kbd> function and set the API URL and session ID. We can use the <kbd>Math.random()</kbd> technique to make a random 16-digit number for the <kbd>sessionID</kbd>:</p>
<pre class="mce-root">function start() {<br/>    const URL = 'YOUR-API-URL/production/shopping-bot';<br/>    // create unique code for this session<br/>    const sessionID = Math.random().toString().slice(-16);<br/>}</pre>
<p class="mce-root">At the <kbd>start()</kbd> function, we also need to access the message area, text input box, and send button, using <kbd>document.querySelector</kbd>:</p>
<pre class="mce-root">let messageArea = document.querySelector('#messageArea');<br/>let textArea = document.querySelector('#textInput');<br/>let sendButton = document.querySelector('#sendButton');</pre>
<p class="mce-root">On to the <kbd>sendButton</kbd>, we can attach a listener for when the user clicks send. This will start by getting the value of the text input box. If there isn't any text then we can return nothing from the function:</p>
<pre class="mce-root">sendButton.addEventListener('click', async e =&gt; {<br/>    let text = textArea.value;<br/>    console.log(text);<br/>    if (!text) return;<br/>}</pre>
<p class="mce-root">If there is any text, then we can carry on to create a <kbd>sendElement</kbd> and add it to the message area. We need to make sure to add the classes of <kbd>sendMessage</kbd> and <kbd>message</kbd> to the element so we can style them later:</p>
<pre class="mce-root">// Add to sent messages<br/>let sendElement = document.createElement('div');<br/>sendElement.classList.add('sendMessage');<br/>sendElement.classList.add('message');<br/>sendElement.appendChild(document.createTextNode(text));<br/>messageArea.appendChild(sendElement);</pre>
<p class="mce-root">Next, we have to send the message to our API. We can use <kbd>axios</kbd> as we imported it in the HTML file, passing through <kbd>text</kbd> and <kbd>sessionID</kbd> as the body. We need to make sure to copy the function from our Lambdas for error-handling here:</p>
<pre class="mce-root">// send to the API<br/>let [err, response] = await to(axios.post(URL, { text, sessionID }));</pre>
<p class="mce-root">If there is an error in the response, then we can set the message to an apology; otherwise, it will be the <kbd>response.data.message</kbd>:</p>
<pre class="mce-root">let responseMessage;<br/>if (err) {<br/>    responseMessage = 'Sorry I appear to have had an error';<br/>} else {<br/>    responseMessage = response.data.message;<br/>}</pre>
<p class="mce-root">The last thing to do is to add the received message to the message area so the user can see it. Don't forget to add the <kbd>receivedMessage</kbd> and <kbd>message</kbd> classes for styling later:</p>
<pre class="mce-root">// adding the response to received messages<br/>let receiveElement = document.createElement('div');<br/>receiveElement.classList.add('receivedMessage');<br/>receiveElement.classList.add('message');<br/>receiveElement.appendChild(document.createTextNode(responseMessage));<br/>messageArea.appendChild(receiveElement);</pre>
<p class="mce-root">If we open the HTML document in a browser, now we should be able to type and send messages to our Lex chatbot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-429 image-border" src="assets/539ba00f-2cb9-4ad3-ae2d-e9e360adf312.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Basic messaging</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Styling the frontend</h1>
                </header>
            
            <article>
                
<p class="mce-root">We've created an awesome web page that allows users to talk to a chatbot, but, currently, it looks awful. We can fix this by using our CSS file. While<span> building the chat, we've been adding classes and IDs to the elements. This means we can set styles on those classes and ids to style our whole chat window. The first thing to do is to set the size of the message area. We can also add a light background and set the overflow to scroll:</span></p>
<pre class="mce-root">#messageArea {<br/>    height: 93vh;<br/>    max-width: 450px;<br/>    background: #eee;<br/>    overflow-y: scroll;<br/>}</pre>
<p class="mce-root">Next, we can style the messages. We add common styling to the <kbd>message</kbd> class such as the <kbd>padding</kbd>, <kbd>margin</kbd>, and <kbd>max-width</kbd>, while the alignment, <kbd>background</kbd>, and <kbd>border-radius</kbd> are defined on each type of message:</p>
<pre class="mce-root">.message {<br/>    padding: 3%;<br/>    margin: 2%;<br/>    position: relative;<br/>    max-width: 70%;<br/>}<br/>.sendMessage {<br/>    right: -20%;<br/>    background: blue;<br/>    color: white;<br/>    border-radius: 16px 16px 8px 16px<br/>}<br/>.receivedMessage {<br/>    background: #bbb;<br/>    left: 0;<br/>    border-radius: 16px 16px 16px 8px;<br/>}</pre>
<p class="mce-root">The last bit to style is the input textbox and send button. We can use <kbd>display: flex</kbd> on the container <kbd>div</kbd> and <kbd>flex-grow: 2</kbd> on the text input so that it stretches to fill the width left by the button. We can style the button up a bit with a different border and background:</p>
<pre class="mce-root">#inputDivs {<br/>    width: 450px;<br/>    display: flex;<br/>}<br/>#textInput {<br/>    font-size: 15px;<br/>    flex-grow: 2;<br/>}<br/>#sendButton {<br/>    font-size: 15px;<br/>    border: 0px solid lightskyblue;<br/>    background: lightskyblue;<br/>    border-radius: 8px;<br/>    padding: 8px;<br/>    margin-left: 8px;<br/>}</pre>
<p class="mce-root">This results in a much nicer user experience than the plain text we had before. This is where you can spend some time customizing the look of your interface to be exactly how you want it to be.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">You can even style this to match the brand colors of a company:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-428 image-border" src="assets/13e37d4f-a664-4340-88e3-91e03230cab3.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Styled chat</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we've learned how to create integrations that allow users to access our chatbots from Facebook Messenger, Slack, and Twilio.</p>
<p class="mce-root">We've also learned how to create an API to give us the ability to integrate our chatbots into other services that Amazon doesn't currently support. This API used a Lambda function to handle the requests sent through API Gateway.</p>
<p class="mce-root">We then used this API to create a frontend web page for our chatbot. We wrote a simple HTML document and then used a script to communicate with the API and add the messages to the page. The last thing we did was add styling to the page so that it looked like a real messaging platform.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why do we want to integrate our chatbots into other platforms and services?</li>
<li>What services can you use to create an API?</li>
<li>What two things do we need to add to an API before it will work?</li>
<li>What is the last thing that we need to do to make our API public?</li>
<li>Name the three parts of our chatbot web page.</li>
<li>What is the first thing a loaded script file should do?</li>
</ol>


            </article>

            
        </section>
    </body></html>