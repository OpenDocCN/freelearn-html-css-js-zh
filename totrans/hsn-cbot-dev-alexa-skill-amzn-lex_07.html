<html><head></head><body>
        

                            
                    <h1 class="header-title">Publishing Your Chatbot to Facebook, Slack, Twilio, and HTTP</h1>
                
            
            
                
<p>We've learned how to build a range of chatbots using Amazon Lex, but currently, no one else can access them. In this chapter, we're going to learn how we can deploy our chatbots onto Facebook, Slack, and Twilio. We'll also learn how to integrate Lex with our own frontend and also create an HTTP endpoint, allowing more flexible integrations.</p>
<p class="mce-root">The following topics will be covered in this chapter:</p>
<ul>
<li class="mce-root">Deploying Lex chatbots to Facebook Messenger, Slack, and Twilio</li>
<li class="mce-root">Creating an HTTP endpoint to allow more flexible integrations</li>
<li class="mce-root">Building a frontend for our chatbot</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will be creating a Lambda function to power our HTTP endpoint, and we'll be creating and deploying it using the local development setup that we created in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>.</p>
<p class="mce-root">We'll also be using Facebook and Slack, so you need to have an account. If you don't already, you can create accounts for free.</p>
<p class="mce-root">All of the code and data required for this chapter can be found at <a href="http://bit.ly/chatbot-ch7">bit.ly/chatbot-ch7</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrations</h1>
                
            
            
                
<p class="mce-root">Having built a chatbot, you want users to be able to find it and use it. A lot of your users will already have Facebook or Slack, and they'll definitely have a mobile number. Being able to use our chatbots through these existing communication methods makes it a lot easier and more natural for our users.</p>
<p class="mce-root">To allow chatbots onto their systems, Facebook, Slack, and Twilio have created integration methods. This allows messages that are sent through each of those platforms to reach our chatbot, making our chatbot appear to be part of the system.</p>
<p class="mce-root">Amazon Lex makes it very easy for us to integrate with Facebook, Slack, Twilio, and Kik, hiding a lot of complex data formatting behind the scenes. To access the integrations that Lex has, click on the Channels tab, and you'll have the choice to configure Facebook, Kik, Slack, or Twilio SMS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Facebook Messenger</h1>
                
            
            
                
<p class="mce-root">The Facebook Messenger had 1.3 billion monthly users as of April 2018, and that number has been growing month on month. This is a huge user base that we can tap into.</p>
<p class="mce-root">As well as the massive user base, there's another great feature for chatbot developers. When you create a Facebook page for a company, organization, or anything else, it has a Messenger account. This is so that users can message the company, but this means that every company on Facebook could benefit from having a chatbot. That's a massive target market.</p>
<p>To access these channels, we can click on Channels in the Lex editor. We can start by selecting Facebook as the channel and then giving this channel a name and description. Next, we can select the alias that we want to deploy. Make sure that you've published your chatbot to an alias and then we can select one of them in the dropdown:</p>
<div><img src="img/a493bdc1-c852-4758-b444-ac10612aefc8.png"/></div>
<p>Channels in Lex console</p>
<p class="mce-root">The last thing we can do right now is choose a Verify Token. This is a string that we will use later to help connect Facebook to our Lex chatbot. This can be any string of letters and numbers you like.</p>
<p class="mce-root">The Page Access Token and App Secret Key are two values that we'll get once we've created a Facebook app, so we'll do this next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and connecting a Facebook Messenger app</h1>
                
            
            
                
<p class="mce-root">To integrate a chatbot into Facebook Messenger, we need to first create a Facebook app. To get started, go to <a href="https://developers.facebook.com/">https://developers.facebook.com/</a> and click Log In. If this is your first Facebook app, then you'll need to link this developer account to your personal account. Once you've logged in, you can create your first app. Click My Apps and then select Create New App. This will open a popup where we can name the app.</p>
<p class="mce-root">This app name won't be displayed to users; it is only ever seen by Facebook page admins:</p>
<div><img src="img/1b1cac0c-7c25-4273-bcd6-ebae052f7fe0.png" style=""/></div>
<p>Creating your Facebook app</p>
<p class="mce-root">Facebook apps can be used to do a huge range of things, but we're wanting to build a Messenger chatbot, so we need to click Set Up under Messenger.</p>
<p class="mce-root">You should now be on a page titled Messenger Platform, and, on the left, you should see Messenger under PRODUCTS. The first thing we need to do is to create a token so that Lex can get access to this app. To generate the token, we can go to the Token Generation section and click the Select a Page dropdown:</p>
<div><img src="img/45a5d082-1aec-4c57-91e7-680af185a5d5.png" style=""/></div>
<p>Generating your page token</p>
<p class="mce-root">If you're not an admin on any Facebook pages, then you're going to have to create one. On Facebook itself, you can quickly and easily make a page for the fake shop or just a page for yourself as a developer.</p>
<p class="mce-root">When you select the page, a token will be generated. This can be copied and pasted into the Page Access Token field in our Lex channel configuration.</p>
<p class="mce-root">The last thing we need to get is the App Secret key, which we can find in our app page under Settings | Basic:</p>
<div><img class="alignnone size-full wp-image-423 image-border" src="img/827b2000-acba-4c28-b41c-2695c319a152.png" style=""/></div>
<p>Getting app credentials</p>
<p class="mce-root">With all of the details of the channel now done, we can click Activate, and we'll be given a new Callback URL. Copy this URL and go back to our Facebook app screen. Go back to the Messenger config Messenger | Settings in the left-hand menu, and scroll down to Webhooks. Webhooks are how Facebook is going to send messages through to our Lex chatbot.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Click Setup Webhooks to open a popup where we can paste the URL we got from Lex as the Callback URL and then the Verify Token that we specified in the setup of the Lex channel. We also need to subscribe to <em>messages</em>, <em>messaging_postbacks</em>, and messaging_optins. These options are selecting which types of messages Facebook will send to Lex:</p>
<div><img src="img/c2b1c735-f2d1-476d-8d88-986fc66cb6e9.png"/></div>
<p>Facebook Webhook options</p>
<p class="mce-root">Clicking Verify and Save will send a request to Lex and will expect the correct verify token to be sent back. Normally, you would have to set up that endpoint, but Lex handles all of this.</p>
<p class="mce-root">The last Webhook setup that we need to do is to select the page we can subscribe to. In the Webhooks section, there's a Select a Page dropdown, which you need to set and then click Subscribe.</p>
<p class="mce-root">Now the chatbot should be on your page, but it'll only be accessible by yourself and other people who you've added to the app. Adding more people to test or work on the app can be done in the Roles menu on the left.</p>
<p class="mce-root">At this point, you can test out your chatbot by going to your Facebook page and sending it a message. Lex should receive the message and send the correct response as it did in the Lex console.</p>
<p class="mce-root">Before you can set your new app live, you need to ask Facebook to allow you to do page messaging. This is done by scrolling to the bottom of the Messenger settings page and adding pages_messaging to the submission. At this point, you will probably be asked to complete a few more things such as adding an app icon and setting a privacy policy URL and category:</p>
<div><img class="alignnone size-full wp-image-434 image-border" src="img/0b5ed283-93f4-42c4-9b25-772d8464e696.png" style=""/></div>
<p>Submission requirements</p>
<p class="mce-root">Once you've completed these, you can submit your app for review. You'll be asked to provide example commands and their automated responses. Make sure that you've tested the commands before submitting as it can take up to a week to get an app verified, so getting it right the first time is key.</p>
<p>Facebook has recently updated its policies so that to activate your chatbot you need to have an approved Facebook business account. This involves registering your business details and providing a few pieces of evidence.</p>
<p class="mce-root">Once your app and the connected business account are verified, you get the joy of switching it from OFF to ON and allowing everyone to start messaging your chatbot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Slack</h1>
                
            
            
                
<p class="mce-root">Slack is a messaging platform massively popular with software developers and tech companies, and it fully supports chatbots.</p>
<p class="mce-root">As we did with Facebook, we need to choose a Channel Name and Alias, and you can provide a Channel Description if you want to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and connecting a Slack app</h1>
                
            
            
                
<p class="mce-root">To start setting up our Slack app, we need to log in to the Slack API (<a href="https://api.slack.com/">https://api.slack.com/</a>). Once we're logged in, we can create a new app:</p>
<div><img src="img/cb593330-99b7-47a8-9ea3-5b3f3dc20330.png" style=""/></div>
<p>Create Slack app</p>
<p class="mce-root">Next, we can set up the features for the app, which for us is configuring the bots feature. We need to give our app a <strong>Display name</strong> and a <strong>Default username</strong><em>,</em> and sett the Always On toggle to <em>On</em>. This means that the bot will always appear to be online.</p>
<p class="mce-root">With this set up, we can now go to Basic Information in the left-hand menu, where we can get the Client ID, Client Secret, and Verification Token, which we can paste into our Lex channel configuration.</p>
<p class="mce-root">When you Activate the Lex channel, you should get a Postback URL and OAuth URL. The Postback URL is the URL that listens for messages from Slack and the OAuth URL is used to authenticate your bot.</p>
<p class="mce-root">With the OAuth URL, we can go back to <a href="https://api.slack.com/">api.Slack.com</a> and navigate into our app. From here, we can navigate to OAuth &amp; Permissions in the left-hand menu and click Add New Redirect URL. We can now paste the OAuth URL that we got from Lex.</p>
<p class="mce-root">We also need to set the scope of permissions that this app will get. In the Scopes section, we can add permissions by selecting from the Select Permission Scopes dropdown. We need to add Send messages as ... (chat:write:bot) and Access information about your workspace (team: read) and then save the changes:</p>
<div><img class="alignnone size-full wp-image-427 image-border" src="img/735fac30-f6ba-4c42-a3e3-14d58a900c66.png" style=""/></div>
<p>Slack permissions</p>
<p class="mce-root">The next step is to allow Lex to interact with our Slack app by clicking on Interactive Components in the left-hand menu and turning <strong>Interactivity</strong> on. We can then set the Request URL to the Postback URL that we got from a Lex activation.</p>
<p class="mce-root">The last step is to enable Event Subscriptions, which can be found in the menu on the left. Turn it On, and paste our Postback URL as the Request URL, and click Add Workspace Event. Scroll down until you see message.im, and add it, before saving changes.</p>
<p class="mce-root">To install our app onto your Slack channel, we need to go to Manage Distribution and click Add to Slack. You should be redirected to your Slack team, and you should see our chatbot in the Direct Messages. If you don't see it, you can search for it using the <strong>+</strong> icon.</p>
<p class="mce-root">You can now send messages to the chatbot through Slack and you should receive the same responses as we got when we tested in the Lex console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Twilio</h1>
                
            
            
                
<p class="mce-root"><strong>Twilio</strong> is a platform that allows you to use SMS, calls, and video calls to interact with users. We're going to be using it to allow users to interact with our bot over SMS text messages.</p>
<p class="mce-root">As we did with the two previous integrations, we can give the channel a <em>name</em> and <em>choose an alias</em>. The Account SID and Authentication Token need to be got from Twilio, so that's what we'll do now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and connecting Twilio</h1>
                
            
            
                
<p class="mce-root">To get started, we need to go to <a href="https://www.twilio.com/">www.twilio.com</a> and sign up or log in. Once you've signed in, go to Settings in the left-hand menu and, under API Credentials, you will see ACCOUNT SID and AUTH TOKEN. These can be copied and pasted into the Lex channel setup, and then we can click Activate. Copy the Endpoint URL that is generated and go back to the Twilio console.</p>
<p class="mce-root">In the console, we need to go to Programmable SMS and we start by getting a number from which we can text:</p>
<div><img class="alignnone size-full wp-image-424 image-border" src="img/c68e942d-c728-48cf-9a34-9b4f467de72c.png" style=""/></div>
<p>Getting a number</p>
<p class="mce-root">We'll be given a random phone number, and we can either Choose this Number or Search for a different number:</p>
<div><img src="img/5ebbf1a3-4d66-47a3-9dda-d4b0e6890601.png" style=""/></div>
<p>Choosing a number</p>
<p>Now that we have a phone number to use, we can select Messaging Services from the menu on the left. We can then add a service for our Lex chatbot. This service will allow us to receive text messages and pass them through to our Lex chatbot before replying with the Lex response. Give the service a name and make sure to set the use case to Chat Bot/Interactive 2-Way:</p>
<div><img class="alignnone size-full wp-image-431 image-border" src="img/06a66916-8dcd-4972-b6e4-6afc64c8ca7c.png" style=""/></div>
<p>Creating a new service</p>
<p class="mce-root">You should be sent to the Numbers sub-menu, where we can Add an Existing Number to this service. This selects the number that our chatbot will use. Select the number that we chose earlier and add this to the service.</p>
<p class="mce-root">With the number set on the service, we can go to Configure to add the Endpoint URL that we get from Lex. We want to be able to receive inbound messages, so click the PROCESS INBOUND MESSAGES tickbox and paste our URL in the REQUEST URL box. Save this service, and we have just one thing left to do to: get our SMS chatbot working:</p>
<div><img class="alignnone size-full wp-image-420 image-border" src="img/509cf560-3306-438e-ac96-c495e6a0abc1.png" style=""/></div>
<p>Inbound settings</p>
<p class="mce-root">The last thing we need to do is to allow our Twilio to send SMS messages to numbers in our region. Inside the Messaging Services, go to Settings and then Geo Permissions. This is a list of all of the country locations that are available; we need to activate our regions to allow us to test it.</p>
<p>Search for your country and activate it by ticking the checkbox. You can activate as many regions as you like.</p>
<p>You can now test out your chatbot by sending a text to the number you chose for this service:</p>
<div><img src="img/c37f30cf-bc0e-491f-bf4a-91f48da36eef.png" style=""/></div>
<p>Texting chatbot</p>
<p>If you want to get rid of the Sent from your Twilio trial account message, then you'll need to upgrade. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP endpoint</h1>
                
            
            
                
<p class="mce-root">It's great that Lex makes it so easy to integrate our chatbot into Facebook, Slack, and Twilio, but we might also want to have our chatbot integrate into other services that don't have built-in integrations. For this, we can create an API endpoint for sending messages to our Lex chatbot.</p>
<p class="mce-root">With AWS, we are lucky that they let you create an API with Lambdas and API Gateway. This means that we don't need to run a server, which means less work for us.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda</h1>
                
            
            
                
<p class="mce-root">We start by creating a new folder in our Lambdas repository called <kbd>lex-shopping-api</kbd> with an <kbd>index.js</kbd> file inside. In this file, we can start by exporting a handler that checks that the event was a <kbd>POST</kbd> request and calls <kbd>sendToLex</kbd> to generate a reply. This reply then gets passed to <kbd>done</kbd> which formats the data, so it can be returned to API Gateway:</p>
<pre class="mce-root">exports.handler = async (event) =&gt; {<br/>    if (event.httpMethod === "POST") {<br/>        let reply = await sendToLex(event);<br/>        return done(reply);<br/>    }<br/>};</pre>
<p class="mce-root">We now need to create the <kbd>sendToLex</kbd> function. The first thing that this function needs to do is to map the event body into the format that Lex requires. We'll create this <kbd>mapMessageToLex</kbd> function later:</p>
<pre class="mce-root">const sendToLex = async event =&gt; {<br/>    console.log('event', event);<br/>    let messageForLex = mapMessageToLex(JSON.parse(event.body));<br/>}</pre>
<p class="mce-root">This message now needs to be sent to Lex. Amazon has made this easy by creating the Lex runtime, which allows you to send messages to your Lex chatbots. To access the Lex runtime, we need to install the <kbd>aws-sdk</kbd> by running <kbd>npm init</kbd> and <kbd>npm install --save aws-sdk</kbd> inside our <kbd>lex-shopping-api</kbd> folder. We can then require it in and create a new instance of the Lex runtime class by adding this code at the top of our file:</p>
<pre class="mce-root">const AWS = require('aws-sdk');<br/>const lexruntime = new AWS.LexRuntime();</pre>
<p class="mce-root">To post a message to Lex, we need to call <kbd>lexruntime.postText()</kbd>, passing in the <kbd>messageForLex</kbd> and a handler callback. We can wrap the whole thing in a <kbd>new Promise</kbd> to allow us to control the <kbd>async</kbd> flow better:</p>
<pre class="mce-root">let lexPromise = new Promise((resolve, reject) =&gt; {<br/>    lexruntime.postText(messageForLex, (err, data) =&gt; {<br/>        if (err) {<br/>            reject(err);<br/>        } else {<br/>            resolve(data);<br/>        }<br/>    })<br/>});</pre>
<p class="mce-root"/>
<p class="mce-root">We can now <kbd>await</kbd> the <kbd>lexPromise</kbd> using our error handler to get either the response or an error. If there is an error, then we can return that error, and if we get a response, we can set the <kbd>res</kbd> to be an object containing the message:</p>
<pre class="mce-root">let [err, res] = await to(lexPromise);<br/>if (err) {<br/>    return { err }<br/>}<br/>console.log('lex response', res);<br/>return { res: { message: res.message } }</pre>
<p class="mce-root">These returned values will flow all the way back to populate the reply variable in our handler. This gets passed to <kbd>done</kbd>, so we now need to create that function. API Gateway expects to get a response in a specific format so this function is returning that format:</p>
<pre class="mce-root">const done = ({ err, res }) =&gt; {<br/>    console.log('res', res);<br/>    console.log('error', err);<br/>    return {<br/>        statusCode: err ? '404' : '200',<br/>        body: err ? JSON.stringify({ error: err }) : JSON.stringify(res),<br/>        headers: {<br/>            'Content-Type': 'application/json',<br/>            'Access-Control-Allow-Methods': '*',<br/>            'Access-Control-Allow-Origin': '*'<br/>        },<br/>    };<br/>}</pre>
<p class="mce-root">The last function that we need to create is <kbd>mapMessageToLex</kbd>. Lex runtime requires that it gets an object with <kbd>botAlias</kbd>, <kbd>botName</kbd>, <kbd>inputText</kbd>, <kbd>userId</kbd>, and <kbd>sessionAttributes</kbd> so we map the message into this format. If you want to create an API for a different bot, then all you need to do is to change the <kbd>botName</kbd> and <kbd>botAlias</kbd>:</p>
<pre class="mce-root">const mapMessageToLex = message =&gt; {<br/>    return {<br/>        botAlias: 'prod',<br/>        botName: 'shoppingBot',<br/>        inputText: message.text,<br/>        userId: message.sessionID,<br/>        sessionAttributes: {}<br/>    };<br/>}</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p class="mce-root">To test that this Lambda works properly, we can run some tests on it. The only values that need to be passed into this Lambda are the <kbd>body</kbd> and <kbd>httpMethod</kbd>. Because the <kbd>body</kbd> is a string, we need to escape the quotation marks:</p>
<pre class="mce-root">{<br/>    "body": "{\"text\":\"I want to buy a shirt\", \"sessionID\": \"abc123\"}",<br/>    "httpMethod": "POST"<br/>}</pre>
<p class="mce-root">Running this test should result in this response, which is in the format that API Gateway expects:</p>
<pre class="mce-root">{<br/>    "statusCode": "200",<br/>    "body": "{\"message\":\"What size of shirt are you looking for?\"}",<br/>    "headers": {<br/>        "Content-Type": "application/json",<br/>        "Access-Control-Allow-Methods": "*",<br/>        "Access-Control-Allow-Origin": "*"<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting API Gateway</h1>
                
            
            
                
<p class="mce-root">API Gateway is a service that allows us to create URLs that can accept all of the normal API request methods. Start by going to the API Gateway service in AWS and clicking Get Started.</p>
<p class="mce-root">When creating our first API, we should select New API and then we can give this API a name and Description, and click Create API:</p>
<div><img class="alignnone size-full wp-image-421 image-border" src="img/543102dc-9a66-4fb1-a561-902c6608f28b.png" style=""/></div>
<p>New API</p>
<p class="mce-root">You should now be on the configuration page for your API, but there are currently no endpoints created. Click on the Actions dropdown and select Create Resource. Doing this allows you to have the APIs for all of your Lex chatbots on a similar URL:</p>
<div><img class="alignnone size-full wp-image-432 image-border" src="img/2ecb5089-fd69-4916-a4ff-941828ff82a7.png" style=""/></div>
<p>Creating a resource</p>
<p>Name the resource <kbd>shopping-bot</kbd> and click Create Resource:</p>
<div><img class="alignnone size-full wp-image-270 image-border" src="img/48f70655-e9d9-4596-8749-3d44cb4f9cb7.png" style=""/></div>
<p>New resource</p>
<p class="mce-root">Now that we have a resource created, we can attach a method to it. In our Lambda, we check that the <kbd>httpMethod</kbd> is <kbd>POST</kbd> so we need to create a <kbd>POST</kbd> method. Click on our <kbd>shopping-bot</kbd> resource and click Actions | Create Method:</p>
<div><img class="alignnone size-full wp-image-425 image-border" src="img/5d8ee865-703f-43cb-830f-5a4cd035e4bd.png" style=""/></div>
<p>New method</p>
<p class="mce-root">This will open the method setup window, and there are a lot of ways to configure your method, but we're going to call our API Lambda. Make sure the integration type is Lambda Function and that Use Lambda Proxy integration is ticked. This makes sure that all of the request data is proxied through to the Lambda.</p>
<p class="mce-root">The next thing in the method setup is to select our <kbd>lex-shopping-api</kbd> as the Lambda function and to Save the method:</p>
<div><img src="img/fd0b461b-c40d-4e95-9a06-5899d47a191a.png" style=""/></div>
<p>Method setup</p>
<p class="mce-root">Finally, we need to add <strong>cross-origin resource sharing</strong> (<strong>CORS</strong>) to our API. This allows us to access our API from different internet browsers. This will be important when we build a frontend for this API in the next section. Select our shopping-bot resource, and then we can click Actions | Enable CORS. We can leave all of the settings as default and click Enable CORS and replace existing CORS headers, confirming that we want to replace existing values:</p>
<div><img src="img/ff23ddda-abcc-4207-9814-f6bcd707b262.png" style=""/></div>
<p>Adding CORS</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing</h1>
                
            
            
                
<p class="mce-root">We can now test that our Lambda is being called properly by selecting the POST method and clicking on TEST:</p>
<div><img class="alignnone size-full wp-image-422 image-border" src="img/b8150dd5-b5f9-4076-8f57-45010bf319ba.png" style=""/></div>
<p>Method TEST</p>
<p class="mce-root">In this screen, we can set query strings, headers, and the request body. We don't need to send any query strings or headers, so we can scroll straight down to the request body section. As we should remember from the testing of the Lambda, all we need to pass through in the body is the <kbd>text</kbd> and a <kbd>sessionID</kbd>, so this is what we can put as the request body:</p>
<pre class="mce-root">{<br/>    "text":"I want to buy a shirt",<br/>    "sessionID": "abc123"<br/>}</pre>
<p class="mce-root">When we hit Test, API Gateway will send our request through to our Lambda. Our Lambda will send it to our Lex chatbot and will send back the response. Our response body should come back like this:</p>
<pre class="mce-root">{<br/>    "message": "What size of shirt are you looking for?"<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the API</h1>
                
            
            
                
<p class="mce-root">The last thing to do is to build our API. While on our API, we can select Actions | Deploy API. As this is the first time we are deploying this API, we need to create a new stage. Give your stage a name and description, and you can also add a deployment description before clicking Deploy:</p>
<div><img class="alignnone size-full wp-image-433 image-border" src="img/6327ffc6-b6fc-4071-9158-8db8908066b1.png" style=""/></div>
<p>Creating a stage</p>
<p class="mce-root">When your API deploys, you'll be given a URL for it, which will be <kbd>https://{unique-code}.execute-api.eu-west-1.amazonaws.com/{stage-name}</kbd>. To access the endpoint that we made, we need to add <kbd>/shopping-bot</kbd> to the end. For example, <kbd>https://acffds-4fnf8x-se54fws-s34d.execute-api.eu-west-1.amazonaws.com/production/shopping-bot</kbd>. This now means you can use this API to integrate Lex into a wider range of systems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Web user interface</h1>
                
            
            
                
<p class="mce-root">Having our own chatbot interface allows users to access it by going to a web page, but we can also integrate that into other websites, or even create mobile apps for our chatbot. We can use the API that we created to easily access the chatbot without making our AWS credentials public.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HTML</h1>
                
            
            
                
<p class="mce-root">To start, we need an HTML page to build upon. The three components that we need to start are a message area, a typing input box, and a send button. Create a folder with an <kbd>index.html</kbd> file inside and we can add this code to that file:</p>
<pre class="mce-root">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;link rel="stylesheet" href="./style.css"&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div id="messageArea"&gt;&lt;/div&gt;<br/>    &lt;div id="inputDivs"&gt;<br/>        &lt;input type="text" id="textInput"&gt;<br/>        &lt;button id="sendButton"&gt;Send&lt;/button&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;script src="img/axios.min.js"&gt;&lt;/script&gt;<br/>&lt;script src="img/script.js"&gt;&lt;/script&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">This is a simple HTML file that has a CSS link in the header so we can style our page, the message area, input box and button, and two scripts. The first of these scripts imports <kbd>axios</kbd> so we can easily make requests, and the second is our own script. </p>
<p class="mce-root">As we've included the <kbd>style.css</kbd> and <kbd>script.js</kbd> files, we should create these files in our folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our script</h1>
                
            
            
                
<p class="mce-root">All of the functionality of this UI needs to be handled in this script file. When all of the HTML has loaded, we need to listen for the user clicking the Send button. When that happens, we need to get the text from the input box and write it as a sent message before sending it to our API. When our API replies, we can add the response as a received message.</p>
<p class="mce-root">To start, we need to make sure that the document has fully loaded. We can check if the document is ready, and if not, then we wait for the <kbd>DOMContentLoaded</kbd> event:</p>
<pre class="mce-root">if (document.readyState === 'complete') {<br/>    start();<br/>} else {<br/>    document.addEventListener("DOMContentLoaded", start())<br/>}</pre>
<p class="mce-root">We can now create the <kbd>start</kbd> function and set the API URL and session ID. We can use the <kbd>Math.random()</kbd> technique to make a random 16-digit number for the <kbd>sessionID</kbd>:</p>
<pre class="mce-root">function start() {<br/>    const URL = 'YOUR-API-URL/production/shopping-bot';<br/>    // create unique code for this session<br/>    const sessionID = Math.random().toString().slice(-16);<br/>}</pre>
<p class="mce-root">At the <kbd>start()</kbd> function, we also need to access the message area, text input box, and send button, using <kbd>document.querySelector</kbd>:</p>
<pre class="mce-root">let messageArea = document.querySelector('#messageArea');<br/>let textArea = document.querySelector('#textInput');<br/>let sendButton = document.querySelector('#sendButton');</pre>
<p class="mce-root">On to the <kbd>sendButton</kbd>, we can attach a listener for when the user clicks send. This will start by getting the value of the text input box. If there isn't any text then we can return nothing from the function:</p>
<pre class="mce-root">sendButton.addEventListener('click', async e =&gt; {<br/>    let text = textArea.value;<br/>    console.log(text);<br/>    if (!text) return;<br/>}</pre>
<p class="mce-root">If there is any text, then we can carry on to create a <kbd>sendElement</kbd> and add it to the message area. We need to make sure to add the classes of <kbd>sendMessage</kbd> and <kbd>message</kbd> to the element so we can style them later:</p>
<pre class="mce-root">// Add to sent messages<br/>let sendElement = document.createElement('div');<br/>sendElement.classList.add('sendMessage');<br/>sendElement.classList.add('message');<br/>sendElement.appendChild(document.createTextNode(text));<br/>messageArea.appendChild(sendElement);</pre>
<p class="mce-root">Next, we have to send the message to our API. We can use <kbd>axios</kbd> as we imported it in the HTML file, passing through <kbd>text</kbd> and <kbd>sessionID</kbd> as the body. We need to make sure to copy the function from our Lambdas for error-handling here:</p>
<pre class="mce-root">// send to the API<br/>let [err, response] = await to(axios.post(URL, { text, sessionID }));</pre>
<p class="mce-root">If there is an error in the response, then we can set the message to an apology; otherwise, it will be the <kbd>response.data.message</kbd>:</p>
<pre class="mce-root">let responseMessage;<br/>if (err) {<br/>    responseMessage = 'Sorry I appear to have had an error';<br/>} else {<br/>    responseMessage = response.data.message;<br/>}</pre>
<p class="mce-root">The last thing to do is to add the received message to the message area so the user can see it. Don't forget to add the <kbd>receivedMessage</kbd> and <kbd>message</kbd> classes for styling later:</p>
<pre class="mce-root">// adding the response to received messages<br/>let receiveElement = document.createElement('div');<br/>receiveElement.classList.add('receivedMessage');<br/>receiveElement.classList.add('message');<br/>receiveElement.appendChild(document.createTextNode(responseMessage));<br/>messageArea.appendChild(receiveElement);</pre>
<p class="mce-root">If we open the HTML document in a browser, now we should be able to type and send messages to our Lex chatbot:</p>
<div><img class="alignnone size-full wp-image-429 image-border" src="img/539ba00f-2cb9-4ad3-ae2d-e9e360adf312.png" style=""/></div>
<p>Basic messaging</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Styling the frontend</h1>
                
            
            
                
<p class="mce-root">We've created an awesome web page that allows users to talk to a chatbot, but, currently, it looks awful. We can fix this by using our CSS file. While building the chat, we've been adding classes and IDs to the elements. This means we can set styles on those classes and ids to style our whole chat window. The first thing to do is to set the size of the message area. We can also add a light background and set the overflow to scroll:</p>
<pre class="mce-root">#messageArea {<br/>    height: 93vh;<br/>    max-width: 450px;<br/>    background: #eee;<br/>    overflow-y: scroll;<br/>}</pre>
<p class="mce-root">Next, we can style the messages. We add common styling to the <kbd>message</kbd> class such as the <kbd>padding</kbd>, <kbd>margin</kbd>, and <kbd>max-width</kbd>, while the alignment, <kbd>background</kbd>, and <kbd>border-radius</kbd> are defined on each type of message:</p>
<pre class="mce-root">.message {<br/>    padding: 3%;<br/>    margin: 2%;<br/>    position: relative;<br/>    max-width: 70%;<br/>}<br/>.sendMessage {<br/>    right: -20%;<br/>    background: blue;<br/>    color: white;<br/>    border-radius: 16px 16px 8px 16px<br/>}<br/>.receivedMessage {<br/>    background: #bbb;<br/>    left: 0;<br/>    border-radius: 16px 16px 16px 8px;<br/>}</pre>
<p class="mce-root">The last bit to style is the input textbox and send button. We can use <kbd>display: flex</kbd> on the container <kbd>div</kbd> and <kbd>flex-grow: 2</kbd> on the text input so that it stretches to fill the width left by the button. We can style the button up a bit with a different border and background:</p>
<pre class="mce-root">#inputDivs {<br/>    width: 450px;<br/>    display: flex;<br/>}<br/>#textInput {<br/>    font-size: 15px;<br/>    flex-grow: 2;<br/>}<br/>#sendButton {<br/>    font-size: 15px;<br/>    border: 0px solid lightskyblue;<br/>    background: lightskyblue;<br/>    border-radius: 8px;<br/>    padding: 8px;<br/>    margin-left: 8px;<br/>}</pre>
<p class="mce-root">This results in a much nicer user experience than the plain text we had before. This is where you can spend some time customizing the look of your interface to be exactly how you want it to be.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">You can even style this to match the brand colors of a company:</p>
<div><img class="alignnone size-full wp-image-428 image-border" src="img/13e37d4f-a664-4340-88e3-91e03230cab3.png" style=""/></div>
<p>Styled chat</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we've learned how to create integrations that allow users to access our chatbots from Facebook Messenger, Slack, and Twilio.</p>
<p class="mce-root">We've also learned how to create an API to give us the ability to integrate our chatbots into other services that Amazon doesn't currently support. This API used a Lambda function to handle the requests sent through API Gateway.</p>
<p class="mce-root">We then used this API to create a frontend web page for our chatbot. We wrote a simple HTML document and then used a script to communicate with the API and add the messages to the page. The last thing we did was add styling to the page so that it looked like a real messaging platform.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Why do we want to integrate our chatbots into other platforms and services?</li>
<li>What services can you use to create an API?</li>
<li>What two things do we need to add to an API before it will work?</li>
<li>What is the last thing that we need to do to make our API public?</li>
<li>Name the three parts of our chatbot web page.</li>
<li>What is the first thing a loaded script file should do?</li>
</ol>


            

            
        
    </body></html>