["```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\n// A typical Flux store class. This module\n// exports a singleton instance of it.\nclass SingletonStore extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = {\n      pending: true\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n        case MY_ACTION:\n          this.state.pending = false;\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new SingletonStore();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\n// Exports the state of this store...\nexport var state = {\n  pending: true\n};\n\n// Exports the \"id\" of the dispatcher registration\n// so that other stores can depend on this module.\nexport var id = dispatcher.register((e) => {\n  switch(e.type) {\n    case MY_ACTION:\n      state.pending = false;\n      emitter.emit('change', state);\n      break;\n    }\n});\n\n// We need to create a new \"EventEmitter\" here\n// since there's no class to extend it.\nconst emitter = new EventEmitter();\n\n// Exports the minimal interface that views\n// require to listen/unlisten to stores.\nexport const on = emitter.on.bind(emitter);\nexport const off = emitter.removeListener.bind(emitter);\n```", "```js\nimport { myAction } from './actions/my-action';\nimport singletonStore from './stores/singleton-store';\n\n// Note that \"moduleStore\" is a module, with everything\n// that it exports, not a class instance.\nimport * as moduleStore from './stores/module-store';\n\n// Registers a \"change\" callback with the singleton\n// store...\nsingletonStore.on('change', (state) => {\n  console.log('singleton', state.pending);\n});\n\n// Registers a \"change\" callback with the module\n// store. Not that it looks and feels exactly\n// like a class instance.\nmoduleStore.on('change', (state) => {\n  console.log('module', state.pending);\n});\n\n// Triggers the \"MY_ACTION\" action.\nmyAction();\n```", "```js\nimport myStore from '../stores/my-store';\n\nclass ClassView {\n  constructor() {\n\n    // The \"container\" DOM element for this view.\n    this.container =\n      document.getElementById('class-view');\n\n    // Render the new state when \"myStore\" changes.\n    myStore.on('change', (state) => {\n      this.render(state);\n    });\n  }\n\n  render({ classContent } = myStore.state) {\n\n    // Sets the content of the container element.\n    // This is done by reducing the \"classContent\"\n    // array to a single string. If it's empty,\n    // any existing DOM elements are removed from\n    // the container.\n    this.container.innerHTML = classContent.reduce(\n      (x, y) => `<strong>${x + y}</strong>`, '');\n  }\n}\n\nexport default new ClassView();\n```", "```js\nimport React from 'react';\n\n// Renders the view content using a functional\n// React component.\nexport default ({content}) => (\n  <strong>{content}</strong>\n);\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { SHOW_CLASS, SHOW_FUNCTION } from '../actions/show';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // The two content properties of this store's state\n    // empty arrays, meaning empty content.\n    this.state = {\n      classContent: [],\n      functionContent: []\n    };\n\n    this.id = dispatcher.register((e) => {\n      let {state} = this;\n\n      switch(e.type) {\n\n        // If the \"SHOW_CLASS\" action was dispatched,\n        // the \"classContent\" state gets a single item\n        // array and the \"functionContent\" state gets\n        // and empty array.\n        case SHOW_CLASS:\n          Object.assign(state, {\n            classContent: [ 'Class View' ],\n            functionContent: []\n          });\n\n          this.emit('change', state);\n          break;\n\n        // If the \"SHOW_FUNCTION\" action was dispatched,\n        // the \"functionContent\" state gets a single item\n        // array and the \"classContent\" state gets an\n        // empty array.\n        case SHOW_FUNCTION:\n          Object.assign(state, {\n            classContent: [],\n            functionContent: [ 'Function View' ]\n          });\n\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport { showClass, showFunction } from './actions/show';\nimport myStore from './stores/my-store';\nimport classView from './views/class';\nimport FunctionView from './views/function';\n\n// The DOM element used by our \"FunctionView\"\n// component.\nvar functionContainer = document\n  .getElementById('function-view');\n\n// Utility to render the \"FunctionView\" React\n// component. Called by the store \"change\"\n// handler and to perform the initial rendering.\nfunction renderFunction(state) {\n  render(\n    <FunctionView\n      content={state.functionContent}/>,\n    functionContainer\n  );\n}\n\n// Sets up the \"change\" handler for \"FunctionView\"...\nmyStore.on('change', renderFunction);\n\n// Perform the initial rendering of both views...\nclassView.render();\nrenderFunction(myStore.state);\n\n// Dispatch the \"SHOW_CLASS\" action.\nshowClass();\n\n// Wait one second, then dispatch the \"SHOW_FUNCTION\"\n// action.\nsetTimeout(() => {\n  showFunction();\n}, 1000);\n```", "```js\n// A really simple view...\nexport default class MyView {\n  constructor(store) {\n\n    // Do nothing except verify that there's\n    // a \"result\" state property.\n    store.on('change', ({ result }) => {\n      console.assert(\n        Number.isInteger(result),\n        'MyView'\n      );\n    });\n  }\n}\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\n// We're exporting the store class instead of\n// an instance from this module because the\n// main module will create a bunch of them.\nexport default class MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // The EventEmitter thinks we're leaking memory\n    // there's too many listeners. This circumvents\n    // the limitation.\n    this.setMaxListeners(5000);\n\n    this.state = {};\n\n    this.id = dispatcher.register((e) => {\n      let {state} = this;\n\n      // Perform some basic arithmetic before emitting\n      // the \"change\" event with the \"result\" state\n      // property.\n      switch(e.type) {\n        case MY_ACTION:\n          state.result = 100000 * e.payload;\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n```", "```js\nimport MyStore from './stores/my-store';\nimport MyView from './views/my-view';\nimport { myAction } from './actions/my-action';\n\n// Holds onto our store and view references...\nvar stores = [];\nvar views = [];\n\n// How many items to create and actions to\n// dispatch...\nvar storeCount = 100;\nvar viewCount = 1000;\nvar actionCount = 10;\n\n// Setup our Flux infrastructure. This establishes\n// all the relevant store listeners and view\n// listeners. They all stay active throughout the\n// lifetime of the application.\nconsole.time('startup');\nfor (let i = 0; i < storeCount; i++) {\n  let store = new MyStore();\n  stores.push(store);\n\n  for (let i = 0; i < viewCount; i++) {\n    views.push(new MyView(store));\n  }\n}\nconsole.timeEnd('startup')\n// → startup: 26.286ms\n\nconsole.log('stores', stores.length);\nconsole.log('views', views.length);\nconsole.log('actions', actionCount);\n// →\n// stores 100\n// views 100000\n// actions 10\n\n// Dispatches the actions. This is where we either\n// succeed or fail at scaling the architecture.\nconsole.time('dispatch');\nfor (let i = 0; i < actionCount; i++) {\n  myAction();\n}\nconsole.timeEnd('dispatch');\n// → dispatch: 443.929ms\n```", "```js\nimport React from 'react';\nimport { hideAll, hideOdd } from '../actions/hide';\n\n// The view function, renders a button\n// that deletes store data by dispatching\n// the \"HIDE_ALL\" action, and renders a list\n// of items. The hide odds button only deletes\n// some store data by dispatching the \"HIDE_ODD\"\n// action.\nexport default ({ items }) => (\n  <div>\n    <button onClick={hideAll}>Hide All</button>\n    <button onClick={hideOdd}>Hide Odd</button>\n    <ul>\n      {items.map(item =>\n        <li key={item}>{item}</li>\n      )}\n    </ul>\n  </div>\n);\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { HIDE_ALL, HIDE_ODD } from '../actions/hide';\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // The initial state is an \"items\" array\n    // of 100 numbers.\n    this.state = {\n      items: new Array(100)\n        .fill(null)\n        .map((x, y) => y)\n    };\n\n    this.id = dispatcher.register((e) => {\n      let { state } = this;\n\n      switch(e.type) {\n\n        // When the \"HIDE_ALL\" action is dispatched,\n        // the \"items\" state is reset back to\n        // an empty array.\n        case HIDE:\n          state.items = []\n          this.emit('change', state);\n          break;\n\n        // When the \"HIDE_ODD\" action is dispatched,\n        // the \"items\" state is filtered to include\n        // only even numbers.\n        case HIDE_ODD:\n          state.items = state.items.filter(\n            x => !(x % 2));\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport myStore from './stores/my-store';\nimport MyView from './views/my-view';\n\n// The DOM container for the React view...\nvar container = document.getElementById('my-view');\n\n// Renders the functional \"MyView\" React\n// component.\nfunction renderView(state) {\n  render(\n    <MyView\n      items={state.items}/>,\n    container\n  );\n}\n\n// Re-render the React component when the store\n// state changes.\nmyStore.on('change', renderView);\n\n// Perform the initial render.\nrenderView(myStore.state);\n```", "```js\nimport React from 'react';\nimport { id } from '../util';\nimport { showUsers, showGroups } from '../actions/show';\n\n// This react view displays the two radio\n// buttons that determine which list to display.\n// Note that they're both using \"map()\" even\n// though it's a single item array. This is to\n// keep the logic in the store and out of the view.\nexport default ({ users, groups }) => (\n  <div>\n    {users.map(user =>\n      <label key={id.next()}>\n        {user.label}\n        <input\n          type=\"radio\"\n          name=\"display\"\n          checked={user.checked}\n          onChange={showUsers}\n        />\n      </label>\n    )}\n    {groups.map(group =>\n      <label key={id.next()}>\n        {group.label}\n        <input\n          type=\"radio\"\n          name=\"display\"\n          checked={group.checked}\n          onChange={showGroups}\n        />\n      </label>\n    )}\n  </div>\n);\n```", "```js\nimport React from 'react';\n\n// A simple React view that displays a list of\n// users.\nexport default ({ users }) => (\n  <ul>\n    {users.map(({ name, groupName }) =>\n      <li key={name}>{name} ({groupName})</li>\n    )}\n  </ul>\n);\n```", "```js\nimport React from 'react';\n\n// A simple React view that displays a list\n// of groups...\nexport default ({ groups }) => (\n  <ul>\n    {groups.map(group =>\n      <li key={group}>{group}</li>\n    )}\n  </ul>\n);\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\n\nimport { SHOW_USERS, SHOW_GROUPS } from '../actions/show';\n\nclass Radio extends EventEmitter {\n  constructor() {\n    super();\n\n    // This store represents radio buttons for\n    // the \"users\" and \"groups\" display. Each\n    // is represented as an array so that we can\n    // easily take the take the button out of\n    // the view by emptying the array.\n    this.state = {\n      users: [{\n        label: 'Users',\n        checked: true\n      }],\n      groups: [{\n        label: 'Groups',\n        checked: false\n      }]\n    };\n\n    this.id = dispatcher.register((e) => {\n\n      // Easy access to the state properties\n      // we need in this handler. See the two\n      // getter methods below.\n      let { users, groups } = this;\n\n      switch(e.type) {\n\n        // Mark the \"users\" display as \"checked\".\n        case SHOW_USERS:\n          users.checked = true;\n          groups.checked = false;\n\n          this.emit('change', this.state);\n          break;\n\n        // Mark the \"groups\" display as \"checked\".\n        case SHOW_GROUPS:\n          users.checked = false;\n          groups.checked = true;\n\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n\n  // A shortcut for easy access to the \"users\" state.\n  get users() {\n    return this.state.users[0]\n  }\n\n  // A shortcut for easy access to the \"groups\" state.\n  get groups() {\n    return this.state.groups[0]\n  }\n}\n\nexport default new Radio();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { SHOW_GROUPS } from '../actions/show';\n\nclass Groups extends EventEmitter {\n  constructor() {\n    super();\n\n    // The default \"_group\" state is an array of group\n    // names.\n    this.state = {\n      _groups: [\n        'Group 1',\n        'Group 2'\n      ]\n    };\n\n    // The \"groups\" state is what's actually used\n    // by views and is an empty array by default\n    // because nothing is displayed by default.\n    this.state.groups = [];\n\n    this.id = dispatcher.register((e) => {\n      let { state } = this;\n\n      switch(e.type) {\n\n        // The \"SHOW_GROUPS\" action will map the\n        // \"_groups\" state to the \"groups\" state\n        // so that the view has something to display.\n        case SHOW_GROUPS:\n          state.groups = state._groups.map(x => x);\n          this.emit('change', state);\n          break;\n\n        // By default, the \"groups\" state is emptied,\n        // which clears out the view's elements. The\n        // \"_groups\" state, however, remains intact.\n        default:\n          state.groups = [];\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Groups();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport groups from './groups';\nimport { SHOW_USERS } from '../actions/show';\n\nclass Users extends EventEmitter {\n  constructor() {\n    super();\n\n    // The default state of the \"_users\" state is\n    // an array of user objects with references to\n    // groups from another store.\n    this.state = {\n      _users: [\n        { name: 'User 1', group: 1 },\n        { name: 'User 2', group: 0 },\n        { name: 'User 3', group: 1 }\n      ]\n    };\n\n    // Sets the \"users\" state array, the state\n    // that's actually used by views. See\n    // \"mapUsers()\" below.\n    this.mapUsers();\n\n    this.id = dispatcher.register((e) => {\n      let { state } = this;\n\n      switch(e.type) {\n\n        // If we're showing users, we need to \"waitFor()\"\n        // the \"groups\" store because we depend on it.\n        // Then we can use \"mapUsers()\" again.\n        case SHOW_USERS:\n          dispatcher.waitFor([ groups.id ]);\n\n          this.mapUsers();\n\n          this.emit('change', state);\n          break;\n\n        // The default action is to empty out\n        // the \"users\" state so that the view\n        // will delete the UI elements. However, the\n        // \"_users\" state remains, so that other stores\n        // that depend on this one can still access\n        // the data.\n        default:\n          state.users = [];\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n\n  // Maps the \"_users\" state to the \"users\" state.\n  // The idea being that the \"users\" array can be\n  // emptied to update view displays while the \"_users\"\n  // array remains intact for other stores to use.\n  mapUsers() {\n    this.state.users = this.state._users.map(user =>\n      Object.assign({\n        groupName: groups.state._groups[user.group]\n      }, user)\n    );\n  }\n}\n\nexport default new Users();\n```", "```js\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport radio from './stores/radio';\nimport users from './stores/users';\nimport groups from './stores/groups';\n\nimport Radio from './views/radio';\nimport Users from './views/users';\nimport Groups from './views/groups';\n\n// The container DOM element...\nvar container = document.getElementById('app');\n\n// Renders the React components. The state for the\n// Flux stores are passed in as props.\nfunction renderApp(\n  radioState=radio.state,\n  usersState=users.state,\n  groupsState=groups.state\n) {\n  render(\n    <div>\n      <Radio\n        users={radioState.users}\n        groups={radioState.groups}/>\n      <Users\n        users={usersState.users}/>\n      <Groups\n        groups={groupsState.groups}/>\n    </div>,\n    container\n  );\n}\n\n// Renders the app with the new \"radio\" state.\nradio.on('change', (state) => {\n  renderApp(state, users.state, groups.state);\n});\n\n// Renders the app with the new \"users\" state.\nusers.on('change', (state) => {\n  renderApp(radio.state, state, groups.state);\n});\n\n// Renders the app with the new \"groups\" state.\ngroups.on('change', (state) => {\n  renderApp(radio.state, users.state, state);\n});\n\n// Initial app rendering...\nrenderApp();\n```"]