- en: '*Chapter 5*: Waiting for elements and network calls'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I won't say I'm old, but I started browsing the internet in the late 90s. So
    yes, I'm old. Back then, you would sometimes have to wait over a minute to get
    a page loaded. You might be thinking, "So if you had 10 tabs open, that would
    be impossible to use." Well, browsers didn't have tabs! Downloading one single
    MP3 file could take you an hour.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 2000s, the web got into the corporate world, and we started developing
    business apps using websites. But that was a decision from an IT department. Old
    terminal apps were hard to update and introduce new features, and desktop apps
    were hard to distribute. Web apps were the IT department's solution, leaving users
    with slow and non-user-friendly web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Developers were trying to do their best with the tools they had back then. Pages
    were mostly generated on the server side using tools such as ASP 3.0 or PHP. AJAX
    was used for small tasks, such as loading the state's list based on a country
    selection without reloading the entire page.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 2000s, Google launched *Gmail*, showing the world how the web should
    look. But the bar was too high for developers. Developing those kinds of apps
    was unthinkable for developers just trying to build CRUD pages.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, our web looks different. Developers are now able to create rich experiences,
    even for more straightforward scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is a thing that didn''t change in all these years: **You have to
    wait**.'
  prefs: []
  type: TYPE_NORMAL
- en: You have to wait for the site to load, for the data to be refreshed, for the
    new page to be opened, for the form to be submitted. You have to wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Waiting for the right moment to act is key to avoid having flaky tests. A flaky
    test is a test that sometimes passes and sometimes fails. You have to consider
    flaky tests as a bug, not in the app but in your tests. Flaky tests bring many
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: They are a waste of time. Nobody wants to merge a pull request with the tests
    in red. So, they will repeatedly run the tests until they get all the tests green.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flaky tests are a false alarm. Suppose the developer doesn't know that the test
    is flaky. They might try to find a non-existent bug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flaky tests hurt your tests' reputation. The loss of reputation begins by skipping
    one flaky test. If you have more flaky tests, the team might move your tests to
    a nightly process. If your tests keep being flaky, they might be removed from
    the CI process. You lose, and your team losses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for the right moment to act is the key to making stable UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the tools that Puppeteer provides to act
    at the right moment. We will also learn different techniques and approaches, so
    you can know how you can wait for the page to be ready, for an input to be visible,
    or for a request to be made, among many other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is about **waiting**, a key topic in web automation. I also want
    to show you a Puppeteer recorder so that you can add one more tool to your toolbox.
    We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for the page to load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for network calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for page events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bonus: Headless Recorder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start at the beginning. How do you know that the page is already loaded?
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter5` directory. Remember to run `npm install` on that directory
    and then go to the `Chapter5/vuejs-firebase-shopping-cart` directory and run `npm
    install` again.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to implement the code while following this chapter, you can start
    from the code you left in the `Chapter4` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for the page to load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050), *Navigating
    through a website*, we talked about navigation through a site. We covered functions
    such as `goto`, `goBack`, `goForward`, and `reload`. One of the options these
    functions have is the `waitUntil` option. This option will help us determine when
    the function we are calling will be resolved. Let''s do a quick recap. We have
    four options there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`domcontentloaded`, which relies on the `DOMContentLoaded` event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load`: If you pass this option, the `promise` will be resolved when the `load`
    event is fired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`networkidle0` will resolve the promise *when there are no more network connections
    for the past 500 ms*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`networkidle2` will resolve the promise *when there are no more than 2 network
    connections for the past 500 ms*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how these options work with a site full of content such as [https://shop.mango.com/gb](https://shop.mango.com/gb).
    We are going to see what content is ready, depending on which `waitUntil` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mango home page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Mango home page
  prefs: []
  type: TYPE_NORMAL
- en: 'The earliest option to be resolved is `DOMContentLoaded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DOM content loaded'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: DOM content loaded
  prefs: []
  type: TYPE_NORMAL
- en: 'That page is not ready at all. Does that mean that `DOMContentLoaded` is useless?
    Well, it is useless in this case. If you do the same with Wikipedia, the page
    is so straightforward that it will be ready to automate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DOM content loaded in Wikipedia'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: DOM content loaded in Wikipedia
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the Mango page. Waiting for the `load` event gives us all the
    content from the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Page after load'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Page after load
  prefs: []
  type: TYPE_NORMAL
- en: The background video is not there yet. And the subscribe popup didn't show up.
    But if we want to interact with the menu bar, use the login action, or test the
    cookies banner, the page is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be hard to find a page where `networkidle0` and `networkidle2` behave
    differently that you have to pick between one or the other. In this case, we''ll
    get an almost complete page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Page using networkidle0 and networkidle2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Page using networkidle0 and networkidle2
  prefs: []
  type: TYPE_NORMAL
- en: The video is not being played yet, so if you want to take screenshots or generate
    PDF files, as we will see in [*Chapter 7*](B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130),
    *Generating Content with Puppeteer*, this won't be enough. But we could say it's
    ready to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: So, which one is better? Should we play safe and use `networkidle0` all the
    time? Shouldn't that be the default then?
  prefs: []
  type: TYPE_NORMAL
- en: Here's where we need to find a balance. We could just wait 10 seconds between
    actions, and we wouldn't have any flaky tests. But, if you have 1,000 tests (remember,
    you will have over 1,000 tests) with 10 actions each, that would mean that the
    entire test suite would take almost 14 hours to run.
  prefs: []
  type: TYPE_NORMAL
- en: '*To reduce flakiness, we need to find a balance between waiting for too long
    and going too fast.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes getting the DOM from the server will be enough. If we were testing
    Wikipedia, our links would be ready for us on the `DOMContentLoaded` event. If
    we want to test our home page and we wait for `DOMContentLoaded`, images won't
    be ready yet, but we will get the stock and price values from the server. We don't
    need more than that.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the right `waitUntil` will make your code less flaky, but unless you
    test a simple site such as Wikipedia, that won't be enough.
  prefs: []
  type: TYPE_NORMAL
- en: The most effective way to make your code stable is by waiting for the element
    we want to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before acting on an element, you need to make sure of two things: first, that
    the element is there, it exists in the DOM; and second, you can act on that element.
    In other words, it''s visible to the user. Let''s see how we can wait for our
    element to be ready.'
  prefs: []
  type: TYPE_NORMAL
- en: You should wait for a selector after some kind of network call. You `goto` a
    page, wait for a selector, and then you act. You click on a button, wait for a
    selector, and then you act.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the selector you need to wait for is easy to find. On our login
    page, we need to wait for the user name input. In other cases, such as our home
    page, we would need to wait for the `div` element containing all the products.
    It's just a little bit more complicated but still straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we want to test Mango's newsletter popup? Maybe the pop-up HTML
    is on the page, but it's not visible. Here's where I start to consider waiting
    as a kind of art. It's not just about automating a page. It's not only about the
    tool. You need to find the right selectors to make your automation code stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two functions that will help us wait for elements: `waitForSelector`
    and `waitForXPath`. Both functions have a similar signature. `waitForSelector(selector,
    [options])` expects a CSS selector and an `options` object. `waitForXPath(XPath,
    [options])` expects an XPath expression and an `options` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the available properties you will be able to set in the `options`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timeout`: We will find this option in all wait functions. We don''t want our
    tests to get stuck. This is another cause of flaky tests. If the timeout is reached,
    the promise will be rejected. If we don''t pass a timeout, the function will use
    the timeout set using `page.setDefaultTimeout(timeout)`. If `setDefaultTimeout`
    wasn''t used, it will default to **30 seconds**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visible`: If `visible` is set to true, Puppeteer will not only check that
    the element exists in the DOM but that it is also visible. We would need to use
    that in our newsletter popup. This check won''t be performed by default. And,
    again, it''s something you might want to check or not, depending on your scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hidden`: If `hidden` is set to true, Puppeteer will check if the element is
    not visible or if the element is not in the DOM. This option is useful when you
    need to deal with loading animations. You know that the page is reading when the
    loading animation is hidden. [Twitter.com](http://Twitter.com) is a great example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Loading animation on Twitter.com'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Loading animation on Twitter.com
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `waitForSelector` and `waitForXPath` will return a promise that can resolve
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ElementHandle`: This element handle will be the element that eventually
    matches the CSS selector or the XPath.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null: When `hidden` is set to true, and the element was not found in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are four approaches to waiting for elements. It's not about which one
    is the best. These approaches will help you in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Await a wait function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find the code used in this section in the `stackoverflow.tests.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: If we go to Stack Overflow ([https://stackoverflow.com/questions](https://stackoverflow.com/questions)),
    we will find that there are job postings on the right of the page. But as we can
    see, that's loaded after the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing while loading and list once loaded'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Listing while loading and list once loaded
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to test that the page has a list of jobs by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could just grab the `LI` elements using `$$` and then check whether the
    list is empty or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Honestly, this will work most of the time using a decent network, but it could
    also get flaky. What we need to do is wait for the elements to be loaded before
    checking that list. What we could do is call the `waitForSelector` function before
    calling `$$`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned before, `waitForSelector` returns an `ElementHandle`. It uses`document.querySelector`.
    That's why we can't use the result of `waitForSelector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we wanted to check whether the title is `waitForSelector` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I think that's the second time I have used the `evaluate` function. Patience
    – that will come in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering why we didn't use the result of `waitForSelector`
    in the job listing example, it turns out that `waitForSelector` uses `document.querySelector`
    to evaluate the CSS expression. That will make `waitForSelector` return only one
    item.
  prefs: []
  type: TYPE_NORMAL
- en: The same happens with `waitForXpath`. Unlike `$x`, that returns an array of
    elements. `waitForXpath` will return only one element.
  prefs: []
  type: TYPE_NORMAL
- en: '`waitForSelector` and `waitForXPath` will save your day most of the time, but
    there are other scenarios we might want to consider. For instance, we might need
    to check network calls. We might want to wait for a request to be made or for
    a response to be received. Let''s see how to accomplish that.'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for network calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050), *Navigating
    through a website*, we talked about **requests** and **responses**. Every page
    navigation begins with a request to a page. The server then processes that request
    and sends a response. That response generally is an HTML page, which has resources
    declared that need to be requested. The server will process each of those requests
    again and send many responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that''s not all. Modern apps will send requests to the server based on
    user actions. Take *Google Maps*: the user moves the mouse, and the page will
    need to request a new picture of the map without reloading the entire page.'
  prefs: []
  type: TYPE_NORMAL
- en: We don't work on the *Google Maps* teams, but many users have reported that
    the home page sometimes doesn't load the product image after login. So, we could
    write a test to check that *it should load an image*. Oh… you thought we were
    going to test *Google Maps*? Not this time, sorry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can use `waitForResponse(urlOrPredicate, [options])`. Let''s
    unpack these arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`urlOrPredicate` can be a string with the URL we want to wait for. But it can
    also be a function. This should be a function expecting a response, which will
    be the response you will want to check and return a truthy value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only option we have in this function is `timeout`. This property has the
    same conditions as the one in `waitForSelector`: If not passed, Puppeteer will
    use `page.setDefaultTimeout(timeout)`, and if that function wasn''t used, the
    default will be 30 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's write our test. We need to log in and wait for the product image. To accomplish
    this, we are going to use the **Arrange, Act, Await** approach.
  prefs: []
  type: TYPE_NORMAL
- en: Arrange, Act, Await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This name comes from the arrange, act, assert pattern we talked about in [*Chapter
    4*](B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072), *Interacting with a page*.
  prefs: []
  type: TYPE_NORMAL
- en: With this pattern, we try to prevent **race conditions**, a common issue in
    async programming, and a cause of flakiness. A race condition in async programming
    is when you are trying to do two or more tasks simultaneously, and the speed of
    one task (too fast or too slow) causes another task to never complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take, for instance, this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, notice something. We are not using asserts. The fact that the `waitForResponse`
    promise resolves is enough for us to know that the test was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept here is that `waitForReponse` doesn't behave in the
    same way as `waitForSelector`. When we use `waitForSelector`, the function will
    resolve when the element we are waiting for is already in the DOM. But with `waitForResponse`,
    if the response we are waiting for has already happened, our `waitForResponse`
    will time out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code there has a risk of flakiness. If our server is too fast serving the
    page after login, the image might have already been served before we wait for
    it. To solve that, we need to get the promise first, and then await it. This is
    how we could change our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that instead of awaiting the promised returned by `waitForResponse`,
    we are assigning that promise to a variable. We call `waitForResponse`, we keep
    that promise, then we act (log in). After that, we await that promise, hoping
    that it will be resolved at one point after the login action is complete. You
    can find this test in the `login.tests.js` file. There, the test is called `Should
    load image after login`.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that we use `waitForResponse`, we can use `waitForRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: We would use `waitForRequest` instead of `waitForResponse` if we wanted to check
    whether the browser is sending a request to the server. As this function also
    expects a `predicate`, a function, as an argument, we can check not only for the
    URL but also the content of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we work at The Weather Channel ([https://weather.com/](https://weather.com/)).
    We want to check that the browser is sending our location. We found that the page
    is calling `redux-dal`. We want to wait for that request, parse the `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![The weather channel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: The weather channel
  prefs: []
  type: TYPE_NORMAL
- en: We are going to solve this using the **fire and forget** approach.
  prefs: []
  type: TYPE_NORMAL
- en: Fire and forget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find the code used in this section in the `weather.tests.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: We call it a "fire and forget" when we call a function that returns a promise
    but we don't await that promise, and we don't even care about the result of that
    promise. "Fire and forget" is a military term that refers to a type of missile
    that does not require further guidance after launch. In our case, our missiles
    are Promises that we launch, but we don't care about the outcome of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how a fire and forget approach would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are many new things to learn here.
  prefs: []
  type: TYPE_NORMAL
- en: We fire and forget the `goto` action. We call `goto`, but we don't wait for
    it to finish. Doing a fire and forget means that we won't care if the promise
    resolves or fails. In this case, we care about the `request` promise. If `goto`
    fails, the `waitForRequest` will fail, and the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second new feature we can see here is that we are waiting for a request
    using a predicate, a function that expects a request and returns a truthy value:
    `r => r.url().includes(''redux-dal'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we can learn here is that we are working with the request resolved
    by the `waitForRequest` promise. Once we get the request, we extract the payload
    using `postData`, parse it, and evaluate the content.
  prefs: []
  type: TYPE_NORMAL
- en: The last feature we have to handle network calls is `waitForNavigation`. Imagine
    `waitForNavigation` as the `goto` function without the URL argument. It's `waitForNavigation([options])`.
    The options are the same options `goto` has. We can use this function to wait
    for navigation triggered by one action we perform.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take, for example, the Packtpub site ([https://www.packtpub.com/](https://www.packtpub.com/)).
    We want to search for a book, press *Enter*, and wait for the page to be redirected
    to the results page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this test, we are going to use our fourth approach: `Promise.all`.'
  prefs: []
  type: TYPE_NORMAL
- en: Promise.all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find the code used in this section in the `packpub.tests.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the scenario, `Promise.all` could be a shortcut for Act, Arrange,
    Await. In fact, I would keep the latter for more complex scenarios and use `Promise.all`
    if I need to wait for two tasks at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test code would look like this with a `Promise.all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first part is pretty straightforward. We go to the site, get the search
    input, and type "Puppeteer." But then, we wait for two Promises in the same `await`
    statement. We wait for navigation to be completed and the `press` function.
  prefs: []
  type: TYPE_NORMAL
- en: Although it would be quite weird getting a race condition inside a `Promise.all`,
    I feel safer adding the `wait` function as the first argument of the `all` function.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Getting started with Puppeteer*, `Promise.all` will wait for all promises to
    finish. It will also resolve as soon as one promise fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know how to wait for elements and network calls. But let me tell you
    a little secret: `waitForRequest` and `waitForResponse` are just wrappers around
    the request and response events the page offers. Puppeteer would create a Promise,
    start listening to an event, and then resolve the Promise when a condition is
    met. The good news is that we can use this same approach to wait for many other
    events.'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for page events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events are messages that a class sends when something happens. As a consumer,
    you can `page-event-demos.js` file inside the `Chapter5` directory. To run that
    demo, you just need to run `node page-event-demos.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you could listen to responses without the `waitForResponse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we say that we want to listen to the `response` event, and
    when a new response arrives, we want to print the URL in the console. Then, we
    call the `goto` function, and all the responses will start being written in the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the arrow (`=>`) is a simple way to write single-line functions. But,
    if you open a bracket, you can write more complex functions, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to reuse a function, you can pass a function there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can create a function, assign it to a variable – in this
    case, `listenToImages` – and then pass it to the `page.on` function. If you pass
    a function, you will be able to remove that listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `removeListener` function will detach the `listenToImages` function from
    the `response` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more feature to add to your toolbox. You can listen to an event
    only once, using – you guessed it – `once`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`once` will attach your function to an event and remove it as soon as the first
    event arrives. Notice that `once` won''t evaluate the result of your function.
    You won''t be able to prevent `once` from removing your listener as soon as the
    first event arrives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try to make our own `waitForResponse` function. We will use the
    approach we mentioned in [*Chapter 1*](B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Getting started with Puppeteer*: *Fulfill our own promises*. We can create a
    promise, and then we will resolve it when the condition we are waiting for is
    met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we created a promise that will be resolved when the `resolve`
    function is called. Inside that function, we attached to the response event and,
    when the URL matched, we called `resolve` passing that response.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, using the `waitForResponse` function will be easier. But there
    are events that don't have a `waitFor` function, and you will need to use this
    approach to wait for them. Let's see what page events we have available.
  prefs: []
  type: TYPE_NORMAL
- en: The close event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `close` event is triggered when the page is closed. These days, it's not
    so common to have popups, mainly because they are not mobile-friendly. But we
    can still find some cases. For instance, when you want to add an account to your
    existing *Gmail* account.
  prefs: []
  type: TYPE_NORMAL
- en: '![Popup in Gmail'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Popup in Gmail
  prefs: []
  type: TYPE_NORMAL
- en: You will need to listen to that page's `close` event to know that the wizard
    process has finished.
  prefs: []
  type: TYPE_NORMAL
- en: But that leaves us with another question. How do you get to that page? If we
    are testing the *Gmail* page and click on the **Create account** link, how do
    we get the popup?
  prefs: []
  type: TYPE_NORMAL
- en: The popup event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The page will trigger a `popup` event when it opens a new tab or window. We
    could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One new thing we can learn here is that `promise.all` returns an array of all
    the responses. As we only care about the response of the first promise, we create
    an array with only one element `[newPage]`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to listen to new pages regardless of what triggered that new page,
    you can also listen to browser events.
  prefs: []
  type: TYPE_NORMAL
- en: Target created event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `targetcreated` event is triggered when a new target (page) is created
    inside the browser. We could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In most scenarios, this will work in the same way as the `popup` event. But
    it's good for you to know that you also have this tool available.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to page events.
  prefs: []
  type: TYPE_NORMAL
- en: The console event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `console` event will be triggered every time a new line is printed on the
    browser console. In the same way the `response` event gives us a `response` object
    with all the information, the `console` event will give us a message class with
    the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text()` with the text message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type(),` which will help us identify the type of the message. The most common
    types are: ''log'', ''debug'', ''info'', ''error,'' and ''warning''.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location()`, giving us the source of the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As `console.log` can expect objects as arguments, we can access those element
    handles with `args()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use this event to check that there are no JavaScript errors during the
    test.
  prefs: []
  type: TYPE_NORMAL
- en: The dialog event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dialog` event is important because dialogs stop the execution of a page.
    There are many types of dialogs, and each of them will require us to react differently.
    We can know the dialog type using the `type()` function. Let's take a look at
    the different dialog types and how we can react to them.
  prefs: []
  type: TYPE_NORMAL
- en: The alert type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Alert` is a dialog with only an `dialog.accept()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Alert](img/Figure_5.10_B16113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alert
  prefs: []
  type: TYPE_NORMAL
- en: Confirm type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Confirm` is a dialog with an `dialog.accept()` or `dialog.dismiss()` to cancel
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Confirm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Confirm
  prefs: []
  type: TYPE_NORMAL
- en: The prompt type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `prompt` dialog is not common these days. It''s like the `confirm` dialog
    but it prompts an input that you can pass by passing a string to the `accept`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prompt](img/Figure_5.12_B16113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prompt
  prefs: []
  type: TYPE_NORMAL
- en: The beforeunload type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will see `beforeunload` these days, asking you if you want to leave the
    site without saving your changes. It works as a `confirm` dialog. You can interact
    with this dialog in the same way you would interact with the `prompt` dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Before unload dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Before unload dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s wrap up this chapter with a new tool for our toolbox: **the headless
    recorder**.'
  prefs: []
  type: TYPE_NORMAL
- en: The headless recorder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The headless recorder is a Chrome extension developed by *Checkly* ([https://www.checklyhq.com/](https://www.checklyhq.com/)).
    This extension will record the actions you perform on a page and generate Puppeteer
    code based on those actions. I think it's a great tool to get a first draft of
    a Puppeteer test, and from there, start working on the final code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download this extension by going to the Chrome Web Store ([https://chrome.google.com/webstore](https://chrome.google.com/webstore))
    and searching for `Headless Recorder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Headless Recorder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Headless Recorder
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you will find a **recorder icon** at the top right of your
    browser. From there, you will have the **record button**, which will start to
    capture all the actions you perform on a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Record option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Record option
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you finish performing your test actions, you click **stop**, and you''ll
    get the code almost ready to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Headless Recorder result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Headless Recorder result
  prefs: []
  type: TYPE_NORMAL
- en: I say almost ready because the recorder can't guess your real intentions. It's
    just a guide. As you can see there are selectors such as `.mb-3:nth-child(1) >
    .thumbnail > .card-body > .row > .col-6 > .btn.` The recorder doesn't know what
    your intentions are behind clicking on a certain link. But it's a good start,
    and it can help you when your test requires many steps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the concept of flaky tests, and we saw many techniques
    and tools to prevent having flaky tests in our test suites.
  prefs: []
  type: TYPE_NORMAL
- en: While we were learning about these wait tools, we saw many page events without
    even noticing them. Now you can not only wait for selectors and network calls
    but you can also deal with dialogs and popups.
  prefs: []
  type: TYPE_NORMAL
- en: The last section was short, but as promised, we now have another tool in our
    toolbox, a headless recorder.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get into more advanced tools and learn how to execute
    JavaScript in the browser.
  prefs: []
  type: TYPE_NORMAL
