- en: Chapter 2. Mastering the Framework's Building Blocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 掌握框架的构建块
- en: The Ext JS class system forms the basis of the framework and provides us with
    an object-oriented structure to construct our applications. This chapter will
    introduce the fundamentals of the class system, and how we can use it to define
    the building blocks of our applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 类系统是框架的基础，为我们提供了一个面向对象的结构来构建我们的应用程序。本章将介绍类系统的基本原理，以及我们如何使用它来定义应用程序的构建块。
- en: 'We will discuss the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章讨论以下主题：
- en: How basic object-oriented principles, such as inheritance, are used
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本面向对象原则，如继承，是如何被使用的
- en: How to dynamically load our classes with the Ext.Loader class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Ext.Loader 类动态加载我们的类
- en: How to override class methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何覆盖类方法
- en: How to use Ext JS' configuration model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Ext JS 的配置模型
- en: Defining classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: 'Our application''s first class will be a configuration class to hold various
    options for our application. We define a class using the `Ext.define` method as
    shown here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第一个类将是一个配置类，用于存储我们应用程序的各种选项。我们使用 `Ext.define` 方法定义一个类，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first parameter is a string defining the class' name, the second, an object
    containing all the class' members, and the third is an optional callback function,
    executed when the class has been defined.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个定义类名的字符串，第二个参数是一个包含所有类成员的对象，第三个是一个可选的回调函数，当类被定义时执行。
- en: Class names must follow a strict naming convention so that they can be auto
    loaded by the `Ext.Loader` class. This class automatically loads classes when
    they are needed and uses their fully qualified name to find them within the directory
    structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类名必须遵循严格的命名约定，以便它们可以被 `Ext.Loader` 类自动加载。这个类在需要时自动加载类，并使用它们的完全限定名在目录结构中找到它们。
- en: The first part of our class name—`BizDash`—is our application's name and is
    our root namespace. This is mapped, by default, to the app folder inside our application
    folder.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们类名的第一部分——`BizDash`——是我们应用程序的名称，也是我们的根命名空间。默认情况下，它映射到我们应用程序文件夹内的 `app` 文件夹。
- en: The second part—`config`—is our class' subnamespace and is used to organize
    our classes into folders. This name maps to a subfolder inside the `app` folder.
    We can create namespaces to any depth we wish, to allow us to organize our code
    in a way that makes sense for the application.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分——`config`——是我们类的子命名空间，用于将我们的类组织到文件夹中。这个名称映射到 `app` 文件夹内的一个子文件夹。我们可以创建任何深度的命名空间，以便我们以对应用程序有意义的方式组织我们的代码。
- en: Finally, `Config` is the name of our class and forms the file name where our
    class definition will live.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`Config` 是我们类的名称，并形成了我们类定义将驻留的文件名。
- en: 'The following screenshot shows how our fully qualified class name equates to
    its directory structure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了我们的完全限定类名与其目录结构的关系：
- en: '![Defining classes](img/6626_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![定义类](img/6626_02_01.jpg)'
- en: The standard Sencha naming convention outlines that all subnamespaces should
    be lowercase, with all class names being upper camel case. For example, `BizDash.view.users.UserForm`
    is preferred over `BizDash.view.Users.userForm`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Sencha 命名约定规定，所有子命名空间都应该小写，所有类名都应该使用大驼峰式。例如，`BizDash.view.users.UserForm`
    优于 `BizDash.view.Users.userForm`。
- en: We will now instantiate this class using the `Ext.create` method. This method
    accepts a class' fully qualified name and an object whose properties and values
    will be used to configure the class. We will talk about how to add our own configuration
    options later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 `Ext.create` 方法实例化这个类。这个方法接受一个类的完全限定名和一个对象，该对象的属性和值将被用来配置这个类。我们将在本章后面讨论如何添加我们自己的配置选项。
- en: 'Open the application in a web browser and run the following code in the Developer
    Tools'' console:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开应用程序，并在开发者工具的控制台中运行以下代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Upon running the code, we should see a console similar to the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，我们应该看到一个类似于以下屏幕截图的控制台：
- en: '![Defining classes](img/6626_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![定义类](img/6626_02_02.jpg)'
- en: 'In the screenshot, we can see three things:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕截图中，我们可以看到三件事：
- en: The source file loaded into the page automatically via a `GET` request
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `GET` 请求自动加载到页面中的源文件
- en: The console log from the `Ext.define` callback
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 `Ext.define` 回调的控制台日志
- en: Our new class instance logged in the console
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新类实例在控制台中记录
- en: You will have noticed that we were able to instantiate our `BizDash.config.Config`
    class without ever referencing it in our application or HTML page. This is taken
    care of by the magic of the `Ext.Loader` class, which we will talk about next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们能够在不在我们的应用程序或HTML页面中引用它的情况下实例化我们的`BizDash.config.Config`类。这是由`Ext.Loader`类的魔法处理的，我们将在下一节中讨论。
- en: The magic behind Ext.Loader
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext.Loader背后的魔法
- en: In the last section, we saw an example of how class source files can be automatically
    loaded into the application as and when they are needed. This is taken care of
    by the `Ext.Loader` class, which analyzes the dependencies of each class defined
    and ensures every reliant class is loaded in via AJAX. For more details on how
    this relates to creating production builds, see the *Creating our application
    with Sencha Cmd* section of [Chapter 1](ch01.html "Chapter 1. Getting to Know
    Ext JS"), *Getting to Know Ext JS*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一个例子，说明了类源文件如何根据需要自动加载到应用程序中。这是由`Ext.Loader`类处理的，它分析每个类的依赖关系，并确保所有依赖的类都通过AJAX加载。有关如何将此与创建生产构建相关联的更多详细信息，请参阅[第1章](ch01.html
    "第1章。了解Ext JS")的*使用Sencha Cmd创建我们的应用程序*部分，*了解Ext JS*。
- en: The class definition process
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类的定义过程
- en: 'The following diagram shows the process of how a class is defined, starting
    with the `Ext.define` method call, and how the `Loader` class fits into this process:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了类定义的过程，从调用`Ext.define`方法开始，以及`Loader`类如何融入这一过程：
- en: '![The class definition process](img/6626_02_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![类的定义过程](img/6626_02_03.jpg)'
- en: Defining dependencies
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义依赖项
- en: The best way to ensure that all necessary classes have loaded into the page
    is to build a dependency tree using the `requires` configuration option. This
    option accepts an array of fully qualified class names, which are then all loaded
    into the page before the class definition is deemed complete. Upon loading a dependent
    class, the process is repeated with the new class where all of its dependencies
    are loaded until all required classes are present.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有必要的类都已加载到页面上的最佳方式是使用`requires`配置选项构建一个依赖关系树。此选项接受一个完全限定的类名数组，然后所有这些类名在类定义被认为完成之前都加载到页面中。在加载一个依赖类后，这个过程会重复进行，新类及其所有依赖项都会被加载，直到所有所需的类都存在。
- en: 'We can extend our `Config` class by introducing a dependency in a new class
    called `BizDash.config.Constants`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在新的类`BizDash.config.Constants`中引入一个依赖项来扩展我们的`Config`类：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We want our `Config` class to make use of this class, so we must ensure it
    is available to be instantiated when the class is defined. We do this by adding
    the `requires` configuration to the class definition, telling the framework to
    load it in automatically:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的`Config`类能够使用这个类，因此我们必须确保在定义类时它能够被实例化。我们通过在类定义中添加`requires`配置来实现这一点，告诉框架自动加载它：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this line in place, we can use `Ext.create` to instantiate our class again
    and see the `Constants` class being loaded in automatically:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行设置后，我们可以使用`Ext.create`再次实例化我们的类，并看到`Constants`类被自动加载：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Defining dependencies](img/6626_02_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![定义依赖项](img/6626_02_04.jpg)'
- en: Loader paths
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Loader路径
- en: By default, the root namespace of an app (in our case `BizDash`) is mapped to
    the `app` folder. This means that any subnamespace is mapped directly to a folder
    inside the `app` folder and the class name to the JavaScript file itself. It is
    important to keep to these naming conventions so that these source files can be
    found.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，应用程序的根命名空间（在我们的案例中是`BizDash`）映射到`app`文件夹。这意味着任何子命名空间直接映射到`app`文件夹内的一个文件夹，类名映射到JavaScript文件本身。保持这些命名约定非常重要，以便可以找到这些源文件。
- en: If you want to have the application load files from a different location, you
    can specify a custom path and namespace convention for the loader to follow, by
    adding a call to the `Ext.Loader.setConfig` method to the top of your `Application.js`
    file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望应用程序从不同的位置加载文件，您可以通过在`Application.js`文件的顶部添加对`Ext.Loader.setConfig`方法的调用，为加载器指定一个自定义路径和命名空间约定。
- en: 'The default `paths` object map `Ext` and the application namespace, as the
    following snippet shows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`paths`对象将`Ext`和应用程序命名空间映射，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can customize this by adding your own namespace as the key (this can be
    more than one portion of a namespace; for example, `Custom.namespace`), and the
    path to the correct folder as the value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加自己的命名空间作为键（这可以是一个命名空间的多个部分；例如，`Custom.namespace`），以及正确的文件夹路径作为值来自定义它：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ext.Loader and Sencha Cmd
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext.Loader和Sencha Cmd
- en: As we have seen, Sencha Cmd can concatenate all the required class files into
    a single file. This is achieved by producing this dependency graph and combining
    all the source files in the order that they are loaded when launching the application.
    This ensures that only the classes that are actually used are included in the
    application's final source file, making it much smaller than if the entire framework
    were always included.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Sencha Cmd可以将所有所需的类文件连接成一个单一的文件。这是通过生成这个依赖图并按应用程序启动时加载的顺序组合所有源文件来实现的。这确保了只有实际使用的类被包含在应用程序的最终源文件中，使其比始终包含整个框架小得多。
- en: Our dependency root
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的依赖根
- en: In our examples, we have forced our `Config` to be loaded via the `Ext.create`
    call, which synchronously loads the source file. By relying on this to load class
    files, the dependency tree is only established and fulfilled during runtime. This
    will mean Sencha Cmd will be unable to create a fully concatenated source file
    and will be forced to load missing classes at runtime.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们通过`Ext.create`调用强制加载了`Config`配置，这会同步加载源文件。通过依赖这种方式来加载类文件，依赖树仅在运行时建立和满足。这意味着Sencha
    Cmd将无法创建一个完全连接的源文件，并且将被迫在运行时加载缺失的类。
- en: To combat this, we should include our root classes as required classes in the
    `Application.js` file. This file is the entry point for the application, so from
    here we can establish the dependency graph all the way to the extremities, before
    the app is launched.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该在`Application.js`文件中将我们的根类作为所需的类包含在内。此文件是应用程序的入口点，因此从这里我们可以建立依赖图，直到应用程序启动前的极端部分。
- en: 'To ensure our `BizDash.config.Config` class is loaded and ready for use upon
    application launch, we would add it inside a `requires` array in the `Application.js`
    file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的`BizDash.config.Config`类在应用程序启动时加载并准备好使用，我们会在`Application.js`文件中的`requires`数组中添加它：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding class members
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类成员
- en: So far, we have looked at defining and creating classes and getting these classes
    loaded into our page. We will now explore how to make them useful by adding class
    members such as properties, methods, and statics.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了定义和创建类以及将这些类加载到我们的页面中的方法。现在，我们将探讨如何通过添加类成员（如属性、方法和静态成员）使它们变得有用。
- en: Properties
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Public properties can be added to a class by including a key-value pair to
    the class'' definition object. The following code example shows how we add a version
    number property to our `Config` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在类的定义对象中包含一个键值对来向类中添加公共属性。以下代码示例展示了我们如何向我们的`Config`类添加一个版本号属性：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This property can be accessed by simply using the dot notation in an instance
    of the `Config` class; for example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性可以通过在`Config`类的一个实例中使用点符号来访问；例如：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Methods
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'Methods can be added in an identical way to properties. We can add a `getBuildNumber`
    method to the `Config` class, which will extract the build number from the version
    property, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以与属性相同的方式添加方法。我们可以在`Config`类中添加一个`getBuildNumber`方法，它将从版本属性中提取构建号，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method can be executed in the normal way:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以按正常方式执行：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that by default, the methods are executed in the scope of the class instance,
    allowing us to access the version property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，方法是在类实例的作用域中执行的，这使得我们可以访问版本属性。
- en: Statics
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员
- en: The Ext JS class system provides us with the ability to include static properties
    and methods to our classes to remove the need to create class instances. These
    can be added inside an object assigned to the `statics` configuration option.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS类系统为我们提供了在类中包含静态属性和方法的能力，以消除创建类实例的需要。这些可以在分配给`statics`配置选项的对象内部添加。
- en: 'The following example shows a static property called `ENVIRONMENT` added to
    the `BizDash.config.Constants` class to track if we are in a development or production
    environment:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了添加到`BizDash.config.Constants`类的名为`ENVIRONMENT`的静态属性，用于跟踪我们是否处于开发或生产环境：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now access this static property using the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下代码访问这个静态属性：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ext JS' naming conventions says that static property names should always be
    in uppercase.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS的命名约定指出，静态属性名称应该始终为大写。
- en: Statics in subclasses
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类中的静态成员
- en: If you would like your class' static properties to be available in any subclasses,
    then they must be defined using the `inheritableStatics` property.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望类的静态属性在所有子类中可用，则必须使用`inheritableStatics`属性来定义。
- en: Singletons
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: 'As an alternative to using static methods, classes can be defined as singletons,
    which will, after successful definition, instantiate the class and assign it back
    to the class property. This can be done by simply adding the `singleton: true`
    configuration to the class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '作为使用静态方法的替代，可以将类定义为单例，在成功定义后，将实例化类并将其分配回类的属性。这可以通过简单地给类添加 `singleton: true`
    配置来实现：'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The logging of the `isInstance` property, which is available in all class instances,
    shows that once defined, the `BizDash.config.Config` property is now an instance
    of the class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有类实例中都存在的 `isInstance` 属性的记录显示，一旦定义，`BizDash.config.Config` 属性现在成为了该类的一个实例。
- en: Extending classes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类
- en: The Ext JS framework's architecture means the functionality is built up and
    shared using inheritance. It is extremely easy to have one of our custom classes
    or views inherit from another or from an existing framework class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 框架的架构意味着功能是通过继承构建和共享的。让我们的自定义类或视图继承另一个或现有的框架类变得极其容易。
- en: For example, when defining your view classes, you will likely extend from the
    base `Ext.Component` class or from one of its subclasses, such as `Ext.panel.Panel`
    or `Ext.grid.Panel`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当定义您的视图类时，您可能会从基础 `Ext.Component` 类或其子类之一扩展，例如 `Ext.panel.Panel` 或 `Ext.grid.Panel`。
- en: 'We define our class'' superclass by including the `extend` configuration and
    giving it the name of the class to extend. In the following example, we will extend
    our `Config` class from the `Ext.util.Observable` class, allowing it to raise
    its own custom events. This will give our `Config` class access to all of the
    methods and properties of this class, such as the `on` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过包含 `extend` 配置并给出要扩展的类的名称来定义我们类的超类。在以下示例中，我们将从 `Ext.util.Observable` 类扩展我们的
    `Config` 类，使其能够触发自己的自定义事件。这将使我们的 `Config` 类能够访问这个类的所有方法和属性，例如 `on` 方法：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Ext JS documentation shows the inheritance tree of each class at the top
    right of its documentation page, as shown here, for the `Ext.panel.Panel` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 文档在其文档页面的右上角显示了每个类的继承树，如下所示，对于 `Ext.panel.Panel` 类：
- en: '![Extending classes](img/6626_02_05.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![扩展类](img/6626_02_05.jpg)'
- en: When omitted, as in our original `Config` class, the class will extend from
    the `Ext.Base` class by default, which is the root base class for all of the framework's
    classes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当省略时，就像我们原始的 `Config` 类一样，类将默认从 `Ext.Base` 类扩展，这是所有框架类的基础基类。
- en: Overriding classes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖类
- en: It is sometimes necessary to change the functionality of a class without directly
    modifying the original source. We can do this by defining a new class along with
    the `overrides` configuration option to tell Ext JS which class to modify.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时有必要在不直接修改原始源的情况下更改类的功能。我们可以通过定义一个新的类以及 `overrides` 配置选项来告诉 Ext JS 要修改哪个类。
- en: This technique should always be used when altering the framework behavior (for
    example, to fix a bug in the framework's code) as the Ext JS code should never
    be modified directly. This will come back to bite you when making framework upgrades
    in the future.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当改变框架行为时（例如，修复框架代码中的错误）应始终使用这种技术，因为 Ext JS 代码不应直接修改。当未来进行框架升级时，这可能会给你带来麻烦。
- en: In the following example, we will override our `getBuildNumber` method so that
    it returns the build number with a prefix of **Build Number:**. You will have
    seen that Sencha Cmd has already created an `overrides` folder in our application
    structure. This is where we will put our class override files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将覆盖我们的 `getBuildNumber` 方法，使其返回带有前缀 **Build Number:** 的构建号。您可能已经看到
    Sencha Cmd 已经在我们的应用程序结构中创建了一个 `overrides` 文件夹。这就是我们将放置我们的类覆盖文件的地方。
- en: Inside this folder, we create a new `config` directory to mirror our main app
    folder structure and define a new class named `Overrides.config.Config` in a file
    called `Config.js`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹内，我们创建一个新的 `config` 目录来映射我们的主应用文件夹结构，并在一个名为 `Config.js` 的文件中定义一个新的名为 `Overrides.config.Config`
    的类。
- en: '![Overriding classes](img/6626_02_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖类](img/6626_02_06.jpg)'
- en: 'The `override` follows the same structure as a normal class definition, as
    shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`override` 的结构与正常的类定义相同，如下所示：'
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now add in our override for the `getBuildNumber` method, which uses
    the `callParent` method to execute the original method and combine its output
    with our label:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加对 `getBuildNumber` 方法的覆盖，该方法使用 `callParent` 方法来执行原始方法，并将其输出与我们的标签结合：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Requiring our override class
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要我们的覆盖类
- en: 'There is one extra step required to include this override in our app and for
    the changes to take effect. We must tell the application where our override classes
    reside so `Ext.Loader` knows where to find them. We do this by adding the `overrides`
    path to our `sencha.cfg` file so that Sencha Cmd can update the app''s dependencies.
    We do this by adding the following line to the bottom of the `BizDash/.sencha/app/sencha.cfg`
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此覆盖包含到我们的应用程序中并使更改生效，我们需要告诉应用程序我们的覆盖类所在的位置，以便`Ext.Loader`知道在哪里找到它们。我们通过向`sencha.cfg`文件中添加`overrides`路径来实现，这样Sencha
    Cmd就可以更新应用程序的依赖项。我们通过在`BizDash/.sencha/app/sencha.cfg`文件的底部添加以下行来完成此操作：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can then run the `sencha app refresh` command from within the `BizDash` folder
    to regenerate the app's bootstrap files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`BizDash`文件夹内运行`sencha app refresh`命令来重新生成应用的引导文件。
- en: 'If we now reload our application and call the `getBuildNumber` method, we should
    see the output as **Build Number: 0**.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在重新加载我们的应用程序并调用`getBuildNumber`方法，我们应该看到输出为**构建号：0**。
- en: '![Requiring our override class](img/6626_02_07.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![要求我们的覆盖类](img/6626_02_07.jpg)'
- en: Although this override is overriding one of our own custom methods, an identical
    process can be followed to override any of the framework's own classes whose behavior
    you would like to change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个覆盖正在覆盖我们自己的自定义方法之一，但可以遵循相同的过程来覆盖任何您想要更改行为的框架自己的类。
- en: Targeting overrides to framework versions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对框架版本进行覆盖
- en: 'It is now possible to target overrides to specific framework or package versions
    by using the compatibility configuration. This can accept a single string containing
    a version number, an array of version strings that will be matched with an OR
    operator, or an object using the `and` or `or` keys to create more complex matches.
    The following examples show how these can be used:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用兼容性配置来针对特定的框架或包版本进行覆盖。这可以接受一个包含版本号的单一字符串，一个将使用逻辑或运算符匹配版本字符串的数组，或者一个使用`and`或`or`键来创建更复杂匹配的对象。以下示例显示了如何使用这些：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the compatibility option is a match, then the override is included; otherwise
    it is not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果兼容性选项匹配，则包含覆盖；否则不包含。
- en: For full details of what version expressions can be used, see the documentation
    on the `Ext.checkVersion` method. [http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可以使用哪些版本表达式的详细信息，请参阅`Ext.checkVersion`方法的文档。[http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion)。
- en: Configuring classes
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置类
- en: Ext JS offers us a useful way of creating configurable properties, which gives
    us an autogenerated process to get and set their values, and also to perform any
    updates required in other areas; for example, reflecting the updated value in
    the UI.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS提供了一种创建可配置属性的有用方法，它为我们提供了一个自动生成的过程来获取和设置它们的值，并且还可以执行在其他区域中所需的任何更新；例如，在UI中反映更新值。
- en: When a class is defined, any properties found in the `config` object become
    completely encapsulated from other class members and are given their own getter
    and setter methods.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被定义时，在`config`对象中找到的任何属性将完全封装在其他类成员之外，并且会为其提供自己的获取器和设置器方法。
- en: For example, if we move our `Config` class' `version` property into a `config`
    object, as shown in the following code snippet, the class will be given two new
    methods named `getVersion` and `setVersion`. Notice that we must create a `constructor`
    function and call the `initConfig` method to have the class system initialize
    these new methods. We also must update our `getBuildNumber` method, which references
    the version number using `this.version`, to use the new getter method `getVersion`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将`Config`类的`version`属性移动到`config`对象中，如以下代码片段所示，类将获得两个新方法，分别命名为`getVersion`和`setVersion`。请注意，我们必须创建一个`constructor`函数并调用`initConfig`方法，以便类系统初始化这些新方法。我们还必须更新我们的`getBuildNumber`方法，该方法使用`this.version`引用版本号，改为使用新的获取器方法`getVersion`。
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In Ext JS 5, the call to `initConfig` is now not required when extending the
    `Ext.Component` class or one of its subclasses, as it is called internally.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 5中，当扩展`Ext.Component`类或其子类时，现在不需要调用`initConfig`，因为它是在内部调用的。
- en: Setting a configuration value
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置配置值
- en: When giving the `config` option a new value, the generated setter method goes
    through a more complex process than just assigning the given value to a property
    in the class. It introduces the concept of `applier` and `updater` methods, which
    are optional and, if present, called in turn within the setter method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当给 `config` 选项赋予新值时，生成的设置器方法比仅仅将给定的值分配给类中的属性要复杂得多。它引入了 `applier` 和 `updater`
    方法的概念，这些方法是可选的，如果存在，则按顺序在设置器方法中调用。
- en: The applier function should be named with the same convention as the getter
    and setter, with the name being prefixed with `apply` and the property name's
    first letter in uppercase; for example, `applyVersion`. This method is used to
    transform the given value as required before it is stored in the class. Potential
    usage may be to perform a lookup of the value to get its real instance (for example,
    a store instance from its ID). This method must return a value; otherwise the
    property won't be updated.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应用器函数应使用与获取器和设置器相同的约定命名，名称前缀为 `apply`，属性名称的首字母大写；例如，`applyVersion`。此方法用于在将值存储在类中之前按需转换给定的值。可能的用法可能包括查找值以获取其实例（例如，从其
    ID 获取存储实例）。此方法必须返回一个值；否则属性将不会被更新。
- en: The updater function follows the same naming pattern (for example, `updateVersion`)
    and is called after the value has been transformed with the applier and set in
    the class. This function is primarily used to update the UI to reflect the latest
    value within a component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更新器函数遵循相同的命名模式（例如，`updateVersion`），并在值经过应用器转换并在类中设置后调用。此函数主要用于更新 UI 以反映组件内的最新值。
- en: 'The following diagram shows how this process works when calling the generated
    setter method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了在调用生成的设置器方法时此过程是如何工作的：
- en: '![Setting a configuration value](img/6626_02_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![设置配置值](img/6626_02_08.jpg)'
- en: 'The following example shows how we use and apply the method to ensure the format
    of the version number; and an update method to raise a custom event, allowing
    other areas of the app to be notified of the change:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何使用和应用此方法以确保版本号的格式；以及一个更新方法来触发自定义事件，允许应用的其他区域通知变化：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Overriding defaults
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖默认值
- en: 'The default values given to configuration properties can be easily overridden
    when a new class instance is created, by simply adding the property and the desired
    value to the configuration object passed to the `Ext.create` method. The following
    snippet shows the version option being set (assuming the `Config` class wasn''t
    set to be a singleton):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新的类实例时，可以通过简单地将属性和所需值添加到传递给 `Ext.create` 方法的配置对象中来轻松覆盖配置属性的默认值。以下代码片段显示了如何设置版本选项（假设
    `Config` 类没有被设置为单例）：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Platform-specific configs
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台特定配置
- en: Ext JS 5 introduces the ability to configure a class differently based on the
    platform the application is being run on, so we can tailor the experience based
    on the platform's capabilities.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5 引入了根据应用程序运行的平台配置类的不同能力的能力，因此我们可以根据平台的能力定制体验。
- en: This is done by using the `platformConfig config` option, giving it an array
    of configuration objects. These configuration options must contain a platform
    property, which will be used to find the appropriate config to use on the current
    platform.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用 `platformConfig config` 选项来完成的，给它一个配置对象数组。这些配置选项必须包含一个平台属性，该属性将用于在当前平台上找到适当的配置。
- en: 'This option should contain an array of strings describing the platform the
    config should target. This can be one or more of the following options: phone,
    tablet, desktop, iOS, Android, Blackberry, Safari, Chrome, or IE10.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项应包含一个字符串数组，描述配置应针对的平台。这可以是一个或多个以下选项：手机、平板、桌面、iOS、Android、Blackberry、Safari、Chrome
    或 IE10。
- en: If any of these platforms match the current one, then the other properties will
    be merged into the class configuration. It is possible that multiple rules will
    evaluate to true, in which case the properties of all matched rules will be applied.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些平台中的任何一个与当前平台匹配，则其他属性将合并到类配置中。可能存在多个规则评估为真，在这种情况下，所有匹配规则的性质都将应用。
- en: 'The following code shows how we can configure our `Config` class differently
    based on the platform:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何根据平台配置我们的 `Config` 类：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then access these properties using their getter methods. The following
    code, run on a laptop, will output `true` for the `isDesktop` property and `false`
    for the other two:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它们的getter方法访问这些属性。以下代码在笔记本电脑上运行，将输出`true`给`isDesktop`属性，对于其他两个属性输出`false`：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we have covered all aspects of the Ext JS class system, including:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了Ext JS类系统的所有方面，包括：
- en: Defining and instantiating classes
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和实例化类
- en: Adding properties, methods, and statics
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加属性、方法和静态成员
- en: Extending other classes and overriding the framework behavior
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展其他类和覆盖框架行为
- en: Configuring classes and making use of applier and updater methods
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置类并使用应用器和更新器方法
- en: We have also demonstrated how to ensure our class files are loaded into our
    application when needed, using the `Ext.Loader` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还演示了如何使用`Ext.Loader`类确保我们的类文件在需要时被加载到应用程序中。
- en: The next chapter will discuss how Ext JS handles events, originating both from
    user input and from other classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论Ext JS如何处理事件，这些事件既来自用户输入，也来自其他类。
