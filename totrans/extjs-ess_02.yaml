- en: Chapter 2. Mastering the Framework's Building Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ext JS class system forms the basis of the framework and provides us with
    an object-oriented structure to construct our applications. This chapter will
    introduce the fundamentals of the class system, and how we can use it to define
    the building blocks of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How basic object-oriented principles, such as inheritance, are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to dynamically load our classes with the Ext.Loader class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to override class methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Ext JS' configuration model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application''s first class will be a configuration class to hold various
    options for our application. We define a class using the `Ext.define` method as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is a string defining the class' name, the second, an object
    containing all the class' members, and the third is an optional callback function,
    executed when the class has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Class names must follow a strict naming convention so that they can be auto
    loaded by the `Ext.Loader` class. This class automatically loads classes when
    they are needed and uses their fully qualified name to find them within the directory
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of our class name—`BizDash`—is our application's name and is
    our root namespace. This is mapped, by default, to the app folder inside our application
    folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part—`config`—is our class' subnamespace and is used to organize
    our classes into folders. This name maps to a subfolder inside the `app` folder.
    We can create namespaces to any depth we wish, to allow us to organize our code
    in a way that makes sense for the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `Config` is the name of our class and forms the file name where our
    class definition will live.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows how our fully qualified class name equates to
    its directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining classes](img/6626_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The standard Sencha naming convention outlines that all subnamespaces should
    be lowercase, with all class names being upper camel case. For example, `BizDash.view.users.UserForm`
    is preferred over `BizDash.view.Users.userForm`.
  prefs: []
  type: TYPE_NORMAL
- en: We will now instantiate this class using the `Ext.create` method. This method
    accepts a class' fully qualified name and an object whose properties and values
    will be used to configure the class. We will talk about how to add our own configuration
    options later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the application in a web browser and run the following code in the Developer
    Tools'' console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running the code, we should see a console similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining classes](img/6626_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the screenshot, we can see three things:'
  prefs: []
  type: TYPE_NORMAL
- en: The source file loaded into the page automatically via a `GET` request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The console log from the `Ext.define` callback
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new class instance logged in the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will have noticed that we were able to instantiate our `BizDash.config.Config`
    class without ever referencing it in our application or HTML page. This is taken
    care of by the magic of the `Ext.Loader` class, which we will talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: The magic behind Ext.Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we saw an example of how class source files can be automatically
    loaded into the application as and when they are needed. This is taken care of
    by the `Ext.Loader` class, which analyzes the dependencies of each class defined
    and ensures every reliant class is loaded in via AJAX. For more details on how
    this relates to creating production builds, see the *Creating our application
    with Sencha Cmd* section of [Chapter 1](ch01.html "Chapter 1. Getting to Know
    Ext JS"), *Getting to Know Ext JS*.
  prefs: []
  type: TYPE_NORMAL
- en: The class definition process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the process of how a class is defined, starting
    with the `Ext.define` method call, and how the `Loader` class fits into this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The class definition process](img/6626_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to ensure that all necessary classes have loaded into the page
    is to build a dependency tree using the `requires` configuration option. This
    option accepts an array of fully qualified class names, which are then all loaded
    into the page before the class definition is deemed complete. Upon loading a dependent
    class, the process is repeated with the new class where all of its dependencies
    are loaded until all required classes are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend our `Config` class by introducing a dependency in a new class
    called `BizDash.config.Constants`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We want our `Config` class to make use of this class, so we must ensure it
    is available to be instantiated when the class is defined. We do this by adding
    the `requires` configuration to the class definition, telling the framework to
    load it in automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this line in place, we can use `Ext.create` to instantiate our class again
    and see the `Constants` class being loaded in automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Defining dependencies](img/6626_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Loader paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the root namespace of an app (in our case `BizDash`) is mapped to
    the `app` folder. This means that any subnamespace is mapped directly to a folder
    inside the `app` folder and the class name to the JavaScript file itself. It is
    important to keep to these naming conventions so that these source files can be
    found.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to have the application load files from a different location, you
    can specify a custom path and namespace convention for the loader to follow, by
    adding a call to the `Ext.Loader.setConfig` method to the top of your `Application.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default `paths` object map `Ext` and the application namespace, as the
    following snippet shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can customize this by adding your own namespace as the key (this can be
    more than one portion of a namespace; for example, `Custom.namespace`), and the
    path to the correct folder as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Ext.Loader and Sencha Cmd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, Sencha Cmd can concatenate all the required class files into
    a single file. This is achieved by producing this dependency graph and combining
    all the source files in the order that they are loaded when launching the application.
    This ensures that only the classes that are actually used are included in the
    application's final source file, making it much smaller than if the entire framework
    were always included.
  prefs: []
  type: TYPE_NORMAL
- en: Our dependency root
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our examples, we have forced our `Config` to be loaded via the `Ext.create`
    call, which synchronously loads the source file. By relying on this to load class
    files, the dependency tree is only established and fulfilled during runtime. This
    will mean Sencha Cmd will be unable to create a fully concatenated source file
    and will be forced to load missing classes at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To combat this, we should include our root classes as required classes in the
    `Application.js` file. This file is the entry point for the application, so from
    here we can establish the dependency graph all the way to the extremities, before
    the app is launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure our `BizDash.config.Config` class is loaded and ready for use upon
    application launch, we would add it inside a `requires` array in the `Application.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding class members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at defining and creating classes and getting these classes
    loaded into our page. We will now explore how to make them useful by adding class
    members such as properties, methods, and statics.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Public properties can be added to a class by including a key-value pair to
    the class'' definition object. The following code example shows how we add a version
    number property to our `Config` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This property can be accessed by simply using the dot notation in an instance
    of the `Config` class; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can be added in an identical way to properties. We can add a `getBuildNumber`
    method to the `Config` class, which will extract the build number from the version
    property, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This method can be executed in the normal way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that by default, the methods are executed in the scope of the class instance,
    allowing us to access the version property.
  prefs: []
  type: TYPE_NORMAL
- en: Statics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ext JS class system provides us with the ability to include static properties
    and methods to our classes to remove the need to create class instances. These
    can be added inside an object assigned to the `statics` configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a static property called `ENVIRONMENT` added to
    the `BizDash.config.Constants` class to track if we are in a development or production
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now access this static property using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Ext JS' naming conventions says that static property names should always be
    in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Statics in subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you would like your class' static properties to be available in any subclasses,
    then they must be defined using the `inheritableStatics` property.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an alternative to using static methods, classes can be defined as singletons,
    which will, after successful definition, instantiate the class and assign it back
    to the class property. This can be done by simply adding the `singleton: true`
    configuration to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The logging of the `isInstance` property, which is available in all class instances,
    shows that once defined, the `BizDash.config.Config` property is now an instance
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ext JS framework's architecture means the functionality is built up and
    shared using inheritance. It is extremely easy to have one of our custom classes
    or views inherit from another or from an existing framework class.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when defining your view classes, you will likely extend from the
    base `Ext.Component` class or from one of its subclasses, such as `Ext.panel.Panel`
    or `Ext.grid.Panel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define our class'' superclass by including the `extend` configuration and
    giving it the name of the class to extend. In the following example, we will extend
    our `Config` class from the `Ext.util.Observable` class, allowing it to raise
    its own custom events. This will give our `Config` class access to all of the
    methods and properties of this class, such as the `on` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ext JS documentation shows the inheritance tree of each class at the top
    right of its documentation page, as shown here, for the `Ext.panel.Panel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending classes](img/6626_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When omitted, as in our original `Config` class, the class will extend from
    the `Ext.Base` class by default, which is the root base class for all of the framework's
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes necessary to change the functionality of a class without directly
    modifying the original source. We can do this by defining a new class along with
    the `overrides` configuration option to tell Ext JS which class to modify.
  prefs: []
  type: TYPE_NORMAL
- en: This technique should always be used when altering the framework behavior (for
    example, to fix a bug in the framework's code) as the Ext JS code should never
    be modified directly. This will come back to bite you when making framework upgrades
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will override our `getBuildNumber` method so that
    it returns the build number with a prefix of **Build Number:**. You will have
    seen that Sencha Cmd has already created an `overrides` folder in our application
    structure. This is where we will put our class override files.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this folder, we create a new `config` directory to mirror our main app
    folder structure and define a new class named `Overrides.config.Config` in a file
    called `Config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overriding classes](img/6626_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `override` follows the same structure as a normal class definition, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add in our override for the `getBuildNumber` method, which uses
    the `callParent` method to execute the original method and combine its output
    with our label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Requiring our override class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one extra step required to include this override in our app and for
    the changes to take effect. We must tell the application where our override classes
    reside so `Ext.Loader` knows where to find them. We do this by adding the `overrides`
    path to our `sencha.cfg` file so that Sencha Cmd can update the app''s dependencies.
    We do this by adding the following line to the bottom of the `BizDash/.sencha/app/sencha.cfg`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can then run the `sencha app refresh` command from within the `BizDash` folder
    to regenerate the app's bootstrap files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now reload our application and call the `getBuildNumber` method, we should
    see the output as **Build Number: 0**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Requiring our override class](img/6626_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although this override is overriding one of our own custom methods, an identical
    process can be followed to override any of the framework's own classes whose behavior
    you would like to change.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting overrides to framework versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is now possible to target overrides to specific framework or package versions
    by using the compatibility configuration. This can accept a single string containing
    a version number, an array of version strings that will be matched with an OR
    operator, or an object using the `and` or `or` keys to create more complex matches.
    The following examples show how these can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the compatibility option is a match, then the override is included; otherwise
    it is not.
  prefs: []
  type: TYPE_NORMAL
- en: For full details of what version expressions can be used, see the documentation
    on the `Ext.checkVersion` method. [http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext-method-checkVersion).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ext JS offers us a useful way of creating configurable properties, which gives
    us an autogenerated process to get and set their values, and also to perform any
    updates required in other areas; for example, reflecting the updated value in
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is defined, any properties found in the `config` object become
    completely encapsulated from other class members and are given their own getter
    and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we move our `Config` class' `version` property into a `config`
    object, as shown in the following code snippet, the class will be given two new
    methods named `getVersion` and `setVersion`. Notice that we must create a `constructor`
    function and call the `initConfig` method to have the class system initialize
    these new methods. We also must update our `getBuildNumber` method, which references
    the version number using `this.version`, to use the new getter method `getVersion`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In Ext JS 5, the call to `initConfig` is now not required when extending the
    `Ext.Component` class or one of its subclasses, as it is called internally.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a configuration value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When giving the `config` option a new value, the generated setter method goes
    through a more complex process than just assigning the given value to a property
    in the class. It introduces the concept of `applier` and `updater` methods, which
    are optional and, if present, called in turn within the setter method.
  prefs: []
  type: TYPE_NORMAL
- en: The applier function should be named with the same convention as the getter
    and setter, with the name being prefixed with `apply` and the property name's
    first letter in uppercase; for example, `applyVersion`. This method is used to
    transform the given value as required before it is stored in the class. Potential
    usage may be to perform a lookup of the value to get its real instance (for example,
    a store instance from its ID). This method must return a value; otherwise the
    property won't be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The updater function follows the same naming pattern (for example, `updateVersion`)
    and is called after the value has been transformed with the applier and set in
    the class. This function is primarily used to update the UI to reflect the latest
    value within a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how this process works when calling the generated
    setter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting a configuration value](img/6626_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows how we use and apply the method to ensure the format
    of the version number; and an update method to raise a custom event, allowing
    other areas of the app to be notified of the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Overriding defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default values given to configuration properties can be easily overridden
    when a new class instance is created, by simply adding the property and the desired
    value to the configuration object passed to the `Ext.create` method. The following
    snippet shows the version option being set (assuming the `Config` class wasn''t
    set to be a singleton):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Platform-specific configs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ext JS 5 introduces the ability to configure a class differently based on the
    platform the application is being run on, so we can tailor the experience based
    on the platform's capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by using the `platformConfig config` option, giving it an array
    of configuration objects. These configuration options must contain a platform
    property, which will be used to find the appropriate config to use on the current
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'This option should contain an array of strings describing the platform the
    config should target. This can be one or more of the following options: phone,
    tablet, desktop, iOS, Android, Blackberry, Safari, Chrome, or IE10.'
  prefs: []
  type: TYPE_NORMAL
- en: If any of these platforms match the current one, then the other properties will
    be merged into the class configuration. It is possible that multiple rules will
    evaluate to true, in which case the properties of all matched rules will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we can configure our `Config` class differently
    based on the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access these properties using their getter methods. The following
    code, run on a laptop, will output `true` for the `isDesktop` property and `false`
    for the other two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered all aspects of the Ext JS class system, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining and instantiating classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding properties, methods, and statics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending other classes and overriding the framework behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring classes and making use of applier and updater methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also demonstrated how to ensure our class files are loaded into our
    application when needed, using the `Ext.Loader` class.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will discuss how Ext JS handles events, originating both from
    user input and from other classes.
  prefs: []
  type: TYPE_NORMAL
