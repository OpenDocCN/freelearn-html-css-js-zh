- en: '*Chapter 1*: Getting started with Puppeteer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I remember the first time I heard about browser automation. A friend told me
    that their QA team was testing using "automation." That sounded magical to me.
    People testing websites using "automation." After a few years, I learned that
    automation wasn't a magic potion, but instead a powerful tool not only for QA
    but also for developers, because we developers love to automate stuff, right?
  prefs: []
  type: TYPE_NORMAL
- en: That's why in the first part of this chapter, I want to show you how browser
    automation works and what makes Puppeteer unique. In the latter part of this chapter,
    we are going to review some asynchronous techniques that are going to be useful
    throughout the rest of the book, and throughout your automation journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is browser automation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing headless browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppeteer use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first Puppeteer code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is browser automation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go and look for the word "automation" in Wikipedia, it will tell you
    that it is *"a process or procedure performed with minimal human assistance."*
    If you are a developer, or just a geek, I bet you love to create scripts to automate
    tasks. You might also create environment variables, so you don't have to type
    long paths, or even create cool Git commands, so you don't need to remember all
    the steps required to create a new branch upstream.
  prefs: []
  type: TYPE_NORMAL
- en: When I got my first Mac, I discovered an app called Automator. I fell in love
    with it. You can automate tasks and connect applications just using drag and drop.
    If you use macOS and you've never played with Automator, please give it a try!
    But Automator isn't the only app. There are many workflow apps in the market,
    such as Hazel or Alfred.
  prefs: []
  type: TYPE_NORMAL
- en: Automation is even in the cloud and is available to the general public. Apps
    such as IFTTT and Zapier allow users to automate everyday tasks. You can create
    automations such as "When I post on Instagram, share the same image on Twitter,"
    all from your phone. Regular people doing automation, that's great!
  prefs: []
  type: TYPE_NORMAL
- en: We also have mail rules. Most mail clients, even web clients, let you create
    rules, so you can mark emails as read, label them, or even remove them based on
    conditions. That's also automation.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you've taken it to the next level and coded an application for some of
    your daily tasks. You have that report that you need to send to your boss every
    month. That report is the result of many CSV files. You just wrote a tiny app,
    using your favorite language to make that report for you.
  prefs: []
  type: TYPE_NORMAL
- en: In a few words, automation means using an app to do a repetitive task for us.
    And as we have seen, it doesn't necessarily involve coding that app. So now, we
    can say that **browser automation is telling an app to do a repetitive task in
    the browser for us**.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, that's a simple statement. But how's that possible? When you automate an
    app, you accomplish this using some kind of **application program interface**
    (**API**). For example, when you write a bat/bash file, you use the command-line
    arguments as an interface. If you use IFTTT, it employs Twitter's and Instagram's
    HTTP APIs to fetch images and create tweets. You need some kind of API, some way
    to interact with the app you are trying to automate. How are we supposed to interact
    with the browser? Good question.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a little bit more complicated, we also need to consider that
    we have two apps to automate: the browser itself and the website. We don''t want
    just to open a browser, create a new tab, and navigate to a page. We also want
    to go to that page and perform some actions. We want to click on a button, or
    enter some text in an input element.'
  prefs: []
  type: TYPE_NORMAL
- en: Automating a browser sounds challenging. But, luckily for us, we have some brilliant
    people who did an excellent job for us and created tools such as Selenium and
    Puppeteer.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium and Puppeteer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A quick search on Google will show that Selenium is one of the top, if not
    *the* top, UI testing tool on the market. I think a question many people would
    ask is: **Why should I choose Puppeteer over Selenium? Which one is better?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to know is that Puppeteer was not created to compete
    with Selenium. Selenium is a cross-language, cross-browser testing tool, whereas
    Puppeteer was created as a multi-purpose automation tool to exploit all the power
    of Chromium. I think both are great automation tools, but they tackle browser
    automation in two different ways. They are different in two important aspects
    that define the target audience of a browser automation library:'
  prefs: []
  type: TYPE_NORMAL
- en: The interface between the tool and the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface between the tool and the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first unpack how Selenium works.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium's approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to automate most browsers in the market, Selenium wrote a spec (an
    API) called **WebDriver**, which the W3C then accepted as a standard ([https://www.hardkoded.com/ui-testing-with-puppeteer/webdriver](https://www.hardkoded.com/ui-testing-with-puppeteer/webdriver)),
    and asked the browsers to implement that interface. Selenium will use this WebDriver
    API to interact with the browser. If you take a look at the paper at the preceding
    URL, you will find two words showing up over and over: **testing** and **simplicity**.
    In other words, they defined an API with a clear focus on testing and simplicity
    and asked the browsers to implement that interface. Cross-browser testing is,
    in my opinion, the main feature of Selenium.'
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs: []
  type: TYPE_NORMAL
- en: An API is the set of classes, functions, properties, and events that a library
    allows us to use. An API is critical for a library's success because it will determine
    how much you can do with it and how easy (or not) the interaction will be with
    the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API that Selenium exposes to users is also considered a part of the WebDriver
    spec, and it follows the same philosophy: it''s focused on testing and simplicity.
    This API provides a layer of abstraction between the user and all the different
    browsers and provides an interface that will easily help the developer write tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer's approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Puppeteer doesn't need to think in terms of cross-browser support. Although
    there are some efforts to run Puppeteer on Firefox, the focus is on grabbing all
    the developer tools that Chromium has and making them available to the user. With
    this goal in mind, Puppeteer can access way more tools than those exposed by the
    WebDriver API that Selenium uses.
  prefs: []
  type: TYPE_NORMAL
- en: The difference in how they communicate with the browser is also reflected in
    the APIs. Puppeteer provides an API that will help us take advantage of all the
    power of Chromium. I think it's important to highlight that Puppeteer was created
    in JavaScript, so the API will feel more natural than Selenium's, which comes
    from a cross-language philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer doesn't need to ask anybody to implement the API because it takes
    advantage of the headless capability of Chromium. Let's now see what headless
    browsers are.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Headless browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a headless browser? No, it's not something from a horror movie. **A
    headless browser is a browser that you can launch and interact with using a particular
    protocol over a particular communication transport, with no UI involved**. This
    means that you will have one active process (or many processes, as we know how
    browsers are these days), but there will be no "window" for you to interact with
    the browser. I think that "windowless browser" would have been a more accurate
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Available headless browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both Chromium and Firefox support headless browser mode. It''s important to
    mention that, at the time of writing this book, Firefox''s headless mode was still
    experimental. That might sound bad, compared with the six browsers Selenium offers
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers](https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers)),
    but, as you might have noticed, I didn''t say Chrome, I said Chromium. Chromium
    is the engine Chrome uses under the hood. But Chrome is not the only browser using
    Chromium; in the past few years, many browsers have started to use the chromium
    engine. These are a few examples of chromium-based browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Edge, a.k.a. Edgium, to avoid confusion with the previous version
    of Microsoft Edge based on Trident
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s much better. We can automate at least five browsers. But there are
    two major browsers with no headless support: Microsoft Internet Explorer and Safari.
    The case of Safari is interesting. In the same way that Chromium is the engine
    behind Chrome, Webkit is the engine of Safari and, although Safari doesn''t support
    headless mode, there are a few Webkit builds created for testing purposes with
    headless support. Microsoft Playwright has its own Webkit build to support cross-browser
    automation.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you want to see a headless browser for the very first time?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have Chrome installed, grab the full path of the executable and pass
    these command arguments: `--headless --remote-debugging-port=9222 --crash-dumps-dir=/tmp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are a macOS user, the Chrome executable will be inside the "`Google
    Chrome.app`" pseudo-file. As you can see, it''s: "`Google Chrome.app/Contents/MacOS/Google
    Chrome`".'
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing that command, you should get something like this in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a headless chrome browser waiting for commands through a WebSocket
    on `ws://127.0.0.1:9222`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firefox also provides a headless mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't say much, but trust me, now we have a Firefox browser running in
    headless mode.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, a headless browser doesn't have a UI. The only way to
    interact with the browser is to use the transport the browser created, in this
    case, a WebSocket, and to send messages using some kind of protocol. In the case
    of Chromium and Firefox, it's the Chromium DevTools Protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The Chromium DevTools Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are a web developer, I''m 100% sure you have used Chrome DevTools. If
    you don''t know what I''m talking about, you can open DevTools by clicking on
    the three dots button in the top-right corner, and then go to `More Tools > Developer
    Tools`. You will get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.01_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Chrome DevTools
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s impressive all the things you can accomplish using this fantastic tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate CSS styles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See network calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the good news is that it's the **Chromium Developer Protocol** (which we'll
    call **CDP** from now on) that drives most of the DevTools' features. And that
    same CDP is the protocol that headless browsers use to interact with the outside
    world.
  prefs: []
  type: TYPE_NORMAL
- en: CDP sounds perfect. We can interact with the browser and do all the things I
    have mentioned. You can create a Node.JS app to launch a browser and start sending
    CDP messages through a WebSocket, but that would be quite complex and hard to
    maintain. That's where Puppeteer comes to the rescue and offers a human-friendly
    interface to interact with the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Puppeteer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Puppeteer is nothing more, and nothing less, than a Node.js package that knows
    how to open a browser, send commands, and react to messages coming from that browser.
    At the time of writing this book, Puppeteer supports Chromium and Firefox, but
    Firefox support is still considered experimental. I think it's a good time for
    you to go to the Puppeteer repository ([https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-repo](https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-repo))
    and check whether things have changed since then.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some community projects that implement Puppeteer in other languages.
    You will find Puppeteer-Sharp ([https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-sharp](https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-sharp))
    for .NET or Pyppeteer ([https://www.hardkoded.com/ui-testing-with-puppeteer/pypeteer](https://www.hardkoded.com/ui-testing-with-puppeteer/pypeteer))
    for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use Puppeteer, you are, in fact, using more than just a JavaScript
    library. Many people call this the "Puppeteer pyramid":'
  prefs: []
  type: TYPE_NORMAL
- en: '![ The Puppeteer pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.02_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: The Puppeteer pyramid
  prefs: []
  type: TYPE_NORMAL
- en: 'The Puppeteer pyramid consists of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: The headless browser is the engine that will run the pages we want to automate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chromium DevTools Protocol allows any external user to interact with the
    browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppeteer provides a JavaScript API to interact with the browser using the CDP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What I find valuable about Puppeteer is that its model clearly represents the
    browser structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The Puppeteer object model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Puppeteer Model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.03_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer Model
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what these objects represent inside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Browser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The browser is the main class. It's the object created when Puppeteer connects
    to a browser. The keyword here is **connect**. The browser that Puppeteer will
    use can be launched by Puppeteer itself. But it could also be a browser that is
    already running on your local machine, or it could even be a browser running in
    the cloud, like Browserless.io ([https://www.hardkoded.com/ui-testing-with-puppeteer/browserless](https://www.hardkoded.com/ui-testing-with-puppeteer/browserless)).
  prefs: []
  type: TYPE_NORMAL
- en: Browser context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A browser can contain more than one context. A context is a browser session
    (not to be confused with a browser window). The best example is the Incognito
    Mode or private mode, depending on the browser, which creates an isolated session
    inside the same browser process.
  prefs: []
  type: TYPE_NORMAL
- en: Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A page is a tab in a browser or even a pop-up page.
  prefs: []
  type: TYPE_NORMAL
- en: Frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The frame object is more important than it looks. Every page has at least one
    frame, which is called the main frame. Most of the page actions we will learn
    across this book are, in fact, a call to the main frame; for example, `page.click`
    calls `mainframe.click`.
  prefs: []
  type: TYPE_NORMAL
- en: The frame is a tree. One page has only one main frame, but a frame can contain
    many child frames.
  prefs: []
  type: TYPE_NORMAL
- en: Worker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A worker is a model that interacts with Web Workers. This is not a feature we
    will talk about in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Execution context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The execution context is a mechanism Chromium uses to isolate the page from
    the browser extensions. Each frame will have its own execution context. Internally,
    all the frame functions that involve executing JavaScript code will use an execution
    context to run the code inside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: There are other objects involved, such as `ElementHandles` and `JSHandles`,
    but we are going to talk about them later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know some of the differences between Selenium and Puppeteer, it's
    a perfect moment to review many possible use cases for Puppeteer.
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, the main difference between Puppeteer and Selenium is that Selenium
    is designed for end-to-end testing. In contrast, Puppeteer is designed as an API
    to exploit all the power of the DevTools, which means that besides end-to-end
    tests, there are also other use cases where you can use Puppeteer, as we will
    see now.
  prefs: []
  type: TYPE_NORMAL
- en: Task Automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many things we do on the web that you can automate. For example, you
    can download a report, fill in a form, or check flight prices. You might also
    want to check your website's health, monitor its performance, or check whether
    your website is working correctly. In [*Chapter 6*](B16113_06_Final_SK_ePub.xhtml#_idTextAnchor104)*,
    Executing and Injecting JavaScript*, we will see how to use Checkly to monitor
    your website in production.
  prefs: []
  type: TYPE_NORMAL
- en: Web Scraping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most library authors won't like to say that you can use their library to do
    web scraping. Web Scraping has a reputation for being illegal. But in [*Chapter
    9*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156)*, Scraping tools*, we will
    see how to do web scraping in the right way, without getting banned or sued.
  prefs: []
  type: TYPE_NORMAL
- en: Content generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generating content is not a use case that would come to your mind if you had
    to think about possible use cases. But Puppeteer is a great tool for generating
    two kinds of content:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screenshots**: Why would you need to take screenshots using an app? Think
    about thumbnails or previews. Imagine you want to create a paywall, showing part
    of your website content but as a blurred image. You could use Puppeteer to take
    a screenshot of your site, blur it, and use that image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PDF files**: Invoices are a great example of PDF generation. Imagine you
    have an e-commerce site. When the user makes a purchase, you show them a nice,
    well-designed invoice, but you need to send them that exact invoice by email.
    You could use Puppeteer to navigate to that invoice page and print it to PDF.
    You could also use your landing page to generate a PDF and use it as a brochure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130), *Generating
    Content with Puppeteer*, we will talk about this use case and how to use screenshots
    to write UI regression tests.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I think Puppeteer is great for testing modern web apps because it's close to
    the browser. The API feels great, modern, and is designed for the JavaScript developer.
    It lets you execute JavaScript code easily and gives you access to all the power
    of Chromium. But I also have to say that Selenium's tolling for end-to-end testing
    is impressive. Puppeteer is not even close to what Selenium offers with its Selenium
    Grid. It's up to you to decide which is the right tool for you.
  prefs: []
  type: TYPE_NORMAL
- en: Enough with the theory. It's time to get started and set up our environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's good about Node.js and Puppeteer is that they are cross-platform. My
    local environment is macOS Catalina 10.15.6\. But you won't see much difference
    if you use a Windows or a Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: Time is a tech book's worst enemy. At the time of writing this book, I was using
    Node.JS 12.18.3 and Puppeteer 7\. I'm pretty sure that by the time you read this
    book, new versions will have come to light. But don't feel discouraged about that;
    we expect that to happen. That's why I encourage you to go now and take a look
    at the GitHub repository of this book ([https://github.com/PacktPublishing/ui-testing-with-Puppeteer](https://github.com/PacktPublishing/ui-testing-with-Puppeteer)).
    If you see that something is not working or has changed, please create an issue
    on that repository. We will try to keep it updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need two things to run our first Puppeteer code: Node.JS and Puppeteer.
    Let''s begin with Node.JS.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purposes of this book, the only thing you need to know about Node.js
    is that it's a runtime that allows us to run JavaScript code outside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to highlight that the website we want to automate doesn't necessarily
    need to run on Node.js. You wouldn't need to know the language used to write the
    website, nor the platform that the website is running, but if you get to know
    those details, that could give you some ideas to write better automation code.
    For instance, if you know that the site is an ASP.NET Webforms project, you will
    know that it uses some hidden inputs to perform postbacks. That becomes more evident
    if you know the client-side frameworks, such as Vue or React.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned before, we will install Node.JS v12.18.3 (or higher). The process
    is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the official site: [https://nodejs.org/](https://nodejs.org/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the LTS version. **LTS** stands for **Long-Term Support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the installer as you would typically do on your platform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Node.js setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.04_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js setup
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see whether the installation was successful, you can open a
    terminal and execute `node --version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't need any special code editor to write a Node.js app. But Visual Studio
    Code is a great editor. It's free, cross-platform, and you can use it not only
    to code JavaScript, but also to code in many other languages as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download it at [https://code.visualstudio.com/](https://code.visualstudio.com/).
    It doesn''t even require running a setup on macOS. It''s just an app you copy
    to your `Applications` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.05_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Node.js installed along with a code editor, we can create our
    first app.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Puppeteer code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first need to create a folder where our `hello-puppeteer` project will be
    located. I''m going to use a terminal, but you can use whatever you feel more
    comfortable with. Our project will be called `hello-puppeteer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to initialize this brand-new node.js application. We create new
    applications in node.js using the `npm init` command. In this case, we will pass
    the `-y` argument, so it creates our app using default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This output doesn''t say much. It shows us that it has created a `package.json`
    file with some default values. Now, I will create an `index.js` file using the
    `touch` command. Again, you can perform this action in the way you feel most comfortable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Touch should have created the entry point of our app. But before coding our
    app, we need to install Puppeteer.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Puppeteer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most frameworks, if not all of them, have a way to publish and reuse components
    from different authors. The most popular package manager in Node.js is `npm init`
    to create our app. As Puppeteer is a package published in NPM, we can download
    and install it using the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t want to jump between apps, you can open a terminal inside Visual
    Studio Code. If you are still in the terminal, you can open Visual Studio Code
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That will open Visual Studio Code. Once there, you will be able to launch a
    new terminal from the **Terminal** menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terminal inside Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.06_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal inside Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'After opening a terminal, we can install Puppeteer using `npm install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I would like to highlight two things here. As this book is based on `@">=7.0.0
    <8.0.0"`, which means that we want the latest Puppeteer version greater than or
    equal to `7.0.0` and less than version `8.0.0`. By forcing this version to be
    used, you will be able to follow the examples in this chapter using the same version
    I used.
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer versioning
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer follows the **Semantic Versioning Specification** (**SemVer**) to
    version their releases, which means that those three numbers in the version follow
    a rule. A change in the major number (the first number) means that there was a
    breaking change in the API. When a package changes the major number, it tells
    you that the new version might break your code. A change in the minor number (the
    second number) means that they added new functionality, maintaining backward compatibility.
    Lastly, a change in the patch number means that they fixed a bug, maintaining
    backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: If you see that Puppeteer is in version 8, 9, or 10, it doesn't mean that this
    book is now obsolete. It means that they changed something that broke someone
    else's code. For instance, the change from version 6 to version 7 was just some
    change they made in the way they take screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: In real life, you can use the latest version available. And second, you might
    have noticed that the package downloaded a specific version of Chromium, in this
    case, `r848005`. That doesn't mean that your code won't work with any version
    of Chromium you download from the internet. But, remember, Puppeteer interacts
    with the browser using the Chrome DevTools Protocol, so it needs a version of
    Chromium that reacts in the way Puppeteer expects. In the case of Puppeteer v7.0.1,
    it needs Chromium 90.0.4403.0, and there is no guarantee that any other version
    of Chromium (newer or older) would work with your current Puppeteer version. It
    doesn't mean that it won't work. It means that it's not guaranteed. You need to
    experiment and see. You can check which chromium version you should use for every
    version of Puppeteer on the API page ([https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api](https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api)).
  prefs: []
  type: TYPE_NORMAL
- en: Hello world in Puppeteer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every language has its own hello world program. Puppeteer''s hello world program
    would be navigating to [https://en.wikipedia.org/wiki/%22Hello,_World!%22_program](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program)
    and taking a screenshot of the page. Let''s see what it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we are doing in this small script:'
  prefs: []
  type: TYPE_NORMAL
- en: We import the Puppeteer library using `require`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch a new browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new page (tab) inside that browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the Wikipedia page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I love how simple and easy it is to get started with Puppeteer. It''s now time
    to run it. Using the same terminal you used to run `npm install`, now run `node
    index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A Chromium browser opened, navigated to Wikipedia, and closed by itself. You
    didn''t see it because it was a headless browser, but it happened. Now, if you
    check your working directory, you should have a new file called `screenshot.png`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.07_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Screenshot
  prefs: []
  type: TYPE_NORMAL
- en: Our code worked as expected. We got our screenshot from Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: I bet you noticed that we used four **awaits** in our small hello puppeteer
    example. Asynchronous programming plays a big role in Puppeteer. Let's now talk
    about asynchronous programming in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, a program runs synchronously, which means that each line of code
    is executed one after the other. Let''s take, for instance, these two lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Those two lines will run in order. The result of `3 + 4` will be assigned to
    the `x` constant, and then the variable `x` will be printed on the screen using
    `console.log`. The `console.log` function can't start until `x` is assigned.
  prefs: []
  type: TYPE_NORMAL
- en: But there are tasks, such as network requests, disk access, or any other I/O
    operation, that are time-consuming, and we don't necessarily want to wait for
    those tasks to finish to keep executing our code. For instance, we could start
    downloading a file, perform other tasks while that file is loading, and then check
    that file when the download is completed. Asynchronous programming will allow
    us to execute those long-running tasks without blocking our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'An asynchronous function returns a **Promise** immediately to avoid blocking
    your code while waiting for a task. This Promise is an object that can be in one
    of the following three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending**: This means that the asynchronous task is still in progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fulfilled**: This means that the asynchronous task was completed successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected**: This means that the asynchronous task has failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say that we have a function called `downloadAFileFromTheInternet`. The
    most common way to wait for a task to finish is to use the `await` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to highlight that the `await` keyword here is not waiting for
    the function itself; it is waiting for the `Promise` returned by that function.
    That means that you can also assign that `Promise` to a variable and `await` it
    later in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can just not wait for the promise at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you want to learn more about asynchronous JavaScript, check out the *Asynchronous
    JavaScript Deep Dive* videos by Steven Hancock ([https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665](https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppeteer relies on asynchronous programming techniques because the communication
    between Puppeteer and Chrome DevTools is asynchronous. After all, the communication
    between Chrome DevTools and the browser is asynchronous. Think about what would
    happen under the hood when you click a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Click timeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.08_B16113.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Click timeline
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call `page.click`, the result of that action is not immediate. As
    we saw, there are many things going on under the hood. When you call `page.click`,
    you will need to do one of the things mentioned previously: await it; keep the
    promise in a variable and await it later; or don''t await it at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about asynchronous programming, I would like to review
    five utilities that we will use across the book.
  prefs: []
  type: TYPE_NORMAL
- en: Promise.all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Promise.all` is a function that expects an array of promises and returns a
    promise that will be **resolved** when **all** the promises are **fulfilled or
    rejected**. Yes, a promise could be fulfilled, completed successfully, or rejected,
    which means it failed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common scenario is clicking on a link, and waiting for the page to navigate
    to the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This promise will wait for the link to `click` and the `waitForNavigation` promises
    to be either fulfilled or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Promise.race
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like `Promise.all`, `Promise.race` expects an array of promises, but in this
    case, it will resolve when **any** of the promises are resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical usage is for timeouts. We want to take a screenshot, but only if
    it takes less than 2 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the `screenshot` promise takes more than 2,000 milliseconds,
    the promise created as the second element in the array will be **rejected**, rejecting
    the Promise.
  prefs: []
  type: TYPE_NORMAL
- en: Fulfilling our own promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You saw in our previous example how you can create a promise, return that Promise
    or assign it to a variable, and then fulfill it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great when you want to wait for an event to happen. We can create a
    promise that will be resolved when the page closes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This kind of `await` is quite risky. If the Promise is never fulfilled, your
    code will hang. I recommend using these promises with `Promise.race` and timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: We will see lots of promises throughout this book. Maybe some recipes such as
    "fulfill our own promises" look odd now, but we will use them a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot in this first chapter. We learned about browser automation
    and the difference between Selenium and Puppeteer. Then we saw that Puppeteer
    isn't limited only to end-to-end testing and reviewed some use case scenarios.
    Then we got our hands dirty and coded our first Puppeteer script. In the last
    section of the chapter, we covered many asynchronous techniques that we will use
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to focus on end-to-end testing. We will review
    some tools available on the market and will consider how to organize our code
    to create reliable end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
