- en: '*Chapter 1*: Getting started with Puppeteer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：Puppeteer入门'
- en: I remember the first time I heard about browser automation. A friend told me
    that their QA team was testing using "automation." That sounded magical to me.
    People testing websites using "automation." After a few years, I learned that
    automation wasn't a magic potion, but instead a powerful tool not only for QA
    but also for developers, because we developers love to automate stuff, right?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得第一次听说浏览器自动化。一个朋友告诉我，他们的QA团队正在使用“自动化”进行测试。这对我来说听起来很神奇。人们使用“自动化”测试网站。几年后，我了解到自动化并不是一种魔法药水，而是一种强大的工具，不仅适用于QA，也适用于开发者，因为我们开发者喜欢自动化，对吧？
- en: That's why in the first part of this chapter, I want to show you how browser
    automation works and what makes Puppeteer unique. In the latter part of this chapter,
    we are going to review some asynchronous techniques that are going to be useful
    throughout the rest of the book, and throughout your automation journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在本章的第一部分，我想向你展示浏览器自动化是如何工作的，以及是什么让Puppeteer独一无二。在本章的后半部分，我们将回顾一些将在本书的其余部分以及你的自动化之旅中非常有用的异步技术。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is browser automation?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器自动化是什么？
- en: Introducing headless browsers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍无头浏览器
- en: Puppeteer use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppeteer用例
- en: Setting up the environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Our first Puppeteer code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个Puppeteer代码
- en: Asynchronous programming in JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的异步编程
- en: What is browser automation?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器自动化是什么？
- en: If you go and look for the word "automation" in Wikipedia, it will tell you
    that it is *"a process or procedure performed with minimal human assistance."*
    If you are a developer, or just a geek, I bet you love to create scripts to automate
    tasks. You might also create environment variables, so you don't have to type
    long paths, or even create cool Git commands, so you don't need to remember all
    the steps required to create a new branch upstream.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去维基百科上查找“自动化”这个词，它会告诉你它是指“一种需要最小人工辅助的过程或程序”。如果你是开发者，或者只是一个极客，我敢打赌你喜欢编写脚本来自动化任务。你也许还会创建环境变量，这样你就不必输入长的路径，甚至创建酷炫的Git命令，这样你就不需要记住创建新分支所需的所有步骤。
- en: When I got my first Mac, I discovered an app called Automator. I fell in love
    with it. You can automate tasks and connect applications just using drag and drop.
    If you use macOS and you've never played with Automator, please give it a try!
    But Automator isn't the only app. There are many workflow apps in the market,
    such as Hazel or Alfred.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次得到我的Mac时，我发现了一个名为Automator的应用程序。我爱上了它。你可以通过拖放来自动化任务和连接应用程序。如果你使用macOS并且从未玩过Automator，请尝试一下！但Automator并不是唯一的应用程序。市场上有很多工作流应用程序，例如Hazel或Alfred。
- en: Automation is even in the cloud and is available to the general public. Apps
    such as IFTTT and Zapier allow users to automate everyday tasks. You can create
    automations such as "When I post on Instagram, share the same image on Twitter,"
    all from your phone. Regular people doing automation, that's great!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化甚至存在于云中，并且对公众开放。例如，IFTTT和Zapier这样的应用程序允许用户自动化日常任务。你可以创建自动化任务，比如“当我发布在Instagram上时，在Twitter上分享相同的图片”，这一切都可以通过你的手机完成。普通人进行自动化，这真是太棒了！
- en: We also have mail rules. Most mail clients, even web clients, let you create
    rules, so you can mark emails as read, label them, or even remove them based on
    conditions. That's also automation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有邮件规则。大多数邮件客户端，甚至是网页客户端，都允许你创建规则，这样你就可以根据条件标记邮件为已读，给它们贴标签，甚至删除它们。这也是自动化的一种。
- en: Maybe you've taken it to the next level and coded an application for some of
    your daily tasks. You have that report that you need to send to your boss every
    month. That report is the result of many CSV files. You just wrote a tiny app,
    using your favorite language to make that report for you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经将它提升到了下一个层次，为你的日常任务编写了一个应用程序。你有一个每月需要发送给老板的报告。这个报告是许多CSV文件的结果。你只是写了一个小程序，使用你喜欢的语言为你生成这个报告。
- en: In a few words, automation means using an app to do a repetitive task for us.
    And as we have seen, it doesn't necessarily involve coding that app. So now, we
    can say that **browser automation is telling an app to do a repetitive task in
    the browser for us**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，自动化意味着使用一个应用程序为我们执行重复性任务。正如我们所看到的，这并不一定涉及到编写该应用程序的代码。因此，现在我们可以这样说，**浏览器自动化就是告诉应用程序为我们自动在浏览器中执行重复性任务**。
- en: Ok, that's a simple statement. But how's that possible? When you automate an
    app, you accomplish this using some kind of **application program interface**
    (**API**). For example, when you write a bat/bash file, you use the command-line
    arguments as an interface. If you use IFTTT, it employs Twitter's and Instagram's
    HTTP APIs to fetch images and create tweets. You need some kind of API, some way
    to interact with the app you are trying to automate. How are we supposed to interact
    with the browser? Good question.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a little bit more complicated, we also need to consider that
    we have two apps to automate: the browser itself and the website. We don''t want
    just to open a browser, create a new tab, and navigate to a page. We also want
    to go to that page and perform some actions. We want to click on a button, or
    enter some text in an input element.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Automating a browser sounds challenging. But, luckily for us, we have some brilliant
    people who did an excellent job for us and created tools such as Selenium and
    Puppeteer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Selenium and Puppeteer
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A quick search on Google will show that Selenium is one of the top, if not
    *the* top, UI testing tool on the market. I think a question many people would
    ask is: **Why should I choose Puppeteer over Selenium? Which one is better?**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to know is that Puppeteer was not created to compete
    with Selenium. Selenium is a cross-language, cross-browser testing tool, whereas
    Puppeteer was created as a multi-purpose automation tool to exploit all the power
    of Chromium. I think both are great automation tools, but they tackle browser
    automation in two different ways. They are different in two important aspects
    that define the target audience of a browser automation library:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The interface between the tool and the browser
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface between the tool and the user
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first unpack how Selenium works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Selenium's approach
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to automate most browsers in the market, Selenium wrote a spec (an
    API) called **WebDriver**, which the W3C then accepted as a standard ([https://www.hardkoded.com/ui-testing-with-puppeteer/webdriver](https://www.hardkoded.com/ui-testing-with-puppeteer/webdriver)),
    and asked the browsers to implement that interface. Selenium will use this WebDriver
    API to interact with the browser. If you take a look at the paper at the preceding
    URL, you will find two words showing up over and over: **testing** and **simplicity**.
    In other words, they defined an API with a clear focus on testing and simplicity
    and asked the browsers to implement that interface. Cross-browser testing is,
    in my opinion, the main feature of Selenium.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: An API is the set of classes, functions, properties, and events that a library
    allows us to use. An API is critical for a library's success because it will determine
    how much you can do with it and how easy (or not) the interaction will be with
    the library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The API that Selenium exposes to users is also considered a part of the WebDriver
    spec, and it follows the same philosophy: it''s focused on testing and simplicity.
    This API provides a layer of abstraction between the user and all the different
    browsers and provides an interface that will easily help the developer write tests.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium向用户暴露的API也被视为WebDriver规范的一部分，它遵循相同的理念：专注于测试和简洁。这个API在用户和所有不同的浏览器之间提供了一个抽象层，并为开发者提供了一个易于使用的接口，以帮助他们编写测试。
- en: Puppeteer's approach
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Puppeteer的方法
- en: Puppeteer doesn't need to think in terms of cross-browser support. Although
    there are some efforts to run Puppeteer on Firefox, the focus is on grabbing all
    the developer tools that Chromium has and making them available to the user. With
    this goal in mind, Puppeteer can access way more tools than those exposed by the
    WebDriver API that Selenium uses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer不需要考虑跨浏览器支持的问题。尽管有人尝试在Firefox上运行Puppeteer，但重点在于获取Chromium的所有开发者工具并将其提供给用户。本着这个目标，Puppeteer可以访问比Selenium使用的WebDriver
    API暴露的工具多得多的工具。
- en: The difference in how they communicate with the browser is also reflected in
    the APIs. Puppeteer provides an API that will help us take advantage of all the
    power of Chromium. I think it's important to highlight that Puppeteer was created
    in JavaScript, so the API will feel more natural than Selenium's, which comes
    from a cross-language philosophy.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它们与浏览器通信的方式的差异也反映在API中。Puppeteer提供了一个API，将帮助我们充分利用Chromium的所有功能。我认为强调Puppeteer是用JavaScript创建的很重要，因此API会比来自跨语言哲学的Selenium的API感觉更自然。
- en: Puppeteer doesn't need to ask anybody to implement the API because it takes
    advantage of the headless capability of Chromium. Let's now see what headless
    browsers are.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer不需要请求任何人实现API，因为它利用了Chromium的无头能力。现在让我们看看什么是无头浏览器。
- en: Introducing Headless browsers
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍无头浏览器
- en: What is a headless browser? No, it's not something from a horror movie. **A
    headless browser is a browser that you can launch and interact with using a particular
    protocol over a particular communication transport, with no UI involved**. This
    means that you will have one active process (or many processes, as we know how
    browsers are these days), but there will be no "window" for you to interact with
    the browser. I think that "windowless browser" would have been a more accurate
    name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是无头浏览器？不，它不是来自恐怖电影的东西。**无头浏览器是一种浏览器，你可以通过特定的协议和特定的通信传输启动并与之交互，而不涉及任何用户界面**。这意味着你将有一个活跃的进程（或者像我们今天所知道的，有多个进程），但将没有“窗口”供你与浏览器交互。我认为“无窗口浏览器”会更准确。
- en: Available headless browsers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的无头浏览器
- en: 'Both Chromium and Firefox support headless browser mode. It''s important to
    mention that, at the time of writing this book, Firefox''s headless mode was still
    experimental. That might sound bad, compared with the six browsers Selenium offers
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers](https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers)),
    but, as you might have noticed, I didn''t say Chrome, I said Chromium. Chromium
    is the engine Chrome uses under the hood. But Chrome is not the only browser using
    Chromium; in the past few years, many browsers have started to use the chromium
    engine. These are a few examples of chromium-based browsers:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Chromium和Firefox都支持无头浏览器模式。重要的是要提到，在撰写这本书的时候，Firefox的无头模式仍然是实验性的。与Selenium提供的六个浏览器相比（[https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers](https://www.hardkoded.com/ui-testing-with-puppeteer/selenium-browsers)），这听起来可能不太好，但正如你可能已经注意到的，我没有说Chrome，我说的是Chromium。Chromium是Chrome在底层使用的引擎。但Chrome并不是唯一使用Chromium的浏览器；在过去的几年里，许多浏览器开始使用Chromium引擎。以下是一些基于Chromium的浏览器的例子：
- en: Google Chrome
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Chrome
- en: Microsoft Edge, a.k.a. Edgium, to avoid confusion with the previous version
    of Microsoft Edge based on Trident
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Edge，也称为Edgium，为了避免与基于Trident的旧版微软Edge混淆
- en: Opera
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera
- en: Brave
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brave
- en: 'That''s much better. We can automate at least five browsers. But there are
    two major browsers with no headless support: Microsoft Internet Explorer and Safari.
    The case of Safari is interesting. In the same way that Chromium is the engine
    behind Chrome, Webkit is the engine of Safari and, although Safari doesn''t support
    headless mode, there are a few Webkit builds created for testing purposes with
    headless support. Microsoft Playwright has its own Webkit build to support cross-browser
    automation.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多。我们可以自动化至少五种浏览器。但是，有两个主要浏览器没有无头支持：Microsoft Internet Explorer和Safari。Safari的情况很有趣。正如Chromium是Chrome背后的引擎一样，Webkit是Safari的引擎，尽管Safari不支持无头模式，但为了测试目的，有一些带有无头支持的Webkit构建。Microsoft
    Playwright有自己的Webkit构建以支持跨浏览器自动化。
- en: Do you want to see a headless browser for the very first time?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你想第一次看到无头浏览器吗？
- en: 'Let''s try this out:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个：
- en: 'If you have Chrome installed, grab the full path of the executable and pass
    these command arguments: `--headless --remote-debugging-port=9222 --crash-dumps-dir=/tmp`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已安装Chrome，请获取可执行文件的完整路径，并传递以下命令参数：`--headless --remote-debugging-port=9222
    --crash-dumps-dir=/tmp`：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you are a macOS user, the Chrome executable will be inside the "`Google
    Chrome.app`" pseudo-file. As you can see, it''s: "`Google Chrome.app/Contents/MacOS/Google
    Chrome`".'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名macOS用户，Chrome可执行文件将位于“`Google Chrome.app`”伪文件中。正如你所见，它是：“`Google Chrome.app/Contents/MacOS/Google
    Chrome`”。
- en: 'After executing that command, you should get something like this in the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，你应在控制台得到类似以下内容：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have a headless chrome browser waiting for commands through a WebSocket
    on `ws://127.0.0.1:9222`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个通过WebSocket在`ws://127.0.0.1:9222`上等待命令的无头Chrome浏览器。
- en: 'Firefox also provides a headless mode:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox也提供了无头模式：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It doesn't say much, but trust me, now we have a Firefox browser running in
    headless mode.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有说太多，但请相信我，现在我们有一个在无头模式下运行的Firefox浏览器。
- en: As I mentioned before, a headless browser doesn't have a UI. The only way to
    interact with the browser is to use the transport the browser created, in this
    case, a WebSocket, and to send messages using some kind of protocol. In the case
    of Chromium and Firefox, it's the Chromium DevTools Protocol.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，无头浏览器没有用户界面。与浏览器交互的唯一方式是使用浏览器创建的传输方式，在本例中是WebSocket，并通过某种协议发送消息。在Chromium和Firefox的情况下，它是Chromium
    DevTools协议。
- en: The Chromium DevTools Protocol
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chromium DevTools协议
- en: 'If you are a web developer, I''m 100% sure you have used Chrome DevTools. If
    you don''t know what I''m talking about, you can open DevTools by clicking on
    the three dots button in the top-right corner, and then go to `More Tools > Developer
    Tools`. You will get something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名网页开发者，我100%确信你已经使用过Chrome DevTools。如果你不知道我在说什么，你可以通过点击右上角的三个点按钮打开DevTools，然后转到“更多工具
    > 开发者工具”。你将得到类似这样的东西：
- en: '![Chrome DevTools'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![Chrome DevTools'
- en: '](img/Figure_1.01_B16113.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.01_B16113.jpg)'
- en: Chrome DevTools
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome DevTools
- en: 'It''s impressive all the things you can accomplish using this fantastic tool:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个神奇的工具你可以完成的事情令人印象深刻：
- en: Inspect the DOM.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查DOM。
- en: Evaluate CSS styles.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估CSS样式。
- en: Run JavaScript code.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行JavaScript代码。
- en: Debug JavaScript code.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试JavaScript代码。
- en: See network calls.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看网络调用。
- en: Measure performance.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量性能。
- en: And the good news is that it's the **Chromium Developer Protocol** (which we'll
    call **CDP** from now on) that drives most of the DevTools' features. And that
    same CDP is the protocol that headless browsers use to interact with the outside
    world.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，是**Chromium开发者协议**（从现在起我们将称之为**CDP**）驱动了大多数DevTools的功能。而且，同样的CDP也是无头浏览器用来与外界交互的协议。
- en: CDP sounds perfect. We can interact with the browser and do all the things I
    have mentioned. You can create a Node.JS app to launch a browser and start sending
    CDP messages through a WebSocket, but that would be quite complex and hard to
    maintain. That's where Puppeteer comes to the rescue and offers a human-friendly
    interface to interact with the browser.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CDP听起来完美。我们可以与浏览器交互并完成我提到的所有事情。你可以创建一个Node.JS应用程序来启动浏览器，并通过WebSocket开始发送CDP消息，但这将相当复杂且难以维护。这就是Puppeteer发挥作用并提供与浏览器交互的人性化界面的地方。
- en: Introducing Puppeteer
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Puppeteer
- en: Puppeteer is nothing more, and nothing less, than a Node.js package that knows
    how to open a browser, send commands, and react to messages coming from that browser.
    At the time of writing this book, Puppeteer supports Chromium and Firefox, but
    Firefox support is still considered experimental. I think it's a good time for
    you to go to the Puppeteer repository ([https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-repo](https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-repo))
    and check whether things have changed since then.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: There are also some community projects that implement Puppeteer in other languages.
    You will find Puppeteer-Sharp ([https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-sharp](https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-sharp))
    for .NET or Pyppeteer ([https://www.hardkoded.com/ui-testing-with-puppeteer/pypeteer](https://www.hardkoded.com/ui-testing-with-puppeteer/pypeteer))
    for Python.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use Puppeteer, you are, in fact, using more than just a JavaScript
    library. Many people call this the "Puppeteer pyramid":'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![ The Puppeteer pyramid'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.02_B16113.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The Puppeteer pyramid
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The Puppeteer pyramid consists of three components:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The headless browser is the engine that will run the pages we want to automate.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chromium DevTools Protocol allows any external user to interact with the
    browser.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppeteer provides a JavaScript API to interact with the browser using the CDP.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What I find valuable about Puppeteer is that its model clearly represents the
    browser structure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The Puppeteer object model
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Puppeteer Model'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.03_B16113.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer Model
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what these objects represent inside the browser.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Browser
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The browser is the main class. It's the object created when Puppeteer connects
    to a browser. The keyword here is **connect**. The browser that Puppeteer will
    use can be launched by Puppeteer itself. But it could also be a browser that is
    already running on your local machine, or it could even be a browser running in
    the cloud, like Browserless.io ([https://www.hardkoded.com/ui-testing-with-puppeteer/browserless](https://www.hardkoded.com/ui-testing-with-puppeteer/browserless)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Browser context
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A browser can contain more than one context. A context is a browser session
    (not to be confused with a browser window). The best example is the Incognito
    Mode or private mode, depending on the browser, which creates an isolated session
    inside the same browser process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Page
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A page is a tab in a browser or even a pop-up page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Frame
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The frame object is more important than it looks. Every page has at least one
    frame, which is called the main frame. Most of the page actions we will learn
    across this book are, in fact, a call to the main frame; for example, `page.click`
    calls `mainframe.click`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The frame is a tree. One page has only one main frame, but a frame can contain
    many child frames.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Worker
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A worker is a model that interacts with Web Workers. This is not a feature we
    will talk about in this book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者是与Web Workers交互的模型。这不是本书中我们将讨论的功能。
- en: Execution context
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行上下文
- en: The execution context is a mechanism Chromium uses to isolate the page from
    the browser extensions. Each frame will have its own execution context. Internally,
    all the frame functions that involve executing JavaScript code will use an execution
    context to run the code inside the browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上下文是Chromium用来隔离页面和浏览器扩展的机制。每个框架都将有自己的执行上下文。内部，所有涉及执行JavaScript代码的框架函数都将使用执行上下文在浏览器内部运行代码。
- en: There are other objects involved, such as `ElementHandles` and `JSHandles`,
    but we are going to talk about them later in the book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的其他对象还包括`ElementHandles`和`JSHandles`，但我们在本书的后面章节会讨论它们。
- en: Now that we know some of the differences between Selenium and Puppeteer, it's
    a perfect moment to review many possible use cases for Puppeteer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了一些Selenium和Puppeteer之间的区别，现在回顾Puppeteer的许多可能用例正是一个完美的时机。
- en: Puppeteer use cases
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppeteer用例
- en: Remember, the main difference between Puppeteer and Selenium is that Selenium
    is designed for end-to-end testing. In contrast, Puppeteer is designed as an API
    to exploit all the power of the DevTools, which means that besides end-to-end
    tests, there are also other use cases where you can use Puppeteer, as we will
    see now.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Puppeteer和Selenium之间的主要区别在于Selenium是为端到端测试设计的。相比之下，Puppeteer被设计为一个API，以利用DevTools的全部功能，这意味着除了端到端测试之外，还有其他可以使用Puppeteer的用例，正如我们现在将要看到的。
- en: Task Automation
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务自动化
- en: There are many things we do on the web that you can automate. For example, you
    can download a report, fill in a form, or check flight prices. You might also
    want to check your website's health, monitor its performance, or check whether
    your website is working correctly. In [*Chapter 6*](B16113_06_Final_SK_ePub.xhtml#_idTextAnchor104)*,
    Executing and Injecting JavaScript*, we will see how to use Checkly to monitor
    your website in production.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，我们做了许多可以自动化的工作。例如，你可以下载报告、填写表格或检查航班价格。你也可能想检查你网站的运行状况、监控其性能或检查你的网站是否运行正确。在[*第6章*](B16113_06_Final_SK_ePub.xhtml#_idTextAnchor104)*，执行和注入JavaScript*中，我们将看到如何使用Checkly在生产环境中监控你的网站。
- en: Web Scraping
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络爬取
- en: Most library authors won't like to say that you can use their library to do
    web scraping. Web Scraping has a reputation for being illegal. But in [*Chapter
    9*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156)*, Scraping tools*, we will
    see how to do web scraping in the right way, without getting banned or sued.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数库的作者可能不会愿意说你可以使用他们的库来进行网络爬取。网络爬取因其非法声誉而闻名。但在[*第9章*](B16113_09_Final_SK_ePub.xhtml#_idTextAnchor156)*，爬取工具*中，我们将看到如何正确地进行网络爬取，而不会遭到封禁或起诉。
- en: Content generation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容生成
- en: 'Generating content is not a use case that would come to your mind if you had
    to think about possible use cases. But Puppeteer is a great tool for generating
    two kinds of content:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 生成内容并不是如果你需要考虑可能的用例时，会想到的用例。但Puppeteer是一个生成两种类型内容的优秀工具：
- en: '**Screenshots**: Why would you need to take screenshots using an app? Think
    about thumbnails or previews. Imagine you want to create a paywall, showing part
    of your website content but as a blurred image. You could use Puppeteer to take
    a screenshot of your site, blur it, and use that image.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕截图**：为什么你需要使用应用程序来截图呢？想想缩略图或预览。想象一下，你想创建一个付费墙，显示你网站内容的一部分，但以模糊图像的形式。你可以使用Puppeteer对你的网站进行截图，将其模糊处理，并使用那张图片。'
- en: '**PDF files**: Invoices are a great example of PDF generation. Imagine you
    have an e-commerce site. When the user makes a purchase, you show them a nice,
    well-designed invoice, but you need to send them that exact invoice by email.
    You could use Puppeteer to navigate to that invoice page and print it to PDF.
    You could also use your landing page to generate a PDF and use it as a brochure.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PDF文件**：发票是PDF生成的绝佳例子。想象一下，你有一个电子商务网站。当用户完成购买时，你会向他们展示一个设计精美、布局合理的发票，但你需要通过电子邮件发送给他们那份确切的发票。你可以使用Puppeteer导航到那个发票页面并将其打印成PDF。你也可以使用你的着陆页生成PDF，并将其用作宣传册。'
- en: In [*Chapter 7*](B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130), *Generating
    Content with Puppeteer*, we will talk about this use case and how to use screenshots
    to write UI regression tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130)*，使用Puppeteer生成内容*中，我们将讨论这个用例以及如何使用截图来编写UI回归测试。
- en: End-to-end testing
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: I think Puppeteer is great for testing modern web apps because it's close to
    the browser. The API feels great, modern, and is designed for the JavaScript developer.
    It lets you execute JavaScript code easily and gives you access to all the power
    of Chromium. But I also have to say that Selenium's tolling for end-to-end testing
    is impressive. Puppeteer is not even close to what Selenium offers with its Selenium
    Grid. It's up to you to decide which is the right tool for you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 Puppeteer 对于测试现代网络应用来说非常棒，因为它接近浏览器。API 感觉非常好，现代，并且是为 JavaScript 开发者设计的。它让你可以轻松执行
    JavaScript 代码，并给你访问 Chromium 所有功能的权限。但我也必须说，Selenium 的端到端测试工具非常出色。Puppeteer 甚至无法与
    Selenium Grid 提供的功能相提并论。选择哪个工具适合你取决于你自己。
- en: Enough with the theory. It's time to get started and set up our environment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了。现在是时候开始并设置我们的环境了。
- en: Setting up the environment
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: What's good about Node.js and Puppeteer is that they are cross-platform. My
    local environment is macOS Catalina 10.15.6\. But you won't see much difference
    if you use a Windows or a Linux environment.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 和 Puppeteer 的好处是它们是跨平台的。我的本地环境是 macOS Catalina 10.15.6。但如果你使用 Windows
    或 Linux 环境，你不会看到太大的区别。
- en: Time is a tech book's worst enemy. At the time of writing this book, I was using
    Node.JS 12.18.3 and Puppeteer 7\. I'm pretty sure that by the time you read this
    book, new versions will have come to light. But don't feel discouraged about that;
    we expect that to happen. That's why I encourage you to go now and take a look
    at the GitHub repository of this book ([https://github.com/PacktPublishing/ui-testing-with-Puppeteer](https://github.com/PacktPublishing/ui-testing-with-Puppeteer)).
    If you see that something is not working or has changed, please create an issue
    on that repository. We will try to keep it updated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是技术书籍的最大敌人。在撰写这本书的时候，我正在使用 Node.JS 12.18.3 和 Puppeteer 7。我非常确信，当你阅读这本书的时候，新的版本已经发布。但不要因此感到气馁；我们预期这种情况会发生。这就是为什么我鼓励你现在就去查看这本书的
    GitHub 仓库（[https://github.com/PacktPublishing/ui-testing-with-Puppeteer](https://github.com/PacktPublishing/ui-testing-with-Puppeteer)）。如果你看到有什么东西不工作或者已经改变，请在那个仓库中创建一个
    issue。我们将尽力保持其更新。
- en: 'We only need two things to run our first Puppeteer code: Node.JS and Puppeteer.
    Let''s begin with Node.JS.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的第一个 Puppeteer 代码只需要两样东西：Node.JS 和 Puppeteer。让我们从 Node.JS 开始。
- en: Node.js
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js
- en: For the purposes of this book, the only thing you need to know about Node.js
    is that it's a runtime that allows us to run JavaScript code outside the browser.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这本书的目的，你需要了解的关于 Node.js 的唯一一件事是，它是一个运行时，允许我们在浏览器之外运行 JavaScript 代码。
- en: It's important to highlight that the website we want to automate doesn't necessarily
    need to run on Node.js. You wouldn't need to know the language used to write the
    website, nor the platform that the website is running, but if you get to know
    those details, that could give you some ideas to write better automation code.
    For instance, if you know that the site is an ASP.NET Webforms project, you will
    know that it uses some hidden inputs to perform postbacks. That becomes more evident
    if you know the client-side frameworks, such as Vue or React.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，我们想要自动化的网站不一定需要在 Node.js 上运行。你不需要知道编写网站的编程语言，也不需要知道网站运行的平台，但如果你能了解这些细节，这可能会给你一些编写更好的自动化代码的想法。例如，如果你知道该网站是一个
    ASP.NET Webforms 项目，你就会知道它使用一些隐藏的输入来执行 postbacks。如果你了解客户端框架，如 Vue 或 React，这一点会更加明显。
- en: 'As I mentioned before, we will install Node.JS v12.18.3 (or higher). The process
    is quite simple:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们将安装 Node.JS v12.18.3（或更高版本）。这个过程相当简单：
- en: 'Go to the official site: [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往官方网站：[https://nodejs.org/](https://nodejs.org/)。
- en: Download the LTS version. **LTS** stands for **Long-Term Support**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 LTS 版本。**LTS** 代表 **长期支持**。
- en: 'Run the installer as you would typically do on your platform:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照你通常在平台上安装的方式运行安装程序：
- en: '![Node.js setup'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Node.js 安装](img/Figure_1.04_B16113.jpg)'
- en: '](img/Figure_1.04_B16113.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.04_B16113.jpg](img/Figure_1.04_B16113.jpg)'
- en: Node.js setup
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 安装
- en: 'If you want to see whether the installation was successful, you can open a
    terminal and execute `node --version`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看安装是否成功，你可以在终端中执行 `node --version`：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Visual Studio Code
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: You don't need any special code editor to write a Node.js app. But Visual Studio
    Code is a great editor. It's free, cross-platform, and you can use it not only
    to code JavaScript, but also to code in many other languages as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要任何特殊的代码编辑器来编写 Node.js 应用程序。但 Visual Studio Code 是一个很好的编辑器。它是免费的，跨平台的，你不仅可以用它来编写
    JavaScript 代码，还可以用它来编写许多其他语言的代码。
- en: 'You can download it at [https://code.visualstudio.com/](https://code.visualstudio.com/).
    It doesn''t even require running a setup on macOS. It''s just an app you copy
    to your `Applications` folder:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://code.visualstudio.com/](https://code.visualstudio.com/) 下载它。它甚至不需要在
    macOS 上运行设置。它只是一个你复制到 `Applications` 文件夹的应用程序：
- en: '![Visual Studio Code'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![Visual Studio Code]'
- en: '](img/Figure_1.05_B16113.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.05_B16113.jpg)'
- en: Visual Studio Code
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Now that we have Node.js installed along with a code editor, we can create our
    first app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Node.js 以及代码编辑器，我们可以创建我们的第一个应用程序。
- en: Our first Puppeteer code
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一段 Puppeteer 代码
- en: 'We first need to create a folder where our `hello-puppeteer` project will be
    located. I''m going to use a terminal, but you can use whatever you feel more
    comfortable with. Our project will be called `hello-puppeteer`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个文件夹，我们的 `hello-puppeteer` 项目将位于该文件夹中。我将使用终端，但你可以使用你感到更舒适的方式。我们的项目将被称为
    `hello-puppeteer`：
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now need to initialize this brand-new node.js application. We create new
    applications in node.js using the `npm init` command. In this case, we will pass
    the `-y` argument, so it creates our app using default values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要初始化这个全新的 node.js 应用程序。在 node.js 中，我们使用 `npm init` 命令创建新应用程序。在这种情况下，我们将传递
    `-y` 参数，这样它就会使用默认值创建我们的应用程序：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This output doesn''t say much. It shows us that it has created a `package.json`
    file with some default values. Now, I will create an `index.js` file using the
    `touch` command. Again, you can perform this action in the way you feel most comfortable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出并没有说明太多。它显示它创建了一个包含一些默认值的 `package.json` 文件。现在，我将使用 `touch` 命令创建一个 `index.js`
    文件。同样，你可以以你感到最舒适的方式执行此操作：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Touch should have created the entry point of our app. But before coding our
    app, we need to install Puppeteer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch` 应该已经创建了我们的应用程序的入口点。但在编码我们的应用程序之前，我们需要安装 Puppeteer。'
- en: Installing Puppeteer
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Puppeteer
- en: Most frameworks, if not all of them, have a way to publish and reuse components
    from different authors. The most popular package manager in Node.js is `npm init`
    to create our app. As Puppeteer is a package published in NPM, we can download
    and install it using the `npm install` command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架，如果不是所有框架，都有一种方式来发布和重用不同作者编写的组件。在 Node.js 中最流行的包管理器是 `npm init` 来创建我们的应用程序。由于
    Puppeteer 是在 NPM 上发布的包，我们可以使用 `npm install` 命令下载和安装它。
- en: 'If you don''t want to jump between apps, you can open a terminal inside Visual
    Studio Code. If you are still in the terminal, you can open Visual Studio Code
    using the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在应用程序之间跳转，你可以在 Visual Studio Code 内部打开一个终端。如果你还在终端中，你可以使用以下命令打开 Visual
    Studio Code：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That will open Visual Studio Code. Once there, you will be able to launch a
    new terminal from the **Terminal** menu, as shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 Visual Studio Code。一旦进入，你将能够从 **终端** 菜单启动一个新的终端，如下面的截图所示：
- en: '![Terminal inside Visual Studio Code'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![Visual Studio Code 内部的终端]'
- en: '](img/Figure_1.06_B16113.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.06_B16113.jpg)'
- en: Terminal inside Visual Studio Code
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 内部的终端
- en: 'After opening a terminal, we can install Puppeteer using `npm install`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端后，我们可以使用 `npm install` 安装 Puppeteer：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I would like to highlight two things here. As this book is based on `@">=7.0.0
    <8.0.0"`, which means that we want the latest Puppeteer version greater than or
    equal to `7.0.0` and less than version `8.0.0`. By forcing this version to be
    used, you will be able to follow the examples in this chapter using the same version
    I used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里强调两点。由于本书基于 `@">=7.0.0 <8.0.0"`，这意味着我们想要大于或等于 `7.0.0` 且小于版本 `8.0.0` 的最新
    Puppeteer 版本。通过强制使用此版本，你将能够使用与我相同的版本来跟随本章中的示例。
- en: Puppeteer versioning
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 版本控制
- en: Puppeteer follows the **Semantic Versioning Specification** (**SemVer**) to
    version their releases, which means that those three numbers in the version follow
    a rule. A change in the major number (the first number) means that there was a
    breaking change in the API. When a package changes the major number, it tells
    you that the new version might break your code. A change in the minor number (the
    second number) means that they added new functionality, maintaining backward compatibility.
    Lastly, a change in the patch number means that they fixed a bug, maintaining
    backward compatibility.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 遵循 **语义化版本控制规范**（**SemVer**）来为其发布版本进行版本控制，这意味着版本号中的三个数字遵循一定的规则。主版本号（第一个数字）的变化意味着
    API 中发生了重大变化。当一个包更改主版本号时，它会告诉你新版本可能会破坏你的代码。次版本号（第二个数字）的变化意味着他们添加了新功能，同时保持向后兼容。最后，修订号的变化意味着他们修复了一个错误，同时保持向后兼容。
- en: If you see that Puppeteer is in version 8, 9, or 10, it doesn't mean that this
    book is now obsolete. It means that they changed something that broke someone
    else's code. For instance, the change from version 6 to version 7 was just some
    change they made in the way they take screenshots.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到 Puppeteer 的版本是 8、9 或 10，这并不意味着这本书现在已经过时了。这意味着他们改变了某些东西，破坏了其他人的代码。例如，从版本
    6 到版本 7 的变化只是他们在截图方式上做的一些改动。
- en: In real life, you can use the latest version available. And second, you might
    have noticed that the package downloaded a specific version of Chromium, in this
    case, `r848005`. That doesn't mean that your code won't work with any version
    of Chromium you download from the internet. But, remember, Puppeteer interacts
    with the browser using the Chrome DevTools Protocol, so it needs a version of
    Chromium that reacts in the way Puppeteer expects. In the case of Puppeteer v7.0.1,
    it needs Chromium 90.0.4403.0, and there is no guarantee that any other version
    of Chromium (newer or older) would work with your current Puppeteer version. It
    doesn't mean that it won't work. It means that it's not guaranteed. You need to
    experiment and see. You can check which chromium version you should use for every
    version of Puppeteer on the API page ([https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api](https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，你可以使用可用的最新版本。其次，你可能已经注意到下载的包包含了一个特定的 Chromium 版本，在这个例子中是 `r848005`。这并不意味着你从互联网上下载的任何
    Chromium 版本都无法与你的代码一起工作。但是，记住，Puppeteer 通过 Chrome DevTools 协议与浏览器交互，因此它需要一个 Puppeteer
    预期的方式反应的 Chromium 版本。在 Puppeteer v7.0.1 的情况下，它需要 Chromium 90.0.4403.0，并且不能保证任何其他版本的
    Chromium（无论是新版本还是旧版本）都能与你的当前 Puppeteer 版本一起工作。这并不意味着它不会工作。这意味着它没有保证。你需要进行实验并查看。你可以在
    API 页面上检查每个 Puppeteer 版本应使用哪个 Chromium 版本（[https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api](https://www.hardkoded.com/ui-testing-with-puppeteer/puppeteer-api)）。
- en: Hello world in Puppeteer
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppeteer 中的“Hello World”
- en: 'Every language has its own hello world program. Puppeteer''s hello world program
    would be navigating to [https://en.wikipedia.org/wiki/%22Hello,_World!%22_program](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program)
    and taking a screenshot of the page. Let''s see what it would look like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言都有自己的“Hello World”程序。Puppeteer 的“Hello World”程序将是导航到 [https://en.wikipedia.org/wiki/%22Hello,_World!%22_program](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program)
    并对页面进行截图。让我们看看它看起来会是什么样子：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is what we are doing in this small script:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这个小脚本中做的事情：
- en: We import the Puppeteer library using `require`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `require` 导入 Puppeteer 库。
- en: Launch a new browser.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的浏览器。
- en: Open a new page (tab) inside that browser.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个浏览器中打开一个新的页面（标签页）。
- en: Navigate to the Wikipedia page.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到维基百科页面。
- en: Take a screenshot.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获屏幕截图。
- en: Close the browser.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: 'I love how simple and easy it is to get started with Puppeteer. It''s now time
    to run it. Using the same terminal you used to run `npm install`, now run `node
    index.js`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 Puppeteer 开始使用起来既简单又容易。现在是时候运行它了。使用你用来运行 `npm install` 的相同终端，现在运行 `node
    index.js`：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A Chromium browser opened, navigated to Wikipedia, and closed by itself. You
    didn''t see it because it was a headless browser, but it happened. Now, if you
    check your working directory, you should have a new file called `screenshot.png`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Chromium 浏览器打开了，导航到维基百科，然后自行关闭。你没有看到它，因为这是一个无头浏览器，但它确实发生了。现在，如果你检查你的工作目录，你应该有一个名为
    `screenshot.png` 的新文件：
- en: '![Screenshot'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![Screenshot'
- en: '](img/Figure_1.07_B16113.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_1.07_B16113.jpg](img/Figure_1.07_B16113.jpg)'
- en: Screenshot
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图
- en: Our code worked as expected. We got our screenshot from Wikipedia.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码按预期工作。我们从维基百科获得了我们的截图。
- en: I bet you noticed that we used four **awaits** in our small hello puppeteer
    example. Asynchronous programming plays a big role in Puppeteer. Let's now talk
    about asynchronous programming in JavaScript.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你注意到了在我们的小型 hello puppeteer 示例中使用了四个 **awaits**。异步编程在 Puppeteer 中扮演着重要角色。现在让我们来谈谈
    JavaScript 中的异步编程。
- en: Asynchronous programming in JavaScript
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 中的异步编程
- en: 'Normally, a program runs synchronously, which means that each line of code
    is executed one after the other. Let''s take, for instance, these two lines of
    code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序是同步运行的，这意味着每一行代码都是依次执行的。让我们以这两行代码为例：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Those two lines will run in order. The result of `3 + 4` will be assigned to
    the `x` constant, and then the variable `x` will be printed on the screen using
    `console.log`. The `console.log` function can't start until `x` is assigned.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码将按顺序执行。`3 + 4` 的结果将被分配给 `x` 常量，然后使用 `console.log` 在屏幕上打印变量 `x`。`console.log`
    函数必须在 `x` 被分配后才能开始执行。
- en: But there are tasks, such as network requests, disk access, or any other I/O
    operation, that are time-consuming, and we don't necessarily want to wait for
    those tasks to finish to keep executing our code. For instance, we could start
    downloading a file, perform other tasks while that file is loading, and then check
    that file when the download is completed. Asynchronous programming will allow
    us to execute those long-running tasks without blocking our code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但有些任务，比如网络请求、磁盘访问或任何其他I/O操作，可能需要很长时间，我们不一定想等待这些任务完成后再继续执行我们的代码。例如，我们可以开始下载一个文件，在文件加载的同时执行其他任务，然后在下载完成后检查该文件。异步编程将允许我们在不阻塞代码的情况下执行这些长时间运行的任务。
- en: 'An asynchronous function returns a **Promise** immediately to avoid blocking
    your code while waiting for a task. This Promise is an object that can be in one
    of the following three states:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数会立即返回一个 **Promise** 以避免在等待任务时阻塞你的代码。这个Promise是一个对象，它可以处于以下三种状态之一：
- en: '**Pending**: This means that the asynchronous task is still in progress.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pending**：这意味着异步任务仍在进行中。'
- en: '**Fulfilled**: This means that the asynchronous task was completed successfully.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fulfilled**：这意味着异步任务成功完成了。'
- en: '**Rejected**: This means that the asynchronous task has failed.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rejected**：这意味着异步任务失败了。'
- en: 'Let''s say that we have a function called `downloadAFileFromTheInternet`. The
    most common way to wait for a task to finish is to use the `await` keyword:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `downloadAFileFromTheInternet` 的函数。等待一个任务完成的常见方式是使用 `await` 关键字：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It''s important to highlight that the `await` keyword here is not waiting for
    the function itself; it is waiting for the `Promise` returned by that function.
    That means that you can also assign that `Promise` to a variable and `await` it
    later in the code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，这里的 `await` 关键字并不是等待函数本身；它是在等待该函数返回的 `Promise`。这意味着你还可以将那个 `Promise`
    赋值给一个变量，并在代码的稍后位置等待它：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or you can just not wait for the promise at all:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以根本不等待这个Promise：
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want to learn more about asynchronous JavaScript, check out the *Asynchronous
    JavaScript Deep Dive* videos by Steven Hancock ([https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665](https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于异步JavaScript的知识，可以查看Steven Hancock的 *Asynchronous JavaScript Deep
    Dive* 视频教程（[https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665](https://www.packtpub.com/product/asynchronous-javascript-deep-dive-video/9781800202665)）。
- en: 'Puppeteer relies on asynchronous programming techniques because the communication
    between Puppeteer and Chrome DevTools is asynchronous. After all, the communication
    between Chrome DevTools and the browser is asynchronous. Think about what would
    happen under the hood when you click a link:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer依赖于异步编程技术，因为Puppeteer与Chrome DevTools之间的通信是异步的。毕竟，Chrome DevTools与浏览器之间的通信也是异步的。想想当你点击一个链接时幕后会发生什么：
- en: '![Click timeline'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![点击时间线'
- en: '](img/Figure_1.08_B16113.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.08_B16113.jpg)'
- en: Click timeline
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 点击时间线
- en: 'When you call `page.click`, the result of that action is not immediate. As
    we saw, there are many things going on under the hood. When you call `page.click`,
    you will need to do one of the things mentioned previously: await it; keep the
    promise in a variable and await it later; or don''t await it at all.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `page.click` 时，该动作的结果不会立即出现。正如我们所见，幕后有许多事情在进行。当你调用 `page.click` 时，你需要做之前提到的事情之一：等待它；将承诺保存在变量中并在稍后等待它；或者根本不等待它。
- en: Now that we know more about asynchronous programming, I would like to review
    five utilities that we will use across the book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对异步编程有了更多的了解，我想回顾一下本书中我们将使用的五个实用工具。
- en: Promise.all
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.all
- en: '`Promise.all` is a function that expects an array of promises and returns a
    promise that will be **resolved** when **all** the promises are **fulfilled or
    rejected**. Yes, a promise could be fulfilled, completed successfully, or rejected,
    which means it failed.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all` 是一个函数，它期望一个promise数组，并返回一个当 **所有** promise都 **解决或拒绝** 时才会解决的promise。是的，一个promise可以是解决的，成功完成，或者拒绝，这意味着它失败了。'
- en: 'A common scenario is clicking on a link, and waiting for the page to navigate
    to the next page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的场景是点击一个链接，并等待页面导航到下一页：
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This promise will wait for the link to `click` and the `waitForNavigation` promises
    to be either fulfilled or rejected.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个promise将等待链接的点击和 `waitForNavigation` promise被解决或拒绝。
- en: Promise.race
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.race
- en: Like `Promise.all`, `Promise.race` expects an array of promises, but in this
    case, it will resolve when **any** of the promises are resolved.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Promise.all` 类似，`Promise.race` 期望一个承诺数组，但在这个情况下，只要**任何一个**承诺被解决，它就会解决。
- en: 'A typical usage is for timeouts. We want to take a screenshot, but only if
    it takes less than 2 seconds:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 典型用法是用于超时。我们想要截图，但只有当它少于 2 秒时：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, if the `screenshot` promise takes more than 2,000 milliseconds,
    the promise created as the second element in the array will be **rejected**, rejecting
    the Promise.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 `screenshot` 承诺超过 2,000 毫秒，数组中作为第二个元素的承诺将被**拒绝**，拒绝该承诺。
- en: Fulfilling our own promises
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 履行我们的承诺
- en: You saw in our previous example how you can create a promise, return that Promise
    or assign it to a variable, and then fulfill it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你在我们的上一个例子中看到了如何创建一个承诺，返回那个承诺或将其分配给一个变量，然后履行它。
- en: 'This is great when you want to wait for an event to happen. We can create a
    promise that will be resolved when the page closes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要等待一个事件发生时，这很棒。我们可以创建一个承诺，当页面关闭时它将被解决：
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This kind of `await` is quite risky. If the Promise is never fulfilled, your
    code will hang. I recommend using these promises with `Promise.race` and timeouts.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `await` 是相当危险的。如果承诺永远不会解决，你的代码将会挂起。我建议使用这些承诺与 `Promise.race` 和超时一起使用。
- en: We will see lots of promises throughout this book. Maybe some recipes such as
    "fulfill our own promises" look odd now, but we will use them a lot.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将看到许多承诺。也许现在一些像“履行我们的承诺”这样的食谱看起来很奇怪，但我们会大量使用它们。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot in this first chapter. We learned about browser automation
    and the difference between Selenium and Puppeteer. Then we saw that Puppeteer
    isn't limited only to end-to-end testing and reviewed some use case scenarios.
    Then we got our hands dirty and coded our first Puppeteer script. In the last
    section of the chapter, we covered many asynchronous techniques that we will use
    in this book.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们涵盖了大量的内容。我们学习了浏览器自动化以及 Selenium 和 Puppeteer 之间的区别。然后我们看到 Puppeteer 不仅限于端到端测试，并回顾了一些用例场景。然后我们亲自动手编写了我们的第一个
    Puppeteer 脚本。在章节的最后部分，我们介绍了许多我们将在本书中使用的异步技术。
- en: In the next chapter, we are going to focus on end-to-end testing. We will review
    some tools available on the market and will consider how to organize our code
    to create reliable end-to-end tests.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于端到端测试。我们将回顾市场上可用的工具，并考虑如何组织我们的代码以创建可靠的端到端测试。
