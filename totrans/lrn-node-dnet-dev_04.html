<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Introducing Node.js Modules</h1></div></div></div><p>Now that we're up to speed with the syntax of the JavaScript language, we can start building up our application. To do this, we need to know how to structure our application to allow it to grow in a maintainable way.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Structuring JavaScript code with modules</li><li class="listitem">Declaring and using our own modules</li><li class="listitem">Organizing modules into files and directories</li><li class="listitem">Implementing an Express middleware module</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec18"/>Organizing your codebase</h1></div></div></div><p>Most programming platforms provide several mechanisms for structuring your code. Consider C#/.NET or Java: you can use classes, namespaces or packages, and compilation<a id="id133" class="indexterm"/> units (assemblies or JAR/WAR files). Notice the range from small-scale organizational units (classes) to large-scale ones (assemblies). This allows you to make a codebase more approachable by providing order at each level of detail.</p><p>Classic browser-based JavaScript development was quite unstructured. Functions were the only built-in language feature for organizing your code. You could split your code into separate script files, but these all share the same global context within a web page.</p><p>Over time, people have developed ways of organizing JavaScript code. The standard approach now is to use <a id="id134" class="indexterm"/>
<strong>modules</strong>. There are a few different module systems available for JavaScript, but they all work in a similar way. Each module system includes the following aspects: </p><div><ul class="itemizedlist"><li class="listitem">A way of declaring a module with a name and its own scope</li><li class="listitem">A way of defining functionality provided by the module</li><li class="listitem">A way of importing a module into another script</li></ul></div><p>In each system, when you import a module, you get a plain JavaScript object that you can assign to a variable. For most modules, this will be an object with several properties containing functions. But it could be any valid JavaScript object, for example, a single function.</p><p>Most module<a id="id135" class="indexterm"/> systems expect or at least encourage you to define each module in a separate file, just as you would with classes in other languages. It is also common for large modules to be composed of other, smaller, modules. These would be grouped together under the same directory. In this way, modules act more like namespaces or packages.</p><p>The flexibility of modules means that you can use them to structure your code at different scales. The lack of a built-in hierarchy of organizational units in JavaScript provides more flexibility. It also forces you to think more about how you structure your code.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>JavaScript module systems</h2></div></div></div><p>ECMAScript 2015 introduces modules as a built-in feature of the language. They have been common practice for a while, though. For client-side programming, this practice has relied on using third-party libraries to provide a module system.</p><p>You may<a id="id136" class="indexterm"/> have seen RequireJS, which provides a way of <a id="id137" class="indexterm"/>using functions to define modules. RequireJS uses plain JavaScript and works in any environment. It is most useful in the browser, where additional modules may be loaded over the Internet. RequireJS addresses some of the pitfalls of loading additional scripts dynamically and asynchronously.</p><p>The Node.js environment has its own module system, which we will look at in the rest of this chapter. It makes use of the filesystem for organizing modules.</p><div><h3 class="title"><a id="tip02"/>Tip</h3><p>You might come <a id="id138" class="indexterm"/>across the terms <strong>AMD</strong> or <strong>CommonJS</strong>. These are<a id="id139" class="indexterm"/> standards for defining modules. RequireJS is an implementation of AMD, and Node.js modules follow the CommonJS standard. ECMAScript 2015 modules define a new standard with new <code class="literal">export</code> and <code class="literal">import</code> language keywords. The syntax is quite similar, though, to the Node.js module system we'll be using in this book, and it is easy to switch between the two.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec19"/>Creating modules in Node.js</h1></div></div></div><p>We've <a id="id140" class="indexterm"/>actually already used several Node.js modules and created some of our own. Let's look again at our application from <a class="link" title="Chapter 2. Getting Started with Node.js" href="part0018.xhtml#aid-H5A41">Chapter 2</a>, <em>Getting Started with Node.js</em>.</p><p>The following code is from <code class="literal">routes/index.js and routes/users.js</code>:</p><div><pre class="programlisting">module.exports = router;</pre></div><p>The following<a id="id141" class="indexterm"/> is the code from <code class="literal">app.js</code>:</p><div><pre class="programlisting">var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var routes = require('./routes/index');
var users = require('./routes/users');</pre></div><p>Each of our routes (index and users) is a module. They expose their functionality using the built-in <code class="literal">module</code> object, which is defined by Node.js as a variable scoped to each module. In the preceding example, the object provided by each of our route modules is an Express router instance. The <code class="literal">app.js</code> script imports these modules using the built-in <code class="literal">require</code> function.</p><p>Observe that <code class="literal">app.js</code> also imports various <code class="literal">npm</code> packages using <code class="literal">require</code>. Note that it uses file paths to reference our own modules, whereas <code class="literal">npm</code> modules are referenced by name.</p><p>Let's look at how Node.js modules satisfy the three aspects of JavaScript module functionality.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Declaring a module with a name and its own scope</h2></div></div></div><p>In Node.js, each <a id="id142" class="indexterm"/>separate JavaScript file is automatically<a id="id143" class="indexterm"/> treated as a new module. Unlike scripts loaded into a web page, each file has its own scope. The name of the module is the name of the file.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Defining functionality provided by the module</h2></div></div></div><p>Node.js provides two built-in variables for exporting functionality from a module. These are <code class="literal">module.exports</code> and <code class="literal">exports</code>. <code class="literal">module.exports</code> is initialized to an empty object. <code class="literal">exports</code> is <a id="id144" class="indexterm"/>just a reference to <code class="literal">module.exports</code>. It is equivalent to the following appearing before your script:</p><div><pre class="programlisting">var exports = module.exports = {};</pre></div><p>Whatever is contained in the <code class="literal">module.exports</code> variable at the end of your script is the exported value of your module. This will be returned whenever your module is imported elsewhere. The following are all equivalent:</p><div><pre class="programlisting">module.exports.foo = 1;
module.exports.bar = 2;

module.exports = { foo: 1, bar: 2 };

exports.foo = 1;
exports.bar = 2;</pre></div><p>Note that<a id="id145" class="indexterm"/> the following is <em>not</em> the same as the previous examples. It just reassigns <code class="literal">exports</code>, but doesn't alter <code class="literal">module.exports</code> at all:</p><div><pre class="programlisting">exports = { foo: 1, bar: 2 };</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Importing a module into another script</h2></div></div></div><p>Node.js provides<a id="id146" class="indexterm"/> another built-in variable for importing modules. This is the <code class="literal">require</code> function we saw in <code class="literal">app.js</code> earlier in the chapter. This function is provided by Node.js and always available. It takes a single argument, which is the name or path of the module you want to import. The following excerpts from <code class="literal">app.js</code> demonstrate loading a third-party module by name and one of our own modules by a file path:</p><div><pre class="programlisting">var express = require('express');
...
var routes = require('./routes/index');</pre></div><p>Note that we don't need to specify the <code class="literal">.js</code> file extension for our own module. Node.js will automatically add this for us.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Defining a directory-level module</h1></div></div></div><p>As mentioned<a id="id147" class="indexterm"/> at the beginning of this chapter, modules can also <a id="id148" class="indexterm"/>act more like namespaces. We can treat a whole directory as a module, consisting of smaller modules in individual files. The simplest way to do this is to create an <code class="literal">index.js</code> file in the directory.</p><p>When calling <code class="literal">require('./directoryName')</code>, Node.js will attempt to load a file named <code class="literal">'./directoryName/index.js'</code> (relative to the current script). There is nothing special about <code class="literal">index.js</code> itself. This is just another script file that exposes an entry point to the module. If <code class="literal">directoryName</code> contains a <code class="literal">package.json</code> file, Node.js will load this file first and see if it specifies a <code class="literal">main</code> script, in which case Node.js will load this script instead of looking for <code class="literal">index.js</code>.</p><p>To import local modules, we use a file or directory path, that is, something starting with <code class="literal">'/'</code>, <code class="literal">'../'</code>, or <code class="literal">'./'</code> as in the preceding example. If we call <code class="literal">require</code> with a plain string, Node.js treats it as relative to the <code class="literal">node_modules</code> folder. The <code class="literal">npm</code> packages are just directory-level modules<a id="id149" class="indexterm"/> under this folder. We will<a id="id150" class="indexterm"/> look at defining our own <code class="literal">npm</code> packages in more detail in a later chapter.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Implementing an Express middleware module</h1></div></div></div><p>Let's return to the Node.js application we started in <a class="link" title="Chapter 2. Getting Started with Node.js" href="part0018.xhtml#aid-H5A41">Chapter 2</a>, <em>Getting Started with Node.js</em>. We're going to write an application where users can set puzzles for one another. First of all, we'll need a way of identifying the current user. We'll need to do this on most requests, making it a cross-cutting concern. This is a good use case for middleware.</p><p>For now, we <a id="id151" class="indexterm"/>will implement users in the simplest<a id="id152" class="indexterm"/> way possible, just storing an ID in a cookie. We will look into more robust identification in a later chapter. Note, however, that our use of middleware means it will be easy to alter our approach later on. This concern is encapsulated in our user middleware, so we only need to change it in one place.</p><p>First, we need a way of generating unique IDs. For this, we will use the UUID module from npm. We can add this to our project by running the following on the command line:</p><div><pre class="programlisting"><strong>&gt; npm install uuid --save</strong>
</pre></div><p>The <code class="literal">--save</code> flag stores the name of this module in our <code class="literal">package.json</code> file so that it will be installed automatically by <code class="literal">npm install</code>. This is useful for restoring our application from a clean checkout of the source code (recall that people commonly exclude the <code class="literal">node_modules</code> directory from source control, precisely because it can easily be restored in this way).</p><p>Now we are ready to create our middleware, which will place under <code class="literal">middleware/users.js</code>:</p><div><pre class="programlisting">'use strict';

const uuid = require('uuid');

module.exports = function(req, res, next) {
    let userId = req.cookies.userId;
    if (!userId) {
        userId = uuid.v4();
        res.cookie('userId', userId);
    }
    req.user = {
        id: userId
    };
    next();
};</pre></div><p>Notice that we use the ES2015 <code class="literal">const</code> keyword for the <code class="literal">uuid</code> module because this reference never changes. But we use the <code class="literal">let</code> keyword for the <code class="literal">userId</code> variable because this can be reassigned. Also notice that we call <code class="literal">next()</code> rather than returning a response, so the next<a id="id153" class="indexterm"/> middleware can continue processing<a id="id154" class="indexterm"/> the request.</p><p>Finally, we need to add this middleware to our application in <code class="literal">app.js</code>:</p><div><pre class="programlisting"><strong>var users = require('./middleware/users');</strong>
var routes = require('./routes/index');
var app = express();

...

<strong>app.use(users);</strong>
app.use('/', routes);

...</pre></div><p>Note that this replaces the import and usage of the <code class="literal">./routes/users</code> module that was generated for us. This route wasn't particularly useful, but we will add more routes soon.</p><p>We can check that our middleware works by altering our index route and view as follows:</p><div><pre class="programlisting">routes/index.jsrouter.get('/', function(req, res, next) {
<strong>  res.render('index', { title: 'Welcome', userId: req.user.id });</strong>
});</pre></div><p>The following is the code <code class="literal">views/index.hjs</code>:</p><div><pre class="programlisting">  &lt;body&gt;
<strong>    &lt;h1&gt;{{ title }}&lt;/h1&gt;</strong>
<strong>    &lt;p&gt;Your user ID is {{ userId }}.&lt;/p&gt;</strong>
  &lt;/body&gt;</pre></div><p>Launch the application and visit <code class="literal">http://localhost:3000/</code>. You should see a randomly-generated user ID. Refresh the page and you should retain the same ID. Open the site in a different browser (or an incognito/private browsing window). This separate browser session should see a different ID.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to use Node.js modules to structure our codebase, and how to create an Express middleware module to implement cross-cutting concerns.</p><p>Now that we have a way of structuring our codebase and a means of identifying users, we can get on with implementing our application's functionality. In the next chapter, we'll start adding some interactivity to our application.</p></div></body></html>