- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensuring Purity – Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, when
    we considered pure functions and their advantages, we saw that side effects such
    as modifying a received argument or a global variable were frequent causes of
    impurity. Now, after several chapters dealing with many aspects and tools of FP,
    let’s talk about the concept of *immutability* – how to work with objects in such
    a way that accidentally modifying them will become harder or, even better, impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot force developers to work in a safe, guarded way. Still, if we find
    some way to make data structures immutable (meaning that they cannot be directly
    changed, except through some interface that never allows us to modify the original
    data and produces new objects instead), then we’ll have an enforceable solution.
    In this chapter, we will look at two distinct approaches to working with such
    immutable objects and data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Basic JavaScript ways*, such as freezing objects, plus cloning to create new
    ones instead of modifying existing objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Persistent data structures*, with methods that allow us to update them without
    changing the original and without the need to clone everything either, for higher
    performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning!
  prefs: []
  type: TYPE_NORMAL
- en: The code in this chapter isn’t production-ready; I wanted to focus on the main
    points and not on all the myriad details concerning properties, getters, setters,
    lenses, prototypes, and so on that you should take into account for a full, bulletproof
    solution. For actual development, I recommend going with a third-party library,
    but only after checking that it really applies to your situation. We’ll be recommending
    several such libraries, but of course, there are many more that you could use.
  prefs: []
  type: TYPE_NORMAL
- en: Going the straightforward JavaScript way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest causes of side effects was the possibility of a function
    modifying its arguments or global objects. All non-primitive objects are passed
    as references, so if/when you modify them, the original objects will be changed.
    If we want to stop this (without just depending on the goodwill and clean coding
    of our developers), we may want to consider some straightforward JavaScript techniques
    to prohibit those side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding mutator functions that directly modify the object that they are applied
    to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `const` declarations to prevent variables from being changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freezing objects so that they can’t be modified in any way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating (changed) clones of objects to avoid modifying the original
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using getters and setters to control what is changed and how
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a functional concept – *lenses* – to access and set attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at each technique in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Mutator functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common source of unexpected problems is that several JavaScript methods are
    mutators that modify the underlying object. (Refer to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods)
    for more on mutators.) In this case, by merely using these methods, you will be
    causing a side effect that you may not even be aware of. Arrays are the most basic
    sources of problems, and the list of troublesome methods isn’t short:'
  prefs: []
  type: TYPE_NORMAL
- en: '`copyWithin()` lets you copy elements within an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill()` fills an array with a given value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push()` and `pop()` let you add or delete elements at the end of an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shift()` and `unshift()` work in the same way as `push()` and `pop()` but
    at the beginning of an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splice()` lets you add or delete elements anywhere within an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse()` and `sort()` modify an array in place, reversing or sorting its
    elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example we saw in the *Argument mutation* section of
    [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*,* *Behaving Properly*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `maxStrings()` function returns the highest value in an array, but also
    modifies the original array; this is a side effect of the `sort()` and `pop()`
    mutator functions. In this case and others, you might generate a copy of the array
    and then work with that; both the spread operator and `.slice()` are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both new versions of our `maxStrings()` functions are now functional, without
    side effects, because the mutator methods have been applied to copies of the original
    argument. By the way, if you are wondering about the `as string` part in both
    new functions, it’s because TypeScript warns you that the array might be empty,
    and I’m telling it that I guarantee the array won’t be so.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, setter methods are also mutators and will logically produce side
    effects because they can do just about anything. If this is the case, you’ll have
    to go for some of the other solutions described later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the mutations don’t happen because of the use of some JavaScript methods,
    then we might want to attempt to use `const` definitions, but unfortunately, that
    just won’t work. In JavaScript, `const` means that the *reference* to the object
    or array cannot change (you cannot assign a different object to it), but you can
    still modify its properties. We can see this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You cannot modify the value of `myObj` by assigning it a new value, but you
    can modify its current value so that only the reference to an object is constant,
    not the object’s values themselves. (By the way, this would have also happened
    with arrays.) So, if you use `const` everywhere, you will only be safe against
    direct assignments to objects and arrays. More modest side effects, such as changing
    an attribute or an array element, will still be possible, so this is not a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Two methods can work – *freezing* to provide unmodifiable structures, and *cloning*
    to produce modified new ones. These are probably not the best ways to go about
    forbidding objects from being changed, but they can be used as a makeshift solution.
    Let’s look at them in more detail, starting with freezing.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to avoid the possibility of a programmer accidentally or willingly
    modifying an object, freezing it is a valid solution. After an object has been
    frozen, any attempts at modifying it will silently fail – JavaScript won’t report
    an error or throw an exception, but it won’t alter the object either.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, if we attempt to make the same changes we made in
    the previous section, they won’t have any effect, and `myObj` will be unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Sealing or freezing?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t confuse freezing with sealing – `Object.seal()`, when applied to an object,
    prohibits you from adding or deleting properties to it. This means that the object’s
    structure is immutable, but the attributes themselves can be changed. `Object.freeze()`
    covers not only sealing properties but also making them unchangeable. See [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)
    and [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
    for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one problem with this solution – freezing an object is a shallow
    operation that freezes the attributes themselves, similar to what a `const` declaration
    does. If any of the attributes are objects or arrays themselves they can still
    be modified. We will only be considering data here; you may also want to freeze,
    say, functions, but for most use cases, it’s data you want to protect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only partially successful, as we can see when we try changing some
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Modifying `myObj3.d` doesn’t work because the object is frozen, but that doesn’t
    extend to objects within `myObj3`, so changing `myObj3.o.f.a` does work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to achieve real immutability for our object, we need to write a
    routine that will freeze all the levels of an object. Fortunately, it’s easy to
    achieve this by applying recursion. (We saw similar applications of recursion
    in the *Traversing a tree structure* section of the previous chapter.) Mainly,
    the idea is to freeze the object itself and then recursively freeze each of its
    properties. We must ensure that we only freeze the object’s own properties; we
    shouldn’t mess with the prototype of the object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the same way that `Object.freeze()` works, `deepFreeze()` also
    freezes the object in place. I wanted to keep the original semantics of the operation
    so that the returned object would always be the original one. If we wanted to
    work in a purer fashion, we should make a copy of the original object first (we’ll
    learn how to do this in the next section) and then freeze that. As for TypeScript,
    the returned value is the same type as the input; the object being frozen makes
    no difference with regard to types.
  prefs: []
  type: TYPE_NORMAL
- en: A small possible problem remains, but with a very bad result – what would happen
    if an object included a reference to itself? We can avoid this if we skip freezing
    already frozen objects; backward circular references would be ignored, since the
    objects they refer to would already be frozen. So, the logic we wrote took care
    of that problem, and there’s nothing more to be done!
  prefs: []
  type: TYPE_NORMAL
- en: If we apply `deepFreeze()` to an object, we can safely pass it to any function,
    knowing there is no way in which it can be modified. You can also use this property
    to test whether a function modifies its arguments – deep-freeze them, call the
    function, and if the function depends on modifying its arguments, it won’t work
    because the changes will be silently ignored. So, how can we return a result from
    a function if it involves a received object? This can be solved in many ways.
    A simple one uses cloning, as we’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we dealt with one of the methods we can use to avoid changes
    in objects. (Check the *Questions* section at the end of this chapter for another
    way of freezing objects by means of proxies.) Now, let’s look at an alternative
    involving cloning.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning and mutating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If mutating an object isn’t allowed, you must create a new one. For example,
    if you use Redux, a reducer is a function that receives the current state and
    an action (essentially, an object with new data) and produces the new state. Modifying
    the current state is totally forbidden, and we could avoid this error by always
    working with frozen objects, as we saw in the previous section. To fulfill the
    reducer’s requirements, we have to be able to clone the original state, as well
    as mutate it according to the received action. The resulting object will become
    the new state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To round things off, we should also freeze the returned object, just like we
    did with the original state. But let’s start at the beginning – how do we clone
    an object? Of course, you can always do this by hand, but that’s not something
    you’d want to consider when working with large, complex objects. (You may want
    to revisit the *More general looping* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, where we wrote a basic `objCopy()` function that
    provides a different approach from the one we’ll show here.) For example, if you
    wanted to clone `oldObject` to produce `newObject`, doing it by hand would imply
    a lot of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This manual solution is obviously a lot of work, and error-prone as well; you
    could easily forget an attribute! Going for more automatic solutions, there are
    a couple of straightforward ways of copying arrays or objects in JavaScript, but
    they have the same shallowness problem. You can make a (shallow) copy of an object
    with `Object.assign()` or by spreading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a (shallow) copy of an array, you can either use `slice()` or spreading,
    as we saw in the *Mutator functions* section earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s the problem with these solutions? If an object or array includes objects
    (which may themselves include objects), we get the same problem that we had when
    freezing – objects are copied by reference, which means that a change in the new
    object will also change the old object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, note what happened when we changed some properties of `newObject`.
    Changing `newObject.d` worked fine, but changing `newObject.o.f.a` also impacted
    `oldObject`, since `newObject.o` and `oldObject.o` actually refer to the very
    same object.
  prefs: []
  type: TYPE_NORMAL
- en: New age, old section
  prefs: []
  type: TYPE_NORMAL
- en: Since 2022, a new `structuredClone()` function has been available, so if your
    browser supports it, the code on these pages won’t be needed. For more information,
    check out [developer.mozilla.org/en-US/docs/Web/API/structuredClone](http://developer.mozilla.org/en-US/docs/Web/API/structuredClone).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a simple solution to this, based on JSON. If we `stringify()` the
    original object and then `parse()` the result, we’ll get a new object that’s totally
    separate from the old one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `JSON.stringify()`, we can convert our object into a string. Then,
    `JSON.parse()` creates a (new) object out of that string – simple! This works
    with both arrays and objects, but there’s a problem. If any object’s properties
    have a constructor, they won’t be invoked; the result will always be composed
    of plain JavaScript objects. (This is not the only problem with `jsonCopy()`;
    see *Question 10.2*.) We can see this very simply with `Date()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While `myDate` is an object, `newDate` turns out to be a string with a value,
    the date and time at the moment we did the conversion, "`2023-01-15T09:23:55.125Z`".
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do a recursive solution, just like we did with deep freezing, and
    the logic is quite similar. Whenever we find a property that is really an object,
    we invoke the appropriate constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we find that a property of an object is actually another object, we
    invoke its constructor before continuing. This solves the problem we found with
    dates or, in fact, with any object! If we run the preceding code but use `deepCopy()`
    instead of `jsonCopy()`, we’ll get `object object` as output, as it should be.
    If we check the types and constructors, everything will match.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a need for a minor hack because TypeScript works better with classes
    than with constructor functions – writing `obj as any` gets type checking to work,
    but it’s not very nice. Also, we need to write `prop as keyof O` because, otherwise,
    TypeScript would protest that `prop` could be anything, not necessarily a key
    of the original type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data-changing experiment will also work fine now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s check out the last few lines. Modifying `newObject` had no impact on `oldObject`,
    so both objects are completely separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to copy an object, we can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive a (frozen) object as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of it, which won’t be frozen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take values from that copy that we can use in our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the copy at will.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Freeze it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return it as the result of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of this is viable, though a bit cumbersome. Also, there are some limitations
    – we won’t be able to duplicate private properties or properties that involve
    symbols, we won’t duplicate getters and setters, and metadata-related features
    will also be missing. Let’s accept that, and add a couple of functions that will
    help bring everything together.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When following the steps provided at the end of the previous section, you may
    have noticed that every time you want to update a field, things become troublesome
    and prone to errors. Let’s use a common technique to add a pair of functions:
    getters and setters. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Getters* can be used to get values from a frozen object by unfreezing them
    so that they can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setters* allow you to modify any property of an object. You can do this by
    creating a new and updated version, leaving the original untouched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s build our getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the *Getting a property from an object* section in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we wrote a simple `getField()` function that could handle
    getting a single attribute from an object. (See *Question 6.13* in that chapter
    for the missing companion `setField()` function.) Let’s take a look at how we
    can code this. We can have a straightforward version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even go one better by applying currying so that we have a more general
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We could get a deep attribute from an object by composing a series of `getField()`
    applications, but that would be rather cumbersome. Instead, let’s create a function
    that will receive a path – an array of field names – and return the corresponding
    part of the object, or be undefined if the path doesn’t exist. Using recursion
    is appropriate here and simplifies coding! Observe the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we look for the first string in the path to see whether it exists
    in the object. If it doesn’t, the operation fails, so we return `undefined`. If
    successful, and we still have more strings in the path, we use recursion to keep
    digging into the object; otherwise, we return a deep copy of the attribute’s value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an object has been frozen, we cannot defrost it, so we must resort to
    making a new copy of it; `deepCopy()` is appropriate for doing this. Let’s try
    out our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check that returned objects are not frozen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we could directly update the `fObj` object, which means
    it wasn’t frozen. Now that we’ve written our getter, we can create a setter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a property by path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can code a similar `setByPath()` function that will take a path, a
    value, and an object and update an object. This is not a pure function, but we’ll
    use it to write a pure one – wait and see! Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using recursion to get into the object, creating new attributes
    if needed, until we have traveled the entire length of the path. One crucial detail
    when creating attributes is whether we need an array or an object. (And why the
    `as any` cast for `obj`? That’s an issue with TypeScript, which objects to `obj[arr[0]]`,
    so we must “trick” it. Weirdly, using `Reflect.set()` also works!) We can determine
    that by checking the next element in the path – if it’s a number, then we need
    an array; otherwise, an object will do.
  prefs: []
  type: TYPE_NORMAL
- en: When we get to the end of the path, we assign the new given value.
  prefs: []
  type: TYPE_NORMAL
- en: Seamless, immutable objects
  prefs: []
  type: TYPE_NORMAL
- en: If you like this way of doing things, check out the `seamless-immutable` library,
    which works in this fashion. The seamless part of the name alludes to the fact
    that you still work with normal objects – albeit frozen – which means you can
    use `map()`, `reduce()`, and so on. You can read more about this at [github.com/rtfeldman/seamless-immutable](http://github.com/rtfeldman/seamless-immutable).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can write a function that will be able to take a frozen object and
    update an attribute within it, returning a new, also frozen, object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check out how it works. To do this, we’ll run several updates on the
    `myObj3` object we have been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this pair of functions, we have finally gotten ourselves a way to keep
    immutability:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects must be frozen from the beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data from objects is done with `getByPath()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting data is done with `updateObject()`, which internally uses `setByPath()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned how to get and set values from an object in a way
    that keeps objects immutable. Let’s now look at a variation of this concept –
    **lenses** – that will allow us to not only get and set values but also apply
    a function to the data.
  prefs: []
  type: TYPE_NORMAL
- en: Lenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s another way to get and set values, which goes by the name of *optics*,
    and includes *lenses* (which we’ll study now) and *prisms* (which we’ll look at
    later in this chapter). What are lenses? They are functional ways of focusing
    (another optical term!) on a given spot in an object so that we can access or
    modify its value in a non-mutating way. In this section, we’ll look at some examples
    of the usage of lenses and consider two implementations – first, a simple one
    based on objects, and then a more complete one that’s interesting because of some
    of the techniques we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: Working with lenses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both implementations will share basic functionality, so let’s start by skipping
    what lenses are or how they are built and look at some examples of their usage
    instead. First, let’s create a sample object that we will work with – some data
    about a writer (his name sounds familiar...) and his books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall assume that several functions exist; we’ll see how they are implemented
    in upcoming sections. A lens depends on having a getter and a setter for a given
    attribute, and we can build one by directly using `lens()`, or `lensProp()` for
    briefer coding. Let’s create a lens for the `user` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a lens that focuses on the `user` attribute. Since this is a common
    operation, it can also be written more compactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Both these lenses allow us to focus on the `user` attribute of whatever object
    we use them with. With lenses, there are three basic operations, and we’ll follow
    tradition by using the names that most (if not all) libraries follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`view()`: Used to access the value of an attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set()`: Used to modify the value of an attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`over()`: Used to apply a function to an attribute and change its value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s assume the functions are curried, as we saw in the previous chapter.
    So, to access the `user` attribute, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `view()` function takes a lens as its first parameter. When applied to
    an object, it produces the value of whatever the lens focuses on – in our case,
    the `user` attribute. Of course, you could apply sequences of `view()` functions
    to get to deeper parts of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this section on optics, we’ll always go with fully curried functions, not
    only for variety but because that’s usually how those functions are applied, as
    you’ll see in any textbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing such a series of `view()` calls, we’ll compose lenses so
    that we can focus more deeply on an object. Let’s take a look at one final example,
    which shows how we access an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the future, should there be any change in the author structure, a simple
    change in the `lensBooks` definition would be enough to keep the rest of the code
    unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Lenses elsewhere?
  prefs: []
  type: TYPE_NORMAL
- en: You can also use lenses to access other structures; refer to *Question 10.8*
    for a way to use lenses with arrays, and *Question 10.9* for how to use lenses
    so that they work with maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the `set()` function allows us to set the value of the focus of
    the lens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result of `set()` is a new object with a changed value. Using this function
    in a fully curried style may be surprising, but if we used our `curry()` or `partialCurry()`
    function from earlier chapters, we could write `set(lens1, "FEFK", author)` as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `over()` is similar in that a new object is returned, but in this case,
    the value is changed by applying a mapping function to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A fundamental question is, why is `user` equal to `"fkerekifkerekifkereki"`
    and not `"FEFKFEFKFEFK"`? Our lens does not modify an object when using the setter
    but instead provides a new one, so we’re applying `triple()` to the original object’s
    user attribute.
  prefs: []
  type: TYPE_NORMAL
- en: There are more functions you can do with lenses, but we’ll just go with these
    three for now. (Here’s a suggestion – take a look at *Question 10.7* for an interesting
    idea on how to use lenses to access virtual attributes that don’t actually exist
    in an object.)
  prefs: []
  type: TYPE_NORMAL
- en: To finish this section, I’d recommend looking at some third-party optics libraries
    ([github.com/stoeffel/awesome-fp-js#lenses](http://github.com/stoeffel/awesome-fp-js#lenses)
    and [tinyurl.com/jslenses](http://tinyurl.com/jslenses) have several suggestions)
    to get a glimpse into all the available functionality. Now that we have an idea
    of what to expect when using lenses, let’s learn how to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing lenses with objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to implement a lens is by representing it with an object with
    just two properties – a getter and a setter. In this case, we’d have something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve already seen similar `getField()` and `setField()` functions; the former
    gets a specific attribute from an object, and the latter returns a new object
    with a single changed attribute. We can now define our `lens`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is easy to understand – given a getter and a setter, `lens()` creates
    an object with those two attributes, and `lensProp()` creates a getter/setter
    pair by using `getField()` and `setField()` with `lens()`, which is very straightforward.
    Now that we have our lens, how do we implement the three basic functions we saw
    in the previous section? Viewing an attribute requires applying the getter; to
    maintain a curried style, let’s do currying by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The generic `LENS<>` type is the type of whatever the `lens()` function returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, setting an attribute is a matter of applying the setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, applying a mapping function to an attribute is a *two-for-one* operation
    – we use the getter to get the current value of the attribute, we apply the function
    to it, and we use the setter to store the calculated result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This needs to be studied carefully. We use the lens’s `getter()` function to
    get some attribute from the input object, we apply the mapping function to the
    obtained value, and we use the lens’s `setter()` function to produce a new object
    with the changed attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can do all three operations, we have working lenses! What about
    composition? Lenses have a peculiar characteristic – they’re composed backward,
    left to right, so you start with the most generic and end with the most specific.
    That certainly goes against intuition; we’ll learn about this in more detail in
    the next section, but for now, we’ll keep with tradition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is sort of impressive but not too hard to understand. The getter for
    the composition of two lenses is the result of using the first lens’s getter and
    then applying the second lens’s getter to that result. The setter for the composition
    is a tad more complex, but follows along the same lines; can you see how it works?
    Now, we can compose lenses easily; let’s start with an invented nonsensical object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define a few lenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try composing our new lens in a couple of ways, just for variety, to
    check that everything works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With `lCEGJ1`, we composed some lenses, starting with the latter ones. With
    `lCEGJ2`, we started with the lenses at the beginning, but the results are the
    same. Now, let’s try setting some values. We want to get down to the `k` attribute
    and set it to `60`. We can do this by using the same lens we just applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The composed lens worked perfectly, and the value was changed. (Also, a new
    object was returned; the original is unmodified, as we wanted.) To finish, let’s
    verify that we can use `over()` with our lens and try to duplicate the `k` value
    so that it becomes `22`. Just for variety, let’s use the other composed lens,
    even though we know that it works in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have learned how to implement lenses in a simple fashion. However, let’s
    consider a different way of achieving the same objective by using actual functions
    to represent a lens. This will allow us to do composition in the standard way,
    without needing any special lens function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing lenses with functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous implementation of lenses with objects works well, but we want to
    look at a different way of doing things that will let us work with more advanced
    functional ideas. This will involve some concepts we’ll be analyzing in more detail
    in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*,
    but here, we’ll use just what we need so that you don’t have to go and read that
    chapter now! Our lenses will work the same way the preceding ones did, except
    that since they will be functions, we’ll be able to compose them with no special
    composing code.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the key concept here? A lens will be a function, based on a getter and
    a setter pair, that will construct a *container* (actually an object, but let’s
    go with the container name) with a `value` attribute and a `map` method (in [*Chapter
    12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*, we’ll see
    that this is a *functor*, but you don’t need to know that now). By having specific
    mapping methods, we’ll implement our `view()`, `set()`, and `over()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `lens()` function is as follows. We’ll explain the details of this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `getter` and `setter` parameters are the same as before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fn` function is the “magic sauce” that makes everything work; depending
    on what we want to do with the lens, we’ll provide a specific function. There’ll
    be more on this later!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `obj` parameter is the object we want to apply the lens to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s code our `view()` function. For this, we’ll need an auxiliary class,
    `Constant`, that, given a value, `v`, produces a container with that value and
    a `map` function that returns the very same container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can now code `view()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What happens here? Let’s follow this step by step; it’s a bit tricky!
  prefs: []
  type: TYPE_NORMAL
- en: We use `lensProp()` to create a lens focusing on the `user` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `view()` function passes the constant-building function to `lens()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `lens()` function uses the getter to access the user attribute in the `author`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the value we receive is used to create a constant container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `map()` method is invoked, which returns the very same container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `value` attribute of the container is accessed, and that’s the value that
    the getter retrieved in *step* *3*. Wow!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that under our belt, let’s move on to `set()` and `over()`, which will
    require a different auxiliary function to create a container whose value may vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case (as opposed to `Constant` objects), the `map()` method really
    does something – when provided with a function, it applies it to the value of
    the container and returns a new `Variable` object, with the resulting value. The
    `set()` function can be implemented now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this case, when the lens invokes the container’s `map()` method, it will
    produce a new container with a new value, which makes all the difference. To understand
    how this works, follow the same six steps we saw for `get()` – the only difference
    will be in *step 5*, where a new, different container is produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve survived this (tricky indeed!) code, the `over()` function is
    simple, and the only difference is that instead of mapping to a given value, you
    use the mapping `mapfn` function provided to compute the new value for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the difference between `set()` and `over()` is that, in the
    former case, you provide a value to replace the original one, while in the latter
    case, you provide a function to calculate the new value. Other than that, both
    are similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, let’s verify that `compose()` can be applied to our functor-based
    lenses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created two individual lenses for `name` and `last`, and we composed
    them with the very same `compose()` function that we developed back in [*Chapter
    8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*. Using this composite
    lens, we focused on the author’s last name without any problem, so everything
    worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Wrong direction?
  prefs: []
  type: TYPE_NORMAL
- en: It seems to go against logic that lenses should be composed from left to right;
    this appears to be backward. This is something that troubles developers, and if
    you google for an explanation, you’ll find many. To answer this question on your
    own, I suggest spelling out how `compose()` works in full – two functions will
    be enough – and then substitute the definitions of lenses; you’ll see why and
    how everything works out.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at lenses, we can move on and look at **prisms**, another
    optics tool.
  prefs: []
  type: TYPE_NORMAL
- en: Prisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous section, lenses are useful for working with product
    types. However, prisms are useful for working with *sum* types. But what are they?
    (We’ll look at products and unions in more detail in the last chapter of the book.)
    Whereas a product type is always built out of the same options, such as an object
    from a class, a sum type will likely have different structures – extra or missing
    attributes, for example. When you use a lens, you assume that the object you’ll
    be applying it to has a known structure with no variations, but what do you use
    if the object has different structures? The answer is prisms. Let’s look at how
    they are used first; then, we’ll examine their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with prisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with prisms is similar to using lenses, except for what happens when
    an attribute is not present. Let’s take a look at an example from the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to access the `user` attribute using prisms, we would write something
    like the following (and don’t worry about the details now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a prism using a `prismProp()` function, which parallels our
    previous `lensProp()`. Then, we use the prism with the `preview()` function, which
    is analogous to `get()` with lenses, and the result is the same as if we had used
    lenses – no surprises there. What would have happened if we had asked for a non-existing
    pseudonym attribute? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we may not see any differences, but let’s see what happens if we try
    to compose lenses or prisms with several missing attributes. Say you wanted to
    access a (missing!) `pseudonym.usedSince` attribute with lenses, without taking
    precautions and checking that the attributes exist. Here, you would get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, since prisms already take missing values into account, this
    would cause no problems, and we’d get an `undefined` result; that’s why `preview()`
    is sometimes called `getOptional()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if we want to set a value? The analogous function to `set()` is
    `review()`; let’s look at how it would work. The idea is that whatever attribute
    we specify will be set if, and only if, the attribute already exists. So, if we
    attempt to change the `user.name` attribute, this will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we try to modify the (non-existent) `pseudonym` attribute, the
    original, unchanged object will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: So, using prisms takes care of all possible missing or optional fields. How
    do we implement this new optics type? New names are used (`preview()` and `review()`
    instead of `get()` and `set()`), but that difference is minor. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing prisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How do we implement prisms? We will take our cue from our lens implementation
    and make a few changes. When getting an attribute, we must check whether the object
    we are processing is not `null` or `undefined` and whether the attribute we want
    is in the object. We can make do with small changes to our original `getField()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re checking for the existence of the object and the attribute – if
    everything’s okay, we return `obj[attr]`; otherwise, we return `undefined`. The
    changes for `setField()` are very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If the object and the attribute both exist, we return a new object by changing
    the attribute’s value; otherwise, we return a copy of the object. That’s all there
    is to it! Defining the other functions is directly based on `lens()`, `lensProp()`,
    and so on, so we’ll skip that.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to access objects in functional ways, let’s analyze
    persistent data structures that can be modified very efficiently without the need
    for a full copy of the original object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating persistent data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to change something in a data structure and you just go and change
    it, your code will be full of side effects. On the other hand, copying complete
    structures every time is a waste of time and space. There’s a middle ground to
    this that has to do with persistent data structures, which, if handled correctly,
    let you apply changes while creating new structures efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that there are many possible data structures you could work with, let’s
    just take a look at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with lists, one of the simplest data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with objects, a very common necessity in JavaScript programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with arrays, which will prove to be harder to work with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Working with lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider a simple procedure – suppose you have a list and want to add
    a new element to it. How would you do this? Here, we can assume that each node
    is a `NodeList` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: A possible list would be as shown in the following figure – a `list` variable
    would point to the first element. Look at the following diagram; can you tell
    what is missing in the list, and where?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The initial list](img/Figure_10.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The initial list
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to add D between B and F (the sample list represents a concept
    that musicians will understand, the *Circle of Thirds*, but with the D note missing),
    the simplest solution would be to add a new node and change an existing one. This
    would result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The list now has a new element – we had to modify an existing
    one to perform the addition](img/Figure_10.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The list now has a new element – we had to modify an existing
    one to perform the addition
  prefs: []
  type: TYPE_NORMAL
- en: 'However, working in this way is obviously non-functional, and we are clearly
    modifying data. There is a different way of working – creating a persistent data
    structure in which all the alterations (insertions, deletions, and modifications)
    are done separately, being careful not to modify existing data. On the other hand,
    if some parts of the structure can be reused, this is done to gain performance.
    Doing a persistent update would return a new list, with some nodes that are duplicates
    of some previous ones but no changes whatsoever to the original list. This can
    be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The dotted elements show the newly returned list, which shares
    some elements with the old one](img/Figure_10.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The dotted elements show the newly returned list, which shares
    some elements with the old one
  prefs: []
  type: TYPE_NORMAL
- en: Updating a structure this way requires duplicating some elements to avoid modifying
    the original structure, but part of the list is shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we will also deal with updates or deletions. Starting again with
    the list shown in the following diagram, if we wanted to update its fourth element,
    the solution would imply creating a new subset of the list, up to and including
    the fourth element, while keeping the rest unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Our list, with a changed element](img/Figure_10.4_B19301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Our list, with a changed element
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an element would also be similar. Let’s do away with the third element,
    F, in the original list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 — The original list, after removing the third element in a persistent
    way](img/Figure_10.5_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 — The original list, after removing the third element in a persistent
    way
  prefs: []
  type: TYPE_NORMAL
- en: Working with lists or other structures can always be solved to provide data
    persistence. For now, focus on what will probably be the most important kind of
    work for us – dealing with simple JavaScript objects. After all, all data structures
    are JavaScript objects, so if we can work with objects, we can work with other
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Updating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method can also be applied to more common requirements, such as modifying
    an object. This is a very good idea for, say, Redux users – a reducer can be programmed
    to receive the old state as a parameter and produce an updated version with the
    minimum needed changes, without altering the original state in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you had the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume you wanted to modify the value of the `myObj.d.f` attribute but
    in a persistent way. Instead of copying the entire object (with the `deepCopy()`
    function we wrote earlier), we could create a new object, with several attributes
    in common with the previous object but new ones for the modified ones. This can
    be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – A persistent way of editing an object – that is, by sharing
    some attributes and creating others](img/Figure_10.6_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – A persistent way of editing an object – that is, by sharing some
    attributes and creating others
  prefs: []
  type: TYPE_NORMAL
- en: The old and new objects share most of the attributes, but there are new `d`
    and `f` attributes, so you managed to minimize the changes when creating the new
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to do this by hand, you would have to write, in a very cumbersome
    way, something like the following. Most attributes are taken from the original
    object, but `d` and `d.f` are new:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw some similar code earlier in this chapter when we decided to work on
    a cloning function. Here, let’s go for a different type of solution. In fact,
    this kind of update can be automated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The logic is recursive, but not too complex. First, we figure out, at the current
    level, what kind of object we need – an array or an object. Then, we copy all
    the attributes from the original object to the new one, except the property we
    are changing. Finally, we set that property to the given value (if we have finished
    with the path of property names), or we use recursion to go deeper with the copy.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering parameters
  prefs: []
  type: TYPE_NORMAL
- en: Note the order of the parameters – first, the path, then the value, and finally,
    the object. We are applying the concept of putting the most stable parameters
    first and the most variable last. If you curry this function, you can apply the
    same path to several different values and objects, and if you fix the path and
    the value, you can still use the function with different objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give this logic a try. We’ll start with a nonsensical object but with
    several levels, and even an array of objects for variety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this by changing `myObj.d.f` to a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The logs at the bottom verify that the algorithm is working correctly – `myObj2.d`
    is a new object, but `myObj2.d.g` is reusing the value from `myObj1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the array in the second object lets us test how the logic works in
    those cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We can compare the elements in the `myObj1.d.j` array with the ones in the newly
    created object. You will see that the array is a new one, but two of the elements
    (the ones that weren’t updated) are still the same objects that were in `myObj1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This obviously isn’t enough to get by. Our logic can update an existing field
    or even add it if it wasn’t there, but you’d also need to eliminate an old attribute.
    Libraries usually provide many more functions, but let’s work on the deletion
    of an attribute for now so that we can look at some of the other important structural
    changes we can make to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic here is similar to that of `setIn()`. The difference is that we don’t
    always copy all the attributes from the original object to the new one; we only
    do that if we haven’t arrived at the end of the array of path properties. Continuing
    with the series of tests after the updates, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: With this pair of functions, we can manage to work with persistent objects by
    making changes, additions, and deletions in an efficient way that won’t create
    new objects needlessly.
  prefs: []
  type: TYPE_NORMAL
- en: A tip
  prefs: []
  type: TYPE_NORMAL
- en: The most well-known library for working with immutable objects is the appropriately
    named `immutable.js`, which can be found at [immutable-js.com/](http://immutable-js.com/).
    The only weak point about it is its notoriously obscure documentation. However,
    there’s an easy solution – check out *The Missing Immutable.js Manual* with all
    the examples you’ll ever need at [untangled.io/the-missing-immutable-js-manual/](http://untangled.io/the-missing-immutable-js-manual/),
    and you won’t have any trouble!
  prefs: []
  type: TYPE_NORMAL
- en: A final caveat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with persistent data structures requires some cloning, but how would
    you implement a persistent array? If you think about this, you’ll realize that,
    in that case, there would be no way out apart from cloning the whole array after
    each operation. This would mean that an operation such as updating an element
    in an array, which took a constant time, would now take a length of time proportional
    to the size of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity concerns
  prefs: []
  type: TYPE_NORMAL
- en: In algorithm complexity terms, updates went from being O(1) operations to O(*n*)
    ones. Similarly, access to an element may become an O(*log n*) operation, and
    similar slowdowns might be observed for other operations, such as mapping and
    reducing.
  prefs: []
  type: TYPE_NORMAL
- en: How do we avoid this? There’s no easy solution. For example, you may find that
    an array is internally represented as a binary search tree (or even more complex
    data structures) and that the persistence library provides the necessary interface
    so that you’ll still be able to use it as an array, not noticing the internal
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: When using this kind of library, the advantages of having immutable updates
    without cloning may be partially offset by some operations that may become slower.
    If this becomes a bottleneck in your application, you might have to go so far
    as changing the way you implement immutability or even work out how to change
    your basic data structures to avoid the time loss, or at least minimize it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at two different approaches (used by commonly available
    immutability libraries) to avoiding side effects by working with immutable objects
    and data structures – one based on using JavaScript’s object freezing, plus some
    special logic for cloning, and the other based on applying the concept of persistent
    data structures with methods that allow all kinds of updates, without changing
    the original or requiring full cloning.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing Design Patterns*,
    we will focus on a question often asked by object-oriented programmers – how are
    design patterns used in FP? Are they required, available, or usable? Are they
    still practiced but with a new focus on functions rather than on objects? We’ll
    answer these questions with several examples, showing where and how they are equivalent
    or how they differ from the usual OOP practices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 10.1 `jsonCopy()` function has problems with dates, but that’s not all. What
    happens if we try to copy objects that include maps? Sets? Regular expressions?
    Functions?
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 `jsonCopy()`; how does `deepCopy()` fare with the same kind of objects?
    Can it be enhanced?
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 `JSON.stringify()` will protest if dealing with such. How could you fix
    our `deepCopy()` function to avoid that problem? We did deal with that issue in
    the `deepFreeze()` function, but that solution cannot be used here; something
    different is required.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 `freezeByProxy(obj)` function that will apply this idea to forbid all kinds
    of updates (adding, modifying, or deleting properties) for an object. Remember
    to work recursively if an object has other objects as properties!
  prefs: []
  type: TYPE_NORMAL
- en: '10.5 `insertAfter(list, newKey, oldKey)` function that will create a new list,
    but add a new node with `newKey` just after the node with `oldKey`. Here, you’ll
    need to assume that the nodes in the list were created by the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 10.6 `composeLenses()` function that will allow you to compose as many simple
    lenses as you want, instead of only two, as in `composeTwoLenses()`, along the
    same lines as what we did in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,
    Connecting Functions**,*when we moved from `composeTwo()` to a generic `compose()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 `getField()` and `setField()`. Then, we used composition to access deeper
    attributes. Can you create a lens by giving a path, allowing shorter code?
  prefs: []
  type: TYPE_NORMAL
- en: '10.8 `author` and return the author’s full name in LAST NAME, FIRST NAME format?
    Second, can you write a setter that, given a full name, will split it in half
    and set its first and last names? With those two functions, you could write the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 10.9 **Lenses for arrays?** What would happen if you created a lens like in
    the following code and applied it to an array? If there’s a problem, could you
    fix it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '10.10 `lensMap()` function to create a lens you can use to access and modify
    maps. You may want to look at the following for more information about cloning
    maps: [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).
    Your function should be declared as follows. You’ll have to write a couple of
    auxiliary functions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
