- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Ensuring Purity – Immutability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保纯净性 – 不可变性
- en: In [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, when
    we considered pure functions and their advantages, we saw that side effects such
    as modifying a received argument or a global variable were frequent causes of
    impurity. Now, after several chapters dealing with many aspects and tools of FP,
    let’s talk about the concept of *immutability* – how to work with objects in such
    a way that accidentally modifying them will become harder or, even better, impossible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第4章*](B19301_04.xhtml#_idTextAnchor069) *行为规范* 中，当我们考虑纯函数及其优势时，我们看到修改接收到的参数或全局变量等副作用是导致不纯的常见原因。现在，在处理FP的许多方面和工具的几个章节之后，让我们来谈谈
    *不可变性* 的概念——如何以这种方式处理对象，使得意外修改它们变得更困难，甚至更好，变得不可能。
- en: 'We cannot force developers to work in a safe, guarded way. Still, if we find
    some way to make data structures immutable (meaning that they cannot be directly
    changed, except through some interface that never allows us to modify the original
    data and produces new objects instead), then we’ll have an enforceable solution.
    In this chapter, we will look at two distinct approaches to working with such
    immutable objects and data structures:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能强迫开发者以安全、受保护的方式工作。然而，如果我们找到一种方法使数据结构不可变（这意味着它们不能直接更改，除非通过一些接口，该接口永远不会允许我们修改原始数据，而是产生新的对象），那么我们将有一个可执行的解决方案。在本章中，我们将探讨两种不同的方法来处理这样的不可变对象和数据结构：
- en: '*Basic JavaScript ways*, such as freezing objects, plus cloning to create new
    ones instead of modifying existing objects'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本的JavaScript方法*，如冻结对象，以及克隆以创建新对象而不是修改现有对象'
- en: '*Persistent data structures*, with methods that allow us to update them without
    changing the original and without the need to clone everything either, for higher
    performance'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持久数据结构*，具有允许我们更新它们而不改变原始数据，也不需要克隆一切的方法，以提高性能'
- en: Warning!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！
- en: The code in this chapter isn’t production-ready; I wanted to focus on the main
    points and not on all the myriad details concerning properties, getters, setters,
    lenses, prototypes, and so on that you should take into account for a full, bulletproof
    solution. For actual development, I recommend going with a third-party library,
    but only after checking that it really applies to your situation. We’ll be recommending
    several such libraries, but of course, there are many more that you could use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码不是生产就绪的；我想专注于主要观点，而不是所有关于属性、获取器、设置器、透镜、原型等细节，这些细节你应该考虑到一个完整、无懈可击的解决方案。对于实际开发，我建议使用第三方库，但只有在确认它确实适用于你的情况之后。我们将推荐几个这样的库，但当然，还有更多你可以使用的库。
- en: Going the straightforward JavaScript way
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接使用JavaScript的方式
- en: 'One of the biggest causes of side effects was the possibility of a function
    modifying its arguments or global objects. All non-primitive objects are passed
    as references, so if/when you modify them, the original objects will be changed.
    If we want to stop this (without just depending on the goodwill and clean coding
    of our developers), we may want to consider some straightforward JavaScript techniques
    to prohibit those side effects:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的副作用之一是函数修改其参数或全局对象的可能性。所有非原始对象都作为引用传递，所以如果你/当你修改它们时，原始对象将会改变。如果我们想阻止这种情况（而不仅仅依赖于开发者的善意和良好的编码习惯），我们可能需要考虑一些简单的JavaScript技术来禁止这些副作用：
- en: Avoiding mutator functions that directly modify the object that they are applied
    to
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免直接修改它们所应用的对象的突变函数
- en: Using `const` declarations to prevent variables from being changed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `const` 声明来防止变量被更改
- en: Freezing objects so that they can’t be modified in any way
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冻结对象，使其无法以任何方式被修改
- en: Creating (changed) clones of objects to avoid modifying the original
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建（更改）对象的副本以避免修改原始对象
- en: Using getters and setters to control what is changed and how
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用获取器和设置器来控制更改的内容和方式
- en: Using a functional concept – *lenses* – to access and set attributes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数式概念 – *透镜* – 来访问和设置属性
- en: Let’s take a look at each technique in more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每种技术。
- en: Mutator functions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突变函数
- en: 'A common source of unexpected problems is that several JavaScript methods are
    mutators that modify the underlying object. (Refer to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods)
    for more on mutators.) In this case, by merely using these methods, you will be
    causing a side effect that you may not even be aware of. Arrays are the most basic
    sources of problems, and the list of troublesome methods isn’t short:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的不期望问题的来源是，有几个JavaScript方法是突变者，它们会修改底层对象。（有关突变者的更多信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods)。）在这种情况下，仅仅使用这些方法，您就会产生可能甚至没有意识到的副作用。数组是最基本的问题来源，而问题方法列表并不短：
- en: '`copyWithin()` lets you copy elements within an array'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copyWithin()`允许您在数组内部复制元素'
- en: '`fill()` fills an array with a given value'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill()`用给定的值填充数组'
- en: '`push()` and `pop()` let you add or delete elements at the end of an array'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push()`和`pop()`允许您在数组的末尾添加或删除元素'
- en: '`shift()` and `unshift()` work in the same way as `push()` and `pop()` but
    at the beginning of an array'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift()`和`unshift()`的工作方式与`push()`和`pop()`相同，但是在数组的开始处'
- en: '`splice()` lets you add or delete elements anywhere within an array'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splice()`允许您在数组的任何位置添加或删除元素'
- en: '`reverse()` and `sort()` modify an array in place, reversing or sorting its
    elements'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()`和`sort()`在原地修改数组，反转或排序其元素'
- en: 'Let’s take a look at an example we saw in the *Argument mutation* section of
    [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*,* *Behaving Properly*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在[*第4章*](B19301_04.xhtml#_idTextAnchor069)*，* *行为规范*中的[*“参数突变”*](B19301_04.xhtml#_idTextAnchor069)部分看到的例子：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `maxStrings()` function returns the highest value in an array, but also
    modifies the original array; this is a side effect of the `sort()` and `pop()`
    mutator functions. In this case and others, you might generate a copy of the array
    and then work with that; both the spread operator and `.slice()` are useful:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`maxStrings()`函数返回数组中的最大值，但也会修改原始数组；这是`sort()`和`pop()`突变函数的副作用。在这种情况下和其他情况下，您可能需要生成数组的副本，然后使用它；展开运算符和`.slice()`都很有用：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both new versions of our `maxStrings()` functions are now functional, without
    side effects, because the mutator methods have been applied to copies of the original
    argument. By the way, if you are wondering about the `as string` part in both
    new functions, it’s because TypeScript warns you that the array might be empty,
    and I’m telling it that I guarantee the array won’t be so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`maxStrings()`函数的新版本现在都是功能性的，没有副作用，因为突变方法已经应用于原始参数的副本。顺便说一句，如果您对两个新函数中的`as
    string`部分感到好奇，那是因为TypeScript会警告您数组可能为空，而我正在告诉它我保证数组不会这样。
- en: Of course, setter methods are also mutators and will logically produce side
    effects because they can do just about anything. If this is the case, you’ll have
    to go for some of the other solutions described later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，设置方法也是突变者，并且逻辑上会产生副作用，因为它们几乎可以做任何事情。如果这种情况发生，您将不得不选择本章后面描述的其他一些解决方案。
- en: Constants
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: 'If the mutations don’t happen because of the use of some JavaScript methods,
    then we might want to attempt to use `const` definitions, but unfortunately, that
    just won’t work. In JavaScript, `const` means that the *reference* to the object
    or array cannot change (you cannot assign a different object to it), but you can
    still modify its properties. We can see this in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果突变不是由于使用某些JavaScript方法引起的，那么我们可能想要尝试使用`const`定义，但不幸的是，这根本行不通。在JavaScript中，`const`意味着对象或数组的*引用*不能改变（您不能将其分配给不同的对象），但您仍然可以修改其属性。我们可以在以下代码中看到这一点：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You cannot modify the value of `myObj` by assigning it a new value, but you
    can modify its current value so that only the reference to an object is constant,
    not the object’s values themselves. (By the way, this would have also happened
    with arrays.) So, if you use `const` everywhere, you will only be safe against
    direct assignments to objects and arrays. More modest side effects, such as changing
    an attribute or an array element, will still be possible, so this is not a solution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能通过为其分配新值来修改`myObj`的值，但您可以修改其当前值，这样只有对象的引用是恒定的，而不是对象的值本身。（顺便说一句，这种情况也会发生在数组上。）因此，如果您在所有地方都使用`const`，那么您将只能防止直接对对象和数组的赋值。更多微妙的副作用，例如更改属性或数组元素，仍然可能发生，所以这不是一个解决方案。
- en: Two methods can work – *freezing* to provide unmodifiable structures, and *cloning*
    to produce modified new ones. These are probably not the best ways to go about
    forbidding objects from being changed, but they can be used as a makeshift solution.
    Let’s look at them in more detail, starting with freezing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以工作——*冻结*以提供不可修改的结构，以及*克隆*以产生修改后的新对象。这些可能不是禁止修改对象的最佳方法，但它们可以用作临时解决方案。让我们更详细地看看它们，从冻结开始。
- en: Freezing
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冻结
- en: If we want to avoid the possibility of a programmer accidentally or willingly
    modifying an object, freezing it is a valid solution. After an object has been
    frozen, any attempts at modifying it will silently fail – JavaScript won’t report
    an error or throw an exception, but it won’t alter the object either.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要避免程序员意外或故意修改对象的可能性，冻结它是一个有效的解决方案。对象一旦被冻结，任何修改尝试都将静默失败——JavaScript不会报告错误或抛出异常，但也不会改变对象。
- en: 'In the following example, if we attempt to make the same changes we made in
    the previous section, they won’t have any effect, and `myObj` will be unchanged:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，如果我们尝试进行与上一节相同的更改，它们将没有任何效果，`myObj`将保持不变：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sealing or freezing?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 密封还是冻结？
- en: Don’t confuse freezing with sealing – `Object.seal()`, when applied to an object,
    prohibits you from adding or deleting properties to it. This means that the object’s
    structure is immutable, but the attributes themselves can be changed. `Object.freeze()`
    covers not only sealing properties but also making them unchangeable. See [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)
    and [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
    for more on this.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆冻结和密封——`Object.seal()`当应用于对象时，禁止你向其添加或删除属性。这意味着对象的结构是不可变的，但属性本身可以更改。`Object.freeze()`不仅覆盖了密封属性，还使它们不可更改。有关更多信息，请参阅[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)和[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)。
- en: 'There is only one problem with this solution – freezing an object is a shallow
    operation that freezes the attributes themselves, similar to what a `const` declaration
    does. If any of the attributes are objects or arrays themselves they can still
    be modified. We will only be considering data here; you may also want to freeze,
    say, functions, but for most use cases, it’s data you want to protect:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案只有一个问题——冻结对象是一个浅层操作，它冻结了属性本身，类似于`const`声明所做的那样。如果任何属性本身是对象或数组，它们仍然可以被修改。我们在这里只考虑数据；你可能还想冻结函数，例如，但对于大多数用例，你想要保护的是数据：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is only partially successful, as we can see when we try changing some
    attributes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这只部分成功，正如我们尝试更改一些属性时可以看到的：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Modifying `myObj3.d` doesn’t work because the object is frozen, but that doesn’t
    extend to objects within `myObj3`, so changing `myObj3.o.f.a` does work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`myObj3.d`不起作用，因为对象已被冻结，但这并不适用于`myObj3`内的对象，因此修改`myObj3.o.f.a`是有效的。
- en: 'If we want to achieve real immutability for our object, we need to write a
    routine that will freeze all the levels of an object. Fortunately, it’s easy to
    achieve this by applying recursion. (We saw similar applications of recursion
    in the *Traversing a tree structure* section of the previous chapter.) Mainly,
    the idea is to freeze the object itself and then recursively freeze each of its
    properties. We must ensure that we only freeze the object’s own properties; we
    shouldn’t mess with the prototype of the object, for example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使我们的对象达到真正的不可变性，我们需要编写一个将冻结对象所有级别的例程。幸运的是，通过应用递归可以轻松实现这一点。（我们在上一章的*遍历树结构*部分看到了递归的类似应用。）主要思路是首先冻结对象本身，然后递归地冻结其每个属性。我们必须确保我们只冻结对象的自身属性；我们不应该干扰对象的原型，例如：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that, in the same way that `Object.freeze()` works, `deepFreeze()` also
    freezes the object in place. I wanted to keep the original semantics of the operation
    so that the returned object would always be the original one. If we wanted to
    work in a purer fashion, we should make a copy of the original object first (we’ll
    learn how to do this in the next section) and then freeze that. As for TypeScript,
    the returned value is the same type as the input; the object being frozen makes
    no difference with regard to types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`Object.freeze()`的工作方式相同，`deepFreeze()`也会原地冻结对象。我想保持操作的原始语义，以便返回的对象始终是原始对象。如果我们想以更纯粹的方式工作，我们应该首先复制原始对象（我们将在下一节中学习如何做），然后冻结它。至于TypeScript，返回的值与输入类型相同；被冻结的对象与类型无关。
- en: A small possible problem remains, but with a very bad result – what would happen
    if an object included a reference to itself? We can avoid this if we skip freezing
    already frozen objects; backward circular references would be ignored, since the
    objects they refer to would already be frozen. So, the logic we wrote took care
    of that problem, and there’s nothing more to be done!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一个小问题，但结果非常糟糕——如果一个对象包含了对自身的引用会发生什么？如果我们跳过冻结已经冻结的对象，我们可以避免这个问题；向后循环引用将被忽略，因为它们引用的对象已经冻结了。所以，我们编写的逻辑处理了这个问题，没有更多的事情要做！
- en: If we apply `deepFreeze()` to an object, we can safely pass it to any function,
    knowing there is no way in which it can be modified. You can also use this property
    to test whether a function modifies its arguments – deep-freeze them, call the
    function, and if the function depends on modifying its arguments, it won’t work
    because the changes will be silently ignored. So, how can we return a result from
    a function if it involves a received object? This can be solved in many ways.
    A simple one uses cloning, as we’ll see.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个对象应用`deepFreeze()`，我们可以安全地将它传递给任何函数，因为我们知道它不可能被修改。你还可以使用这个属性来测试一个函数是否修改了它的参数——将它们深度冻结，调用函数，如果函数依赖于修改其参数，则它将无法工作，因为更改将被默默地忽略。那么，如果一个函数涉及到接收到的对象，我们如何从函数中返回一个结果呢？这可以通过许多方式解决。一种简单的方法是使用克隆，正如我们将要看到的。
- en: In this section, we dealt with one of the methods we can use to avoid changes
    in objects. (Check the *Questions* section at the end of this chapter for another
    way of freezing objects by means of proxies.) Now, let’s look at an alternative
    involving cloning.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们处理了我们可以使用的方法之一来避免对象的变化。（检查本章末尾的*问题*部分，了解另一种通过代理冻结对象的方法。）现在，让我们看看一种涉及克隆的替代方法。
- en: Cloning and mutating
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆和修改
- en: If mutating an object isn’t allowed, you must create a new one. For example,
    if you use Redux, a reducer is a function that receives the current state and
    an action (essentially, an object with new data) and produces the new state. Modifying
    the current state is totally forbidden, and we could avoid this error by always
    working with frozen objects, as we saw in the previous section. To fulfill the
    reducer’s requirements, we have to be able to clone the original state, as well
    as mutate it according to the received action. The resulting object will become
    the new state.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许修改对象，你必须创建一个新的对象。例如，如果你使用Redux，一个reducer是一个接收当前状态和一个动作（本质上是一个包含新数据的对象）的函数，并产生新的状态。修改当前状态是完全禁止的，我们可以通过始终使用冻结对象来避免这个错误，就像我们在上一节中看到的那样。为了满足reducer的要求，我们必须能够克隆原始状态，并根据接收到的动作对其进行修改。结果对象将成为新的状态。
- en: 'To round things off, we should also freeze the returned object, just like we
    did with the original state. But let’s start at the beginning – how do we clone
    an object? Of course, you can always do this by hand, but that’s not something
    you’d want to consider when working with large, complex objects. (You may want
    to revisit the *More general looping* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, where we wrote a basic `objCopy()` function that
    provides a different approach from the one we’ll show here.) For example, if you
    wanted to clone `oldObject` to produce `newObject`, doing it by hand would imply
    a lot of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加完整，我们也应该冻结返回的对象，就像我们对原始状态所做的那样。但让我们从开始说起——我们如何克隆一个对象？当然，你可以手动完成这个操作，但在处理大型、复杂对象时，你不会希望考虑这一点。（你可能想回顾一下[*第五章*](B19301_05.xhtml#_idTextAnchor084)中的*更通用的循环*部分，我们在那里编写了一个基本的`objCopy()`函数，它提供了一种与我们在这里展示的不同方法。）例如，如果你想克隆`oldObject`以生成`newObject`，手动操作将意味着大量的代码：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This manual solution is obviously a lot of work, and error-prone as well; you
    could easily forget an attribute! Going for more automatic solutions, there are
    a couple of straightforward ways of copying arrays or objects in JavaScript, but
    they have the same shallowness problem. You can make a (shallow) copy of an object
    with `Object.assign()` or by spreading:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种手动解决方案显然需要做很多工作，而且容易出错；你可能会忘记一个属性！寻求更自动化的解决方案，在JavaScript中有几种简单的方法可以复制数组或对象，但它们都存在同样的问题。你可以使用`Object.assign()`或者通过展开来创建一个（浅层）对象的副本：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To create a (shallow) copy of an array, you can either use `slice()` or spreading,
    as we saw in the *Mutator functions* section earlier in this chapter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个（浅层）数组的副本，你可以使用`slice()`或者展开，就像我们在本章前面的*突变函数*部分看到的那样：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What’s the problem with these solutions? If an object or array includes objects
    (which may themselves include objects), we get the same problem that we had when
    freezing – objects are copied by reference, which means that a change in the new
    object will also change the old object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案有什么问题？如果一个对象或数组包含对象（这些对象可能自身也包含对象），我们将遇到我们在冻结时遇到的问题——对象是通过引用复制的，这意味着新对象的变化也会改变旧对象：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, note what happened when we changed some properties of `newObject`.
    Changing `newObject.d` worked fine, but changing `newObject.o.f.a` also impacted
    `oldObject`, since `newObject.o` and `oldObject.o` actually refer to the very
    same object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，注意当我们改变`newObject`的一些属性时发生了什么。改变`newObject.d`没有问题，但改变`newObject.o.f.a`也影响了`oldObject`，因为`newObject.o`和`oldObject.o`实际上指向的是同一个对象。
- en: New age, old section
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 新时代，旧章节
- en: Since 2022, a new `structuredClone()` function has been available, so if your
    browser supports it, the code on these pages won’t be needed. For more information,
    check out [developer.mozilla.org/en-US/docs/Web/API/structuredClone](http://developer.mozilla.org/en-US/docs/Web/API/structuredClone).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 自2022年以来，一个新的`structuredClone()`函数已经可用，所以如果你的浏览器支持它，这些页面上的代码就不需要了。更多信息，请查看[developer.mozilla.org/en-US/docs/Web/API/structuredClone](http://developer.mozilla.org/en-US/docs/Web/API/structuredClone)。
- en: 'There is a simple solution to this, based on JSON. If we `stringify()` the
    original object and then `parse()` the result, we’ll get a new object that’s totally
    separate from the old one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基于JSON，有一个简单的解决方案。如果我们`stringify()`原始对象，然后`parse()`结果，我们将得到一个与旧对象完全不同的新对象：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By using `JSON.stringify()`, we can convert our object into a string. Then,
    `JSON.parse()` creates a (new) object out of that string – simple! This works
    with both arrays and objects, but there’s a problem. If any object’s properties
    have a constructor, they won’t be invoked; the result will always be composed
    of plain JavaScript objects. (This is not the only problem with `jsonCopy()`;
    see *Question 10.2*.) We can see this very simply with `Date()`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`JSON.stringify()`，我们可以将我们的对象转换成一个字符串。然后，`JSON.parse()`从这个字符串中创建一个新的对象——很简单！这对数组和对象都适用，但有一个问题。如果任何对象的属性有构造函数，它们不会被调用；结果将始终由普通的JavaScript对象组成。（这并不是`jsonCopy()`的唯一问题；参见*问题10.2*。）我们可以通过`Date()`简单地看到这一点：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While `myDate` is an object, `newDate` turns out to be a string with a value,
    the date and time at the moment we did the conversion, "`2023-01-15T09:23:55.125Z`".
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`myDate`是一个对象，但`newDate`实际上是一个包含日期和时间的字符串，即我们在转换时的日期和时间，"`2023-01-15T09:23:55.125Z`"。
- en: 'We could do a recursive solution, just like we did with deep freezing, and
    the logic is quite similar. Whenever we find a property that is really an object,
    we invoke the appropriate constructor:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用递归解决方案，就像我们处理深度冻结时做的那样，逻辑相当相似。每当我们找到一个确实是对象的属性时，我们会调用适当的构造函数：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Whenever we find that a property of an object is actually another object, we
    invoke its constructor before continuing. This solves the problem we found with
    dates or, in fact, with any object! If we run the preceding code but use `deepCopy()`
    instead of `jsonCopy()`, we’ll get `object object` as output, as it should be.
    If we check the types and constructors, everything will match.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们发现一个对象的属性实际上是一个对象时，我们在继续之前会调用它的构造函数。这解决了我们遇到的问题，无论是日期还是任何对象！如果我们运行前面的代码，但使用`deepCopy()`而不是`jsonCopy()`，我们将得到`object
    object`作为输出，正如预期的那样。如果我们检查类型和构造函数，一切都会匹配。
- en: There’s a need for a minor hack because TypeScript works better with classes
    than with constructor functions – writing `obj as any` gets type checking to work,
    but it’s not very nice. Also, we need to write `prop as keyof O` because, otherwise,
    TypeScript would protest that `prop` could be anything, not necessarily a key
    of the original type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TypeScript 与类相比更适合与构造函数一起使用，因此需要进行一些小的修改——编写 `obj as any` 可以使类型检查工作，但这并不优雅。此外，我们还需要编写
    `prop as keyof O`，因为否则 TypeScript 会抗议 `prop` 可以是任何东西，而不一定是原始类型的键。
- en: 'The data-changing experiment will also work fine now:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数据更改实验现在也将正常工作：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s check out the last few lines. Modifying `newObject` had no impact on `oldObject`,
    so both objects are completely separate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查最后几行。修改 `newObject` 对 `oldObject` 没有影响，因此两个对象是完全独立的。
- en: 'Now that we know how to copy an object, we can follow these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何复制一个对象，我们可以遵循以下步骤：
- en: Receive a (frozen) object as an argument.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收一个（冻结的）对象作为参数。
- en: Make a copy of it, which won’t be frozen.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个副本，它不会被冻结。
- en: Take values from that copy that we can use in our code.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个副本中取出我们可以在代码中使用的数据。
- en: Modify the copy at will.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随意修改副本。
- en: Freeze it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冻结它。
- en: Return it as the result of the function.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为函数的结果返回。
- en: All of this is viable, though a bit cumbersome. Also, there are some limitations
    – we won’t be able to duplicate private properties or properties that involve
    symbols, we won’t duplicate getters and setters, and metadata-related features
    will also be missing. Let’s accept that, and add a couple of functions that will
    help bring everything together.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是可行的，尽管有些繁琐。此外，还有一些限制——我们无法复制私有属性或涉及符号的属性，我们也不会复制获取器和设置器，并且与元数据相关的功能也将缺失。让我们接受这一点，并添加几个将有助于将一切整合在一起的函数。
- en: Getters and setters
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: 'When following the steps provided at the end of the previous section, you may
    have noticed that every time you want to update a field, things become troublesome
    and prone to errors. Let’s use a common technique to add a pair of functions:
    getters and setters. They are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当遵循上一节末尾提供的步骤时，你可能已经注意到，每次你想更新一个字段时，事情都会变得麻烦且容易出错。让我们使用一种常见的技术来添加一对函数：获取器和设置器。它们如下所示：
- en: '*Getters* can be used to get values from a frozen object by unfreezing them
    so that they can be used.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取器* 可以通过解冻对象来从冻结对象中获取值，以便使用。'
- en: '*Setters* allow you to modify any property of an object. You can do this by
    creating a new and updated version, leaving the original untouched.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置器* 允许你修改对象的任何属性。你可以通过创建一个新的更新版本，而保留原始版本不变来实现这一点。'
- en: Let’s build our getters and setters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的获取器和设置器。
- en: Getting a property
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取属性
- en: 'In the *Getting a property from an object* section in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we wrote a simple `getField()` function that could handle
    getting a single attribute from an object. (See *Question 6.13* in that chapter
    for the missing companion `setField()` function.) Let’s take a look at how we
    can code this. We can have a straightforward version as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第6章*](B19301_06.xhtml#_idTextAnchor107) 的 *从对象获取属性* 部分，我们编写了一个简单的 `getField()`
    函数，它可以处理从对象中获取单个属性。 (参见该章节的 *问题6.13* 以获取缺失的配套 `setField()` 函数。) 让我们看看我们如何编写这个函数。我们可以有一个直接的版本，如下所示：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can even go one better by applying currying so that we have a more general
    version:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过应用柯里化来做得更好，从而得到一个更通用的版本：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We could get a deep attribute from an object by composing a series of `getField()`
    applications, but that would be rather cumbersome. Instead, let’s create a function
    that will receive a path – an array of field names – and return the corresponding
    part of the object, or be undefined if the path doesn’t exist. Using recursion
    is appropriate here and simplifies coding! Observe the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合一系列 `getField()` 应用来从对象中获取深层属性，但这会很麻烦。相反，让我们创建一个函数，它将接收一个路径——一个字段名称数组——并返回对象对应的部分，或者在路径不存在时返回
    `undefined`。在这里使用递归是合适的，并且可以简化编码！观察以下代码：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Basically, we look for the first string in the path to see whether it exists
    in the object. If it doesn’t, the operation fails, so we return `undefined`. If
    successful, and we still have more strings in the path, we use recursion to keep
    digging into the object; otherwise, we return a deep copy of the attribute’s value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们查找路径中的第一个字符串是否存在于对象中。如果不存在，操作失败，因此我们返回 `undefined`。如果成功，并且路径中还有更多的字符串，我们使用递归继续深入对象；否则，我们返回属性的深层副本。
- en: 'Once an object has been frozen, we cannot defrost it, so we must resort to
    making a new copy of it; `deepCopy()` is appropriate for doing this. Let’s try
    out our new function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个对象被冻结，我们就无法解冻它，因此我们必须求助于创建它的一个新副本；`deepCopy()`非常适合做这件事。让我们试试我们的新函数：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also check that returned objects are not frozen:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查返回的对象是否未冻结：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can see that we could directly update the `fObj` object, which means
    it wasn’t frozen. Now that we’ve written our getter, we can create a setter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以直接更新`fObj`对象，这意味着它没有被冻结。现在我们已经编写了获取器，我们可以创建一个设置器。
- en: Setting a property by path
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过路径设置属性
- en: 'Now, we can code a similar `setByPath()` function that will take a path, a
    value, and an object and update an object. This is not a pure function, but we’ll
    use it to write a pure one – wait and see! Here is the code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个类似的`setByPath()`函数，它将接受一个路径、一个值和一个对象，并更新对象。这不是一个纯函数，但我们将用它来编写一个纯函数——稍后你就会看到！以下是代码：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we are using recursion to get into the object, creating new attributes
    if needed, until we have traveled the entire length of the path. One crucial detail
    when creating attributes is whether we need an array or an object. (And why the
    `as any` cast for `obj`? That’s an issue with TypeScript, which objects to `obj[arr[0]]`,
    so we must “trick” it. Weirdly, using `Reflect.set()` also works!) We can determine
    that by checking the next element in the path – if it’s a number, then we need
    an array; otherwise, an object will do.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用递归进入对象，如果需要，创建新的属性，直到我们走完整个路径。在创建属性时有一个关键细节，那就是我们需要数组还是对象。（为什么需要对`obj`进行`as
    any`类型转换？这是TypeScript的一个问题，它反对`obj[arr[0]]`，因此我们必须“欺骗”它。奇怪的是，使用`Reflect.set()`也行！）我们可以通过检查路径中的下一个元素来确定这一点——如果是数字，则需要数组；否则，对象即可。
- en: When we get to the end of the path, we assign the new given value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达路径的末尾时，我们分配新的给定值。
- en: Seamless, immutable objects
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 无缝、不可变的对象
- en: If you like this way of doing things, check out the `seamless-immutable` library,
    which works in this fashion. The seamless part of the name alludes to the fact
    that you still work with normal objects – albeit frozen – which means you can
    use `map()`, `reduce()`, and so on. You can read more about this at [github.com/rtfeldman/seamless-immutable](http://github.com/rtfeldman/seamless-immutable).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这种方式，可以查看`seamless-immutable`库，它以这种方式工作。名字中的“无缝”部分暗示了这样一个事实，即你仍然使用正常的对象——尽管是冻结的——这意味着你可以使用`map()`、`reduce()`等。你可以在[github.com/rtfeldman/seamless-immutable](http://github.com/rtfeldman/seamless-immutable)了解更多信息。
- en: 'Now, you can write a function that will be able to take a frozen object and
    update an attribute within it, returning a new, also frozen, object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以编写一个函数，该函数能够接受一个冻结的对象并更新其内部的属性，返回一个新的、同样冻结的对象：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s check out how it works. To do this, we’ll run several updates on the
    `myObj3` object we have been using:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。为此，我们将对我们一直在使用的`myObj3`对象进行几次更新：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Given this pair of functions, we have finally gotten ourselves a way to keep
    immutability:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这对函数，我们终于找到了一种保持不可变性的方法：
- en: Objects must be frozen from the beginning
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象必须从一开始就冻结
- en: Getting data from objects is done with `getByPath()`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从对象中获取数据使用`getByPath()`
- en: Setting data is done with `updateObject()`, which internally uses `setByPath()`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据使用`updateObject()`，它内部使用`setByPath()`
- en: In this section, we learned how to get and set values from an object in a way
    that keeps objects immutable. Let’s now look at a variation of this concept –
    **lenses** – that will allow us to not only get and set values but also apply
    a function to the data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何以保持对象不可变的方式从对象中获取和设置值。现在让我们看看这个概念的变体——**镜头**——它不仅允许我们获取和设置值，还可以对数据进行函数应用。
- en: Lenses
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜头
- en: There’s another way to get and set values, which goes by the name of *optics*,
    and includes *lenses* (which we’ll study now) and *prisms* (which we’ll look at
    later in this chapter). What are lenses? They are functional ways of focusing
    (another optical term!) on a given spot in an object so that we can access or
    modify its value in a non-mutating way. In this section, we’ll look at some examples
    of the usage of lenses and consider two implementations – first, a simple one
    based on objects, and then a more complete one that’s interesting because of some
    of the techniques we will be using.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取和设置值的方法被称为*光学*，包括*透镜*（我们现在将研究）和*棱镜*（我们将在本章后面讨论）。什么是透镜？它们是在对象中聚焦于特定位置的功能方式（另一个光学术语！），这样我们就可以以非突变的方式访问或修改其值。在本节中，我们将查看一些透镜用法的示例，并考虑两种实现方式——首先是一个基于对象的简单实现，然后是一个更完整的实现，后者之所以有趣，是因为我们将使用的一些技术。
- en: Working with lenses
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用透镜
- en: 'Both implementations will share basic functionality, so let’s start by skipping
    what lenses are or how they are built and look at some examples of their usage
    instead. First, let’s create a sample object that we will work with – some data
    about a writer (his name sounds familiar...) and his books:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实现将共享基本功能，所以让我们先跳过透镜是什么或它们是如何构建的，而是看看它们用法的示例。首先，让我们创建一个我们将要使用的示例对象——关于一个作家（他的名字听起来很熟悉...)和他的书籍的一些数据：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We shall assume that several functions exist; we’ll see how they are implemented
    in upcoming sections. A lens depends on having a getter and a setter for a given
    attribute, and we can build one by directly using `lens()`, or `lensProp()` for
    briefer coding. Let’s create a lens for the `user` attribute:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设存在几个函数；我们将在接下来的章节中看到它们的实现。透镜依赖于给定属性的存在一个获取器和设置器，我们可以通过直接使用`lens()`，或者更简短的`lensProp()`来构建一个。让我们为`user`属性创建一个透镜：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This defines a lens that focuses on the `user` attribute. Since this is a common
    operation, it can also be written more compactly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个聚焦于`user`属性的透镜。由于这是一个常见的操作，它也可以更紧凑地写出来：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Both these lenses allow us to focus on the `user` attribute of whatever object
    we use them with. With lenses, there are three basic operations, and we’ll follow
    tradition by using the names that most (if not all) libraries follow:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个透镜都允许我们聚焦于我们使用它们的任何对象的`user`属性。使用透镜，有三个基本操作，我们将遵循传统，使用大多数（如果不是所有）库使用的名称：
- en: '`view()`: Used to access the value of an attribute'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view()`：用于访问属性的值'
- en: '`set()`: Used to modify the value of an attribute'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set()`：用于修改属性的值'
- en: '`over()`: Used to apply a function to an attribute and change its value'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`over()`：用于将函数应用于属性并更改其值'
- en: 'Let’s assume the functions are curried, as we saw in the previous chapter.
    So, to access the `user` attribute, we can write the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设函数是柯里化的，就像我们在上一章中看到的那样。因此，要访问`user`属性，我们可以写出以下内容：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `view()` function takes a lens as its first parameter. When applied to
    an object, it produces the value of whatever the lens focuses on – in our case,
    the `user` attribute. Of course, you could apply sequences of `view()` functions
    to get to deeper parts of the object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`view()`函数将其第一个参数作为透镜。当应用于对象时，它产生透镜聚焦的任何值的值——在我们的例子中，是`user`属性。当然，你可以应用一系列`view()`函数来到达对象的更深层部分：'
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this section on optics, we’ll always go with fully curried functions, not
    only for variety but because that’s usually how those functions are applied, as
    you’ll see in any textbook.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节关于光学的部分，我们将始终使用完全柯里化的函数，这不仅是为了多样性，也因为通常就是这样应用这些函数的，正如你将在任何教科书中看到的那样。
- en: 'Instead of writing such a series of `view()` calls, we’ll compose lenses so
    that we can focus more deeply on an object. Let’s take a look at one final example,
    which shows how we access an array:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写一系列`view()`调用，我们将组合透镜，以便我们可以更深入地聚焦于对象。让我们看看最后一个示例，它展示了我们如何访问一个数组：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the future, should there be any change in the author structure, a simple
    change in the `lensBooks` definition would be enough to keep the rest of the code
    unchanged.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，如果作者结构有任何变化，只需简单更改`lensBooks`的定义就足以保持其余代码不变。
- en: Lenses elsewhere?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 透镜在其他地方？
- en: You can also use lenses to access other structures; refer to *Question 10.8*
    for a way to use lenses with arrays, and *Question 10.9* for how to use lenses
    so that they work with maps.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用透镜来访问其他结构；参考*问题10.8*了解如何使用透镜与数组一起使用，以及*问题10.9*了解如何使用透镜使其与映射一起工作。
- en: 'Moving on, the `set()` function allows us to set the value of the focus of
    the lens:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`set()` 函数允许我们设置 lenses 的焦点值：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result of `set()` is a new object with a changed value. Using this function
    in a fully curried style may be surprising, but if we used our `curry()` or `partialCurry()`
    function from earlier chapters, we could write `set(lens1, "FEFK", author)` as
    well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()` 的结果是具有更改值的新对象。以完全柯里化的方式使用此函数可能会令人惊讶，但如果我们使用之前章节中的 `curry()` 或 `partialCurry()`
    函数，我们也可以将 `set(lens1, "FEFK", author)` 写出来。'
- en: 'Using `over()` is similar in that a new object is returned, but in this case,
    the value is changed by applying a mapping function to it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `over()` 类似，它返回一个新的对象，但在这个例子中，通过应用映射函数来更改值：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A fundamental question is, why is `user` equal to `"fkerekifkerekifkereki"`
    and not `"FEFKFEFKFEFK"`? Our lens does not modify an object when using the setter
    but instead provides a new one, so we’re applying `triple()` to the original object’s
    user attribute.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本问题是，为什么 `user` 等于 `"fkerekifkerekifkereki"`，而不是 `"FEFKFEFKFEFK"`？我们的 lens
    在使用设置器时不会修改对象，而是提供一个新对象，因此我们将 `triple()` 应用到原始对象的用户属性上。
- en: There are more functions you can do with lenses, but we’ll just go with these
    three for now. (Here’s a suggestion – take a look at *Question 10.7* for an interesting
    idea on how to use lenses to access virtual attributes that don’t actually exist
    in an object.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 lenses 做更多的事情，但现在我们只关注这三个。（这里有一个建议——看看 *问题 10.7*，了解如何使用 lenses 访问实际上不存在于对象中的虚拟属性的一个有趣想法。）
- en: To finish this section, I’d recommend looking at some third-party optics libraries
    ([github.com/stoeffel/awesome-fp-js#lenses](http://github.com/stoeffel/awesome-fp-js#lenses)
    and [tinyurl.com/jslenses](http://tinyurl.com/jslenses) have several suggestions)
    to get a glimpse into all the available functionality. Now that we have an idea
    of what to expect when using lenses, let’s learn how to implement them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本节，我建议查看一些第三方光学库（[github.com/stoeffel/awesome-fp-js#lenses](http://github.com/stoeffel/awesome-fp-js#lenses)
    和 [tinyurl.com/jslenses](http://tinyurl.com/jslenses) 有几个建议），以了解所有可用的功能。现在我们已经了解了使用
    lenses 时可以期待什么，让我们学习如何实现它们。
- en: Implementing lenses with objects
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象实现 lenses
- en: 'The simplest way to implement a lens is by representing it with an object with
    just two properties – a getter and a setter. In this case, we’d have something
    like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个 lens 的最简单方法是通过一个具有两个属性的对象来表示它——一个获取器和设置器。在这种情况下，我们会得到类似这样的东西：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We’ve already seen similar `getField()` and `setField()` functions; the former
    gets a specific attribute from an object, and the latter returns a new object
    with a single changed attribute. We can now define our `lens`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了类似的 `getField()` 和 `setField()` 函数；前者从一个对象中获取一个特定的属性，而后者返回一个具有单个更改属性的新的对象。我们现在可以定义我们的
    `lens`：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is easy to understand – given a getter and a setter, `lens()` creates
    an object with those two attributes, and `lensProp()` creates a getter/setter
    pair by using `getField()` and `setField()` with `lens()`, which is very straightforward.
    Now that we have our lens, how do we implement the three basic functions we saw
    in the previous section? Viewing an attribute requires applying the getter; to
    maintain a curried style, let’s do currying by hand:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易理解——给定一个获取器和设置器，`lens()` 创建一个具有这两个属性的对象，而 `lensProp()` 通过使用 `getField()`
    和 `setField()` 与 `lens()` 创建一个获取器/设置器对，这非常直接。现在我们有了我们的 lens，我们如何实现之前章节中看到的三个基本函数？查看一个属性需要应用获取器；为了保持柯里化风格，让我们手动进行柯里化：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The generic `LENS<>` type is the type of whatever the `lens()` function returns.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 `LENS<>` 类型是 `lens()` 函数返回的类型。
- en: 'Similarly, setting an attribute is a matter of applying the setter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，设置一个属性只是应用设置器的问题：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, applying a mapping function to an attribute is a *two-for-one* operation
    – we use the getter to get the current value of the attribute, we apply the function
    to it, and we use the setter to store the calculated result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将映射函数应用于一个属性是一个“一石二鸟”的操作——我们使用获取器来获取属性的当前值，我们将函数应用于它，然后我们使用设置器来存储计算出的结果：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This needs to be studied carefully. We use the lens’s `getter()` function to
    get some attribute from the input object, we apply the mapping function to the
    obtained value, and we use the lens’s `setter()` function to produce a new object
    with the changed attribute.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要仔细研究。我们使用 lens 的 `getter()` 函数从输入对象中获取一些属性，我们将映射函数应用于获取的值，然后我们使用 lens 的 `setter()`
    函数来生成一个新的具有更改属性的对象。
- en: 'Now that we can do all three operations, we have working lenses! What about
    composition? Lenses have a peculiar characteristic – they’re composed backward,
    left to right, so you start with the most generic and end with the most specific.
    That certainly goes against intuition; we’ll learn about this in more detail in
    the next section, but for now, we’ll keep with tradition:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以执行所有三种操作，我们有了工作的透镜！关于组合呢？透镜有一个独特的特性——它们是反向组合的，从左到右，所以你从最通用的开始，以最具体的结束。这确实与直觉相反；我们将在下一节中更详细地了解这一点，但现在，我们将保持传统：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code is sort of impressive but not too hard to understand. The getter for
    the composition of two lenses is the result of using the first lens’s getter and
    then applying the second lens’s getter to that result. The setter for the composition
    is a tad more complex, but follows along the same lines; can you see how it works?
    Now, we can compose lenses easily; let’s start with an invented nonsensical object:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有点令人印象深刻，但并不难理解。两个透镜组合的获取器是使用第一个透镜的获取器，然后应用第二个透镜的获取器到该结果上。组合的设置器稍微复杂一些，但遵循相同的思路；你能看到它是如何工作的吗？现在，我们可以轻松地组合透镜；让我们从一个虚构的无意义对象开始：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can define a few lenses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一些透镜：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can try composing our new lens in a couple of ways, just for variety, to
    check that everything works:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试以几种不同的方式组合我们的新透镜，只是为了变化，以检查一切是否正常工作：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With `lCEGJ1`, we composed some lenses, starting with the latter ones. With
    `lCEGJ2`, we started with the lenses at the beginning, but the results are the
    same. Now, let’s try setting some values. We want to get down to the `k` attribute
    and set it to `60`. We can do this by using the same lens we just applied:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lCEGJ1`，我们编写了一些透镜，从后者开始。使用 `lCEGJ2`，我们从透镜的开始部分开始，但结果是一样的。现在，让我们尝试设置一些值。我们想要将
    `k` 属性设置为 `60`。我们可以通过使用刚刚应用的相同透镜来完成这个操作：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The composed lens worked perfectly, and the value was changed. (Also, a new
    object was returned; the original is unmodified, as we wanted.) To finish, let’s
    verify that we can use `over()` with our lens and try to duplicate the `k` value
    so that it becomes `22`. Just for variety, let’s use the other composed lens,
    even though we know that it works in the same way:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 组合透镜工作得非常完美，值已经改变。（此外，还返回了一个新对象；原始对象未修改，正如我们所希望的。）为了完成，让我们验证我们是否可以使用 `over()`
    与我们的透镜一起使用，并尝试复制 `k` 值，使其变为 `22`。为了变化，让我们使用另一个组合透镜，尽管我们知道它以相同的方式工作：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we have learned how to implement lenses in a simple fashion. However, let’s
    consider a different way of achieving the same objective by using actual functions
    to represent a lens. This will allow us to do composition in the standard way,
    without needing any special lens function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何以简单的方式实现透镜。然而，让我们考虑一种不同的方法来实现相同的目标，即使用实际函数来表示透镜。这将允许我们以标准方式执行组合，而无需任何特殊的透镜函数。
- en: Implementing lenses with functions
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数实现透镜
- en: The previous implementation of lenses with objects works well, but we want to
    look at a different way of doing things that will let us work with more advanced
    functional ideas. This will involve some concepts we’ll be analyzing in more detail
    in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*,
    but here, we’ll use just what we need so that you don’t have to go and read that
    chapter now! Our lenses will work the same way the preceding ones did, except
    that since they will be functions, we’ll be able to compose them with no special
    composing code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用对象实现的透镜实现效果很好，但我们想看看一种不同的做事方式，这将使我们能够使用更高级的函数概念。这将涉及我们在 [*第12章*](B19301_12.xhtml#_idTextAnchor221)，*构建更好的容器*
    中将要更详细分析的一些概念，但在这里，我们将只使用我们需要的，这样你就不必现在就去读那章！我们的透镜将以与之前相同的方式工作，只是由于它们将是函数，我们将能够不使用任何特殊的组合代码来组合它们。
- en: What’s the key concept here? A lens will be a function, based on a getter and
    a setter pair, that will construct a *container* (actually an object, but let’s
    go with the container name) with a `value` attribute and a `map` method (in [*Chapter
    12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*, we’ll see
    that this is a *functor*, but you don’t need to know that now). By having specific
    mapping methods, we’ll implement our `view()`, `set()`, and `over()` functions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键概念是什么？透镜将是一个基于获取器和设置器对的功能，它将构建一个 *容器*（实际上是一个对象，但让我们使用容器名称）并具有一个 `value`
    属性和一个 `map` 方法（在 [*第12章*](B19301_12.xhtml#_idTextAnchor221)，*构建更好的容器* 中，我们将看到这是一个
    *函子*，但你现在不需要知道这一点）。通过具有特定的映射方法，我们将实现我们的 `view()`、`set()` 和 `over()` 函数。
- en: 'Our `lens()` function is as follows. We’ll explain the details of this later:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定义 `lens()` 函数如下。我们将在稍后解释其细节：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s consider its parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑它的参数：
- en: The `getter` and `setter` parameters are the same as before.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getter` 和 `setter` 参数与之前相同。'
- en: The `fn` function is the “magic sauce” that makes everything work; depending
    on what we want to do with the lens, we’ll provide a specific function. There’ll
    be more on this later!
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn` 函数是“魔法调料”，让一切工作；根据我们想要对透镜做什么，我们将提供一个特定的函数。我们将在稍后了解更多关于这个！'
- en: The `obj` parameter is the object we want to apply the lens to.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 参数是我们想要应用透镜的对象。'
- en: 'Let’s code our `view()` function. For this, we’ll need an auxiliary class,
    `Constant`, that, given a value, `v`, produces a container with that value and
    a `map` function that returns the very same container:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的 `view()` 函数。为此，我们需要一个辅助类 `Constant`，它给定一个值 `v`，产生一个具有该值的容器和一个返回相同容器的
    `map` 函数：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this, we can now code `view()`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写 `view()` 代码了：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What happens here? Let’s follow this step by step; it’s a bit tricky!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？让我们一步一步地跟踪；这有点棘手！
- en: We use `lensProp()` to create a lens focusing on the `user` attribute.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `lensProp()` 创建一个聚焦于 `user` 属性的透镜。
- en: Our `view()` function passes the constant-building function to `lens()`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `view()` 函数将构建常数的函数传递给 `lens()`。
- en: Our `lens()` function uses the getter to access the user attribute in the `author`
    object.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `lens()` 函数使用获取器来访问 `author` 对象中的用户属性。
- en: Then, the value we receive is used to create a constant container.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们接收到的值被用来创建一个常数容器。
- en: The `map()` method is invoked, which returns the very same container.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `map()` 方法，它返回相同的容器。
- en: The `value` attribute of the container is accessed, and that’s the value that
    the getter retrieved in *step* *3*. Wow!
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问容器的 `value` 属性，这就是在第 *3* 步中获取器的返回值。哇！
- en: 'With that under our belt, let’s move on to `set()` and `over()`, which will
    require a different auxiliary function to create a container whose value may vary:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这些之后，让我们继续学习 `set()` 和 `over()`，这需要不同的辅助函数来创建一个值可能变化的容器：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this case (as opposed to `Constant` objects), the `map()` method really
    does something – when provided with a function, it applies it to the value of
    the container and returns a new `Variable` object, with the resulting value. The
    `set()` function can be implemented now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下（与 `Constant` 对象相反），`map()` 方法确实做了些事情——当提供一个函数时，它将此函数应用于容器的值，并返回一个新的 `Variable`
    对象，带有结果值。现在可以实施 `set()` 函数：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case, when the lens invokes the container’s `map()` method, it will
    produce a new container with a new value, which makes all the difference. To understand
    how this works, follow the same six steps we saw for `get()` – the only difference
    will be in *step 5*, where a new, different container is produced.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当透镜调用容器的 `map()` 方法时，它将产生一个新的容器和一个新值，这产生了所有差异。为了理解它是如何工作的，请遵循我们之前看到的
    `get()` 的相同六个步骤——唯一的区别将在 *第 5* 步，那里将产生一个新的、不同的容器。
- en: 'Now that we’ve survived this (tricky indeed!) code, the `over()` function is
    simple, and the only difference is that instead of mapping to a given value, you
    use the mapping `mapfn` function provided to compute the new value for the container:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功通过了这段（确实有点棘手！）代码，`over()` 函数很简单，唯一的区别是，你不再映射到一个给定的值，而是使用提供的映射函数 `mapfn`
    来计算容器的新值：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, the difference between `set()` and `over()` is that, in the
    former case, you provide a value to replace the original one, while in the latter
    case, you provide a function to calculate the new value. Other than that, both
    are similar.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`set()` 和 `over()` 之间的区别在于，在前者中，你提供一个值来替换原始值，而在后者中，你提供一个函数来计算新值。除此之外，两者相似。
- en: 'To finish, let’s verify that `compose()` can be applied to our functor-based
    lenses:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们验证 `compose()` 是否可以应用于基于函子（functor）的透镜：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we created two individual lenses for `name` and `last`, and we composed
    them with the very same `compose()` function that we developed back in [*Chapter
    8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*. Using this composite
    lens, we focused on the author’s last name without any problem, so everything
    worked as expected.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `name` 和 `last` 创建了两个单独的透镜，并使用我们之前在 [*第 8 章*](B19301_08.xhtml#_idTextAnchor148)
    中开发的相同的 `compose()` 函数将它们组合起来，*连接函数*。使用这个组合透镜，我们没有任何问题地关注了作者的姓氏，所以一切如预期进行。
- en: Wrong direction?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 方向错误吗？
- en: It seems to go against logic that lenses should be composed from left to right;
    this appears to be backward. This is something that troubles developers, and if
    you google for an explanation, you’ll find many. To answer this question on your
    own, I suggest spelling out how `compose()` works in full – two functions will
    be enough – and then substitute the definitions of lenses; you’ll see why and
    how everything works out.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 透镜应该从左到右组合似乎与逻辑相悖；这似乎是倒退的。这是让开发者感到困扰的事情，如果你在谷歌上搜索解释，你会找到很多。为了自己回答这个问题，我建议详细说明`compose()`是如何工作的——两个函数就足够了——然后替换透镜的定义；你会看到为什么以及如何一切都能正常工作。
- en: Now that we’ve looked at lenses, we can move on and look at **prisms**, another
    optics tool.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了透镜，我们可以继续了解**棱镜**，另一种光学工具。
- en: Prisms
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 棱镜
- en: As we saw in the previous section, lenses are useful for working with product
    types. However, prisms are useful for working with *sum* types. But what are they?
    (We’ll look at products and unions in more detail in the last chapter of the book.)
    Whereas a product type is always built out of the same options, such as an object
    from a class, a sum type will likely have different structures – extra or missing
    attributes, for example. When you use a lens, you assume that the object you’ll
    be applying it to has a known structure with no variations, but what do you use
    if the object has different structures? The answer is prisms. Let’s look at how
    they are used first; then, we’ll examine their implementation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节所见，透镜在处理产品类型时很有用。然而，棱镜在处理*求和*类型时很有用。但它们是什么？（我们将在本书的最后一章更详细地探讨产品类型和联合类型。）产品类型总是由相同的选项构建而成，例如一个类中的对象，而求和类型可能具有不同的结构——例如额外的或缺失的属性。当你使用透镜时，你假设你要应用透镜的对象具有已知结构且没有变化，但如果对象具有不同的结构，你将使用什么？答案是棱镜。让我们首先看看它们是如何使用的；然后，我们将检查它们的实现。
- en: Working with prisms
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用棱镜
- en: 'Working with prisms is similar to using lenses, except for what happens when
    an attribute is not present. Let’s take a look at an example from the previous
    section:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用棱镜与使用透镜类似，但要注意当某个属性不存在时会发生什么。让我们看看上一节的一个例子：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we wanted to access the `user` attribute using prisms, we would write something
    like the following (and don’t worry about the details now):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用棱镜访问`user`属性，我们会写一些类似以下的内容（现在不用担心细节）：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, we define a prism using a `prismProp()` function, which parallels our
    previous `lensProp()`. Then, we use the prism with the `preview()` function, which
    is analogous to `get()` with lenses, and the result is the same as if we had used
    lenses – no surprises there. What would have happened if we had asked for a non-existing
    pseudonym attribute? Let’s see:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`prismProp()`函数定义了一个棱镜，这与我们之前的`lensProp()`函数类似。然后，我们使用棱镜与`preview()`函数一起使用，这与透镜中的`get()`函数类似，结果与使用透镜一样——没有惊喜。如果我们请求一个不存在的别名属性会发生什么？让我们看看：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So far, we may not see any differences, but let’s see what happens if we try
    to compose lenses or prisms with several missing attributes. Say you wanted to
    access a (missing!) `pseudonym.usedSince` attribute with lenses, without taking
    precautions and checking that the attributes exist. Here, you would get the following
    output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能没有看到任何区别，但让我们看看如果我们尝试组合具有多个缺失属性的透镜或棱镜会发生什么。假设你想使用透镜访问一个（缺失的！）`pseudonym.usedSince`属性，而不采取预防措施并检查属性是否存在。在这里，你会得到以下输出：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'On the other hand, since prisms already take missing values into account, this
    would cause no problems, and we’d get an `undefined` result; that’s why `preview()`
    is sometimes called `getOptional()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于棱镜已经考虑了缺失的值，这不会引起任何问题，我们会得到一个`undefined`结果；这就是为什么`preview()`有时被称为`getOptional()`的原因：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'What happens if we want to set a value? The analogous function to `set()` is
    `review()`; let’s look at how it would work. The idea is that whatever attribute
    we specify will be set if, and only if, the attribute already exists. So, if we
    attempt to change the `user.name` attribute, this will work:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想设置一个值会发生什么？与`set()`函数类似的是`review()`函数；让我们看看它将如何工作。想法是，无论我们指定什么属性，只有在属性已经存在的情况下才会设置该属性。所以，如果我们尝试更改`user.name`属性，这将起作用：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, if we try to modify the (non-existent) `pseudonym` attribute, the
    original, unchanged object will be returned:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试修改（不存在的）`pseudonym`属性，将返回原始的、未更改的对象：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So, using prisms takes care of all possible missing or optional fields. How
    do we implement this new optics type? New names are used (`preview()` and `review()`
    instead of `get()` and `set()`), but that difference is minor. Let’s take a look.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用棱镜可以处理所有可能的缺失或可选字段。我们如何实现这种新的光学类型？使用了新的名称（`preview()` 和 `review()` 代替 `get()`
    和 `set()`），但这个差异很小。让我们看看。
- en: Implementing prisms
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现棱镜
- en: 'How do we implement prisms? We will take our cue from our lens implementation
    and make a few changes. When getting an attribute, we must check whether the object
    we are processing is not `null` or `undefined` and whether the attribute we want
    is in the object. We can make do with small changes to our original `getField()`
    function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现棱镜？我们将从我们的透镜实现中汲取灵感并做出一些更改。在获取属性时，我们必须检查我们正在处理的对象是否不是 `null` 或 `undefined`，以及我们想要的属性是否在对象中。我们可以通过对我们原始的
    `getField()` 函数进行一些小的更改来做到这一点：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, we’re checking for the existence of the object and the attribute – if
    everything’s okay, we return `obj[attr]`; otherwise, we return `undefined`. The
    changes for `setField()` are very similar:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查对象和属性的存在性 – 如果一切正常，我们返回 `obj[attr]`；否则，我们返回 `undefined`。`setField()`
    的更改非常相似：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If the object and the attribute both exist, we return a new object by changing
    the attribute’s value; otherwise, we return a copy of the object. That’s all there
    is to it! Defining the other functions is directly based on `lens()`, `lensProp()`,
    and so on, so we’ll skip that.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象和属性都存在，我们通过更改属性值返回一个新的对象；否则，我们返回对象的副本。这就是全部！定义其他函数直接基于 `lens()`、`lensProp()`
    等等，所以我们将跳过这一点。
- en: Now that we’ve learned how to access objects in functional ways, let’s analyze
    persistent data structures that can be modified very efficiently without the need
    for a full copy of the original object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何以函数式的方式访问对象，让我们分析那些可以非常高效地修改而不需要原始对象完整副本的持久化数据结构。
- en: Creating persistent data structures
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建持久化数据结构
- en: If you want to change something in a data structure and you just go and change
    it, your code will be full of side effects. On the other hand, copying complete
    structures every time is a waste of time and space. There’s a middle ground to
    this that has to do with persistent data structures, which, if handled correctly,
    let you apply changes while creating new structures efficiently.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在数据结构中更改某些内容，只是直接去更改它，你的代码将充满副作用。另一方面，每次都复制完整的结构是时间和空间的浪费。有一个中间方案与此有关，即持久化数据结构，如果处理得当，可以在创建新结构的同时应用更改。
- en: 'Given that there are many possible data structures you could work with, let’s
    just take a look at a few examples:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 既然有那么多可能的数据结构可以工作，我们只需看看几个例子：
- en: Working with lists, one of the simplest data structures
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与列表一起工作，这是最简单的数据结构之一
- en: Working with objects, a very common necessity in JavaScript programs
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象一起工作，这是 JavaScript 程序中非常常见的需求
- en: Dealing with arrays, which will prove to be harder to work with
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数组，这将证明更难处理
- en: Let’s get started!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Working with lists
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与列表一起工作
- en: 'Let’s consider a simple procedure – suppose you have a list and want to add
    a new element to it. How would you do this? Here, we can assume that each node
    is a `NodeList` object:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的程序 – 假设你有一个列表并想向其中添加一个新元素。你会怎么做？在这里，我们可以假设每个节点都是一个 `NodeList` 对象：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A possible list would be as shown in the following figure – a `list` variable
    would point to the first element. Look at the following diagram; can you tell
    what is missing in the list, and where?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的列表如下所示 – `list` 变量将指向第一个元素。看看下面的图；你能说出列表中缺少什么，以及在哪里吗？
- en: '![Figure 10.1 – The initial list](img/Figure_10.1_B19301.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 初始列表](img/Figure_10.1_B19301.jpg)'
- en: Figure 10.1 – The initial list
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 初始列表
- en: 'If you wanted to add D between B and F (the sample list represents a concept
    that musicians will understand, the *Circle of Thirds*, but with the D note missing),
    the simplest solution would be to add a new node and change an existing one. This
    would result in the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 B 和 F（示例列表代表音乐家会理解的概念，即**大三和弦**，但缺少 D 音）之间添加 D，最简单的解决方案是添加一个新节点并更改一个现有节点。这将导致以下结果：
- en: '![Figure 10.2 – The list now has a new element – we had to modify an existing
    one to perform the addition](img/Figure_10.2_B19301.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 列表现在有一个新元素 – 我们必须修改一个现有的元素来执行添加](img/Figure_10.2_B19301.jpg)'
- en: Figure 10.2 – The list now has a new element – we had to modify an existing
    one to perform the addition
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 列表中现在有一个新元素——我们必须修改一个现有的元素来执行添加操作
- en: 'However, working in this way is obviously non-functional, and we are clearly
    modifying data. There is a different way of working – creating a persistent data
    structure in which all the alterations (insertions, deletions, and modifications)
    are done separately, being careful not to modify existing data. On the other hand,
    if some parts of the structure can be reused, this is done to gain performance.
    Doing a persistent update would return a new list, with some nodes that are duplicates
    of some previous ones but no changes whatsoever to the original list. This can
    be seen in the following diagram:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以这种方式工作显然是非函数性的，我们显然正在修改数据。有另一种工作方式——创建一个持久数据结构，其中所有更改（插入、删除和修改）都是单独进行的，注意不要修改现有数据。另一方面，如果结构的一部分可以重用，这是为了提高性能。进行持久更新将返回一个新的列表，其中一些节点是前一个的一些副本，但原始列表没有任何更改。这可以在以下图中看到：
- en: '![Figure 10.3 – The dotted elements show the newly returned list, which shares
    some elements with the old one](img/Figure_10.3_B19301.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 虚线元素显示新返回的列表，它与旧列表共享一些元素](img/Figure_10.3_B19301.jpg)'
- en: Figure 10.3 – The dotted elements show the newly returned list, which shares
    some elements with the old one
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 虚线元素显示新返回的列表，它与旧列表共享一些元素
- en: Updating a structure this way requires duplicating some elements to avoid modifying
    the original structure, but part of the list is shared.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式更新结构需要复制一些元素以避免修改原始结构，但列表的一部分是共享的。
- en: 'Of course, we will also deal with updates or deletions. Starting again with
    the list shown in the following diagram, if we wanted to update its fourth element,
    the solution would imply creating a new subset of the list, up to and including
    the fourth element, while keeping the rest unchanged:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也会处理更新或删除。再次从以下图中显示的列表开始，如果我们想更新其第四个元素，解决方案意味着创建一个新的列表子集，包括第四个元素，同时保持其余部分不变：
- en: '![Figure 10.4 – Our list, with a changed element](img/Figure_10.4_B19301.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 我们列表中的更改元素](img/Figure_10.4_B19301.png)'
- en: Figure 10.4 – Our list, with a changed element
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 我们列表中的更改元素
- en: 'Removing an element would also be similar. Let’s do away with the third element,
    F, in the original list, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 删除元素也会类似。让我们按照以下方式删除原始列表中的第三个元素F：
- en: '![Figure 10.5 — The original list, after removing the third element in a persistent
    way](img/Figure_10.5_B19301.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 — 删除第三个元素后的原始列表](img/Figure_10.5_B19301.jpg)'
- en: Figure 10.5 — The original list, after removing the third element in a persistent
    way
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 — 删除第三个元素后的原始列表
- en: Working with lists or other structures can always be solved to provide data
    persistence. For now, focus on what will probably be the most important kind of
    work for us – dealing with simple JavaScript objects. After all, all data structures
    are JavaScript objects, so if we can work with objects, we can work with other
    structures.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表或其他结构始终可以解决以提供数据持久性。目前，让我们专注于对我们来说可能最重要的工作类型——处理简单的JavaScript对象。毕竟，所有数据结构都是JavaScript对象，所以如果我们能处理对象，我们就能处理其他结构。
- en: Updating objects
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新对象
- en: This method can also be applied to more common requirements, such as modifying
    an object. This is a very good idea for, say, Redux users – a reducer can be programmed
    to receive the old state as a parameter and produce an updated version with the
    minimum needed changes, without altering the original state in any way.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也可以应用于更常见的需求，例如修改对象。这对于Redux用户来说是一个非常不错的想法——一个reducer可以被编程为接收旧状态作为参数，并生成一个带有最小必要更改的更新版本，而不会以任何方式改变原始状态。
- en: 'Imagine you had the following object:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个以下对象：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let’s assume you wanted to modify the value of the `myObj.d.f` attribute but
    in a persistent way. Instead of copying the entire object (with the `deepCopy()`
    function we wrote earlier), we could create a new object, with several attributes
    in common with the previous object but new ones for the modified ones. This can
    be seen in the following diagram:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想以持久的方式修改`myObj.d.f`属性的值。而不是复制整个对象（使用我们之前编写的`deepCopy()`函数），我们可以创建一个新的对象，它与前一个对象有多个共同属性，但对于修改的部分有新的属性。这可以在以下图中看到：
- en: '![Figure 10.6 – A persistent way of editing an object – that is, by sharing
    some attributes and creating others](img/Figure_10.6_B19301.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 一种持久编辑对象的方法 – 即通过共享一些属性和创建其他属性](img/Figure_10.6_B19301.jpg)'
- en: Figure 10.6 – A persistent way of editing an object – that is, by sharing some
    attributes and creating others
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 一种持久编辑对象的方法 – 即通过共享一些属性和创建其他属性
- en: The old and new objects share most of the attributes, but there are new `d`
    and `f` attributes, so you managed to minimize the changes when creating the new
    object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 旧对象和新对象共享大多数属性，但新的 `d` 和 `f` 属性，所以你在创建新对象时最小化了更改。
- en: 'If you want to do this by hand, you would have to write, in a very cumbersome
    way, something like the following. Most attributes are taken from the original
    object, but `d` and `d.f` are new:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想手动完成这项工作，你需要以一种非常繁琐的方式写下类似以下的内容。大多数属性都来自原始对象，但 `d` 和 `d.f` 是新的：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We saw some similar code earlier in this chapter when we decided to work on
    a cloning function. Here, let’s go for a different type of solution. In fact,
    this kind of update can be automated:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，当我们决定编写一个克隆函数时，我们看到了一些类似的代码。这里，让我们尝试一种不同的解决方案。实际上，这种更新可以自动化：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The logic is recursive, but not too complex. First, we figure out, at the current
    level, what kind of object we need – an array or an object. Then, we copy all
    the attributes from the original object to the new one, except the property we
    are changing. Finally, we set that property to the given value (if we have finished
    with the path of property names), or we use recursion to go deeper with the copy.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是递归的，但并不复杂。首先，我们在当前级别确定我们需要什么类型的对象——一个数组还是一个对象。然后，我们将原始对象的所有属性复制到新对象中，除了我们要更改的属性。最后，我们将该属性设置为给定的值（如果我们已经完成了属性名称的路径），或者我们使用递归进一步复制。
- en: Ordering parameters
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 排序参数
- en: Note the order of the parameters – first, the path, then the value, and finally,
    the object. We are applying the concept of putting the most stable parameters
    first and the most variable last. If you curry this function, you can apply the
    same path to several different values and objects, and if you fix the path and
    the value, you can still use the function with different objects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数的顺序 – 首先是路径，然后是值，最后是对象。我们正在应用将最稳定的参数放在前面，最易变的参数放在后面的概念。如果你将这个函数currying化，你可以将相同的路径应用到几个不同的值和对象上，如果你固定路径和值，你仍然可以使用这个函数与不同的对象一起使用。
- en: 'Let’s give this logic a try. We’ll start with a nonsensical object but with
    several levels, and even an array of objects for variety:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试这个逻辑。我们将从一个多级且具有多个对象数组的无意义对象开始，以增加多样性：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can test this by changing `myObj.d.f` to a new value:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改 `myObj.d.f` 为新值来测试这一点：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The logs at the bottom verify that the algorithm is working correctly – `myObj2.d`
    is a new object, but `myObj2.d.g` is reusing the value from `myObj1`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的日志验证了算法是否正确工作 – `myObj2.d` 是一个新对象，但 `myObj2.d.g` 重新使用了 `myObj1` 的值。
- en: 'Updating the array in the second object lets us test how the logic works in
    those cases:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 更新第二个对象中的数组让我们测试逻辑在这些情况下的工作情况：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We can compare the elements in the `myObj1.d.j` array with the ones in the newly
    created object. You will see that the array is a new one, but two of the elements
    (the ones that weren’t updated) are still the same objects that were in `myObj1`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `myObj1.d.j` 数组中的元素与新创建的对象中的元素进行比较。你会发现数组是一个新的，但有两个元素（那些未更新的）仍然是 `myObj1`
    中的相同对象。
- en: 'This obviously isn’t enough to get by. Our logic can update an existing field
    or even add it if it wasn’t there, but you’d also need to eliminate an old attribute.
    Libraries usually provide many more functions, but let’s work on the deletion
    of an attribute for now so that we can look at some of the other important structural
    changes we can make to an object:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不足以解决问题。我们的逻辑可以更新现有字段，甚至如果它不存在，还可以添加它，但你还需要消除旧属性。库通常提供更多函数，但让我们现在专注于删除属性，这样我们可以看看我们可以对对象进行的其他一些重要结构更改：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The logic here is similar to that of `setIn()`. The difference is that we don’t
    always copy all the attributes from the original object to the new one; we only
    do that if we haven’t arrived at the end of the array of path properties. Continuing
    with the series of tests after the updates, we get the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑与 `setIn()` 的逻辑相似。区别在于我们并不总是从原始对象复制所有属性到新对象；我们只在没有到达路径属性数组的末尾时才这样做。在更新后的测试系列中继续，我们得到以下结果：
- en: '[PRE66]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With this pair of functions, we can manage to work with persistent objects by
    making changes, additions, and deletions in an efficient way that won’t create
    new objects needlessly.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这对函数，我们可以通过以高效的方式修改、添加和删除，而不必无谓地创建新对象来管理持久化对象。
- en: A tip
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小贴士
- en: The most well-known library for working with immutable objects is the appropriately
    named `immutable.js`, which can be found at [immutable-js.com/](http://immutable-js.com/).
    The only weak point about it is its notoriously obscure documentation. However,
    there’s an easy solution – check out *The Missing Immutable.js Manual* with all
    the examples you’ll ever need at [untangled.io/the-missing-immutable-js-manual/](http://untangled.io/the-missing-immutable-js-manual/),
    and you won’t have any trouble!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的用于处理不可变对象的库是名为`immutable.js`的库，可以在[immutable-js.com/](http://immutable-js.com/)找到。它唯一的弱点是它的文档臭名昭著地晦涩难懂。然而，有一个简单的解决方案——查看[untangled.io/the-missing-immutable-js-manual/](http://untangled.io/the-missing-immutable-js-manual/)上的*The
    Missing Immutable.js Manual*，那里有你需要的一切示例，你将不会遇到任何麻烦！
- en: A final caveat
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个最后的注意事项
- en: Working with persistent data structures requires some cloning, but how would
    you implement a persistent array? If you think about this, you’ll realize that,
    in that case, there would be no way out apart from cloning the whole array after
    each operation. This would mean that an operation such as updating an element
    in an array, which took a constant time, would now take a length of time proportional
    to the size of the array.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持久化数据结构需要一些克隆操作，但你是如何实现一个持久化数组的呢？如果你思考这个问题，你会意识到在这种情况下，除了在每次操作后克隆整个数组之外，没有其他出路。这意味着像更新数组中的一个元素这样的操作，原本是常数时间的，现在将需要与数组大小成比例的时间。
- en: Complexity concerns
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度问题
- en: In algorithm complexity terms, updates went from being O(1) operations to O(*n*)
    ones. Similarly, access to an element may become an O(*log n*) operation, and
    similar slowdowns might be observed for other operations, such as mapping and
    reducing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法复杂度方面，更新操作从O(1)变成了O(*n*)。同样，访问一个元素可能变成O(*log n*)的操作，其他操作，如映射和归约，也可能观察到类似的减速。
- en: How do we avoid this? There’s no easy solution. For example, you may find that
    an array is internally represented as a binary search tree (or even more complex
    data structures) and that the persistence library provides the necessary interface
    so that you’ll still be able to use it as an array, not noticing the internal
    difference.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免这种情况？没有简单的解决方案。例如，你可能发现数组在内部表示为二叉搜索树（甚至更复杂的数据结构），而持久化库提供了必要的接口，这样你仍然可以将其用作数组，而不会注意到内部差异。
- en: When using this kind of library, the advantages of having immutable updates
    without cloning may be partially offset by some operations that may become slower.
    If this becomes a bottleneck in your application, you might have to go so far
    as changing the way you implement immutability or even work out how to change
    your basic data structures to avoid the time loss, or at least minimize it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这类库时，没有克隆的不可变更新的优势可能会部分被一些可能变慢的操作所抵消。如果这成为你应用程序的瓶颈，你可能不得不改变实现不可变性的方式，甚至想方设法改变你的基本数据结构以避免时间损失，或者至少最小化它。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at two different approaches (used by commonly available
    immutability libraries) to avoiding side effects by working with immutable objects
    and data structures – one based on using JavaScript’s object freezing, plus some
    special logic for cloning, and the other based on applying the concept of persistent
    data structures with methods that allow all kinds of updates, without changing
    the original or requiring full cloning.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种不同的方法（由常用的不可变库使用）通过处理不可变对象和数据结构来避免副作用——一种基于使用JavaScript的对象冻结，以及一些特殊的克隆逻辑，另一种基于应用持久数据结构的概念，这些方法允许进行各种更新，而不改变原始数据或需要完全克隆。
- en: In [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing Design Patterns*,
    we will focus on a question often asked by object-oriented programmers – how are
    design patterns used in FP? Are they required, available, or usable? Are they
    still practiced but with a new focus on functions rather than on objects? We’ll
    answer these questions with several examples, showing where and how they are equivalent
    or how they differ from the usual OOP practices.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第11章*](B19301_11.xhtml#_idTextAnchor204) *实现设计模式* 中，我们将关注面向对象程序员经常提出的问题——设计模式在函数式编程（FP）中是如何使用的？它们是必需的、可用的还是可用的？它们是否仍然在实践，但新的焦点是函数而不是对象？我们将通过几个示例来回答这些问题，展示它们在哪里以及如何与常规的面向对象（OOP）实践等效或不同。
- en: Questions
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 10.1 `jsonCopy()` function has problems with dates, but that’s not all. What
    happens if we try to copy objects that include maps? Sets? Regular expressions?
    Functions?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 10.1 `jsonCopy()` 函数在处理日期时存在问题，但这并非全部。如果我们尝试复制包含映射的对象会发生什么？集合？正则表达式？函数？
- en: 10.2 `jsonCopy()`; how does `deepCopy()` fare with the same kind of objects?
    Can it be enhanced?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 10.2 `jsonCopy()`；`deepCopy()` 在处理相同类型的对象时表现如何？它可以被增强吗？
- en: 10.3 `JSON.stringify()` will protest if dealing with such. How could you fix
    our `deepCopy()` function to avoid that problem? We did deal with that issue in
    the `deepFreeze()` function, but that solution cannot be used here; something
    different is required.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 10.3 `JSON.stringify()` 在处理此类情况时会提出抗议。你该如何修复我们的 `deepCopy()` 函数以避免这个问题？我们在 `deepFreeze()`
    函数中处理了这个问题，但那个解决方案在这里不能使用；需要不同的方法。
- en: 10.4 `freezeByProxy(obj)` function that will apply this idea to forbid all kinds
    of updates (adding, modifying, or deleting properties) for an object. Remember
    to work recursively if an object has other objects as properties!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 10.4 `freezeByProxy(obj)` 函数将应用这个想法来禁止对对象的所有类型的更新（添加、修改或删除属性）。记住，如果一个对象有其他对象作为属性，你需要递归地工作！
- en: '10.5 `insertAfter(list, newKey, oldKey)` function that will create a new list,
    but add a new node with `newKey` just after the node with `oldKey`. Here, you’ll
    need to assume that the nodes in the list were created by the following logic:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 10.5 `insertAfter(list, newKey, oldKey)` 函数将创建一个新的列表，但在 `oldKey` 节点之后添加一个带有
    `newKey` 的新节点。在这里，你需要假设列表中的节点是由以下逻辑创建的：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 10.6 `composeLenses()` function that will allow you to compose as many simple
    lenses as you want, instead of only two, as in `composeTwoLenses()`, along the
    same lines as what we did in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148)*,
    Connecting Functions**,*when we moved from `composeTwo()` to a generic `compose()`
    function.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 10.6 `composeLenses()` 函数将允许你组合尽可能多的简单透镜，而不是像 `composeTwoLenses()` 那样仅限于两个，正如我们在
    [*第8章*](B19301_08.xhtml#_idTextAnchor148) *连接函数**中做的那样，当我们从 `composeTwo()` 转换到通用的
    `compose()` 函数时。
- en: 10.7 `getField()` and `setField()`. Then, we used composition to access deeper
    attributes. Can you create a lens by giving a path, allowing shorter code?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 10.7 `getField()` 和 `setField()`。然后，我们使用组合来访问更深的属性。你能通过提供一个路径来创建一个透镜，从而允许更短的代码吗？
- en: '10.8 `author` and return the author’s full name in LAST NAME, FIRST NAME format?
    Second, can you write a setter that, given a full name, will split it in half
    and set its first and last names? With those two functions, you could write the
    following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 10.8 `author` 和返回以 LAST NAME, FIRST NAME 格式的作者全名？其次，你能写一个setter，给定一个全名，将其分成两半并设置其首尾名吗？有了这两个函数，你可以编写以下内容：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 10.9 **Lenses for arrays?** What would happen if you created a lens like in
    the following code and applied it to an array? If there’s a problem, could you
    fix it?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 10.9 **数组的透镜？** 如果你创建了以下代码中的透镜并将其应用于数组，会发生什么？如果存在问题，你能修复它吗？
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '10.10 `lensMap()` function to create a lens you can use to access and modify
    maps. You may want to look at the following for more information about cloning
    maps: [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).
    Your function should be declared as follows. You’ll have to write a couple of
    auxiliary functions as well:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 10.10 `lensMap()` 函数来创建一个可以用来访问和修改映射的透镜。你可能需要查看以下内容以获取有关克隆映射的更多信息：[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)。你的函数应该声明如下。你还将不得不编写几个辅助函数：
- en: '[PRE70]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
