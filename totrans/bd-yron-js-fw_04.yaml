- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensuring Framework Usability and Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing on the theme of framework architecture from the previous chapter,
    we will begin to look at the more architectural aspects of JavaScript frameworks.
    While technical architecture plays the core role and provides the guts of the
    framework, there are additional pieces of system architecture that engineers can
    add so that the project has a higher grade of usability and quality. As we mainly
    specialize in JavaScript projects, we will find a variety of tools that help us
    focus on quality. These tools are often built with JavaScript, but they also integrate
    with other systems, making it easier for those familiar with the language to cherish
    the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the technical usability of a framework is a series of development
    quality and usability patterns. These include the additional infrastructure that
    is used as part of framework development and framework usage. Generally, we look
    at these components as tools that improve our framework’s life cycle. First are
    the techniques that ensure the framework’s usability, for framework authors, contributors,
    and users. Second is the supporting infrastructure, such as documentation and
    many types of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to explore these important topics in this chapter, focusing on
    development support patterns that help us build frameworks. Just like the technical
    architectures, these skills and tools can be applied while building any type of
    JavaScript framework. This chapter’s topics include exploring the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Framework documentation** – a set of written or generated materials that
    provide information on framework features and how to utilize the framework for
    new projects. To learn from the best, in this section, we will take a look at
    how other JavaScript frameworks produce public and internal documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variety of framework tests** – used extensively to check the correctness
    of the framework using different types of tooling, such as unit tests, end-to-end
    tests, and more. Focusing further on JavaScript projects, this section explores
    the testing abilities of framework projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development tooling** – external tools that help with the development process.
    This includes additional configurations and tooling that assist with the internal
    workflow of the framework, such as continuous integration, source control enhancements,
    and development tweaks. In the upcoming sections, we will see what type of developer
    tools are used by JavaScript projects such as Vue.js and Nest.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic framework structure** – understanding how we can create our own framework
    structure based on lessons from other open source framework architectures and
    patterns that we have seen in the book so far. This will give us a good outline
    of how authors organize the JavaScript framework code in large projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the resources for this chapter in the book’s repository: [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    To make it easier to interact with the practical portion of this chapter, use
    the `chapter4` directory. The interactive script will make it easier for you to
    run the samples from this chapter. It works as follows from your command prompt
    or terminal window on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As with other chapters, the code in the repository is designed to work in operating
    systems that can run the Node.js runtime, such as Windows, macOS, and most variants
    of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript testing refresher
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be discussing topics related to JavaScript testing.
    If you require a refresher or additional resources to give you in-depth information
    on various types of testing techniques, then check out additional Packt publications
    at [subscription.packtpub.com/search?query=javascript+testing](http://subscription.packtpub.com/search?query=javascript+testing).
  prefs: []
  type: TYPE_NORMAL
- en: Development support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive into a series of techniques and tools that enable developers to build
    quality frameworks focused on usability and ease of use. Learning and utilizing
    these types of development support strategies will help us with our framework
    development, making our projects more usable in internal (work projects) or public
    contexts (open source/publicly published projects).
  prefs: []
  type: TYPE_NORMAL
- en: Some of these development methodologies and skills are not specific to JavaScript
    framework development; they are used across many JavaScript and web application
    development undertakings. However, in the context of framework development, the
    approach to these tooling and usability patterns is different from a regular application
    project. For example, a framework might have a particular expanded set of tests
    that ensures that new features and changes do not break the existing applications
    that use it. This type of extended testing is a particular case that only applies
    to framework projects and not application projects.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, a framework may focus more on technical design benchmarking and
    compatibility testing, supporting a variety of use cases. A lot of this comes
    from the requirements of the framework consumers and stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Core APIs* section of [*Chapter 3*](B19014_03.xhtml#_idTextAnchor051),
    we saw examples of interfaces and features, such as *dependency injection*. These
    interfaces are designed to empower framework users with their flexibility and
    feature set. However, these interfaces need to be documented to be accessible
    to the developers. Otherwise, even if the framework interface is simple enough
    or powerful but not discoverable or explained, it probably won’t be utilized by
    users. These interfaces also need to be thoroughly tested, in isolation and as
    part of a greater system. Finally, we need various types of infrastructure to
    enable this process of testing, maintenance, and documentation. Luckily, there
    are many existing solutions that make framework development and maintenance much
    easier through the tools provided by the greater JavaScript community and external
    software services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us focus on the three categories of usability and quality patterns that
    will help us build a great framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation** – a collection of materials targeting different framework
    stakeholders. These could be generated or written by the framework’s developers.
    This reference can also be internal, showcasing the design decisions and the technical
    architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework testing** – the testing infrastructure is crucial to development,
    feature set, and maintenance as they ensure framework quality. This includes using
    a variety of tools, such as unit, end-to-end, and integration testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development tooling** – the supplementary tools that improve the internal
    workflow of developers. The tools incorporate technologies that simplify working
    with the project. They do this by introducing processes such as source control
    improvements, continuous integration, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each category of these patterns has several subtypes. In most cases, multiple
    existing frameworks rely on these types of techniques in their projects. We are
    going to get into an in-depth look at those patterns in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.1* presents a detailed outlook at an assortment of documentation
    kinds, types of tests, and additional tooling that is used by JavaScript frameworks
    today:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Documentation** | **Framework testing** | **Development tooling** |'
  prefs: []
  type: TYPE_TB
- en: '| Public API | Unit tests | Continuous integration |'
  prefs: []
  type: TYPE_TB
- en: '| Examples | Integration tests | Source control |'
  prefs: []
  type: TYPE_TB
- en: '| Internal documentation | End-to-end tests | Package configuration |'
  prefs: []
  type: TYPE_TB
- en: '|  | Benchmarks |  |'
  prefs: []
  type: TYPE_TB
- en: 'Figure 4.1: Subtypes of tools and patterns utilized in frameworks'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by looking at the documentation, something that our framework cannot
    survive without.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing up documentation is one of the most crucial things for framework adaptation
    and usability. The reference materials produced can enable developers to properly
    utilize the provided tools. Framework developers spent a lot of time writing and
    tweaking their documentation, focusing on providing the most detailed and simple
    explanations of the components of the framework function. With a typical web application,
    you would already have some existing documentation on how to run it and configure
    parts of it. However, while developing a framework, a lot more documentation is
    required, consisting of API methods, learning materials, and other solutions to
    make it easier to utilize the framework to its maximum potential. Today, most
    frameworks invest in showcasing the framework’s API methods, writing up articles
    that help developers learn the framework from scratch, creating interactive tutorials,
    and providing detailed examples demonstrating how a framework can approach the
    challenges of a particular feature set.
  prefs: []
  type: TYPE_NORMAL
- en: A great role model example of documentation comes from the creators of React
    – with the recently launched new learning platform at [https://react.dev](https://react.dev),
    which encourages the use of the library across the ecosystem and within frameworks.
    To help encourage adaption and successful knowledge transfer, their focus was
    on creating a learning environment alongside the API reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you begin to build out your framework, keep in mind that providing a list
    of programmatic APIs is not enough. In *Figure 4**.2*, we can see excellent examples
    of valuable reference material:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Learning React documentation](img/Figure_4.2_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Learning React documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Even though React is a library, there is still much we can learn about how the
    documentation is structured for this project. It consists of several vital items.
    The installation guide comes first and foremost; this can consist of package installation
    guidelines and the ability to scaffold a new project using a framework. Then,
    the existing or potential framework user is presented with a tutorial and an explanation
    of the thinking model behind the tool. Lastly, a series of articles explains the
    most important topics that a developer needs to know about the tool they are about
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Your framework should aspire to a similar form of learning documentation. Even
    in cases of internal framework development, you or your team should still document
    and create learning reference material to encourage proper usage of your framework
    procedures. This kind of approach leads us to the next important part of documentation
    – the API.
  prefs: []
  type: TYPE_NORMAL
- en: Public API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19014_03.xhtml#_idTextAnchor051), as part of exploring framework
    packages, we have examined the framework entry points. Documentation serves as
    another type of entry point; developers interact with the framework by utilizing
    the provided documentation. Primarily, this interaction can be facilitated by
    the **public API** or **API reference**, created from the framework’s code and
    its interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every framework we have seen in this book has an API reference published alongside
    the framework. This type of API reference can be statically or dynamically generated.
    In *Figure 4**.3*, we see an example of such documentation; the Vue.js docs are
    generated from the [github.com/vuejs/docs](http://github.com/vuejs/docs) repository
    and assembled using a static site generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Part of the Vue.js API reference](img/Figure_4.3_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Part of the Vue.js API reference'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many open source projects that can make it easier for you to generate
    and maintain documentation files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docusaurus** ([docusaurus.io](http://docusaurus.io)) – a static documentation
    site generator. Specifically for frameworks, it provides features such as search,
    versioning according to framework releases, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MarkDoc** ([markdoc.dev](http://markdoc.dev)) – another open source for custom
    documentation sites. It is extensible and aims to provide the best documentation
    authoring and publishing experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docus** ([docus.dev](http://docus.dev)) – a documentation generator that
    utilizes familiar to us frameworks such as Nuxt.js and Vue.js. Supports Markdown
    syntax and zero-configuration deploys across many services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeDoc** ([typedoc.org](http://typedoc.org)) – a documentation generator
    for TypeScript source code. Creates static sites based on the comments inside
    of the TypeScript files. The tool also has the ability to output the parsed source
    as a JSON file. A similar tool, **JSDoc** ([jsdoc.app](http://jsdoc.app)), is
    also available for pure JavaScript projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TSDoc** ([tsdoc.org](http://tsdoc.org)) – a similar project to TypeDoc, backed
    by Microsoft. It focuses on standardization efforts around documentation generators
    by providing an engine for other tools to generate comment-based documentation.
    Has integrations with several other projects, such as ESLint and Visual Studio
    Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using one of the tools we just listed might be going overboard if your framework
    is just starting up, but given that documentation is critically necessary to the
    framework’s usability, you need to make sure to make it easier for yourself to
    maintain readable and clean documentation. You can also draw inspiration from
    a larger and more complex framework such as Angular. The project already provides
    the in-depth API reference ([angular.io/api](http://angular.io/api)), but in addition,
    the authors also deliver an exhaustive reference to concepts, error types, and
    diagnostics. All of these can be found in the **guides** section (e.g., [angular.io/guide/file-structure](http://angular.io/guide/file-structure))
    of the Angular website.
  prefs: []
  type: TYPE_NORMAL
- en: As you develop your framework, you will likely introduce drastic breaking changes
    as you go along from version to version. If you are in a context where you already
    have existing framework consumers, then you should spend the time creating a migration
    reference document. Good migration guidelines help your stakeholders keep up to
    date with the changes and use the latest fixes. Some examples of good migration
    guides include the Electron *Breaking Changes* guides ([electronjs.org/docs/latest/breaking-changes](http://electronjs.org/docs/latest/breaking-changes))
    and the Express migration overview ([expressjs.com/en/guide/migrating-5.html](http://expressjs.com/en/guide/migrating-5.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Practical use of documentation tools
  prefs: []
  type: TYPE_NORMAL
- en: The repository directory for this chapter has an example of one of the documentation
    tools in action. In this case, the example uses Docus, with the Nuxt.js framework
    powering the behind-the-scenes infrastructure of the project. You can try this
    out on your own computer by running the interactive script in the `chapter4` directory
    or manually navigating to `practical-docus` and running `npm install`, and then
    `npm run dev`. The documentation site will run on port `3001` and you can live
    edit and interact with the docs tooling by editing files in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Basic documentation can improve your framework experience greatly, but there
    is more you can do to make adaptation more effortless. In the next section, we
    will focus on the importance of providing examples of framework usage. These meaningful
    resources can highlight the strong elements of your framework and ease of integration
    with other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Providing examples drastically helps reduce one of the most challenging aspects
    of adapting frameworks – the learning curve. To encourage adoption and reduce
    friction, framework developers invest time to produce examples of framework usage.
    These could be included as part of the reference documentation or provided alongside
    the framework source code. If you are working on an internal framework, investing
    in examples is still beneficial. If your project will be used by many internal
    teams or new hires, maintaining a base case of examples can reduce the number
    of questions and confusion.
  prefs: []
  type: TYPE_NORMAL
- en: As part of my experience contributing to JavaScript testing frameworks, one
    of the most effective development investments was my focus on creating integration
    guides and developing examples. This was particularly important for a testing
    framework project, as the availability of these resources made it easier for developers
    to add the testing framework into their systems. It also showcased the maturity
    of the project, showing that it is capable of working with many different systems.
    It’s not just my experience, almost all JavaScript frameworks concentrate on providing
    instantly-runnable samples. These projects utilize tools such as **StackBlitz**
    ([stackblitz.com](http://stackblitz.com)) and **CodePen** ([codepen.io](http://codepen.io))
    to enable potential developers to get into the framework environment within seconds.
    For example, navigating to [stackblitz.com/fork/angular](http://stackblitz.com/fork/angular)
    presents you with a ready-to-go Angular framework application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more inspiration, Next.js takes the approach to examples thoughtfully;
    the framework maintains over 50 samples at [github.com/vercel/next.js/tree/canary/examples](http://github.com/vercel/next.js/tree/canary/examples).
    These include showcases of GraphQL support, CMS and blog use cases, integrations
    with other tooling, and deployment targets. To quickly enable users to run the
    samples, the `create-next-app` CLI supports the `example` argument to scaffold
    based on the sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When developing examples for your framework, keep in mind that you will later
    need to maintain all the examples you create, just like the documentation reference.
    If some example code gets out of date and no longer functions as it should, then
    it will cause more burden for you as the framework maintainer.
  prefs: []
  type: TYPE_NORMAL
- en: Practical example with Next.js
  prefs: []
  type: TYPE_NORMAL
- en: You can check out this example in the `chapter4` directory in the `next-example-app`
    directory. Follow the `README.md` file for guidelines on setting up the Firebase
    project. The project requires Firebase project credentials to run properly. To
    initialize the Next.js app, run `npm install` and then `npm run dev`. You can
    also use the interactive script directly from the `chapter4` directory.
  prefs: []
  type: TYPE_NORMAL
- en: To open the application, use the localhost URL, which will likely be `http://localhost:3000`.
    Follow the terminal output for instructions. To edit the files, open the `next-example-app`
    project directory with Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the nature of your framework, you can use the JavaScript runtime
    tools to create a playground environment for your framework. In *Figure 4**.4*,
    we see a sample of the Vue.js component playground; this kind of environment takes
    the idea of examples further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Vue.js single-file component playground](img/Figure_4.4_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Vue.js single-file component playground'
  prefs: []
  type: TYPE_NORMAL
- en: With every “playground” example, you can teach the framework using the most
    basic features to more advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: As you are starting up with your own framework, it is better to include your
    examples as part of your framework repository. To lessen the maintenance burden,
    make sure you execute your examples as part of your testing infrastructure (more
    on that later in [*Chapter 10*](B19014_10.xhtml#_idTextAnchor173), related to
    framework maintenance). If you are working on the framework alone or with a small
    team, the usage of included examples in your framework can greatly enhance the
    development process, helping you iterate quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Internal documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The internal documentation is all about helping the framework authors to continue
    developing the framework. Even if you are the only author of the framework, it
    is still useful to maintain internal documentation, even for your own sake. This
    way, you can look back on the code and design decisions from the past and make
    it easier to make updates to your project. Primarily, this type of documentation
    should not be consumed by the framework users or stakeholders. However, it can
    still be useful to expose these materials for debugging use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The internal documentation can potentially include detailed interfaces of internal
    modules. It could potentially describe the design principles of the internal implementation.
    For instance, the Nuxt.js framework combines both public-facing and internal documentation
    on its reference pages. The framework’s renderer, builders, generator, and other
    classes are described in the Internals Glossary ([github.com/nuxt/nuxtjs.org/tree/main/content/en/docs/6.internals-glossary](http://github.com/nuxt/nuxtjs.org/tree/main/content/en/docs/6.internals-glossary)).
    For instance, Nuxt provides its own module system ([nuxtjs.org/docs/directory-structure/modules](http://nuxtjs.org/docs/directory-structure/modules))
    to extend the framework functionality, and the internals of that feature are supported
    by the `ModuleContainer` class. This class is part of the framework’s internals
    and should still be documented. It also enables framework plugin development for
    external developers to understand and extend the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of using this type of documentation for the framework’s benefit
    can be seen in Vue.js. The framework utilizes the TSDoc tooling internally to
    ensure the specification of its functions, such as the shared utility methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code taken from the developer tools repository of the framework
    ([github.com/vuejs/devtools/blob/main/packages/shared-utils/src/util.ts](http://github.com/vuejs/devtools/blob/main/packages/shared-utils/src/util.ts))
    is a simpler example of documentation annotations that are available to framework
    developers while browsing the file, can later be exported to an external document,
    or can be previewed by an IDE while accessing this helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Contribution guidelines** are also part of this type of internal documentation.
    For both open and closed frameworks, you will potentially have someone who wants
    to make changes or contribute to the framework, either helping you fix issues
    or introducing new features. Contribution documentation helps enable this, providing
    the steps to quickly write and test new framework changes. As part of the contribution
    instruction, it is often important to list several important pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: First, how to modify the framework, build it, and test it. This includes pointers
    to all the relevant scripts that make the development process more approachable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, how to successfully write a patch, both in open source and internal
    environments. This includes following the source control guidelines and commit
    history rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make framework contributions easier, this type of documentation should mention
    the coding rules around public and internal APIs, file formatting, and other potential
    style guides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide some examples, Ember.js has a page on their contribution guidelines
    at [guides.emberjs.com/release/contributing](http://guides.emberjs.com/release/contributing),
    and other frameworks such as Angular include a `CONTRIBUTING.md` file in their
    repositories at [github.com/angular/angular/blob/main/CONTRIBUTING.md](http://github.com/angular/angular/blob/main/CONTRIBUTING.md).
  prefs: []
  type: TYPE_NORMAL
- en: Framework testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like any software project, frameworks require a number of tests to ensure
    that the framework is functioning as intended. In the framework context, you will
    find much in-depth testing focused on correctness, performance, and special framework
    use cases that need to be handled for all possible usage scenarios. We have seen
    examples of testing frameworks in the *Testing frameworks* section of [*Chapter
    1*](B19014_01.xhtml#_idTextAnchor015); those can be used from within our frameworks
    to simplify the testing workflow. In this section, we are going to look at what
    techniques JavaScript frameworks use internally to ensure that the final framework
    product is of high quality.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like most software projects, frameworks also include unit tests for their
    interfaces. They utilize a testing framework similar to the ones we have seen
    listed in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015). Often, you will see
    these types of tests called “specs” as well, meaning they are *specification tests*.
    This means that, given a certain component of a framework, there is a technical
    specification that it should adhere to. In the framework context, comprehensive
    tests help with refactoring major components much more quickly. Open source frameworks
    also benefit from a good unit testing suite when receiving external code contributions.
    It is much easier to review and be confident in the code change when there is
    a vast collection of existing tests and new tests being added as part of the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the type of JavaScript framework, the testing environment and
    testing challenges can be different. In frameworks that target the browser, the
    unit testing requires mocking out browser and web APIs. For instance, Angular
    introduces several internal testing interfaces to simplify working with components
    that are injected into the DOM. Angular’s “change detection” and other DOM-related
    functionality use these testing interfaces to abstract away working with the `document`
    object instance directly. For example, Angular developers create several test
    wrappers to make it easier to attach the framework’s node tree to the DOM body,
    as seen in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `change_detection_spec.ts` file relies on the `withBody` helper from the
    test utilities; these utilities rely on executing many frameworks’ tests in an
    environment where a `document` object is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'In backend frameworks, projects may choose to mock out or create test-only
    classes based on the existing interfaces. For instance, Nest.js has defined a
    `NoopHttpAdapter` class ([https://github.com/nestjs/nest/blob/master/packages/core/test/utils/noop-adapter.spec.ts](https://github.com/nestjs/nest/blob/master/packages/core/test/utils/noop-adapter.spec.ts))
    that extends `AbstractHttpAdapter`, which we have seen before in the *Backend
    abstraction* section of [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030). The following
    code shows how the testing adapter is structured to make it easier to use it in
    framework tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `HttpAdapter` TypeScript class is used within the framework’s specification
    testing to ensure that the main `Application`, `Routing`, and `Middleware` classes
    function as they should.
  prefs: []
  type: TYPE_NORMAL
- en: 'While developing your JavaScript framework, ensure to unit test every new component
    or interface that you add. This process will help you in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It will increase the code quality and help you organize your framework such
    that its components fit better together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework development process is full of constant refactoring or changes.
    Your unit testing suite will grow as your framework grows and will increase your
    confidence in the changes as you code along.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, ensure that your unit testing suite runs efficiently. For example,
    Vue.js uses the Vitest test runner. Vue has over 2,500 unit tests, which execute
    in about 20 seconds. The unit tests of your framework should run as fast as possible
    to provide you with a blazing-fast feedback loop while you are busy developing
    new framework features.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integration tests are created with the purpose of testing how multiple interfaces
    or components of the framework fit together. These tests can catch issues that
    are not detected by unit/specification testing due to the fact that those types
    of tests are designed to test the component in isolation. Integration tests simulate
    the interaction between the components, making sure that the functionality fits
    well together.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of frameworks, the internal core architecture has to fit together.
    This means the integration tests would be verifying that behavior. For instance,
    a good integration test for a full stack framework would be ensuring that a component
    is rendered when a particular `router` route is called to. This kind of test ensures
    that all those components are behaving nicely together.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, frameworks usually have to integrate with other systems. This means
    developers also need to produce integration tests between a framework and that
    external system. For example, the Gatsby framework has integration tests ([github.com/gatsbyjs/gatsby/tree/master/integration-tests](http://github.com/gatsbyjs/gatsby/tree/master/integration-tests))
    for its static-site rendering, command-line interface, and caching infrastructure.
    These tests verify the framework’s features. However, Gatsby also includes integration
    tests to verify that it works with other technologies. The framework has an integration
    test to verify compatibility with the JavaScript ESM module standard.
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests can be challenging, as you have to verify that all
    sorts of interface combinations are working faultlessly together. Though it is
    an essential part of the framework development process, this type of testing can
    ultimately be much more beneficial than unit testing if you are in a rush to deliver
    your new framework project.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: End-to-end tests evaluate how the framework is functioning as a system overall.
    Usually, these tests simulate almost real user interaction. For a frontend framework,
    creating these tests usually means configuring one of the end-to-end testing frameworks.
    For server-side frameworks, the end-to-end tests usually simulate real requests
    to a server that is powered by the framework. Similar to its set of integration
    tests, Gatsby also maintains a suite of `transition`, `grid`, and `tree-view`
    interfaces. These can be found at [github.com/vuejs/core/tree/main/packages/vue/__tests__/e2e](http://github.com/vuejs/core/tree/main/packages/vue/__tests__/e2e).
    These tests use Puppeteer to execute commands in a headless Chrome browser, thus
    simulating real browser and user behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extensive E2E test suite can support the development of your framework in
    several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Catch regressions of the whole system, such as simulating common framework commands
    and expected functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm that all components of your framework can work together as you make
    changes and develop new features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate performance trials into E2E tests to be able to detect the slow performance
    of your framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the framework works correctly with external systems. These systems
    can include different types of web browsers or different backend environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important form of testing for frameworks that is relevant in many projects
    today is benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of benchmarking runs a set of assessments and trials on a particular
    scenario of your framework. These benchmark tests can be written by framework
    authors or an external party. For the purposes of framework building, we are focusing
    on the former, where a framework includes a series of benchmarks as part of its
    internal testing. Frameworks can potentially compete on their benchmarking scores
    for tasks such as rendering a particular component configuration, or, in the case
    of backend frameworks, the time it takes to process a large number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: For JavaScript frameworks, it is essential to benchmark the performance of the
    code in the runtime. In the browser runtime, the benchmarks are focused on efficient
    rendering and processing large inputs. In the full stack Next.js framework, the
    authors include several benchmarking scripts to test various features (found at
    [github.com/vercel/next.js/blob/canary/bench](http://github.com/vercel/next.js/blob/canary/bench)).
    When you are developing benchmarks of your own, keep in mind that you probably
    do not need any complex tooling. Instead, you can rely on built-in methods of
    the runtime – in this case, in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.5* shows one of the simpler benchmarking scripts [github.com/vercel/next.js/blob/canary/bench/recursive-copy/run.js](http://github.com/vercel/next.js/blob/canary/bench/recursive-copy/run.js)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Benchmarking in the Next.js repository](img/Figure_4.5_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Benchmarking in the Next.js repository'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.5*, the main function provides a recursive copy implementation
    to the test. Executing the `run` function with two different implementations provides
    us with comparison results of these two functions.
  prefs: []
  type: TYPE_NORMAL
- en: For backend frameworks, factors such as memory utilization, request throughput,
    and latency are often benchmarked. For inspiration, Nest.js maintains a set of
    benchmarking tools to compare the performance of the HTTP servers provided by
    the framework at [github.com/nestjs/nest/tree/master/benchmarks](http://github.com/nestjs/nest/tree/master/benchmarks).
    In other types of frameworks, such as application development (Electron) and testing
    frameworks, the benchmarks are also focused on performance. As we saw in the *Framework
    testing* section earlier in this chapter, the testing framework itself needs to
    execute the test suites as efficiently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You, as a framework developer, should focus on setting up benchmarks for two
    use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the benchmark for the public interfaces your framework exposes. These
    would allow you to gauge how long it takes for your framework to complete the
    tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, you want to look into the micro-benchmarks of the framework internals.
    These internal benchmarks help optimize particular parts of the framework’s core,
    enabling speed improvements in the internal functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you further develop your project, keep an eye on measurements of your benchmarks,
    ensuring that you do not regress the speed of your framework.
  prefs: []
  type: TYPE_NORMAL
- en: Development tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The framework development and the release process can greatly benefit from the
    inclusion of additional tools that elevate the quality and usability of the framework
    project. These workflows could be applied to various aspects of the framework,
    such as dependency management, testing, editor configuration, formatting, and
    more. We already saw a similar approach of relying on additional scripts and tooling
    in the *Binaries and scripts* section of [*Chapter 3*](B19014_03.xhtml#_idTextAnchor051).
    Additional tooling that can improve our framework’s development life cycle includes
    the introduction of continuous integration steps, improving the source control,
    and the addition of package-level utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of the development cycle, just like many web application projects, frameworks
    configure **continuous integration** (**CI**) steps to test the code changes and
    new releases. These CI systems run tests of all types, such as the ones mentioned
    in the *Framework testing* section of this chapter. Every change committed using
    a version control system has to pass the existing test suite. This ensures that
    the changes do not introduce breaking changes or bugs. Besides running the tests,
    CI runs other types of analysis, such as formatting checks, linting, and more.
    These ensure consistency, usability, and quality.
  prefs: []
  type: TYPE_NORMAL
- en: If we focus on framework development, there are a few special uses for CI. It
    ensures that the framework works properly in different JavaScript environments.
    For a frontend framework, this means executing tests in a variety of browsers
    on different platforms. Browser support testing goes both ways – new features
    must work in older browser versions, and new browsers should not break any of
    the existing framework features. Node.js and Deno frameworks that run on the backend
    keep track of newer runtime versions, following the [github.com/nodejs/release](http://github.com/nodejs/release)
    release schedule. Running these compatibility checks in CI is the best solution;
    the CI platforms allow to quickly spin up different versions of environments and
    parallelize the test execution in those environments.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the focus on testing in various environments, the CI step can run a
    series of tests of projects that depend on your framework. For example, it can
    generate and run a sample application or an external script with the new framework
    changes applied. This way, it can check whether the changes are compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the framework CI configuration, the integration story may be different.
    In *Figure 4**.6*, we see four successful checks; this is part of the Vue.js CI
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Vue.js reporting its CI status](img/Figure_4.6_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Vue.js reporting its CI status'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Angular, there are over 20 checks in the CI pipeline before a
    code change can be merged into the repository. The reason for a growing number
    of integration steps is the execution tasks that are not tests. These could be
    formatting, spelling, and JavaScript code usability checks.
  prefs: []
  type: TYPE_NORMAL
- en: The CI steps can vary in complexity and type, and they can also contribute to
    the release process of your framework. No matter what type of framework you are
    working on, internal or public, it is highly advised to configure a CI step as
    part of your framework development. This approach will ensure the quality of the
    code and help you maintain efficiency in your framework development.
  prefs: []
  type: TYPE_NORMAL
- en: Source control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using source control for frameworks is similar to using it for other application
    projects. Nevertheless, JavaScript frameworks rely on source control tooling for
    tagging framework releases and keeping track of feature development branches.
    The use of source control in this context is a bit more in-depth. For instance,
    a framework author might need to write patches for an older version of the framework,
    which means jumping back to an older Git tag to introduce that change. In many
    cases, large framework refactoring also takes place in a temporary Git branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most JavaScript frameworks also configure supplementary source control scripts
    that improve the workflow as new features and changes get developed. In *Figure
    4**.7*, we see the Nest framework using the Git pre-commit hook to execute JavaScript
    linting scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: The pre-commit hook configuration](img/Figure_4.7_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: The pre-commit hook configuration'
  prefs: []
  type: TYPE_NORMAL
- en: The pre-commit hook, in this case (*Figure 4**.7*), enforces the code quality
    standards before the changes are committed. The step to configure this kind of
    behavior is simplified using a JavaScript module called **Husky** ([typicode.github.io/husky](http://typicode.github.io/husky)).
    You will find this pattern in a lot of the frameworks, as this is a handy addition
    to make the development process much more friendly.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is a given that you will use source control for your new framework.
    However, you can invest in additional tooling by learning from some of the existing
    frameworks that we’ve seen in this book to improve your coding workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Package configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `package.json` file and the additional files in the root of the framework
    directory define the package configurations of the project. The number of such
    configurations may vary depending on the types of tools you use in your framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package configuration of Nest.js consists of many tools, such as ESLint,
    Git, npm, and Gulp, to name a few. Similar to the Nest.js configuration seen in
    *Figure 4**.8*, the `package.json` file will be the development entry point of
    your framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Package configurations of Nest.js](img/Figure_4.8_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Package configurations of Nest.js'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `package.json` file consists of the information about your framework, its
    dependencies, and auxiliary configuration used by other tools. For example, the
    Nest.js package file ([github.com/nestjs/nest/blob/master/package.json](http://github.com/nestjs/nest/blob/master/package.json))
    stores configuration for the `nyc` code coverage tooling, the `mocha` test runner
    configuration, and commands for the changelog tooling. Besides those configuration
    entries, the package file has the `scripts` object. This object consists of commands
    that can be used during framework development. In the Nest.js case, these commands
    run some of the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build** – the command that compiles or builds the framework. Nest.js executes
    the TypeScript compiler as part of this command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean** – a quick command that cleans the working directory of the framework
    project. Usually, this means getting rid of any generated or built files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test** – commands that run all types of tests that are included in the framework.
    In the cases of Nest.js and many other frameworks, these types of commands are
    usually split by the type of tests they are running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lint** – analyzes the JavaScript code in the project, looking for coding
    style errors, pitfalls, and potential issues. Nest.js uses ESLint, running in
    parallel to quickly diagnose the framework files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Install** – installs the dependencies of the project. In the case of Nest.js,
    the dependency modules provide the functionality that is required to run a backend
    service. The developer dependency list has all the infrastructure modules to work
    on the framework project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coverage** – runs testing code coverage tooling to determine whether more
    tests are required to fully cover all the framework logic. For instance, Nest.js
    uses **Istanbul** ([istanbul.js.org](http://istanbul.js.org)) for the code coverage
    report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not an extensive list, but it provides some inspiration for command
    types you can include in your project. The `scripts` part of the `package.json`
    file usually follows the reference material at [docs.npmjs.com/cli/using-npm/scripts](http://docs.npmjs.com/cli/using-npm/scripts),
    but different JavaScript package managers may treat these commands a bit differently.
    Your framework should utilize `package.json` to your advantage, creating quickly
    accessible scripts and configuring the `package.json` file as the entry point
    for your framework’s development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in this section, there are a lot of development tools that empower
    framework development and are crucial to make the project successful. These development
    patterns have been improving over many years and are now deeply embedded in many
    JavaScript projects. In the next section, we shall take a look at the overall
    picture of a framework structure, which will give us a solid outline for our own
    framework project.
  prefs: []
  type: TYPE_NORMAL
- en: Learnings from other architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the current and previous chapters, we’ve seen all the different technical
    structures, tools, and patterns that frameworks use for their benefit. If we browse
    through the sources of frameworks gathered in the *Framework showcase* section
    of [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we can start to clearly see
    repeating patterns. Following these practices, we can take advantage of them in
    our own framework development. By gathering knowledge from the existing designs
    from different types of JavaScript frameworks, we can conceive a structural system
    that can serve us well in building our project. We can fuse all those methods
    and practices into a general framework structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the generic JavaScript framework structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This project structure should help demystify the approach to our framework project
    structure and empower you, as a developer, to design your own. The framework file
    and directory structure is the culmination of the last two chapters, combining
    many of the components that we have seen so far – framework packages, the compiler
    infrastructure, framework testing, documentation, scripts, and more. Future chapters
    will be using this structure for our own framework building.
  prefs: []
  type: TYPE_NORMAL
- en: As we look at the core architectures and the examples of what the framework
    projects consist of, it helps us form what our framework will include and look
    like. Not everything that we see in the current architecture example will be necessary
    for our framework to function or succeed. In fact, if you will be building a framework
    for internal project use only, then you will be choosing a different combination
    of tools that help you with development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the importance of framework documentation, the variety
    of tests that improve stability, and the array of internal tools that establish
    efficient framework workflows. The investment in good documentation helps both
    framework authors and framework users. The lack of well-defined documents can
    be devastating to the framework’s success. Luckily, there are a ton of tools that
    help simplify the approach to documentation. In the same sense, there are existing
    tools for testing workflows, covering all aspects of code testing within the framework.
    Finally, the additional tooling, such as improved source control and editor configurations,
    makes it much more pleasant to work on the framework and helps authors focus on
    the framework internals. All of these development support factors play an essential
    role in framework development and architecture. Learning from other projects and
    utilizing the patterns that support the development process helps us expand our
    architectural skills and be more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have learned a lot about existing framework technologies that
    enable web application and backend service development targeting the JavaScript
    runtime. In the next chapters, using these learnings and detailed exposure to
    existing framework projects, we will dive into the aspects of our framework building.
    This means starting a brand-new project from scratch. Utilizing the patterns,
    abstractions, and lessons learned from existing projects, we get to experience
    what it takes to build our own framework.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on some of the considerations a framework author
    needs to take into account before starting off with a new project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Framework Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, the book builds on top of the real-world framework examples and
    switches gears to focus on the programming aspects of framework creation from
    scratch. The goal is to cover the complete process of planning, architecting,
    and publishing a new full stack framework. These stages include several important
    considerations and a lesson in the architecture of various types of components.
    The emphasis is on the practical approach and guidance of each process’s steps
    that benefit developers of all types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, we cover the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19014_05.xhtml#_idTextAnchor073), *Framework Considerations*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19014_06.xhtml#_idTextAnchor089), *Building a Framework by Example*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19014_07.xhtml#_idTextAnchor108)*, Creating a Full Stack Framework*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19014_08.xhtml#_idTextAnchor138)*, Architecting Frontend Frameworks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
