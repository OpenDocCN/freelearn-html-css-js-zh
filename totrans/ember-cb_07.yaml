- en: Chapter 7. Ember Models and Ember Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the functionalities of Ember Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, reading, updating, and deleting records with Ember Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the adapter and serializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models are objects in Ember that represent data that can be displayed to users.
    They are persistent and won't be lost when the user closes the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Many models are loaded from data that is stored in a server from a database.
    Typically, the data is sent back and forth as a JSON representation. This is where
    Ember Data comes in. Ember Data is included by default when you create an application
    in Ember. It helps retrieve data, store data locally, and save information to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Ember Data can be configured to work with many different types of databases
    and servers. If used properly, Ember Data can help manage your application models
    without the use of multiple Ajax requests throughout your application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the functionalities of Ember Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember Data uses a single data store that can be accessed throughout an application.
    In this example, we'll create a simple application that retrieves a list of books
    and displays it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin, we'll need to mock data for our server. Ember CLI has a built-in
    mock server that can handle this situation by generating a basic **Express server**.
    However, for the purposes of this recipe, we'll go ahead and use the Ember CLI
    Mirage add-on. It has more features and is easier to use. You can find more information
    about Ember CLI Mirage at [https://github.com/samselikoff/ember-cli-mirage](https://github.com/samselikoff/ember-cli-mirage).
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s create a new application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the application has been created, let''s install the add-on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install the latest Bower and `npm` packages needed and create the
    `book` factory for Mirage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make this recipe work, we'll need to mock book data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `config.js` file in the `app/mirage` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This configuration file will set the fake routes that we need for our data.
    The `/books` route will return all the book data and the `/books/:id` route will
    return individual books based on the ID passed in the URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `book.js` file in the `app/mirage/factories` folder. Add the following
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file sets the properties that we'll use later for our model. The `title`
    property refers to the name of the book, `author` refers to the person who wrote
    the book, and `year` is the year it was published. To make things a little easier,
    Ember CLI Mirage includes a library called `faker`. This library generates data
    that we can use to populate our in-memory data store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `default.js` file in the `app/mirage/scenarios` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to delete the comments around `server`. This scenario will generate
    ten new `'book'` records every time the browser is loaded. After the browser is
    loaded, the books will be generated via the factory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Begin by creating a model file for our books, a REST adapter, and a route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will generate a new model called `book`, and set the `title`, `author`,
    and `year` as properties in this model. The generate `adapter` command will create
    a new adapter for our application, while the last commands will generate routes
    for the `book` and `application`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `book.js` file in the `app/models` folder. It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `models` file is a representation of the data that we''ll be using. We
    can use three different types of data: `string`, `number`, or `date`. This data
    will be loaded from our mock server.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `application.js` file created in the `app/adapters` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ember Data has several adapters available for it. One of the easiest to use
    is the REST adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The REST adapter data expects the data from the server in this format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding JSON lists an array of books. If, by chance, only one record was
    returned, the REST adapter would expect the array to be named `book` and not `books`.
    Keep in mind that you should camel-case all record names and the data should be
    in the REST adapter format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll need to be able to retrieve data from our data store and present it
    to the user. Edit the `application.js` file in the `app/routes` folder. Add a
    new model that returns all the books listed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As discussed in [Chapter 4](part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 4. Ember Router"), *Ember Router*, one of the responsibilities of the
    route is returning the model data. The Ember Data store has a method called `findAll`
    that will return all the data from the `book` model. By convention, the Ember
    application will execute an HTTP GET to the `/book/ URL` and expect a JSON payload
    in response. As this model is in the application route, it can be accessed in
    any template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `application.hbs` file and display the new data from the mock server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This template uses the `each` helper to iterate though all the data that is
    returned from the `model` hook after the page loads. The `link-to` helper will
    pass `book.id` in the URL as an argument. We'll use the book `title` as the link.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the books route so that it returns a single record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `model` hook receives a parameter from the URL. The `findRecord` Ember Data
    can be used to find individual records. It will make an HTTP GET request to the
    `/books/:id` URL when the `model` hook is loaded. The first argument is the data
    store and the second is the record ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `router.js` file in the `app` folder with the new dynamic route
    for `books`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This new route for `books` has a path of `/books/:book_id`. To access the `books`
    route, you have to submit an ID in the path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `books.hbs` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Accessing this route will trigger the `model` hook. This will render `author`
    and `year` of the book selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` and open a web browser. You'll see a list of all the titles
    with links to each individual book:![How to do it...](img/00038.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each post has a unique ID. Clicking on a link will display the title and author
    of that book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Models represent data in Ember. These models can use Ember Data to store, update,
    and retrieve data from a server. The data from the server is usually sent in the
    JSON format. Ember offers a handful of adapters to the interface with the data
    coming from the server. The REST adapter is the most commonly used. It expects
    data in a certain format so that Ember can parse, store, and display it to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Ember Data caches the data after it retrieves the data from the server. This
    minimizes the amount of round-trips to the server. However, Ember Data will make
    a request in the background whenever a cached data record is returned from the
    store. If the data has changed, it will be rerendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, reading, updating, and deleting records with Ember Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we retrieved already existing book data from our mock
    server and displayed it to the user. Ember Data also has the ability to create,
    delete, and even update records from the data store. We will be looking at these
    methods and more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the previous example, we'll need to install Ember CLI Mirage. Take
    a look at the previous recipe for instructions on this process. We'll be using
    the same factories as the book recipe and we'll be adding new methods to add,
    edit, and delete data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mirage` folder, open the `config.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will mock our backend and allow us to create, update, and delete data.
    This is done using the HTTP PUT, POST, and DELETE requests. We'll use this later
    in our program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `book.js` file in the `app/mirage` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This factory will be used to generate fake data that the Mirage in-memory database
    will return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `default.js` file in the `scenarios` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time that the application loads, the server will create `10` `book` objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll be adding to the book example that we had in the *Understanding
    the functionalities of Ember* *Data* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route called `new` and controller named `books`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate the `new` route and `books` controller files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new template for the new route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new route will be used to add a new book to the repository. In this template,
    the `input` helper is used to create three textboxes. Each will be bound to the
    info property. A button at the bottom will submit the changes to the `newText`
    `action` method. The `cancel` button will trigger the `cancel` action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `new.js` controller with the new `actions` for `cancel` and `newText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is a lot going on here; let''s take a look at the `newText` action first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this action, we are getting the `info` property that was declared earlier.
    This property is an object that is used to store values from the template. The
    store has a method called `createRecord` that takes two arguments. The first argument
    is the model. The second is the object that we want to store. In this case, we
    want to add a new `book` record to the store. We use the `inf` object to set the
    `title`, `author`, and `year`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the `createRecord` method doesn''t persist the changes. The `save()`
    method is used to persist data back to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `save` method is a promise. It will either succeed or fail. If it succeeds,
    we use the `transitionToRoute` method to change the route back to the main application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Afterwards, we set the `info` property back to an empty object. We do this
    so that the template `input` helper is cleared of all data. If it doesn''t succeed,
    then we output an error to the console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `cancel` action returns `true`. What this means is that instead of the
    controller handling it, it will be bubbled up to be handled by the route:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**REST with Ember**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using the REST adapter in Ember, the `save()` method will send a PUT, DELETE,
    GET, or POST HTTP request to the server. The PUT request will be sent during an
    update. The DELETE request is used to delete a record. POST is used to add a new
    record, and the GET request is used to retrieve records. This is done by convention
    by the Ember REST adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `books.hbs` template file with a new action to update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ve updated the books template to behave differently from our last example.
    In this example, it will allow us to edit the entries as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00039.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Update the `books.js` controller to handle the new `updateText` and `cancel`
    actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `updateText` action gets the current book `model`, sets the `year`, and
    then saves it. Afterwards, it transitions to the `application` route. If needed,
    we could handle the error condition if the save promise fails. For the sake of
    simplicity, we'll leave it as is. The `cancel` action returns `true`, which means
    that it will bubble up to the books route to be handled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `books.js` file in the route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The route file is the same as the previous recipe, except now we have a `cancel`
    action. This `cancel` action will be triggered after the controller returns `true`.
    By returning `true` here, the action bubbles up one more time to the application
    route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `new.js` route file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file will receive the action from the new controller. It also returns `true`,
    which means that the `cancel` action will be handled by the application route
    as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the application route file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `cancel` action in the application route handles the new and book routes
    `cancel` action. In either case, it will transition to the `application` route.
    In summary, the bubbling of the action went from the new controller to the new
    route and finally to the application route. If the `cancel` action was not included
    in the controller, by convention, the action will automatically bubble up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to update the application template and add a new option to delete records.
    Update the `application.hbs` file with the new `delete` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application will display each book. There is also a `delete` action button
    at the bottom of each record that passes in the `book` record.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the application controller to handle the new `delete` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The book record has a method called `deleteRecord`. This deletes the record;
    however, it doesn't send the HTTP delete request to the server until `save()`
    is done. Another method called `destroyRecord` will `delete` and `save` at the
    same time. For this example, we'll use `deleteRecord` instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Load the Ember server and you'll see a list of records. You can click on each
    record and delete or edit it:![How to do it...](img/00040.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Not using Ember Data?**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ember Data is the preferred method when working with a backend data store. However,
    it doesn't have to be the only option. When defining model information in a route,
    you can use Ajax methods or define your own repositories as well. You can use
    services and inject them throughout your application if needed. This will take
    a substantial amount of extra work, depending on your setup, but it is an option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember Data comes with several adapters that can be used to retrieve data from
    a backend server. The REST adapter allows the user to make requests to a backend
    server using HTTP GET, DETETE, PUT, and POST requests. By default, it expects
    responses in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The Ember Data store methods allow a user to find, delete, and save records.
    The Ember `save()` method triggers a response to the server. Before the save is
    done, records can be rolled back if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Using fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixtures are another way of mocking data. It's static data that can be used
    in our model to display to the user when testing our application. In this recipe,
    we'll see some basics on how to set it up with Ember CLI Mirage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with many of our other examples, we'll be using Ember CLI Mirage. Instead
    of using a factory, we'll set up fixture data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a new application. Then add the Ember CLI Mirage add-on and
    generate the model and routes for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These commands will generate the basic structure of our app. In this application,
    fixture data will be used to display student information. For the sake of simplicity,
    we'll only be displaying this information and not manipulating it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `mirage` `fixtures` folder, update the `students.js` file and add the
    fixture data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The fixture data has four records. Each record has a different student's `name`
    and `age`. To use fixture data with Ember CLI Mirage, you must enter it as an
    array of objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `config.js` file in the `mirage` folder. This file is used to set
    the `students` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will set up a mock server endpoint for Ember Data to reach. By convention,
    Ember Data will look for the URL path of the pluralized model name. In this example,
    our model will be student; therefore, when Ember Data looks for data, it will
    do a GET request to `/students` on the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new scenario to the `default.js` file for the fixture data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `loadFixtures()` command will load the fixtures in memory so that they are
    available to the `students` route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we created the model file. Let''s take a look at it first to make
    sure that everything is set up correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `student` model has two properties called `name` and `age`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the route `index.js` file to return the students model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The route file will return all `student` records using the `findAll` method.
    This will trigger an HTTP GET request to the server at `/students`. The `model`
    hook is triggered when you visit the route. By convention, Ember will then cache
    these results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the application adapter. Set it to the REST adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RESTAdapter` will be used for all routes. It''s a type of adapter that assumes
    that JSON data will be sent via XHR.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `index.hbs` file. This will display the model information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we use the `each` helper to iterate through all the records.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` and the following results should be displayed:![How to do
    it...](img/00041.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the page loads, a list of the students' names and ages will be displayed.
    This data is retrieved from the fixture data that we set up earlier using our
    mock server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fixtures are used when testing an application. It is well-known data and can
    be used for repeated tests. Ember CLI Mirage can be set up to use fixture data.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be going over using fixture data with testing in the testing chapter in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the adapter and serializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember Data is very opinionated on how it wants to access data. The adapter has
    built-in assumptions on what the data looks like. We can use serializers and adapters
    to change these assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll be building on the student application that we created
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the same application from the previous recipe. We'll need to
    edit Ember CLI Mirage to handle a new namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `config.js` file in the `mirage` folder, update the `students` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will change the endpoint to `api/v1/students` instead of just `/students`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the students application from the previous section, edit the `application.js`
    file in the `adapters` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new `namespace`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `namespace` property is used to prefix requests with a specific URL. In
    this case, all requests will have `api/v1` prepended to them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the Ember server and you should see requests going to `/api/v1/students`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optional customizations in Ember Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ember offers a number of other customizations if needed. Here are a few important
    ones to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Host customization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the adapter file, you can add a new location where Ember Data should send
    requests. This overwrites the default location of the local server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As an example, now all the requests will be sent to `api.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Headers customization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Depending on the API, you may need to send specific headers in each HTTP request.
    You can add this using the `headers` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will add new `headers` for every request that is sent. If needed, you can
    also use dynamic information in your headers by creating a computed property.
  prefs: []
  type: TYPE_NORMAL
- en: Working with serializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Ember Data, serializers format the data that's sent and received
    from the backend data store. We can customize this data to fit the needs of our
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Updating IDs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, Ember Data expects each record to have an ID. We can change the
    name of this using the primary key property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a new `serializer` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This generates the `serializer` file that we can update.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `application.js` serializer with the new ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will transform the ID property to `_id` when serializing and deserializing
    data. In other words, when data is sent or received from the server, it will have
    a primary key that is set to `_id`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: KeyForAttribute when working a JSON payload
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At times, the data sent back from the server may not be in the correct format.
    For example, `RESTAdapter` expects the JSON payload attribute names in camel-case.
    We can change this using the `keyForAttribute` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For example, let's say that the data sent back from the server is underscored
    instead of camel-cased. The server is returning `school_name` instead of `schoolName`.
    This can be fixed using `keyForAttribute` and `decamelize`. This will take the
    model name `schoolName` and `decamelize` it to `school_name` so that it matches
    what's returned from the server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adapters are used in Ember Data to help interpret data that is sent and retrieved
    from the server. It has a set of built-in assumptions on how the data should look.
    We can make changes so that we can accommodate different types of APIs. For example,
    we can customize the endpoint's path namespace as well as the host if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Serializers format the data that is sent and received from the server. Ember
    Data expects data to be in a certain format. We can change many things in this
    data including the primary key and the keys in the JSON payload. This is accomplished
    by adding new properties to the serializer.
  prefs: []
  type: TYPE_NORMAL
- en: Working with relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with a data store, you'll need to be able to handle relationships.
    In this recipe, we'll go over some common relationships from one-to-many and many-to-one
    and also how to use it with Ember Data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the other recipes, we'll be using Ember CLI Mirage to mock our backend.
    In this recipe, we'll create a simple one-to-many and many-to-one relationship.
    We'll mock a school that has instructors and classes. For every class, there is
    one instructor. Every instructor will have one or more classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Ember application. In this application, generate the following
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create the models, route, adapter, and helper that we'll need for
    this application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `mirage` `fixtures` folder, update these two files, `classes.js` and
    `instructors.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `classes.js` file has a list of classes and subjects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `instructors.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, each young instructor has a list of classes that they teach.
    Each class has one, and only one, instructor for that class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `config.js` file for Mirage. Add the new routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each one of these endpoints will return the `instructor` and `class` data.
    This is done via **sideloading**. Here is an example of a JSON response sideloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see from the preceding example, both the `instructor` and `class`
    data was returned. This is the default that `RESTAdapter` expects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the other hand, we could return the data using asynchronous relationships.
    When this occurs, the server data store returns records only for one model. Ember
    then does one or more HTTP requests to retrieve data for the other model. For
    the simplicity of this example, we'll assume that the data is sideloaded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, create a new scenario that loads the fixture data for us to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will load both fixtures so that they can be returned to the Ember client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `application.js` file in the `adapter` folder. Set it to `RESTAdapter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RESTAdapter` will be used for this recipe.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `class.js` and `instructor.js` files in the `models` folder. Add the
    new properties for the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we need to make sure that the class has one `instructor`. This
    can be accomplished using the `DS.belongsTo` method. This tells Ember to look
    at the `instructor` model for this property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The instructor has a one-to-many relationship with the class model. One instructor
    can have one or more classes that he teaches. We can accomplish this using the
    `DS.hasMany()` method and providing the name of the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `index.js` file in the `routes` folder. Specify it to return all
    the `instructor` data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This route uses the Ember Data `findAll` method to return all the `instructor`
    data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `helper` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Helpers in Ember are used to manipulate template data. You can pass information
    to one and return information. In this example, we are doing some simple mathematics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `index.hbs` file with the model data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this template, we are using the `each` helper to display the instructor's
    name. To access the class information, another `each` helper iterates over `instructor.classes`.
    In each iteration, we display the `subject` and `index` class. As the index starts
    at zero, we can pass it to the `addone` helper. This helper increments the number
    passed to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` and you should see all the data displayed from the fixture
    data:![How to do it...](img/00042.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each instructor is listed with each class
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember uses the `DS.hasMany` and `DS.belongsTo` methods to signify a one-to-many
    and a one-to-one relationship. Ember, by convention, assumes that you are using
    the JSON API adapter. At the time of writing this, the JSON API is the default
    adapter for Ember Data. It communicates with a server via well-defined JSON via
    XHR. Its goal is to be easy to work with on the client and server side while working
    with a broad set of use cases, including relationships. For the most part, the
    REST adapter works fine. So, I've included it in the book instead of the JSON
    API adapter. Be aware that you can use either to accomplish your goals.
  prefs: []
  type: TYPE_NORMAL
- en: This can be changed using `RESTAdapter` instead. `RESTAdapter` assumes that
    all keys are camel-cased and that any data sent is sideloaded. This is done to
    help developers easily integrate their backend APIs and data stores with Ember.
  prefs: []
  type: TYPE_NORMAL
