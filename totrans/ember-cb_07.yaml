- en: Chapter 7. Ember Models and Ember Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. Ember 模型和 Ember Data
- en: 'In this chapter, you''ll learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下食谱：
- en: Understanding the functionalities of Ember Data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Ember Data 的功能
- en: Creating, reading, updating, and deleting records with Ember Data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ember Data 创建、读取、更新和删除记录
- en: Using fixtures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定数据
- en: Customizing the adapter and serializer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义适配器和序列化器
- en: Working with relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理关系
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Models are objects in Ember that represent data that can be displayed to users.
    They are persistent and won't be lost when the user closes the browser window.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是 Ember 中的对象，代表可以显示给用户的数据。它们是持久的，当用户关闭浏览器窗口时不会丢失。
- en: Many models are loaded from data that is stored in a server from a database.
    Typically, the data is sent back and forth as a JSON representation. This is where
    Ember Data comes in. Ember Data is included by default when you create an application
    in Ember. It helps retrieve data, store data locally, and save information to
    the server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模型是从存储在服务器数据库中的数据加载的。通常，数据以 JSON 表示的形式来回发送。这就是 Ember Data 发挥作用的地方。当您在 Ember
    中创建应用程序时，Ember Data 默认包含。它有助于检索数据、在本地存储数据并将信息保存到服务器。
- en: Ember Data can be configured to work with many different types of databases
    and servers. If used properly, Ember Data can help manage your application models
    without the use of multiple Ajax requests throughout your application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data 可以配置为与许多不同类型的数据库和服务器一起工作。如果使用得当，Ember Data 可以帮助您管理应用程序模型，而无需在应用程序中多次使用
    Ajax 请求。
- en: Understanding the functionalities of Ember Data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Ember Data 的功能
- en: Ember Data uses a single data store that can be accessed throughout an application.
    In this example, we'll create a simple application that retrieves a list of books
    and displays it to the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data 使用一个单一的数据存储，可以在整个应用程序中访问。在这个例子中，我们将创建一个简单的应用程序，检索书籍列表并将其显示给用户。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we begin, we'll need to mock data for our server. Ember CLI has a built-in
    mock server that can handle this situation by generating a basic **Express server**.
    However, for the purposes of this recipe, we'll go ahead and use the Ember CLI
    Mirage add-on. It has more features and is easier to use. You can find more information
    about Ember CLI Mirage at [https://github.com/samselikoff/ember-cli-mirage](https://github.com/samselikoff/ember-cli-mirage).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要为我们的服务器生成模拟数据。Ember CLI 内置了一个模拟服务器，可以通过生成基本的 **Express 服务器** 来处理这种情况。然而，为了本食谱的目的，我们将继续使用
    Ember CLI Mirage 插件。它具有更多功能且易于使用。您可以在 [https://github.com/samselikoff/ember-cli-mirage](https://github.com/samselikoff/ember-cli-mirage)
    找到更多关于 Ember CLI Mirage 的信息。
- en: 'To begin, let''s create a new application:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的应用程序：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the application has been created, let''s install the add-on:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序创建完成后，让我们安装插件：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will install the latest Bower and `npm` packages needed and create the
    `book` factory for Mirage.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装所需的最新 Bower 和 `npm` 软件包，并为 Mirage 创建 `book` 工厂。
- en: To make this recipe work, we'll need to mock book data.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使这个食谱工作，我们需要模拟书籍数据。
- en: 'Edit the `config.js` file in the `app/mirage` folder:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `app/mirage` 文件夹中的 `config.js` 文件：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This configuration file will set the fake routes that we need for our data.
    The `/books` route will return all the book data and the `/books/:id` route will
    return individual books based on the ID passed in the URL.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此配置文件将设置我们所需的数据的虚拟路由。`/books` 路由将返回所有书籍数据，而 `/books/:id` 路由将根据 URL 中传递的 ID 返回单个书籍。
- en: 'Update the `book.js` file in the `app/mirage/factories` folder. Add the following
    properties:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app/mirage/factories` 文件夹中的 `book.js` 文件。添加以下属性：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file sets the properties that we'll use later for our model. The `title`
    property refers to the name of the book, `author` refers to the person who wrote
    the book, and `year` is the year it was published. To make things a little easier,
    Ember CLI Mirage includes a library called `faker`. This library generates data
    that we can use to populate our in-memory data store.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件设置了我们将用于模型的属性。`title` 属性指的是书籍的名称，`author` 指的是写这本书的人，而 `year` 是出版年份。为了使事情更简单一些，Ember
    CLI Mirage 包含了一个名为 `faker` 的库。这个库生成我们可以用来填充我们的内存数据存储的数据。
- en: 'Update the `default.js` file in the `app/mirage/scenarios` folder:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app/mirage/scenarios` 文件夹中的 `default.js` 文件：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure to delete the comments around `server`. This scenario will generate
    ten new `'book'` records every time the browser is loaded. After the browser is
    loaded, the books will be generated via the factory.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保删除 `server` 附近的注释。此场景将在浏览器加载时每次生成十个新的 `'book'` 记录。浏览器加载后，书籍将通过工厂生成。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Begin by creating a model file for our books, a REST adapter, and a route:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个用于书籍的模型文件、REST 适配器和路由：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will generate a new model called `book`, and set the `title`, `author`,
    and `year` as properties in this model. The generate `adapter` command will create
    a new adapter for our application, while the last commands will generate routes
    for the `book` and `application`.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将生成一个名为 `book` 的新模型，并将 `title`、`author` 和 `year` 作为模型中的属性。`generate adapter`
    命令将为我们的应用程序创建一个新的适配器，而最后的命令将为 `book` 和 `application` 生成路由。
- en: 'Open the `book.js` file in the `app/models` folder. It should look as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/models` 文件夹中打开 `book.js` 文件。它应该看起来如下：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `models` file is a representation of the data that we''ll be using. We
    can use three different types of data: `string`, `number`, or `date`. This data
    will be loaded from our mock server.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`models` 文件是我们将要使用的数据的表示。我们可以使用三种不同类型的数据：`string`、`number` 或 `date`。这些数据将从我们的模拟服务器加载。'
- en: 'Open the `application.js` file created in the `app/adapters` folder:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/adapters` 文件夹中打开创建的 `application.js` 文件：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ember Data has several adapters available for it. One of the easiest to use
    is the REST adapter.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember Data 有几个适配器可供使用。其中最容易使用的是 REST 适配器。
- en: 'The REST adapter data expects the data from the server in this format:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST 适配器期望服务器以这种格式提供数据：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding JSON lists an array of books. If, by chance, only one record was
    returned, the REST adapter would expect the array to be named `book` and not `books`.
    Keep in mind that you should camel-case all record names and the data should be
    in the REST adapter format.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的 JSON 列出了一个书籍数组。如果意外地只返回了一个记录，REST 适配器会期望数组被命名为 `book` 而不是 `books`。请记住，你应该将所有记录名称使用驼峰命名法，并且数据应该以
    REST 适配器格式呈现。
- en: 'We''ll need to be able to retrieve data from our data store and present it
    to the user. Edit the `application.js` file in the `app/routes` folder. Add a
    new model that returns all the books listed:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要能够从我们的数据存储中检索数据并将其展示给用户。编辑 `app/routes` 文件夹中的 `application.js` 文件。添加一个新的模型，它返回所有列出的书籍：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As discussed in [Chapter 4](part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 4. Ember Router"), *Ember Router*, one of the responsibilities of the
    route is returning the model data. The Ember Data store has a method called `findAll`
    that will return all the data from the `book` model. By convention, the Ember
    application will execute an HTTP GET to the `/book/ URL` and expect a JSON payload
    in response. As this model is in the application route, it can be accessed in
    any template.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如 [第 4 章](part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb "第
    4 章。Ember Router") 中所述，*Ember Router*，路由的一个职责是返回模型数据。Ember Data 存储有一个名为 `findAll`
    的方法，它将返回 `book` 模型的所有数据。按照惯例，Ember 应用程序将执行一个 HTTP GET 请求到 `/book/` URL，并期望响应中包含
    JSON 负载。由于此模型位于应用程序路由中，它可以在任何模板中访问。
- en: 'Update the `application.hbs` file and display the new data from the mock server:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `application.hbs` 文件并显示来自模拟服务器的新的数据：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This template uses the `each` helper to iterate though all the data that is
    returned from the `model` hook after the page loads. The `link-to` helper will
    pass `book.id` in the URL as an argument. We'll use the book `title` as the link.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模板使用 `each` 辅助函数遍历页面加载后从 `model` 钩子返回的所有数据。`link-to` 辅助函数将 `book.id` 作为参数传递到
    URL 中。我们将使用书籍的 `title` 作为链接。
- en: 'Update the books route so that it returns a single record:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新书籍路由，使其返回单个记录：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `model` hook receives a parameter from the URL. The `findRecord` Ember Data
    can be used to find individual records. It will make an HTTP GET request to the
    `/books/:id` URL when the `model` hook is loaded. The first argument is the data
    store and the second is the record ID.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model` 钩子从 URL 接收一个参数。可以使用 Ember Data 的 `findRecord` 来查找单个记录。当 `model` 钩子被加载时，它将向
    `/books/:id` URL 发送一个 HTTP GET 请求。第一个参数是数据存储，第二个参数是记录 ID。'
- en: 'Update the `router.js` file in the `app` folder with the new dynamic route
    for `books`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹中的 `router.js` 文件中更新新的动态路由 `books`：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This new route for `books` has a path of `/books/:book_id`. To access the `books`
    route, you have to submit an ID in the path.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新的 `books` 路由的路径为 `/books/:book_id`。要访问 `books` 路由，必须在路径中提交一个 ID。
- en: 'Update the `books.hbs` template:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `books.hbs` 模板：
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Accessing this route will trigger the `model` hook. This will render `author`
    and `year` of the book selected.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问此路由将触发 `model` 钩子。这将渲染所选书籍的 `author` 和 `year`。
- en: Run `ember server` and open a web browser. You'll see a list of all the titles
    with links to each individual book:![How to do it...](img/00038.jpeg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server` 并打开一个网页浏览器。您将看到所有标题的列表，每个标题都有一个链接指向每本书：![如何操作...](img/00038.jpeg)
- en: Each post has a unique ID. Clicking on a link will display the title and author
    of that book.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每篇文章都有一个唯一的 ID。点击链接将显示该书的标题和作者。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Models represent data in Ember. These models can use Ember Data to store, update,
    and retrieve data from a server. The data from the server is usually sent in the
    JSON format. Ember offers a handful of adapters to the interface with the data
    coming from the server. The REST adapter is the most commonly used. It expects
    data in a certain format so that Ember can parse, store, and display it to the
    user.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模型代表 Ember 中的数据。这些模型可以使用 Ember Data 将数据存储、更新和从服务器检索数据。从服务器发送的数据通常是 JSON 格式。Ember
    为与来自服务器的数据接口提供了一组适配器。REST 适配器是最常用的。它期望数据以特定格式，以便 Ember 可以解析、存储并向用户显示。
- en: Ember Data caches the data after it retrieves the data from the server. This
    minimizes the amount of round-trips to the server. However, Ember Data will make
    a request in the background whenever a cached data record is returned from the
    store. If the data has changed, it will be rerendered on the screen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data 在从服务器检索数据后缓存数据。这最小化了往返服务器的次数。然而，当从存储返回缓存的记录时，Ember Data 将在后台发出请求。如果数据已更改，它将在屏幕上重新渲染。
- en: Creating, reading, updating, and deleting records with Ember Data
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ember Data 创建、读取、更新和删除记录
- en: In the previous recipe, we retrieved already existing book data from our mock
    server and displayed it to the user. Ember Data also has the ability to create,
    delete, and even update records from the data store. We will be looking at these
    methods and more.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们从我们的模拟服务器检索了现有的书籍数据并将其显示给用户。Ember Data 还具有从数据存储创建、删除甚至更新记录的能力。我们将探讨这些方法以及更多。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Just like the previous example, we'll need to install Ember CLI Mirage. Take
    a look at the previous recipe for instructions on this process. We'll be using
    the same factories as the book recipe and we'll be adding new methods to add,
    edit, and delete data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的例子一样，我们需要安装 Ember CLI Mirage。请参阅前面的配方以获取有关此过程的说明。我们将使用与书籍配方相同的工厂，并添加新的方法来添加、编辑和删除数据。
- en: 'In the `mirage` folder, open the `config.js` file:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mirage` 文件夹中，打开 `config.js` 文件：
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will mock our backend and allow us to create, update, and delete data.
    This is done using the HTTP PUT, POST, and DELETE requests. We'll use this later
    in our program.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将模拟我们的后端，并允许我们创建、更新和删除数据。这是通过使用 HTTP PUT、POST 和 DELETE 请求来完成的。我们将在程序中稍后使用这些。
- en: 'Update the `book.js` file in the `app/mirage` folder:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app/mirage` 文件夹中的 `book.js` 文件：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This factory will be used to generate fake data that the Mirage in-memory database
    will return.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个工厂将用于生成 Mirage 内部数据库将返回的假数据。
- en: 'Update the `default.js` file in the `scenarios` folder:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `scenarios` 文件夹中的 `default.js` 文件：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Every time that the application loads, the server will create `10` `book` objects.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次应用程序加载时，服务器将创建 `10` 个 `book` 对象。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this recipe, we'll be adding to the book example that we had in the *Understanding
    the functionalities of Ember* *Data* recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将向我们在 *Understanding the functionalities of Ember* *Data* 配方中已有的书籍示例中添加内容。
- en: 'Create a route called `new` and controller named `books`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `new` 的路由和一个名为 `books` 的控制器：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will generate the `new` route and `books` controller files.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成 `new` 路由和 `books` 控制器文件。
- en: 'Create a new template for the new route:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新路由创建一个新的模板：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The new route will be used to add a new book to the repository. In this template,
    the `input` helper is used to create three textboxes. Each will be bound to the
    info property. A button at the bottom will submit the changes to the `newText`
    `action` method. The `cancel` button will trigger the `cancel` action.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新路由将用于向存储库添加新书。在这个模板中，使用 `input` 辅助函数创建三个文本框。每个都将绑定到信息属性。底部的一个按钮将提交更改到 `newText`
    `action` 方法。`cancel` 按钮将触发 `cancel` 动作。
- en: 'Update the `new.js` controller with the new `actions` for `cancel` and `newText`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `new.js` 控制器，添加新的 `cancel` 和 `newText` `actions`：
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is a lot going on here; let''s take a look at the `newText` action first:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中；让我们首先看看 `newText` 动作：
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this action, we are getting the `info` property that was declared earlier.
    This property is an object that is used to store values from the template. The
    store has a method called `createRecord` that takes two arguments. The first argument
    is the model. The second is the object that we want to store. In this case, we
    want to add a new `book` record to the store. We use the `inf` object to set the
    `title`, `author`, and `year`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个操作中，我们获取之前声明的`info`属性。这个属性是一个对象，用于存储从模板中获取的值。存储库有一个名为`createRecord`的方法，它接受两个参数。第一个参数是模型。第二个是我们想要存储的对象。在这种情况下，我们想要向存储库添加一个新的`book`记录。我们使用`inf`对象设置`title`、`author`和`year`。
- en: 'Using the `createRecord` method doesn''t persist the changes. The `save()`
    method is used to persist data back to the server:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createRecord`方法不会持久化更改。`save()`方法用于将数据持久化回服务器：
- en: '[PRE21]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `save` method is a promise. It will either succeed or fail. If it succeeds,
    we use the `transitionToRoute` method to change the route back to the main application.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`save`方法是一个承诺。它要么成功，要么失败。如果成功，我们使用`transitionToRoute`方法将路由切换回主应用程序。'
- en: 'Afterwards, we set the `info` property back to an empty object. We do this
    so that the template `input` helper is cleared of all data. If it doesn''t succeed,
    then we output an error to the console:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，我们将`info`属性设置回空对象。我们这样做是为了清除模板`input`助手的所有数据。如果它不成功，那么我们将输出错误到控制台：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `cancel` action returns `true`. What this means is that instead of the
    controller handling it, it will be bubbled up to be handled by the route:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cancel`操作返回`true`。这意味着不是控制器处理它，而是将其冒泡到路由进行处理：'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**REST with Ember**'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**使用 Ember 的 REST**'
- en: When using the REST adapter in Ember, the `save()` method will send a PUT, DELETE,
    GET, or POST HTTP request to the server. The PUT request will be sent during an
    update. The DELETE request is used to delete a record. POST is used to add a new
    record, and the GET request is used to retrieve records. This is done by convention
    by the Ember REST adapter.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用 Ember 中的 REST 适配器时，`save()`方法将向服务器发送 PUT、DELETE、GET 或 POST HTTP 请求。PUT 请求将在更新期间发送。DELETE
    请求用于删除记录。POST 用于添加新记录，而 GET 请求用于检索记录。这是由 Ember REST 适配器按照惯例完成的。
- en: 'Update the `books.hbs` template file with a new action to update:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`books.hbs`模板文件，添加一个新操作以更新：
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ve updated the books template to behave differently from our last example.
    In this example, it will allow us to edit the entries as follows:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已更新书籍模板，使其与上一个示例的行为不同。在这个示例中，它将允许我们按以下方式编辑条目：
- en: '![How to do it...](img/00039.jpeg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/00039.jpeg)'
- en: 'Update the `books.js` controller to handle the new `updateText` and `cancel`
    actions:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`books.js`控制器以处理新的`updateText`和`cancel`操作：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `updateText` action gets the current book `model`, sets the `year`, and
    then saves it. Afterwards, it transitions to the `application` route. If needed,
    we could handle the error condition if the save promise fails. For the sake of
    simplicity, we'll leave it as is. The `cancel` action returns `true`, which means
    that it will bubble up to the books route to be handled.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`updateText`操作获取当前书籍`model`，设置`year`，然后保存。之后，它过渡到`application`路由。如果需要，我们可以处理保存承诺失败时的错误条件。为了简单起见，我们将保持原样。`cancel`操作返回`true`，这意味着它将冒泡到书籍路由进行处理。'
- en: 'Update the `books.js` file in the route:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新路由中的`books.js`文件：
- en: '[PRE25]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The route file is the same as the previous recipe, except now we have a `cancel`
    action. This `cancel` action will be triggered after the controller returns `true`.
    By returning `true` here, the action bubbles up one more time to the application
    route.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由文件与上一个配方相同，但现在我们有一个`cancel`操作。这个`cancel`操作将在控制器返回`true`后触发。通过在这里返回`true`，操作再次冒泡到应用程序路由。
- en: 'Update the `new.js` route file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`new.js`路由文件：
- en: '[PRE26]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This file will receive the action from the new controller. It also returns `true`,
    which means that the `cancel` action will be handled by the application route
    as well.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件将接收来自新控制器的操作。它也返回`true`，这意味着`cancel`操作将由应用程序路由处理。
- en: 'Update the application route file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序路由文件：
- en: '[PRE27]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `cancel` action in the application route handles the new and book routes
    `cancel` action. In either case, it will transition to the `application` route.
    In summary, the bubbling of the action went from the new controller to the new
    route and finally to the application route. If the `cancel` action was not included
    in the controller, by convention, the action will automatically bubble up.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序路由中的`cancel`操作处理新的和书籍路由的`cancel`操作。在任何情况下，它都会过渡到`application`路由。总之，操作的冒泡从新的控制器到新的路由，最后到应用程序路由。如果`cancel`操作未包含在控制器中，根据惯例，操作将自动向上冒泡。
- en: 'We need to update the application template and add a new option to delete records.
    Update the `application.hbs` file with the new `delete` action:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更新应用程序模板并添加一个新选项来删除记录。使用新的`delete`操作更新`application.hbs`文件：
- en: '[PRE28]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The application will display each book. There is also a `delete` action button
    at the bottom of each record that passes in the `book` record.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序将显示每本书。每条记录底部还有一个`delete`操作按钮，该按钮传递`book`记录。
- en: 'Update the application controller to handle the new `delete` action:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序控制器以处理新的`delete`操作：
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The book record has a method called `deleteRecord`. This deletes the record;
    however, it doesn't send the HTTP delete request to the server until `save()`
    is done. Another method called `destroyRecord` will `delete` and `save` at the
    same time. For this example, we'll use `deleteRecord` instead.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 书籍记录有一个名为`deleteRecord`的方法。这个方法会删除记录；然而，它不会在`save()`完成之前向服务器发送HTTP删除请求。另一个名为`destroyRecord`的方法会同时`delete`和`save`。在这个例子中，我们将使用`deleteRecord`。
- en: Load the Ember server and you'll see a list of records. You can click on each
    record and delete or edit it:![How to do it...](img/00040.jpeg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载Ember服务器，你会看到一个记录列表。你可以点击每条记录并删除或编辑它：![如何操作...](img/00040.jpeg)
- en: Tip
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Not using Ember Data?**'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**不使用Ember Data？**'
- en: Ember Data is the preferred method when working with a backend data store. However,
    it doesn't have to be the only option. When defining model information in a route,
    you can use Ajax methods or define your own repositories as well. You can use
    services and inject them throughout your application if needed. This will take
    a substantial amount of extra work, depending on your setup, but it is an option.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当与后端数据存储一起工作时，Ember Data是首选方法。然而，它不必是唯一的选择。在路由中定义模型信息时，你可以使用Ajax方法或定义自己的存储库。如果需要，你可以使用服务并将它们注入到你的应用程序的各个部分。这需要额外的大量工作，具体取决于你的设置，但这是一个选择。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember Data comes with several adapters that can be used to retrieve data from
    a backend server. The REST adapter allows the user to make requests to a backend
    server using HTTP GET, DETETE, PUT, and POST requests. By default, it expects
    responses in JSON.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data附带了一些适配器，可以用来从后端服务器检索数据。REST适配器允许用户使用HTTP GET、DELETE、PUT和POST请求向后端服务器发送请求。默认情况下，它期望以JSON格式接收响应。
- en: The Ember Data store methods allow a user to find, delete, and save records.
    The Ember `save()` method triggers a response to the server. Before the save is
    done, records can be rolled back if needed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data存储方法允许用户查找、删除和保存记录。Ember的`save()`方法触发对服务器的响应。在保存完成之前，如果需要，可以回滚记录。
- en: Using fixtures
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用固定数据
- en: Fixtures are another way of mocking data. It's static data that can be used
    in our model to display to the user when testing our application. In this recipe,
    we'll see some basics on how to set it up with Ember CLI Mirage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 固定数据是模拟数据的一种方式。它是静态数据，可以在测试我们的应用程序时用于我们的模型以显示给用户。在这个菜谱中，我们将看到如何使用Ember CLI Mirage设置它的一些基本知识。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with many of our other examples, we'll be using Ember CLI Mirage. Instead
    of using a factory, we'll set up fixture data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们其他许多示例一样，我们将使用Ember CLI Mirage。我们将设置固定数据而不是使用工厂。
- en: 'Begin by creating a new application. Then add the Ember CLI Mirage add-on and
    generate the model and routes for the application:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建一个新的应用程序。然后添加Ember CLI Mirage插件并生成应用程序的模型和路由：
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These commands will generate the basic structure of our app. In this application,
    fixture data will be used to display student information. For the sake of simplicity,
    we'll only be displaying this information and not manipulating it.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些命令将生成我们应用程序的基本结构。在这个应用程序中，固定数据将用于显示学生信息。为了简单起见，我们只会显示这些信息而不会对其进行操作。
- en: 'In the `mirage` `fixtures` folder, update the `students.js` file and add the
    fixture data:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mirage`的`fixtures`文件夹中，更新`students.js`文件并添加固定数据：
- en: '[PRE31]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The fixture data has four records. Each record has a different student's `name`
    and `age`. To use fixture data with Ember CLI Mirage, you must enter it as an
    array of objects.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 固定数据有四个记录。每个记录都有一个不同的学生的 `name` 和 `age`。要使用 Ember CLI Mirage 与固定数据一起使用，你必须将其作为对象的数组输入。
- en: 'Update the `config.js` file in the `mirage` folder. This file is used to set
    the `students` route:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `mirage` 文件夹中的 `config.js` 文件。此文件用于设置 `students` 路由：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will set up a mock server endpoint for Ember Data to reach. By convention,
    Ember Data will look for the URL path of the pluralized model name. In this example,
    our model will be student; therefore, when Ember Data looks for data, it will
    do a GET request to `/students` on the server.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为 Ember Data 设置一个模拟服务器端点。按照惯例，Ember Data 将查找复数模型名称的 URL 路径。在这个例子中，我们的模型将是学生；因此，当
    Ember Data 查找数据时，它将对服务器的 `/students` 执行 GET 请求。
- en: 'Add a new scenario to the `default.js` file for the fixture data:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `default.js` 文件中添加一个新的场景用于固定数据：
- en: '[PRE33]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `loadFixtures()` command will load the fixtures in memory so that they are
    available to the `students` route.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`loadFixtures()` 命令将在内存中加载固定数据，以便它们可用于 `students` 路由。'
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Earlier, we created the model file. Let''s take a look at it first to make
    sure that everything is set up correctly:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前，我们创建了模型文件。让我们先看看它，以确保一切设置正确：
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `student` model has two properties called `name` and `age`.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`student` 模型有两个属性，称为 `name` 和 `age`。'
- en: 'Update the route `index.js` file to return the students model:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `index.js` 路由文件以返回学生模型：
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The route file will return all `student` records using the `findAll` method.
    This will trigger an HTTP GET request to the server at `/students`. The `model`
    hook is triggered when you visit the route. By convention, Ember will then cache
    these results.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路由文件将使用 `findAll` 方法返回所有 `student` 记录。这将触发对服务器 `/students` 的 HTTP GET 请求。当你访问路由时，将触发
    `model` 钩子。按照惯例，Ember 将缓存这些结果。
- en: 'Open the application adapter. Set it to the REST adapter:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用程序适配器。将其设置为 REST 适配器：
- en: '[PRE36]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`RESTAdapter` will be used for all routes. It''s a type of adapter that assumes
    that JSON data will be sent via XHR.'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RESTAdapter` 将用于所有路由。它是一种假设通过 XHR 发送 JSON 数据的适配器类型。'
- en: 'Edit the `index.hbs` file. This will display the model information:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `index.hbs` 文件。这将显示模型信息：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we use the `each` helper to iterate through all the records.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `each` 辅助函数遍历所有记录。
- en: Run `ember server` and the following results should be displayed:![How to do
    it...](img/00041.jpeg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server`，以下结果应该会显示：![如何操作...](img/00041.jpeg)
- en: After the page loads, a list of the students' names and ages will be displayed.
    This data is retrieved from the fixture data that we set up earlier using our
    mock server.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面加载后，将显示学生姓名和年龄的列表。这些数据是从我们之前设置的模拟服务器中检索的固定数据。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Fixtures are used when testing an application. It is well-known data and can
    be used for repeated tests. Ember CLI Mirage can be set up to use fixture data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 固定数据在测试应用程序时使用。这是已知数据，可用于重复测试。Ember CLI Mirage 可以设置为使用固定数据。
- en: We'll be going over using fixture data with testing in the testing chapter in
    more detail.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试章节中更详细地介绍使用固定数据与测试。
- en: Customizing the adapter and serializer
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义适配器和序列化器
- en: Ember Data is very opinionated on how it wants to access data. The adapter has
    built-in assumptions on what the data looks like. We can use serializers and adapters
    to change these assumptions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Data 对如何访问数据有很强的意见。适配器对数据的外观有内置的假设。我们可以使用序列化和适配器来改变这些假设。
- en: For this recipe, we'll be building on the student application that we created
    in the previous section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将基于上一节中创建的学生应用程序进行构建。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using the same application from the previous recipe. We'll need to
    edit Ember CLI Mirage to handle a new namespace.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前菜谱中的相同应用程序。我们需要编辑 Ember CLI Mirage 以处理新的命名空间。
- en: 'In the `config.js` file in the `mirage` folder, update the `students` route:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mirage` 文件夹中的 `config.js` 文件中更新 `students` 路由：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will change the endpoint to `api/v1/students` instead of just `/students`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更改端点为 `api/v1/students` 而不是仅仅 `/students`。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the students application from the previous section, edit the `application.js`
    file in the `adapters` folder.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一节中的学生应用程序中，编辑 `adapters` 文件夹中的 `application.js` 文件。
- en: 'Add a new `namespace`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 `namespace`：
- en: '[PRE39]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `namespace` property is used to prefix requests with a specific URL. In
    this case, all requests will have `api/v1` prepended to them.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`namespace` 属性用于在请求前添加特定的 URL 前缀。在这种情况下，所有请求都将添加 `api/v1` 作为前缀。'
- en: Start the Ember server and you should see requests going to `/api/v1/students`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Ember 服务器，你应该会看到请求发送到 `/api/v1/students`。
- en: Optional customizations in Ember Data
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ember Data 中的可选定制
- en: Ember offers a number of other customizations if needed. Here are a few important
    ones to keep in mind.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，Ember 提供了多种其他定制选项。以下是一些需要记住的重要选项。
- en: Host customization
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主机定制
- en: 'In the adapter file, you can add a new location where Ember Data should send
    requests. This overwrites the default location of the local server:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在适配器文件中，你可以添加 Ember Data 应该发送请求的新位置。这将覆盖本地服务器的默认位置：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As an example, now all the requests will be sent to `api.example.com`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在所有请求都将发送到 `api.example.com`。
- en: Headers customization
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Headers 定制
- en: 'Depending on the API, you may need to send specific headers in each HTTP request.
    You can add this using the `headers` property:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根据API，你可能需要在每个 HTTP 请求中发送特定的 headers。你可以使用 `headers` 属性来添加这些 headers：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will add new `headers` for every request that is sent. If needed, you can
    also use dynamic information in your headers by creating a computed property.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每个发送的请求添加新的 `headers`。如果需要，你还可以通过创建计算属性在 headers 中使用动态信息。
- en: Working with serializers
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与序列化器一起工作
- en: When using Ember Data, serializers format the data that's sent and received
    from the backend data store. We can customize this data to fit the needs of our
    backend.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Ember Data 时，序列化器格式化从后端数据存储发送和接收的数据。我们可以定制这些数据以适应后端的需求。
- en: Updating IDs
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新 IDs
- en: By default, Ember Data expects each record to have an ID. We can change the
    name of this using the primary key property.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ember Data 期望每个记录都有一个 ID。我们可以使用主键属性来更改此名称。
- en: 'Generate a new `serializer` file:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个新的 `serializer` 文件：
- en: '[PRE42]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This generates the `serializer` file that we can update.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成我们可以更新的 `serializer` 文件。
- en: 'Update the `application.js` serializer with the new ID:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的 ID 更新 `application.js` 序列化器：
- en: '[PRE43]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will transform the ID property to `_id` when serializing and deserializing
    data. In other words, when data is sent or received from the server, it will have
    a primary key that is set to `_id`.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在序列化和反序列化数据时将 ID 属性转换为 `_id`。换句话说，当数据从服务器发送或接收时，它将有一个设置为 `_id` 的主键。
- en: KeyForAttribute when working a JSON payload
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理 JSON 负载时的 KeyForAttribute
- en: 'At times, the data sent back from the server may not be in the correct format.
    For example, `RESTAdapter` expects the JSON payload attribute names in camel-case.
    We can change this using the `keyForAttribute` property:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，从服务器返回的数据可能不是正确的格式。例如，`RESTAdapter` 期望 JSON 负载属性名称为驼峰式。我们可以使用 `keyForAttribute`
    属性来更改这一点：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For example, let's say that the data sent back from the server is underscored
    instead of camel-cased. The server is returning `school_name` instead of `schoolName`.
    This can be fixed using `keyForAttribute` and `decamelize`. This will take the
    model name `schoolName` and `decamelize` it to `school_name` so that it matches
    what's returned from the server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设从服务器返回的数据是下划线而不是驼峰式。服务器返回 `school_name` 而不是 `schoolName`。这可以通过使用 `keyForAttribute`
    和 `decamelize` 来修复。这将模型名称 `schoolName` 转换为 `school_name`，以便与服务器返回的内容匹配。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Adapters are used in Ember Data to help interpret data that is sent and retrieved
    from the server. It has a set of built-in assumptions on how the data should look.
    We can make changes so that we can accommodate different types of APIs. For example,
    we can customize the endpoint's path namespace as well as the host if needed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器用于 Ember Data 以帮助解释从服务器发送和检索的数据。它对数据的外观有一套内置假设。我们可以进行更改，以便我们可以适应不同类型的 API。例如，我们可以定制端点的路径命名空间以及如果需要的主机。
- en: Serializers format the data that is sent and received from the server. Ember
    Data expects data to be in a certain format. We can change many things in this
    data including the primary key and the keys in the JSON payload. This is accomplished
    by adding new properties to the serializer.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器格式化从服务器发送和接收的数据。Ember Data 期望数据以特定的格式。我们可以更改此数据中的许多内容，包括主键和 JSON 负载数据中的键。这是通过向序列化器添加新属性来实现的。
- en: Working with relationships
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与关系一起工作
- en: When working with a data store, you'll need to be able to handle relationships.
    In this recipe, we'll go over some common relationships from one-to-many and many-to-one
    and also how to use it with Ember Data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据存储一起工作时，你需要能够处理关系。在这个菜谱中，我们将介绍一些常见的关系，从一对一和一对多，以及如何使用 Ember Data 来实现。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with the other recipes, we'll be using Ember CLI Mirage to mock our backend.
    In this recipe, we'll create a simple one-to-many and many-to-one relationship.
    We'll mock a school that has instructors and classes. For every class, there is
    one instructor. Every instructor will have one or more classes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他菜谱一样，我们将使用 Ember CLI Mirage 来模拟我们的后端。在这个菜谱中，我们将创建一个简单的一对多和一对多关系。我们将模拟一个有教练和班级的学校。对于每个班级，都有一个教练。每个教练将有一个或多个班级。
- en: 'Create a new Ember application. In this application, generate the following
    files:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Ember 应用程序。在这个应用程序中，生成以下文件：
- en: '[PRE45]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will create the models, route, adapter, and helper that we'll need for
    this application.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建我们需要的模型、路由、适配器和辅助函数。
- en: 'In the `mirage` `fixtures` folder, update these two files, `classes.js` and
    `instructors.js`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mirage` 的 `fixtures` 文件夹中，更新这两个文件，`classes.js` 和 `instructors.js`：
- en: '[PRE46]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `classes.js` file has a list of classes and subjects.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`classes.js` 文件包含班级和科目的列表。'
- en: 'Create the `instructors.js` file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `instructors.js` 文件：
- en: '[PRE47]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, each young instructor has a list of classes that they teach.
    Each class has one, and only one, instructor for that class.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，每位年轻教练都有一个他们教授的班级列表。每个班级只有一个，并且只有一个教练。
- en: 'Edit the `config.js` file for Mirage. Add the new routes:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 Mirage 的 `config.js` 文件。添加新的路由：
- en: '[PRE48]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Each one of these endpoints will return the `instructor` and `class` data.
    This is done via **sideloading**. Here is an example of a JSON response sideloaded:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个这些端点都将返回 `instructor` 和 `class` 数据。这是通过 **侧加载** 实现的。以下是一个示例 JSON 响应侧加载：
- en: '[PRE49]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see from the preceding example, both the `instructor` and `class`
    data was returned. This is the default that `RESTAdapter` expects.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前例所示，`instructor` 和 `class` 数据都被返回了。这是 `RESTAdapter` 预期的默认行为。
- en: On the other hand, we could return the data using asynchronous relationships.
    When this occurs, the server data store returns records only for one model. Ember
    then does one or more HTTP requests to retrieve data for the other model. For
    the simplicity of this example, we'll assume that the data is sideloaded.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，我们可以使用异步关系返回数据。当这种情况发生时，服务器数据存储只返回一个模型的数据。然后 Ember 执行一个或多个 HTTP 请求以检索其他模型的数据。为了简化这个例子，我们假设数据是侧加载的。
- en: 'Finally, create a new scenario that loads the fixture data for us to use:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的场景，用于加载我们使用的固定数据：
- en: '[PRE50]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will load both fixtures so that they can be returned to the Ember client.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将加载这两个固定数据，以便它们可以被返回给 Ember 客户端。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Open the `application.js` file in the `adapter` folder. Set it to `RESTAdapter`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `adapter` 文件夹中的 `application.js` 文件。将其设置为 `RESTAdapter`：
- en: '[PRE51]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`RESTAdapter` will be used for this recipe.'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将使用 `RESTAdapter` 来实现这个菜谱。
- en: 'Edit the `class.js` and `instructor.js` files in the `models` folder. Add the
    new properties for the model:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `models` 文件夹中的 `class.js` 和 `instructor.js` 文件。为模型添加新的属性：
- en: '[PRE52]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we need to make sure that the class has one `instructor`. This
    can be accomplished using the `DS.belongsTo` method. This tells Ember to look
    at the `instructor` model for this property.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要确保班级有一个 `instructor`。这可以通过使用 `DS.belongsTo` 方法来实现。这告诉 Ember 查看该属性的
    `instructor` 模型。
- en: 'The instructor has a one-to-many relationship with the class model. One instructor
    can have one or more classes that he teaches. We can accomplish this using the
    `DS.hasMany()` method and providing the name of the model:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 教练与班级模型之间存在一对一的关系。一位教练可以教授一个或多个班级。我们可以使用 `DS.hasMany()` 方法并指定模型名称来实现这一点：
- en: '[PRE53]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Update the `index.js` file in the `routes` folder. Specify it to return all
    the `instructor` data:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `routes` 文件夹中的 `index.js` 文件。指定它返回所有 `instructor` 数据：
- en: '[PRE54]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This route uses the Ember Data `findAll` method to return all the `instructor`
    data.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此路由使用 Ember Data 的 `findAll` 方法返回所有 `instructor` 数据。
- en: 'Update the `helper` file:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `helper` 文件：
- en: '[PRE55]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Helpers in Ember are used to manipulate template data. You can pass information
    to one and return information. In this example, we are doing some simple mathematics.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember 中的辅助函数用于操作模板数据。你可以传递信息给一个，并返回信息。在这个例子中，我们进行了一些简单的数学运算。
- en: 'Edit the `index.hbs` file with the model data:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模型数据编辑 `index.hbs` 文件：
- en: '[PRE56]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this template, we are using the `each` helper to display the instructor's
    name. To access the class information, another `each` helper iterates over `instructor.classes`.
    In each iteration, we display the `subject` and `index` class. As the index starts
    at zero, we can pass it to the `addone` helper. This helper increments the number
    passed to it.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个模板中，我们使用 `each` 辅助函数来显示讲师的姓名。为了访问课程信息，另一个 `each` 辅助函数遍历 `instructor.classes`。在每次迭代中，我们显示
    `subject` 和 `index` 课程。由于索引从零开始，我们可以将其传递给 `addone` 辅助函数。这个辅助函数增加传递给它的数字。
- en: Run `ember server` and you should see all the data displayed from the fixture
    data:![How to do it...](img/00042.jpeg)
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server` 并应看到从固定数据中显示的所有数据：![如何操作...](img/00042.jpeg)
- en: Each instructor is listed with each class
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每位讲师都列出了每个课程
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember uses the `DS.hasMany` and `DS.belongsTo` methods to signify a one-to-many
    and a one-to-one relationship. Ember, by convention, assumes that you are using
    the JSON API adapter. At the time of writing this, the JSON API is the default
    adapter for Ember Data. It communicates with a server via well-defined JSON via
    XHR. Its goal is to be easy to work with on the client and server side while working
    with a broad set of use cases, including relationships. For the most part, the
    REST adapter works fine. So, I've included it in the book instead of the JSON
    API adapter. Be aware that you can use either to accomplish your goals.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 使用 `DS.hasMany` 和 `DS.belongsTo` 方法来表示一对多和一对一的关系。按照惯例，Ember 假设你正在使用 JSON
    API 适配器。在撰写本文时，JSON API 是 Ember Data 的默认适配器。它通过 XHR 通过定义良好的 JSON 与服务器通信。它的目标是便于在客户端和服务器端处理，同时支持广泛的用例，包括关系。在大多数情况下，REST
    适配器表现良好。因此，我在书中包括了它而不是 JSON API 适配器。请注意，你可以使用任一适配器来实现你的目标。
- en: This can be changed using `RESTAdapter` instead. `RESTAdapter` assumes that
    all keys are camel-cased and that any data sent is sideloaded. This is done to
    help developers easily integrate their backend APIs and data stores with Ember.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `RESTAdapter` 来更改。`RESTAdapter` 假设所有键都是驼峰式命名，并且发送的数据都是侧加载的。这样做是为了帮助开发者轻松地将他们的后端
    API 和数据存储与 Ember 集成。
