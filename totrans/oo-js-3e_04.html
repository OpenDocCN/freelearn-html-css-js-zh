<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Objects</h1></div></div></div><p>Now that you've mastered JavaScript's primitive data types, arrays, and functions, it's time to stay true to the promise of the book title and talk about objects.</p><p>JavaScript has an eccentric take on the classical Object-oriented programming. Object-oriented programming is one of the most popular programming paradigms and has been a mainstay in most of programming languages like Java and C++. There are well defined ideas proposed by classical OOP that most of these languages adopt. JavaScript, however, has a different take on it. We will look JavaScript's way of supporting OOP.</p><p>In this chapter, you will learn the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create and use objects</li><li class="listitem" style="list-style-type: disc">What are the constructor functions</li><li class="listitem" style="list-style-type: disc">What types of built-in JavaScript objects exist and what they can do for you</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>From arrays to objects</h1></div></div></div><p>As you already know from <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <em>Primitive Data Types, Arrays, Loops, and Conditions</em>, an array is just a list of values. Each value has an index (a numeric key) that starts from zero and increments by one for each value. Consider the following example:</p><pre class="programlisting">    &gt; var myarr = ['red', 'blue', 'yellow', 'purple']; &#13;
    &gt; myarr; &#13;
    ["red", "blue", "yellow", "purple"]. &#13;
    &gt; myarr[0]; &#13;
    "red" &#13;
    &gt; myarr[3]; &#13;
    "purple" &#13;
</pre><p>If you put the indexes in one column and the values in another, you'll end up with a table of key/value pairs shown as follows:</p><div><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>Key</strong>
</p>
</td><td>
<p>
<strong>Value</strong>
</p>
</td></tr><tr><td>
<p>0</p>
</td><td>
<p>red</p>
</td></tr><tr><td>
<p>1</p>
</td><td>
<p>blue</p>
</td></tr><tr><td>
<p>2</p>
</td><td>
<p>yellow</p>
</td></tr><tr><td>
<p>3</p>
</td><td>
<p>purple</p>
</td></tr></tbody></table></div><p>An object is similar to an array, but the difference is that you define the keys yourself. You're not limited to using only numeric indexes, and you can use friendlier keys such as <code class="literal">first_name</code>, <code class="literal">age</code>, and so on.</p><p>Let's take a look at a simple object and examine its parts:</p><pre class="programlisting">    var hero = { &#13;
      breed: 'Turtle',  &#13;
      occupation: 'Ninja' &#13;
    }; &#13;
</pre><p>You can see that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name of the variable that refers to the object is <code class="literal">hero</code></li><li class="listitem" style="list-style-type: disc">Instead of <code class="literal">[</code> and <code class="literal">]</code>, which you use to define an array, you use <code class="literal">{</code> and <code class="literal">}</code> for objects</li><li class="listitem" style="list-style-type: disc">You separate the elements (called properties) contained in the object with commas</li><li class="listitem" style="list-style-type: disc">The key/value pairs are divided by colons, as in <code class="literal">key:value</code></li></ul></div><p>The keys (names of the properties) can optionally be placed in quotation marks. For example, these keys are all the same:</p><pre class="programlisting">    var hero = {occupation: 1}; &#13;
    var hero = {"occupation": 1}; &#13;
    var hero = {'occupation': 1}; &#13;
</pre><p>It's recommended that you don't quote the names of the properties (it's less typing), but there are cases when you must use quotes. Some of the cases are stated here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the property name is one of the reserved words in JavaScript (see <a class="link" href="apa.html" title="Appendix A. Reserved Words">Appendix A</a>, <em>Reserved Words</em>)</li><li class="listitem" style="list-style-type: disc">If it contains spaces or special characters (anything other than letters, numbers, and the <code class="literal">_</code> and <code class="literal">$</code> characters)</li><li class="listitem" style="list-style-type: disc">If it starts with a number</li></ul></div><p>In other words, if the name you have chosen for a property is not a valid name for a variable in JavaScript, then you need to wrap it in quotes.</p><p>Have a look at this bizarre-looking object:</p><pre class="programlisting">    var o = { &#13;
      $omething: 1, &#13;
      'yes or no': 'yes', &#13;
      '!@#$%^&amp;*': true &#13;
    }; &#13;
</pre><p>This is a valid object. The quotes are required for the second and the third properties; otherwise, you'll get an error.</p><p>Later in this chapter, you'll see other ways to define objects and arrays, in addition to <code class="literal">[]</code> and <code class="literal">{}</code>. However, first, let's introduce this bit of terminology - defining an array with <code class="literal">[]</code> is called <strong>array literal notation</strong>, and defining an object using curly braces <code class="literal">{}</code> is called <strong>object literal notation</strong>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Elements, properties, methods, and members</h2></div></div></div><p>When talking about arrays, you say that they contain elements. When talking about objects, you say that they contain properties. There isn't any significant difference in JavaScript; it's just the terminology that people are used to, probably from other programming languages.</p><p>A property of an object can point to a function, because functions are just data. Properties that point to functions are also called methods. In the following example, <code class="literal">talk</code> is a method:</p><pre class="programlisting">    var dog = { &#13;
      name: 'Benji', &#13;
      talk: function () { &#13;
        alert('Woof, woof!'); &#13;
      } &#13;
    }; &#13;
</pre><p>As you have seen in the previous chapter, it's also possible to store functions as array elements and invoke them, but you'll not see much code like this in practice:</p><pre class="programlisting">    &gt; var a = []; &#13;
    &gt; a[0] = function (what) { alert(what); }; &#13;
    &gt; a[0]('Boo!'); &#13;
</pre><p>You can also see people using the word members to refer to the properties of an object, most often when it doesn't matter if the property is a function or not.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Hashes and associative arrays</h2></div></div></div><p>In some programming languages, there is a distinction between:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A regular array, also called an <strong>indexed</strong> or <strong>enumerated</strong> array (the keys are numbers)</li><li class="listitem" style="list-style-type: disc">An associative array, also called a <strong>hash</strong> or a <strong>dictionary</strong> (the keys are strings)</li></ul></div><p>JavaScript uses arrays to represent indexed arrays and objects to represent associative arrays. If you want a hash in JavaScript, you use an object.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Accessing an object's properties</h2></div></div></div><p>There are two ways to access the property of an object:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the square bracket notation, for example, <code class="literal">hero['occupation']</code></li><li class="listitem" style="list-style-type: disc">Using the dot notation, for example, <code class="literal">hero.occupation</code></li></ul></div><p>The dot notation is easier to read and write, but it cannot always be used. The same rules apply for quoting property names. If the name of the property is not a valid variable name, you cannot use the dot notation.</p><p>Let's take the <code class="literal">hero</code> object again:</p><pre class="programlisting">    var hero = { &#13;
      breed: 'Turtle', &#13;
      occupation: 'Ninja' &#13;
    }; &#13;
</pre><p>Following is an example for accessing a property with the dot notation:</p><pre class="programlisting">    &gt; hero.breed; &#13;
    "Turtle" &#13;
</pre><p>Let's see an example for accessing a property with the bracket notation:</p><pre class="programlisting">    &gt; hero['occupation']; &#13;
    "Ninja" &#13;
</pre><p>Consider the following example for accessing a non-existing property returns <code class="literal">undefined</code>:</p><pre class="programlisting">    &gt; 'Hair color is ' + hero.hair_color; &#13;
    "Hair color is undefined" &#13;
</pre><p>Objects can contain any data, including other objects:</p><pre class="programlisting">    var book = { &#13;
      name: 'Catch-22', &#13;
      published: 1961, &#13;
      author: { &#13;
        firstname: 'Joseph', &#13;
        lastname: 'Heller' &#13;
      } &#13;
    }; &#13;
</pre><p>To get to the <code class="literal">firstname</code> property of the object contained in the <code class="literal">author</code> property of the <code class="literal">book</code> object, you can use the following lines of code:</p><pre class="programlisting">    &gt; book.author.firstname; &#13;
    "Joseph" &#13;
</pre><p>Let see an example using the square brackets notation:</p><pre class="programlisting">    &gt; book['author']['lastname']; &#13;
    "Heller" &#13;
</pre><p>It works even if you mix both:</p><pre class="programlisting">    &gt; book.author['lastname']; &#13;
    "Heller" &#13;
    &gt; book['author'].lastname; &#13;
    "Heller" &#13;
</pre><p>Another case where you need square brackets is when the name of the property you need to access is not known beforehand. During runtime, it's dynamically stored in a variable:</p><pre class="programlisting">    &gt; var key = 'firstname'; &#13;
    &gt; book.author[key]; &#13;
    "Joseph" &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Calling an object's methods</h2></div></div></div><p>You know a method is just a property that happens to be a function, so you access methods in the same way in which you would access properties-using the dot notation or using square brackets. Calling (invoking) a method is the same as calling any other function - you just add parentheses after the method name, which effectively says Execute!:</p><pre class="programlisting">    &gt; var hero = { &#13;
        breed: 'Turtle', &#13;
        occupation: 'Ninja', &#13;
        say: function () { &#13;
          return 'I am ' + hero.occupation; &#13;
        } &#13;
      }; &#13;
    &gt; hero.say(); &#13;
    "I am Ninja" &#13;
</pre><p>If there are any parameters that you want to pass to a method, you would proceed as you would with normal functions:</p><pre class="programlisting">    &gt; hero.say('a', 'b', 'c'); &#13;
</pre><p>As you can use the array-like square brackets to access a property, it means you can also use brackets to access and invoke methods:</p><pre class="programlisting">    &gt; hero['say'](); &#13;
</pre><p>This is not a common practice, unless the method name is not known at the time of writing code, but it is instead defined at runtime:</p><pre class="programlisting">    var method = 'say'; &#13;
    hero[method](); &#13;
</pre><div><div><h3 class="title"><a id="note14"/>Note</h3><p>No quotes unless you have to use the dot notation to access methods and properties, and don't quote properties in your object literals.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Altering properties/methods</h2></div></div></div><p>JavaScript allows you to alter the properties and methods of existing objects at any time. This includes adding new properties or deleting them. You can start with a blank object and add properties later. Let's see how you can go about doing this.</p><p>An object without properties is shown as follows:</p><pre class="programlisting">    &gt; var hero = {}; &#13;
</pre><div><div><h3 class="title"><a id="note15"/>Note</h3><p>
<strong>A "blank" object</strong></p><p>In this section, you started with a "blank" object, <code class="literal">var hero = {}</code>. Blank is in quotes because this object is not really empty and useless. Although at this stage it has no properties of its own, it has already inherited some.</p><p>You'll learn more about own versus inherited properties later. So, an object in ES3 is never really blank or empty. In ES5 though, there is a way to create a completely blank object that doesn't inherit anything, but let's not get ahead too much.</p></div></div><div><ol class="orderedlist arabic"><li class="listitem">Following is the code to access an non-existing property:<pre class="programlisting">        &gt; typeof hero.breed; &#13;
        "undefined" &#13;
</pre></li><li class="listitem">Adding two properties and a method:<pre class="programlisting">        &gt; hero.breed = 'turtle'; &#13;
        &gt; hero.name = 'Leonardo'; &#13;
        &gt; hero.sayName = function () { &#13;
            return hero.name;  &#13;
          }; &#13;
</pre></li><li class="listitem">Calling the method:<pre class="programlisting">        &gt; hero.sayName(); &#13;
        "Leonardo" &#13;
</pre></li><li class="listitem">Deleting a property:<pre class="programlisting">        &gt; delete hero.name; &#13;
        true &#13;
</pre></li><li class="listitem">If you call the method again, it will no longer find the deleted <code class="literal">name</code> property:<pre class="programlisting">        &gt; hero.sayName(); &#13;
        "undefined" &#13;
</pre></li></ol></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>
<strong>Malleable objects</strong></p><p>You can always change any object at any time, such as adding and removing properties and changing their values. However, there are exceptions to this rule. A few properties of some built-in objects are not changeable (for example, <code class="literal">Math.PI</code>, as you'll see later). Also, ES5 allows you to prevent changes to objects. You'll learn more about it in <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <em>Built-in Objects</em>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Using the this value</h2></div></div></div><p>In the previous example, the <code class="literal">sayName()</code> method used <code class="literal">hero.name</code> to access the <code class="literal">name</code> property of the <code class="literal">hero</code> object. When you're inside a method though, there is another way to access the object the method belongs to. This method is using the special value <code class="literal">this</code>:</p><pre class="programlisting">    &gt; var hero = { &#13;
        name: 'Rafaelo', &#13;
        sayName: function () { &#13;
          return this.name; &#13;
        } &#13;
      }; &#13;
    &gt; hero.sayName(); &#13;
    "Rafaelo" &#13;
</pre><p>So, when you say <code class="literal">this</code>, you're actually saying-this object or the current object.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Constructor functions</h2></div></div></div><p>There is another way to create objects-using constructor functions. Let's look at an example:</p><pre class="programlisting">    function Hero() { &#13;
      this.occupation = 'Ninja'; &#13;
    } &#13;
</pre><p>In order to create an object using this function, you can use the <code class="literal">new</code> operator as follows:</p><pre class="programlisting">    &gt; var hero = new Hero(); &#13;
    &gt; hero.occupation; &#13;
    "Ninja" &#13;
</pre><p>A benefit of using constructor functions is that they accept parameters, which can be used when creating new objects. Let's modify the constructor to accept one parameter and assign it to the <code class="literal">name</code> property:</p><pre class="programlisting">    function Hero(name) { &#13;
      this.name = name; &#13;
      this.occupation = 'Ninja'; &#13;
      this.whoAreYou = function () { &#13;
        return "I'm " + &#13;
               this.name + &#13;
               " and I'm a " + &#13;
               this.occupation; &#13;
      }; &#13;
    } &#13;
</pre><p>Now, you can create different objects using the same constructor:</p><pre class="programlisting">    &gt; var h1 = new Hero('Michelangelo'); &#13;
    &gt; var h2 = new Hero('Donatello'); &#13;
    &gt; h1.whoAreYou(); &#13;
    "I'm Michelangelo and I'm a Ninja" &#13;
    &gt; h2.whoAreYou(); &#13;
    "I'm Donatello and I'm a Ninja" &#13;
</pre><div><div><h3 class="title"><a id="note17"/>Note</h3><p>By convention, you should capitalize the first letter of your constructor functions so that you have a visual clue that they are not intended to be called as regular functions.</p></div></div><p>If you call a function that is designed to be a constructor but you omit the <code class="literal">new</code> operator, it is not an error. However, it doesn't give you the expected result:</p><pre class="programlisting">    &gt; var h = Hero('Leonardo'); &#13;
    &gt; typeof h; &#13;
    "undefined" &#13;
</pre><p>What happened here? There is no <code class="literal">new</code> operator, so a new object was not created. The function was called like any other function, so the variable <code class="literal">h</code> contains the value that the function returns. The function does not return anything (there's no <code class="literal">return</code> function), so it actually returns <code class="literal">undefined</code>, which gets assigned to the variable <code class="literal">h</code>.</p><p>In this case, what does <code class="literal">this</code> refer to? It refers to the global object.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>The global object</h2></div></div></div><p>You have already learned a bit about global variables (and how you should avoid them). You also know that JavaScript programs run inside a host environment (the browser, for example). Now that you know about objects, it's time for the whole truth, the host environment provides a global object, and all global variables are accessible as properties of the global object.</p><p>If your host environment is the web browser, the global object is called <strong>window</strong>. Another way to access the global object (and this is also true in most other environments) is to use <code class="literal">this</code> keyword outside a constructor function, for example in the global program code outside any function.</p><p>As an illustration, you can declare a global variable outside any function as follows:</p><pre class="programlisting">    &gt; var a = 1; &#13;
</pre><p>Then, you can access this global variable in various ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As a variable <code class="literal">a</code></li><li class="listitem" style="list-style-type: disc">As a property of the global object, for example, <code class="literal">window['a']</code> or <code class="literal">window.a</code></li><li class="listitem" style="list-style-type: disc">As a property of the global object referred to as <code class="literal">this</code>:<pre class="programlisting">    &gt; var a = 1; &#13;
    &gt; window.a; &#13;
    1 &#13;
    &gt; this.a; &#13;
    1 &#13;
</pre></li></ul></div><p>Let's go back to the case where you define a constructor function and call it without the <code class="literal">new</code> operator. In such cases, <code class="literal">this</code> refers to the global object and all the properties set to <code class="literal">this</code> become properties of <code class="literal">window</code>.</p><p>Declaring a constructor function and calling it without new returns <code class="literal">"undefined"</code>:</p><pre class="programlisting">    &gt; function Hero(name) { &#13;
        this.name = name; &#13;
      } &#13;
    &gt; var h = Hero('Leonardo'); &#13;
    &gt; typeof h; &#13;
    "undefined" &#13;
    &gt; typeof h.name; &#13;
    TypeError: Cannot read property 'name' of undefined &#13;
</pre><p>As you had <code class="literal">this</code> keyword inside the function <code class="literal">Hero</code>, a global variable (a property of the global object) called <code class="literal">name</code> was created:</p><pre class="programlisting">    &gt; name; &#13;
    "Leonardo" &#13;
    &gt; window.name; &#13;
    "Leonardo" &#13;
</pre><p>If you call the same constructor function using <code class="literal">new</code>, then a new object is returned, and <code class="literal">this</code> refers to it:</p><pre class="programlisting">    &gt; var h2 = new Hero('Michelangelo'); &#13;
    &gt; typeof h2; &#13;
    "object" &#13;
    &gt; h2.name; &#13;
    "Michelangelo" &#13;
</pre><p>The built-in global functions you have seen in <a class="link" href="ch03.html" title="Chapter 3. Functions">Chapter 3</a>, <em>Functions</em>, can also be invoked as methods of the <code class="literal">window</code> object. So, the following two calls have the same result:</p><pre class="programlisting">    &gt; parseInt('101 dalmatians'); &#13;
    101 &#13;
    &gt; window.parseInt('101 dalmatians') &#13;
    101 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>The constructor property</h2></div></div></div><p>When an object is created, a special property is assigned to it behind the scenes-the <code class="literal">constructor</code> property. It contains a reference to the constructor function used to create <code class="literal">this</code> object.</p><p>Continuing from the previous example:</p><pre class="programlisting">    &gt; h2.constructor; &#13;
    function Hero(name) { &#13;
      this.name = name; &#13;
    } &#13;
</pre><p>As the <code class="literal">constructor</code> property contains a reference to a function, you might as well call this function to produce a new object. The following code is like saying, "I don't care how object <code class="literal">h2</code> was created, but I want another one just like it":</p><pre class="programlisting">    &gt; var h3 = new h2.constructor('Rafaello'); &#13;
    &gt; h3.name; &#13;
    "Rafaello" &#13;
</pre><p>If an object was created using the object literal notation, its constructor is the built-in <code class="literal">Object()</code> constructor function (there is more about this later in this chapter):</p><pre class="programlisting">    &gt; var o = {}; &#13;
    &gt; o.constructor; &#13;
    function Object() { [native code] } &#13;
    &gt; typeof o.constructor; &#13;
    "function" &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>The instanceof operator</h2></div></div></div><p>With the <code class="literal">instanceof</code> operator, you can test whether an object was created with a specific <code class="literal">constructor</code> function:</p><pre class="programlisting">    &gt; function Hero() {} &#13;
    &gt; var h = new Hero(); &#13;
    &gt; var o = {}; &#13;
    &gt; h instanceof Hero; &#13;
    true &#13;
    &gt; h instanceof Object; &#13;
    true &#13;
    &gt; o instanceof Object; &#13;
    true &#13;
</pre><p>Note that you don't put parentheses after the function name (you don't use <code class="literal">h instanceof Hero()</code>). This is because you're not invoking this function, but just referring to it by name, as with any other variable.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Functions that return objects</h2></div></div></div><p>In addition to using <code class="literal">constructor</code> functions and the <code class="literal">new</code> operator to create objects, you can also use a normal function to create objects without the <code class="literal">new</code> operator. You can have a function that does a bit of preparatory work and has an object as a return value.</p><p>For example, here's a simple <code class="literal">factory()</code> function that produces objects:</p><pre class="programlisting">    function factory(name) { &#13;
      return { &#13;
        name: name &#13;
      }; &#13;
    } &#13;
</pre><p>Consider the following example using the <code class="literal">factory()</code> function:</p><pre class="programlisting">    &gt; var o = factory('one'); &#13;
    &gt; o.name; &#13;
    "one" &#13;
    &gt; o.constructor; &#13;
    function Object() { [native code] } &#13;
</pre><p>In fact, you can also use <code class="literal">constructor</code> functions and <code class="literal">return</code> objects different from <code class="literal">this</code> keyword. This means you can modify the default behavior of the <code class="literal">constructor</code> function. Let's see how.</p><p>Here's the normal constructor scenario:</p><pre class="programlisting">    &gt; function C() { &#13;
        this.a = 1; &#13;
      } &#13;
    &gt; var c = new C(); &#13;
    &gt; c.a; &#13;
    1 &#13;
</pre><p>However, now, look at this scenario:</p><pre class="programlisting">    &gt; function C2() { &#13;
        this.a = 1; &#13;
        return {b: 2}; &#13;
      } &#13;
    &gt; var c2 = new C2(); &#13;
    &gt; typeof c2.a; &#13;
    "undefined" &#13;
    &gt; c2.b; &#13;
    2 &#13;
</pre><p>What happened here? Instead of returning the <code class="literal">this</code> object, which contains the property <code class="literal">a</code>, the constructor returned another object that contains the property <code class="literal">b</code>. This is possible only if the return value is an object. Otherwise, if you try to return anything that is not an object, the constructor will proceed with its usual behavior and return <code class="literal">this</code>.</p><p>If you think about how objects are created inside constructor functions, you can imagine that a variable called <code class="literal">this</code> is defined at the top of the function and then returned at the end. Consider the following code:</p><pre class="programlisting">    function C() { &#13;
      // var this = {}; // pseudo code, you can't do this &#13;
      this.a = 1; &#13;
      // return this; &#13;
    } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Passing objects</h2></div></div></div><p>When you assign an object to a different variable or pass it to a function, you only pass a reference to that object. Consequently, if you make a change to the reference, you're actually modifying the original object.</p><p>Here's an example of how you can assign an object to another variable and then make a change to the copy. As a result, the original object is also changed:</p><pre class="programlisting">    &gt; var original = {howmany: 1}; &#13;
    &gt; var mycopy = original; &#13;
    &gt; mycopy.howmany; &#13;
    1 &#13;
    &gt; mycopy.howmany = 100; &#13;
    100 &#13;
    &gt; original.howmany; &#13;
    100 &#13;
</pre><p>The same thing applies when passing objects to functions:</p><pre class="programlisting">    &gt; var original = {howmany: 100}; &#13;
    &gt; var nullify = function (o) { o.howmany = 0; }; &#13;
    &gt; nullify(original); &#13;
    &gt; original.howmany; &#13;
    0 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Comparing objects</h2></div></div></div><p>When you compare objects, you'll get <code class="literal">true</code> only if you compare two references to the same object. If you compare two distinct objects that happen to have the exact same methods and properties, the result would be <code class="literal">false</code>.</p><p>Let's create two objects that look the same:</p><pre class="programlisting">    &gt; var fido  = {breed: 'dog'}; &#13;
    &gt; var benji = {breed: 'dog'}; &#13;
</pre><p>Comparing them returns <code class="literal">false</code>:</p><pre class="programlisting">    &gt; benji === fido; &#13;
    false &#13;
    &gt; benji == fido; &#13;
    false &#13;
</pre><p>You can create a new variable, <code class="literal">mydog</code>, and assign one of the objects to it. This way, the variable <code class="literal">mydog</code> actually points to the same object:</p><pre class="programlisting">    &gt; var mydog = benji; &#13;
</pre><p>In this case, <code class="literal">benji</code> is <code class="literal">mydog</code> because they are the same object (changing the <code class="literal">mydog</code> variable's properties will change the <code class="literal">benji</code> variable's properties). The comparison returns <code class="literal">true</code>:</p><pre class="programlisting">    &gt; mydog === benji; &#13;
    true &#13;
</pre><p>As <code class="literal">fido</code> is a different object, it does not compare to <code class="literal">mydog</code>:</p><pre class="programlisting">    &gt; mydog === fido; &#13;
    false &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Objects in the WebKit console</h2></div></div></div><p>Before diving into the built-in objects in JavaScript, let's quickly say a few words about working with objects in the WebKit console.</p><p>After playing around with the examples in this chapter, you might have already noticed how objects are displayed in the console. If you create an object and type its name, you'll get an arrow pointing to the word object.</p><p>The object is clickable and expands to show you a list of all of the properties of the object. If a property is also an object, there is an arrow next to it too, so you can expand this as well. This is handy as it gives you an insight into exactly what this object contains. Consider the following example:</p><p>
</p><div><img src="img/image_04_001-e1482749176512.jpg" alt="Objects in the WebKit console"/></div><p>
</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>You can ignore <code class="literal">__proto__</code> for now; there's more about it in the next chapter.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec31"/>Logging using the console.log method</h3></div></div></div><p>The console also offers you an object called <code class="literal">console</code> and a few methods, such as <code class="literal">console.log()</code> and <code class="literal">console.error()</code>, which you can use to display any value you want in the console.</p><p>
</p><div><img src="img/image_04_002-e1482749557416.jpg" alt="Logging using the console.log method"/></div><p>
</p><p>The <code class="literal">console.log()</code> method is convenient when you want to quickly test something, as well as when you want to dump some intermediate debugging information in your real scripts. Here's how you can experiment with loops, for example:</p><pre class="programlisting">    &gt; for (var i = 0; i &lt; 5; i++) { &#13;
        console.log(i);  &#13;
      } &#13;
    0 &#13;
    1 &#13;
    2 &#13;
    3 &#13;
    4 &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>ES6 object literals</h2></div></div></div><p>ES6 introduces a much succinct syntax while using object literals. ES6 offers several shorthands for property initialization and function definitions. ES6 shorthands closely resemble a familiar JSON syntax. Consider the following code fragment:</p><pre class="programlisting">    let a = 1 &#13;
    let b = 2 &#13;
    let val = {a: a, b: b} &#13;
    console.log(val) //{"a":1,"b":2} &#13;
</pre><p>This is a typical way to assign property values. If the name of the variable and the property key is the same, ES6 allows you to use shorthand syntax. The preceding code can be written as follows:</p><pre class="programlisting">    let a = 1 &#13;
    let b = 2 &#13;
    let val = {a, b} &#13;
    console.log(val) //{"a":1,"b":2} &#13;
</pre><p>Similar syntax is available for method definitions as well. As we have discussed, methods are simply properties of an object whose values are functions. Consider the following example:</p><pre class="programlisting">    var obj = { &#13;
      prop: 1, &#13;
      modifier:  function() { &#13;
        console.log(this.prop);   &#13;
      } &#13;
    } &#13;
</pre><p>There is a compact way to define methods in ES6. You simply drop the <code class="literal">function</code> keyword and <code class="literal">:</code>. The equivalent code in ES6 would look like the following:</p><pre class="programlisting">    var obj = { &#13;
      prop: 1, &#13;
      modifier () { &#13;
        console.log(this.prop); &#13;
      } &#13;
    } &#13;
</pre><p>ES6 allows you to compute the key of a property. Until ES6, you could only use fixed property names. Here is an example:</p><pre class="programlisting">    var obj = { &#13;
      prop: 1, &#13;
      modifier: function () { &#13;
        console.log(this.prop);   &#13;
      } &#13;
    } &#13;
    obj.prop = 2; &#13;
    obj.modifier(); //2 &#13;
</pre><p>As you can see, we are limited to using fixed key names: <code class="literal">prop</code> and <code class="literal">modifier</code> in this case. However, ES6 allows you to use computed property keys. It is possible to create property keys dynamically using values returned by a function as well:</p><pre class="programlisting">    let vehicle = "car" &#13;
    function vehicleType(){ &#13;
      return "truck" &#13;
    } &#13;
    let car = { &#13;
      [vehicle+"_model"]: "Ford" &#13;
    } &#13;
    let truck= { &#13;
      [vehicleType() + "_model"]: "Mercedez" &#13;
    } &#13;
    console.log(car) //{"car_model":"Ford"} &#13;
    console.log(truck) //{"truck_model":"Mercedez"} &#13;
</pre><p>We are using the value of variable <code class="literal">vehicle</code> to concatenate with a fixed string to derive the property key while creating the <code class="literal">car</code> object. In the second snippet, we are creating a property by concatenating a fixed string with the value returned by a function. This way of computing property keys provides great flexibility while creating objects, and a lot of boilerplate and repetitive code can be eliminated.</p><p>This syntax is applicable to method definition as well:</p><pre class="programlisting">    let object_type = "Vehicle" &#13;
    let obj = { &#13;
      ["get"+object_type]() { &#13;
        return "Ford" &#13;
      } &#13;
    } &#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Object properties and attributes</h1></div></div></div><p>Each object has a few properties. Each property, in turn, has a key and attributes. A property's state is stored in these attributes. All properties have the following attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Enumerable (boolean)</strong>: This indicates if you can enumerate the properties of the object. System properties are non-enumerable while user properties are enumerable. Unless there is a strong reason, this property should remain untouched.</li><li class="listitem" style="list-style-type: disc"><strong>Configurable(boolean)</strong>: If this attribute is <code class="literal">false</code>, the property cannot be deleted or edited (it cannot change any of its attribute).</li></ul></div><p>You can use the <code class="literal">Object.getOwnPropertyDescriptor()</code> method to retrieve an object's own properties:</p><pre class="programlisting">    let obj = { &#13;
      age: 25 &#13;
    } &#13;
    console.log(Object.getOwnPropertyDescriptor(obj, 'age')); &#13;
    //{"value":25,"writable":true,"enumerable":true,"configurable":true} &#13;
</pre><p>Meanwhile, the property can be defined using the <code class="literal">Object.defineProperty() method</code>:</p><pre class="programlisting">    let obj = { &#13;
      age: 25 &#13;
    } &#13;
    Object.defineProperty(obj, 'age', { configurable: false }) &#13;
    console.log(Object.getOwnPropertyDescriptor(obj, 'age')); &#13;
    //{"value":25,"writable":true,"enumerable":true,"configurable":false} &#13;
</pre><p>Though you would never use these methods, it is important to understand object properties and attributes. In the next section, we will discuss how some of the <code class="literal">object</code> methods are used in context of some of these properties.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>ES6 object methods</h1></div></div></div><p>ES6 introduces a few static helper methods for objects. <code class="literal">Object.assign</code> is a helper method that replaces popular mixins to perform a shallow copy of an object.</p><div><div><div><div><h2 class="title"><a id="ch04lvl3sec32"/>Copy properties using Object.assign</h2></div></div></div><p>This method is used to copy properties of the target object into the source object. In other words, this method merges the source object with the target object and modifies the target object:</p><pre class="programlisting">    let a = {} &#13;
    Object.assign(a, { age: 25 }) &#13;
    console.log(a)  //{"age":25} &#13;
</pre><p>The first parameter to <code class="literal">Object.assign</code> is the target on which source properties are copied. The same target object is returned to the caller. Existing properties are overwritten, while properties that aren't part of the source object are ignored:</p><pre class="programlisting">    let a = {age : 23, gender: "male"} &#13;
    Object.assign(a, { age: 25 })    // age overwritten, but gender ignored &#13;
    console.log(a)  //{"age":25, "gender":"male"} &#13;
</pre><p>
<code class="literal">Object.assign</code> can take multiple source objects. You can write <code class="literal">Object.assign(target, source1, source2)</code>. Here is an example:</p><pre class="programlisting">    console.log(Object.assign({a:1, b:2}, {a: 2}, {c: 4}, {b: 3})) &#13;
    //Object { &#13;
    //"a": 2,  &#13;
    //"b": 3, &#13;
    //"c": 4 &#13;
    // &#13;
</pre><p>In this snippet, we are assigning properties from multiple source objects. Also, notice how <code class="literal">Object.assign()</code> returns the target object, which we in turn use inside <code class="literal">console.log()</code>.</p><p>One point to note is that only enumerable own (non-inherited) properties can be copied using <code class="literal">Object.assign()</code>. Properties from the prototype chain (will be discussed later in this chapter when we talk about Inheritance) are not considered. Our earlier discussion of enumerable properties will help you understand this distinction.</p><p>In the following example, we will create a non-enumerable property using <code class="literal">defineProperty()</code> and validate the fact that <code class="literal">Object.assign()</code> ignores that property:</p><pre class="programlisting">    let a = {age : 23, gender: "male"} &#13;
    Object.defineProperty(a, 'superpowers', {enumberable:false, value: 'ES6'}) &#13;
    console.log(</pre><p>The property defined as <code class="literal">superpowers</code> has the enumerable attribute set to <code class="literal">false</code>. While copying properties, this property is ignored.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl3sec33"/>Compare values with Object.is</h2></div></div></div><p>ES6 provides a slightly precise way of comparing values. We have discussed the strict equality operator <code class="literal">===</code>. However, for <code class="literal">NaN</code> and <code class="literal">-0</code> and <code class="literal">+0</code>, the strict equality operator behaves inconsistently. Here is an example:</p><pre class="programlisting">    console.log(NaN===NaN) //false &#13;
    console.log(-0===+0) //true &#13;
    //ES6 Object.is &#13;
    console.log(Object.is(NaN,NaN)) //true &#13;
    console.log(Object.is(-0,+0)) //false &#13;
</pre><p>Apart from these two cases, <code class="literal">Object.is()</code> can safely be replaced with the <code class="literal">===</code> operator.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Destructuring</h1></div></div></div><p>You will be working with objects and arrays all the time when you code. JavaScript object and array notations resemble the JSON format. You will define objects and arrays, and then retrieve elements from them. ES6 gives a convenient syntax that significantly improves the way we access properties/members from objects and arrays. Let's consider a typical code you would often write:</p><pre class="programlisting">    var config = { &#13;
      server: 'localhost', &#13;
      port: '8080' &#13;
    } &#13;
    var server = config.server; &#13;
    var port = config.port; &#13;
</pre><p>Here, we extracted values of server and port from the <code class="literal">config</code> object and assigned them to local variables. Pretty straightforward! However, when this object has a bunch of properties, some of them nested, this simple operation can get very tedious to write.</p><p>ES6 destructuring syntax allows an object literal on the left-hand side of an assignment statement. In the following example, we will define an object <code class="literal">config</code> with a few properties. Later, we will use destructuring to assign the object <code class="literal">config</code> to assign values to individual properties on the left-hand side of the assignment statement:</p><pre class="programlisting">    let config = { &#13;
      server: 'localhost', &#13;
      port: '8080', &#13;
      timeout: 900, &#13;
    } &#13;
    let {server,port} = config  &#13;
    console.log(server, port) //"localhost" "8080" &#13;
</pre><p>As you can see <code class="literal">server</code> and <code class="literal">port</code> are local variables that got assigned properties from the <code class="literal">config</code> object because the name of the properties were the same as that of the local variables. You can also pick particular properties while you assign them to local variables. Here is an example:</p><pre class="programlisting">    let {timeout : t} =config &#13;
    console.log(t) //900 &#13;
</pre><p>Here, we are only picking <code class="literal">timeout</code> from the <code class="literal">config</code> object and assign it to a local variable <code class="literal">t</code>.</p><p>You can also use the destructuring syntax to assign values to already declared variables. In this case, you have to put parentheses around the assignment:</p><pre class="programlisting">    let config = { &#13;
      server: 'localhost', &#13;
      port: '8080', &#13;
      timeout: 900, &#13;
    } &#13;
    let server = '127.0.0.1'; &#13;
    let port = '80'; &#13;
    ({server,port} = config) //assignment surrounded by () &#13;
    console.log(server, port) //"localhost" "8080" &#13;
</pre><p>As the destructuring expression evaluates to the right-hand side of the expression, it's possible to use it anywhere you would expect a value. For example, in a function call, as shown here:</p><pre class="programlisting">    let config = { &#13;
      server: 'localhost', &#13;
      port: '8080', &#13;
      timeout: 900, &#13;
    } &#13;
    let server='127.0.0.1'; &#13;
    let port ='80'; &#13;
    let timeout ='100'; &#13;
 &#13;
    function startServer(configValue){ &#13;
      console.log(configValue) &#13;
    } &#13;
    startServer({server,port,timeout} = config) &#13;
</pre><p>If you specify a local variable with a property name that does not exist in the object, the local variable gets an <code class="literal">undefined</code> value. However, while using variables in the destructuring assignment, you can optionally specify default values:</p><pre class="programlisting">    let config = { &#13;
      server: 'localhost', &#13;
      port: '8080' &#13;
    } &#13;
    let {server,port,timeout=0} = config &#13;
    console.log(timeout) &#13;
</pre><p>In this example, for a non-existent property timeout, we provided a default value to prevent getting <code class="literal">undefined</code> values assigned to local variables.</p><p>Destructuring works on arrays as well, and the syntax is also very similar to that of the objects. We just need to replace object literal syntax with <code class="literal">array:literals</code>:</p><pre class="programlisting">    const arr = ['a','b'] &#13;
    const [x,y] = arr &#13;
    console.log (x,y) /"a" "b" &#13;
</pre><p>As you can see, this is the exact same syntax we saw earlier. We defined an array <code class="literal">arr</code> and later used the destructuring syntax to assign elements of that array to two local variables, <code class="literal">x</code> and <code class="literal">y</code>. Here, the assignment happens based on the order of elements in the array. As you only care about the position of elements, you can skip some of them if you want to. Here is an example:</p><pre class="programlisting">    const days = ['Thursday','Friday','Saturday','Sunday'] &#13;
    const [,,sat,sun] = days &#13;
    console.log (sat,sun) //"Saturday" "Sunday" &#13;
</pre><p>Here, we know that we need elements from positions 2 and 3 (an array's index starts from 0), and hence, we ignore elements at positions 0 and 1. Array destructuring can eliminate the use of a <code class="literal">temp</code> variable while swapping values of two variables. Consider the following:</p><pre class="programlisting">    let a=1, b=2; &#13;
    [b,a] = [a,b] &#13;
    console.log(a,b) //2 1 &#13;
</pre><p>You can use the rest operator (<code class="literal">...</code>) to extract remaining elements and assign them to an array. The rest operator can only be used as the last operator during destructuring:</p><pre class="programlisting">    const [x, ...y] = ['a', 'b', 'c']; // x='a'; y=['b', 'c'] &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Built-in objects</h1></div></div></div><p>Earlier in this chapter, you came across the <code class="literal">Object()</code> constructor function. It's returned when you create objects with the object literal notation and access their <code class="literal">constructor</code> property. <code class="literal">Object()</code> is one of the built-in constructors; there are a few others, and in the rest of this chapter you'll see all of them.</p><p>The built-in objects can be divided into three groups:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Data wrapper objects</strong>: These are <code class="literal">Object</code>, <code class="literal">Array</code>, <code class="literal">Function</code>, <code class="literal">Boolean</code>, <code class="literal">Number</code>, and <code class="literal">String</code>. These objects correspond to the different data types in JavaScript. There is a data wrapper object for every different value returned by <code class="literal">typeof</code> (discussed in <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <em>Primitive Data Types, Arrays, Loops, and Conditions</em>), with the exception of <code class="literal">undefined</code> and <code class="literal">null</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Utility objects</strong>: These are <code class="literal">Math</code>, <code class="literal">Date</code>, and <code class="literal">RegExp</code>, and can come in handy.</li><li class="listitem" style="list-style-type: disc"><strong>Error objects</strong>: These include the generic <code class="literal">Error</code> object as well as other more specific objects that can help your program recover its working state when something unexpected happens.</li></ul></div><p>Only a handful of methods of the built-in objects will be discussed in this chapter. For a full reference, see <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <em>Built-in Objects</em>.</p><p>If you're confused about what a built-in object is and what a built-in constructor is, well, they are the same thing. In a moment, you'll see how functions and, therefore, constructor functions, are also objects.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Object</h2></div></div></div><p>Object is the parent of all JavaScript objects, which means that every object you create inherits from it. To create a new empty object, you can use the literal notation or the <code class="literal">Object()</code> constructor function. The following two lines are equivalent:</p><pre class="programlisting">    &gt; var o = {}; &#13;
    &gt; var o = new Object(); &#13;
</pre><p>As mentioned before, an empty (or blank) object is not completely useless, because it already contains several inherited methods and properties. In this book, empty means an object like <code class="literal">{}</code> that has no properties of its own, other than the ones it automatically gets. Let's look at a few of the properties that even blank objects already have:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">o.constructor</code> property returns a reference to the constructor function</li><li class="listitem" style="list-style-type: disc">The <code class="literal">o.toString()</code> is a method that returns a string representation of the object</li><li class="listitem" style="list-style-type: disc">The <code class="literal">o.valueOf()</code> returns a single-value representation of the object; often, this is the object itself</li></ul></div><p>Let's see these methods in action. First, create an object:</p><pre class="programlisting">    &gt; var o = new Object(); &#13;
</pre><p>Calling <code class="literal">toString()</code> returns a string representation of the object:</p><pre class="programlisting">    &gt; o.toString(); &#13;
    "[object Object]" &#13;
</pre><p>The <code class="literal">toString()</code> method will be called internally by JavaScript when an object is used in a string context. For example, <code class="literal">alert()</code> works only with strings, so if you call the <code class="literal">alert()</code> function passing an object, the <code class="literal">toString()</code>method will be called behind the scenes. These two lines produce the same result:</p><pre class="programlisting">    &gt; alert(o); &#13;
    &gt; alert(o.toString()); &#13;
</pre><p>Another type of string context is the string concatenation. If you try to concatenate an object with a string, the object's <code class="literal">toString()</code> method is called first:</p><pre class="programlisting">    &gt; "An object: " + o; &#13;
    "An object: [object Object]" &#13;
</pre><p>The <code class="literal">valueOf()</code> method is another method that all objects provide. For the simple objects (whose constructor is <code class="literal">Object()</code>), the <code class="literal">valueOf()</code> method returns the object itself:</p><pre class="programlisting">    &gt; o.valueOf() === o; &#13;
    true &#13;
</pre><p>To summarize:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can create objects either with <code class="literal">var o = {};</code> (object literal notation, the preferred method) or with <code class="literal">var o = new Object();</code></li><li class="listitem" style="list-style-type: disc">Any object, no matter how complex, inherits from the <code class="literal">Object</code> object and therefore, offers methods such as <code class="literal">toString()</code> and properties such as a constructor</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Array</h2></div></div></div><p>
<code class="literal">Array()</code> is a built-in function that you can use as a constructor to create arrays:</p><pre class="programlisting">    &gt; var a = new Array(); &#13;
</pre><p>This is equivalent to the array literal notation:</p><pre class="programlisting">    &gt; var a = []; &#13;
</pre><p>No matter how the array is created, you can add elements to it as usual:</p><pre class="programlisting">    &gt; a[0] = 1; &#13;
    &gt; a[1] = 2; &#13;
    &gt; a; &#13;
    [1, 2] &#13;
</pre><p>When using the <code class="literal">Array()</code> constructor, you can also pass values that will be assigned to the new array's elements:</p><pre class="programlisting">    &gt; var a = new Array(1, 2, 3, 'four'); &#13;
    &gt; a; &#13;
    [1, 2, 3, "four"] &#13;
</pre><p>An exception to this is when you pass a single number to the constructor. In this case, the number is considered to be the length of the array:</p><pre class="programlisting">    &gt; var a2 = new Array(5); &#13;
    &gt; a2; &#13;
     [undefined x 5] &#13;
</pre><p>As arrays are created with a constructor, does this mean that arrays are in fact objects? Yes, and you can verify this using the <code class="literal">typeof</code> operator:</p><pre class="programlisting">    &gt; typeof [1, 2, 3]; &#13;
    "object" &#13;
</pre><p>As arrays are objects, this means that they inherit the properties and methods of the parent object:</p><pre class="programlisting">    &gt; var a = [1, 2, 3, 'four']; &#13;
    &gt; a.toString(); &#13;
    "1,2,3,four" &#13;
    &gt; a.valueOf(); &#13;
    [1, 2, 3, "four"] &#13;
    &gt; a.constructor; &#13;
    function Array() { [native code] } &#13;
</pre><p>Arrays are objects, but of a special type because:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The names of their properties are automatically assigned using numbers starting from 0.</li><li class="listitem" style="list-style-type: disc">They have a <code class="literal">length</code> property that contains the number of elements in the array.</li><li class="listitem" style="list-style-type: disc">They have more built-in methods in addition to those inherited from the parent object.</li></ul></div><p>Let's examine the differences between an array and an object, starting by creating the empty array <code class="literal">a</code> and the empty object <code class="literal">o</code>:</p><pre class="programlisting">    &gt; var a = [], o = {}; &#13;
</pre><p>Array objects have a <code class="literal">length</code> property automatically defined for them, while normal objects do not:</p><pre class="programlisting">    &gt; a.length; &#13;
    0 &#13;
    &gt; typeof o.length; &#13;
    "undefined" &#13;
</pre><p>It's ok to add both numeric and non-numeric properties to both arrays and objects:</p><pre class="programlisting">    &gt; a[0] = 1;  &#13;
    &gt; o[0] = 1; &#13;
    &gt; a.prop = 2; &#13;
    &gt; o.prop = 2; &#13;
</pre><p>The <code class="literal">length</code> property is always up to date with the number of numeric properties, while it ignores the non-numeric ones:</p><pre class="programlisting">    &gt; a.length; &#13;
    1 &#13;
</pre><p>The <code class="literal">length</code> property can also be set by you. Setting it to a greater value than the current number of items in the array makes room for additional elements. If you try to access these non-existing elements, you'll get the value <code class="literal">undefined</code>:</p><pre class="programlisting">    &gt; a.length = 5; &#13;
    5 &#13;
    &gt; a; &#13;
    [1, undefined x 4] &#13;
</pre><p>Setting the <code class="literal">length</code> property to a lower value removes the trailing elements:</p><pre class="programlisting">    &gt; a.length = 2; &#13;
    2 &#13;
    &gt; a; &#13;
    [1, undefined x 1] &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch04lvl3sec34"/>A few array methods</h3></div></div></div><p>In addition to the methods inherited from the parent object, array objects also have specialized methods for working with arrays, such as <code class="literal">sort()</code>, <code class="literal">join()</code>, and <code class="literal">slice()</code>, among others (see <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <em>Built-in Objects</em>, for the complete list).</p><p>Let's take an array and experiment with some of these methods:</p><pre class="programlisting">    &gt; var a = [3, 5, 1, 7, 'test']; &#13;
</pre><p>The <code class="literal">push()</code> method appends a new element to the end of the array. The <code class="literal">pop()</code> method removes the last element. The <code class="literal">a.push('new')</code> method works like <code class="literal">a[a.length] = 'new'</code>, and <code class="literal">a.pop()</code> is like <code class="literal">a.length-</code>.</p><p>The <code class="literal">push()</code> method returns the length of the changed array, whereas <code class="literal">pop()</code> returns the removed element:</p><pre class="programlisting">    &gt; a.push('new'); &#13;
    6 &#13;
    &gt; a; &#13;
    [3, 5, 1, 7, "test", "new"] &#13;
    &gt; a.pop(); &#13;
    "new" &#13;
    &gt; a; &#13;
    [3, 5, 1, 7, "test"] &#13;
</pre><p>The <code class="literal">sort()</code> method sorts the array and returns it. In the next example, after sort, both <code class="literal">a</code> and <code class="literal">b</code> point to the same array:</p><pre class="programlisting">    &gt; var b = a.sort(); &#13;
    &gt; b; &#13;
    [1, 3, 5, 7, "test"] &#13;
    &gt; a === b; &#13;
    true &#13;
</pre><p>The <code class="literal">join()</code> method returns a string containing the values of all the elements in the array glued together using the string parameter passed to <code class="literal">join()</code>:</p><pre class="programlisting">    &gt; a.join(' is not '); &#13;
    "1 is not 3 is not 5 is not 7 is not test" &#13;
</pre><p>The <code class="literal">slice()</code> method returns a piece of the array without modifying the source array. The first parameter to <code class="literal">slice()</code> is the start index (zero-based), and the second is the end index (both indices are zero-based). Start index is included, while the end index is not. Take a look at the following example:</p><pre class="programlisting">    &gt; b = a.slice(1, 3); &#13;
    [3, 5] &#13;
    &gt; b = a.slice(0, 1); &#13;
    [1] &#13;
    &gt; b = a.slice(0, 2); &#13;
    [1, 3] &#13;
</pre><p>After all the slicing, the source array is still the same:</p><pre class="programlisting">    &gt; a; &#13;
    [1, 3, 5, 7, "test"] &#13;
</pre><p>The <code class="literal">splice()</code> method modifies the source array. It removes a slice, returns it, and optionally fills the gap with new elements. The first two parameters define the start index and length (number of elements) of the slice to be removed; the other parameters pass the new values:</p><pre class="programlisting">    &gt; b = a.splice(1, 2, 100, 101, 102); &#13;
    [3, 5] &#13;
    &gt; a; &#13;
    [1, 100, 101, 102, 7, "test"] &#13;
</pre><p>Filling the gap with new elements is optional, so you can skip it:</p><pre class="programlisting">    &gt; a.splice(1, 3);  &#13;
    [100, 101, 102] &#13;
    &gt; a; &#13;
    [1, 7, "test"] &#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>ES6 array methods</h1></div></div></div><p>Arrays get a bunch of useful methods. Libraries such as <strong>lodash</strong> and <strong>underscore</strong> provided features missing in the language so far. With the new helper methods, array creation and manipulation is much more functional and easy to code.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Array.from</h2></div></div></div><p>Converting array-like values to arrays has always been a bit of a challenge in JavaScript. People have employed several hacks and written libraries to just let you handle arrays effectively.</p><p>ES6 introduces a very helpful method to convert array-like objects and iterable values into arrays. Array-like values are objects that have a length property and indexed elements. Every function has an implicit arguments variable that contains a list of all arguments passed to the function. This variable is an array-like object. Before ES6, the only way we could convert the <code class="literal">arguments</code> object to an array was to iterate through it and copy the values over to a new array:</p><pre class="programlisting">    function toArray(args) { &#13;
        var result = []; &#13;
        for (var i = 0, len = args.length; i &lt; len; i++) { &#13;
            result.push(args[i]); &#13;
        } &#13;
        return result; &#13;
    } &#13;
    function doSomething() { &#13;
        var args = toArray(arguments); &#13;
        console.log(args) &#13;
    } &#13;
    doSomething("hellow", "world") &#13;
    //Array [ &#13;
    //  "hellow", &#13;
    //  "world" &#13;
    //] &#13;
</pre><p>Here, we are creating a new array to copy over all elements of the <code class="literal">arguments</code> object. This is wasteful and needs a lot of unnecessary coding. <code class="literal">Array.from()</code> is a concise way to convert array-like objects into arrays. We can convert this example to a more succinct one using <code class="literal">Array.from()</code>:</p><pre class="programlisting">    function doSomething() { &#13;
        console.log(Array.from(arguments)) &#13;
    } &#13;
    doSomething("hellow", "world") &#13;
    //Array [ &#13;
    //  "hellow", &#13;
    //  "world" &#13;
    //] &#13;
</pre><p>You can provide your own mapping scheme while calling <code class="literal">Array.from()</code> by providing a mapping function. This function is invoked on all the elements of the object and converts it. This is a useful construct for many common usecases, for example:</p><pre class="programlisting">    function doSomething() { &#13;
       console.log(Array.from(arguments, function(elem) &#13;
      { return elem + " mapped"; })); &#13;
    } &#13;
</pre><p>In this example, we are deconstructing the <code class="literal">arguments</code> object using <code class="literal">Array.from</code> and for each element in <code class="literal">arguments</code> object, we are calling a function.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Creating arrays using Array.of</h2></div></div></div><p>Creating an array using the <code class="literal">Array()</code> constructor causes a bit of a problem. The constructor behaves differently based on the number and type of arguments. When you pass a single numeric value to the <code class="literal">Array()</code> constructor, an array of undefined elements is created, with the value of the length assigned to the value of the argument:</p><pre class="programlisting">    let arr = new Array(2) &#13;
    console.log(arr) //[undefined, undefined] &#13;
    console.log(arr.length) //2 &#13;
</pre><p>On the other hand, if you pass only one non-numeric value, it becomes the only item in the array:</p><pre class="programlisting">    let arr = new Array("2") &#13;
    console.log(arr) //["2"] &#13;
    console.log(arr.length) //1 &#13;
</pre><p>This is not all. If you pass multiple values, they become elements of the array:</p><pre class="programlisting">    let arr = new Array(1,"2",{obj: "3"}) &#13;
    console.log(arr.length) //3 &#13;
</pre><p>So, clearly, there needs to be a better way to create arrays to avoid such confusion. ES6 introduces the <code class="literal">Array.of</code> method that works like the <code class="literal">Array()</code> constructor, but guarantees one standard behavior. <code class="literal">Array.of</code> creates an array from its arguments, regardless of their number and type:</p><pre class="programlisting">    let arr = Array.of(1,"2",{obj: "3"}) &#13;
    console.log(arr.length) //3 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Array.prototype methods</h2></div></div></div><p>ES6 introduces several interesting methods as part of array instances. These methods help with array iteration and searching elements in the array, both of which are very frequent and useful operations.</p><p>Here are the methods used for iterating over arrays:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Array.prototype.entries()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Array.prototype.values()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Array.prorotype.keys()</code></li></ul></div><p>All three methods return an iterator. This iterator can be used to create arrays using <code class="literal">Array.from()</code> and can be used in for loops for iteration:</p><pre class="programlisting">    let arr = ['a','b','c'] &#13;
    for (const index of arr.keys()){ &#13;
      console.log(index) //0 1 2 &#13;
    } &#13;
    for (const value of arr.values()){ &#13;
      console.log(value) //a b c &#13;
    } &#13;
    for (const [index,value] of arr.entries()){ &#13;
      console.log(index,value)  &#13;
    } &#13;
    //0 "a" &#13;
    //1 "b" &#13;
    //2 "c" &#13;
</pre><p>Similarly, there are new methods for searching within arrays. Looking for an element in an array usually involved iterating through the entire list and comparing them with a value, as there were no built-in methods for this. Though <code class="literal">indexOf()</code> and <code class="literal">lastIndexOf()</code> helped find a single value, there was no way to find elements based on complex conditions. With ES6, the following build-in methods help with <code class="literal">this</code> keyword.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Array.prototype.find</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Array.prototype.findIndex</code></li></ul></div><p>Both these methods accept two arguments-first is the <code class="literal">callback</code> function(which contains the predicate condition) and the second is an optional <code class="literal">this</code> keyword. The <code class="literal">callback</code> accepts three arguments: the array element, index of that element, and the array. The <code class="literal">callback</code> returns <code class="literal">true</code> if the element matches the predicate:</p><pre class="programlisting">    let numbers = [1,2,3,4,5,6,7,8,9,10]; &#13;
    console.log(numbers.find(n =&gt; n &gt; 5)); //6 &#13;
    console.log(numbers.findIndex(n =&gt; n &gt; 5)); //5 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec68"/>Function</h2></div></div></div><p>You already know that functions are a special data type. However, it turns out that there's more to it than that: functions are actually objects. There is a built-in <code class="literal">constructor</code> function called <code class="literal">Function()</code> that allows for an alternative (but not necessarily recommended) way to create a function.</p><p>The following example shows three ways to define a function:</p><pre class="programlisting">    &gt; function sum(a, b) { // function declaration &#13;
        return a + b; &#13;
      } &#13;
    &gt; sum(1, 2); &#13;
    3 &#13;
    &gt; var sum = function (a, b) { // function expression &#13;
        return a + b; &#13;
      }; &#13;
    &gt; sum(1, 2) &#13;
    3 &#13;
    &gt; var sum = new Function('a', 'b', 'return a + b;'); &#13;
    &gt; sum(1, 2) &#13;
    3 &#13;
</pre><p>When using the <code class="literal">Function()</code> constructor, you pass the parameter names first (as strings) and then the source code for the body of the function (again as a string). The JavaScript engine needs to evaluate the source code you pass and create the new function for you. This source code evaluation suffers from the same drawbacks as the <code class="literal">eval()</code> function, so defining functions using the <code class="literal">Function()</code> constructor should be avoided when possible.</p><p>If you use the <code class="literal">Function()</code> constructor to create functions that have lots of parameters, bear in mind that the parameters can be passed as a single comma-delimited list; so, for example, these are the same:</p><pre class="programlisting">    &gt; var first = new Function( &#13;
        'a, b, c, d', &#13;
        'return arguments;' &#13;
      ); &#13;
    &gt; first(1, 2, 3, 4); &#13;
           [1, 2, 3, 4] &#13;
    &gt; var second = new Function( &#13;
        'a, b, c', &#13;
        'd', &#13;
        'return arguments;' &#13;
       ); &#13;
    &gt; second(1, 2, 3, 4); &#13;
           [1, 2, 3, 4] &#13;
    &gt; var third = new Function( &#13;
        'a', &#13;
        'b', &#13;
        'c', &#13;
        'd', &#13;
        'return arguments;' &#13;
      ); &#13;
    &gt; third(1, 2, 3, 4);  &#13;
          [1, 2, 3, 4] &#13;
</pre><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Do not use the <code class="literal">Function()</code> constructor. As with <code class="literal">eval()</code> and <code class="literal">setTimeout()</code> (discussed later in the book), always try to stay away from passing JavaScript code as a string.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec35"/>Properties of function objects</h3></div></div></div><p>Like any other object, functions have a <code class="literal">constructor</code> property that contains a reference to the <code class="literal">Function()</code> constructor function. This is true no matter which syntax you used to create the function:</p><pre class="programlisting">    &gt; function myfunc(a) { &#13;
        return a;  &#13;
      } &#13;
    &gt; myfunc.constructor; &#13;
    function Function() { [native code] } &#13;
</pre><p>Functions also have a <code class="literal">length</code> property, which contains the number of formal parameters the function expects:</p><pre class="programlisting">    &gt; function myfunc(a, b, c) { &#13;
        return true; &#13;
      } &#13;
    &gt; myfunc.length; &#13;
       3 &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec36"/>Using the prototype property</h3></div></div></div><p>One of the most widely used properties of function objects is the <code class="literal">prototype</code> property. You'll see this property discussed in detail in the next chapter, but for now, let's just say:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">prototype</code> property of a <code class="literal">function</code> object points to another object</li><li class="listitem" style="list-style-type: disc">Its benefits shine only when you use this <code class="literal">function</code> as a constructor</li><li class="listitem" style="list-style-type: disc">All objects created with this <code class="literal">function</code> keep a reference to the <code class="literal">prototype</code> property and can use its properties as their own</li></ul></div><p>Let's look at a quick example to demonstrate the <code class="literal">prototype</code> property. Take a simple object that has a property name and a method <code class="literal">say()</code> method:</p><pre class="programlisting">    var ninja = { &#13;
      name: 'Ninja', &#13;
      say: function () { &#13;
        return 'I am a ' + this.name; &#13;
      } &#13;
    }; &#13;
</pre><p>When you create a function (even one without a body), you can verify that it automatically has a <code class="literal">prototype</code> property that points to a new object:</p><pre class="programlisting">    &gt; function F() {} &#13;
    &gt; typeof F.prototype; &#13;
    "object" &#13;
</pre><p>It gets interesting when you modify the <code class="literal">prototype</code> property. You can add properties to it, or you can replace the default object with any other object. Let's assign <code class="literal">ninja</code> to the <code class="literal">prototype</code>:</p><pre class="programlisting">    &gt; F.prototype = ninja; &#13;
</pre><p>Now, and here's where the magic happens, using the <code class="literal">F()</code>function as a <code class="literal">constructor</code> function, you can create a new object, <code class="literal">baby_ninja</code>, which will have access to the properties of <code class="literal">F.prototype</code> (which points to <code class="literal">ninja</code>) as if it were its own:</p><pre class="programlisting">    &gt; var baby_ninja = new F(); &#13;
    &gt; baby_ninja.name; &#13;
    "Ninja" &#13;
    &gt; baby_ninja.say(); &#13;
    "I am a Ninja" &#13;
</pre><p>There will be much more on this topic later. In fact, the next chapter is all about the <code class="literal">prototype</code> property.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec37"/>Methods of function objects</h3></div></div></div><p>Function objects, being a descendant of the top parent object, get the default methods such as <code class="literal">toString()</code>. When invoked on a function, the <code class="literal">toString()</code> method returns the source code of the function:</p><pre class="programlisting">    &gt; function myfunc(a, b, c) { &#13;
        return a + b + c; &#13;
      } &#13;
    &gt; myfunc.toString(); &#13;
    "function myfunc(a, b, c) { &#13;
      return a + b + c; &#13;
    }" &#13;
</pre><p>If you try to peek into the source code of the built-in functions, you'll get the <code class="literal">[native code]</code> string instead of the body of the function:</p><pre class="programlisting">    &gt; parseInt.toString(); &#13;
    "function parseInt() { [native code] }" &#13;
</pre><p>As you can see, you can use <code class="literal">toString()</code> to differentiate between native methods and developer-defined ones.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>The behavior of the function's <code class="literal">toString()</code> is environment dependent, and it differs among browsers in terms of spacing and new lines.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec38"/>Call and apply</h3></div></div></div><p>Function objects have <code class="literal">call()</code> and <code class="literal">apply()</code> methods. You can use them to invoke a function and pass any arguments to it.</p><p>These methods also allow your objects to borrow methods from other objects and invoke them as their own. This is an easy and powerful way to reuse code.</p><p>Let's say you have a <code class="literal">some_obj</code> object, which contains the <code class="literal">say()</code> method:</p><pre class="programlisting">    var some_obj = { &#13;
      name: 'Ninja', &#13;
      say: function (who) { &#13;
        return 'Haya ' + who + ', I am a ' + this.name; &#13;
      } &#13;
   }; &#13;
</pre><p>You can call the <code class="literal">say()</code> method, which internally uses <code class="literal">this.name</code> to gain access to its own name property:</p><pre class="programlisting">    &gt; some_obj.say('Dude'); &#13;
    "Haya Dude, I am a Ninja" &#13;
</pre><p>Now, let's create a simple object, <code class="literal">my_obj</code>, which only has a name property:</p><pre class="programlisting">    &gt; var my_obj = {name: 'Scripting guru'}; &#13;
</pre><p>The <code class="literal">my_obj</code> likes the <code class="literal">some_obj</code> object's <code class="literal">say()</code> method so much that it wants to invoke it as its own. This is possible using the <code class="literal">call()</code> method of the <code class="literal">say()</code> function object:</p><pre class="programlisting">    &gt; some_obj.say.call(my_obj, 'Dude'); &#13;
    "Haya Dude, I am a Scripting guru" &#13;
</pre><p>It worked! But what happened here? You invoked the <code class="literal">call()</code> method of the <code class="literal">say()</code> function object by passing two parameters-the <code class="literal">my_obj</code> object and the <code class="literal">Dude</code> string. The result is that when <code class="literal">say()</code> is invoked, the references to the this value that it contains point to <code class="literal">my_obj</code>. This way, <code class="literal">this.name</code> doesn't return <code class="literal">Ninja</code>, but <code class="literal">Scripting guru</code> instead.</p><p>If you have more parameters to pass when invoking the <code class="literal">call()</code> method, you just keep adding them:</p><pre class="programlisting">    some_obj.someMethod.call(my_obj, 'a', 'b', 'c'); &#13;
</pre><p>If you don't pass an object as a first parameter to <code class="literal">call()</code> or you pass <code class="literal">null</code>, the global object is assumed.</p><p>The method <code class="literal">apply()</code> works the same way as <code class="literal">call()</code>, but with the difference that all parameters you want to pass to the method of the other object are passed as an array. The following two lines are equivalent:</p><pre class="programlisting">    some_obj.someMethod.apply(my_obj, ['a', 'b', 'c']); &#13;
    some_obj.someMethod.call(my_obj, 'a', 'b', 'c'); &#13;
</pre><p>Continuing the previous example, you can use the following line of code:</p><pre class="programlisting">    &gt; some_obj.say.apply(my_obj, ['Dude']); &#13;
    "Haya Dude, I am a Scripting guru" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>The arguments object revisited</h3></div></div></div><p>In the previous chapter, you have seen how, from inside a function, you have access to something called <code class="literal">arguments</code>, which contains the values of all the parameters passed to the function:</p><pre class="programlisting">    &gt; function f() { &#13;
        return arguments; &#13;
      } &#13;
    &gt; f(1, 2, 3); &#13;
    [1, 2, 3] &#13;
</pre><p>The <code class="literal">arguments</code> looks like an array, but it is actually an array-like object. It resembles an array because it contains indexed elements and a <code class="literal">length</code> property. However, the similarity ends there, as arguments doesn't provide any of the array methods, such as <code class="literal">sort()</code> or <code class="literal">slice()</code>.</p><p>However, you can convert <code class="literal">arguments</code> to an array and benefit from all the array goodies. Here's what you can do, practicing your newly-learned <code class="literal">call()</code> method:</p><pre class="programlisting">    &gt; function f() { &#13;
        var args = [].slice.call(arguments); &#13;
        return args.reverse(); &#13;
      } &#13;
 &#13;
    &gt; f(1, 2, 3, 4); &#13;
     [4, 3, 2, 1] &#13;
</pre><p>As you can see, you can borrow <code class="literal">slice()</code> using <code class="literal">[].slice</code> or the more verbose <code class="literal">Array.prototype.slice</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Lexical this in arrow functions</h1></div></div></div><p>We discussed ES6 arrow functions and the syntax in detail in the last chapter. However, an important aspect of arrow functions is that they behave differently from normal functions. The difference is subtle but important. Arrow functions do not have their own value of <code class="literal">this</code>. The value of <code class="literal">this</code> in an arrow function is inherited from the enclosing (lexical) scope.</p><p>Functions have a special variable <code class="literal">this</code> that refers to the object via which the method was invoked. As the value of <code class="literal">this</code> is dynamically given based on the function invocation, it is sometimes called dynamic <code class="literal">this</code>. A function is executed in two scopes-lexical and dynamic. A lexical scope is a scope that surrounds the function scope, and the dynamic scope is the scope that called the function (usually an object)</p><p>In JavaScript, traditional functions play several roles. They are non-method functions (aka subroutines or functions), methods (part of an object), and constructors. When functions do the duty of a subroutine, there is a small problem due to dynamic <code class="literal">this</code>. As subroutines are not called on an object, the value of <code class="literal">this</code> is undefined in a strict mode and set to the global scope otherwise. This makes writing <code class="literal">callbacks</code> difficult. Consider the following example:</p><pre class="programlisting">    var greeter = { &#13;
      default: "Hello ", &#13;
      greet: function (names){ &#13;
        names.forEach(function(name) { &#13;
    console.log(this.default + name); //Cannot read property &#13;
      'default' of undefined &#13;
       }) &#13;
      } &#13;
    }     &#13;
    console.log(greeter.greet(['world', 'heaven'])) &#13;
</pre><p>We are passing a subroutine to the <code class="literal">forEach()</code> function on the <code class="literal">names</code> array. This subroutine has an undefined value of <code class="literal">this</code>, and unfortunately, it does not have access to <code class="literal">this</code> of the outer method <code class="literal">greet</code>. Clearly, this subroutine needs a lexical <code class="literal">this</code>,derive <code class="literal">this</code> from the surrounding scope of the <code class="literal">greet</code> method. Traditionally, to fix this limitation, we assign the lexical <code class="literal">this</code> into a variable, which is then accessible to the subroutine via closure.</p><p>We can fix the earlier example as follows:</p><pre class="programlisting">    var greeter = { &#13;
      default: "Hello ", &#13;
      greet: function (names){ &#13;
        let that = this &#13;
        names.forEach(function(name) { &#13;
          console.log(that.default + name);  &#13;
       }) &#13;
      } &#13;
    }     &#13;
    console.log(greeter.greet(['world', 'heaven'])) &#13;
</pre><p>This is a reasonable hack to simulate lexical <code class="literal">this</code>. However, the problem with such hacks is that it creates too much noise for the person writing or reviewing <code class="literal">this</code> code. First, you have to understand the quirk of the behavior of <code class="literal">this</code>. Even if you understand <code class="literal">this</code> behavior well, you will need to continuously remain on the lookout for such hacks in your code.</p><p>Arrow functions have lexical <code class="literal">this</code> and do not require such a hack. They are more suited as subroutines because of <code class="literal">this</code>. We can covert the preceding example to use lexical <code class="literal">this</code> using the arrow function:</p><pre class="programlisting">    var greeter = { &#13;
      default: "Hello ", &#13;
      greet: function (names){ &#13;
        names.forEach(name=&gt; { &#13;
          console.log(this.default + name);   //lexical 'this' &#13;
           available for this subroutine &#13;
       }) &#13;
     } &#13;
    }     &#13;
    console.log(greeter.greet(['world', 'heaven'])) &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch04lvl2sec69"/>Inferring object types</h2></div></div></div><p>You can see that you have this array-like arguments object looking so much like an array object. How can you reliably tell the difference between the two? Additionally, <code class="literal">typeof</code> returns an object when used with arrays. Therefore, how can you tell the difference between an object and an array?</p><p>The silver bullet is the <code class="literal">Object</code> object's <code class="literal">toString()</code> method. It gives you the internal class name used to create a given object:</p><pre class="programlisting">    &gt; Object.prototype.toString.call({}); &#13;
    "[object Object]" &#13;
    &gt; Object.prototype.toString.call([]); &#13;
    "[object Array]" &#13;
</pre><p>You have to call the original <code class="literal">toString()</code> method as defined in the prototype of the <code class="literal">Object</code> constructor. Otherwise, if you call the <code class="literal">Array</code> function's <code class="literal">toString()</code>, it will give you a different result, as it's been overridden for the specific purposes of the array objects:</p><pre class="programlisting">    &gt; [1, 2, 3].toString(); &#13;
    "1,2,3" &#13;
</pre><p>The preceding code is same as:</p><pre class="programlisting">    &gt; Array.prototype.toString.call([1, 2, 3]); &#13;
    "1,2,3" &#13;
</pre><p>Let's have some more fun with <code class="literal">toString()</code>. Make a handy reference to save typing:</p><pre class="programlisting">    &gt; var toStr = Object.prototype.toString; &#13;
</pre><p>The following example shows how we can differentiate between an array and the array-like object <code class="literal">arguments</code>:</p><pre class="programlisting">    &gt; (function () { &#13;
        return toStr.call(arguments); &#13;
      }()); &#13;
    "[object Arguments]" &#13;
</pre><p>You can even inspect DOM elements:</p><pre class="programlisting">    &gt; toStr.call(document.body); &#13;
    "[object HTMLBodyElement]" &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec70"/>Boolean</h2></div></div></div><p>Your journey through the built-in objects in JavaScript continues, and the next three are fairly straightforward. They are Boolean, number, and string. They merely wrap the primitive data types.</p><p>You already know a lot about Booleans from <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <em>Primitive Data Types, Arrays, Loops, and Conditions</em>. Now, let's meet the <code class="literal">Boolean()</code> constructor:</p><pre class="programlisting">    &gt; var b = new Boolean(); &#13;
</pre><p>It's important to note that this creates a new object, <code class="literal">b</code>, and not a primitive Boolean value. To get the primitive value, you can call the <code class="literal">valueOf()</code> method (inherited from <code class="literal">Object</code> class and customized):</p><pre class="programlisting">    &gt; var b = new Boolean(); &#13;
    &gt; typeof b; &#13;
    "object" &#13;
    &gt; typeof b.valueOf(); &#13;
    "boolean" &#13;
    &gt; b.valueOf(); &#13;
    false &#13;
</pre><p>Overall, objects created with the <code class="literal">Boolean()</code> constructor are not too useful, as they don't provide any methods or properties other than the inherited ones.</p><p>The <code class="literal">Boolean()</code> function, when called as a normal function without <code class="literal">new</code>, converts non-Booleans to Booleans (which is like using a double negation <code class="literal">!!</code>value):</p><pre class="programlisting">    &gt; Boolean("test"); &#13;
    true &#13;
    &gt; Boolean(""); &#13;
    false &#13;
    &gt; Boolean({}); &#13;
    true &#13;
</pre><p>Apart from the six <code class="literal">false</code> values, everything else is <code class="literal">true</code> in JavaScript, including all objects. This also means that all Boolean objects created with <code class="literal">new Boolean()</code> are also <code class="literal">true</code>, as they are objects:</p><pre class="programlisting">    &gt; Boolean(new Boolean(false)); &#13;
    true &#13;
</pre><p>This can be confusing, and since Boolean objects don't offer any special methods, it's best to just stick with regular primitive Boolean values.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec71"/>Number</h2></div></div></div><p>Similar to <code class="literal">Boolean()</code>, the <code class="literal">Number()</code> function can be used as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">constructor</code> function (with <code class="literal">new</code>) to create objects.</li><li class="listitem" style="list-style-type: disc">A normal function in order to try to convert any value to a number. This is similar to the use of <code class="literal">parseInt()</code> or <code class="literal">parseFloat()</code>:<pre class="programlisting">    &gt; var n = Number('12.12'); &#13;
    &gt; n; &#13;
    12.12 &#13;
    &gt; typeof n; &#13;
    "number" &#13;
    &gt; var n = new Number('12.12'); &#13;
    &gt; typeof n; &#13;
    "object" &#13;
</pre></li></ul></div><p>As functions are objects, they can also have properties. The <code class="literal">Number()</code> function has constant built-in properties that you cannot modify:</p><pre class="programlisting">    &gt; Number.MAX_VALUE; &#13;
    1.7976931348623157e+308 &#13;
    &gt; Number.MIN_VALUE; &#13;
    5e-324 &#13;
    &gt; Number.POSITIVE_INFINITY; &#13;
    Infinity &#13;
    &gt; Number.NEGATIVE_INFINITY; &#13;
    -Infinity &#13;
    &gt; Number.NaN; &#13;
    NaN &#13;
</pre><p>The number objects provide three methods-<code class="literal">toFixed()</code>, <code class="literal">toPrecision()</code>, and <code class="literal">toExponential()</code>(see <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <em>Built-in Objects</em>, for more details):</p><pre class="programlisting">    &gt; var n = new Number(123.456); &#13;
    &gt; n.toFixed(1); &#13;
    "123.5" &#13;
</pre><p>Note that you can use these methods without explicitly creating a <code class="literal">Number</code> object first. In such cases, the <code class="literal">Number</code> object is created (and destroyed) for you behind the scenes:</p><pre class="programlisting">    &gt; (12345).toExponential(); &#13;
    "1.2345e+4" &#13;
</pre><p>Like all objects, the <code class="literal">Number</code> object also provide the <code class="literal">toString()</code> method. When used with <code class="literal">Number</code> object, this method accepts an optional radix parameter (10 being the default):</p><pre class="programlisting">    &gt; var n = new Number(255); &#13;
    &gt; n.toString(); &#13;
    "255" &#13;
    &gt; n.toString(10); &#13;
    "255" &#13;
    &gt; n.toString(16); &#13;
    "ff" &#13;
    &gt; (3).toString(2); &#13;
    "11" &#13;
    &gt; (3).toString(10); &#13;
    "3" &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec72"/>String</h2></div></div></div><p>You can use the <code class="literal">String()</code> constructor function to create string objects. String objects provide convenient methods for text manipulation.</p><p>Here's an example that shows the difference between a <code class="literal">String</code> object and a <code class="literal">primitive</code> string data type:</p><pre class="programlisting">    &gt; var primitive = 'Hello'; &#13;
    &gt; typeof primitive; &#13;
    "string" &#13;
    &gt; var obj = new String('world'); &#13;
    &gt; typeof obj; &#13;
    "object" &#13;
</pre><p>A <code class="literal">String</code> object is similar to an array of characters. String objects have an indexed property for each character (introduced in ES5, but long supported in many browsers, except old IEs), and they also have a <code class="literal">length</code> property.</p><pre class="programlisting">    &gt; obj[0]; &#13;
    "w" &#13;
    &gt; obj[4]; &#13;
    "d" &#13;
    &gt; obj.length; &#13;
    5 &#13;
</pre><p>To extract the <code class="literal">primitive</code> value from the <code class="literal">String</code> object, you can use the <code class="literal">valueOf()</code> or <code class="literal">toString()</code> method inherited from <code class="literal">Object</code>. You'll probably never need to do this, as <code class="literal">toString()</code> is called behind the scenes if you use an object in a <code class="literal">primitive</code> string context:</p><pre class="programlisting">    &gt; obj.valueOf(); &#13;
    "world" &#13;
    &gt; obj.toString(); &#13;
    "world" &#13;
    &gt; obj + ""; &#13;
    "world" &#13;
</pre><p>The <code class="literal">primitive</code> strings are not objects, so they don't have any methods or properties. However, JavaScript also offers you the syntax to treat <code class="literal">primitive</code> strings as objects (just like you already saw with primitive numbers).</p><p>In the following example, <code class="literal">String</code> objects are being created (and then destroyed) behind the scenes every time you treat a <code class="literal">primitive</code> string as if it were an object:</p><pre class="programlisting">    &gt; "potato".length; &#13;
    6 &#13;
    &gt; "tomato"[0]; &#13;
    "t" &#13;
    &gt; "potatoes"["potatoes".length - 1]; &#13;
    "s" &#13;
</pre><p>Here is one final example to illustrate the difference between a <code class="literal">primitive</code> string and a <code class="literal">String</code> object. In this example, we are converting them to Boolean. The empty string is a falsy value, but any string object is truthy (because all objects are truthy):</p><pre class="programlisting">    &gt; Boolean(""); &#13;
    false &#13;
    &gt; Boolean(new String("")); &#13;
    true &#13;
</pre><p>Similar to <code class="literal">Number()</code> and <code class="literal">Boolean()</code>, if you use the <code class="literal">String()</code> function without <code class="literal">new</code>, it converts the parameter to a primitive:</p><pre class="programlisting">    &gt; String(1); &#13;
    "1" &#13;
</pre><p>If you pass an object to <code class="literal">String()</code>, this object's <code class="literal">toString()</code> method will be called first:</p><pre class="programlisting">    &gt; String({p: 1}); &#13;
       "[object Object]" &#13;
    &gt; String([1, 2, 3]); &#13;
       "1,2,3" &#13;
    &gt; String([1, 2, 3]) === [1, 2, 3].toString(); &#13;
       true &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>A few methods of string objects</h3></div></div></div><p>Let's experiment with a few of the methods you can call on string objects (see <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <em>Built-in Objects</em>, for the complete list).</p><p>Start off by creating a string object:</p><pre class="programlisting">    &gt; var s = new String("Couch potato"); &#13;
</pre><p>The <code class="literal">toUpperCase()</code> and <code class="literal">toLowerCase()</code> methods transform the capitalization of the string:</p><pre class="programlisting">    &gt; s.toUpperCase(); &#13;
    "COUCH POTATO" &#13;
    &gt; s.toLowerCase(); &#13;
    "couch potato" &#13;
</pre><p>The <code class="literal">charAt()</code> method tells you the character found at the position you specify, which is the same as using square brackets (treating a string as an array of characters):</p><pre class="programlisting">    &gt; s.charAt(0); &#13;
    "C" &#13;
    &gt; s[0]; &#13;
    "C" &#13;
</pre><p>If you pass a non-existent position to <code class="literal">charAt()</code>, you get an empty string:</p><pre class="programlisting">    &gt; s.charAt(101); &#13;
    "" &#13;
</pre><p>The <code class="literal">indexOf()</code> method allows you to search within a string. If there is a match, the method returns the position at which the first match is found. The position count starts at 0, so the second character in <code class="literal">Couch</code> is <code class="literal">o</code> at position 1:</p><pre class="programlisting">    &gt; s.indexOf('o'); &#13;
    1 &#13;
</pre><p>You can optionally specify where (at what position) to start the search. The following finds the second <code class="literal">o</code>, because <code class="literal">indexOf()</code> is instructed to start the search at position 2:</p><pre class="programlisting">    &gt; s.indexOf('o', 2); &#13;
    7 &#13;
</pre><p>The <code class="literal">lastIndexOf()</code>starts the search from the end of the string (but the position of the match is still counted from the beginning):</p><pre class="programlisting">    &gt; s.lastIndexOf('o'); &#13;
    11 &#13;
</pre><p>You can search , not only for characters, but also for strings, and the search is case sensitive:</p><pre class="programlisting">    &gt; s.indexOf('Couch'); &#13;
    0 &#13;
</pre><p>If there is no match, the function returns position <code class="literal">-1</code>:</p><pre class="programlisting">    &gt; s.indexOf('couch'); &#13;
    -1 &#13;
</pre><p>For a case-insensitive search, you can transform the string to lowercase first and then search:</p><pre class="programlisting">    &gt; s.toLowerCase().indexOf('couch'.toLowerCase()); &#13;
    0 &#13;
</pre><p>If you get <code class="literal">0</code>, this means that the matching part of the string starts at position <code class="literal">0</code>. This can cause confusion when you check with <code class="literal">if</code>, because <code class="literal">if</code> converts the position <code class="literal">0</code> to a Boolean <code class="literal">false</code> value. So, while this is syntactically correct, it is logically wrong:</p><pre class="programlisting">    if (s.indexOf('Couch')) {...} &#13;
</pre><p>The proper way to check whether a string contains another string is to compare the result of <code class="literal">indexOf()</code> to the number <code class="literal">-1</code>:</p><pre class="programlisting">    if (s.indexOf('Couch') !== -1) {...} &#13;
</pre><p>The <code class="literal">slice()</code>and <code class="literal">substring()</code> return a piece of the string when you specify the start and end positions:</p><pre class="programlisting">    &gt; s.slice(1, 5); &#13;
    "ouch" &#13;
    &gt; s.substring(1, 5); &#13;
    "ouch" &#13;
</pre><p>Note that the second parameter you pass is the end position, not the length of the piece. The difference between these two methods is how they treat negative arguments. <code class="literal">substring()</code> treats them as zeros, while <code class="literal">slice()</code> adds them to the length of the string. So, if you pass parameters <code class="literal">(1, -1)</code> to both methods, it's the same as <code class="literal">substring(1,0)</code> and <code class="literal">slice(1,s.length-1)</code>:</p><pre class="programlisting">    &gt; s.slice(1, -1); &#13;
    "ouch potat" &#13;
    &gt; s.substring(1, -1); &#13;
    "C" &#13;
</pre><p>There's also the non-standard method <code class="literal">substr()</code>, but you should try to avoid it in favor of <code class="literal">substring()</code>.</p><p>The <code class="literal">split()</code> method creates an array from the string using another string that you pass as a separator:</p><pre class="programlisting">    &gt; s.split(" "); &#13;
    ["Couch", "potato"] &#13;
</pre><p>The <code class="literal">split()</code> method is the opposite of the <code class="literal">join()</code> method, which creates a string from an array:</p><pre class="programlisting">    &gt; s.split(' ').join(' '); &#13;
    "Couch potato" &#13;
</pre><p>The <code class="literal">concat()</code> glues strings together, in the same way in which the <code class="literal">+</code> operator does for <code class="literal">primitive</code> strings:</p><pre class="programlisting">    &gt; s.concat("es"); &#13;
    "Couch potatoes" &#13;
</pre><p>Note that while some of the preceding methods discussed return new <code class="literal">primitive</code> strings, none of them modify the source string. After all the method calls listed previously, the initial string is still the same:</p><pre class="programlisting">    &gt; s.valueOf(); &#13;
    "Couch potato" &#13;
</pre><p>You have seen how to use <code class="literal">indexOf()</code> and <code class="literal">lastIndexOf()</code> to search within strings, but there are more powerful methods (<code class="literal">search()</code>, <code class="literal">match()</code>, and <code class="literal">replace()</code>) that take regular expressions as parameters. You'll see these later in the <code class="literal">RegExp()</code> constructor function.</p><p>At this point, you're done with all of the data wrapper objects, so let's move on to the utility objects <code class="literal">Math</code>, <code class="literal">Date</code>, and <code class="literal">RegExp</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec73"/>Math</h2></div></div></div><p>
<code class="literal">Math</code> is a little different from the other built-in global objects you have seen previously. It's not a function, and, therefore, cannot be used with <code class="literal">new</code> to create objects. <code class="literal">Math</code> is a built-in global object that provides a number of methods and properties for mathematical operations.</p><p>The <code class="literal">Math</code> object's properties are constants, so you can't change their values. Their names are all in uppercase to emphasize the difference between them and a normal property (similar to the constant properties of the <code class="literal">Number()</code> constructor). Let's see a few of these constant properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The constant PI:<pre class="programlisting">    &gt; Math.PI; &#13;
      3.141592653589793 &#13;
</pre></li><li class="listitem" style="list-style-type: disc">Square root of 2:<pre class="programlisting">    &gt; Math.SQRT2; &#13;
      1.4142135623730951 &#13;
</pre></li><li class="listitem" style="list-style-type: disc">Euler's constant:<pre class="programlisting">    &gt; Math.E; &#13;
      2.718281828459045 &#13;
</pre></li><li class="listitem" style="list-style-type: disc">Natural logarithm of 2:<pre class="programlisting">    &gt; Math.LN2; &#13;
      0.6931471805599453 &#13;
</pre></li><li class="listitem" style="list-style-type: disc">Natural logarithm of 10:<pre class="programlisting">    &gt; Math.LN10; &#13;
      2.302585092994046 &#13;
</pre></li></ul></div><p>Now, you know how to impress your friends the next time they (for whatever reason) start wondering, "What was the value of <em>e</em>? I can't remember." Just type <code class="literal">Math.E</code> in the console and you have the answer.</p><p>Let's take a look at some of the methods the <code class="literal">Math</code> object provides (the full list is in <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <em>Built-in Objects</em>).</p><p>Generating random numbers:</p><pre class="programlisting">    &gt; Math.random(); &#13;
    0.3649461670235814 &#13;
</pre><p>The <code class="literal">random()</code> function returns a number between <code class="literal">0</code> and <code class="literal">1</code>, so if you want a number between, let's say, <code class="literal">0</code> and <code class="literal">100</code>, you can use the following line of code:</p><pre class="programlisting">    &gt; 100 * Math.random(); &#13;
</pre><p>For numbers between any two values, use the formula <code class="literal">((max-min) * Math.random())+min</code>. For example, a random number between 2 and 10 can be obtained using the formula as follows:</p><pre class="programlisting">    &gt; 8 * Math.random() + 2; &#13;
    9.175650496668485 &#13;
</pre><p>If you only need an integer, you can use one of the following rounding methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">floor()</code> to round down</li><li class="listitem" style="list-style-type: disc"><code class="literal">ceil()</code> to round up</li><li class="listitem" style="list-style-type: disc"><code class="literal">round()</code> to round to the nearest</li></ul></div><p>For example, to get either <code class="literal">0</code> or <code class="literal">1</code>, you can use the following line of code:</p><pre class="programlisting">    &gt; Math.round(Math.random()); &#13;
</pre><p>If you need the lowest or the highest among a set of numbers, you have the <code class="literal">min()</code> and <code class="literal">max()</code> methods. So, if you have a form on a page that asks for a valid month, you can make sure that you always work with sane data (a value between <code class="literal">1</code> and <code class="literal">12</code>):</p><pre class="programlisting">    &gt; Math.min(Math.max(1, input), 12); &#13;
</pre><p>The <code class="literal">Math</code> object also provides the ability to perform mathematical operations for which you don't have a designated operator. This means that you can raise to a power using <code class="literal">pow()</code>, find the square root using <code class="literal">sqrt()</code>, and perform all the trigonometric operations-<code class="literal">sin()</code>, <code class="literal">cos()</code>, <code class="literal">atan()</code>, and so on.</p><p>For example, to calculate <code class="literal">2</code> to the power of <code class="literal">8</code>, you can use the following line of code:</p><pre class="programlisting">    &gt; Math.pow(2, 8); &#13;
    256 &#13;
</pre><p>To calculate the square root of <code class="literal">9</code>, you can use the following line of code:</p><pre class="programlisting">    &gt; Math.sqrt(9); &#13;
    3 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec74"/>Date</h2></div></div></div><p>
<code class="literal">Date()</code> is a constructor function that creates date objects. You can create a new object by passing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Nothing (defaults to today's date)</li><li class="listitem" style="list-style-type: disc">A date-like string</li><li class="listitem" style="list-style-type: disc">Separate values for day, month, time, and so on</li><li class="listitem" style="list-style-type: disc">A timestamp</li></ul></div><p>Here is an object instantiated with today's date/time (using the browser's timezone):</p><pre class="programlisting">    &gt; new Date(); &#13;
    Wed Feb 27 2013 23:49:28 GMT-0800 (PST) &#13;
</pre><p>The console displays the result of the <code class="literal">toString()</code> method called on the <code class="literal">Date</code> object, so you get this long string <code class="literal">Wed Feb 27 2013 23:49:28 GMT-0800 (PST)</code> as a representation of the date object.</p><p>Here are a few examples of using strings to initialize a <code class="literal">Date</code> object. Note how many different formats you can use to specify the date:</p><pre class="programlisting">    &gt; new Date('2015 11 12'); &#13;
    Thu Nov 12 2015 00:00:00 GMT-0800 (PST) &#13;
    &gt; new Date('1 1 2016'); &#13;
    Fri Jan 01 2016 00:00:00 GMT-0800 (PST) &#13;
    &gt; new Date('1 mar 2016 5:30'); &#13;
    Tue Mar 01 2016 05:30:00 GMT-0800 (PST) &#13;
</pre><p>The <code class="literal">Date</code> constructor can figure out a date from different strings, but this is not really a reliable way of defining a precise date, for example, when passing user input to the constructor. A better way is to pass numeric values to the <code class="literal">Date()</code> constructor representing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Year</li><li class="listitem" style="list-style-type: disc">Month - 0 (January) to 11 (December)</li><li class="listitem" style="list-style-type: disc">Day - 1 to 31</li><li class="listitem" style="list-style-type: disc">Hour - 0 to 23</li><li class="listitem" style="list-style-type: disc">Minutes - 0 to 59</li><li class="listitem" style="list-style-type: disc">Seconds - 0 to 59</li><li class="listitem" style="list-style-type: disc">Milliseconds - 0 to 999</li></ul></div><p>Let's look at some examples.</p><p>Passing all the parameters by writing the following line of code:</p><pre class="programlisting">    &gt; new Date(2015, 0, 1, 17, 05, 03, 120); &#13;
    Tue Jan 01 2015 17:05:03 GMT-0800 (PST) &#13;
</pre><p>Passing date and hour by writing the following line of code:</p><pre class="programlisting">    &gt; new Date(2015, 0, 1, 17); &#13;
    Tue Jan 01 2015 17:00:00 GMT-0800 (PST) &#13;
</pre><p>Watch out for the fact that the month starts from 0, so 1 is February:</p><pre class="programlisting">    &gt; new Date(2016, 1, 28); &#13;
    Sun Feb 28 2016 00:00:00 GMT-0800 (PST) &#13;
</pre><p>If you pass a value greater than the one allowed, your date overflows forward. As there's no February 30 in 2016, this means it has to be March 1 (2016 is a leap year):</p><pre class="programlisting">    &gt; new Date(2016, 1, 29); &#13;
    Mon Feb 29 2016 00:00:00 GMT-0800 (PST) &#13;
    &gt; new Date(2016, 1, 30); &#13;
    Tue Mar 01 2016 00:00:00 GMT-0800 (PST) &#13;
</pre><p>Similarly, December 32 becomes January 1 of the next year:</p><pre class="programlisting">    &gt; new Date(2012, 11, 31); &#13;
    Mon Dec 31 2012 00:00:00 GMT-0800 (PST) &#13;
    &gt; new Date(2012, 11, 32); &#13;
    Tue Jan 01 2013 00:00:00 GMT-0800 (PST) &#13;
</pre><p>Finally, a date object can be initialized with a timestamp (the number of milliseconds since the UNIX epoch, where 0 milliseconds is January 1, 1970):</p><pre class="programlisting">    &gt; new Date(1357027200000); &#13;
    Tue Jan 01 2013 00:00:00 GMT-0800 (PST) &#13;
</pre><p>If you call <code class="literal">Date()</code> without <code class="literal">new</code>, you get a string representing the current date, whether or not you pass any parameters. The following example gives the current time (current when this example was run):</p><pre class="programlisting">    &gt; Date(); &#13;
    Wed Feb 27 2013 23:51:46 GMT-0800 (PST) &#13;
    &gt; Date(1, 2, 3, "it doesn't matter"); &#13;
    Wed Feb 27 2013 23:51:52 GMT-0800 (PST) &#13;
    &gt; typeof Date(); &#13;
    "string" &#13;
    &gt; typeof new Date(); &#13;
    "object" &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>Methods to work with date objects</h3></div></div></div><p>Once you've created a date object, there are lots of methods you can call on that object. Most of the methods can be divided into <code class="literal">set*()</code> and <code class="literal">get*()</code> methods, for example, <code class="literal">getMonth()</code>, <code class="literal">setMonth()</code>, <code class="literal">getHours()</code>, <code class="literal">setHours()</code>, and so on. Let's see some examples.</p><p>Creating a date object by writing the following code:</p><pre class="programlisting">    &gt; var d = new Date(2015, 1, 1); &#13;
    &gt; d.toString(); &#13;
    Sun Feb 01 2015 00:00:00 GMT-0800 (PST) &#13;
</pre><p>Setting the month to March (months start from 0):</p><pre class="programlisting">    &gt; d.setMonth(2); &#13;
    1425196800000 &#13;
    &gt; d.toString(); &#13;
    Sun Mar 01 2015 00:00:00 GMT-0800 (PST) &#13;
</pre><p>Getting the month by writing the following code:</p><pre class="programlisting">    &gt; d.getMonth(); &#13;
    2 &#13;
</pre><p>In addition to all the methods of date objects, there are also two methods (plus one more added in ES5) that are properties of the <code class="literal">Date()</code> function/object. These do not need a <code class="literal">date</code> object; they work just like the <code class="literal">Math</code> object methods. In class-based languages, such methods would be called static because they don't require an instance.</p><p>The <code class="literal">Date.parse()</code> method takes a string and returns a timestamp:</p><pre class="programlisting">    &gt; Date.parse('Jan 11, 2018'); &#13;
    1515657600000 &#13;
</pre><p>The <code class="literal">Date.UTC()</code> method takes all the parameters for year, month, day, and so on, and produces a timestamp in <strong>Universal Time </strong>(<strong>UT</strong>):</p><pre class="programlisting">    &gt; Date.UTC(2018, 0, 11); &#13;
    1515628800000 &#13;
</pre><p>As the <code class="literal">new Date()</code> constructor can accept timestamps, you can pass the result of <code class="literal">Date.UTC()</code> to it. Using the following example, you can see how <code class="literal">UTC()</code> works with Universal Time, while <code class="literal">new Date()</code> works with local time:</p><pre class="programlisting">    &gt; new Date(Date.UTC(2018, 0, 11)); &#13;
    Wed Jan 10 2018 16:00:00 GMT-0800 (PST) &#13;
    &gt; new Date(2018, 0, 11); &#13;
    Thu Jan 11 2018 00:00:00 GMT-0800 (PST) &#13;
</pre><p>The ES5 addition to the <code class="literal">Date</code> constructor is the <code class="literal">now()</code>method, which returns the current timestamp. It provides a more convenient way to get the timestamp instead of using the <code class="literal">getTime()</code> method on a <code class="literal">Date</code> object as you would in ES3:</p><pre class="programlisting">    &gt; Date.now(); &#13;
    1362038353044 &#13;
    &gt; Date.now() === new Date().getTime(); &#13;
    true &#13;
</pre><p>You can think of the internal representation of the date being an integer timestamp and all other methods being sugar on top of it. So, it makes sense that <code class="literal">valueOf()</code> is a timestamp:</p><pre class="programlisting">    &gt; new Date().valueOf(); &#13;
    1362418306432 &#13;
</pre><p>Also, dates cast to integers with the <code class="literal">+</code> operator:</p><pre class="programlisting">    &gt; +new Date(); &#13;
    1362418318311 &#13;
</pre><div><div><div><div><h4 class="title"><a id="ch04lvl4sec4"/>Calculating birthdays</h4></div></div></div><p>Let's look at one final example of working with <code class="literal">Date</code> objects. I was curious about which day my birthday falls on in 2016:</p><pre class="programlisting">    &gt; var d = new Date(2016, 5, 20); &#13;
    &gt; d.getDay(); &#13;
    1 &#13;
</pre><p>Starting the count from 0 (Sunday), 1 means Monday. Is that so?</p><pre class="programlisting">    &gt; d.toDateString(); &#13;
    "Mon Jun 20 2016" &#13;
</pre><p>ok, good to know, but Monday is not necessarily the best day for a party. So, how about a loop that shows how many times June 20 is a Friday from year 2016 to year 3016, or better yet, let's see the distribution of all the days of the week. After all, with all the progress in DNA hacking, we're all going to be alive and kicking in 3016.</p><p>First, let's initialize an array with seven elements, one for each day of the week. These will be used as counters. Then, as a loop goes up to 3016, let's increment the counters:</p><pre class="programlisting">    var stats = [0, 0, 0, 0, 0, 0, 0]; &#13;
</pre><p>Here is the loop:</p><pre class="programlisting">    for (var i = 2016; i &lt; 3016; i++) { &#13;
       stats[new Date(i, 5, 20).getDay()]++; &#13;
    } &#13;
</pre><p>Here is the result:</p><pre class="programlisting">    &gt; stats; &#13;
    [140, 146, 140, 145, 142, 142, 145] &#13;
</pre><p>142 Fridays and 145 Saturdays. Woo-hoo!</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec75"/>RegExp</h2></div></div></div><p>Regular expressions provide a powerful way to search and manipulate text. Different languages have different implementations (think dialects) of the regular expression syntax. JavaScript uses the Perl 5 syntax.</p><p>Instead of saying regular expression, people often shorten it to regex or regexp.</p><p>A regular expression consists of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A pattern you use to match text</li><li class="listitem" style="list-style-type: disc">Zero or more modifiers (also called flags) that provide more instructions on how the pattern should be used</li></ul></div><p>The pattern can be as simple as literal text to be matched verbatim, but that's rare, and in such cases you're better off using <code class="literal">indexOf()</code>. Most of the time, the pattern is more complex and could be difficult to understand. Mastering regular expressions' patterns is a large topic, which won't be discussed in full detail here. Instead, you'll see what JavaScript provides in terms of syntax, objects, and methods in order to support the use of regular expressions. You can also refer to <a class="link" href="apd.html" title="Appendix D. Regular Expressions">Appendix D</a>, <em>Regular Expressions</em>, to help you when you're writing patterns.</p><p>JavaScript provides the <code class="literal">RegExp()</code> constructor, which allows you to create regular expression objects:</p><pre class="programlisting">    &gt; var re = new RegExp("j.*t");  &#13;
</pre><p>There is also the more convenient <strong>regexp literal notation</strong>:</p><pre class="programlisting">    &gt; var re = /j.*t/; &#13;
</pre><p>In the preceding example,<code class="literal"> j.*t</code> is the regular expression pattern. It means <code class="literal">"</code> matches any string that starts with <code class="literal">j</code>, ends with <code class="literal">t</code>, and has zero or more characters in between <code class="literal">"</code>. The asterisk (<code class="literal">*</code>) means <code class="literal">"</code> zero or more of the preceding, <code class="literal">"</code> and the dot (<code class="literal">.</code>) means <code class="literal">"</code> any character <code class="literal">"</code>. The pattern needs to be quoted when passed to a <code class="literal">RegExp()</code> constructor.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec42"/>Properties of RegExp objects</h3></div></div></div><p>Regular expression objects have the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">global</code>: If this property is <code class="literal">false</code>, which is the default, the search stops when the first match is found. Set this to <code class="literal">true</code> if you want all matches.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ignoreCase</code>: When the match is case insensitive, this property defaults to <code class="literal">false</code> (meaning the default is a case-sensitive match).</li><li class="listitem" style="list-style-type: disc"><code class="literal">multiline</code>: Search matches that may span over more than one line default to <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">lastIndex</code>: The position at which to start the search; this defaults to <code class="literal">0</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">source</code>: This contains the <code class="literal">RegExp</code> pattern.</li></ul></div><p>None of these properties, except for <code class="literal">lastIndex</code>, can be changed once the object has been created.</p><p>The first three items in the preceding list represent the regex modifiers. If you create a regex object using the constructor, you can pass any combination of the following characters as a second parameter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">g</code> for <code class="literal">global</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">i</code> for <code class="literal">ignoreCase</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">m</code> for <code class="literal">multiline</code></li></ul></div><p>These letters can be in any order. If a letter is passed, the corresponding modifier property is set to <code class="literal">true</code>. In the following example, all modifiers are set to <code class="literal">true</code>:</p><pre class="programlisting">    &gt; var re = new RegExp('j.*t', 'gmi'); &#13;
</pre><p>Let's verify:</p><pre class="programlisting">    &gt; re.global; &#13;
    true &#13;
</pre><p>Once set, the modifier cannot be changed:</p><pre class="programlisting">    &gt; re.global = false; &#13;
    &gt; re.global; &#13;
    true &#13;
</pre><p>To set any modifiers using the regex literal, you add them after the closing slash:</p><pre class="programlisting">    &gt; var re = /j.*t/ig; &#13;
    &gt; re.global; &#13;
    true &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Methods of RegExp objects</h3></div></div></div><p>Regex objects provide two methods you can use to find matches-<code class="literal">test()</code> and <code class="literal">exec()</code>. They both accept a string parameter. The <code class="literal">test()</code> method returns a Boolean (<code class="literal">true</code> when there's a match, <code class="literal">false</code> otherwise), while <code class="literal">exec()</code> returns an array of matched strings. Obviously, <code class="literal">exec()</code> is doing more work, so use <code class="literal">test()</code> only if you really need to do something with the matches. People often use regular expressions to validate data. In this case, <code class="literal">test()</code> should be enough.</p><p>In the following example, there is no match because of the capital <code class="literal">J</code>:</p><pre class="programlisting">    &gt; /j.*t/.test("Javascript"); &#13;
    false &#13;
</pre><p>A case-insensitive test gives a positive result:</p><pre class="programlisting">    &gt; /j.*t/i.test("Javascript"); &#13;
    true &#13;
</pre><p>The same test using <code class="literal">exec()</code> returns an array, and you can access the first element as shown here:</p><pre class="programlisting">    &gt; /j.*t/i.exec("Javascript")[0]; &#13;
    "Javascript" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>String methods that accept regular expressions as arguments</h3></div></div></div><p>Previously in this chapter, you learned about string objects and how you can use the <code class="literal">indexOf()</code> and <code class="literal">lastIndexOf()</code> methods to search within text. Using these methods, you can only specify literal string patterns to search. A more powerful solution would be to use regular expressions to find text. String objects offer you this ability.</p><p>String objects provide the following methods that accept regular expression objects as parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">match()</code>: Returns an array of matches</li><li class="listitem" style="list-style-type: disc"><code class="literal">search()</code>: Returns the position of the first match</li><li class="listitem" style="list-style-type: disc"><code class="literal">replace()</code>: Allows you to substitute matched text with another string</li><li class="listitem" style="list-style-type: disc"><code class="literal">split()</code>: Accepts a regexp when splitting a string into array elements</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>search() and match()</h3></div></div></div><p>Let's look at some examples of using the <code class="literal">search()</code>and <code class="literal">match()</code> methods. First, you create a string object:</p><pre class="programlisting">    &gt; var s = new String('HelloJavaScriptWorld'); &#13;
</pre><p>Using <code class="literal">match()</code>, you get an array containing only the first match:</p><pre class="programlisting">    &gt; s.match(/a/); &#13;
    ["a"] &#13;
</pre><p>Using the <code class="literal">g</code> modifier, you perform a global search, so the result array contains two elements:</p><pre class="programlisting">    &gt; s.match(/a/g); &#13;
    ["a", "a"] &#13;
</pre><p>A case-insensitive match is as follows:</p><pre class="programlisting">    &gt; s.match(/j.*a/i); &#13;
    ["Java"] &#13;
</pre><p>The <code class="literal">search()</code> method gives you the position of the matching string:</p><pre class="programlisting">    &gt; s.search(/j.*a/i); &#13;
    5 &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>replace()</h3></div></div></div><p>The <code class="literal">replace()</code> method allows you to replace the matched text with some other string. The following example removes all capital letters (it replaces them with blank strings):</p><pre class="programlisting">    &gt; s.replace(/[A-Z]/g, ''); &#13;
    "elloavacriptorld" &#13;
</pre><p>If you omit the <code class="literal">g</code> modifier, you're only going to replace the first match:</p><pre class="programlisting">    &gt; s.replace(/[A-Z]/, ''); &#13;
    "elloJavaScriptWorld" &#13;
</pre><p>When a match is found, if you want to include the matched text in the replacement string, you can access it using <code class="literal">$&amp;</code>. Here's how to add an underscore before the match while keeping the match:</p><pre class="programlisting">    &gt; s.replace(/[A-Z]/g, "_$&amp;"); &#13;
    "_Hello_Java_Script_World" &#13;
</pre><p>When the regular expression contains groups (denoted by parentheses), the matches of each group are available as <code class="literal">$1</code> for the first group, <code class="literal">$2</code> the second, and so on:</p><pre class="programlisting">    &gt; s.replace(/([A-Z])/g, "_$1"); &#13;
    "_Hello_Java_Script_World" &#13;
</pre><p>Imagine you have a registration form on your web page that asks for an e-mail address, username, and password. The user enters their e-mail IDs, and then, your JavaScript kicks in and suggests the username, taking it from the e-mail address:</p><pre class="programlisting">    &gt; var email = "stoyan@phpied.com"; &#13;
    &gt; var username = email.replace(/(.*)@.*/, "$1"); &#13;
    &gt; username; &#13;
    "stoyan" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>Replace callbacks</h3></div></div></div><p>When specifying the replacement, you can also pass a function that returns a string. This gives you the ability to implement any special logic you may need before specifying the replacements:</p><pre class="programlisting">    &gt; function replaceCallback(match) { &#13;
       return "_" + match.toLowerCase(); &#13;
      } &#13;
 &#13;
    &gt; s.replace(/[A-Z]/g, replaceCallback); &#13;
    "_hello_java_script_world" &#13;
</pre><p>The callback function receives a number of parameters (the previous example ignores all but the first one):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first parameter is the <code class="literal">match</code></li><li class="listitem" style="list-style-type: disc">The last is the string being searched</li><li class="listitem" style="list-style-type: disc">The one before last is the position of the <code class="literal">match</code></li><li class="listitem" style="list-style-type: disc">The rest of the parameters contain any strings matched by any groups in your regex pattern</li></ul></div><p>Let's test this. First, let's create a variable to store the entire arguments array passed to the callback function:</p><pre class="programlisting">    &gt; var glob; &#13;
</pre><p>Next, define a regular expression that has three groups and matches e-mail addresses in the format <code class="literal">something@something.something</code>:</p><pre class="programlisting">    &gt; var re = /(.*)@(.*)\.(.*)/; &#13;
</pre><p>Finally, let's define a callback function that stores the arguments in <code class="literal">glob</code> and then returns the replacement:</p><pre class="programlisting">    var callback = function () { &#13;
      glob = arguments; &#13;
      return arguments[1] + ' at ' + &#13;
        arguments[2] + ' dot ' +  arguments[3]; &#13;
    }; &#13;
</pre><p>Now, perform a test:</p><pre class="programlisting">    &gt; "stoyan@phpied.com".replace(re, callback); &#13;
    "stoyan at phpied dot com" &#13;
</pre><p>Here's what the callback function received as arguments:</p><pre class="programlisting">    &gt; glob; &#13;
    ["stoyan@phpied.com", "stoyan", "phpied", "com", 0,  &#13;
    "stoyan@phpied.com"] &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>split()</h3></div></div></div><p>You already know about the <code class="literal">split()</code> method, which creates an array from an input string and a delimiter string. Let's take a string of comma-separated values and split it:</p><pre class="programlisting">    &gt; var csv = 'one, two,three ,four'; &#13;
    &gt; csv.split(','); &#13;
    ["one", " two", "three ", "four"] &#13;
</pre><p>Because the input string happens to have random inconsistent spaces before and after the commas, the array result has spaces too. With a regular expression, you can fix this using <code class="literal">\s*</code>, which means zero or more spaces:</p><pre class="programlisting">    &gt; csv.split(/\s*,\s*/); &#13;
    ["one", "two", "three", "four"] &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Passing a string when a RegExp is expected</h3></div></div></div><p>One last thing to note is that the four methods that you have just seen (<code class="literal">split()</code>, <code class="literal">match()</code>, <code class="literal">search()</code>, and <code class="literal">replace()</code>) can also take strings as opposed to regular expressions. In this case, the string argument is used to produce a new regex as if it were passed to <code class="literal">new RegExp()</code>.</p><p>An example of passing a string to <code class="literal">replace</code> is shown as follows:</p><pre class="programlisting">    &gt; "test".replace('t', 'r'); &#13;
    "rest" &#13;
</pre><p>The preceding lines of code are the same as the following one:</p><pre class="programlisting">    &gt; "test".replace(new RegExp('t'), 'r'); &#13;
    "rest" &#13;
</pre><p>When you pass a string, you cannot set modifiers the way you do with a normal constructor or regex literal. There's a common source of errors when using a string instead of a regular expression object for string replacements, and it's due to the fact that the <code class="literal">g</code> modifier is <code class="literal">false</code> by default. The outcome is that only the first string is replaced, which is inconsistent with most other languages and a little confusing. Here is an example:</p><pre class="programlisting">    &gt; "pool".replace('o', '*'); &#13;
    "p*ol" &#13;
</pre><p>Most likely, you want to replace all occurrences:</p><pre class="programlisting">    &gt; "pool".replace(/o/g, '*'); &#13;
    "p**l" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>Error objects</h3></div></div></div><p>Errors happen, and it's good to have the mechanisms in place so that your code can realize that there has been an error condition and can recover from it in a graceful manner. JavaScript provides the <code class="literal">try</code>, <code class="literal">catch</code>, and <code class="literal">finally</code> statements to help you deal with errors. If an error occurs, an error object is thrown. Error objects are created using one of these built-in constructors-<code class="literal">EvalError</code>, <code class="literal">RangeError</code>, <code class="literal">ReferenceError</code>, <code class="literal">SyntaxError</code>, <code class="literal">TypeError</code>, and <code class="literal">URIError</code>. All these constructors inherit from <code class="literal">Error</code>.</p><p>Let's just cause an error and see what happens. What's a simple way to cause an error? Just call a function that doesn't exist. Type this into the console:</p><pre class="programlisting">    &gt; iDontExist(); &#13;
</pre><p>You'll get something like the following:</p><p>
</p><div><img src="img/image_04_003-e1482749061350.jpg" alt="Error objects"/></div><p>
</p><p>The display of errors can vary greatly between browsers and other host environments. In fact, most recent browsers tend to hide the errors from the users. However, you cannot assume that all of your users have disabled the display of errors, and it is your responsibility to ensure an error-free experience for them. The previous error propagated to the user, because the code didn't try to trap (catch) this error. The code didn't expect the error and was not prepared to handle it. Fortunately, it's trivial to trap the error. All you need is the <code class="literal">try</code> statement followed by a <code class="literal">catch</code> statement.</p><p>This code hides the error from the user:</p><pre class="programlisting">    try { &#13;
      iDontExist(); &#13;
    } catch (e) { &#13;
      // do nothing &#13;
     } &#13;
</pre><p>Here you have:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">try</code> statement followed by a block of code.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">catch</code> statement followed by a variable name in parentheses and another block of code.</li></ul></div><p>There can be an optional <code class="literal">finally</code> statement (not used in this example) followed by a block of code, which is executed regardless of whether there was an error or not.</p><p>In the previous example, the code block that follows the <code class="literal">catch</code> statement didn't do anything. However, this is the place where you put the code that can help recover from the error, or at least give feedback to the user that your application is aware that there was a special condition.</p><p>The variable <code class="literal">e</code> in the parentheses after the <code class="literal">catch</code> statement contains an error object. Like any other object, it contains properties and methods. Unfortunately, different browsers implement these methods and properties differently, but there are two properties that are consistently implemented-<code class="literal">e.name</code> and <code class="literal">e.message</code>.</p><p>Let's try this code now:</p><pre class="programlisting">    try { &#13;
      iDontExist(); &#13;
    } catch (e) { &#13;
      alert(e.name + ': ' + e.message); &#13;
    } finally { &#13;
      alert('Finally!'); &#13;
    } &#13;
</pre><p>This will present an <code class="literal">alert()</code> showing <code class="literal">e.name</code> and <code class="literal">e.message</code> and then another <code class="literal">alert()</code> saying <code class="literal">Finally!</code>.</p><p>In Firefox and Chrome, the first alert will say <strong>ReferenceError: iDontExist is not defined</strong>. In Internet Explorer, it will be <strong>TypeError: Object expected</strong>. This tells us two things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">e.name</code> method contains the name of the constructor that was used to create the error object</li><li class="listitem" style="list-style-type: disc">As the error objects are not consistent across host environments (browsers), it would be somewhat tricky to have your code act differently depending on the type of error (the value of <code class="literal">e.name</code>)</li></ul></div><p>You can also create error objects yourself using <code class="literal">new Error()</code> or any of the other error constructors and then let the JavaScript engine know that there's an erroneous condition using the <code class="literal">throw</code> statement.</p><p>For example, imagine a scenario where you call the <code class="literal">maybeExists()</code> function and after that make calculations. You want to trap all errors in a consistent way, no matter whether the error is that <code class="literal">maybeExists()</code> doesn't exist or that your calculations found a problem. Consider the following code:</p><pre class="programlisting">    try { &#13;
      var total = maybeExists(); &#13;
      if (total === 0) { &#13;
        throw new Error('Division by zero!'); &#13;
      } else { &#13;
        alert(50 / total); &#13;
      } &#13;
    } catch (e) { &#13;
       alert(e.name + ': ' + e.message); &#13;
     } finally { &#13;
      alert('Finally!'); &#13;
    } &#13;
</pre><p>This code will alert different messages depending on whether or not <code class="literal">maybeExists()</code> is defined and the values it returns:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If <code class="literal">maybeExists()</code> doesn't exist, you get <strong>ReferenceError: maybeExists() is not defined</strong> in Firefox and <strong>TypeError: Object expected</strong> in IE</li><li class="listitem" style="list-style-type: disc">If <code class="literal">maybeExists()</code> returns <code class="literal">0</code>, you get <strong>Error: Division by zero!</strong></li><li class="listitem" style="list-style-type: disc">If <code class="literal">maybeExists()</code> returns <code class="literal">2</code>, you get an alert that says <strong>25</strong></li></ul></div><p>In all cases, there will be a second alert that says <strong>Finally!</strong>.</p><p>Instead of throwing a generic error, <code class="literal">thrownewError('Divisionbyzero!')</code>, you can be more specific if you choose to, for example, throw <code class="literal">thrownewRangeError('Divisionbyzero!')</code>. Alternatively, you don't need a constructor; you can simply throw a normal object:</p><pre class="programlisting">    throw { &#13;
      name: "MyError", &#13;
      message: "OMG! Something terrible has happened" &#13;
    } &#13;
</pre><p>This gives you cross-browser control over the error name.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Exercises</h1></div></div></div><p>Lets solve the following exercise:</p><div><ol class="orderedlist arabic"><li class="listitem">Look at the following code:<pre class="programlisting">        function F() { &#13;
          function C() { &#13;
           return this; &#13;
          } &#13;
          return C(); &#13;
        } &#13;
        var o = new F(); &#13;
</pre><p>Does the value of <code class="literal">this</code> refer to the global object or the object <code class="literal">o</code>?</p></li><li class="listitem">What's the result of executing this piece of code?<pre class="programlisting">        function C(){  &#13;
          this.a = 1; &#13;
          return false; &#13;
        } &#13;
        console.log(typeof new C()); &#13;
</pre></li><li class="listitem">What's the result of executing the following piece of code?<pre class="programlisting">        &gt; c = [1, 2, [1, 2]]; &#13;
        &gt; c.sort(); &#13;
        &gt; c.join('--');  &#13;
        &gt; console.log(c);  &#13;
</pre></li><li class="listitem">Imagine the <code class="literal">String()</code> constructor didn't exist. Create a constructor function, <code class="literal">MyString()</code>, that acts like <code class="literal">String()</code> as closely as possible. You're not allowed to use any built-in string methods or properties, and remember that the <code class="literal">String()</code> doesn't exist. You can use this code to test your constructor:<pre class="programlisting">        &gt; var s = new MyString('hello'); &#13;
        &gt; s.length; &#13;
              5 &#13;
        &gt; s[0]; &#13;
              "h" &#13;
        &gt; s.toString(); &#13;
              "hello" &#13;
        &gt; s.valueOf(); &#13;
              "hello" &#13;
        &gt; s.charAt(1); &#13;
              "e" &#13;
        &gt; s.charAt('2'); &#13;
              "l" &#13;
        &gt; s.charAt('e'); &#13;
              "h" &#13;
        &gt; s.concat(' world!'); &#13;
              "hello world!" &#13;
        &gt; s.slice(1, 3); &#13;
              "el" &#13;
        &gt; s.slice(0, -1); &#13;
              "hell" &#13;
        &gt; s.split('e'); &#13;
              ["h", "llo"] &#13;
        &gt; s.split('l'); &#13;
              ["he", "", "o"] &#13;
</pre><div><div><h3 class="title"><a id="note21"/>Note</h3><p>You can use a <code class="literal">for</code> loop to loop through the input string, treating it as an array.</p></div></div></li><li class="listitem">Update your <code class="literal">MyString()</code> constructor to include a <code class="literal">reverse()</code> method.<div><div><h3 class="title"><a id="note22"/>Note</h3><p>Try to leverage the fact that arrays have a <code class="literal">reverse()</code> method.</p></div></div></li><li class="listitem">Imagine that <code class="literal">Array()</code>and the array literal notation don't exist. Create a constructor called <code class="literal">MyArray()</code> that behaves as close to <code class="literal">Array()</code> as possible. Test it with the following code:<pre class="programlisting">        &gt; var a = new MyArray(1, 2, 3, "test"); &#13;
        &gt; a.toString(); &#13;
              "1,2,3,test" &#13;
        &gt; a.length; &#13;
              4 &#13;
        &gt; a[a.length - 1]; &#13;
              "test" &#13;
        &gt; a.push('boo'); &#13;
              5 &#13;
        &gt; a.toString(); &#13;
              "1,2,3,test,boo" &#13;
        &gt; a.pop(); &#13;
              "boo" &#13;
        &gt; a.toString(); &#13;
              "1,2,3,test" &#13;
        &gt; a.join(','); &#13;
              "1,2,3,test" &#13;
        &gt; a.join(' isn't '); &#13;
              "1 isn't 2 isn't 3 isn't test" &#13;
</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you found this exercise amusing, don't stop with the <code class="literal">join()</code> method; go on with as many methods as possible.</li></ul></div></li><li class="listitem">Imagine <code class="literal">Math</code> didn't exist. Create a <code class="literal">MyMath</code> object that also provides the following additional methods:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MyMath.rand(min, max, inclusive)</code>: This generates a random number between <code class="literal">min</code> and <code class="literal">max</code>, inclusive if <code class="literal">inclusive</code> is <code class="literal">true</code> (default)</li><li class="listitem" style="list-style-type: disc"><code class="literal">MyMath.min(array)</code>: This returns the smallest number in a given array</li><li class="listitem" style="list-style-type: disc"><code class="literal">MyMath.max(array)</code>: This returns the largest number in a given array</li></ul></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Summary</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <em>Primitive Data Types, Arrays, Loops, and Conditions</em>, you saw that there are five primitive data types (<code class="literal">number</code>, <code class="literal">string</code>, <code class="literal">Boolean</code>, <code class="literal">null</code>, and <code class="literal">undefined</code>), and we also said that everything that is not a primitive piece of data is an object. Now, you also know that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Objects are like arrays, but you specify the keys</li><li class="listitem" style="list-style-type: disc">Objects contain properties</li><li class="listitem" style="list-style-type: disc">Properties can be functions (functions are data; remember <code class="literal">var f = function () {};</code>). Properties that are functions are also called methods</li><li class="listitem" style="list-style-type: disc">Arrays are actually objects with predefined numeric properties and an auto-incrementing <code class="literal">length</code> property</li><li class="listitem" style="list-style-type: disc">Array objects have a number of convenient methods (such as <code class="literal">sort()</code> or <code class="literal">slice()</code>)</li><li class="listitem" style="list-style-type: disc">Functions are also objects, and they have properties (such as <code class="literal">length</code> and <code class="literal">prototype</code>) and methods (such as <code class="literal">call()</code> and <code class="literal">apply()</code>)</li></ul></div><p>Regarding the five primitive data types, apart from <code class="literal">undefined</code> and <code class="literal">null</code>, the other three have the corresponding constructor functions-<code class="literal">Number()</code>, <code class="literal">String()</code>, and <code class="literal">Boolean()</code>. Using these, you can create objects, called wrapper objects, which contain methods for working with primitive data elements.</p><p>
<code class="literal">Number()</code>, <code class="literal">String()</code>, and <code class="literal">Boolean()</code> can be invoked:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">With the <code class="literal">new</code> operator, to create new objects.</li><li class="listitem" style="list-style-type: disc">Without the <code class="literal">new</code> operator, to convert any value to the corresponding primitive data type.</li></ul></div><p>Other built-in constructor functions you're now familiar with include <code class="literal">Object()</code>, <code class="literal">Array()</code>, <code class="literal">Function()</code>, <code class="literal">Date()</code>, <code class="literal">RegExp()</code>, and <code class="literal">Error()</code>. You're also familiar with <code class="literal">Math</code>-a global object that is not a constructor.</p><p>Now, you can see how objects have a central role in JavaScript programming, as pretty much everything is an object or can be wrapped by an object.</p><p>Finally, let's wrap up the literal notations you're now familiar with:</p><div><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>Name</strong>
</p>
</td><td>
<p>
<strong>Literal</strong>
</p>
</td><td>
<p>
<strong>Constructor</strong>
</p>
</td><td>
<p>
<strong>Example</strong>
</p>
</td></tr><tr><td>
<p>Object</p>
</td><td>
<p>
<code class="literal">{}</code>
</p>
</td><td>
<p>
<code class="literal">new Object()</code>
</p>
</td><td>
<p>
<code class="literal">{prop: 1}</code>
</p>
</td></tr><tr><td>
<p>Array</p>
</td><td>
<p>
<code class="literal">[]</code>
</p>
</td><td>
<p>
<code class="literal">new Array()</code>
</p>
</td><td>
<p>
<code class="literal">[1,2,3,'test']</code>
</p>
</td></tr><tr><td>
<p>Regular expression</p>
</td><td>
<p>
<code class="literal">/pattern/modifiers</code>
</p>
</td><td>
<p>
<code class="literal">new RegExp('pattern', 'modifiers')</code>
</p>
</td><td>
<p>
<code class="literal">/java.*/img</code>
</p>
</td></tr></tbody></table></div></div></body></html>