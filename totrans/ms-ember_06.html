<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Views and Event Management</h1></div></div></div><p class="calibre7">We discussed templates and controllers in the previous two chapters. We noted that controllers present models that templates render to users. We also learned that when users interact with applications, templates usually propagate these events back to controllers using action template helpers. In reality, these action expressions are views that delegate the events initially to controllers, and later to routes. Therefore, in this chapter, we will learn how to integrate views right into templates, especially when the following application needs arise:</p><div><ul class="itemizedlist"><li class="listitem">A section of the application requires sophisticated event management</li><li class="listitem">There's a need to build reusable components</li><li class="listitem">The application needs to integrate third-party libraries</li></ul></div><p class="calibre7">Therefore, by the end of this chapter, you should be able to:</p><div><ul class="itemizedlist"><li class="listitem">Define a view</li><li class="listitem">Create a view instance</li><li class="listitem">Customize a view</li><li class="listitem">Manage events in views</li><li class="listitem">Use built-in views</li><li class="listitem">Use third-party libraries</li></ul></div><p class="calibre7">As mentioned in the first chapter, we will rarely need to define views unless we really need a tight control over the DOM structure. In the next chapter, we will discuss how to use ember components that are a higher level construct of views.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec63" class="calibre1"/>Defining views</h1></div></div></div><p class="calibre7">Views <a id="id277" class="calibre1"/>in an application manage templates through data binding and delegation of user-initiated events. Just like controllers, a view class is defined from the base <code class="email">Ember.View</code> class as:</p><div><pre class="programlisting">var View = Ember.View.extend({});</pre></div><p class="calibre7">An instance of the preceding view can then be created by calling the view's <code class="email">create</code> method:</p><div><pre class="programlisting">var view = View.create();</pre></div><p class="calibre7">We<a id="id278" class="calibre1"/> can still create additional views from the already defined class, as illustrated in the following code:</p><div><pre class="programlisting">var UserView = View.extend({
  isLoggedIn: true,
  isAdmin: false
});</pre></div><p class="calibre7">By now, we already know that Ember.js classes can accept any number of mixins as shown in the preceding example. However, instances <a id="id279" class="calibre1"/>created with mixins always use the <code class="email">createWithMixins</code> method:</p><div><pre class="programlisting">var mixinA = Ember.Mixin.create({
  isLoggedIn: true
});

var mixinB = Ember.Mixin.create({
  isAdmin: false
});

var userView = View.createWithMixins(mixinA, mixinB);</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec64" class="calibre1"/>Accessing a view's controller</h1></div></div></div><p class="calibre7">Views <a id="id280" class="calibre1"/>are <a id="id281" class="calibre1"/>usually backed by an instance of the corresponding controller. Once a view is inserted into the DOM, the corresponding controller can be accessed by the <code class="email">controller</code> property, as shown in the following example:</p><div><pre class="programlisting">view.get('controller').getSortedBooks();</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec65" class="calibre1"/>Specifying a view's template</h1></div></div></div><p class="calibre7">Every <a id="id282" class="calibre1"/>view <a id="id283" class="calibre1"/>renders a template into the DOM. Views can be assigned the template to use in a number of ways. For example, let's consider the following router:</p><div><pre class="programlisting">App.Router.map(function(){
  this.route('new');
});</pre></div><p class="calibre7">Ember.js will expect a defined <code class="email">App.NewRoute</code> class for the new route as:</p><div><pre class="programlisting">App.NewRoute = Ember.Route.extend({
  model: function(){
    return Em.Object.create();
  }
});</pre></div><p class="calibre7">Any visit to this route will use the following Ember.js objects, if defined:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">App.NewController</code> object</li><li class="listitem">The <code class="email">Ember.TEMPLATES.new</code> template</li><li class="listitem">The <code class="email">App.NewView</code> object</li></ul></div><p class="calibre7">The default<a id="id284" class="calibre1"/> behavior is where the name of the template dictates the view<a id="id285" class="calibre1"/> to use. If we wish to use a different template, say <code class="email">Ember.TEMPLATES.form</code>, we will need to implement it in the <code class="email">renderTemplates</code> hook of the route as:</p><div><pre class="programlisting">App.NewRoute = Ember.Route.extend({
  model: function(){
    return Em.Object.create();
  },
  renderTemplate: function(controller, model){
    this.render('form');
  }
});</pre></div><p class="calibre7">As expected, this route will use the <code class="email">App.FormView</code> view class. The template used is usually included into the application as a script tag. For example, we can define the new template that will be used by an <code class="email">App.NewView</code> as:</p><div><pre class="programlisting">&lt;script type='text/x-handlebars' id='new'&gt;
&lt;input name='name' &gt;
&lt;input name='gender' &gt;
&lt;button type='submit'&gt;save&lt;/button&gt;
&lt;/script&gt;</pre></div><p class="calibre7">Note that the previous template can still be accessed as <code class="email">Ember.TEMPLATES.new</code>. Therefore, an alternative way to specify a view's template is to pragmatically update its value with the desired compiled template, as shown in the following code:</p><div><pre class="programlisting">var template = [
 '&lt;input name='name' &gt;',
 '&lt;input name='gender' &gt;',
'&lt;button type='submit'&gt;save&lt;/button&gt;'
].join('');

Ember.TEMPLATES['new'] = Ember.Handlebars.compile(template);</pre></div><p class="calibre7">In a production environment, it's advised to compile these templates server side, and then bundle them up<a id="id286" class="calibre1"/> for performance reasons. We can still specify the<a id="id287" class="calibre1"/> template using the <code class="email">templateName</code> property on the view class, for example:</p><div><pre class="programlisting">&lt;script type='text/x-handlebars' id='form'&gt;
   &lt;input name='name' &gt;
   &lt;input name='gender' &gt;
   &lt;button type='submit'&gt;save&lt;/button&gt;
&lt;/script&gt;

   App.NewView = Ember.View.extend({
     templateName: 'form'
  });</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec66" class="calibre1"/>Specifying a view's element tag</h1></div></div></div><p class="calibre7">A <a id="id288" class="calibre1"/>view's template <a id="id289" class="calibre1"/>is usually wrapped in a <code class="email">div</code> element by default, as shown in the following example:</p><div><pre class="programlisting">&lt;div&gt;{{name}}&lt;/div&gt;
&lt;div&gt;{{gender}}&lt;/div&gt;</pre></div><p class="calibre7">This yields the following:</p><div><pre class="programlisting">&lt;div id='ember10' class='ember-view'&gt;
  &lt;div&gt;Jon Doe&lt;/div&gt;
  &lt;div&gt;Male&lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre7">This element type can be altered using the <code class="email">tagName</code> property of the <code class="email">view</code> class, as shown in the following code:</p><div><pre class="programlisting">var View = Ember.View.extend({
  templateName: 'user',
  tagName: 'header'
});</pre></div><p class="calibre7">The preceding snippet will yield something like the following:</p><div><pre class="programlisting">&lt;header div id='ember10' class='ember-view'&gt;
  &lt;div&gt;Jon Doe&lt;/div&gt;
  &lt;div&gt;Male&lt;/div&gt;
&lt;/header&gt;</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec67" class="calibre1"/>Updating a view's element class attribute</h1></div></div></div><p class="calibre7">In the <a id="id290" class="calibre1"/>previous section, we learned that views are <a id="id291" class="calibre1"/>usually wrapped in a configurable DOM element. The element's class attribute can also be specified statically using the view's <code class="email">classNames</code> array property. For example, a Twitter Bootstrap button can be created as:</p><div><pre class="programlisting">var view = Ember.View.extend({
  tagName: 'button',
  classNames: ['btn', 'btn-primary]
});</pre></div><p class="calibre7">This will yield something like the following:</p><div><pre class="programlisting">&lt;button class='btn btn-primary'&gt;Button&lt;/button&gt;</pre></div><p class="calibre7">The element's classes can also be altered dynamically using the view's <code class="email">classNameBindings</code> array property, as shown in the following code:</p><div><pre class="programlisting">var View = Ember.View.extend({
  tagName: 'button',
  classNames: ['btn'],
  classNameBindings: ['btnWarning'],
  btnWarning: true
});</pre></div><p class="calibre7">This example yields the following:</p><div><pre class="programlisting">&lt;button class='btn btn-warning'&gt;Button&lt;/button&gt;</pre></div><p class="calibre7">These class names are dasherized as per the Ember.js naming conventions. Hence, the <code class="email">btnWarning</code> property is mapped to the <code class="email">btn-warning</code> class name.</p><p class="calibre7">Sometimes, you might want to specify the class name to be used based on a given state. This is something we learned in <a class="calibre1" title="Chapter 4. Writing Application Templates" href="part0044_split_000.html#page">Chapter 4</a>, <em class="calibre9">Writing Application Templates</em>, for example:</p><div><pre class="programlisting">var View = Ember.View.extend({
  tagName: 'button',
  classNames: ['btn'],
  classNameBindings: ['warn:btnWarning'],
  warn: true
});</pre></div><p class="calibre7">In the preceding example, the <code class="email">btn-warning</code> class will be added to the class attribute of the element, based on the view's <code class="email">warn</code> property.</p><p class="calibre7">Lastly, we can add different classes depending on a certain state. For example, imagine we want to display different states of our Bootstrap button. This is possible with the following signature:</p><div><pre class="programlisting">classNameBindings: ['property:truthyClassName:falsyClassName'],</pre></div><p class="calibre7">For example:</p><div><pre class="programlisting">var View = Ember.View.extend({
  tagName: 'button',
  classNames: ['btn'],
  classNameBindings: ['controller.warn:btnWarning:btnPrimary'],
});</pre></div><p class="calibre7">In the <a id="id292" class="calibre1"/>preceding<a id="id293" class="calibre1"/> example, when the view controller's <code class="email">warn</code> property becomes <code class="email">true</code>, the following will be yielded:</p><div><pre class="programlisting">&lt;button class='btn btn-warning'&gt;checkout&lt;/button&gt;</pre></div><p class="calibre7">Otherwise, the other class will be used instead:</p><div><pre class="programlisting">&lt;button class='btn btn-primary'&gt;checkout&lt;/button&gt;</pre></div><p class="calibre7">By now, you will have noticed that the binding behavior is similar to the one we learned in <a class="calibre1" title="Chapter 4. Writing Application Templates" href="part0044_split_000.html#page">Chapter 4</a>, <em class="calibre9">Writing Application Templates</em>.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec68" class="calibre1"/>Updating other views' element attributes</h1></div></div></div><p class="calibre7">In<a id="id294" class="calibre1"/> addition<a id="id295" class="calibre1"/> to class attributes, all other attributes of a view's element can be altered dynamically. For example, let's create a thumbnail view, as shown in the following code:</p><div><pre class="programlisting">var thumb = Ember.View.create({
  tagName: 'img',
  attributeBindings: ['width', 'height', 'src'],
  width: 50,
  height: 50,
  src: 'http://www.google.com/doodles/new-years-day-2014'
});</pre></div><p class="calibre7">This yields the following:</p><div><pre class="programlisting">&lt;img src='http://www.google.com/doodles/new-years-day-2014' width='50' height='50'&gt;</pre></div><p class="calibre7">The attributes' presence can be altered using bound Boolean properties. For example, we can disable a <code class="email">save</code> button of a form if the corresponding input has not been filled, as shown in the following example:</p><div><pre class="programlisting">// view

App.FormButton = Em.View.extend({
  tagName: 'button',
  attributeBindings: ['disabled'],
  disabled: function(){
     return !this.get('controller.model.title');
  }.property('controller.model.title')
});

// route

App.NewRoute = Em.Route.extend({
  model: function(){
    return Em.Object.create({
   });
  }
});

{{! new template }}

&lt;form {{action 'save' model on='submit'}}&gt;
  {{input value=model.title}}
  {{#view App.FormButton}}save{{/view}}
&lt;/form&gt;</pre></div><p class="calibre7">When<a id="id296" class="calibre1"/> the <a id="id297" class="calibre1"/>model's <code class="email">title</code> property is undefined, the view's disabled property will come true. Hence, the view's element will acquire the disabled attribute and vice versa. This example lets users submit the form only when it's valid. Note that the defined view can be reimplemented as:</p><div><pre class="programlisting">App.FormButton = Em.View.extend({
  tagName: 'button',
  attributeBindings: ['modelIsValid::disabled'],
  modelIsValid: function(){
     return !this.get('model.title');
  }.property('model.title')
});</pre></div><p class="calibre7">This example shows that any property, in this case, <code class="email">modelIsValid</code>, can be used to provide the attribute to show or hide when the state changes, as long as it's specified using the following signature:</p><div><pre class="programlisting">"propertyName:attributeWhenTrue:attributeWhenFalse" </pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec69" class="calibre1"/>Inserting views into DOM</h1></div></div></div><p class="calibre7">We<a id="id298" class="calibre1"/> just <a id="id299" class="calibre1"/>learned that views have templates that they render into DOM. Applications that need to do this manually will need to utilize the view instance <code class="email">appendTo</code> method, as shown in the following example:</p><div><pre class="programlisting">view.appendTo('#header');</pre></div><p class="calibre7">This method takes a jQuery query selector that we are already used to, as shown in the following examples:</p><div><pre class="programlisting">view.appendTo('header');
view.appendTo('#header');
view.appendTo('.header');
view.appendTo('body &gt; header');</pre></div><p class="calibre7">Note that only one matched element is <a id="id300" class="calibre1"/>used. Therefore, in the third example, the view will be inserted into the last <code class="email">header</code> element found.</p><p class="calibre7">As a <a id="id301" class="calibre1"/>convenience, views have an <code class="email">append</code> method that can be used to insert the views directly into the body section of DOM:</p><div><pre class="programlisting">view.append(); // appends view to the body section</pre></div><p class="calibre7">You might also want to remove a view from DOM using the <code class="email">remove</code> method as:</p><div><pre class="programlisting">view.remove();</pre></div><p class="calibre7">Note that a view is automatically removed from DOM if destroyed, as shown in the following line of code:</p><div><pre class="programlisting">view.destroy();</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec70" class="calibre1"/>Inserting views into templates</h1></div></div></div><p class="calibre7">Views<a id="id302" class="calibre1"/> are hierarchical, and hence, they can be inserted<a id="id303" class="calibre1"/> into the templates of other views constituting the template hierarchy we discussed in <a class="calibre1" title="Chapter 4. Writing Application Templates" href="part0044_split_000.html#page">Chapter 4</a>, <em class="calibre9">Writing Application Templates</em>. For example, consider the following application template:</p><div><pre class="programlisting">&lt;script type='text/x-handlebars' id='application'&gt;
{{view App.HeaderView}}
{{view App.FooterView}}
&lt;/script&gt;</pre></div><p class="calibre7">As shown, defined views are inserted into a desired template using the <code class="email">view</code> expression. These <code class="email">view</code> expressions can also be wrapped into block clauses, as shown in the following code. Additional views can then be inserted into these block expressions:</p><div><pre class="programlisting">{{! application template}}
&lt;script type='text/x-handlebars' id='application'&gt;

 {{view App.HeaderView}}

 {{#view App.ContentView}}
   {{view App.SideView}}
   {{view App.PaneView}}
 {{/view}}

 {{view App.FooterView}}

&lt;/script&gt;</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec71" class="calibre1"/>Specifying view layouts</h1></div></div></div><p class="calibre7">We <a id="id304" class="calibre1"/>already learned that a view's template is wrapped in an element, which is usually specified by the <code class="email">tagName</code> property. In addition, this template can be wrapped by another template, as illustrated in the following figure:</p><div><img src="img/00010.jpeg" alt="Specifying view layouts" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">A template is marked as a layout by adding a <code class="email">yield</code> expression, as shown in the following code:</p><div><pre class="programlisting">&lt;script type='text/x-handlebars' id='container'&gt;
  &lt;div id='container'&gt;
   {{yield}}
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">Just like the <code class="email">outlet</code> expression, the <code class="email">yield</code> expression serves as the portion that the template being wrapped will be inserted into. We then specify this layout in the view as:</p><div><pre class="programlisting">var View = Ember.View.extend({
  tagName: 'section',
  layoutName: 'container',
  templateName: 'book'
});</pre></div><p class="calibre7">Suppose our <code class="email">book</code> template is:</p><div><pre class="programlisting">&lt;script type='text/x-handlebars' id='book'&gt;
  &lt;p&gt;Author: Jon Doe&lt;/p&gt;
   &lt;/script&gt;</pre></div><p class="calibre7">This will yield the following:</p><div><pre class="programlisting">&lt;div id='container'&gt;
 &lt;section&gt;
  &lt;p&gt;Author: Jon Doe&lt;/p&gt;
 &lt;/section&gt;
   &lt;/div&gt;</pre></div><p class="calibre7">It is<a id="id305" class="calibre1"/> important to note that views with self-closing HTML elements cannot have layouts. These views include <code class="email">&lt;input&gt;</code> and <code class="email">&lt;img&gt;</code>.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec72" class="calibre1"/>Registering event handlers in views</h1></div></div></div><p class="calibre7">Views<a id="id306" class="calibre1"/> can register event handlers on events emitted <a id="id307" class="calibre1"/>from elements in their rendered templates, in addition to the use of the <code class="email">action</code> template expressions. For example, let's reuse an example from <a class="calibre1" title="Chapter 4. Writing Application Templates" href="part0044_split_000.html#page">Chapter 4</a>, <em class="calibre9">Writing Application Templates</em>:</p><div><pre class="programlisting">  &lt;button {{action 'checkout'}}&gt;checkout&lt;/button&gt;</pre></div><p class="calibre7">This example can easily be reimplemented as a view, as shown in the following code:</p><div><pre class="programlisting">App.CheckoutButton = Ember.View.extend({
  tagName: 'button',
  click: function(event){
    this.get('controller').send('checkout');
  }
});

{{! template }}
{{#view App.CheckoutButton }}checkout{{/view}}</pre></div><p class="calibre7">In this example, we created a custom button view that registers a click event handler.</p><p class="calibre7">Every view manages only the events invoked from their templates. However, child views usually bubble events to parent views up to the root element up until the events get handled.</p><p class="calibre7">Ember.js supports the following events:</p><div><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Touch events</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Keyboard events</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Mouse events</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Form events</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">HTML5 drag-and-drop events</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">touchStart</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">keyDown</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">mouseDown</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">submit</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">dragStart</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">touchMove</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">keyUp</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">mouseUp</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">change</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">drag</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">touchEnd</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">keyPress</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">contextMenu</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">focusIn</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">dragEnter</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">touchCancel</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">click</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">focusOut</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">dragLeave</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">doubleClick</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">input</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">drop</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">mouseMove</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">dragEnd</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">focusIn</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">focusOut</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">mouseEnter</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">mouseLeave</code>
</p>
</td><td valign="top" class="calibre21"> </td><td valign="top" class="calibre21"> </td></tr></tbody></table></div><p class="calibre7">Now is a <a id="id308" class="calibre1"/>good opportunity to try and write views<a id="id309" class="calibre1"/> that use some of these events.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec73" class="calibre1"/>Emitting actions from views</h1></div></div></div><p class="calibre7">We<a id="id310" class="calibre1"/> already<a id="id311" class="calibre1"/> learned that views have a reference to the context controller via the <code class="email">controller</code> property. A view can use the controller's <code class="email">send</code> method to delegate user-initiated events to the corresponding <a id="id312" class="calibre1"/>routes, as shown in the following <a id="id313" class="calibre1"/>example:</p><div><pre class="programlisting">App.CheckoutButton = Ember.View.extend({
  tagName: 'button',
  click: function(event){
    this.get('controller').send('checkout');
  }
});</pre></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec74" class="calibre1"/>Using built-in views (components)</h1></div></div></div><p class="calibre7">In <a class="calibre1" title="Chapter 4. Writing Application Templates" href="part0044_split_000.html#page">Chapter 4</a>, <em class="calibre9">Writing Application Templates</em>, we <a id="id314" class="calibre1"/>promised to discuss the built-in views that Ember.js provides. Most of these are high-level views (components) from controls that guarantee painless design of forms.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec33" class="calibre1"/>Textfields</h2></div></div></div><p class="calibre7">The<a id="id315" class="calibre1"/> textfield<a id="id316" class="calibre1"/> view is used to create a bound text input in a form. It's usually created from the <code class="email">Ember.TextField</code> class. We can subscribe to the input's value changes by implementing the view's <code class="email">change</code> event handler, as shown in the following code:</p><div><pre class="programlisting">App.InputView = Ember.TextField.extend({
  change: function(event){
    console.log(this.get('value')); 
  }
});</pre></div><p class="calibre7">Just like any other view, we can insert this view into a template as:</p><div><pre class="programlisting">{{view App.InputView name='name' valueBinding='controller.name'}}</pre></div><p class="calibre7">In this example, we created a text input that updated the context controller's name property whenever its value changes. This is one of the many use cases of such views.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec34" class="calibre1"/>Textareas</h2></div></div></div><p class="calibre7">A <a id="id317" class="calibre1"/>textarea<a id="id318" class="calibre1"/> is very similar to a textfield, both accept some additional attributes such as <code class="email">rows</code> and <code class="email">cols</code>, for example:</p><div><pre class="programlisting">{{view Ember.TextArea name='content' valueBinding='content' rows=10 cols=10}}</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec35" class="calibre1"/>Select menus</h2></div></div></div><p class="calibre7">Another<a id="id319" class="calibre1"/> common form control is<a id="id320" class="calibre1"/> the select menu. Ember.js provides an <code class="email">Ember.Select</code> class that can be used to create this control. For example, let's create a select menu that prompts a user to choose their favorite fruit in this control:</p><div><pre class="programlisting">// controller

App.ApplicationController = Ember.Controller.extend({
  selectedFruit: null,
  fruits: [{
    id: 1,
    name: 'mango'
  }, {
    id: 2,
    name: 'apple'
 }],
}); 

{{! template }}

{{view Ember.Select
  prompt='Select a fruit:'
  contentBinding='fruits'
  selectionBinding='selectedFruit'
  optionLabelPath='content.name'
  optionValuePath='content.id'}}</pre></div><p class="calibre7">In the preceding example, the user is presented with two fruits to select from. They are first prompted with a <strong class="calibre8">Select a fruit</strong> prompt that was passed during definition. The view's <code class="email">content</code> property is usually an array of the choices that should be displayed, and the <code class="email">selection</code> property holds the selected choice. Often, these choices are usually objects rather than strings, as seen in the preceding example. Therefore, additional customization needs to be done using two properties:</p><div><ul class="itemizedlist"><li class="listitem">The <a id="id321" class="calibre1"/><code class="email">optionLabelPath</code> property: This specifies the choice's label</li><li class="listitem">The <a id="id322" class="calibre1"/><code class="email">optionValuePath</code> property: This specifies the value to be looked up for the selected choice</li></ul></div><p class="calibre7">Therefore, the preceding example specified the fruit's name as the property to display and the ID as the property to determine the selection.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec36" class="calibre1"/>Checkboxes</h2></div></div></div><p class="calibre7">Checkboxes <a id="id323" class="calibre1"/>can also be implemented in the <a id="id324" class="calibre1"/>same way using the <code class="email">Ember.Cechkbox</code> view class. These controls enable the user to select various choices from a given set, for example:</p><div><pre class="programlisting">{{view Ember.Checkbox name='is-complete' valueBinding='isComplete'}}
{{view Ember.Checkbox name='is-done' valueBinding='isDone'}}
{{view Ember.Checkbox name='is-empty' valueBinding='isEmpty'}}</pre></div><p class="calibre7">This will yield something like the following:</p><div><pre class="programlisting">&lt;input type='checkbox' name='is-complete' checked &gt;
&lt;input type='checkbox' name='is-done' &gt;
&lt;input type='checkbox' name='is-empty' &gt;</pre></div><p class="calibre7">The bound value of an instance of this view is usually a Boolean.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec37" class="calibre1"/>The container view</h2></div></div></div><p class="calibre7">We<a id="id325" class="calibre1"/> already learned that a view can be <a id="id326" class="calibre1"/>inserted into other views using the <code class="email">view</code> template helper, as shown in the following lines of code:</p><div><pre class="programlisting">{{#view App.ContentView}}
  {{view App.SideView}}
  {{view App.PaneView}}
{{/view}}</pre></div><p class="calibre7">In some cases, we might want the parent view, in this case, <code class="email">App.ContentView</code>, to be able to manually manage child views. <code class="email">Ember.ContainerView</code> is an enumerable view that an application can pragmatically add or remove child views from, as shown in the following example:</p><div><pre class="programlisting">var sideView = Ember.View.create();
var paneView = Ember.View.create();
var contentView = Ember.ContainerView.create();
contentView.pushObjects([
  sideView, paneView
]);</pre></div><p class="calibre7">These child views are usually contained in the <code class="email">childViews</code> property. You can, therefore, implement the preceding example as:</p><div><pre class="programlisting">var compile = Em.Handlebars.compile;
var contentView = Ember.ContainerView.create({
  childViews: ['sideView', 'paneView'],
  sideView: Ember.View.create({
    template: compile('Side')
  }),
  paneView = Ember.View.create({
    template: compile('Pane')
  })
});</pre></div><p class="calibre7">This yields something like the following:</p><div><pre class="programlisting">&lt;div&gt;
  &lt;div&gt;Side&lt;/div&gt;
  &lt;div&gt;Pane&lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre7">It is <a id="id327" class="calibre1"/>important to note that since container <a id="id328" class="calibre1"/>views house other views, they cannot have templates or layouts. Therefore, specified templates or layouts will be ignored.</p><p class="calibre7">Other HTML form controls can be abstracted to achieve simpler views. Therefore, as an exercise, create an <code class="email">Ember.Radios</code> view class that displays a set of HTML radio buttons. Note that the implementation will be very similar to that of <code class="email">Ember.Select</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec38" class="calibre1"/>Integrating with third-party DOM manipulation libraries</h2></div></div></div><p class="calibre7">Many<a id="id329" class="calibre1"/> jQuery libraries primarily manipulate <a id="id330" class="calibre1"/>DOM in order to achieve a desired effect. We all know that you need to initialize these libraries only when DOM is ready:</p><div><pre class="programlisting">$(docoment).ready(function(event){
  // initialize library
  $('#menu').dropdown();
});</pre></div><p class="calibre7">jQuery is an Ember.js dependency, and it's thus very easy to integrate such libraries into applications. Imagine we had a menu view that we wanted to apply to this plugin. Views have the <code class="email">willInsertElement</code>
<a id="id331" class="calibre1"/> and <code class="email">didInsertElement</code> hooks <a id="id332" class="calibre1"/>that we can use to implement such needs, as shown in the following code:</p><div><pre class="programlisting">// view
App.MenuView = Ember.View.extend({
  didInsertElement: function(){
    this._super();
    Ember.run.schedule('afterRender', this, function() {
      this.$().dropdown();
    });
  }
});

{{! template}}
{{view App.MenuView}}</pre></div><p class="calibre7">The <code class="email">didInsertElement</code> hooks guarantee that the <a id="id333" class="calibre1"/>view has been inserted into DOM, and therefore, we<a id="id334" class="calibre1"/> might apply any plugin to it. Note that calling <code class="email">this.$()</code> returns a jQuery element selector relative to the view. Also, note that we take care to call the <code class="email">_super</code> method, as there can be parent implementations we cannot afford to lose. We also <em class="calibre9">schedule</em> this code to be run after the element is rendered into DOM.</p><p class="calibre7">At a later <a id="id335" class="calibre1"/>point in time, we might decide to remove the view from DOM. It will, therefore, be necessary that we remove any event that the plugin set up before removing the view. Ember.js provides the <code class="email">willDestroy</code> hook<a id="id336" class="calibre1"/> that can be used to accomplish this:</p><div><pre class="programlisting">App.MenuView = Ember.View.extend({
  willDestroy: function(){
    this._super();
    this.$().tearDownDropdown();
  }
});</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec75" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we discussed how views are defined and created as well as how they can be customized. We also learned how events in these views can be managed. Lastly, we explored the different components Ember.js provides and how third-party libraries such as jQuery plugins can be integrated into an application through views.</p><p class="calibre7">The end of this chapter marked the completion of the core concepts of Ember.js. In the next chapters, we'll start building complete sample applications as we explore more features. You should, therefore, be well versed in the following Ember.js concepts and objects:</p><div><ul class="itemizedlist"><li class="listitem">Objects</li><li class="listitem">Routes</li><li class="listitem">Templates</li><li class="listitem">Controllers</li><li class="listitem">Views</li></ul></div></div></body></html>