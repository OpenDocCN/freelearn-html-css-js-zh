<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Loading and Working with Textures"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Loading and Working with Textures</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Working with Three.js Materials">Chapter 4</a>, <span class="emphasis"><em>Working with Three.js Materials</em></span>, we introduced you to the various materials that are available in Three.js. In that chapter, however, we didn't talk about applying textures to meshes. In this chapter, we'll look at that subject. More specifically, in this chapter, we'll discuss the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading textures in Three.js and applying them to a mesh</li><li class="listitem" style="list-style-type: disc">Using bump and normal maps to apply depth and detail to a mesh</li><li class="listitem" style="list-style-type: disc">Creating fake shadows using a light map</li><li class="listitem" style="list-style-type: disc">Adding detailed reflection to a material using an environment map</li><li class="listitem" style="list-style-type: disc">Using a specular map to set the <span class="emphasis"><em>shininess</em></span> of specific parts of a mesh</li><li class="listitem" style="list-style-type: disc">Fine-tuning and customizing the UV mapping of a mesh</li><li class="listitem" style="list-style-type: disc">Using the HTML5 canvas and video element as input for a texture</li></ul></div><p>Let's start with the most basic example, where we show you how to load and apply a texture.</p><div class="section" title="Using textures in materials"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec51"/>Using textures in materials</h1></div></div></div><p>There are <a id="id956" class="indexterm"/>different ways textures are used in Three.js. You can use them to define the colors of the mesh, but you can also use them to define shininess, bumps, and reflections. The first example we look at, though, is the most basic approach, where we use a texture to define the colors of the individual pixels of a mesh.</p><div class="section" title="Loading a texture and applying it to a mesh"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec70"/>Loading a texture and applying it to a mesh</h2></div></div></div><p>The<a id="id957" class="indexterm"/> most basic usage of a texture is when it's set as a map <a id="id958" class="indexterm"/>on a material. When you use this material to create a mesh, the mesh will be colored based on the supplied texture.</p><p>Loading a texture and using it on a mesh can be done in the following manner:</p><div class="informalexample"><pre class="programlisting">function createMesh(geom, imageFile) {
  var texture = THREE.ImageUtils.loadTexture("../assets/textures/general/" + imageFile)

  var mat = new THREE.MeshPhongMaterial();
  mat.map = texture;

  var mesh = new THREE.Mesh(geom, mat);
  return mesh;
}</pre></div><p>In this code sample, we use the <code class="literal">THREE.ImageUtils.loadTexture</code> function to load an image file from a specific location. You can use PNG, GIF, or JPEG images as input for a texture. Note that loading textures is done asynchronously. In our scenario, this isn't an issue as we have a <code class="literal">render</code> loop where we render the scene around 60 times per second. If you want to wait until a texture is loaded, you could use the following approach:</p><div class="informalexample"><pre class="programlisting">texture = THREE.ImageUtils.loadTexture('texture.png', {}, function() { renderer.render(scene); });</pre></div><p>In this example, we supply a callback function to <code class="literal">loadTexture</code>. This callback is called when the texture is loaded. In our examples, we don't use the callback and rely on the <code class="literal">render</code> loop to eventually show the texture when it's loaded.</p><p>You can use pretty much any image you'd like as a texture. The best results, however, are when you use a square texture whose dimensions are a power of 2. So dimensions such as 256 x 256, 512 x 512, 1024 x 1024, and so on work the best. The following image is an example of a square texture:</p><div class="mediaobject"><img src="graphics/2215OS_10_01.jpg" alt="Loading a texture and applying it to a mesh"/></div><p>Since the pixels of a texture (also called <span class="strong"><strong>texels</strong></span>) usually<a id="id959" class="indexterm"/> don't map one-to-one on the pixels of the face, the<a id="id960" class="indexterm"/> texture needs to be magnified or minified. For this purpose, WebGL and Three.js offer a couple of different options. You can specify how the texture is magnified by setting the <code class="literal">magFilter</code> property and how it is minified with the <code class="literal">minFilter</code> property. These properties can be set to the following two basic values:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.NearestFilter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id961" class="indexterm"/> filter uses the color of the nearest texel that it can find. When used for magnification, this will result in blockiness, and when used for minification, the result will lose much detail.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.LinearFilter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id962" class="indexterm"/>filter is more advanced and uses the color value of the four neighboring texels to determine the correct color. You'll still lose much detail in minification, but the magnification will be much smoother and less blocky.</p>
</td></tr></tbody></table></div><p>Besides these basic values, we can also use a mipmap. A <span class="strong"><strong>mipmap</strong></span><a id="id963" class="indexterm"/> is a set of texture images, each half the size of the previous one. These are created when you load the texture and allow much smoother filtering. So, when you've got a square texture (as a power of 2), you can use a couple of additional approaches for better filtering. The properties can be set using the following values:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.NearestMipMapNearestFilter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id964" class="indexterm"/>property selects the mipmap that best maps the required resolution and applies the nearest filter principle that we discussed in the previous table. Magnification is still blocky, but minification looks much better.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.NearestMipMapLinearFilter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id965" class="indexterm"/>property selects not just a single mipmap but the two nearest mipmap levels. On both these levels, a nearest filter is applied to get two intermediate results. These two results are passed through a linear filter to get the final result. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.LinearMipMapNearestFilter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id966" class="indexterm"/> property selects the mipmap that best maps the required resolution and applies the linear filter principle we discussed in the previous table.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.LinearMipMapLinearFilter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id967" class="indexterm"/> property selects not a single mipmap but the two nearest mipmap levels. On both these levels, a linear filter is applied to get two intermediate results. These two results are passed through a linear filter to get the final result.</p>
</td></tr></tbody></table></div><p>If you don't specify the <code class="literal">magFilter</code> and <code class="literal">minFilter</code> properties explicitly, Three.js uses <code class="literal">THREE.LinearFilter</code> as the default for the <code class="literal">magFilter</code> property and <code class="literal">THREE.LinearMipMapLinearFilter</code> as the default for the <code class="literal">minFilter</code> property. In our examples, we'll just use these <a id="id968" class="indexterm"/>default properties. An example for the basic texture can be found in <code class="literal">01-basic-texture.html</code>. The following screenshot shows this example:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_02.jpg" alt="Loading a texture and applying it to a mesh"/></div><p>
</p><p>In this example, we load a couple of textures (using the code you saw earlier) and apply them to various shapes. In this example, you can see that the textures nicely wrap around the shapes. When you create geometries in Three.js, it makes sure that any texture that is used is applied correctly. This is done by something called <span class="strong"><strong>UV mapping</strong></span><a id="id969" class="indexterm"/> (more on this later in this chapter). With UV mapping, we tell the renderer which part of a texture should be applied to a specific face. The easiest example for this is the cube. The UV mapping for one of the faces looks like this:</p><div class="informalexample"><pre class="programlisting">(0,1),(0,0),(1,0),(1,1)</pre></div><p>This means that we use the complete texture (UV values range from 0 to 1) for this face.</p><p>Besides the standard image formats we can load with <code class="literal">THREE.ImageUtils.loadTexture</code>, Three.js also provides a couple of custom loaders you can use to load textures provided in different formats. The following table shows the additional loaders you can use:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.DDSLoader</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With<a id="id970" class="indexterm"/> this loader, you can load textures that are provided in the DirectDraw Surface format. This format is a proprietary Microsoft format to store compressed textures. Using this loader is very easy. First, include the <code class="literal">DDSLoader.js</code> file in your HTML page and then use the following to use a texture:
</p><div class="informalexample"><pre class="programlisting">var loader = new THREE.DDSLoader();
var texture = loader.load( '../assets/textures/  seafloor.dds' );

var mat = new THREE.MeshPhongMaterial();
mat.map = texture;</pre></div>
<p>You can see an example of this loader in the sources for this chapter in <code class="literal">01-basic-texture-dds.html</code>. Internally, this loader uses <code class="literal">THREE.CompressedTextureLoader</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.PVRLoader</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Power VR<a id="id971" class="indexterm"/> is another proprietary file format to store compressed textures. Three.js supports the Power VR 3.0 file format and can use textures provided in this format. To use this loader, include the <code class="literal">PVRLoader.js</code> file in your HTML page and then use the following to use a texture:
</p><div class="informalexample"><pre class="programlisting">var loader = new THREE.DDSLoader();
var texture = loader.load( '../assets/textures/ seafloor.dds' );

var mat = new THREE.MeshPhongMaterial();
mat.map = texture;</pre></div>
<p>You can see an example of this loader in the sources for this chapter: <code class="literal">01-basic-texture-pvr.html</code>. Note that not all WebGL implementations support textures in this format. So when you use this and don't see a texture, check the console for errors. Internally, this loader also uses <code class="literal">THREE.CompressedTextureLoader</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">THREE.TGALoader</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Targa<a id="id972" class="indexterm"/> is a raster graphics file format that is still used by a large number of 3D software programs. With the <code class="literal">THREE.TGALoader</code> object, you can use textures provided in this format with your 3D models. To use these image files, you first have to include the <code class="literal">TGALoader.js</code> file in your HTML, and then you can use the following to load a TGA texture:
</p><div class="informalexample"><pre class="programlisting">var loader = new THREE.TGALoader();
var texture = loader.load( '../assets/textures/crate_color8.tga' );

var mat = new THREE.MeshPhongMaterial();
mat.map = texture;</pre></div>
<p>An example of this loader is provided in the sources of this chapter. You can view this example by opening <code class="literal">01-basic-texture-tga.html</code> in your browser.</p>
</td></tr></tbody></table></div><p>In these examples, we've used textures to define the color of the pixels of our mesh. We can also use textures<a id="id973" class="indexterm"/> for other purposes. The following two examples are used to define how shading is applied to a material. You use this to create bumps and wrinkles on the surface of a mesh.</p></div><div class="section" title="Using a bump map to create wrinkles"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec71"/>Using a bump map to create wrinkles</h2></div></div></div><p>A <span class="strong"><strong>bump map</strong></span><a id="id974" class="indexterm"/> is used <a id="id975" class="indexterm"/>to add more depth to a material. You can see this in action by opening up the <code class="literal">02-bump-map.html</code> example. Refer to the following screenshot to see the example:</p><div class="mediaobject"><img src="graphics/2215OS_10_03.jpg" alt="Using a bump map to create wrinkles"/></div><p>In this example, you can see that the left-hand side wall looks much more detailed and seems to have much more depth when you compare it with the wall on the right-hand side. This is done by setting an additional texture, a so-called bump map, on the material:</p><div class="informalexample"><pre class="programlisting">function createMesh(geom, imageFile, bump) {
  var texture = THREE.ImageUtils.loadTexture("../assets/textures/general/" + imageFile)
  var mat = new THREE.MeshPhongMaterial();
  mat.map = texture;

  var bump = THREE.ImageUtils.loadTexture(
    "../assets/textures/general/" + bump)
  mat.bumpMap = bump;
  mat.bumpScale = 0.2;


  var mesh = new THREE.Mesh(geom, mat);
  return mesh;
}</pre></div><p>You can see<a id="id976" class="indexterm"/> in this code that besides <a id="id977" class="indexterm"/>setting the <code class="literal">map</code> property, we also set the <code class="literal">bumpMap</code> property to a texture. Additionally, with the <code class="literal">bumpScale</code> property, we can set the height (or depth if set to a negative value) of the bumps. The textures used in this example are shown here:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_04.jpg" alt="Using a bump map to create wrinkles"/></div><p>
</p><p>The bump map is a grayscale image, but you can also use a color image. The intensity of the pixel defines the height of the bump. A bump map only contains the relative height of a pixel. It doesn't say anything about the direction of the slope. So the level of detail and perception of depth that you can reach with a bump map is limited. For more details, you can use a normal map.</p></div><div class="section" title="Achieving more detailed bumps and wrinkles with a normal map"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec72"/>Achieving more detailed bumps and wrinkles with a normal map</h2></div></div></div><p>In a <a id="id978" class="indexterm"/>normal map, the <a id="id979" class="indexterm"/>height (displacement) is not stored, but the direction of the normal for each picture is stored. Without going into too much detail, with normal maps, you can create very detailed-looking models that still only use a small number of vertices and faces. For instance, have a look at the <code class="literal">03-normal-map.html</code> example. The following screenshot depicts this example:</p><div class="mediaobject"><img src="graphics/2215OS_10_05.jpg" alt="Achieving more detailed bumps and wrinkles with a normal map"/></div><p>In this screenshot, you can see a very detailed plastered cube to the left. The light source moves around the cubes, and you can see that the texture responds naturally to the light source. This provides a very realistic-looking model and only requires a very simple model and a couple of textures. The following code fragment shows how to use a normal map in Three.js:</p><div class="informalexample"><pre class="programlisting">function createMesh(geom, imageFile, normal) {
  var t = THREE.ImageUtils.loadTexture("../assets/textures/general/" + imageFile);
  var m = THREE.ImageUtils.loadTexture("../assets/textures/general/" + normal);

  var mat2 = new THREE.MeshPhongMaterial();
  mat2.map = t;
  mat2.normalMap = m;

  var mesh = new THREE.Mesh(geom, mat2);
  return mesh;
}</pre></div><p>The same approach <a id="id980" class="indexterm"/>is used here as was done for the bump map. This time, though, we set the <code class="literal">normalMap</code> property to the normal texture. We can also define how pronounced the bumps look by setting the <code class="literal">normalScale</code> property <code class="literal">mat.normalScale.set(1,1)</code>. With these two properties, you can scale along the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes. The best approach, though, is to keep these values the same for the best effect. Note that once again, when<a id="id981" class="indexterm"/> these values are below zero, the heights inverse. The following screenshot shows both the texture (on the left-hand side) and the normal map (on the right-hand side):</p><div class="mediaobject"><img src="graphics/2215OS_10_06.jpg" alt="Achieving more detailed bumps and wrinkles with a normal map"/></div><p>The problem with normal maps, however, is that they aren't very easy to create. You need to use specialized tools, such as Blender or Photoshop. They can use high-resolution renderings or textures as input and create normal maps from them.</p><p>Three.js also provides a way to do this during runtime. The <code class="literal">THREE.ImageUtils</code> object has a function called <code class="literal">getNormalMap</code>, which takes a JavaScript/DOM <code class="literal">Image</code> as input and converts it into a normal map.</p></div><div class="section" title="Creating fake shadows using a light map"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec73"/>Creating fake shadows using a light map</h2></div></div></div><p>In<a id="id982" class="indexterm"/> the<a id="id983" class="indexterm"/> previous examples, we used specific maps to create real-looking shadows that react to the lighting in the room. There is an alternative option to create <a id="id984" class="indexterm"/>fake shadows. In this section, we'll use a light map. A <a id="id985" class="indexterm"/>
<span class="strong"><strong>light map</strong></span> is a pre-rendered <a id="id986" class="indexterm"/>shadow (also called a prebaked shadow) that you can use to create the illusion of a real shadow. The following screenshot, from the <code class="literal">04-light-map.html</code> example, shows how this looks:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_07.jpg" alt="Creating fake shadows using a light map"/></div><p>
</p><p>If you look <a id="id987" class="indexterm"/>at the previous example, it shows a couple of very nice shadows, which seem to be cast by the two cubes. These shadows, however, are based on a light map texture that looks like the following:</p><div class="mediaobject"><img src="graphics/2215OS_10_08.jpg" alt="Creating fake shadows using a light map"/></div><p>As you can see, the shadows, as specified in the light map, are also shown as the shadows on the ground plane, creating the illusion of real shadows. You can use this technique to create high-resolution shadows, without incurring a heavy rendering penalty. This, of course, only works for static scenes. Using a light map is pretty much the same as using other textures with a couple of small differences. This is how we go about using a light map:</p><div class="informalexample"><pre class="programlisting">var lm = THREE.ImageUtils.loadTexture('../assets/textures/lightmap/lm-1.png');
var wood = THREE.ImageUtils.loadTexture('../assets/textures/general/floor-wood.jpg');
var groundMaterial = new THREE.MeshBasicMaterial({lightMap: lm, map: wood});
groundGeom.faceVertexUvs[1] = groundGeom.faceVertexUvs[0];</pre></div><p>To apply <a id="id988" class="indexterm"/>a light map, we just need to set the <code class="literal">lightMap</code> property of the material to the light map we just showed. There is, however, an additional step required to get the light map to show up. We need to <a id="id989" class="indexterm"/>explicitly define the UV mapping (what part of the texture is shown on a face) for the light map. This needs to be done so that you<a id="id990" class="indexterm"/> can apply and map the light map independently of the other textures. In our example, we just use the basic UV mapping, automatically created by Three.js when we created the ground plane. More information and a background of why an <a id="id991" class="indexterm"/>explicit UV mapping is required can be found at <a class="ulink" href="http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op">http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op</a>.</p><p>When the shadow map is positioned correctly, we need to place the cubes in the correct location so that it looks as though the shadows are being cast by them.</p><p>Three.js provides another texture that you can use to fake advanced 3D effects. In the next section, we'll look at using environment maps for fake reflections.</p></div><div class="section" title="Creating fake reflections using an environment map"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec74"/>Creating fake reflections using an environment map</h2></div></div></div><p>Calculating <a id="id992" class="indexterm"/>environment<a id="id993" class="indexterm"/> reflections is very CPU-intensive and usually requires a ray tracer approach. If you want to use reflections in<a id="id994" class="indexterm"/> Three.js, you can still do that, but you'll have to fake it. You can do this by creating a texture of the environment the object is in and apply this to the specific object. First, we'll show you the result we're aiming for (see <code class="literal">05-env-map-static.html</code>, which is also shown in the following screenshot):</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_09.jpg" alt="Creating fake reflections using an environment map"/></div><p>
</p><p>In this<a id="id995" class="indexterm"/> screenshot, you can see the sphere and cube reflect the environment. If you move your mouse around, you<a id="id996" class="indexterm"/> can also see that the reflection <a id="id997" class="indexterm"/>corresponds with the camera angle in relation to the city environment you see. To create this example, we perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Create a CubeMap object</strong></span>: The <a id="id998" class="indexterm"/>first thing we need to do is create a <code class="literal">CubeMap</code> object. <code class="literal">CubeMap</code> is a set of six textures that can be applied to each side of a cube.</li><li class="listitem"><span class="strong"><strong>Create a box with this CubeMap object</strong></span>: The <a id="id999" class="indexterm"/>box with <code class="literal">CubeMap</code> is the environment you see when you move the camera around. It gives the illusion that you're standing in an environment where you can look around. In reality, you're inside a cube with textures rendered on the inside to give an illusion of space.</li><li class="listitem"><span class="strong"><strong>Apply the CubeMap object as a texture</strong></span>: The<a id="id1000" class="indexterm"/> same <code class="literal">CubeMap</code> object we used to simulate the environment can be used as a texture on the meshes. Three.js will make sure it looks like a reflection of the environment.</li></ol></div><p>Creating <code class="literal">CubeMap</code> is pretty easy once you've got the source material. What you need are six images that together make up a complete environment. So you need the following pictures: looking forward (<code class="literal">posz</code>), looking backward (<code class="literal">negz</code>), looking up (<code class="literal">posy</code>), looking down (<code class="literal">negy</code>), looking right (<code class="literal">posx</code>), and looking left (<code class="literal">negx</code>). Three.js will patch these together to create a seamless environment map. There are a couple of sites where you can download these pictures. The ones used in this example are from <a class="ulink" href="http://www.humus.name/index.php?page=Textures">http://www.humus.name/index.php?page=Textures</a>.</p><p>Once you've got the six separate pictures, you can load them as shown in the following code fragment:</p><div class="informalexample"><pre class="programlisting">function createCubeMap() {

  var path = "../assets/textures/cubemap/parliament/";
  var format = '.jpg';
  var urls = [
    path + 'posx' + format, path + 'negx' + format,
    path + 'posy' + format, path + 'negy' + format,
    path + 'posz' + format, path + 'negz' + format
  ];

  var textureCube = THREE.ImageUtils.loadTextureCube( urls );
  return textureCube;
}</pre></div><p>We again <a id="id1001" class="indexterm"/>use<a id="id1002" class="indexterm"/> the <code class="literal">THREE.ImageUtils</code> JavaScript object, but this time, we pass in an array of textures and create the <code class="literal">CubeMap</code> object using the <code class="literal">loadTextureCube</code> function. If you've already got a <a id="id1003" class="indexterm"/>360-degree panoramic image, you can also convert that into a set of images you can use to create <code class="literal">CubeMap</code>. Just go to <a class="ulink" href="http://gonchar.me/panorama/">http://gonchar.me/panorama/</a> to convert an image, and you end up with six images with names like <code class="literal">right.png</code>, <code class="literal">left.png</code>, <code class="literal">top.png</code>, <code class="literal">bottom.png</code>, <code class="literal">front.png</code>, and <code class="literal">back.png</code>. You can use these by creating the <code class="literal">urls</code> variable like this:</p><div class="informalexample"><pre class="programlisting">var urls = [
  'right.png',
  'left.png',
  'top.png',
  'bottom.png',
  'front.png',
  'back.png'
];</pre></div><p>Alternatively, you can also let Three.js handle the conversion when you load the scene by creating <code class="literal">textureCube</code> like this:</p><div class="informalexample"><pre class="programlisting">var textureCube = THREE.ImageUtils.loadTexture("360-degrees.png", new THREE.UVMapping());</pre></div><p>With <code class="literal">CubeMap</code>, we first create a box, which can be created like this:</p><div class="informalexample"><pre class="programlisting">var textureCube = createCubeMap();
var shader = THREE.ShaderLib[ "cube" ];
shader.uniforms[ "tCube" ].value = textureCube;
var material = new THREE.ShaderMaterial( {
  fragmentShader: shader.fragmentShader,
  vertexShader: shader.vertexShader,
  uniforms: shader.uniforms,
  depthWrite: false,
  side: THREE.BackSide
});
cubeMesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100), material);</pre></div><p>Three.js <a id="id1004" class="indexterm"/>provides a specific shader that we can use with <code class="literal">THREE.ShaderMaterial</code> to create an environment <a id="id1005" class="indexterm"/>based on <code class="literal">CubeMap</code> (<code class="literal">var shader = THREE.ShaderLib[ "cube" ];</code>). We configure this shader with <code class="literal">CubeMap</code>, create a <a id="id1006" class="indexterm"/>mesh, and add it to the scene. This mesh, if seen from the inside, represents the fake environment we're standing in.</p><p>This same <code class="literal">CubeMap</code> object should be applied to the meshes we want to render to create the fake reflection:</p><div class="informalexample"><pre class="programlisting">var sphere1 = createMesh(new THREE.SphereGeometry(10, 15, 15), "plaster.jpg");
sphere1.material.envMap = textureCube;
sphere1.rotation.y = -0.5;
sphere1.position.x = 12;
sphere1.position.y = 5;
scene.add(sphere1);

var cube = createMesh(new THREE.CubeGeometry(10, 15, 15), "plaster.jpg","plaster-normal.jpg");
sphere2.material.envMap = textureCube;
sphere2.rotation.y = 0.5;
sphere2.position.x = -12;
sphere2.position.y = 5;
scene.add(cube);</pre></div><p>As you can see, we set the <code class="literal">envMap</code> property of the material to the <code class="literal">cubeMap</code> object we created. The result is a scene where it looks like we're standing in a wide, outdoors environment, where the meshes reflect this environment. If you use the sliders, you can set the <code class="literal">reflectivity</code> property of the material, and, as the name implies, this determines how much of the environment is reflected by the material.</p><p>Besides reflection, Three.js also allows you to use a <code class="literal">CubeMap</code> object for refraction (glass-like objects). The following screenshot shows this:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_10.jpg" alt="Creating fake reflections using an environment map"/></div><p>
</p><p>To get this effect, we just need to change the loading of the textures to this:</p><div class="informalexample"><pre class="programlisting">var textureCube = THREE.ImageUtils.loadTextureCube( urls, new THREE.CubeRefractionMapping());</pre></div><p>You can<a id="id1007" class="indexterm"/> control the <code class="literal">refraction</code> ratio with the <code class="literal">refraction</code> property on the material, just as with the <code class="literal">reflection</code> property. In<a id="id1008" class="indexterm"/> this example, we've <a id="id1009" class="indexterm"/>used a static environment map for the meshes. In other words, we only saw the environment reflection and not the other meshes in this environment. In the following screenshot (which you can see in action by opening <code class="literal">05-env-map-dynamic.html</code> in your browser), we'll show you how you can create a reflection that also shows the other objects in the scene:</p><div class="mediaobject"><img src="graphics/2215OS_10_22.jpg" alt="Creating fake reflections using an environment map"/></div><p>To also<a id="id1010" class="indexterm"/> show reflections from the other objects in the scene, we need to use some other Three.js components. The first thing we need is an additional camera called <code class="literal">THREE.CubeCamera</code>:</p><div class="informalexample"><pre class="programlisting">Var cubeCamera = new THREE.CubeCamera(0.1, 20000, 256);
scene.add(cubeCamera);</pre></div><p>We will <a id="id1011" class="indexterm"/>use <code class="literal">THREE.CubeCamera</code> to take a snapshot of the scene with all the objects rendered, and use that to set up <code class="literal">CubeMap</code>. You<a id="id1012" class="indexterm"/> need to make sure you position this camera at the exact location of <code class="literal">THREE.Mesh</code> on which you want to show the dynamic reflections. For this example, we'll only show reflections on the center sphere (as you can see in the previous screenshot). This sphere is located at the position 0, 0, 0, so for this example, we don't need to explicitly position <code class="literal">THREE.CubeCamera</code>.</p><p>We only apply the dynamic reflections to the sphere, so we're going to need two different materials:</p><div class="informalexample"><pre class="programlisting">var dynamicEnvMaterial = new THREE.MeshBasicMaterial({envMap: cubeCamera.renderTarget });
var envMaterial = new THREE.MeshBasicMaterial({envMap: textureCube });</pre></div><p>The main difference with our previous example is that for the dynamic reflections, we set the <code class="literal">envMap</code> property to <code class="literal">cubeCamera.renderTarget</code> instead of to <code class="literal">textureCube</code>, which we created <a id="id1013" class="indexterm"/>earlier. For<a id="id1014" class="indexterm"/> this example, we use <code class="literal">dynamicEnvMaterial</code> on the central sphere and <code class="literal">envMaterial</code> for the other two objects:</p><div class="informalexample"><pre class="programlisting">sphere = new THREE.Mesh(sphereGeometry, dynamicEnvMaterial);
sphere.name = 'sphere';
scene.add(sphere);

var cylinder = new THREE.Mesh(cylinderGeometry, envMaterial);
cylinder.name = 'cylinder';
scene.add(cylinder);
cylinder.position.set(10, 0, 0);

var cube = new THREE.Mesh(boxGeometry, envMaterial);
cube.name = 'cube';
scene.add(cube);
cube.position.set(-10, 0, 0);</pre></div><p>All that is<a id="id1015" class="indexterm"/> left to do is make sure <code class="literal">cubeCamera</code> renders the scene, so we can use that output as input for the center sphere. To do this, we update the <code class="literal">render</code> loop like this:</p><div class="informalexample"><pre class="programlisting">function render() {
  sphere.visible = false;
  cubeCamera.updateCubeMap( renderer, scene );
  sphere.visible = true;
  renderer.render(scene, camera);
  ...
  requestAnimationFrame(render);
}</pre></div><p>As you can see, we first disable the visibility of <code class="literal">sphere</code>. We do this because we only want to see reflections from the other two objects. Next, we render the scene using <code class="literal">cubeCamera</code> by calling the <code class="literal">updateCubeMap</code> function. After that, we make <code class="literal">sphere</code> visible again and render the scene as normal. The result is that in the reflection of the sphere, you can see the reflections of the cube and the cylinder.</p><p>The last of the basic materials we'll look at is the specular map.</p></div><div class="section" title="Specular map"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec75"/>Specular map</h2></div></div></div><p>With a<a id="id1016" class="indexterm"/> <span class="strong"><strong>specular map</strong></span>, you<a id="id1017" class="indexterm"/> can <a id="id1018" class="indexterm"/>specify a map that defines the shininess and the highlight color of a material. For instance, in the following screenshot, we've used a specular map together with a normal map to render a globe. You can see this example if you open <code class="literal">06-specular-map.html</code> in your browser. The result of this is also shown<a id="id1019" class="indexterm"/> in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_10_11.jpg" alt="Specular map"/></div><p>In this screenshot, you can see that the oceans are highlighted and reflect light. The continents, on <a id="id1020" class="indexterm"/>the other hand, are very dark and don't reflect (much) light. For this effect, we didn't use any specific normal textures, but only a normal map to show heights and the following specular map to highlight the oceans:</p><div class="mediaobject"><img src="graphics/2215OS_10_12.jpg" alt="Specular map"/></div><p>Basically, what happens is that the higher the value of the pixel (from black to white), the shinier the surface will appear. A specular map is usually used together with the <code class="literal">specular</code> property<a id="id1021" class="indexterm"/> that you can use to determine the color of the reflection. In this case, it is set to red:</p><div class="informalexample"><pre class="programlisting">var specularTexture=THREE.ImageUtils.loadTexture("../assets/textures/planets/EarthSpec.png");
var normalTexture=THREE.ImageUtils.loadTexture("../assets/textures/planets/EarthNormal.png");

var planetMaterial = new THREE.MeshPhongMaterial();
planetMaterial.specularMap = specularTexture;
planetMaterial.specular = new THREE.Color( 0xff0000 );
planetMaterial.shininess = 1;

planetMaterial.normalMap = normalTexture;</pre></div><p>Also note that<a id="id1022" class="indexterm"/> the best effects are usually realized with low shininess, but depending on the lighting and the specular map you use, you might need to experiment to get the desired effect.</p></div></div></div>
<div class="section" title="Advanced usage of textures"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec52"/>Advanced usage of textures</h1></div></div></div><p>In the previous<a id="id1023" class="indexterm"/> section, we saw some basic texture usages. Three.js also provides options for more advanced texture usage. In this section, we'll look at a couple of options that Three.js provides.</p><div class="section" title="Custom UV mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec76"/>Custom UV mapping</h2></div></div></div><p>We'll <a id="id1024" class="indexterm"/>start off with a deeper look at UV mappings. We <a id="id1025" class="indexterm"/>explained earlier that with UV mapping, you can specify what part of a texture is shown on a specific face. When you create a geometry in Three.js, these mappings will also be automatically created based on the type of geometry you created. In most cases, you don't really need to change this default UV mapping. A good way to understand how UV mapping works is to look at an example from Blender, which is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_10_13.jpg" alt="Custom UV mapping"/></div><p>In this <a id="id1026" class="indexterm"/>example, you <a id="id1027" class="indexterm"/>see two windows. The window on the left-hand side contains a cube geometry. The window on the right-hand side is the UV mapping, where we've loaded an example texture to show how the mapping is. In this example, we've selected a single face for the window on the left-hand side and the window on the right-hand side shows the UV mapping for this face. As you can see, each vertex of the face is positioned in one of the corners of the UV mapping on the right (the small circles). This means that the complete texture will be used for that face. All the other faces of this cube are mapped in the same manner, so the result will show a cube where each face shows the complete texture; see <code class="literal">07-uv-mapping.html</code>, which is also shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_10_14.jpg" alt="Custom UV mapping"/></div><p>This is <a id="id1028" class="indexterm"/>the <a id="id1029" class="indexterm"/>default for a cube in Blender (also in Three.js). Let's change the UV by selecting only two-thirds of the texture (see the selected area in the following screenshot):</p><div class="mediaobject"><img src="graphics/2215OS_10_15.jpg" alt="Custom UV mapping"/></div><p>If we <a id="id1030" class="indexterm"/>now<a id="id1031" class="indexterm"/> show this in Three.js, you can see that the texture is applied differently, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2215OS_10_16.jpg" alt="Custom UV mapping"/></div><p>Customizing UV mappings is normally done from programs such as Blender, especially when the models<a id="id1032" class="indexterm"/> become more complex. The most important part to remember here is that UV mappings run in two dimensions, <code class="literal">u</code> and <code class="literal">v</code>, from 0 to 1. To customize the UV mapping, you <a id="id1033" class="indexterm"/>need to define, for each face, what part of the texture should be shown. You do this by defining the <code class="literal">u</code> and <code class="literal">v</code> coordinates for each of the vertices that make up the face. You can use the following code to set the <code class="literal">u</code> and <code class="literal">v</code> values:</p><div class="informalexample"><pre class="programlisting">geom.faceVertexUvs[0][0][0].x = 0.5;
geom.faceVertexUvs[0][0][0].y = 0.7;
geom.faceVertexUvs[0][0][1].x = 0.4;
geom.faceVertexUvs[0][0][1].y = 0.1;
geom.faceVertexUvs[0][0][2].x = 0.4;
geom.faceVertexUvs[0][0][2].y = 0.5;</pre></div><p>This code snippet will set the <code class="literal">uv</code> properties of the first face to the specified value. Remember that each face is defined by three vertices, so to set all the <code class="literal">uv</code> values for a face, we need to set six properties. If you open the <code class="literal">07-uv-mapping-manual.html,</code> example you can see what happens when you change the <code class="literal">uv</code> mappings manually. The following screenshot shows the example:</p><div class="mediaobject"><img src="graphics/2215OS_10_23.jpg" alt="Custom UV mapping"/></div><p>Next, we'll look at how textures can be repeated, which is done by some internal UV mapping tricks.</p></div><div class="section" title="Repeat wrapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec77"/>Repeat wrapping</h2></div></div></div><p>When<a id="id1034" class="indexterm"/> you apply a texture to a geometry created by Three.js, Three.js <a id="id1035" class="indexterm"/>will try to apply the texture as optimally as possible. For instance, for cubes, this means each side will show the complete texture, and for spheres, the complete texture is wrapped around the sphere. There are, however, situations where you don't want the texture to spread around a complete face or the complete geometry, but have the texture repeat itself. Three.js provides detailed functionality that allows you to control this. An example where you can play around with the repeat properties is provided in the <code class="literal">08-repeat-wrapping.html</code> example. The following screenshot shows this example:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_17.jpg" alt="Repeat wrapping"/></div><p>
</p><p>In this example, you can set the property that controls how a texture repeats itself.</p><p>Before this property has the desired effect, you need to make sure you set the wrapping of the texture to <code class="literal">THREE.RepeatWrapping</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">cube.material.map.wrapS = THREE.RepeatWrapping;
cube.material.map.wrapT = THREE.RepeatWrapping;</pre></div><p>The <code class="literal">wrapS</code> property <a id="id1036" class="indexterm"/>defines how you want the texture to behave along its <span class="emphasis"><em>x</em></span> axis and the <code class="literal">wrapT</code> property defines how the texture should behave along its <span class="emphasis"><em>y</em></span> axis. Three.js provides two options for this, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.RepeatWrapping</code><a id="id1037" class="indexterm"/> allows the texture to repeat itself.</li><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.ClampToEdgeWrapping</code> is <a id="id1038" class="indexterm"/>a default setting. With <code class="literal">THREE.ClampToEdgeWrapping,</code> the texture doesn't repeat as a whole, but only the pixels at the edge are repeated.</li></ul></div><p>If you disable the <span class="strong"><strong>repeatWrapping</strong></span> menu option, the <code class="literal">THREE.ClampToEdgeWrapping</code> option is used, as follows:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_18.jpg" alt="Repeat wrapping"/></div><p>
</p><p>If we use <code class="literal">THREE.RepeatWrapping</code>, we can set the <code class="literal">repeat</code> property as shown in the following code fragment:</p><div class="informalexample"><pre class="programlisting">cube.material.map.repeat.set(repeatX, repeatY);</pre></div><p>The <code class="literal">repeatX</code> variable<a id="id1039" class="indexterm"/> defines how often the texture is repeated along its <span class="emphasis"><em>x</em></span> axis and the <code class="literal">repeatY</code> variable defines the same for the <span class="emphasis"><em>y</em></span> axis. If these values are <a id="id1040" class="indexterm"/>set to <code class="literal">1</code>, the texture won't repeat itself; if they are set to a higher value, you'll see that the texture will start repeating. You can also use values less than 1. In that case, you can see that you'll zoom in on the texture. If you set the repeat value to a negative value, the texture will be mirrored.</p><p>When you change the <code class="literal">repeat</code> property, Three.js will automatically update the textures and render with this new setting. If you change from <code class="literal">THREE.RepeatWrapping</code> to <code class="literal">THREE.ClampToEdgeWrapping</code>, you need to explicitly update the texture:</p><div class="informalexample"><pre class="programlisting">cube.material.map.needsUpdate = true;</pre></div><p>Until now, we've only used static images for our textures. Three.js, however, also has the option to use the HTML5 canvas as a texture.</p></div><div class="section" title="Rendering to canvas and using it as a texture"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec78"/>Rendering to canvas and using it as a texture</h2></div></div></div><p>In this section, we're going to look at two different examples. First, we're going to look at how you can<a id="id1041" class="indexterm"/> use the canvas to create a simple texture and apply it to a mesh, and after that, we'll go one step further and create a canvas that can be used as a bump map using a randomly generated pattern.</p><div class="section" title="Using the canvas as a texture"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec31"/>Using the canvas as a texture</h3></div></div></div><p>In the first <a id="id1042" class="indexterm"/>example, we <a id="id1043" class="indexterm"/>will use the <span class="strong"><strong>Literally</strong></span> library (from <a class="ulink" href="http://literallycanvas.com/">http://literallycanvas.com/</a>) to create an interactive canvas that you can draw on; see the bottom-left corner in the following screenshot. You can view this example at <code class="literal">09-canvas-texture</code>. The ensuing screenshot shows this example:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_19.jpg" alt="Using the canvas as a texture"/></div><p>
</p><p>Anything you draw on this canvas is directly rendered on the cube as a texture. Accomplishing this in Three.js is really simple and only takes a couple of steps. The first thing we need to do is create a canvas element and, for this specific example, configure it to be used with the <code class="literal">Literally</code> library, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div class="fs-container"&gt;
  &lt;div id="canvas-output" style="float:left"&gt;
  &lt;/div&gt;
&lt;/div&gt;
...
var canvas = document.createElement("canvas");
$('#canvas-output')[0].appendChild(canvas);
$('#canvas-output').literallycanvas(
  {imageURLPrefix: '../libs/literally/img'});</pre></div><p>We just<a id="id1044" class="indexterm"/> create a <code class="literal">canvas</code> element from JavaScript and add it to a specific <code class="literal">div</code> element. With the <code class="literal">literallycanvas</code> call, we can create the drawing tools that you can use to directly draw on the canvas. Next, we need to create a texture that uses the canvas drawing as its input:</p><div class="informalexample"><pre class="programlisting">function createMesh(geom) {

  var canvasMap = new THREE.Texture(canvas);
  var mat = new THREE.MeshPhongMaterial();
  mat.map = canvasMap;
  var mesh = new THREE.Mesh(geom,mat);

  return mesh;
}</pre></div><p>As the code shows, the only thing you need to do to is pass in the reference to the canvas element when you create a new texture, <code class="literal">new THREE.Texture(canvas)</code>. This will create a texture that uses the canvas element as its material. All that is left is to update the material whenever we render so that the latest version of the canvas drawing is shown on the cube, as follows:</p><div class="informalexample"><pre class="programlisting">function render() {
  stats.update();

  cube.rotation.y += 0.01;
  cube.rotation.x += 0.01;

  cube.material.map.needsUpdate = true;
  requestAnimationFrame(render);
  webGLRenderer.render(scene, camera);
}</pre></div><p>To inform Three.js that we want to update the texture, we just set the <code class="literal">needsUpdate</code> property of the texture to <code class="literal">true</code>. In this example, we've used the canvas element as input for the most simple of textures. We can, of course, use this same idea for all the different types of maps we've seen so far. In the next example, we'll use it as a bump map.</p></div><div class="section" title="Using the canvas as a bump map"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec32"/>Using the canvas as a bump map</h3></div></div></div><p>As we've seen<a id="id1045" class="indexterm"/> earlier in this chapter, we can create a simple wrinkled texture with a bump map. The higher the intensity of a pixel in this map, the higher the wrinkling. Since a bump map is just a simple black-and-white image, nothing keeps us from creating this on a canvas and using that canvas as an input for the bump map.</p><p>In the following<a id="id1046" class="indexterm"/> example, we use a canvas to generate a random grayscale image, and we use that image as an input for the bump map we apply to the cube. See the <code class="literal">09-canvas-texture-bumpmap.html</code> example. The following screenshot shows this example:</p><p> </p><div class="mediaobject"><img src="graphics/2215OS_10_20.jpg" alt="Using the canvas as a bump map"/></div><p>
</p><p>The JavaScript code required for this is not that different from the previous example we explained. We need to create a canvas element and fill this canvas with some random noise. For the noise, we use<a id="id1047" class="indexterm"/> <span class="strong"><strong>Perlin noise</strong></span>. Perlin noise (<a class="ulink" href="http://en.wikipedia.org/wiki/Perlin_noise">http://en.wikipedia.org/wiki/Perlin_noise</a>) generates<a id="id1048" class="indexterm"/> a very natural-looking random texture as you can see in the preceding screenshot. We use the Perlin noise function from <a class="ulink" href="https://github.com/wwwtyro/perlin.js">https://github.com/wwwtyro/perlin.js</a> for this:</p><div class="informalexample"><pre class="programlisting">var ctx = canvas.getContext("2d");
function fillWithPerlin(perlin, ctx) {

  for (var x = 0; x &lt; 512; x++) {
    for (var y = 0; y &lt; 512; y++) {
      var base = new THREE.Color(0xffffff);
      var value = perlin.noise(x / 10, y / 10, 0);
      base.multiplyScalar(value);
      ctx.fillStyle = "#" + base.getHexString();
      ctx.fillRect(x, y, 1, 1);
    }
  }
}</pre></div><p>We use the <code class="literal">perlin.noise</code> function<a id="id1049" class="indexterm"/> to create a value from 0 to 1 based on the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates of <a id="id1050" class="indexterm"/>the canvas element. This value is used to draw a single pixel on the canvas element. Doing this for all the pixels creates the random map you can also see in the bottom-left corner of the previous screenshot. This map can then be easily used as a bump map. Here's how the random map can be created:</p><div class="informalexample"><pre class="programlisting">var bumpMap = new THREE.Texture(canvas);

var mat = new THREE.MeshPhongMaterial();
mat.color = new THREE.Color(0x77ff77);
mat.bumpMap = bumpMap;
bumpMap.needsUpdate = true;

var mesh = new THREE.Mesh(geom, mat);
return mesh;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>In this example, we've rendered Perlin noise using an HTML canvas element. Three.js also provides an alternative way to dynamically create a texture. The <code class="literal">THREE.ImageUtils</code> object has a <code class="literal">generateDataTexture</code> function, which you can use to create a <code class="literal">THREE.DataTexture</code> texture of a specific size. This texture contains <code class="literal">Uint8Array</code> in the <code class="literal">image.data</code> property, which you can use to directly set the RGB values of this texture.</p></div></div><p>The final input we use for the texture is another HTML element: the HTML5 video element.</p></div></div><div class="section" title="Using the output from a video as a texture"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec79"/>Using the output from a video as a texture</h2></div></div></div><p>If you've read<a id="id1051" class="indexterm"/> the previous paragraph on rendering to canvas, you might have thought about rendering video to canvas and using that as input for a texture. That is an option, but Three.js (through WebGL) already has direct support to use the HTML5 video element. Check out <code class="literal">11-video-texture.html</code>. Refer to the following screenshot for a still image of this example:</p><div class="mediaobject"><img src="graphics/2215OS_10_21.jpg" alt="Using the output from a video as a texture"/></div><p>Using video<a id="id1052" class="indexterm"/> as input for a texture is, just like using the canvas element, very easy. First off, we need to have a video element to play the video:</p><div class="informalexample"><pre class="programlisting">&lt;video  id="video"
  style="display: none;
  position: absolute; left: 15px; top: 75px;"
  src="../assets/movies/Big_Buck_Bunny_small.ogv"
  controls="true" autoplay="true"&gt;
&lt;/video&gt;</pre></div><p>This was just a basic HTML5 video element that we set to automatically play. Next, we can configure Three.js to use this video as an input for a texture, as follows:</p><div class="informalexample"><pre class="programlisting">var video  = document.getElementById('video');
texture = new THREE.Texture(video);
texture.minFilter = THREE.LinearFilter;
texture.magFilter = THREE.LinearFilter;
texture.generateMipmaps = false;</pre></div><p>Since our video isn't square, we need to make sure we disable the mipmap generation on the material. We also set some simple high-performance filters as the material changes very often. All that is left to do now is create a mesh and set the texture. In this example, we've used <code class="literal">MeshFaceMaterial</code> together with <code class="literal">MeshBasicMaterial</code>:</p><div class="informalexample"><pre class="programlisting">var materialArray = [];
materialArray.push(new THREE.MeshBasicMaterial({color: 0x0051ba}));
materialArray.push(new THREE.MeshBasicMaterial({color: 0x0051ba}));
materialArray.push(new THREE.MeshBasicMaterial({color: 0x0051ba}));
materialArray.push(new THREE.MeshBasicMaterial({color: 0x0051ba}));
materialArray.push(new THREE.MeshBasicMaterial({map: texture }));
materialArray.push(new THREE.MeshBasicMaterial({color: 0xff51ba}));

var faceMaterial = new THREE.MeshFaceMaterial(materialArray);
var mesh = new THREE.Mesh(geom,faceMaterial);</pre></div><p>All that is left <a id="id1053" class="indexterm"/>to do is make sure that in our <code class="literal">render</code> loop, we update the texture, as follows:</p><div class="informalexample"><pre class="programlisting">if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
  if (texture) texture.needsUpdate = true;
}</pre></div><p>In this example, we just rendered the video to one side of the cube, but since this is a normal texture, we could do anything we want with it. We could, for instance, divide it along the sides of a cube using custom UV mapping, or we could even use video input as input for a bump map or a normal map.</p><p>In Three.js version r69, a texture specifically for dealing with videos was introduced. This texture (<code class="literal">THREE.VideoTexture</code>) wraps the code you've seen in this section, and you can use the <code class="literal">THREE.VideoTexture</code> approach as an alternative. The following code fragment shows how to use <code class="literal">THREE.VideoTexture</code> to create a texture (you can see this in action by looking at the <code class="literal">11-video-texture.html</code> example):</p><div class="informalexample"><pre class="programlisting">var video = document.getElementById('video');
texture = new THREE.VideoTexture(video);</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Summary</h1></div></div></div><p>And so we end this chapter on textures. As you've seen, there are lots of different kinds of textures available in Three.js, each with their different uses. You can use any image in the PNG, JPG, GIF, TGA, DDS, or PVR format as a texture. Loading these images is done asynchronously, so remember to either use a rendering loop or add a callback when you load the texture. With textures, you can create great-looking objects from low-poly models and even add fake detailed depth using bump maps and normal maps. With Three.js, it is also easy to create dynamic textures using either the HTML5 canvas element or the video element. Just define a texture with these elements as the input and set the <code class="literal">needsUpdate</code> property to <code class="literal">true</code> whenever you want the texture to be updated.</p><p>With this chapter out of the way, we've pretty much covered all the important concepts of Three.js. We haven't, however, looked at an interesting feature Three.js offers—<span class="strong"><strong>postprocessing</strong></span>. With postprocessing, you can add effects to your scene after it is rendered. You could, for instance, blur or colorize your scene or add a TV-like effect using scan lines. In the next chapter, we'll look at postprocessing and how you can apply it to your scene.</p></div></body></html>