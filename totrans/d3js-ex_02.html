<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Selections and Data Binding</h1></div></div></div><p>In this chapter, you will learn how to use D3.js to select and manipulate the DOM of an HTML page based upon data. Rendering of visuals in D3.js takes a declarative approach, where you inform D3.js of how to visualize a piece of data instead of imperatively programming exactly how to draw the visual and iterate across the data. This process is referred to as <strong>selection</strong> <a id="id81" class="indexterm"/>and <strong>data binding</strong> <a id="id82" class="indexterm"/>in the D3.js nomenclature.</p><p>To demonstrate how D3.js can be used to create DOM elements driven by data, we will progress through a number of examples that demonstrate creating DIV elements to display various arrays of integer values. We will first examine how selection can be used to extract the existing DOM elements, and how D3.js is used to associate the data to each DOM element. Then we will examine the ways to instruct D3.js to create new DOM elements from the data. That will be followed by discussing the procedure for updating the existing elements, and for removing visual elements when particular data items are removed.</p><p>We will focus purely upon the HTML DOM elements, and will progress to using SVG in later chapters. Specifically, we will progress through the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using D3.js selections to modify DOM elements</li><li class="listitem" style="list-style-type: disc">Modifying the style of DOM elements using D3.js selectors</li><li class="listitem" style="list-style-type: disc">Binding data to the DOM using <code class="literal">.data()</code></li><li class="listitem" style="list-style-type: disc">Using <code class="literal">.enter()</code> for creating DOM elements from new data items</li><li class="listitem" style="list-style-type: disc">Updating the existing DOM elements based upon the changes in data</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">.exit()</code> to remove DOM elements when the associated data is no longer to be visualized</li><li class="listitem" style="list-style-type: disc">A laundry list of tips on performing data binding with D3.js</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>D3.js selections</h1></div></div></div><p>At its core, D3.js is about<a id="id83" class="indexterm"/> selection, which is a process of finding and creating DOM elements that visualize data. At a simple level, a selection can just be a means of finding and manipulating elements in the DOM that already exist. However, D3.js selections can also be used for explicitly creating new elements in the DOM as well as for implicitly creating and removing DOM elements based upon the changes in an underlying data model.</p><p>In <a class="link" href="ch01.html" title="Chapter 1. Getting Started with D3.js">Chapter 1</a>, <em>Getting Started with D3.js</em>, we saw a simple example of selection in which we used selection to make a D3.js version of the canonical Hello World application. Now we will dive deeper into the power of selections. We will look at two examples of selecting a DOM element and changing its style.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Changing the style of a DOM element</h2></div></div></div><p>In this first example, we will <a id="id84" class="indexterm"/>create a page with four <code class="literal">div</code> elements, each with a<a id="id85" class="indexterm"/> unique ID. We will then use D3.js to find the first <code class="literal">div</code> tag, and change its background color.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>bl.ock (2.1): <a class="ulink" href="http://goo.gl/EnAQBc">http://goo.gl/EnAQBc</a>
</p></div></div><p>The <code class="literal">body</code> tag of the document contains the following code:</p><div><pre class="programlisting">&lt;div id='div1'&gt;A&lt;/div&gt;
&lt;div id='div2'&gt;B&lt;/div&gt;
&lt;div id='div3'&gt;C&lt;/div&gt;
&lt;div id='div4'&gt;D&lt;/div&gt;
&lt;script&gt;
  d3.select('div').style('background-color', 'lightblue')
&lt;/script&gt;</pre></div><p>The result of this preceding code is as follows:</p><div><img src="img/B04230_02_01.jpg" alt="Changing the style of a DOM element"/></div><p>This example uses the <code class="literal">d3.select()</code> function, which returns the first element in the DOM that matches the given tag—in this case, <code class="literal">'DIV'</code>. The result of <code class="literal">d3.select()</code> is a D3.js object representing the DOM element that was identified and the data that D3.js has associated with that element.</p><p>This concept in D3.js is referred to as a <strong>selector</strong>. The function <code class="literal">d3.select()</code> always represents a single DOM element or a null value if the element is not found.</p><p>A selector has methods such as <code class="literal">.style()</code>, which can be used to change the CSS style properties of the underlying element, attributes using <code class="literal">.attr()</code>, and the text property using the <code class="literal">.text()</code> function.</p><p>In this case, we <a id="id86" class="indexterm"/>use the <code class="literal">.style()</code> function to set the <code class="literal">background-color</code> property<a id="id87" class="indexterm"/> of the DIV elements style to <code class="literal">lightblue</code>.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Changing the style of multiple items</h3></div></div></div><p>To select multiple items in the<a id="id88" class="indexterm"/> DOM, we can use the <code class="literal">d3.selectAll()</code> function. The <a id="id89" class="indexterm"/>result is a selector which can represent multiple DOM elements that match the criteria.</p><p>To demonstrate, we will change the single line of the D3.js code in our previous example to the following:</p><div><pre class="programlisting">d3.selectAll('div').style('background-color', 'lightblue')</pre></div><p>As a result of this, the call to <code class="literal">.selectAll()</code> will represent each of the four <code class="literal">div</code> elements in the document. The call to <code class="literal">.style()</code> will be applied to each of the DOM element represented, which results in the following output:</p><div><img src="img/B04230_02_02.jpg" alt="Changing the style of multiple items"/></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>bl.ock (2.2): <a class="ulink" href="http://goo.gl/61p8Nv">http://goo.gl/61p8Nv</a>
</p></div></div><p>This demonstrates one of the advantages of using D3.js for selection. Chained function calls will be applied to all DOM elements resulting from a D3.js selection. Therefore, we do not need to explicitly iterate through all the items. This saves us from excessive coding, and helps in reducing the potential of errors.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Note that, by default, the items in a selector are fixed at the time of the creation of the D3.js selector. If we were to add another <code class="literal">div</code> after the selection, then the elements in the existing selector will not have the new <code class="literal">div</code> tag added.</p></div></div><p>The parameter passed to the functions <code class="literal">d3.select()</code> and <code class="literal">d3.selectAll()</code> can also include various CSS rules as part of the query. As an example, to select all the elements with a specific ID, prepend the parameter with <code class="literal">#</code>. The following example selects only those DOM elements whose id is <code class="literal">div2</code>:</p><div><pre class="programlisting">d3.selectAll('#div2').style('background-color', 'lightblue')</pre></div><p>This results in the following output:</p><div><img src="img/B04230_02_03.jpg" alt="Changing the style of multiple items"/></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>bl.ock (2.3): <a class="ulink" href="http://goo.gl/TC4Yox">http://goo.gl/TC4Yox</a>
</p></div></div><p>Note that this<a id="id90" class="indexterm"/> selection will return all the DOM elements which have<a id="id91" class="indexterm"/> the ID <code class="literal">div2</code>, be they <code class="literal">div</code> or other types of DOM elements. This example only has <code class="literal">div</code> tags, so that is all that we will retrieve. Moreover, it is bad practice to have identical ID values on a page. But the way in which the query functions is viable.</p><p>If we want to ensure that this query returns only <code class="literal">div</code> elements, then we can use the following query, which places the type of the element before the hash symbol:</p><div><pre class="programlisting">d3.selectAll("div#div3").style('background-color', 'lightblue')</pre></div><p>The preceding query has the following result:</p><div><img src="img/B04230_02_04.jpg" alt="Changing the style of multiple items"/></div><div><div><h3 class="title"><a id="note13"/>Note</h3><p>bl.ock (2.4): <a class="ulink" href="http://goo.gl/xVwV1O">http://goo.gl/xVwV1O</a>
</p></div></div><p>Now let's examine the scenario where we would like to apply a different style to each DOM element in the selector. To do this, we can pass an accessor function to the <code class="literal">.style()</code> instead of a value. For example, the following code will alternate the color of the background of the <code class="literal">div</code> tags between <code class="literal">lightblue</code> and <code class="literal">lightgray</code>.</p><div><pre class="programlisting">d3.selectAll("div")
    .style('background-color', function (d, i) {
        return (i % 2 === 0) ? "lightblue" : "lightgray";
    });</pre></div><p>The preceding code results in the following output:</p><div><img src="img/B04230_02_05.jpg" alt="Changing the style of multiple items"/></div><div><div><h3 class="title"><a id="note14"/>Note</h3><p>bl.ock (2.5): <a class="ulink" href="http://goo.gl/PdohHx">http://goo.gl/PdohHx</a>
</p></div></div><p>Accessor<a id="id92" class="indexterm"/> functions are commonly used through D3.js. An accessor <a id="id93" class="indexterm"/>function has two parameters, the first of which represents the datum that has been associated by D3.js to the DOM element (we'll come back to this later in the chapter). The second parameter represents the 0-based array position of the DOM element in the result of the selection.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>The second parameter of an accessor function is optional.</p></div></div><p>The return value of the selector function is another selector (or the same selector) in many cases. This allows us to chain the method calls together. We can do this to conveniently set multiple styles on all the DOM elements represented by the selector.</p><p>As an example, the following code first sets the background color, and then sets the width of each DIV to an increasing value:</p><div><pre class="programlisting">d3.selectAll("div")
  .style('width', function(d, i) {
    return (10 + 10 * i) + "px";
  })
  .style('background-color', function (d, i) {
    return (i % 2 === 0) ? 'lightblue' : 'lightgray';
  });</pre></div><p>The output for the preceding code will be as follows:</p><div><img src="img/B04230_02_06.jpg" alt="Changing the style of multiple items"/></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>bl.ock (2.6): <a class="ulink" href="http://goo.gl/ukFFYL">http://goo.gl/ukFFYL</a>
</p></div></div><p>Multiple<a id="id94" class="indexterm"/> style properties can also be set in a single<a id="id95" class="indexterm"/> call to <code class="literal">.style()</code> by passing a hash of property names and values. The following has the same result as the previous example:</p><div><pre class="programlisting">d3.selectAll("div").style({
    width: function (d, i) { return (10 + 10 * i) + "px" },
    'background-color': function (d, i) {
        return (i % 2 === 0) ? 'lightblue' : 'lightgray';
    }
});</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>bl.ock (2.7): <a class="ulink" href="http://goo.gl/17FVJs">http://goo.gl/17FVJs</a>. The image of the output is omitted as it is a duplicate of the previous bl.ock.</p></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>D3.js and data binding</h1></div></div></div><p>The example in the <a id="id96" class="indexterm"/>previous section relied upon the elements that already exist in the DOM. Normally, in D3.js <a id="id97" class="indexterm"/>we would start with a set of data, and then build visualizations based on this data. We would also want to change the visualization as the data changes as a result of either adding more data items, removing some or all of them, or changing the properties of the existing objects.</p><p>This process of managing mapping of data to visual elements is often referred to as <strong>binding of data</strong>, and in terms of the D3.js nomenclature, it is referred to as a<a id="id98" class="indexterm"/> <strong>data join</strong> (do not confuse this with an SQL join). Binding in D3.js is performed by using the <code class="literal">.data()</code> function of a selector.</p><p>Let's dive in, and examine a few examples of binding data in some detail.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Data binding</h2></div></div></div><p>Binding of data<a id="id99" class="indexterm"/> can be one of the hardest things for someone new to D3.js to get used to. Even for somebody who uses other languages and frameworks that provide data binding, the way in which D3.js binds data is a little different, and getting to know how it does so will save a lot of time down the road. Therefore, we will take the time to examine it in detail as it is essential for creating effective D3.js visualizations.</p><p>In D3.js, we drive the visualization of data through binding using the following functions of a selector.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.data()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specifies the data to be used to drive the visualization</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.enter()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns a selector representing the new items to be displayed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">.exit()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns a selector representing the items that are no longer to be displayed</p>
</td></tr></tbody></table></div><p>This pattern in<a id="id100" class="indexterm"/> which test functions are used is so ingrained in the D3.js code that it is often referred to as the <a id="id101" class="indexterm"/>
<strong>enter</strong>/<strong>update</strong>/<strong>exit</strong> pattern or <a id="id102" class="indexterm"/>
<strong>general update</strong> pattern. It provides a powerful means of declaratively telling D3.js how you want the dynamic data to be displayed, and to let D3.js handle the rendering.</p><p>We will come back to these details of the specifics of enter/update/exit in a little bit. For now, let's start by examining our selection example from earlier in the chapter, where we selected all the <code class="literal">div</code> objects in the document. This will help us understand the basis of how a selector facilitates the rendering process.</p><p>We will use a slight variant on the <code class="literal">d3.selectAll()</code> function from the previous example. Here, we will assign the result to a variable named <code class="literal">selector</code>:</p><div><pre class="programlisting">&lt;div id='div1'&gt;A&lt;/div&gt;
&lt;div id='div2'&gt;B&lt;/div&gt;
&lt;div id='div3'&gt;C&lt;/div&gt;
&lt;div id='div4'&gt;D&lt;/div&gt;
&lt;script&gt;
    var selector = d3.select('body')
                     .selectAll('div');
&lt;/script&gt;</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>bl.ock (2.8): <a class="ulink" href="http://goo.gl/etDgJV">http://goo.gl/etDgJV</a>. The output is not shown as the code does give results visually different from the previous examples.</p></div></div><p>There are two other subtle differences in this preceding statement from the previous examples. The first is that we select the body DOM element, and the second is that we chain a call to <code class="literal">.selectAll()</code> for the div tags.</p><p>Using this pattern of a function chain, we are instructing D3.js to select all the <code class="literal">div</code> tags that are a child of the <code class="literal">body</code> tag. This chaining of select function calls allows us to navigate through the HTML document to look for tags in specific places, and as we will see shortly, specify where to put the new visual elements.</p><p>To help conceptualize a<a id="id103" class="indexterm"/> selector, I believe that a selector can be thought of as a collection of mappings between the DOM elements and the data that D3.js has associated with those element(s). I find it useful to mentally picture a selector with diagrams such as the following:</p><div><img src="img/B04230_02_07.jpg" alt="Data binding"/></div><p>The orange part in the preceding diagram represents the overall selector that results from our selection. This selector contains four items represented by white, rounded rectangles, one for each <code class="literal">div</code>, and which we can think of as being numbered from 0 through 3.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Do not confuse a selector with an array—the individual elements in this diagram cannot be accessed using <code class="literal">[]</code>.</p></div></div><p>The ordering is important as we will see when we update the data. By default, the ordering depends on how the identified DOM elements are ordered in the DOM at the point of selection (in this case, children of the <code class="literal">body</code> tag).</p><p>Each item in a selector can then be thought of as consisting of two other objects. The first is the actual DOM element that was identified by the selection, represented by a blue square in the preceding diagram. Inside that square in the image is the DOM element type (<code class="literal">div</code>), and the value of its <code class="literal">id</code> property.</p><p>The second is the datum that D3.js has associated with that DOM element, represented by the green square. In this case, there is no data that is bound at this point by D3.js, so the data for each is null (or empty in the diagram). This is because these DOM elements were created in HTML and not with D3.js, and hence there is no associated datum.</p><p>Let's change that and bind some data to these <code class="literal">div</code> tags. We do this by chaining a call to <code class="literal">.data()</code> immediately following the selection functions. This function is passed a collection of values or objects, and it informs D3.js that you want to associate each datum with a specific visual representation created by the function calls that follow.</p><p>To demonstrate this, let's modify the code to the following, binding the array of integers to the <code class="literal">div</code> tags:</p><div><pre class="programlisting">var selector = d3.select('body')
                 .selectAll('div')
                 .data([10, 20, 30, 40]);</pre></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>bl.ock (2.9): <a class="ulink" href="http://goo.gl/h1O1wX">http://goo.gl/h1O1wX</a>. The output is omitted from the book as it is not visually different from the previous example.</p></div></div><p>The result of chaining the<a id="id104" class="indexterm"/> call to <code class="literal">.data()</code> tells D3.js that for each item identified in the selector, the datum at the same index in the data should be assigned. In this example, this does not change the visual. It simply assigns a datum to each <code class="literal">div</code> element.</p><p>To check this, let's examine the result using the developer tools. If you right-click on <strong>A</strong> in the browser, and select inspect item, the tools will open. Next, open the properties panel, as shown in the following screenshot:</p><div><img src="img/B04230_02_08.jpg" alt="Data binding"/></div><p>The highlighted red rectangle in the preceding screenshot shows that the <code class="literal">div</code> tag now has a <code class="literal">__data__</code> property, and its value is <code class="literal">10</code>. This is how D3.js binds data to the visuals, by creating this property on the DOM element and assigning the datum. If you examine the three other <code class="literal">div</code> tags, you will see that they all have this property and the associated value.</p><p>Using the visual for our selector, we get the following values:</p><div><img src="img/B04230_02_09.jpg" alt="Data binding"/></div><p>Now you might ask what happens if the count of items in the call to <code class="literal">.data()</code> does not equal the amount of items in the selector? Let's take a look at those scenarios, starting with the case of fewer data items than the selected DOM elements:</p><div><pre class="programlisting"> var selector = d3.select('body')
                  .selectAll('div')
                  .data([10, 20, 30]);</pre></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>bl.ock (2.10): <a class="ulink" href="http://goo.gl/89NReN">http://goo.gl/89NReN</a>. The output has been omitted again, since the visual did not change.</p></div></div><p>If you open the Developer<a id="id105" class="indexterm"/> tools after running this example, and examine the properties for each of our <code class="literal">div</code> tags, you will notice that the first three have a <code class="literal">__data__</code> property with the values assigned. The fourth tag does not have the property added. This is because D3.js iterates through the items in the data, assigning them one by one, and any extra DOM elements in the selector are ignored.</p><p>Conceptually, the selector then looks like following:</p><div><img src="img/B04230_02_10.jpg" alt="Data binding"/></div><p>Now let's change the code to have more data items than the DOM elements:</p><div><pre class="programlisting">var selector = d3.select('body')
                 .selectAll('div')
                 .data([10, 20, 30, 40, 50]);</pre></div><div><div><h3 class="title"><a id="note22"/>Note</h3><p>bl.ock (2.11): <a class="ulink" href="http://goo.gl/CvuxNJ">http://goo.gl/CvuxNJ</a>. The output has been omitted again since the visual did not change.</p></div></div><p>Examining the resulting DOM in the Developer tools, you can see that there are still only four <code class="literal">div</code> elements, with <code class="literal">10</code> through <code class="literal">40</code> assigned respectively. There is no new visual created for the extra data item.</p><div><img src="img/B04230_02_11.jpg" alt="Data binding"/></div><p>Why is a visual not <a id="id106" class="indexterm"/>created in this case? It is because the call to <code class="literal">.data()</code> assigns data only to the existing visual elements in the selector. Since <code class="literal">.data()</code> iterates the items passed to it, it stops at the last item, and the extra DOM elements are ignored.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>We will examine how we add visuals for these stray data items in the next section.</p></div></div><p>There is one more case that I think is worth examining. The examples so far for <code class="literal">.data()</code> have had pre-existing <code class="literal">div</code> tags in the document. Let's now try binding some data items when there are no existing <code class="literal">div</code> tags. The body of code for this is as follows:</p><div><pre class="programlisting">    var selector = d3.select('body')
                     .selectAll('div')
                     .data([10, 20, 30]);</pre></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>bl.ock (2.12): <a class="ulink" href="http://goo.gl/5gsEGe">http://goo.gl/5gsEGe</a>. The output has been omitted as there are no visuals.</p></div></div><p>This does not create any DOM elements, since we do not chain any functions to create them after <code class="literal">.data()</code>. However, the variable selector is a valid selector with three items. In our visual, it would look like the following diagram, where the blue squares are empty:</p><div><img src="img/B04230_02_12.jpg" alt="Data binding"/></div><p>If you take a look at the output created on the console, you will see that this selector indeed has an array of three items:</p><div><pre class="programlisting">[[undefined, undefined, undefined]]</pre></div><p>The output does not <a id="id107" class="indexterm"/>necessarily show the data, but it does demonstrate that the selector consists of three items. Our conceptual model shows more, but it is only a conceptual model after all, and intended for understanding and not for representing the underlying data structures.</p><p>Now let's see how we instruct D3.js to create some visuals for the data items to fill in those blue squares, and put something on the screen.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Specifying the entering elements with .enter()</h3></div></div></div><p>To create visuals with<a id="id108" class="indexterm"/> D3.js, we need to call the <code class="literal">.enter()</code> method <a id="id109" class="indexterm"/>of the selector after the call to <code class="literal">.data()</code>. Then we chain the other method calls to append one or more DOM elements, and normally, also call various functions for setting the properties of those DOM elements.</p><p>To exemplify the use of <code class="literal">.enter()</code>, let's take a look at the last example from the previous section, where we started without any <code class="literal">div</code> tags in the body and used D3.js to bind three integers:</p><div><pre class="programlisting">var selector = d3.select('body')
    .selectAll('div')
    .data([10, 20, 30]);</pre></div><p>Now using the selector variable, we call the <code class="literal">.enter()</code> function and assign it to a variable named <code class="literal">entering</code>:</p><div><pre class="programlisting">var entering = selector.enter();</pre></div><p>The value of <code class="literal">entering</code> will represent the new items in the selector that need to be created. <code class="literal">selector</code> did not have any <code class="literal">div</code> tags selected, and since we bound to three items, this variable represents the three new items in the selector that need to be created.</p><p>We can then use the entering value and call functions to specify how to render the visuals for each item:</p><div><pre class="programlisting">entering.append('div')
    .text(function(d) { return d; });</pre></div><div><div><h3 class="title"><a id="note25"/>Note</h3><p>bl.ock (2.13): <a class="ulink" href="http://goo.gl/HFdspR">http://goo.gl/HFdspR</a>.</p></div></div><p>After execution, the value of <code class="literal">selector</code> contains three items, with both values assigned and the DOM elements created:</p><div><img src="img/B04230_02_13.jpg" alt="Specifying the entering elements with .enter()"/></div><p>The resulting output on the page will be as follows:</p><div><img src="img/B04230_02_14.jpg" alt="Specifying the entering elements with .enter()"/></div><p>Examining the <a id="id110" class="indexterm"/>resulting DOM, we see that three <code class="literal">div</code> tags<a id="id111" class="indexterm"/> have been created:</p><div><img src="img/B04230_02_15.jpg" alt="Specifying the entering elements with .enter()"/></div><div><div><h3 class="title"><a id="note26"/>Note</h3><p>I will leave it as an exercise for you to examine the properties of these elements for verifying the creation of the <code class="literal">__data__</code> property and assignment of the values.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Adding new items using .enter()</h2></div></div></div><p>Now that we have<a id="id112" class="indexterm"/> created DOM elements from data without any existing visuals, let's<a id="id113" class="indexterm"/> change the code to update the data by adding a new datum upon the press of a button.</p><p>In D3.js, data which need new visuals created are said to be in a state referred to as <em>entering</em>. After calling <code class="literal">.data()</code>, we can call the <code class="literal">.enter()</code> method on that same resulting selector. This method identifies the items in the selector that are entering, and hence require visuals to be created. We then simply chain methods on the result of <code class="literal">.enter()</code> to tell D3.js how each data item should be visualized.</p><p>Let's change our code a little bit to demonstrate this in action.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>bl.ock (2.14): <a class="ulink" href="http://goo.gl/TuVYQu">http://goo.gl/TuVYQu</a>
</p></div></div><p>This code makes a few modifications to the previous example. First we add a button that can be pressed. This button will call a function named <code class="literal">render()</code> and pass an array of four values to it, the first three of which are identical in value. There also exists a new datum at the end:</p><div><pre class="programlisting">&lt;button onclick='render([10, 20, 30, 40])'&gt;Take action!&lt;/button&gt;</pre></div><p>The render function<a id="id114" class="indexterm"/> itself does the selection and creation of the new<a id="id115" class="indexterm"/> visual elements, but it uses the values passed to the function instead of a hard-coded array of values.</p><div><pre class="programlisting">  function render(dataToRender) {
    var selector = d3.select('body')
                     .selectAll('div')
                     .data(dataToRender);

    var entering = selector.enter();
    entering.append('div')
            .text(function(d) { return d; });
  }</pre></div><p>When the page is first loaded, we call render, telling it to create elements in a different array.</p><div><pre class="programlisting">  render([10, 20, 30]);</pre></div><p>The initial page that is loaded will contain the following content:</p><div><img src="img/B04230_02_16.jpg" alt="Adding new items using .enter()"/></div><p>When we press the button we call render again, but pass it four values. This results in the content on the page changing as follows:</p><div><img src="img/B04230_02_17.jpg" alt="Adding new items using .enter()"/></div><p>This may appear as if the previously existing <code class="literal">div</code> tags were replaced with four new ones, but what happens is actually more subtle. The second time that <code class="literal">render()</code> is called, the call to <code class="literal">.selectAll('div')</code> creates a selector that has three items, each of which has DOM elements and their bound data:</p><div><img src="img/B04230_02_18.jpg" alt="Adding new items using .enter()"/></div><p>Then, <code class="literal">.data([10, 20, 30, 40])</code> is executed. D3.js iterates this array, and it compares the value of each <a id="id116" class="indexterm"/>datum to the item in the selector at the same index. In this <a id="id117" class="indexterm"/>case, the items at positions 0, 1, and 2 have the values <code class="literal">10</code>, <code class="literal">20</code>, and <code class="literal">30</code>, which are each equal to the values at the same position in the data. Therefore, D3.js does not do anything to these items. But the fourth value, <code class="literal">40</code>, does not have an associated item in the selector.</p><div><img src="img/B04230_02_19.jpg" alt="Adding new items using .enter()"/></div><p>Therefore, D3.js will create a new item in the selector for the datum 40, and then apply the functions for creating the visuals, resulting in the following:</p><div><img src="img/B04230_02_20.jpg" alt="Adding new items using .enter()"/></div><p>D3.js has left the first three items (and their DOM elements) untouched, and added new DOM elements for just the <code class="literal">40</code> datum.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>One thing to point out in this example is that I did not set the ID property, and hence the conceptual selector does not show the property.</p></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Updating values</h3></div></div></div><p>Now let's look at an example where we <a id="id118" class="indexterm"/>change the value of several of the items in our data. In this case, we do not want to remove and insert a new visual in the DOM, but to simply update the properties in the DOM to represent a change in the underlying values.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>An example of an update like this could be the price of a stock that needs to be updated.</p></div></div><p>To demonstrate this, let's make a quick change to the previous example, where when we click the button, we will now execute the following:</p><div><pre class="programlisting">&lt;button onclick='render([20, 30, 50])'&gt;Take action!&lt;/button&gt;</pre></div><div><div><h3 class="title"><a id="note129"/>Note</h3><p>bl.ock (2.15): <a class="ulink" href="http://goo.gl/nyUrRL">http://goo.gl/nyUrRL</a></p></div></div><p>On pressing the button, we get the following result:</p><div><img src="img/B04230_02_21.jpg" alt="Updating values"/></div><p>Nothing has changed on the page! Shouldn't the page be displaying 20, 30, and 50?</p><p>This gets into some of the subtleties of D3.js data binding. Let's step through this to explain this result:</p><div><pre class="programlisting">            var selector = d3.select('body')
                .selectAll('div')
                .data(dataToRender);</pre></div><p>The call to <code class="literal">.selectAll('div')</code> identifies the three <code class="literal">div</code> tags when the page was loaded:</p><div><img src="img/B04230_02_22.jpg" alt="Updating values"/></div><p>Following that, the call to <code class="literal">.data()</code> binds new values to each item in the selector:</p><div><img src="img/B04230_02_23.jpg" alt="Updating values"/></div><p>D3.js has changed the bound values, but all the items were reused, and hence, are not tagged as entering. Therefore, the following statement results in an empty set of entering items.</p><div><pre class="programlisting">            var entering = selector.enter();</pre></div><p>As a result, the chained <a id="id119" class="indexterm"/>methods are not executed, and the DOM elements are not updated.</p><p>How do we fix this? It's actually quite simple: we need to handle both, the case of entering elements and the case of the already existing ones. To do this, change the render function to the following:</p><div><pre class="programlisting">function render(dataToRender) {
    var selector = d3.select('body')
        .selectAll('div')
        .data(dataToRender);

    var entering = selector.enter();

    entering.append('div')
        .text(function(d) { return d; });
  
    selector.text(function(d) { return d; });
}</pre></div><p>The only difference is that we have added the following line:</p><div><pre class="programlisting">    selector.text(function(d) { return d; });</pre></div><p>When we chain methods to the original selector, the chained functions will be applied to all the items in the selector that are neither entering nor exiting (we cover exiting in the next section). And the result is what we expected:</p><div><img src="img/B04230_02_24.jpg" alt="Updating values"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Removing items with .exit()</h3></div></div></div><p>Now let's discuss how <a id="id120" class="indexterm"/>visuals change when items are removed from the <a id="id121" class="indexterm"/>collection of bound data. To handle exit, we simply need to use the <code class="literal">.exit()</code> function on the result of <code class="literal">.data()</code>. The return value of <code class="literal">.exit()</code> is a collection of the selector items which D3.js has determined need removal from the visualization based upon the change in data.</p><p>To demonstrate the removal of items, we will make a couple of simple modifications to the previous example. First, let's change the button code to render the following array upon clicking:</p><div><pre class="programlisting">&lt;button onclick='render([5, 15])'&gt;Take action!&lt;/button&gt;</pre></div><p>When we execute the page with this change, we get the following result:</p><div><img src="img/B04230_02_25.jpg" alt="Removing items with .exit()"/></div><p>Conceptually, we would have expected the resulted as a page with just 5 and 15, and not 5, 15, and 30.</p><p>The reason for this result is again because of the way that D3.js handles data binding. When we call <code class="literal">.data()</code> with the updated data, D3.js attempts to reconcile the following:</p><div><img src="img/B04230_02_26.jpg" alt="Removing items with .exit()"/></div><p>Since all that <code class="literal">.data()</code> does is update the bound value in each item of the selector, and since there are fewer values than the selector items, we get the following selector as a result:</p><div><img src="img/B04230_02_27.jpg" alt="Removing items with .exit()"/></div><p>We then call our code to handle the enter and update states. In this case, there are no entering items, whereas items at positions 0 and 1 are scheduled for update. Hence, the first two div tags get new text values, and the third div is left unchanged in the DOM.</p><p>All that we <a id="id122" class="indexterm"/>have to do to fix this is make a call to <code class="literal">.exit()</code>, and <a id="id123" class="indexterm"/>use the results of this call to remove those items from the DOM. We can modify <code class="literal">render()</code> to the following, which gives us our desired result:</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>bl.ock (2.16): <a class="ulink" href="http://goo.gl/IkIjGY">http://goo.gl/IkIjGY</a>
</p></div></div><div><pre class="programlisting">function render(dataToRender) {
    var selector = d3.select('body')
        .selectAll('div')
        .data(dataToRender);
    
    var entering = selector.enter();
    
    entering.append('div')
        .text(function(d) { return d; });
  
    selector.text(function(d) { return d; });
  
    var exiting = selector.exit();
    exiting.remove();
}</pre></div><p>The only change is the addition of the last two lines. Now when we press the button, we get the desired result:</p><div><img src="img/B04230_02_28.jpg" alt="Removing items with .exit()"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>A few notes for the wise about the general update pattern</h2></div></div></div><p>To close this chapter, I'd like to <a id="id124" class="indexterm"/>emphasize several points about managing visuals based upon data using D3.js. I believe these will definitely help you avoid problems in learning D3.js. Having come from other development platforms where data binding works in a different manner, I definitely struggled with these issues, and I want to pass along the insights that have I have learned to save you a lot of stress. It's kind of a long list, but I believe it to be very valuable.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A visualization is almost always based upon data, and is not just coded explicitly.</li><li class="listitem" style="list-style-type: disc">Normally, a D3.js application, on page load, will perform a <code class="literal">.selectAll()</code> on the document for the DOM elements that would represent data. Often, the result of this selection does not have any elements, as the page was just loaded.</li><li class="listitem" style="list-style-type: disc">A call is then made to <code class="literal">.data()</code> to bind data to the selector that results from the selection.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.data()</code> iterates across the datum that are passed to it, and ensures that there are items in the selector to correlate the datum to the visuals. The value of the datum is copied into this item. DOM elements are not created by the call to <code class="literal">.data()</code>.</li><li class="listitem" style="list-style-type: disc">Data in many apps changes dynamically over time without reloading the page, either by user interaction or through code that updates the data based upon other events. You would want to update the visualization when this happens. Therefore, you will need to call <code class="literal">.data()</code> multiple times.</li><li class="listitem" style="list-style-type: disc">If the number of items in the data is more than the number of items in the selector it is applied to, then more selector items will be created at the end of the selector. These will be marked as in a state referred to as entering. These will be accessible using the <code class="literal">.enter()</code> function on the selector. You then chain the function calls to create DOM elements for each new item in the selector.</li><li class="listitem" style="list-style-type: disc">If the number of items in the data is less than the number of items in the selector, then selector items will be removed from the end of the selector. These will be marked as <a id="id125" class="indexterm"/>exiting. These selector items will be available through a call to the <code class="literal">.exit()</code> function. These DOM elements will not be removed from the DOM automatically, and you will need to make a call to <code class="literal">.remove()</code> to make this so.</li><li class="listitem" style="list-style-type: disc">To optimize this <a id="id126" class="indexterm"/>process, D3.js really only concerns itself with ensuring the number of items in the selector matches the number of datum that you specify with <code class="literal">.data()</code>.</li><li class="listitem" style="list-style-type: disc">The data associated with a selector item is by value and not reference. Hence, <code class="literal">.data()</code> copies data into the <code class="literal">__data__</code> property on the DOM element. On subsequent calls to <code class="literal">.data()</code>, there is no comparison performed between the datum and the value of the <code class="literal">__data__</code> property.</li><li class="listitem" style="list-style-type: disc">To update data, you write code to chain methods for generating DOM on the result of a selection, in addition to code that chains on the <code class="literal">.enter()</code> and <code class="literal">.exit()</code> functions.</li><li class="listitem" style="list-style-type: disc">If a new datum has the same value as is already associated to a selector item, D3.js does not care. Even though the values have not changed, you will be rendering it again, but reusing the DOM elements. You will need to provide your own facilities to manage not setting the properties again if the data is the same, so as to optimize the browser re-rendering the elements.</li><li class="listitem" style="list-style-type: disc">If you have 1,000,000 data items, and then change just one and call <code class="literal">.data() </code>again, D3.js will inherently force you to loop through all the 1,000,000 items. There will likely be visual updates to just one set of visuals, but your application will make the effort to iterate through everything every time. However, if you have 1,000,000 data items, you probably should be looking at another means of summarizing your data before visualizing it.</li><li class="listitem" style="list-style-type: disc">D3.js optimizes around the reuse of visual elements. The assumption is that a visualization will only be periodically making updates to the exiting items, and that addition or removal of items will be relatively infrequent. Hence, the general update pattern would consist of exit, update, and exit, and not comparing data.</li><li class="listitem" style="list-style-type: disc">Normally, the rule of thumb is that one or two thousand data items and the associated visuals are handled pretty effectively by D3.js.</li></ul></div><p>Well, that's quite a<a id="id127" class="indexterm"/> long list. But as we progress through this book, all the examples will follow these guidelines. By the end, these will be second nature.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we covered many examples to demonstrate how you can create data-driven visualizations using D3.js. We started with examples of the D3.js concept of selectors, using them to select elements from within the DOM, and discussed how selectors are used to map data items to the visuals that D3.js creates. We then examined several scenarios of binding new data, updating data, and removing data from a D3.js visualization.</p><p>Throughout this chapter, the visuals that we created with D3.js were pure HTML objects, primarily <code class="literal">div</code> tags. Although we changed the size of these <code class="literal">div</code> tags, the background color, and included text within them, the examples are a very basic form of graphical representation.</p><p>In the next chapter, we will start to get significantly more graphical by changing the focus of the examples towards working with SVG, creating real graphics (not just HTML <code class="literal">div</code> tags), and setting a framework for the rich visualizations that we will create later in the book.</p></div></body></html>