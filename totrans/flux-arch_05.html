<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Asynchronous Actions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Asynchronous Actions</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Creating Actions">Chapter 4</a>, <span class="emphasis"><em>Creating Actions,</em></span> we examined Flux actions in detail—action creator functions in particular. One aspect of action creators we didn't cover was asynchronous behavior. Asynchronicity is central to any web application, and in this chapter, we'll think about what this means for a Flux architecture.</p><p>We'll start by covering the synchronous nature of Flux, as breaking this synchronicity breaks the whole architecture. Next, we'll dive into some code that makes API calls and some action creators that need to synchronize multiple API calls before actually dispatching the action. Then, we'll introduce promises as return values from action creator functions.</p><div class="section" title="Keeping Flux synchronous"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Keeping Flux synchronous</h1></div></div></div><p>It may sound strange<a id="id162" class="indexterm"/> that we would want to keep an architecture synchronous—especially on the web. What about the laggy user experience that happens when everything is performed synchronously?</p><p>It's just the Flux data-flow that's synchronous, not the entire application. In this section, we'll touch upon why keeping the core data-flow mechanisms of our architecture synchronous is a good idea. Next, we'll talk about how we should encapsulate asynchronous behavior in our application. Finally, we'll go over the general semantics of how asynchronous action creator functions work.</p><div class="section" title="Why synchronicity?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Why synchronicity?</h2></div></div></div><p>The simple answer is that <a id="id163" class="indexterm"/>anything that's asynchronous introduces a level of uncertainty that wouldn't otherwise be there. It can be tempting, given all the new hotness in web browsers, to make everything happen in parallel—to leverage as many concurrent web requests and as many processor cores as we possibly can. Once we go down this path, it's hard to turn back, and the further down we go, the more tangled the synchronization semantics get.</p><p>Let's think about the DOM API for a moment. JavaScript applications use this API to change the state of elements on the page. When these changes happen, the browser's rendering engine kicks in<a id="id164" class="indexterm"/> and performs an update to the screen so that the user can actually see the changes. The DOM API doesn't directly interface with what's displayed on screen—there's a whole bunch of nasty details taken care of for us by the rendering engine. This idea is illustrated here:</p><div class="mediaobject"><img src="graphics/B05419_05_01.jpg" alt="Why synchronicity?"/></div><p>The takeaway here is that it's not the individual updates made by our components that cause the rendering engine to update the screen. The JavaScript engine is run-to-completion, meaning that it waits for all these components to finish making their calls to update the DOM (and any other code they're running) before handing off control to the rendering engine. This means that any updates the user sees are fundamentally synchronous—all the concurrent code in the world doesn't change the synchronous communication path between the JavaScript engine and the render engine.</p><p>You might be wondering what this has to do with Flux at this point. It's actually very relevant because the authors of Flux understand this synchronous DOM update mechanism, so rather than fight it with complex asynchronous code everywhere, they came up with data-flow semantics that embrace the synchronous nature of updating the DOM.</p><p>The core abstraction Flux uses for synchronous data-flow is the <span class="strong"><strong>update round</strong></span>, which was introduced in <a class="link" href="ch02.html" title="Chapter 2. Principles of Flux">Chapter 2</a>, <span class="emphasis"><em>Principles of Flux</em></span>. Nothing can interrupt an update round because every component that takes part in it has no asynchronous behavior. If Flux has a killer feature, this is it. The update round is such a critical property of Flux architectures that we<a id="id165" class="indexterm"/> have to be especially careful to maintain it. It's like an umbrella concept—dozens of little edge cases caused by asynchronous behavior fall outside of it.</p></div><div class="section" title="Encapsulating asynchronous behavior"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Encapsulating asynchronous behavior</h2></div></div></div><p>With Flux update rounds<a id="id166" class="indexterm"/> being synchronous, where should we put our asynchronous code? Let's think about this for a moment. Flux architecture aside, any asynchronous behavior is going to update the state of the system in some way when the action completes and is synchronized with the rest of our code. In some architectures, this happens all over the place and there's nothing guarding against these types of asynchronous actions from being called from places where they shouldn't.</p><p>For example, a Flux update round should never result in new asynchronous behavior running. We know that update rounds are synchronous, so this is a non-starter. We do need to encapsulate our asynchronous behavior somehow though. This is what action creator functions are really good at—performing the asynchronous work and managing the action dispatches once the asynchronous portion has completed. Here is a visualization of action creator functions encapsulating asynchronous calls:</p><div class="mediaobject"><img src="graphics/B05419_05_02.jpg" alt="Encapsulating asynchronous behavior"/></div><p>Keeping asynchronous behavior in the action creator functions does two things for us. First, we know there's no synchronization semantics involved in calling the action creator—this is all handled within the function for us. The second advantage is that all of our asynchronous behavior can be found within a single architectural layer. That is, if there's something that's asynchronous, such as making an API call, we know where to look for this code.</p></div><div class="section" title="Asynchronous action semantics"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Asynchronous action semantics</h2></div></div></div><p>It's up to our action creator functions to perform any synchronizations before dispatching any actions. There are two<a id="id167" class="indexterm"/> parts to a given action creator function. The first is the asynchronous calls, if any, while the second part is the actual dispatching of the action. The job of these action creator functions is to synchronize the async call with the Flux dispatcher, meaning that the function will have to wait for some kind of response before the action can be dispatched.</p><p>This is because the asynchronous action has payload data. Let's take a look at an example, shall we? Here's an action creator function that calls an API to load a list of user objects:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';

// The action identifier...
export const LOAD_USERS = 'LOAD_USERS';

// Performs some asynchronous behavior, and once
// complete, dispatches the action.
export function loadUsers() {

  // Creates a new promise, intended to simulate
  // a call to some API function, which would likely
  // also return a promise.
  let api = new Promise((resolve, reject) =&gt; {

    // Resolves the promise with some data after half
    // a second.
    setTimeout(() =&gt; {
      resolve([
        { id: 1, name: 'User 1' },
        { id: 2, name: 'User 2' },
        { id: 3, name: 'User 3' }
      ]);
    }, 500);
  });

  // When the promise resolves, the callback that's
  // passed to "then()" is called with the resolved
  // value. This is the payload that's dispatched.
  api.then((response) =&gt; {
    dispatcher.dispatch({
      type: LOAD_USERS,
      payload: response
    });
  });
}</pre></div><p>As you can see, we're using a promise in place of an actual API call. Generally speaking, our application will probably have an API function call that returns a promise. This is exactly what we're doing here—making it seem like we're talking with an API when in reality, it's just a promise. The mechanics are the same, regardless of whether <code class="literal">setTimeout()</code> or an actual AJAX response resolves the promise.</p><p>The important thing to note is that it's the <code class="literal">loadUsers()</code> function that takes care of dispatching the action after<a id="id168" class="indexterm"/> the promise has resolved. Think of it this way—the dispatcher is never invoked unless we have new data for the system. The waiting part falls outside of the Flux update round, which is why it's nice to keep everything together in a function like this. Here's how we use the <code class="literal">loadUsers()</code> function:</p><div class="informalexample"><pre class="programlisting">import dispatcher from './dispatcher';
import { 
  LOAD_USERS, 
  loadUsers
} from './actions/load-users';

// Logs the specific action payloads as
// they're dispatched.
dispatcher.register((e) =&gt; {
  switch(e.type) {
    case LOAD_USERS:
      console.log('users', e.payload.map(x =&gt;x.id));
      break;
  }
});

loadUsers();
// → users [1, 2, 3]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Something that you may have noticed is missing from this example is any kind of error handling. For example, it would be unpleasant to call <code class="literal">loadUsers()</code> and have it fail silently because something's wrong with the API. We'll cover error-handling in more depth in the final section of this chapter.</p></div></div></div></div></div>
<div class="section" title="Making API calls"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Making API calls</h1></div></div></div><p>In this section, well go over the<a id="id169" class="indexterm"/> common case for asynchronous behavior in Flux architectures—making API calls over the network. Then, we'll discuss some the implications of asynchronous behavior in the context of user interactivity and the Flux tools available to deal with them.</p><div class="section" title="APIs are the common case"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>APIs are the common case</h2></div></div></div><p>Flux architecture is for the frontend of web applications. That said, there's going to be a lot of network communication <a id="id170" class="indexterm"/>between some components of our architecture and the backend API. This is the common case for asynchronous behavior, not just in Flux, but in the majority of JavaScript applications. Therefore, this is where the emphasis should be when designing action creators that directly communicate asynchronously with these API endpoints. Here's what the most common communication paths look like in Flux applications:</p><div class="mediaobject"><img src="graphics/B05419_05_03.jpg" alt="APIs are the common case"/></div><p>The stores need to be populated with data, and this is the most common way to get data—by fetching it from the API. In fact, the user is likely going to spend more time consuming information than interacting with UI elements. As you saw in the last section, synchronizing the response with the dispatcher isn't difficult to do with promises.</p><p>These types of API calls aren't the only source of asynchronous data in Flux architectures. For example, reading a file using the file API requires the use of an asynchronous function call. Interacting with web workers is another asynchronous form of communication—you ask the worker to compute something and get a response in the form of a callback function. Although less common than HTTP calls, these asynchronous interfaces may be treated in the same way, as illustrated here:</p><div class="mediaobject"><img src="graphics/B05419_05_04.jpg" alt="APIs are the common case"/></div><p>The same synchronization mechanism—promises—can be used for all of these types of asynchronous communication channels. As far as the action creator functions are concerned, they all have the same interface—a promised value that's resolved at a later time. The dispatcher semantics are the same here as well.</p><p>There's no asynchronous behavior entering the<a id="id171" class="indexterm"/> Flux update round because it's all encapsulated within the action creator functions themselves. Additionally, it could take more than one API to get all the data needed for an action payload. We'll look at this shortly. For now, let's turn our attention to how asynchronous action creators impact user interactivity.</p></div><div class="section" title="API calls and user interactivity"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>API calls and user interactivity</h2></div></div></div><p>The main challenge with <a id="id172" class="indexterm"/>asynchronous calls and user interface elements is that we have to manage the state of the request, which in turn reflects the state of the UI elements. For example, when the user submits a form, we have to give some sort of visual indication that the request has been made and that it's being processed. Moreover, we also need to prevent the user from interacting with certain UI elements until a response comes back with the state of the request.</p><p>The stores in a Flux architecture contain all application state, including the state of any network requests we want to track. This can help us coordinate the state of relevant UI elements with a given request. Let's look at an action creator that sends an asynchronous API request to start something:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';

// The action identifier...
export const START = 'START';

export function start() {

  // Simulate an async API call that starts
  // something. The promise resolves after
  // one second.
  let api = new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, 1000);
  });

  // Dispatches the action after the promise
  // has resolved.
  api.then((response) =&gt; {
    dispatcher.dispatch({ type: START });
  });
}</pre></div><p>As you can see, the <code class="literal">start()</code> function dispatches the <code class="literal">START</code> action after the promise resolves. Just like a real API call, this delay allows the user ample time to interact with the UI before the call<a id="id173" class="indexterm"/> returns. So, we have to take steps to prevent this from happening. Let's look at another action creator function that tells the system about the state of the API request we just made:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';

export const STARTING = 'STARTING';

export function starting() {
  dispatcher.dispatch({ type: STARTING });
}</pre></div><p>By calling <code class="literal">starting()</code>, we can inform any stores that might be listening that we're about to make an API call to start something. This could be what we need to take care of handling the state of UI elements to inform the user that the request is in progress, and to disable elements the user shouldn't touch while the request is happening. Let's take a look at a store that processes these types of actions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>The store also processes <code class="literal">STOP</code> and <code class="literal">STOPPING</code> actions. These modules aren't listed separately here because they're nearly identical to the <code class="literal">START</code> and <code class="literal">STARTING</code> actions, respectively.</p></div></div><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';
import {
  START,
  STARTING,
  STOP,
  STOPPING
} from '../actions/constants';

import { EventEmitter } from 'events';

class MyStore extends EventEmitter {
  constructor() {
    super();

    this.state = {
      startDisabled: false,
      stopDisabled: true
    };

    dispatcher.register((e) =&gt; {
      switch(e.type) {

        // If starting or stopping, we don't want any
        // buttons enabled.
        case STARTING:
        case STOPPING:
          this.state.startDisabled = true;
          this.state.stopDisabled = true;
          this.emit('change', this.state);
          break;

        // Disable the stop button after being started.
        case START:
          this.state.startDisabled = true;
          this.state.stopDisabled = false;
          this.emit('change', this.state);
          break;

        // Disabled the start button after being stopped.
        case STOP:
          this.state.startDisabled = false;
          this.state.stopDisabled = true;
          this.emit('change', this.state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>The store has a clear representation <a id="id174" class="indexterm"/>of the disabled state for both a <code class="literal">start</code> and a <code class="literal">stop</code> button. If the <code class="literal">STARTING</code> or <code class="literal">STOPPING</code> action is dispatched, then we can mark both buttons as disabled. In the case of <code class="literal">START</code> or <code class="literal">STOP</code>, we can mark the appropriate button as disabled and the other as enabled. Now that the stores have all the state that they need, let's now look at a view that actually renders the button elements.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>You might be wondering why we've separated these two actions into two action creator functions—<code class="literal">start()</code> and <code class="literal">starting()</code>. The reason is simple: one action creator dispatches one action. However, this isn't set in stone and is a matter of personal preference. For example, <code class="literal">start()</code> could have dispatched the <code class="literal">STARTING</code> action before actually making the API call. The upside here is that there's only one function<a id="id175" class="indexterm"/> that takes care of everything. On the downside, we lose the one-to-one correspondence between action creator and action, raising the potential for confusion.</p></div></div><div class="informalexample"><pre class="programlisting">import myStore from '../stores/mystore';
import {
  start,
  starting,
  stop,
  stopping
} from '../actions/functions';

class MyView {
  constructor() {

    // The elements our view interacts with...
    this.start = document.getElementById('start');
    this.stop = document.getElementById('stop');

    // The start button was clicked. Dispatch the
    // "STARTING" action, and the "START" action
    // once the asynchronous call resolves.
    this.start.addEventListener('click', (e) =&gt; {
      starting();
      start();
    });

    // The stop button was clicked. Dispatch the
    // "STOPPING" action, and the "STOP" action
    // once the asynchronous call resolves.
    this.stop.addEventListener('click', (e) =&gt; {
      stopping();
      stop();
    });

    // When the store state changes, update the UI
    // by enabling or disabling the buttons,
    // depending on the store state.
    myStore.on('change', (state) =&gt; {
      this.start.disabled = state.startDisabled;
      this.stop.disabled = state.stopDisabled;
    });
  }
}

export default new MyView();</pre></div><p>Note that the main job of the click handlers is to call action creator functions. They're not performing extra state checking to make sure that the actions can be called, and so on. This sort of thing doesn't belong in views, it belongs in a store. We're following this tactic here, where we disable the buttons<a id="id176" class="indexterm"/> in the store by change a particular piece of state. If we check for this sort of thing in view event handlers, we end up decoupling the state from the logic that operates on it, and in Flux this is not a good thing.</p></div></div>
<div class="section" title="Combining API calls"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Combining API calls</h1></div></div></div><p>As development moves forward and features become more involved, we're inevitably faced with complex API scenarios. This means that there's no longer a simple API endpoint that delivers <a id="id177" class="indexterm"/>everything the feature needs with one call. Instead, our code has to stitch together two or more resources from different endpoints just to get the data needed by the feature.</p><p>In this section, we'll look at action creator functions that fetch data from multiple asynchronous resources and pass them to stores as payload data. These stores then convert these to information required by features. Then, we'll look at an alternative approach, where we compose action creator functions out of smaller action creator functions, each pulling data from their own asynchronous resource.</p><div class="section" title="Complex action creators"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Complex action creators</h2></div></div></div><p>Sometimes, a single API endpoint doesn't have all of the data we need for a given store. This means that we have to<a id="id178" class="indexterm"/> fetch data from multiple API endpoints. The challenge is that these are asynchronous resources, and they need to be synchronized before passing them to stores by dispatching them as action payloads. Let's take a look at an action creator that fetches data from three asynchronous API endpoints. But first, here's the API functions we'll use to simulate asynchronous network calls:</p><div class="informalexample"><pre class="programlisting">// API helper function - resolves the given
// "data" after the given MS "delay".
function api(data, delay=1000) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(data);
    }, delay);
  });
}

// The first API...
export function first() {
  return api([ 'A', 'B', 'C' ], 500);
}

// The second API...
export function second() {
  return api([ 1, 2, 3 ]);
}

// The third API...
export function third() {
  return api([ 'D', 'E', 'F' ], 1200);
}</pre></div><p>So we have consistent return values from these API functions—promises. Each promise that's returned from a given<a id="id179" class="indexterm"/> function is responsible for synchronizing that one API call. But what about when our store needs to combine all of these resolved values to form the state of a store? Let's now look at an action creator function that handles this:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';

// The mock API functions we need.
import {
  first,
  second,
  third
} from './api';

// The action identifier...
export constMY_ACTION = 'MY_ACTION';

export function myAction() {

  // Calls all three APIs, which all resolve
  // after different delay times. The "Promise.all()"
  // method synchronizes them and returns a new promise.
  Promise.all([
    first(),
    second(),
    third()
  ]).then((values) =&gt; {

    // These are the resolved values...
    let [ first, second, third ] = values;

    // All three API calls have resolved, meaning we
    // can now dispatch "MY_ACTION" with the three
    // resolved async values as the payload.
    dispatcher.dispatch({
      type: MY_ACTION,
      payload: {
        first: first,
        second: second,
        third, third
      }
    });
  });
}</pre></div><p>The action <code class="literal">MY_ACTION</code> is only dispatched once all three asynchronous values have resolved, because the store depends on all three. All three values are available to the store within a single update round when the action is dispatched. Something less obvious about this code, but important nonetheless, is the fact that we're not performing any data transformations inside the <a id="id180" class="indexterm"/>action creator function before dispatching the payload. Instead, we provide the resolved API data as is, in the form of payload properties. This ensures that the store is the sole component responsible for the state of its information. Let's look at how a store is now able to use this payload:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import dispatcher from '../dispatcher';
import { MY_ACTION } from '../actions/myaction';

class MyStore extends EventEmitter {
  constructor() {
    super();

    this.state = [];

    dispatcher.register((e) =&gt; {
      switch(e.type) {
        case MY_ACTION:

          // Get the resolved async values from the
          // action payload.
          let { first, second, third } = e.payload;

          // Zip the three arrays and set the resulting
          // array as the store state.
          this.state = first.map((item, i) =&gt;
            [ item, second[i], third[i] ]);

          this.emit('change', this.state);
          break;
      }
    });
  }
}

export default new MyStore();</pre></div><p>As you can see, the store has <a id="id181" class="indexterm"/>everything it needs in the payload to perform the necessary transformations. Let's call the action creator function and see if this store behaves as expected:</p><div class="informalexample"><pre class="programlisting">import { myAction } from './actions/myaction';
import myStore from './stores/mystore';

myStore.on('change', (state) =&gt; {
  console.log('changed', state);
});

myAction();
// → changed
// [
//   [ 'A', 1, 'D' ],
//   [ 'B', 2, 'E' ],
//   [ 'C', 3, 'F' ]
// ]</pre></div></div><div class="section" title="Composing action creators"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Composing action creators</h2></div></div></div><p>As you saw earlier in the chapter, our action creator function calls can get quite verbose when user interactivity is involved. This is because we have to make two or more calls to action creator functions. One call ensures that the UI elements are in a state that's appropriate while the user <a id="id182" class="indexterm"/>waits for the asynchronous action to complete. The other call invokes the asynchronous behavior. To avoid having to make two calls everywhere, we could just have the action creator function dispatch two actions. However, this isn't always ideal because we might need to call the first action creator without the second action creator at some point. It's a granularity problem more than anything.</p><p>The easy solution is to compose a function out of the two. This way, we keep the granularity intact, while reducing the number of functions to call in many places. Let's revisit our code from earlier, where we had to manually call <code class="literal">starting()</code> then <code class="literal">start()</code>:</p><div class="informalexample"><pre class="programlisting">import { start as _start } from './start';
import { starting } from './starting';
import { stop as _stop } from './stop';
import { stopping } from './stopping';

// The "start()" function now automatically
// calls "starting()".
export function start() {
  starting();
  _start();
}

// The "stop()" function now automatically
// calls "stopping()"
export function stop() {
  stopping();
  _stop();
}

// Export "starting()" and "stopping()" so
// that they can still be used on their
// own, or composed into other functions.
export { starting, stopping };</pre></div><p>Now our views can simply call <code class="literal">start()</code> or <code class="literal">stop()</code> and the necessary state changes are applied to the relevant UI elements. This works because the first action creator function is synchronous—meaning that the full Flux update round takes place before the asynchronous call is made. This behavior is consistent, no matter what. Where we start running into problems is when we start composing functions out of several asynchronous action creators, as visualized here:</p><div class="mediaobject"><img src="graphics/B05419_05_05.jpg" alt="Composing action creators"/></div><p>The problem here is that each of these <code class="literal">asyncAction()</code> functions we've used to compose <code class="literal">action()</code> results in an update round. The update round that happens first is a race condition. We can't combine them<a id="id183" class="indexterm"/> into a single action creator that makes requests to multiple API endpoints because they service two different stores. Flux is all about predictable data flows, and this means always knowing the order of update rounds. In the next section, we'll revisit promises in action creator functions to help us get around these tricky asynchronous action creator scenarios.</p></div></div>
<div class="section" title="Returning promises"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Returning promises</h1></div></div></div><p>None of the action creator functions we've looked at so far in this chapter have returned any values. That's because their main job is to dispatch actions, while at the same time hiding any concurrency<a id="id184" class="indexterm"/> synchronization semantics. On the other hand, action creator functions could return a promise so that we could compose more complex asynchronous behavior that spans multiple stores. In the last section, we saw that composing asynchronous behavior using action creator functions can be difficult if not impossible to do.</p><p>In this section, we'll revisit the challenges posed by asynchronous behavior in the context of composing larger functionality. Then, we'll create an example implementation with action creators that return promises and use them to synchronize with one another. Finally, we'll see whether returning promises from action creators can help us deal with errors that happen in the asynchronous resources we're communicating with.</p><div class="section" title="Synchronizing without promises"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Synchronizing without promises</h2></div></div></div><p>One nice aspect of a Flux architecture is the fact that a lot of it is synchronous. For example, when we call the dispatcher with a new action and a new payload, we can rest assured that the call will block until the update round has completed, and everything in the UI is reflecting the <a id="id185" class="indexterm"/>current state of things. With asynchronous behavior, things are different—especially in a Flux architecture where this type of thing is strictly confined to action creator functions. Therefore, we face the inevitable challenge of trying to piece together complex systems from an abundance of asynchronous resources.</p><p>We saw how to get partway there earlier in the chapter. A single action creator function can combine the resolved values of several asynchronous resources into a single action and a payload. Then the logic within the store can figure out how to make use of the data and update its state. This works fine when single stores are in play, but falters when we're trying to synchronize resources across several stores and features.</p><p>This is when being able to synchronize the async data and the Flux update round becomes important. To do so, our action creator functions need to return promises that resolve when both have completed. Here's an illustration of what we need to accomplish:</p><div class="mediaobject"><img src="graphics/B05419_05_06.jpg" alt="Synchronizing without promises"/></div></div><div class="section" title="Composing asynchronous behavior"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Composing asynchronous behavior</h2></div></div></div><p>The way to get around these<a id="id186" class="indexterm"/> tricky asynchronous action creator scenarios is to have these functions return promises that are resolved after the asynchronous behavior and the update round have completed. This lets the caller know that the update round is complete and that anything we call now will take place afterward. Consistency is what we're after here, so let's take a look at an action creator function that returns a promise:</p><div class="informalexample"><pre class="programlisting">// The action identifier...
export const FIRST = 'FIRST';

// The API function that returns a promise that's
// resolved after 1.5 seconds.
function api() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve({ first: 'First Name' });
    }, 1500);
  });
}

export function first() {

  // Returns a promise so that the caller
  // knows when the update round is complete,
  // regardless of the asynchronous behavior
  // that takes place before the action is dispatched.
  return new Promise((resolve, reject) =&gt; {
    api().then((response) =&gt; {

      // Action is dispatched after the asynchronous
      // value is resolved.
      dispatcher.dispatch({
        type: FIRST,
        payload: response
      });

      // Resolve the promise returned by "first()",
      // after the update round.
      resolve();
    });
  });
}</pre></div><p>So this action creator calls an asynchronous API that resolves after 1.5 seconds, at which point the action payload is<a id="id187" class="indexterm"/> dispatched and the returned promise is resolved. Let's take a look at another action creator that uses a different API function:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';

// The action identifier...
export const LAST = 'LAST';

// The API function that returns a promise that's
// resolved after 1.5 seconds.
function api() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve({ last: 'Last Name' });
    }, 1000);
  });
}

export function last() {
  return new Promise((resolve, reject) =&gt; {
    api().then((response) =&gt; {
      dispatcher.dispatch({
        type: LAST,
        payload: response
      });

      resolve();
    });
  });
}</pre></div><p>You can see that the two action creator functions—<code class="literal">first()</code> and <code class="literal">last()</code>—follow an identical strategy by<a id="id188" class="indexterm"/> returning promises. The API function, however, resolves different data, and it takes only 1 second to do so. Let's see what happens when we try to use these two functions together:</p><div class="informalexample"><pre class="programlisting">import dispatcher from './dispatcher';
import { FIRST, first } from './actions/first';
import { LAST, last } from './actions/last';

// Logs the payload as actions are dispatched...
dispatcher.register((e) =&gt; {
  switch (e.type) {
    case FIRST:
      console.log('first', e.payload.first);
      break;
    case LAST:
      console.log('last', e.payload.last);
      break;
  }
});

// Order of update rounds isn't guaranteed here.
first();
last();
// →
// last Last Name
// first First Name

// With promises, update round order is consistent.
first().then(last);
// →
// first First Name
// last Last Name</pre></div></div><div class="section" title="Handling errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Handling errors</h2></div></div></div><p>What happens when the API that Flux action creators interact with fails? Generally speaking, when we make <a id="id189" class="indexterm"/>AJAX calls, we supply both success and error callback functions. This way, we can fail in a graceful manor. We have to be careful about how we handle failure in Flux action creators because, just as stores want to know about actions, they want to know about failures too.</p><p>So the question is—what do we do differently in our action creator functions? Do we just dispatch some sort of error action from within the action creator when the API fails? We do want to dispatch an error action so that the stores can adjust their state accordingly, but what about the caller of the action creator? For example, we could have a generic action creator function that's used in many places, and the error-handling could be context dependent.</p><p>The answer is to have the promise that's returned by the action creator reject. This allows the caller to specify their own behavior in the event of a failed API call. Let's look at an action creator function that handles errors this way:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';

// The action identifier...
export const UPDATE_TASK = 'UPDATE_TASK';

// The action error identifier...
export const UPDATE_TASK_ERROR = 'UPDATE_TASK_ERROR';

// Returns a promise that's rejected with an error
// message after 0.5 seconds.
function api() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      reject('Failed to update task');
    }, 500);
  });
}

export function updateTask() {
  return new Promise((resolve, reject) =&gt; {

    // Dispatches the "UPDATE_TASK" action as usual
    // when the promise resolves. Then resolves
    // the promise returned by "updateTask()".
    api().then((response) =&gt; {
      dispatcher.dispatch({
        type: UPDATE_TASK
      });

      resolve();

    // If the API promise rejects, reject the promise
    // returned by "updateTask()" as well.
    }, (error) =&gt; {
      reject(error);
    });
  });
}

// A basic helper action creator for when the
// "updateTask()" function is rejected.
export function updateTaskError(error) {
  dispatcher.dispatch({
    type: UPDATE_TASK_ERROR,
    payload: error
  });
}</pre></div><p>Now let's call this<a id="id190" class="indexterm"/> <code class="literal">updateTask()</code> function and see if we can assign error handling behavior to it:</p><div class="informalexample"><pre class="programlisting">import dispatcher from './dispatcher';
import {
  UPDATE_TASK,
  UPDATE_TASK_ERROR,
  updateTask,
  updateTaskError
} from './actions/update-task';

// Logs the payload as actions are dispatched...
dispatcher.register((e) =&gt; {
  switch (e.type) {
    case UPDATE_TASK:
      console.log('task updated');
      break;
    case UPDATE_TASK_ERROR:
      console.error(e.payload);
      break;
  }
});

// We can tell "updateTask()" how to respond when
// the underlying API call fails.
updateTask().catch(updateTaskError);
// → Failed to update task</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Summary</h1></div></div></div><p>This chapter focused on asynchronous action creators in Flux architectures. These are functions that need to dispatch actions, but before they can, they have to wait for some asynchronous resource to resolve. We looked at the synchronous update round concept, which is central to any Flux architecture. Then, we discussed how action creators encapsulate asynchronous behavior in such a way that they preserve the synchronous update rounds.</p><p>Network calls are the most common form of asynchronous communication in JavaScript applications, including Flux architectures. We covered the difference between these and other asynchronous channels, and how promises can be used to bridge the gap between them. We also looked at how promises can be utilized by action creator functions to allow for the composition of more complex functionality.</p><p>In the next chapter, we'll take a deeper look at stores and everything they have to do to maintain consistent state in our Flux architectures.</p></div></body></html>