- en: Chapter 14. Node.js and Beyond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, this book has shown you how to work with JavaScript and Node.js in a
    variety of use cases. In this chapter, we'll look at how the JavaScript ecosystem
    is continuing to evolve. We'll also see how the .NET and JavaScript ecosystems
    influence each other and how to integrate them within a single project.
  prefs: []
  type: TYPE_NORMAL
- en: While the chapters so far have aimed to start you on your path into Node.js
    and JavaScript, this chapter aims to map out the remaining territory. Each of
    the preceding chapters has provided in-depth step-by-step coverage of a single
    topic. This chapter will cover a much broader range of topics, with links to resources
    for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how Node.js and JavaScript are continuing to evolve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce some of the new and upcoming JavaScript language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at some alternative programming languages for Node.js and the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider principles from Node.js that can apply to .NET programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to integrate Node.js with .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Node.js versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why Node.js?"),
    *Why Node.js?*, the release of Node.js v4 in 2015 shows the platform coming to
    maturity. If you've used Node.js before the end of 2015, you would have seen version
    numbers such as v0.8.0 or v0.12.0\. So why the leap to v4.0.0?
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js is an open-source project with a corporate sponsor, Joyent. This means
    that a single company has a lot of influence over the direction of Node.js, but
    anyone can create their own fork of the source code. This is exactly what happened
    at the end of 2014\. A group of major contributors to Node.js split the project
    to create a new fork, named **io.js**. A few key properties of io.js were:'
  prefs: []
  type: TYPE_NORMAL
- en: A more open governance model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more regular release cycle, keeping more up-to-date with the underlying V8
    engine, to take advantage of performance improvements and newer JavaScript language
    features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A move to semantic versioning (see [http://semver.org/](http://semver.org/)),
    resulting in major version numbers increasing more quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over the course of 2015, the Node.js project reshaped itself to take on the
    above properties and align with io.js. In September 2015, the release of Node.js
    v4 brought the two projects back together under a new governance model. Node.js
    v4 supersedes (and merges) both Node.js v0.12 and io.js v3.3\. You can read more
    about the new governance model at [https://nodejs.org/en/about/governance/](https://nodejs.org/en/about/governance/).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Node.js LTS schedule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The timetable for Node.js releases now follows a regular schedule. A new stable
    release occurs every 6 months. Each stable branch receives fixes as well as new
    features that reach maturity. The lifetime of stable releases alternates as follows
    (as shown in the following chart):'
  prefs: []
  type: TYPE_NORMAL
- en: Odd-numbered branches live for 9 months
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even-numbered branches enter **long-term support** (**LTS**) after 6 months,
    receiving bug fixes but no new features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long-term support lasts for 30 months, with the final 12 months being maintenance
    mode (critical bug fixes only)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Introducing the Node.js LTS schedule](img/image00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can find more details of the LTS model at [https://github.com/nodejs/LTS](https://github.com/nodejs/LTS).
  prefs: []
  type: TYPE_NORMAL
- en: The LTS model allows you to have confidence in Node.js as a platform for your
    application. The code in this book targets Node.js v6, the current stable release
    at the time of publication. This version will be in LTS through to April 2019,
    some three years later.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ECMAScript versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript is the formal standard for the JavaScript language. The first three
    iterations of the language occurred between 1997 and 1999\. A 10-year gap followed
    before ECMAScript 5 in December 2009\. ES5 introduced few new features and focused
    on cleaning up the language. It introduced strict modes and addressed various
    inconsistencies, flaws, or gotchas in earlier versions.
  prefs: []
  type: TYPE_NORMAL
- en: 2015 saw a major change to the language and to the versioning approach. ECMAScript
    2015 (formerly ECMAScript 6) introduced many significant new language features.
    These include classes, `let`/`const` keywords and block-scoping, arrow functions,
    and native promises. In the rest of this chapter, we'll look at some of the other
    significant new features in ES2015.
  prefs: []
  type: TYPE_NORMAL
- en: The name change from ES6 to ES2015 indicates a new yearly versioning model.
    From 2015 onwards, there will be a new version of the ECMAScript standard every
    year. Planned features that aren't quite ready for release will wait until the
    following year. For this reason, ECMAScript 2016 is a small release with only
    a couple of new features.
  prefs: []
  type: TYPE_NORMAL
- en: Note that ECMAScript is the standard and it takes time for new features to be
    implemented. Indeed, some ES2015 features are still missing from the JavaScript
    engines in popular browsers. Note though that the major browser vendors are part
    of the ECMAScript standards process. So browsers, and Chrome's V8 engine (used
    by Node.js) in particular, should generally not lag too far behind the latest
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ECMAScript 2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used many of the new features of ES2015 throughout this book,
    such as arrow functions, template strings, and promises. We have also already
    seen ES2015's syntax for classes in [Chapter 3](part0022.xhtml#aid-KVCC1 "Chapter 3. A
    JavaScript Primer"), *A JavaScript Primer*.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 is a major update to the language, including many new features and syntax
    improvements. This section will cover some of the other useful improvements that
    we haven't seen so far in the book. For complete coverage of everything new in
    ES2015, see the excellent *Exploring ES6*, available at [http://exploringjs.com/es6/](http://exploringjs.com/es6/).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ES2015 modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in previous chapters, ES2015 introduces a new module specification.
    Recall from [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing Node.js
    Modules"), *Introducing Node.js Modules*, that each module system provides the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A way of declaring a module with a name and its own scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of defining functionality provided by the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of importing a module into another script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modules are scoped to their containing file, as in CommonJS. Modules provide
    functionality via a new `export` keyword. Prefixing an expression with `export`
    is equivalent to making it a property of the `module.exports` variable in CommonJS.
    A special `default export` is equivalent to assigning the value of `module.exports`
    itself. Modules are imported using an `import` keyword rather than a special `require`
    function. There is one additional restriction: imports must come at the top of
    the script, before any conditional blocks or other logic.'
  prefs: []
  type: TYPE_NORMAL
- en: These might seem like small syntax changes, but they have an important implication.
    Because defining and importing modules doesn't involve assignment and method calls,
    the structure of dependencies between modules is static. This allows the JavaScript
    engine to optimize loading of modules (particularly important in the browser).
    It also means that cyclic dependencies between modules can be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about the new ES2015 module syntax at [http://jsmodules.io/](http://jsmodules.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Using syntax improvements from ES2015
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we'll look at some of the new syntax features in ES2015 that
    we haven't used in the book so far. These are all available in the latest JavaScript
    engines, including Node.js v6.
  prefs: []
  type: TYPE_NORMAL
- en: The for... of loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say we have an array defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's also say that another library has added a helper function to all arrays.
    Perhaps something like our `flatMap` function from [Chapter 13](part0076.xhtml#aid-28FAO2
    "Chapter 13. Creating JavaScript Packages"), *Creating JavaScript Packages*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to iterate through all the members of an array, you might be
    tempted to use JavaScript''s `for... in` construct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn''t work very well though, as it includes properties on the array''s
    prototype and prints out the `flatMap` function as well as the elements in the
    array. This is a common problem with `for... in` loops, when used with objects
    as well as with arrays. The standard way to avoid it is by skipping prototype
    properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This prints out just the elements of the array, as we want. A similar loop could
    also be used to print the properties of an object, without accidentally attempting
    to print out functions from the prototype (which may have been added by a third-party
    library).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `for... in` also doesn''t technically guarantee the order in which
    it iterates through the keys of an object. This means it''s not really the best
    thing to use with arrays, where we expect a specific order. That''s why the standard
    way to iterate through arrays is using a plain old `for` loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'ES2015 addresses these issues with a new `for... of` loop, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is very similar to `for... in` loops. However, you do not need to
    filter out prototype members as these are excluded. It can be used with any iterable
    objects (such as arrays) and will follow the natural ordering of the iterable.
    In short, `for... of` loops are like `for... in` loops but without any nasty surprises.
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator and rest parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **spread operator** allows you to treat arrays as if they were a sequence
    of values. For example, to call a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the spread operator within array literals, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The **rest parameter** syntax serves the opposite purpose, turning a sequence
    of values into an array. This is similar to the `params` keyword in C# or `varargs`
    in Java. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Destructuring** allows you to use structuring syntax to assign multiple variables
    together. For example, you can assign variables using the array literal syntax
    to destructure arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine destructuring with the spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use destructuring with the object literal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring is particularly useful for dealing with complex return values.
    Imagine if any of the expressions on the right-hand side of the equals sign in
    the above examples were actually function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring is also useful for performing multiple assignments in a single
    statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Introducing generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES2016 introduces **generator functions** and the `yield` keyword. You may
    already be familiar with the `yield` keyword in C#. Methods that return `IEnumerable`/`IEnumerator`
    can include the `yield` keyword to return one element at a time, suspending execution
    of the method until the next value is requested. You can do the same with generator
    functions in JavaScript. The following example is a JavaScript implementation
    of one of the examples from the MSDN documentation of C#''s `yield`. It prints
    the first eight powers of 2 (note the asterisk after the function keyword, which
    denotes this as a generator function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `for... of` loops work with generators. The above loop is equivalent
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that generators are very similar to the `IEnumerator` interface
    in C#. Note that they are slightly more powerful than this though. We can also
    pass a value *into* a generator''s `next` method to allow it to be used when execution
    continues in the generator function. The following dummy example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the previous example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This two-way communication makes generators much more than just `IEnumerator`
    for JavaScript. They are a powerful control flow mechanism, especially when combined
    with promises. See [https://www.promisejs.org/generators/](https://www.promisejs.org/generators/)
    for a derivation of C#-like `async`/`await` functionality using generators and
    promises (with `yield` taking the place of C#'s `await` keyword). It's also worth
    noting that `async` functions are planned for a future version of ECMAScript (probably
    ES2017) and will work in a similar way. In the meantime, you can achieve a similar
    programming model using the `Promise.coroutine` method provided by the bluebird
    library, which is based on generators. See [http://bluebirdjs.com/docs/api/promise.coroutine.html](http://bluebirdjs.com/docs/api/promise.coroutine.html)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ECMAScript 2016
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, ECMAScript 2016 is a small release with
    only a couple of new features. These are an `includes` method for arrays and the
    exponentation operator `**`.
  prefs: []
  type: TYPE_NORMAL
- en: You can write `myArray.includes(value)` instead of `myArray.indexOf(value) !==
    -1`. Note that these expressions are not quite equivalent. You can use `includes`
    to check for the value `NaN` within an array, which you can't do with `indexOf`.
  prefs: []
  type: TYPE_NORMAL
- en: The exponential operator allows you to rewrite `Math.pow(coefficient, exponent)`
    as `coefficient ** exponent`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also combine it with an assignment, as in `myVariable **= 2`.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to target browsers or Node.js, JavaScript is the only language natively
    supported by these environments. This is different to VM-based environments like
    the .NET runtime and the JVM, which support multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET runtime supports C#, F#, VB.NET, and others. The JVM supports Java,
    Scala, Clojure, and others. These languages work by compiling down to an assembly
    language for the environment's VM. This is the Common Intermediate Language in
    .NET or Java bytecode in the case of the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: There is a reason why programmers don't all write CIL or Java bytecode though.
    These are low-level machine languages and much less human-friendly than C#, Java,
    and so on. In general, higher-level languages can support better productivity,
    as well as safety (for example, through type systems and memory management).
  prefs: []
  type: TYPE_NORMAL
- en: There is also a reason why .NET programmers don't always use C# and JVM programmers
    don't always use Java. A range of languages can serve different use cases better.
    It can also just be a matter of personal taste for the semantics of a particular
    language.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has been called the *Assembly Language for the Web* ([http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx](http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx)).
    While JavaScript is not a low-level or machine language, it is a common language
    for its platform. Like CIL and Java bytecode, it can serve as a compile target
    for other languages. And, like .NET and the JVM, there is an appetite amongst
    developers for a variety of languages on the same platform.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring compile-to-JavaScript languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several languages that support web and Node.js development by compiling
    down to JavaScript. We'll look at a few of the more prominent of these languages
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The TypeScript language is developed and supported by Microsoft. Its key aim
    is to include features that aid large-scale application development. TypeScript
    can be compiled down to ES2016, ES5, or even ES3\. So it works in any modern JavaScript
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is based closely on the JavaScript syntax. It is a superset of JavaScript,
    so you can write ordinary JavaScript and gradually use TypeScript features more
    as you learn it. TypeScript also tries to match the syntax of upcoming JavaScript
    features where possible. This allows developers to start using new JavaScript
    features earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The most important TypeScript features aid large-scale application development.
    TypeScript has had classes and modules for some time, to help with structuring
    code. As the name suggests, TypeScript also adds type annotations and type inference.
    It also adds new ways of defining and specifying types, including enums, generic
    types, and interfaces. This makes for a safer language as the compiler can catch
    more errors. It also lets IDEs offer features like code completion (namely, Intellisense)
    and better source code navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, TypeScript makes it possible to specify type definitions for libraries
    written in plain JavaScript. Type definitions for many third-party libraries can
    be found at [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
    These provide type checking and code completion when working with library code
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of our `flatMap` function from the previous chapter written
    with type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for generics may be familiar from C#. Type annotations follow the
    expression or parameter, separated by a colon. We could specify the generic type
    when we call the function too, but in this case it can be inferred. Note that
    our method has two generic types, as our callback could map to an array of a different
    element type. The TypeScript compiler will infer the type of `result` as `number[]`.
    Note that this inference actually takes a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We specify that the `callback` parameter `i` has a type `number`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the expressions `i` and `i + 0.5` also both have a type `number`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the result type of our `callback` is `number[]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the argument for the type parameter `R` must be `number`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we did not specify the type of `i`, then the compiler would only infer the
    type of `result` as `any[]`, that is an array, but of an unspecified element type.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about TypeScript at [http://www.typescriptlang.org/](http://www.typescriptlang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're more familiar with Java than .NET, and especially if you're familiar
    with the Eclipse IDE in particular, you may also be interested in N4JS ([http://numberfour.github.io/n4js/](http://numberfour.github.io/n4js/)).
    This language has similar goals to TypeScript, but is inspired by Java and has
    an IDE based on Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: CoffeeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CoffeeScript was one of the earliest successful compile-to-JavaScript languages.
    CoffeeScript streamlines the syntax of JavaScript and adds features for writing
    more terse and expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: CoffeeScript is a good example of when taste might influence language choice.
    Developers may find CoffeeScript more readable and/or easier to write. Ruby or
    Python programmers may be particularly comfortable with CoffeeScript. They'll
    find its syntax and many of its language features familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Many features from CoffeeScript have subsequently appeared in ES2015, for example
    arrow functions, destructuring, and the splat/spread operator. Unlike TypeScript,
    CoffeeScript does not attempt to match the syntax of JavaScript, neither for current
    nor upcoming features. It does however offer seamless interoperability with JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comprehensions are one of CoffeeScript''s most expressive features and do not
    appear in ES2015\. You may be familiar with comprehensions from Python. They are
    also a little like LINQ in C#, in that they allow you to express operations on
    lists without using loops. The following example prints the squares of even numbers,
    first in JavaScript and then as a one-liner in CoffeeScript. As `squares.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As `squares.coffee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And beyond...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript and CoffeeScript are specifically designed to target JavaScript.
    There are many other projects in existence that allow more general languages to
    compile JavaScript. Note that not all such projects are mature or well-maintained.
    Languages whose own project team supports and maintains compilation to JavaScript
    tend to be a safer choice. Both Dart ([https://www.dartlang.org/](https://www.dartlang.org/))
    and Clojure ([http://clojure.org/](http://clojure.org/)) provide first-class support
    for compiling to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a true assembly language for the web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed above, while JavaScript can be a common compile target for the
    web and Node.js, it is not a true assembly language. It is a high-level human-readable
    language, rather than an optimized machine language. There are projects to introduce
    just such a language into the web environment though. This means defining an assembly
    language implemented by all browsers, including Chrome's V8 engine and therefore
    Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding asm.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first attempt at such a language is asm.js ([http://asmjs.org/](http://asmjs.org/)),
    developed by Mozilla. This is a strict subset of JavaScript, which means it can
    run on any browser. But browsers that support asm.js can precompile it and heavily
    optimize its execution. Demanding applications such as 3D games can be recompiled
    to target asm.js and run seamlessly in-browser. The first environment with full
    support for asm.js is Mozilla's own Firefox browser. It will also be supported
    in Microsoft's new Edge browser. The V8 engine used by Chrome (and Node.js) does
    not yet pre-compile asm.js, but V8 does make some optimizations to allow asm.js
    to run much faster than if interpreted as plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WebAssembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebAssembly ([https://webassembly.github.io/](https://webassembly.github.io/))
    is a new standard for a true assembly language for the web. Unlike asm.js it is
    not a subset of JavaScript and won't run in today's browsers. It defines a new
    assembly language more like CIL or Java bytecode. It is developed by the W3C standards
    body, with input from the major browser vendors. There are early implementations
    of WebAssembly in preview releases of Mozilla Firefox, Google Chrome, and Microsoft
    Edge.
  prefs: []
  type: TYPE_NORMAL
- en: As an application developer, you do not need to be able to write WebAssembly
    any more than you need to write CIL or Java bytecode. These are all low-level
    languages to act as compilation targets. In future, WebAssembly may replace JavaScript
    as the common compile target for the web (and Node.js). Other languages, including
    JavaScript itself, may all compile to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: This would mean that JavaScript would no longer be the only native language
    for the web and Node.js. But JavaScript will almost certainly remain the default
    development language for these environments, just as C# and Java are for their
    respective environments. Knowledge of the execution model of Node.js will still
    be relevant in any language and JavaScript will still be the most natural fit
    for this execution model. Knowledge of JavaScript will also be important for working
    with the many well-established libraries based on it.
  prefs: []
  type: TYPE_NORMAL
- en: There would be other benefits to JavaScript from WebAssembly. Interoperation
    between JavaScript and other languages will become easier. There will be more
    options for implementing performance-critical code. New versions of JavaScript
    will be able to roll out more quickly (as a single JavaScript to WebAssembly compiler
    can target all browser engines).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript and ASP.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the server side, we don't need to wait for WebAssembly to mature in order
    to work with Node.js and .NET together. There is already some convergence between
    programming on these two platforms and support for interoperability between them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring .NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next version of NET, called .NET Core, makes some major changes to the platform.
    Some of these changes might seem familiar if you've spent some time working with
    Node.js. This is not just a coincidence. Microsoft are incorporating good ideas
    that have worked in Node.js and elsewhere into their ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Defining project structure in .NET Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET Core separates the programming platform from the IDE. Microsoft still recommends
    using Visual Studio, but have made it much easier to use other editors. For example,
    the OmniSharp project ([http://www.omnisharp.net/](http://www.omnisharp.net/))
    supports development in other editors, providing features such as Intellisense
    outside of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: One aspect of this change is simplifying the use of `.csproj` files. In previous
    versions of .NET, these large XML files were the canonical description of each
    C# project. They included important things like compilation options, target platforms,
    build steps, and dependencies. They were mainly generated by Visual Studio, difficult
    to edit by hand, and often particularly awkward to merge in source control. To
    satisfy Visual Studio, they also needed to list every single source file in the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these drawbacks are addressed in .NET Core. New tools make it much easier
    to edit `.csproj` files from the command line. A project's sources are just the
    files under its parent folder (not listed in `.csproj` or any other metadata file).
    Dependencies are declared separately in a more lightweight JSON-based file.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these improvements are inspired by programming platforms like Node.js.
    In fact, early release candidates for .NET Core removed the need for `.csproj`
    files entirely and introduced `project.json` files (just like in Node.js) for
    defining projects. Although .NET Core ultimately uses `.csproj` files (for continued
    compatibility with MSBuild), it aims to keep those aspects of more lightweight
    approaches that are most important to developers.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies in .NET Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NuGet package manager has been part of the .NET ecosystem for several years.
    NuGet becomes even more important in .NET Core. The framework and runtime themselves
    are distributed as NuGet packages. Dependencies are specified as NuGet package
    names (and versions) rather than DLL paths. NuGet packages can also be a useful
    unit of deployment for your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with Node.js, you can checkout the source code of one of your dependencies
    to a local folder and reference it there. This allows you to tinker with open
    source libraries and debug them as part of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Building web applications in ASP.NET Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ASP.NET Core consolidates ASP.NET MVC and WebAPI into a single framework. It
    also brings OWIN to the fore as the standard abstraction for implementing web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: OWIN simply defines a standard for passing request and response objects between
    a host and an application. Although OWIN has been around for a while and has its
    own history, this is a similar abstraction to the `http.createServer` method in
    Node.js. You can read more about OWIN at [https://docs.asp.net/en/latest/fundamentals/owin.html](https://docs.asp.net/en/latest/fundamentals/owin.html).
  prefs: []
  type: TYPE_NORMAL
- en: Related to this, ASP.NET also uses middleware as the standard building block
    for web applications. Again, although middleware in .NET has its own history,
    the abstraction is very similar to middleware in Express. Applications set up
    a pipeline of middleware, with each having access to the request, response, and
    the next handler in the chain. Built-in middleware is available for cross-cutting
    concerns such as authentication, sessions, and routing. You can read more about
    middleware at [https://docs.asp.net/en/latest/fundamentals/middleware.html](https://docs.asp.net/en/latest/fundamentals/middleware.html)
  prefs: []
  type: TYPE_NORMAL
- en: Integration with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio has provided good support for client-side JavaScript development
    for several years. Microsoft have improved and updated this in the latest versions
    of ASP.NET and Visual Studio: for example, by including better integration with
    task runners such as Gulp and Grunt. You can read more about client-side JavaScript
    support at [https://docs.asp.net/en/latest/client-side/index.html](https://docs.asp.net/en/latest/client-side/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side JavaScript integration with .NET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Edge.js project ([https://github.com/tjanczuk/edge](https://github.com/tjanczuk/edge))
    allows Node.js and .NET to run within the same process. It also defines a very
    simple way for marshalling method calls between the two. This is much faster than
    marshalling calls out-of-process (for example, via an HTTP call to a process on
    the local machine).
  prefs: []
  type: TYPE_NORMAL
- en: Edge.js allows you to take the best of .NET and Node.js. Perhaps you want to
    use Node.js to put a web interface on top of your existing .NET business logic.
    Or perhaps you're using Node.js for rapid development of most of your application,
    but have a particularly CPU-intensive operation that would be easier to optimize
    in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making calls from Node.js to .NET (or vice versa) is very simple. For example,
    if we have the following .NET class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it from JavaScript as follows (after running `npm install edge`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling our C# code and running our JavaScript file results in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can find a good introduction to Edge.js at [http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx](http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, recall that the OWIN standard and ASP.NET middleware are quite similar
    to the corresponding concepts in JavaScript. Edge.js makes it easy to include
    a .NET OWIN application as middleware in a Node.js Express application. See the
    `connect-owin` project at [https://github.com/bbaia/connect-owin](https://github.com/bbaia/connect-owin)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how Node.js and JavaScript's new release cycles
    bring stability to the platform. We have introduced some of the new and upcoming
    features of JavaScript. We have explored current and future alternative languages
    for the JavaScript environment. We have seen some of the commonalities between
    .NET and Node.js and how to use these technologies together.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this book has allowed you to get up-and-running with Node.js and given
    you an appetite to learn more. The resources in this chapter will help you take
    the next step on your journey with JavaScript and Node.js.
  prefs: []
  type: TYPE_NORMAL
