- en: Chapter 14. Node.js and Beyond
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章 Node.js 与其超越
- en: So far, this book has shown you how to work with JavaScript and Node.js in a
    variety of use cases. In this chapter, we'll look at how the JavaScript ecosystem
    is continuing to evolve. We'll also see how the .NET and JavaScript ecosystems
    influence each other and how to integrate them within a single project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书已经向您展示了如何在各种用例中与JavaScript和Node.js一起工作。在本章中，我们将探讨JavaScript生态系统如何持续发展。我们还将看到.NET和JavaScript生态系统如何相互影响，以及如何在单个项目中集成它们。
- en: While the chapters so far have aimed to start you on your path into Node.js
    and JavaScript, this chapter aims to map out the remaining territory. Each of
    the preceding chapters has provided in-depth step-by-step coverage of a single
    topic. This chapter will cover a much broader range of topics, with links to resources
    for further reading.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止的章节旨在引导您进入Node.js和JavaScript的道路，但本章旨在绘制剩余的领域。前几章已经对单个主题进行了深入的逐步覆盖。本章将涵盖更广泛的主题范围，并提供进一步阅读的资源链接。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Understand how Node.js and JavaScript are continuing to evolve
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Node.js和JavaScript如何持续发展
- en: Introduce some of the new and upcoming JavaScript language features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些新的和即将推出的JavaScript语言特性
- en: Look at some alternative programming languages for Node.js and the web
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Node.js和Web的替代编程语言
- en: Consider principles from Node.js that can apply to .NET programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑适用于.NET编程的Node.js原则
- en: See how to integrate Node.js with .NET
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何将Node.js与.NET集成
- en: Understanding Node.js versioning
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Node.js版本控制
- en: As mentioned in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why Node.js?"),
    *Why Node.js?*, the release of Node.js v4 in 2015 shows the platform coming to
    maturity. If you've used Node.js before the end of 2015, you would have seen version
    numbers such as v0.8.0 or v0.12.0\. So why the leap to v4.0.0?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](part0014.xhtml#aid-DB7S2 "第1章. 为什么选择Node.js？")中所述，*为什么选择Node.js？*，2015年Node.js
    v4的发布显示了该平台正在走向成熟。如果您在2015年底之前使用过Node.js，您会看到如v0.8.0或v0.12.0之类的版本号。那么为什么会有v4.0.0的跳跃呢？
- en: A brief history of Node.js
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 简史
- en: 'Node.js is an open-source project with a corporate sponsor, Joyent. This means
    that a single company has a lot of influence over the direction of Node.js, but
    anyone can create their own fork of the source code. This is exactly what happened
    at the end of 2014\. A group of major contributors to Node.js split the project
    to create a new fork, named **io.js**. A few key properties of io.js were:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个有企业赞助的开源项目，赞助商为Joyent。这意味着一个公司对Node.js的发展方向有很大的影响力，但任何人都可以创建自己的源代码分支。这正是2014年底发生的事情。一组Node.js的主要贡献者将项目拆分，创建了一个新的分支，名为**io.js**。io.js的一些关键特性包括：
- en: A more open governance model
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更为开放的治理模式
- en: A more regular release cycle, keeping more up-to-date with the underlying V8
    engine, to take advantage of performance improvements and newer JavaScript language
    features
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更为规律的发布周期，与底层V8引擎保持更紧密的同步，以利用性能改进和新的JavaScript语言特性
- en: A move to semantic versioning (see [http://semver.org/](http://semver.org/)),
    resulting in major version numbers increasing more quickly
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向语义版本控制（见[http://semver.org/](http://semver.org/)），导致主版本号增加更快
- en: Over the course of 2015, the Node.js project reshaped itself to take on the
    above properties and align with io.js. In September 2015, the release of Node.js
    v4 brought the two projects back together under a new governance model. Node.js
    v4 supersedes (and merges) both Node.js v0.12 and io.js v3.3\. You can read more
    about the new governance model at [https://nodejs.org/en/about/governance/](https://nodejs.org/en/about/governance/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年期间，Node.js项目重塑自身以承担上述特性并与io.js保持一致。2015年9月，Node.js v4的发布将两个项目重新整合到一个新的治理模式之下。Node.js
    v4取代（并合并）了Node.js v0.12和io.js v3.3。您可以在[https://nodejs.org/en/about/governance/](https://nodejs.org/en/about/governance/)了解更多关于新治理模式的信息。
- en: Introducing the Node.js LTS schedule
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Node.js长期支持（LTS）计划
- en: 'The timetable for Node.js releases now follows a regular schedule. A new stable
    release occurs every 6 months. Each stable branch receives fixes as well as new
    features that reach maturity. The lifetime of stable releases alternates as follows
    (as shown in the following chart):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的发布时间表现在遵循一个常规的日程。每6个月就会有一个新的稳定版本发布。每个稳定分支都会收到修复以及成熟的新特性。稳定版本的寿命交替如下（如下表所示）：
- en: Odd-numbered branches live for 9 months
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇数分支存活9个月
- en: Even-numbered branches enter **long-term support** (**LTS**) after 6 months,
    receiving bug fixes but no new features
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶数分支在 6 个月后进入 **长期支持**（**LTS**）阶段，只接收错误修复，没有新特性
- en: Long-term support lasts for 30 months, with the final 12 months being maintenance
    mode (critical bug fixes only)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期支持持续 30 个月，最后 12 个月为维护模式（仅修复关键错误）
- en: '![Introducing the Node.js LTS schedule](img/image00230.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Node.js LTS 时间表](img/image00230.jpeg)'
- en: You can find more details of the LTS model at [https://github.com/nodejs/LTS](https://github.com/nodejs/LTS).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/nodejs/LTS](https://github.com/nodejs/LTS) 找到更多关于 LTS
    模型的详细信息。
- en: The LTS model allows you to have confidence in Node.js as a platform for your
    application. The code in this book targets Node.js v6, the current stable release
    at the time of publication. This version will be in LTS through to April 2019,
    some three years later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: LTS 模型使你能够对 Node.js 作为应用程序平台有信心。本书中的代码针对 Node.js v6，这是出版时的当前稳定版本。这个版本将一直处于 LTS
    状态，直到 2019 年 4 月，大约三年后。
- en: Understanding ECMAScript versioning
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ECMAScript 版本
- en: ECMAScript is the formal standard for the JavaScript language. The first three
    iterations of the language occurred between 1997 and 1999\. A 10-year gap followed
    before ECMAScript 5 in December 2009\. ES5 introduced few new features and focused
    on cleaning up the language. It introduced strict modes and addressed various
    inconsistencies, flaws, or gotchas in earlier versions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 是 JavaScript 语言的正式标准。语言的前三个版本发生在 1997 年至 1999 年之间。在 2009 年 12 月的
    ECMAScript 5 之前有一个 10 年的间隔。ES5 引入了很少的新特性，并专注于清理语言。它引入了严格模式，并解决了早期版本中的各种不一致性、缺陷或陷阱。
- en: 2015 saw a major change to the language and to the versioning approach. ECMAScript
    2015 (formerly ECMAScript 6) introduced many significant new language features.
    These include classes, `let`/`const` keywords and block-scoping, arrow functions,
    and native promises. In the rest of this chapter, we'll look at some of the other
    significant new features in ES2015.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年对语言和版本方法都进行了重大改变。ECMAScript 2015（以前称为 ECMAScript 6）引入了许多重要的新语言特性。这些包括类、`let`/`const`
    关键字和块作用域、箭头函数和原生的承诺。在本章的剩余部分，我们将探讨 ES2015 中的一些其他重要新特性。
- en: The name change from ES6 to ES2015 indicates a new yearly versioning model.
    From 2015 onwards, there will be a new version of the ECMAScript standard every
    year. Planned features that aren't quite ready for release will wait until the
    following year. For this reason, ECMAScript 2016 is a small release with only
    a couple of new features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ES6 到 ES2015 的名称变更表明了一个新的年度版本模型。从 2015 年开始，每年都会有新的 ECMAScript 标准版本。尚未准备好的计划特性将等待下一年。因此，ECMAScript
    2016 是一个小版本，只包含几个新特性。
- en: Note that ECMAScript is the standard and it takes time for new features to be
    implemented. Indeed, some ES2015 features are still missing from the JavaScript
    engines in popular browsers. Note though that the major browser vendors are part
    of the ECMAScript standards process. So browsers, and Chrome's V8 engine (used
    by Node.js) in particular, should generally not lag too far behind the latest
    standard.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，ECMAScript 是一个标准，新特性被实现需要时间。实际上，一些 ES2015 的特性在流行浏览器的 JavaScript 引擎中仍然缺失。不过，主要的浏览器供应商都是
    ECMAScript 标准流程的一部分。因此，浏览器，尤其是 Chrome 的 V8 引擎（Node.js 所使用），通常不会落后于最新的标准太远。
- en: Exploring ECMAScript 2015
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 ECMAScript 2015
- en: We have already used many of the new features of ES2015 throughout this book,
    such as arrow functions, template strings, and promises. We have also already
    seen ES2015's syntax for classes in [Chapter 3](part0022.xhtml#aid-KVCC1 "Chapter 3. A
    JavaScript Primer"), *A JavaScript Primer*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书中使用了 ES2015 的许多新特性，例如箭头函数、模板字符串和承诺。我们已经在 [第 3 章](part0022.xhtml#aid-KVCC1
    "第 3 章。JavaScript 入门") *JavaScript 入门* 中看到了 ES2015 的类语法。
- en: ES2015 is a major update to the language, including many new features and syntax
    improvements. This section will cover some of the other useful improvements that
    we haven't seen so far in the book. For complete coverage of everything new in
    ES2015, see the excellent *Exploring ES6*, available at [http://exploringjs.com/es6/](http://exploringjs.com/es6/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 是语言的一个重大更新，包括许多新特性和语法改进。本节将涵盖一些我们在本书中尚未见到的其他有用改进。要全面了解 ES2015 中的所有新特性，请参阅优秀的《探索
    ES6》，可在 [http://exploringjs.com/es6/](http://exploringjs.com/es6/) 获取。
- en: Understanding ES2015 modules
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ES2015 模块
- en: 'As mentioned in previous chapters, ES2015 introduces a new module specification.
    Recall from [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing Node.js
    Modules"), *Introducing Node.js Modules*, that each module system provides the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，ES2015引入了一种新的模块规范。回想一下[第4章](part0025.xhtml#aid-NQU21 "第4章：介绍Node.js模块")，*介绍Node.js模块*，每个模块系统都提供以下功能：
- en: A way of declaring a module with a name and its own scope
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明具有名称和自身作用域的模块的方式
- en: A way of defining functionality provided by the module
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块提供功能的方式
- en: A way of importing a module into another script
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块导入到另一个脚本中的方式
- en: 'Modules are scoped to their containing file, as in CommonJS. Modules provide
    functionality via a new `export` keyword. Prefixing an expression with `export`
    is equivalent to making it a property of the `module.exports` variable in CommonJS.
    A special `default export` is equivalent to assigning the value of `module.exports`
    itself. Modules are imported using an `import` keyword rather than a special `require`
    function. There is one additional restriction: imports must come at the top of
    the script, before any conditional blocks or other logic.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的作用域限定在其包含的文件中，就像CommonJS一样。模块通过一个新的`export`关键字提供功能。在表达式前加上`export`相当于将其作为`module.exports`变量的属性。特殊的`default
    export`相当于将`module.exports`的值赋给它。模块使用`import`关键字导入，而不是特殊的`require`函数。还有一个额外的限制：导入必须位于脚本顶部，在所有条件块或其他逻辑之前。
- en: These might seem like small syntax changes, but they have an important implication.
    Because defining and importing modules doesn't involve assignment and method calls,
    the structure of dependencies between modules is static. This allows the JavaScript
    engine to optimize loading of modules (particularly important in the browser).
    It also means that cyclic dependencies between modules can be resolved.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能看起来像是微小的语法变化，但它们有着重要的含义。因为定义和导入模块不涉及赋值和方法调用，模块之间的依赖结构是静态的。这允许JavaScript引擎优化模块的加载（这在浏览器中尤为重要）。这也意味着可以解决模块之间的循环依赖。
- en: You can find out more about the new ES2015 module syntax at [http://jsmodules.io/](http://jsmodules.io/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://jsmodules.io/](http://jsmodules.io/)了解更多关于新的ES2015模块语法的详细信息。
- en: Using syntax improvements from ES2015
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ES2015的语法改进
- en: In this section we'll look at some of the new syntax features in ES2015 that
    we haven't used in the book so far. These are all available in the latest JavaScript
    engines, including Node.js v6.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些ES2015中的一些新语法特性，这些特性我们在书中还没有使用过。这些特性在最新的JavaScript引擎中都是可用的，包括Node.js
    v6。
- en: The for... of loop
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for... of循环
- en: 'Let''s say we have an array defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义了一个如下所示的数组：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's also say that another library has added a helper function to all arrays.
    Perhaps something like our `flatMap` function from [Chapter 13](part0076.xhtml#aid-28FAO2
    "Chapter 13. Creating JavaScript Packages"), *Creating JavaScript Packages*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再假设另一个库已经为所有数组添加了一个辅助函数。可能类似于我们在第13章中提到的`flatMap`函数，[第13章：创建JavaScript包](part0076.xhtml#aid-28FAO2
    "第13章：创建JavaScript包")。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you wanted to iterate through all the members of an array, you might be
    tempted to use JavaScript''s `for... in` construct as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要遍历数组的所有成员，你可能倾向于使用JavaScript的`for... in`结构，如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This doesn''t work very well though, as it includes properties on the array''s
    prototype and prints out the `flatMap` function as well as the elements in the
    array. This is a common problem with `for... in` loops, when used with objects
    as well as with arrays. The standard way to avoid it is by skipping prototype
    properties as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不太有效，因为它包括了数组原型的属性，并打印出了`flatMap`函数以及数组中的元素。这是`for... in`循环的一个常见问题，无论是与对象还是数组一起使用时。避免这种情况的标准方法是跳过原型属性，如下所示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This prints out just the elements of the array, as we want. A similar loop could
    also be used to print the properties of an object, without accidentally attempting
    to print out functions from the prototype (which may have been added by a third-party
    library).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只打印出数组的元素，正如我们所期望的。类似的循环也可以用来打印对象的属性，而不会意外地尝试打印出原型上的函数（这些函数可能是由第三方库添加的）。
- en: 'Note that `for... in` also doesn''t technically guarantee the order in which
    it iterates through the keys of an object. This means it''s not really the best
    thing to use with arrays, where we expect a specific order. That''s why the standard
    way to iterate through arrays is using a plain old `for` loop, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`for... in` 在技术上并不保证迭代对象键的顺序。这意味着它并不是与数组一起使用的最佳选择，因为我们期望特定的顺序。这就是为什么标准的方法是使用普通的
    `for` 循环来遍历数组，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'ES2015 addresses these issues with a new `for... of` loop, which looks like
    this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 通过引入新的 `for... of` 循环来解决这些问题，其语法如下：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The syntax is very similar to `for... in` loops. However, you do not need to
    filter out prototype members as these are excluded. It can be used with any iterable
    objects (such as arrays) and will follow the natural ordering of the iterable.
    In short, `for... of` loops are like `for... in` loops but without any nasty surprises.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与 `for... in` 循环非常相似。然而，你不需要过滤原型成员，因为这些成员被排除在外。它可以与任何可迭代对象（如数组）一起使用，并遵循可迭代对象的自然顺序。简而言之，`for...
    of` 循环就像 `for... in` 循环，但没有任何令人不快的惊喜。
- en: The spread operator and rest parameters
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展运算符和剩余参数
- en: 'The **spread operator** allows you to treat arrays as if they were a sequence
    of values. For example, to call a function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展运算符** 允许你将数组视为一系列值。例如，要调用一个函数：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also use the spread operator within array literals, for example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在数组字面量中使用扩展运算符，例如：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The **rest parameter** syntax serves the opposite purpose, turning a sequence
    of values into an array. This is similar to the `params` keyword in C# or `varargs`
    in Java. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**剩余参数** 语法具有相反的作用，将一系列值转换为一个数组。这与 C# 中的 `params` 关键字或 Java 中的 `varargs` 类似。例如：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Destructuring assignment
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构赋值
- en: '**Destructuring** allows you to use structuring syntax to assign multiple variables
    together. For example, you can assign variables using the array literal syntax
    to destructure arrays:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**解构**允许你使用结构化语法一起分配多个变量。例如，你可以使用数组字面量语法来解构数组：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also combine destructuring with the spread operator:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将解构与扩展运算符结合使用：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, you can use destructuring with the object literal syntax:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用对象字面量语法进行解构：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Destructuring is particularly useful for dealing with complex return values.
    Imagine if any of the expressions on the right-hand side of the equals sign in
    the above examples were actually function calls.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解构对于处理复杂的返回值特别有用。想象一下，如果上述示例中等于号右侧的任何表达式实际上是函数调用。
- en: 'Destructuring is also useful for performing multiple assignments in a single
    statement. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解构对于在单个语句中执行多个赋值也很有用。例如：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Introducing generators
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍生成器
- en: 'ES2016 introduces **generator functions** and the `yield` keyword. You may
    already be familiar with the `yield` keyword in C#. Methods that return `IEnumerable`/`IEnumerator`
    can include the `yield` keyword to return one element at a time, suspending execution
    of the method until the next value is requested. You can do the same with generator
    functions in JavaScript. The following example is a JavaScript implementation
    of one of the examples from the MSDN documentation of C#''s `yield`. It prints
    the first eight powers of 2 (note the asterisk after the function keyword, which
    denotes this as a generator function):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016 引入了 **生成器函数** 和 `yield` 关键字。你可能已经熟悉 C# 中的 `yield` 关键字。返回 `IEnumerable`/`IEnumerator`
    的方法可以包含 `yield` 关键字，一次返回一个元素，直到请求下一个值时才暂停方法的执行。你可以在 JavaScript 中的生成器函数中做同样的事情。以下是一个
    JavaScript 实现的示例，它来自 C# 的 `yield` 的 MSDN 文档中的一个示例。它打印出 2 的前八个幂（注意函数关键字后面的星号，表示这是一个生成器函数）：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that `for... of` loops work with generators. The above loop is equivalent
    to the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`for... of` 循环与生成器一起工作。上面的循环等同于以下代码：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see that generators are very similar to the `IEnumerator` interface
    in C#. Note that they are slightly more powerful than this though. We can also
    pass a value *into* a generator''s `next` method to allow it to be used when execution
    continues in the generator function. The following dummy example illustrates this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到生成器与 C# 中的 `IEnumerator` 接口非常相似。注意，尽管如此，它们的功能要强大一些。我们还可以将一个值传递到生成器的 `next`
    方法中，以便在生成器函数继续执行时使用。以下是一个示例来说明这一点：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the previous example produces the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的示例会产生以下输出：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This two-way communication makes generators much more than just `IEnumerator`
    for JavaScript. They are a powerful control flow mechanism, especially when combined
    with promises. See [https://www.promisejs.org/generators/](https://www.promisejs.org/generators/)
    for a derivation of C#-like `async`/`await` functionality using generators and
    promises (with `yield` taking the place of C#'s `await` keyword). It's also worth
    noting that `async` functions are planned for a future version of ECMAScript (probably
    ES2017) and will work in a similar way. In the meantime, you can achieve a similar
    programming model using the `Promise.coroutine` method provided by the bluebird
    library, which is based on generators. See [http://bluebirdjs.com/docs/api/promise.coroutine.html](http://bluebirdjs.com/docs/api/promise.coroutine.html)
    for details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双向通信使得生成器在 JavaScript 中远不止是 `IEnumerator`。它们是一种强大的控制流机制，尤其是在与承诺结合使用时。参见[https://www.promisejs.org/generators/](https://www.promisejs.org/generators/)，了解如何使用生成器和承诺（用
    `yield` 代替 C# 的 `await` 关键字）实现类似 C# 的 `async`/`await` 功能。还值得注意的是，`async` 函数计划在
    ECMAScript 的未来版本（可能是 ES2017）中实现，并且将以类似的方式工作。在此期间，您可以使用 bluebird 库提供的 `Promise.coroutine`
    方法实现类似的编程模型，该方法基于生成器。有关详细信息，请参见[http://bluebirdjs.com/docs/api/promise.coroutine.html](http://bluebirdjs.com/docs/api/promise.coroutine.html)。
- en: Introducing ECMAScript 2016
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 ECMAScript 2016
- en: As mentioned earlier in this chapter, ECMAScript 2016 is a small release with
    only a couple of new features. These are an `includes` method for arrays and the
    exponentation operator `**`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，ECMAScript 2016 是一个小版本，只包含几个新功能。这些是一个用于数组的 `includes` 方法以及指数运算符 `**`。
- en: You can write `myArray.includes(value)` instead of `myArray.indexOf(value) !==
    -1`. Note that these expressions are not quite equivalent. You can use `includes`
    to check for the value `NaN` within an array, which you can't do with `indexOf`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `myArray.includes(value)` 代替 `myArray.indexOf(value) !== -1`。请注意，这些表达式并不完全等价。您可以使用
    `includes` 在数组中检查值 `NaN`，这是您无法使用 `indexOf` 做到的。
- en: The exponential operator allows you to rewrite `Math.pow(coefficient, exponent)`
    as `coefficient ** exponent`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 指数运算符允许您将 `Math.pow(coefficient, exponent)` 重写为 `coefficient ** exponent`。
- en: You can also combine it with an assignment, as in `myVariable **= 2`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将其与赋值结合使用，例如 `myVariable **= 2`。
- en: Going beyond JavaScript
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越 JavaScript
- en: If you want to target browsers or Node.js, JavaScript is the only language natively
    supported by these environments. This is different to VM-based environments like
    the .NET runtime and the JVM, which support multiple languages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想针对浏览器或 Node.js，JavaScript 是这些环境中唯一原生支持的编程语言。这与基于虚拟机的环境（如 .NET 运行时和 JVM）不同，这些环境支持多种语言。
- en: The .NET runtime supports C#, F#, VB.NET, and others. The JVM supports Java,
    Scala, Clojure, and others. These languages work by compiling down to an assembly
    language for the environment's VM. This is the Common Intermediate Language in
    .NET or Java bytecode in the case of the JVM.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 运行时支持 C#、F#、VB.NET 等语言。JVM 支持Java、Scala、Clojure 等语言。这些语言通过将代码编译成环境虚拟机的汇编语言来工作。在
    .NET 中这是公共中间语言（CIL），在 JVM 的情况下是 Java 字节码。
- en: There is a reason why programmers don't all write CIL or Java bytecode though.
    These are low-level machine languages and much less human-friendly than C#, Java,
    and so on. In general, higher-level languages can support better productivity,
    as well as safety (for example, through type systems and memory management).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，程序员并不都编写 CIL 或 Java 字节码，这也有原因。这些都是低级机器语言，比 C#、Java 等语言要少有人性化。一般来说，高级语言可以支持更高的生产力，以及安全性（例如，通过类型系统和内存管理）。
- en: There is also a reason why .NET programmers don't always use C# and JVM programmers
    don't always use Java. A range of languages can serve different use cases better.
    It can also just be a matter of personal taste for the semantics of a particular
    language.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 程序员并不总是使用 C#，JVM 程序员也不总是使用 Java，这也有原因。不同的语言可以更好地满足不同的用例。这也可以仅仅是个人对特定语言语法的喜好问题。
- en: JavaScript has been called the *Assembly Language for the Web* ([http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx](http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx)).
    While JavaScript is not a low-level or machine language, it is a common language
    for its platform. Like CIL and Java bytecode, it can serve as a compile target
    for other languages. And, like .NET and the JVM, there is an appetite amongst
    developers for a variety of languages on the same platform.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript被称为“Web的汇编语言”([http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx](http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx))。虽然JavaScript不是低级或机器语言，但它是其平台上的通用语言。像CIL和Java字节码一样，它可以作为其他语言的编译目标。而且，像.NET和JVM一样，开发者对同一平台上的多种语言有需求。
- en: Exploring compile-to-JavaScript languages
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索编译到JavaScript的语言
- en: There are several languages that support web and Node.js development by compiling
    down to JavaScript. We'll look at a few of the more prominent of these languages
    in this section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种语言通过编译成JavaScript来支持Web和Node.js开发。在本节中，我们将探讨其中一些较为突出的语言。
- en: TypeScript
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TypeScript
- en: The TypeScript language is developed and supported by Microsoft. Its key aim
    is to include features that aid large-scale application development. TypeScript
    can be compiled down to ES2016, ES5, or even ES3\. So it works in any modern JavaScript
    environment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言由Microsoft开发和支持。其关键目标是包括有助于大规模应用程序开发的特性。TypeScript可以编译成ES2016、ES5，甚至ES3。因此，它在任何现代JavaScript环境中都能工作。
- en: TypeScript is based closely on the JavaScript syntax. It is a superset of JavaScript,
    so you can write ordinary JavaScript and gradually use TypeScript features more
    as you learn it. TypeScript also tries to match the syntax of upcoming JavaScript
    features where possible. This allows developers to start using new JavaScript
    features earlier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript基于JavaScript语法紧密构建。它是JavaScript的超集，因此您可以编写普通的JavaScript，随着学习的深入，逐渐更多地使用TypeScript特性。TypeScript还试图尽可能匹配即将推出的JavaScript特性的语法。这允许开发者更早地开始使用新的JavaScript特性。
- en: The most important TypeScript features aid large-scale application development.
    TypeScript has had classes and modules for some time, to help with structuring
    code. As the name suggests, TypeScript also adds type annotations and type inference.
    It also adds new ways of defining and specifying types, including enums, generic
    types, and interfaces. This makes for a safer language as the compiler can catch
    more errors. It also lets IDEs offer features like code completion (namely, Intellisense)
    and better source code navigation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript最重要的特性有助于大规模应用程序的开发。TypeScript已经有一段时间支持类和模块，以帮助结构化代码。正如其名所示，TypeScript还增加了类型注解和类型推断。它还增加了定义和指定类型的新方法，包括枚举、泛型类型和接口。这使得语言更安全，因为编译器可以捕获更多的错误。它还允许IDE提供诸如代码补全（即Intellisense）和更好的源代码导航等特性。
- en: Finally, TypeScript makes it possible to specify type definitions for libraries
    written in plain JavaScript. Type definitions for many third-party libraries can
    be found at [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
    These provide type checking and code completion when working with library code
    too.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，TypeScript使得为用纯JavaScript编写的库指定类型定义成为可能。许多第三方库的类型定义可以在[https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)找到。这些提供了在处理库代码时的类型检查和代码补全。
- en: 'Here''s an example of our `flatMap` function from the previous chapter written
    with type annotations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自上一章的`flatMap`函数示例，使用了类型注解：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The syntax for generics may be familiar from C#. Type annotations follow the
    expression or parameter, separated by a colon. We could specify the generic type
    when we call the function too, but in this case it can be inferred. Note that
    our method has two generic types, as our callback could map to an array of a different
    element type. The TypeScript compiler will infer the type of `result` as `number[]`.
    Note that this inference actually takes a few steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的语法可能来自C#。类型注解跟随表达式或参数，由冒号分隔。我们也可以在调用函数时指定泛型类型，但在这个例子中它可以被推断。请注意，我们的方法有两个泛型类型，因为我们的回调可以映射到不同元素类型的数组。TypeScript编译器将推断`result`的类型为`number[]`。请注意，这种推断实际上需要几个步骤：
- en: We specify that the `callback` parameter `i` has a type `number`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定`callback`参数`i`的类型为`number`
- en: Therefore, the expressions `i` and `i + 0.5` also both have a type `number`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，表达式 `i` 和 `i + 0.5` 也都具有 `number` 类型
- en: Therefore, the result type of our `callback` is `number[]`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们的 `callback` 的结果类型是 `number[]`
- en: Therefore, the argument for the type parameter `R` must be `number`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，类型参数 `R` 的参数必须是 `number`
- en: If we did not specify the type of `i`, then the compiler would only infer the
    type of `result` as `any[]`, that is an array, but of an unspecified element type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定 `i` 的类型，那么编译器只会推断 `result` 的类型为 `any[]`，即一个数组，但元素类型未指定。
- en: You can learn more about TypeScript at [http://www.typescriptlang.org/](http://www.typescriptlang.org/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://www.typescriptlang.org/](http://www.typescriptlang.org/) 上了解更多关于
    TypeScript 的信息。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're more familiar with Java than .NET, and especially if you're familiar
    with the Eclipse IDE in particular, you may also be interested in N4JS ([http://numberfour.github.io/n4js/](http://numberfour.github.io/n4js/)).
    This language has similar goals to TypeScript, but is inspired by Java and has
    an IDE based on Eclipse.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比 .NET 更熟悉 Java，尤其是如果你特别熟悉 Eclipse IDE，那么你也可能对 N4JS ([http://numberfour.github.io/n4js/](http://numberfour.github.io/n4js/))
    感兴趣。这种语言的目标与 TypeScript 类似，但受到 Java 的启发，并且有一个基于 Eclipse 的 IDE。
- en: CoffeeScript
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CoffeeScript
- en: CoffeeScript was one of the earliest successful compile-to-JavaScript languages.
    CoffeeScript streamlines the syntax of JavaScript and adds features for writing
    more terse and expressive code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 是最早成功的编译到 JavaScript 的语言之一。CoffeeScript 简化了 JavaScript 的语法，并添加了编写更简洁和更具表现力的代码的功能。
- en: CoffeeScript is a good example of when taste might influence language choice.
    Developers may find CoffeeScript more readable and/or easier to write. Ruby or
    Python programmers may be particularly comfortable with CoffeeScript. They'll
    find its syntax and many of its language features familiar.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 是一个很好的例子，说明了品味可能会影响语言选择。开发者可能会发现 CoffeeScript 更易读和/或更容易编写。Ruby
    或 Python 程序员可能会特别适应 CoffeeScript。他们会发现其语法和许多语言特性都很熟悉。
- en: Many features from CoffeeScript have subsequently appeared in ES2015, for example
    arrow functions, destructuring, and the splat/spread operator. Unlike TypeScript,
    CoffeeScript does not attempt to match the syntax of JavaScript, neither for current
    nor upcoming features. It does however offer seamless interoperability with JavaScript
    code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 许多来自 CoffeeScript 的特性后来出现在了 ES2015 中，例如箭头函数、解构和展开操作符。与 TypeScript 不同，CoffeeScript
    并不试图匹配 JavaScript 的语法，无论是当前还是即将推出的特性。然而，它确实提供了与 JavaScript 代码的无缝互操作性。
- en: 'Comprehensions are one of CoffeeScript''s most expressive features and do not
    appear in ES2015\. You may be familiar with comprehensions from Python. They are
    also a little like LINQ in C#, in that they allow you to express operations on
    lists without using loops. The following example prints the squares of even numbers,
    first in JavaScript and then as a one-liner in CoffeeScript. As `squares.js`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 理解是 CoffeeScript 最具表现力的特性之一，并且没有出现在 ES2015 中。你可能对 Python 中的理解很熟悉。它们也与 C# 中的
    LINQ 有点相似，因为它们允许你在不使用循环的情况下对列表进行操作。以下示例首先以 JavaScript 打印偶数的平方，然后以 CoffeeScript
    的一行代码打印。作为 `squares.js`：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As `squares.coffee`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `squares.coffee`：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And beyond...
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以及更多...
- en: TypeScript and CoffeeScript are specifically designed to target JavaScript.
    There are many other projects in existence that allow more general languages to
    compile JavaScript. Note that not all such projects are mature or well-maintained.
    Languages whose own project team supports and maintains compilation to JavaScript
    tend to be a safer choice. Both Dart ([https://www.dartlang.org/](https://www.dartlang.org/))
    and Clojure ([http://clojure.org/](http://clojure.org/)) provide first-class support
    for compiling to JavaScript.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 和 CoffeeScript 是专门设计用来针对 JavaScript 的。存在许多其他项目允许更通用的语言编译成 JavaScript。请注意，并非所有这样的项目都成熟或维护良好。那些自己的项目团队支持并维护编译到
    JavaScript 的语言往往是一个更安全的选择。Dart ([https://www.dartlang.org/](https://www.dartlang.org/))
    和 Clojure ([http://clojure.org/](http://clojure.org/)) 都提供了对编译到 JavaScript 的第一级支持。
- en: Introducing a true assembly language for the web
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍真正的网络汇编语言
- en: As discussed above, while JavaScript can be a common compile target for the
    web and Node.js, it is not a true assembly language. It is a high-level human-readable
    language, rather than an optimized machine language. There are projects to introduce
    just such a language into the web environment though. This means defining an assembly
    language implemented by all browsers, including Chrome's V8 engine and therefore
    Node.js.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，虽然 JavaScript 可以成为网络和 Node.js 的通用编译目标，但它并不是一种真正的汇编语言。它是一种高级的可读语言，而不是优化的机器语言。尽管如此，有一些项目旨在将这种语言引入网络环境。这意味着定义一种由所有浏览器实现的汇编语言，包括
    Chrome 的 V8 引擎和 Node.js。
- en: Understanding asm.js
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 asm.js
- en: The first attempt at such a language is asm.js ([http://asmjs.org/](http://asmjs.org/)),
    developed by Mozilla. This is a strict subset of JavaScript, which means it can
    run on any browser. But browsers that support asm.js can precompile it and heavily
    optimize its execution. Demanding applications such as 3D games can be recompiled
    to target asm.js and run seamlessly in-browser. The first environment with full
    support for asm.js is Mozilla's own Firefox browser. It will also be supported
    in Microsoft's new Edge browser. The V8 engine used by Chrome (and Node.js) does
    not yet pre-compile asm.js, but V8 does make some optimizations to allow asm.js
    to run much faster than if interpreted as plain JavaScript.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对这种语言的第一次尝试是 asm.js ([http://asmjs.org/](http://asmjs.org/))，由 Mozilla 开发。这是一个严格的
    JavaScript 子集，这意味着它可以在任何浏览器上运行。但支持 asm.js 的浏览器可以预先编译它，并对其执行进行大量优化。要求较高的应用程序，如
    3D 游戏，可以重新编译为针对 asm.js，并在浏览器中无缝运行。完全支持 asm.js 的第一个环境是 Mozilla 自己的 Firefox 浏览器。它也将被
    Microsoft 的新 Edge 浏览器支持。Chrome（和 Node.js）使用的 V8 引擎目前还没有预先编译 asm.js，但 V8 确实进行了一些优化，使得
    asm.js 的运行速度比作为纯 JavaScript 解释要快得多。
- en: Understanding WebAssembly
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 WebAssembly
- en: WebAssembly ([https://webassembly.github.io/](https://webassembly.github.io/))
    is a new standard for a true assembly language for the web. Unlike asm.js it is
    not a subset of JavaScript and won't run in today's browsers. It defines a new
    assembly language more like CIL or Java bytecode. It is developed by the W3C standards
    body, with input from the major browser vendors. There are early implementations
    of WebAssembly in preview releases of Mozilla Firefox, Google Chrome, and Microsoft
    Edge.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly ([https://webassembly.github.io/](https://webassembly.github.io/))
    是一种针对网络的真实汇编语言的新标准。与 asm.js 不同，它不是 JavaScript 的子集，并且不会在今天的浏览器上运行。它定义了一种新的汇编语言，更类似于
    CIL 或 Java 字节码。它由 W3C 标准机构开发，并得到了主要浏览器供应商的反馈。Mozilla Firefox、Google Chrome 和 Microsoft
    Edge 的预览版本中都有 WebAssembly 的早期实现。
- en: As an application developer, you do not need to be able to write WebAssembly
    any more than you need to write CIL or Java bytecode. These are all low-level
    languages to act as compilation targets. In future, WebAssembly may replace JavaScript
    as the common compile target for the web (and Node.js). Other languages, including
    JavaScript itself, may all compile to WebAssembly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序开发者，你不需要能够编写 WebAssembly，就像你不需要能够编写 CIL 或 Java 字节码一样。这些都是作为编译目标的低级语言。在未来，WebAssembly
    可能会取代 JavaScript 成为网络（和 Node.js）的通用编译目标。包括 JavaScript 本身在内的其他语言都可能编译到 WebAssembly。
- en: This would mean that JavaScript would no longer be the only native language
    for the web and Node.js. But JavaScript will almost certainly remain the default
    development language for these environments, just as C# and Java are for their
    respective environments. Knowledge of the execution model of Node.js will still
    be relevant in any language and JavaScript will still be the most natural fit
    for this execution model. Knowledge of JavaScript will also be important for working
    with the many well-established libraries based on it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 JavaScript 将不再是网络和 Node.js 的唯一原生语言。但 JavaScript 几乎肯定将继续成为这些环境的默认开发语言，就像
    C# 和 Java 分别是其各自环境的默认语言一样。了解 Node.js 的执行模型在任何语言中都将仍然相关，JavaScript 也将是这个执行模型最自然的选择。了解
    JavaScript 对于使用基于它的许多成熟库也将非常重要。
- en: There would be other benefits to JavaScript from WebAssembly. Interoperation
    between JavaScript and other languages will become easier. There will be more
    options for implementing performance-critical code. New versions of JavaScript
    will be able to roll out more quickly (as a single JavaScript to WebAssembly compiler
    can target all browser engines).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 将为 JavaScript 带来其他好处。JavaScript 与其他语言的互操作性将变得更加容易。将会有更多选项用于实现性能关键代码。新的
    JavaScript 版本将能够更快地推出（因为单个 JavaScript 到 WebAssembly 编译器可以针对所有浏览器引擎）。
- en: JavaScript and ASP.NET
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 和 ASP.NET
- en: On the server side, we don't need to wait for WebAssembly to mature in order
    to work with Node.js and .NET together. There is already some convergence between
    programming on these two platforms and support for interoperability between them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们不需要等待WebAssembly成熟就可以与Node.js和.NET一起工作。这两个平台上的编程已经有一些趋同，并且它们之间也支持互操作性。
- en: Exploring .NET Core
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索.NET Core
- en: The next version of NET, called .NET Core, makes some major changes to the platform.
    Some of these changes might seem familiar if you've spent some time working with
    Node.js. This is not just a coincidence. Microsoft are incorporating good ideas
    that have worked in Node.js and elsewhere into their ecosystem.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: .NET的下一个版本，称为.NET Core，对该平台进行了重大更改。如果你花了一些时间与Node.js一起工作，其中一些更改可能看起来很熟悉。这并非巧合。微软正在将Node.js和其他地方行之有效的好想法整合到他们的生态系统中。
- en: Defining project structure in .NET Core
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义.NET Core中的项目结构
- en: .NET Core separates the programming platform from the IDE. Microsoft still recommends
    using Visual Studio, but have made it much easier to use other editors. For example,
    the OmniSharp project ([http://www.omnisharp.net/](http://www.omnisharp.net/))
    supports development in other editors, providing features such as Intellisense
    outside of Visual Studio.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core将编程平台与IDE分离。微软仍然推荐使用Visual Studio，但已经使使用其他编辑器变得更加容易。例如，OmniSharp项目([http://www.omnisharp.net/](http://www.omnisharp.net/))支持在其他编辑器中进行开发，并提供诸如Visual
    Studio之外的Intellisense等特性。
- en: One aspect of this change is simplifying the use of `.csproj` files. In previous
    versions of .NET, these large XML files were the canonical description of each
    C# project. They included important things like compilation options, target platforms,
    build steps, and dependencies. They were mainly generated by Visual Studio, difficult
    to edit by hand, and often particularly awkward to merge in source control. To
    satisfy Visual Studio, they also needed to list every single source file in the
    project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化的一个方面是简化了`.csproj`文件的使用。在.NET的早期版本中，这些大型XML文件是每个C#项目的规范描述。它们包括编译选项、目标平台、构建步骤和依赖等重要内容。它们主要是由Visual
    Studio生成的，手动编辑困难，并且在源控制中合并时往往特别棘手。为了满足Visual Studio，它们还需要列出项目中的每个单个源文件。
- en: Many of these drawbacks are addressed in .NET Core. New tools make it much easier
    to edit `.csproj` files from the command line. A project's sources are just the
    files under its parent folder (not listed in `.csproj` or any other metadata file).
    Dependencies are declared separately in a more lightweight JSON-based file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core解决了许多这些缺点。新的工具使得从命令行编辑`.csproj`文件变得更加容易。项目源代码只是其父文件夹下的文件（不在`.csproj`或其他元数据文件中列出）。依赖项在更轻量级的基于JSON的文件中单独声明。
- en: Many of these improvements are inspired by programming platforms like Node.js.
    In fact, early release candidates for .NET Core removed the need for `.csproj`
    files entirely and introduced `project.json` files (just like in Node.js) for
    defining projects. Although .NET Core ultimately uses `.csproj` files (for continued
    compatibility with MSBuild), it aims to keep those aspects of more lightweight
    approaches that are most important to developers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些改进都受到了像Node.js这样的编程平台的影响。事实上，.NET Core的早期候选版本完全去除了`.csproj`文件的需求，并引入了`project.json`文件（就像在Node.js中一样）来定义项目。尽管.NET
    Core最终仍然使用`.csproj`文件（以保持与MSBuild的兼容性），但它旨在保留对开发者来说最重要的更轻量级方法的一些方面。
- en: Managing dependencies in .NET Core
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理.NET Core中的依赖项
- en: The NuGet package manager has been part of the .NET ecosystem for several years.
    NuGet becomes even more important in .NET Core. The framework and runtime themselves
    are distributed as NuGet packages. Dependencies are specified as NuGet package
    names (and versions) rather than DLL paths. NuGet packages can also be a useful
    unit of deployment for your own projects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet包管理器已经作为.NET生态系统的一部分存在了几年。在.NET Core中，NuGet变得更加重要。框架和运行时本身都是以NuGet包的形式分发的。依赖项指定为NuGet包名称（和版本）而不是DLL路径。NuGet包也可以成为你自己的项目的有用部署单元。
- en: Just like with Node.js, you can checkout the source code of one of your dependencies
    to a local folder and reference it there. This allows you to tinker with open
    source libraries and debug them as part of your program.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Node.js一样，你可以将你依赖项之一的源代码检出到一个本地文件夹中，并在那里引用它。这允许你修改开源库，并将它们作为你程序的一部分进行调试。
- en: Building web applications in ASP.NET Core
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中构建Web应用程序
- en: ASP.NET Core consolidates ASP.NET MVC and WebAPI into a single framework. It
    also brings OWIN to the fore as the standard abstraction for implementing web
    applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 将 ASP.NET MVC 和 WebAPI 合并成一个单一框架。它还将 OWIN 提升为实施 Web 应用程序的标准抽象。
- en: OWIN simply defines a standard for passing request and response objects between
    a host and an application. Although OWIN has been around for a while and has its
    own history, this is a similar abstraction to the `http.createServer` method in
    Node.js. You can read more about OWIN at [https://docs.asp.net/en/latest/fundamentals/owin.html](https://docs.asp.net/en/latest/fundamentals/owin.html).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: OWIN 简单地定义了在主机和应用程序之间传递请求和响应对象的标准。尽管 OWIN 已经存在一段时间并且有自己的历史，但这与 Node.js 中的 `http.createServer`
    方法类似。您可以在 [https://docs.asp.net/en/latest/fundamentals/owin.html](https://docs.asp.net/en/latest/fundamentals/owin.html)
    上了解更多关于 OWIN 的信息。
- en: Related to this, ASP.NET also uses middleware as the standard building block
    for web applications. Again, although middleware in .NET has its own history,
    the abstraction is very similar to middleware in Express. Applications set up
    a pipeline of middleware, with each having access to the request, response, and
    the next handler in the chain. Built-in middleware is available for cross-cutting
    concerns such as authentication, sessions, and routing. You can read more about
    middleware at [https://docs.asp.net/en/latest/fundamentals/middleware.html](https://docs.asp.net/en/latest/fundamentals/middleware.html)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关，ASP.NET 还使用中间件作为 Web 应用程序的标准构建块。尽管 .NET 中的中间件有自己的历史，但抽象与 Express 中的中间件非常相似。应用程序设置一个中间件管道，每个中间件都可以访问请求、响应和链中的下一个处理器。内置中间件可用于诸如身份验证、会话和路由等跨切面关注点。您可以在
    [https://docs.asp.net/en/latest/fundamentals/middleware.html](https://docs.asp.net/en/latest/fundamentals/middleware.html)
    上了解更多关于中间件的信息。
- en: Integration with JavaScript
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 JavaScript 的集成
- en: 'Visual Studio has provided good support for client-side JavaScript development
    for several years. Microsoft have improved and updated this in the latest versions
    of ASP.NET and Visual Studio: for example, by including better integration with
    task runners such as Gulp and Grunt. You can read more about client-side JavaScript
    support at [https://docs.asp.net/en/latest/client-side/index.html](https://docs.asp.net/en/latest/client-side/index.html).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 已经为客户端 JavaScript 开发提供了多年的良好支持。在最新的 ASP.NET 和 Visual Studio 版本中，微软对其进行了改进和更新：例如，通过包括与任务运行器（如
    Gulp 和 Grunt）的更好集成。您可以在 [https://docs.asp.net/en/latest/client-side/index.html](https://docs.asp.net/en/latest/client-side/index.html)
    上了解更多关于客户端 JavaScript 的信息。
- en: Server-side JavaScript integration with .NET
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 与服务器端 JavaScript 的集成
- en: The Edge.js project ([https://github.com/tjanczuk/edge](https://github.com/tjanczuk/edge))
    allows Node.js and .NET to run within the same process. It also defines a very
    simple way for marshalling method calls between the two. This is much faster than
    marshalling calls out-of-process (for example, via an HTTP call to a process on
    the local machine).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Edge.js 项目 ([https://github.com/tjanczuk/edge](https://github.com/tjanczuk/edge))
    允许 Node.js 和 .NET 在同一进程中运行。它还定义了在两者之间进行方法调用的非常简单的方式。这比在进程外调用（例如，通过本地机器上的进程的 HTTP
    调用）进行调用要快得多。
- en: Edge.js allows you to take the best of .NET and Node.js. Perhaps you want to
    use Node.js to put a web interface on top of your existing .NET business logic.
    Or perhaps you're using Node.js for rapid development of most of your application,
    but have a particularly CPU-intensive operation that would be easier to optimize
    in .NET.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Edge.js 允许您取 .NET 和 Node.js 的最佳之处。也许您想使用 Node.js 在现有的 .NET 业务逻辑之上放置一个 Web 界面。或者也许您正在使用
    Node.js 快速开发应用程序的大部分，但有一个特别占用 CPU 的操作，在 .NET 中优化会更简单。
- en: 'Making calls from Node.js to .NET (or vice versa) is very simple. For example,
    if we have the following .NET class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node.js 调用 .NET（或反之亦然）非常简单。例如，如果我们有以下 .NET 类：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use it from JavaScript as follows (after running `npm install edge`):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 JavaScript 中如下使用它（在运行 `npm install edge` 之后）：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compiling our C# code and running our JavaScript file results in the following
    output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 编译我们的 C# 代码并运行我们的 JavaScript 文件会产生以下输出：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can find a good introduction to Edge.js at [http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx](http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx](http://www.hanselman.com/blog/ItsJustASoftwareIssueEdgejsBringsNodeAndNETTogetherOnThreePlatforms.aspx)
    上找到关于 Edge.js 的良好介绍。
- en: Finally, recall that the OWIN standard and ASP.NET middleware are quite similar
    to the corresponding concepts in JavaScript. Edge.js makes it easy to include
    a .NET OWIN application as middleware in a Node.js Express application. See the
    `connect-owin` project at [https://github.com/bbaia/connect-owin](https://github.com/bbaia/connect-owin)
    for details.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回顾一下，OWIN 标准和 ASP.NET 中间件与 JavaScript 中的相应概念相当相似。Edge.js 使得将 .NET OWIN 应用程序作为中间件包含在
    Node.js Express 应用程序中变得容易。有关详细信息，请参阅 `connect-owin` 项目，网址为 [https://github.com/bbaia/connect-owin](https://github.com/bbaia/connect-owin)。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how Node.js and JavaScript's new release cycles
    bring stability to the platform. We have introduced some of the new and upcoming
    features of JavaScript. We have explored current and future alternative languages
    for the JavaScript environment. We have seen some of the commonalities between
    .NET and Node.js and how to use these technologies together.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了 Node.js 和 JavaScript 的新发布周期如何为平台带来稳定性。我们介绍了一些 JavaScript 的新功能和即将推出的功能。我们探讨了
    JavaScript 环境中的当前和未来替代语言。我们还看到了 .NET 和 Node.js 之间的共同点以及如何使用这些技术一起工作。
- en: I hope this book has allowed you to get up-and-running with Node.js and given
    you an appetite to learn more. The resources in this chapter will help you take
    the next step on your journey with JavaScript and Node.js.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能帮助你开始使用 Node.js，并激发你进一步学习的兴趣。本章中的资源将帮助你继续你的 JavaScript 和 Node.js 之旅。
