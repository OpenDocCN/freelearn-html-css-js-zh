- en: Chapter 2. Adding Interactivity – The Making of a Concentration Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By definition, a game is interactive in some way. Players have to be *part*
    of it by doing things. The simplest form of interactivity is clicking or touching
    tiles in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Concentration game is simple to explain, but it will cover some new and important
    concepts, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple instances of game assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending classes to improve its capabilities. Actually, there are no classes
    in JavaScript, but they are emulated using variables and prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding gradients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making assets react to clicks and touches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing sprite images on the fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding text labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing sprites from the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to create a full Concentration game
    using space for customization.
  prefs: []
  type: TYPE_NORMAL
- en: As the project created in the previous chapter is more than just a Hello World
    game and rather acts as a blueprint for all your future projects, you'll start
    building our Concentration game out of the previously finished project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple instances of game assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you have to do in the making of a Concentration game is draw
    the tiles that you will use in the game. Here are the pictures used for the covered
    tiles and the eight different tiles that could be potentially matched, all saved
    in the `assets` folder, as explained in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating multiple instances of game assets](img/0072OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each tile is a 64 x 64 `PNG` file, where the covered tile is called `cover.png`,
    while the tile to be matched is named with a progressive number from 0 to 7: **tile_0**,
    **tile_1**, until **tile_7**. This is because the actual board tile values will
    be stored in an array whose values will range from 0 to 7, and it will be easy
    to assign value 0 to **tile_0**, value 1 to **tile_1**, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these nine files in the assets folder, you are ready to load them, thanks
    to the `loadassets.js` file located in the `src` folder of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The images are loaded in the same way as in the previous chapter; you then place
    all the 16 covered tiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of `gamescript.js`, which is basically the same you used
    in the previous chapter, except sprite creation is inside a `for` loop that will
    be executed 16 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The strange numbers in the `setPosition` method places the group of 64 x 64
    tiles in a 4 x 4 grid on the stage. You can use some math to change the tiles'
    position the way you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the game and this is what you will see on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating multiple instances of game assets](img/0072OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a nice grid of covered tiles, but the background is poor. It's time
    to work on it a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a gradient background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick and easy way to improve the background is to add a gradient. Most of
    the skies and sceneries you see in the background of your favorite games are just
    gradients.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to add a gradient layer conveniently called `gradient` to the
    game simply by adding these two lines to `gamescript.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Gradient layer creation is made by the `cc.LayerGradient.create` method, which
    requires both the start and end gradient color in an **RGBA** (**Red, Green, Blue,
    Alpha**) format.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things you need to notice about the lines that were added:'
  prefs: []
  type: TYPE_NORMAL
- en: The gradient layer should be added before tiles, so tiles will be placed in
    front of the background because you can play with the depth of the layers to dynamically
    adjust layers in Z-order, but that's not the case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gradient colors can be specified both in decimal (from 0 to 255) and hexadecimal
    (from 0 x 00 to 0 x FF) values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, test the game again and you should see a nice black to blue background.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a gradient background](img/0072OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this time, you have 16 tiles placed on a beautiful gradient background. Now,
    it's time to let the player have the ability to pick some of them up.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, sprites are just images and can't be picked.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Sprite class beyond its capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I say *sometimes*, I mean *most of the time* the default Cocos2d-JS classes
    do not let you do everything you need to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Although this might seem like a limit of Cocos2d-JS, it's one of its best features.
    You are provided with a basic set of classes you can extend the way you need to,
    meaning you can add new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does it really mean to extend a class? Imagine a real-world example:
    you''re entering a bike shop and buying a mountain bike. Your mountain bike is
    a class; with this class, you can do everything you can actually do with a mountain
    bike, namely pedal and steer.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you are a bit lazy and don't want to pedal all the time, so you
    buy a little motor and add it to your mountain bike. Now, you can still do everything
    you usually did with your bike, but you can also rest your legs, turn on the motor,
    and let it pedal on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: You just extended the mountain bike, created a motorized mountain bike, which
    is basically still a bike and inherits all its features with some new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extend the `Sprite` class and make it capable of doing all the stuff you
    need in order to make your Concentration game, you have to add some lines to `gamescript.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you test the game at this time, you will see the same background gradient
    with the 4 x 4 grid of covered tiles. Let's see what has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, the tile creation is not made anymore with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, it''s been replaced with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you aren't creating the Sprite itself, but a new type called `MemoryTile`,
    which will extend the `Sprite` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you declare that you are extending a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `MemoryTile` variable is declared as an extension of the `Sprite`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `ctor` method is the constructor, basically the stuff being executed as
    soon as the variable is created. In this case, `initWithFile` assigns the same
    cover image you assigned before with the old way of placing tiles.
  prefs: []
  type: TYPE_NORMAL
- en: You might argue that four lines of code are being used to do what could be done
    with just a single line of code, and that's true, but this is the little price
    you pay to add new functionalities to Cocos2d-JS built-in classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have a new class that extends Sprite. Let's add interactivity to it.
  prefs: []
  type: TYPE_NORMAL
- en: Making assets react to clicks and touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to pick a tile, irrespective of whether you are playing with
    a touch or mouse-driven device. You can tap on a tile or you can click on it.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a tile as an initial attempt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No matter the way you use Cocos2d-JS, all in all you are creating cross-platform
    games. You have to tell Cocos2d-JS you are going to let the user touch or click
    on some tiles, so the `MemoryTile` class will change this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What just happened? You just added an event listener to the event manager.
    The event manager is the entity that triggers events fired by the game or by the
    player. The `addListener` method adds a listener to the event manager, but you
    don''t have a listener at the moment. Let''s create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic listener. You will find yourself using it in most of your
    projects, so let''s take a closer look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you create a listener with a `cc.EventListener.create` method.
    You named it `listener` to match the previous call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you modified the `MemoryTile` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you specify the type of event: `cc.EventListener.TOUCH_ONE_BY_ONE` tells
    the game that you are waiting for touches, but only one at a time. Note that the
    game talks about touches, but the game will also work with a mouse. This is the
    true power Cocos2d-JS brings when dealing with cross-platform development.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will basically ignore all touches when there''s one active touch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, things start to get serious as you are ready to trigger when the touch
    or mouse click begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getCurrentTarget` method returns the current click target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling the `touch.getLocation` method, you will have the coordinates of
    the touch or click inside the game, while the `convertToNodeSpace` method will
    convert such coordinates into the coordinates relative to the tile itself. This
    way, the `location` variable will contain the coordinates of the touch or click
    that is relative to the tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getContentSize` function only returns the width and height of the target,
    in this case the tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you define a rectangle with the same size of the tile with the `cc.rect`
    method. This will allow us to know whether the click or touch action was inside
    this rectangle. A certain tile has been clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also, this is how you determine whether a point is inside a rectangle, so you
    can say that the tile has been clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, basically:'
  prefs: []
  type: TYPE_NORMAL
- en: Each tile detects a `touch` or `click` action, which can be inside or outside
    the tile itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You get touch/click coordinates relative to the tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You see whether these coordinates are inside the tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can say which tile has been clicked, if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are you ready to click tiles? Run the game and click on a tile, and you will
    see.
  prefs: []
  type: TYPE_NORMAL
- en: '**I picked a tile!!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, it works! Let me just show you this line again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the `clone()` method when you first wrote it? You used the `clone`
    method because an event listener can be added only once. The `addListener` method
    sets a registration flag on the event listener, and it won't add the event listener
    again if the flag is already set. In other words, you will be able to check for
    clicks or touches only on the first tile you assigned the listener to.
  prefs: []
  type: TYPE_NORMAL
- en: Using `clone`, you basically duplicate the listener, so each tile will have
    its own listener up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Changing sprite images on the fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now find out how to change sprite images.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the tile picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a tile is picked, it has to show its picture. Pictures are just a graphical
    representation of a tile value, which you initially store in an array called `gameArray`
    declared at the very beginning of a `gamescript.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, once you create a new tile, you can assign it a custom attribute called
    `pictureValue` with the value of the *i-th* element of `gameArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, once the tile is picked, you can again use the `initWithFile()` method
    to assign it another image according to its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, it should be clear why the tile images files were numbered from 0 to 7\.
    This is because they will match the tile values assigned by the `gameArray` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game and start picking tiles; see how they uncover showing their actual
    picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the tile picture](img/0072OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, add some game logic that will allow you to pick only two tiles, then remove
    them from the game if they match, or cover them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need another array called `pickedTiles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to add a couple of lines to our `listener` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once the `pickedTiles` array contains two tiles, which prevents the player from
    picking the same tile twice, then the `checkTiles` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am not explaining much of the code at this step because there's nothing related
    to Cocos2d-JS; it's just good old JavaScript logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Basically, `checkTiles` waits two seconds, giving some time to the player to
    memorize the picked tiles, and then again covers tiles if they do not match by
    simply changing their image to a covered tile again, or removes them from the
    game with the `removeChild` method.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the player will be allowed to pick new tiles by emptying a `pickedTiles`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Test the game and make some matches to see the tiles being removed from the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the tile picture](img/0072OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You created your first Cocos2d-JS working game. Now, let's
    add some finishing touches.
  prefs: []
  type: TYPE_NORMAL
- en: Shuffling the tiles and adding the score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have noticed the game isn't that hard, since you are just matching
    tiles that are one next to each other. The first tile matches the second tile,
    the third tile matches the fourth, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to shuffle the tiles, then you will add the score to the game.
    Players love to compete for high scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'You start by adding two new variables `scoreText` and `moves`, which will handle
    the text showing the score and count the number of moves (picks) the player did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to shuffle `gameArray`. Shuffling arrays with a true randomization
    is beyond the scope of this book, so for this game, you are going to use a basic
    shuffle function you can find at [http://jsfromhell.com/array/shuffle](http://jsfromhell.com/array/shuffle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `gameArray` is shuffled at the beginning of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the score text to the game, you need a label. Here is how you can create
    a text label called `scoreText`, which contains the text `Moves: 0` with a 32
    pixel Arial font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, once you check for tile matches, it''s easy to increase the number
    of moves and update the `scoreText` text label with a `setString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Test the script and you will be able to play a full game with a randomly generated
    board and the score text.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shuffling the tiles and adding the score](img/0072OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, you really do have a complete and polished game!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By extending the Sprite class and adding a bit of interactivity, you created
    your own Concentration game. Now, you also know how to change Sprite images on
    the fly and deal with text labels.
  prefs: []
  type: TYPE_NORMAL
- en: Concentration is a great brain game. However, sometimes you want more action.
    To make it harder, you can try making your own 6 x 6 game rather than this easy
    4 x 4 game. Head on to the next chapter and let's make things move!
  prefs: []
  type: TYPE_NORMAL
