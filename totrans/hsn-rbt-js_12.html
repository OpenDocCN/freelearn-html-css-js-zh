<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1</h1>
                </header>
            
            <article>
                
<ol>
<li>We'll use the Linux operating system, via the Raspbian distribution, and leverage it to run our projects in Node.js.</li>
<li><span><strong>GPIO</strong> stands for </span>General-Purpose Input/Output.</li>
<li>Rick Waldron started the Johnny-Five project back in 2012 and wrote a program that used node-serialport to operate an Arduino Uno with Node.js.</li>
<li>We run <kbd>uname -m</kbd> command on the command line of our Pi ssh session to <span>find out what </span><span>ARM </span><span>architecture the Raspberry Pi uses.</span></li>
<li><span>Changing the default Raspberry Pi password is important because </span>default username and password isn't very secure, especially when your Pi is connected to the internet.</li>
<li>Node.js allows you to create even advanced robotics projects without having to deal with any low-level languages, also it has <strong>Event-based systems</strong> and <strong>Garbage collection/automatic memory management</strong>.</li>
<li>Node.js prides itself on creating small, bordering on tiny, packages, and has the excellent npm package manager (and others) to help manage those packages.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2</h1>
                </header>
            
            <article>
                
<ol>
<li>The first <kbd>LED.strobe()</kbd> parameter defines the blinking speed of LED, which is 100 ms by default. If the argument is defined as 500 then the blink will go in 500 ms intervals.</li>
<li>The second line of argument use <kbd>require</kbd> function to pull in the <kbd>johnny-five</kbd> modules.</li>
<li><span>Johnny-Five LED objects are output only and therefore do not emit any events.</span></li>
<li><span>Raspberry Pi pin P1-29 </span><span>translate to GPIO 5 in terms of GPIO#.</span></li>
<li><kbd>LED.blink()</kbd> function is an alias to <kbd>LED.strobe()</kbd> function.</li>
<li><span>We begin with constructing a board object, and we pass a new instance of the <kbd>raspi-io</kbd> module in as its I/O. This is how we tell the Johnny-Five library we're running this code on a Raspberry Pi.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 3</h1>
                </header>
            
            <article>
                
<ol>
<li><span>PWM stands for Pulse-width modulation, it sets the percentage of time that a pin is HIGH and LOW. For an LED, it sets the effective brightness.</span></li>
<li>The Raspberry Pi 3 B+ has 2 PWM pins, but they operate on the same channel, effectively creating 1 PWM pin.</li>
<li>We need the GPIO expander because the RGB LED needs 3 PWM pins to fully function, and the Pi only has 1 on board.</li>
<li>7 -- red, green, blue, white (red+green+blue), yellow (red+green), purple (red+blue), and cyan (green+blue).</li>
<li>The GPIO expander communicates with the Raspberry Pi using the I2C protocol.</li>
<li>The color module takes in strings representing color in various formats (#FFF, rgb(255,255,255), and translates them into a red, green, and blue channel that our Pi and LED understand.</li>
<li>The REPL helps with debugging by letting you see and manipulate the state the bot is in. It is powerful because most robotics platforms have a way of altering the state of the code while running.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 4</h1>
                </header>
            
            <article>
                
<ol>
<li>The events available to the Johnny-Five button object are <kbd>press</kbd>, <kbd>release</kbd>, and <kbd>hold</kbd>.</li>
<li>The Raspberry Pi cannot directly use analog input devices because all of its pins are digital.</li>
<li>We will use sensors with the Pi that add a digital interface to access the readings of the analog sensor itself.</li>
<li>There are no events for the Johnny-Five LED.RGB object because it strictly does output.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 5</h1>
                </header>
            
            <article>
                
<ol>
<li>An analog input sensor takes in data from its surroundings and converts it into a value that is represented by a voltage level sent either to an intermediate processor or the microcontroller directly.</li>
<li>Analog sensors cannot interface directly with the Pi because all of the Pi's GPIO pins are digital.</li>
<li>Two digital interfaces we can use to interface analog sensors with the Pi are I2C and SPI.</li>
<li>The two pins (besides ground and power) that an I2C device needs to operate are an SDA (data) pin and an SCL (clock) pin.</li>
<li>The sensor object can fire the <kbd>data</kbd> event, which means data has been collected, and the <kbd>change</kbd> event, which indicates that the data from the sensor has changed.</li>
<li>barcli is helpful in processing sensor data because instead of reading hundreds of lines of numbers, you can look at a bar graph and how it changes when you manipulate the sensor.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 6</h1>
                </header>
            
            <article>
                
<ol>
<li>A motor is an electrical device that converts electricity into rotational movement</li>
<li>The difference between a motor and a stepper motor is that motor can only be told what direction and speed to go, while a stepper motor can be told how many pre-defined increments to move, making it better for precision movements.</li>
<li>You should use external power for motors because otherwise, it will draw too much power from the Raspberry Pi, causing strange errors or even reboots while your project is running. Your motors may also run slowly or not respond to commands when powered directly from the Pi.</li>
<li>We need a Pi hat to control our motor because getting the motor to move backward requires extra components that the hat provides—it also makes it much easier to supply external power to the motors.</li>
<li>The benefits of the Motors object when controlling multiple motors is the ability to control all of your motors in the group with one command while retaining the ability to send commands to the individual motors.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 7</h1>
                </header>
            
            <article>
                
<ol>
<li>The difference between servos and motors is that you can tell a servo what angle to move to, while you can only tell a motor to go forwards or backward and at what speed.</li>
<li>The difference between regular and continuous servos is regular servos can go from 0-180 degrees and you can control what degree, while you can only tell a continuous servo which way to rotate and at what speed, but it has full 360-degree movement.</li>
<li>Servos require an external power source <span>because </span>otherwise<span>, it will draw too much power from the Raspberry Pi, causing strange errors or even reboots while your project is running. Your motors may also run slowly or not respond to commands when powered directly from the Pi.</span></li>
<li>You would use servos over motors when you want your movements to go to a specific angle every time.</li>
<li>The benefits of the Johnny-Five Servos object <span>is the ability to control all of your servos in the group with one </span>command<span> while retaining the ability to send </span>commands<span> to the individual servos.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 8</h1>
                </header>
            
            <article>
                
<ol>
<li>Animations are necessary for complex movements with multiple servos because timing is key for these movements, and moving all servos as fast as they can go with no easing makes complex movements nigh-impossible.</li>
<li>A keyframe is an array of information about the locations of the servos in an animation at an arbitrary point in time, defined by the animation segment. </li>
<li>A cue point is a point in the animation that lines up with a keyframe. When these are combined with duration in the animation segment, you will get a time for each keyframe.</li>
<li>The three pieces of an animation segment are the keyframes, the cue points, and the duration.</li>
<li>Easing manipulates our animation keyframes and segments by changing the acceleration rate of the servos as they travel from one keyframe to another.</li>
<li>The method of the animation object that stops the current segment and clears the animation queue is <kbd>Animation.stop()</kbd>.</li>
<li>Calling<span> </span><kbd>Animation.speed(.25)</kbd><span>  slows the currently running animation to 1/4 of its original speed.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 9</h1>
                </header>
            
            <article>
                
<ol>
<li>The Pi is well-suited for projects that require remote data because of its onboard ability to connect to the internet via either WiFi or Ethernet.</li>
<li>The considerations that need to be taken when making regular web requests from the Pi are:
<ul>
<li>The size of the payload</li>
<li>How much CPU parsing the payload will take</li>
<li>Whether the data being accessed was meant to be accessed</li>
<li>WiFi requests take a lot of power for the Pi and can cause problems if the Pi doesn't have a proper power supply</li>
</ul>
</li>
<li>We can chain the LCD object calls, such as <kbd>LCD.clear().home()</kbd> because the Johnny-Five Objects always return the instance of the Object the method was working on, so another method can be called on it.</li>
<li>We use an I2C backpack with our LCD to cut the number of needed wires and pins from 8 to 2, and eliminate the need to hook up our own potentiometer to adjust LCD contrast.</li>
<li><span>W</span>e would need more components to use the LCD without the backpack—we would need a potentiometer to control the contrast of the LCD.</li>
<li><span> </span><kbd>LCD.on()</kbd><span> does not </span>turn on the entire LCD, instead, it turns on the LCD backlight.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 10</h1>
                </header>
            
            <article>
                
<ol>
<li>Two ways IoT devices interface with the internet that aren't specific to IoT are HTTP/S and WebSockets.</li>
<li>MQTT stands for Message Queueing Telemetry Transport.</li>
<li>An MQTT client is capable of connecting to a broker, subscribing to topics, process incoming messages to topics they are subscribed to, and publishing to topics.</li>
<li>An MQTT broker is capable of letting MQTT clients connect, making sure published messages go to all clients that are subscribed to the message's topic, and publishing messages to any topic.</li>
<li>The Pi gets a copy of the messages we send to AdafruitIO because it is subscribed to the topic it is publishing to, and every device subscribed to the topic is sent the message by the broker.</li>
</ol>


            </article>

            
        </section>
    </body></html>