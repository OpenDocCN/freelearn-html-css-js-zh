<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;MVC and MVVM"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. MVC and MVVM</h1></div></div></div><p>The problem with software development is that we're always looking for the right way to do things. Each software shop will have their own set of guidelines that indicate how their developers should operate. This is the way that software works: we build a set of ideas that reflect our best thoughts on how things should be developed and the software community learns from these ideas and builds on them. They are formalized into patterns of working and these patterns are shared throughout the development community. In this chapter, we'll talk more about this concept, specifically:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The MVC pattern</li><li class="listitem" style="list-style-type: disc">The MVVM pattern</li><li class="listitem" style="list-style-type: disc">The way Ext JS uses both</li><li class="listitem" style="list-style-type: disc">The evolution of Ext JS from MVC to MVVM</li><li class="listitem" style="list-style-type: disc">The benefits of design patterns in the current version of Ext JS</li></ul></div><p>Discussions about design patterns are often very dry. In this chapter, we'll use some practical examples to illustrate why they're so important and how they can help you kick-start your architecture efforts.</p><div class="section" title="Diary of always"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Diary of always</h1></div></div></div><p>In the beginning, there was a giant mess. Well, maybe not quite, but in modern software development, we've got lots of design and architectural patterns that we can draw on to help us shape an application and ensure we're not reinventing the wheel. Each of these is the result of decades of their work, which is constantly reviewed and put into practice, and we all hope that the most elegant and useful work will bubble to the top. Along the way, we've seen clumsy patterns being overtaken by more elegant ones. Hopefully, our mess has become a little bit less tangled.</p><p>A key development in the way we build graphical interfaces was<a id="id42" class="indexterm"/> <span class="strong"><strong>model-view-controller</strong></span> (<span class="strong"><strong>MVC</strong></span>), which was invented at the near-legendary Xerox PARC in the 1970s by Norwegian computer scientist Trygve Reenskaug. It was first publicly incorporated in Smalltalk, a programming language developed by a cast of computer scientists including Alan Kay. It brought together a host of ideas, which influenced nearly all the object-oriented languages we use today. It was a pretty big deal and created by some pretty big guns.</p><p>Connelly Barnes, assistant professor of computer science at University of Virginia, gives us a great way of viewing MVC:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"The model is the data, the view is the window on the screen, and the controller is the glue between the two."</em></span></p></blockquote></div><p>It was first in<a id="id43" class="indexterm"/> describing software constructs in terms of their responsibilities, for example, the View is responsible for presentation. In <a class="link" href="ch01.html" title="Chapter 1. Introduction">Chapter 1</a>, <span class="emphasis"><em>Introduction</em></span>, we talked about its importance in creating strong application architecture.</p><p>It can be difficult for us to look back on innovations (such as Smalltalk and MVC) and understand why they were so important. We could spend many pages reviewing what went before and why the advent of MVC has been described as a seminal insight. What really matters though is that it was a new way of looking at organizing graphical user interface-based software, a new paradigm in computing science that would prove to stand the test of time for the next thirty years:</p><div class="mediaobject"><img src="graphics/5308OT_02_01.jpg" alt="Diary of always"/><div class="caption"><p>Martin Fowler's bare-bones MVC</p></div></div><p>There are several differences between the MVC implementation that Ext JS uses (the one that Ruby on<a id="id44" class="indexterm"/> Rails brought to prominence) and the original implementation in Smalltalk. It has constantly been honed and tweaked since its inception, tailored for the various environments in which it has been used.</p></div></div>
<div class="section" title="Bringing MVC to the Web"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Bringing MVC to the Web</h1></div></div></div><p>Smalltalk's MVC<a id="id45" class="indexterm"/> implementation was created with traditional desktop GUI systems in mind. The separation of responsibilities that it represents makes a lot of sense for web-based software; the model is the representation of the business and persistence layers, the controller is the server-side glue, and the view is the HTML rendered for the client browser.</p><p>However, in traditional MVC, the view observes changes in the model in order to reflect its current state by responding to events that the model issues. In a standard HTTP request/response situation, this isn't viable.</p><p>Model 2 is a derivative of MVC that was implemented in the Java Struts framework, which introduced <a id="id46" class="indexterm"/>a potential solution to this issue. Rather than the view and model directly communicating, the controller becomes a marshaling point for changes. It responds to changes in the view and passes them to the model and vice versa, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/5308OT_02_02.jpg" alt="Bringing MVC to the Web"/><div class="caption"><p>MVC/Model 2 on the Web</p></div></div><p>This is the way in which Ruby on Rails implements MVC and in turn inspired a multitude of similar MVC frameworks for the Web (such as ASP.NET MVC).</p><p>This is in contrast to web technologies (such as Classic ASP, PHP, and Cold Fusion), where it's standard practice to create a page that combines logic, rendering, and database access. This can be described (although rarely is) as Model 1 with the MVC implementation as its logical successor. A Model 1 approach leads to the problems, which we described at the beginning of <a class="link" href="ch01.html" title="Chapter 1. Introduction">Chapter 1</a>, <span class="emphasis"><em>Introduction</em></span>, and so the popularization of MVC, in particular the simplified approach that Ruby on Rails took, begins to provide a strong basis for a well-constructed application.</p><p>MVC on the Web might follow this request flow:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The browser makes a request that is passed on to a controller.</li><li class="listitem">The controller consumes the request parameters.</li><li class="listitem">It retrieves a model (typically from a database) based on these parameters.</li><li class="listitem">Finally, it renders a view based on the model and passes it back to the browser.</li></ol></div><p>Of course, with the advent of Ajax, WebSockets, and fully client-side MVC frameworks, this is a very<a id="id47" class="indexterm"/> simplified example. It does serve to show how MVC can easily be adapted for the Web and, in fact, suits the Web very well.</p></div>
<div class="section" title="Ext JS and MVC"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Ext JS and MVC</h1></div></div></div><p>We've looked at the origins of MVC and the way it was adapted for traditional server-side web applications. How does it work when we use it with the kind of JavaScript-heavy application <a id="id48" class="indexterm"/>we'd typically build using Ext JS?</p><p>The whole MVC concept moves entirely into the browser. As far as we're concerned, the server can use any technology<a id="id49" class="indexterm"/> it wants. It'll generally just provide and consume data to and from the browser. We move back to an MVC implementation that is a little more like the Smalltalk version (different UI elements you see on-screen are views) and each can have their own controller.</p><p>Again, this is about breaking down responsibility. Instead of having a single controller take care of an entire page, we can have a search controller, a list controller, and a detail controller (anything that represents the logical units that make up our application). This is a key detail in how the step from server-side MVC to client-side MVC can help our application architecture.</p><p>We already know that Ext JS Components are our views, and Ext JS models are well named to fit right in. We're left with one important question: what are controllers actually supposed to do? It's probably easier to remove the things we know they don't do and see what's left. We know that models deal with data, but they're also responsible for the calculations and logic around this data. Calculations and rules, for example, belong in a model, but not in a controller.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>This is a generalization. In many cases, you'll have other classes that do this logic work in order to further break down your application. The important thing to take away is that you do not want domain logic in your controller!</p></div></div><p>We also know views deal with presentation. You could build up an HTML string in your controller and pass it to the browser for rendering, but this would involve the controller in something which is the view's responsibility.</p><p>What are we left with? In truth, not much. All your controllers need to do is be in charge of your views and models. That's it. They look at the request the user is making, fetch a model, and use it to render the view to the browser.</p><p>In fact, if your controller is doing more than this, you need to take this as a bad sign. A controller should be the conductor of your orchestra, not the one making the music.</p><div class="section" title="Examples of Ext JS MVC"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Examples of Ext JS MVC</h2></div></div></div><p>The following screenshot<a id="id50" class="indexterm"/> shows our Ext JS v4 MVC test application:</p><div class="mediaobject"><img src="graphics/5308OT_02_03.jpg" alt="Examples of Ext JS MVC"/></div><p>We've generated a stock Ext JS v4 application here, which sticks to the MVC structure and then we've amended it to suit our needs. In this small app, there's a grid of music albums on the left. When you click on the button on the grid, it generates a summary of the artists who are mentioned in the grid, and when you double-click on a row, it puts the album information in the right-hand pane. It's a toy application, but it's useful to demonstrate how MVC works. Later, we'll compare it with a similar application written with Ext JS v5. Let's take a look at the code:</p><div class="informalexample"><pre class="programlisting">// view/List.js
Ext.define('MvcEx1v4.view.List', {
    extend: 'Ext.grid.GridPanel',
    alias: 'widget.app-list',
    store: 'Albums',
    forceFit: true,
    frame: true,
    requires: ['Ext.Msg'],

    columns: [
        { text: 'Name', dataIndex: 'name' },
        { text: 'Artist', dataIndex: 'artist' }
    ],

    initComponent: function() {
        this.bbar = [
            '-&gt;',
            { xtype: 'button', text: 'Show Artist Summary', handler: this.onShowSummary, scope: this },
            '-&gt;'
        ];

        this.callParent(arguments);
    },

    onShowSummary: function() {
        var summary = this.getStore().collect('name').join(', ');

        Ext.Msg.alert('Artists', summary);
    }
});</pre></div><p>Here's our <code class="literal">MvcEx1v4.view.List</code> class in <code class="literal">view/List.js</code>. It's a fairly straightforward grid that uses a <a id="id51" class="indexterm"/>store called <code class="literal">'Albums'</code> and a button on the bottom toolbar to generate the artist summary. Notice that the event handler to generate this summary is included in the view:</p><div class="informalexample"><pre class="programlisting">// view/Detail.js
Ext.define('MvcEx1v4.view.Detail', {
    extend: 'Ext.Container',
    alias: 'widget.app-detail',
    html: 'Double-click an Album to select'
});</pre></div><p>Our second view is <code class="literal">MvcEx1v4.view.Detail</code> in <code class="literal">view/Detail.js</code>. This is just a simple container with some placeholder HTML. Finally, we have the application viewport that holds our views:</p><div class="informalexample"><pre class="programlisting">// view/Viewport.js
Ext.define('MvcEx1v4.view.Viewport', {
    extend: 'Ext.container.Viewport',
    requires:['MvcEx1v4.view.List'],
    layout: 'hbox',
    defaults: {
        width: 250,
        margin: 20
    },
    items: [{ xtype: 'app-list' }, { xtype: 'app-detail' }]
});</pre></div><p>Again, there are a few surprises here. Notice that we refer to our views using the values we defined in<a id="id52" class="indexterm"/> their individual "alias" configuration options: <code class="literal">app-detail</code> and <code class="literal">app-list</code>. We've taken care of the "V" in MVC, so let's move on to "M" and see where our data comes from, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// model/Album.js
Ext.define('MvcEx1v4.model.Album', {
    extend: 'Ext.data.Model',
    
    fields: [
        { name: 'name', type: 'string' },
        { name: 'artist', type: 'string' }
    ]
});
// store/Albums.js
Ext.define('MvcEx1v4.store.Albums', {
extend: 'Ext.data.JsonStore',

   model: 'MvcEx1v4.model.Album',

   data: [
        { name: 'In Rainbows', artist: 'Radiohead' },
        { name: 'Swim', artist: 'Caribou' }
    ]
});</pre></div><p>For easier reading, I've combined the code for the model and the store that consumes it. The data for this application is added inline using the data configuration option (just to avoid messing around with server-side Ajax calls). Let's look at the final facet of MVC, the controller:</p><div class="informalexample"><pre class="programlisting">// controller/Album.js
Ext.define('MvcEx1v4.controller.Album', {
    extend: 'Ext.app.Controller',

    refs: [{
        ref: 'detail',
        selector: 'app-detail'
    }],

    init: function() {
        this.control({
            '.app-list': {
                itemdblclick: this.onAlbumDblClick
            }
        });
    },

    onAlbumDblClick: function(list, record) {
        var html = Ext.String.format('{0} by {1}', record.get('name'), record.get('artist'));

        this.getDetail().getEl().setHTML(html);
    }
});</pre></div><p>Here's where things start to deviate from the straightforward view to data implementation you'd typically see in an Ext JS v3 application. We're introducing a new class that brings in a new<a id="id53" class="indexterm"/> architectural construct. But to what end?</p><p>The answer is communication. The controller, as we know, is the glue that sticks together the "M" and the "V". In our simple example here, it's giving us a mechanism to let the list view talk to the detail view without either of them having to be aware of each other. The <code class="literal">control</code> feature is used to determine what to do when the list view (aliased as <code class="literal">app-list</code>) fires an <code class="literal">itemdblclick</code> event.</p><p>We supply the<a id="id54" class="indexterm"/> <code class="literal">onAlbumDblClick</code> method to respond to this event. In here, we want to talk to our detail view (aliased as <code class="literal">app-detail</code>). We previously used the <code class="literal">refs</code> configuration option to help with this. Let's break it down:</p><div class="informalexample"><pre class="programlisting">refs: [{
    // We give our ref the name "detail". This autogenerates
    // a method on the controller called "getDetail" which
    // will enable us to access the view defined by the selector.
    ref: 'detail',

    // The selector is passed to Ext.ComponentQuery.query,
    // so any valid component query would work here. We're
    // just directly referencing the app-detail alias we
    // set up in the view's configuration
    selector: 'app-detail'
}]</pre></div><p>Long story short, the <code class="literal">refs</code> feature gives us a shorthand way to access a view. In the <code class="literal">onAlbumDblClick</code> handler, we use the autogenerated<a id="id55" class="indexterm"/> <code class="literal">this.getDetail()</code> method that <code class="literal">refs</code> provides. This gives us a reference to the view. We can then set HTML of its view's element based<a id="id56" class="indexterm"/> on the event data provided by the list view.</p></div></div>
<div class="section" title="How does it help your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>How does it help your application</h1></div></div></div><p>Let's recap. How are we better off than in Ext JS 3 before we had any of this MVC stuff involved?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We've got<a id="id57" class="indexterm"/> clear separation of presentation and data with views and models</li><li class="listitem" style="list-style-type: disc">We have a way of orchestrating different parts of our application using controllers</li><li class="listitem" style="list-style-type: disc">We've got a way of splitting our app into logic units by using multiple controllers with associated views</li></ul></div><p>Not only does this lend itself to a good design by keeping different bits of functionality very separate from the outset, but it also gives us a good platform for maintainability purposes because it imposes a very specific way of working.</p></div>
<div class="section" title="MVC and the illusion of choice"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>MVC and the illusion of choice</h1></div></div></div><p>Given everything we've just covered, you'd think that MVC was the holy grail of development. It's tried<a id="id58" class="indexterm"/> and tested, adaptable, and supported by Ext JS. In fact, there are some cases in which it's useful to go a little further and augment MVC.</p><p>To use Ext JS-specific examples, let's look at what happens when you start writing a more complicated application. Your controllers can react to the events that your views fire, orchestrate interactions between different views, and even stores other controllers. So, does this mean that you put your event handlers in your controllers, your views, or a combination of both?</p><p>This is a key question, which can be answered simply by being very strict with your development process from the beginning. MVC provides the "illusion of choice"; in this, it offers a large variety of ways to set up your application, but only a few that will result in a healthy application.</p><p>How about when you have a central source of data, but different views that consume it? You might want to<a id="id59" class="indexterm"/> have this data in slightly different forms for each view. Does the view itself take responsibility for shaping this data?</p><p>Ext JS 5 implements a pattern called <span class="strong"><strong>model-view-viewmodel</strong></span> (<span class="strong"><strong>MVVM</strong></span>) that tries to address these questions.</p></div>
<div class="section" title="Introducing MVVM"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Introducing MVVM</h1></div></div></div><p>MVVM can be seen as an augmentation<a id="id60" class="indexterm"/> of MVC. Introducing the view model concept, it recognizes that not every view concerned with a dataset will be using this data in the same way. It adds a layer of indirection between a view and a model, called a view model, to solve this issue. It also keeps separation of concerns to the fore; why should the model, which is dealing with our data be concerned about anything to do with our view, which is dealing with presentation?</p><div class="mediaobject"><img src="graphics/5308OT_02_04.jpg" alt="Introducing MVVM"/><div class="caption"><p>A typical representation of MVVM</p></div></div><div class="section" title="How does Ext JS use MVVM?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>How does Ext JS use MVVM?</h2></div></div></div><p>With Ext JS 5, MVVM is wholeheartedly embraced. The sample application structure that Sencha Cmd generates will provide a <code class="literal">ViewModel</code> class alongside the <code class="literal">View</code> class. This has tight integration<a id="id61" class="indexterm"/> into the <code class="literal">View</code> class via new configuration options, which <a id="id62" class="indexterm"/>make it a first-class citizen when trying to solve the common problems that arise in a large MVC application, as we discussed earlier.</p><p>In addition, a <code class="literal">ViewController</code> class is created to encapsulate the logic you'd normally put in a view or in a standard controller. It removes the question of where to put event handlers that are concerned with things internal to the view, rather than event handlers that will be passing <a id="id63" class="indexterm"/>off events to other parts of your application.</p></div><div class="section" title="Getting our MVVM started"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Getting our MVVM started</h2></div></div></div><p>We started by generating an <a id="id64" class="indexterm"/>Ext JS 5 application template using Sencha Cmd and used it as a basis to build an implementation of our example album list application. The default Ext JS 5 template uses an MVVM implementation as follows:</p><div class="mediaobject"><img src="graphics/5308OT_02_05.jpg" alt="Getting our MVVM started"/><div class="caption"><p>Our example app ported to Ext JS 5's MVVM architecture</p></div></div><p>The most immediate difference you'll notice is that we've lost our controllers directory and there's a lot more going on in the views directory. Let's break it down:</p><div class="informalexample"><pre class="programlisting">// model/Album.js
Ext.define('MvvmEx1v5.model.Album', {
    extend: 'Ext.data.Model',
    
    fields: [
        { name: 'name', type: 'string' },
        { name: 'artist', type: 'string' }
    ]
});</pre></div><p>The album model is identical to the previous example, although note that we've changed the application name to <code class="literal">MvvmEx1v5</code>. The store is only very slightly different:</p><div class="informalexample"><pre class="programlisting">// store/Albums.js
Ext.define('MvvmEx1v5.store.Albums', {
    extend: 'Ext.data.JsonStore',

    model: 'MvvmEx1v5.model.Album',

    data: [
        { name: 'In Rainbows', artist: 'Radiohead' },
        { name: 'Swim', artist: 'Caribou' }
    ]
});</pre></div><p>We've added the <code class="literal">alias</code> configuration<a id="id65" class="indexterm"/> option so that we can refer to the store later using the albums shorthand. Now, let's take a look at the views directory:</p><div class="informalexample"><pre class="programlisting">// view/album/Album.js
Ext.define('MvvmEx1v5.view.album.Album', {
    extend: 'Ext.container.Container',
    xtype: 'app-album',
    requires: ['Ext.grid.Panel'],
    controller: 'album',
    layout: 'hbox',
    defaults: {
        width: 250,
        margin: 20
    },
    items: [
        {
            xtype: 'grid',
            reference: 'list',
            viewModel: 'album',
            bind: '{albums}',
            forceFit: true,
            frame: true,
            margin: '20 10 20 20',
            columns: [
                { text: 'Album', dataIndex: 'name' },
                { text: 'Artist', dataIndex: 'artist' }
            ],
            bbar: [
                '-&gt;',
                { xtype: 'button', text: 'Show Artist Summary', handler: 'onShowSummary' },
                '-&gt;'
            ],
            listeners: {
                rowdblclick: 'onAlbumDblClick'
            }
        },
        { xtype: 'container', margin: '20 10', reference: 'detail', width: 150, html: 'Double-click an Album to select' }
    ]
});</pre></div><p>We've combined the previous <code class="literal">app-list</code> and <code class="literal">app-detail</code> views into a single <code class="literal">app-albums</code> view, and whereas before we had the logic to build the album summary in the view, we now <a id="id66" class="indexterm"/>define only the event handler and the logic goes elsewhere. This view is now 100 percent presentation and defers all the complicated stuff to other classes.</p><p>Note that we have a <code class="literal">controller</code> configuration option that defines the view controller to use for this view class. Our grid component has several interesting configuration options too:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reference</code>: We use this later to get hold of this component from the view controller.</li><li class="listitem" style="list-style-type: disc"><code class="literal">viewModel</code>: This is the alias of the view model this component will use.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bind</code>: This defines how the view talks to the view model. We're using the simplest binding (the grid's default <code class="literal">bindProperty</code> is store), so here we're essentially just setting the store <code class="literal">config</code> to <code class="literal">'albums'</code>.</li></ul></div><p>Now, let's move on to our album view model:</p><div class="informalexample"><pre class="programlisting">// view/album/AlbumModel.js
Ext.define('MvvmEx1v5.view.album.AlbumModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.album',

    requires: [
        'MvcEx1.store.Albums'
        'Ext.Msg'
    ],
    stores: {
        albums: {
            type: 'albums'
        }
    },

    buildSummary: function() {
        return this.getStore('albums').collect('name').join(', ');
    }
});</pre></div><p>Also, here we have one of these places that now contain this logic. A view model takes data from a model (or stores) and presents it in a way suitable for its matching view. In this case, we take the data<a id="id67" class="indexterm"/> from the <code class="literal">'albums'</code> store (referenced in the <code class="literal">type</code> configuration option by the albums alias we mentioned earlier). It provides a <a id="id68" class="indexterm"/>
<code class="literal">buildSummary</code> method that transforms the stored data into a string ready to be used in the UI as follows:</p><div class="informalexample"><pre class="programlisting">// view/album/AlbumController.js
Ext.define('MvvmEx1v5.view.album.AlbumController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.album',

    onShowSummary: function() {
        var summary = this.lookupReference('list').getViewModel().buildSummary();

        Ext.Msg.alert('Artists', summary);
    },

    onAlbumDblClick: function(list, record) {
        var html = Ext.String.format('{0} by {1}', record.get('name'), record.get('artist'));
        this.lookupReference('detail').getEl().setHtml(html);
    }
});</pre></div><p>Finally, we have our view controller, which is where any logic that manages our view should go. Event handlers defined in the view controller will automatically be available to the matching view.</p></div><div class="section" title="Are we better off?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Are we better off?</h2></div></div></div><p>Yes, we're better off because we're more organized. We know where all of our application bits go, and although we've got a lot more files than a straightforward one-class Ext JS application, we'll always know where to look to change the configuration of a view, where to find our logic for the albums, or where to shape the information we pull from a store.</p><p>One important point about this example is that we forego the overarching controller from the first example in favor of a view controller. Here, this makes sense; we want this view controller to be concerned only with albums, not with other parts of the application. However, a higher-level controller is still a valid piece of the Ext JS MVVM architecture and can be reintroduced in situations that require a way to coordinate an application at a higher level than a view controller.</p></div><div class="section" title="A brief interlude regarding stores"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>A brief interlude regarding stores</h2></div></div></div><p>Throughout this entire chapter, we've talked a lot about models, but never specifically about stores despite using them in our example applications. Why isn't it "SVC" or "SVVM"?</p><p>In Ext JS, a store is a specific <a id="id69" class="indexterm"/>class, which brings specific functionality and is tightly bound into your application. However, in a simple MVC or MVVM implementation, the "store" could just be an array of models, rather than being a separate architectural feature. So, a store is really just a way of collecting models together and Ext JS happens to be the place where we can do lots of extra things (such as sorting, filtering, and batching).</p></div><div class="section" title="Inter-communication"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Inter-communication</h2></div></div></div><p>We've shown how to create a simple application that uses several moving parts to create a logical unit. Thanks to the<a id="id70" class="indexterm"/> MVVM pattern, we have a methodology that allows the parts of this unit to communicate without having to be explicitly tied to the implementation details of other parts.</p><p>When we extend our application, we'll have several of these logical units, perhaps, an artist section in addition to an album section. Now, these have to communicate with each other in turn. This represents one of the main problems in software architecture: how to allow albums and artists to talk to each other without contaminating either component with details of the other. It's a problem that scales in direct proportion to the size and complexity of an application.</p></div><div class="section" title="The main event"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>The main event</h2></div></div></div><p>One approach to this problem is to allow your application parts to fire off custom events, each containing a payload that can be consumed by any other part of your application that might be interested in them.</p><p>In fact, we see this in<a id="id71" class="indexterm"/> action all the time in web development. Event handlers are an integral part of JavaScript programming as we bind functions to the events thrown by user interface elements (such as buttons) or to browser events (such as <code class="literal">window.onload</code>). We've touched on this in our example code already; our view fired off a <code class="literal">rowdblclick</code> event that was handled by our view controller.</p><p>In complex applications, developers will often implement a feature called an event bus, a way of taking the events that application components fire off and transporting them to various subscribers. Since Ext JS 4.2, event domains have allowed developers to incorporate a similar feature into their code base.</p></div><div class="section" title="Event domains"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Event domains</h2></div></div></div><p>Event domains allow controllers to react to events from various different sources in your application. The default <a id="id72" class="indexterm"/>sources are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Components</strong></span>: These are events fired from components. This is essentially the functionality that <code class="literal">Ext.app.Controller.control()</code> provides by handling events from classes that extend <code class="literal">Ext.Component</code> and bind them to event listeners.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Global</strong></span>: These are events<a id="id73" class="indexterm"/> fired from a single global source and used to bind arbitrary application-wide events.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Controller</strong></span>: These are events fired from other controllers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Store</strong></span>: These are events fired from a store.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Direct</strong></span>: These are events fired from classes that extend <code class="literal">Ext.direct.Provider</code>. This is only used if you require <code class="literal">Ext.direct.Manager</code> in your application.</li></ul></div><p>Some event domains allow you to filter the received events by a selector (usually the ID associated with the source), but in the Component case, you can use a full-blown <code class="literal">Ext.Component</code> query. This allows you to have finer-grained control on how to subscribe to events.</p></div></div>
<div class="section" title="An event domain example"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>An event domain example</h1></div></div></div><p>Let's go back to our MVVM album <a id="id74" class="indexterm"/>example we created earlier. Our view had handler and listener configurations that tied view events to event handlers that we put in our view controller. However, event domains allow us to remove this tie and give all of the control to the view component. In <code class="literal">view/album/Album.js</code> in our previous example, we can remove the listener config on the grid and the handler on the button and then add the following code to <code class="literal">view/album/AlbumController.js</code>:</p><div class="informalexample"><pre class="programlisting">init: function() {
    this.listen({
        component: {
            'app-album grid': {
               'rowdblclick': 'onAlbumDblClick'
            },
            'app-album button': {
               'click': 'onShowSummary'
            }
        }
    });
}, </pre></div><p>This is slightly more verbose, so look at what exactly is happening here. We pass an object to <code class="literal">this.listen</code>, which contains a component property; this indicates we are configuring the Component Event Domain. Inside here, we use two selectors, one for the grid itself and one for the summary button, and inside these definitions we specify the event we are binding to and the event handlers.</p><p>This gives us the ability to remove anything clever from the view and put it all in the view controller. The view deals purely with presentation and the view controller deals with the logic.</p><div class="section" title="Using custom events"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Using custom events</h2></div></div></div><p>We've shown how<a id="id75" class="indexterm"/> event domains can be used to separate our code concerns even further, but now, you'll see how they can help orchestrate interactions at a higher level. For this, let's take a look at a theoretical situation in which our application has grown to incorporate multiple views and view controllers:</p><div class="informalexample"><pre class="programlisting">// view/search/SearchController.js
Ext.define('EventDomain1.view.search.SearchController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.search',
    
    init: function() {
        this.listen({
            component: {
                'app-search button': {
                   'click': 'onSearchSubmit'
                }
            }
        });
    },

    onSearchSubmit: function() {
        var val = this.lookupReference('searchfield').getValue();
        this.fireEvent('search', val);
    }
});</pre></div><p>We've created a new <code class="literal">SearchController</code>, which is the view controller for a new <code class="literal">Search</code> view. We use <code class="literal">this.listen</code> to listen for events on the component event domain and filter them using the selector <code class="literal">'app-search button'</code> (a button within our new <code class="literal">Search</code> view). When the button is clicked on, we trigger an event handler method called <code class="literal">onSearchSubmit</code>.</p><p>We extract the<a id="id76" class="indexterm"/> search term that the user entered and then fire a second event, passing the search term as the event data. The event we fire is called <code class="literal">'search'</code> and rather than being tied to a button or other UI component, it can be subscribed to by other parts of the application as a pure application event. Let's take a look at how it could be consumed:</p><div class="informalexample"><pre class="programlisting">// partial /view/album/AlbumController.js
init: function() {
    this.listen({
        controller: {
            '*': {
                'search': 'onSearch'
            }
        }
    });
}</pre></div><p>This is a snippet of the <code class="literal">AlbumController</code> we've seen before with some extra goodness. With <code class="literal">this.listen</code>, we use the <code class="literal">'*'</code> selector to allow all controllers on the event domain. Then, we specify that we want to handle the search event with the <code class="literal">onSearch</code> handler method. This should all be feeling pretty familiar by now! The handler method could be as simple as the following code:</p><div class="informalexample"><pre class="programlisting">onSearch: function(searchTerm) {
    var list = this.lookupReference('list');
    list.getViewModel().search('searchTerm');
}</pre></div><p>Assume that we<a id="id77" class="indexterm"/> created a <code class="literal">search</code> method on the view model. With just a small amount of code, we allowed two distinct parts of our application to communicate using information about our application rather than information about themselves. This is key to keeping the search part of this code unaware about the albums part and allows very clear-cut divisions between them. This provides easier testing through separation of concerns, better maintainability, and easier comprehension of how the application is structured.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>MVC and MVVM are key architectural constructs that we need to firmly understand before starting on a new project. Given that they're so embedded in Ext JS, it's even more important to have a good grasp of the ideas behind them and why implementing such patterns will assist in the way we construct our code base. In the next chapter, we'll move on to more practical examples of structuring an Ext JS application, incorporating MVVM concepts with a variety of other ideas that set out a strong platform to build on.</p></div></body></html>