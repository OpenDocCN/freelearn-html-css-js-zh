<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Evolver: Using Profiles</h1></div></div></div><p>With the growing popularity of mobile devices, web designers have had to deal with a wide variety of screen sizes. This is even tougher on web application developers who also need to allow for different functionality between devices. Sencha Touch offers an easy way of dealing with multiple devices, called <a id="id742" class="indexterm"/>profiles.</p><p>Since the Sencha Touch framework is aware of which device it is running on, we can set up individual profiles for each device we want to support. Sencha Touch will then swap out components and functionality based on the device.</p><p>In this chapter we will look at:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of profiles</li><li class="listitem" style="list-style-type: disc">Setting up profiles</li><li class="listitem" style="list-style-type: disc">Testing profiles</li><li class="listitem" style="list-style-type: disc">Loading custom CSS by device</li></ul></div><p>We will create an application that reads pages and posts from a WordPress website and translates them into a custom application for mobile devices. We call this application, Evolver.</p><p>Evolver will use separate profiles to create a view for iPhone and a different view for iPad. These views will <a id="id743" class="indexterm"/>have their own functionality and can be customized to suit the needs of the user and the device.</p><p>However, before we get too far ahead of ourselves, we should probably talk a little bit about what profiles do and when to use them.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>An overview of profiles</h1></div></div></div><p>Profiles in <a id="id744" class="indexterm"/>Sencha Touch act much like a <a id="id745" class="indexterm"/>director, or a traffic cop. When the application loads, the profiles determine what kind of device they are being run on and load a different set of controllers and views based on the device (the stores and models typically do not change).</p><p>As you may have guessed, this means that each profile (device) needs its own set of controllers and views. While they can, and do share elements such as stores and models, most of the display logic is unique to the device. <a id="id746" class="indexterm"/>This can seem like a lot of extra work, which leads to the question: when and why should you use profiles?</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Profile basics</h2></div></div></div><p>As a general rule, it is usually a good idea to design an application specifically for a device or screen size. A smaller screen requires bigger fonts in order to be readable, but it also has less space for information. This means that it usually relies on multiple screens to get the information across to the user. A similar <a id="id747" class="indexterm"/>interface on a tablet device would be clunky and frustrating in most cases.</p><p>However, with a few simple applications, a change in CSS stylesheets will accomplish the necessary changes to the interface. A profile is not needed in this case and the stylesheet can simply be loaded based on the device being used. This method allows us to use the classes and IDs of our individual elements to control the overall appearance of our application.</p><p>For most professional applications, a combination of profiles and stylesheet changes will better serve the end user. We can demonstrate this using some drawings of our Evolver application. Let's start with our tablet version:</p><div><img src="img/8901OS_08_1.jpg" alt="Profile basics"/></div><p>Here we have a lot of screen real estate we can put to use. We can easily show our list of pages and posts, and still show the content of the selected item at the same time. We have room for multiple tabs and even a website logo.</p><p>If we were to view this kind of layout on a phone-sized screen, it would be far too small to effectively use or even read. As we noted <a id="id748" class="indexterm"/>before, a phone-sized screen needs larger fonts and multiple screens to display the data the user needs:</p><div><img src="img/8901OS_08_2.jpg" alt="Profile basics"/></div><p>In this case we have two screens. The first is for our list of pages or posts. Our tabs at the bottom will determine which list the user sees. When the user selects an item from the list, we will use a second screen to display the content for the page or post. We will also provide a back button to allow the user to return to the mail list.</p><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>
<strong>Sketches or Wireframes</strong>
</p><p>Sketches like these are often called <a id="id749" class="indexterm"/>
<strong>wireframes</strong>. It is a really good idea to draw out these types of ideas before you begin coding the application. They don't have to be fancy, they just need to make you think about how the application will be organized and how the user will get from one screen to the next. Wireframes can quickly highlight any issues you hadn't thought of yet, and they will save you a huge amount of time later on when you begin coding. It's also a good idea to show these wireframes to potential users. Non-technical people can often reveal areas of confusion for a user, and their questions and feedback will make your application more useful.</p></div></div><p>From looking at the two sketches, <a id="id750" class="indexterm"/>we can determine the views that we need and the different functions we will need in our controllers. For example, clicking on an item in the phone version will need to add a panel to a navigation view, while in the tablet version, clicking on an item will just replace the content in our main panel.</p><p>Now that we have some idea of the different views and functions we want, we can take a look at how the profiles actually work.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec86"/>Using profiles</h2></div></div></div><p>The first part of our profile setup takes <a id="id751" class="indexterm"/>place in <code class="literal">app.js</code>. This file is typically where we load our initial stores and models, as well as set up a launch function to start the application.</p><p>With profiles, things work a bit differently. We start by declaring the profiles we wish to use like so:</p><div><pre class="programlisting">Ext.application({
 name: 'Evolver', 
 profiles: ['Phone', 'Tablet'] …</pre></div><p>The names for our two profiles are arbitrary and we can have as many as we like. They can be specific to an OS as well as device type. When we use profiles such as these, we typically do not use a launch function inside our <code class="literal">app.js</code> file. Since the profiles will have different starting screens, we place the launch function inside the individual profiles.</p><p>The profiles should be placed in a directory called <code class="literal">profile</code>, inside the <code class="literal">app</code> directory of your application. They should be named the way you named them in your <code class="literal">app.js</code> file (in our case this would be <code class="literal">Phone.js</code> and <code class="literal">Tablet.js</code>).</p><div><div><h3 class="title"><a id="note48"/>Note</h3><p>If it helps, you can think of the profile files as a way to have multiple <code class="literal">app.js</code> files, one per device.</p></div></div><p>These individual profiles will load our views and controllers, and they will launch our initial screen. However, the first thing we need to do is figure out which profile is active. We do this by creating an <a id="id752" class="indexterm"/>
<code class="literal">isActive</code> function in our <code class="literal">Phone.js</code> file like so:</p><div><pre class="programlisting">Ext.define('Evolver.profile.Phone', {
    extend: 'Ext.app.Profile',
    config: {
        name: 'Phone'
    },
    isActive: function() {
        return Ext.os.is.Phone;
    }
});</pre></div><p>This <code class="literal">isActive</code> function<a id="id753" class="indexterm"/> will return true <a id="id754" class="indexterm"/>if the application is running on a phone. We use a similar function in our <code class="literal">Tablet.js</code> profile:</p><div><pre class="programlisting">Ext.define('Evolver.profile.Tablet, {
    extend: 'Ext.app.Profile',
    config: {
        name: 'Tablet'
    },
    isActive: function() {
        return Ext.os.is.Tablet;
    }
});</pre></div><p>Our <code class="literal">app.js</code> file<a id="id755" class="indexterm"/> will load one of these profiles, if the <code class="literal">isActive</code> function<a id="id756" class="indexterm"/> returns true. Only one of these profiles should ever return true.</p><div><div><h3 class="title"><a id="note49"/>Note</h3><p>You can find more information about the <a id="id757" class="indexterm"/>
<code class="literal">Ext.os.is</code> function in the Sencha Touch developer documentation located at <a class="ulink" href="http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is">http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is</a>.</p></div></div><p>Each profile will also contain its own views and controllers, as well as its own launch function. However, it is important to note that the <a id="id758" class="indexterm"/>
<code class="literal">Ext.loader</code> function will automatically look for these items in a subfolder named after the profile.</p><p>For example, our tablet profile has a controller called <code class="literal">Main.js</code>. We include this in our profile the same way we normally would in <code class="literal">app.js</code>:</p><div><pre class="programlisting">controllers: ['Main']</pre></div><p>However, since this controller is inside a profile, the <code class="literal">Ext.loader</code> function will look for the file as <code class="literal">app/controllers/tablet/Main.js</code>. Conversely, in our phone profile, we still include the controller as <code class="literal">controllers: ['Main']</code>, but the loader will automatically look for the file as <code class="literal">app/controllers/phone/Main.js</code>.</p><p>You can override this behavior in a profile by using the full name of the controller like this:</p><div><pre class="programlisting">controllers: ['MyApp.controller.Main']</pre></div><p>This would look for the <code class="literal">Main.js</code> file in the <code class="literal">app/controller</code> folder. This works the same for views, models, and stores as well.</p><p>You will also find that some files are common to both profiles. Rather than including them in our individual profiles, we can include these common files in <code class="literal">app.js</code>. For example, in our Evolver application, we will have models and stores for pages and posts. These will be common to both profiles, so we can add them as normal in <code class="literal">app.js</code>:</p><div><pre class="programlisting"> models: ['Page', 'Post'],
 stores: ['pageStore', 'postStore']</pre></div><p>Since these load from <code class="literal">app.js</code> (and not from one of our profiles), the loader will look for them in the <code class="literal">app/model</code> and <code class="literal">app/store</code> folders respectively.</p><p>As we noted before, the profiles <a id="id759" class="indexterm"/>also have individual launch functions in addition to the optional <code class="literal">launch</code> function<a id="id760" class="indexterm"/> in <code class="literal">app.js</code>. In a profile-based application, the <code class="literal">app.js launch</code> function is typically ignored since the profiles will likely launch different components to create the main screen. However, if the application requires it, you can use the <code class="literal">app.js launch</code> function as well, to perform clean up or load stores if desired.</p><p>The order works something like this (when the application starts):</p><div><ol class="orderedlist arabic"><li class="listitem">The active profile is determined.</li><li class="listitem">Any controllers in the profile or in <code class="literal">app.js</code> are instantiated (meaning the <code class="literal">init</code> function is fired).</li><li class="listitem">The launch function in the profile fires.</li><li class="listitem">The launch function in <code class="literal">app.js</code> fires.</li></ol></div><p>It should be noted that both the profile and <code class="literal">app.js launch</code> functions are optional and will only be called if they are defined.</p><p>Now that we have the profile basics out of the way, let's get a little more specific about our application.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Creating the Evolver application</h1></div></div></div><p>The Evolver application takes an <a id="id761" class="indexterm"/>RSS feed from a WordPress website and translates the feed into data in a Sencha Touch store. We did something similar in our previous Feedback application with the RSS feed. However, we are going to need a bit of extra help to get all of the information we need out of WordPress.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec87"/>About WordPress</h2></div></div></div><p>For those of you who don't know about <a id="id762" class="indexterm"/>
<a id="id763" class="indexterm"/> WordPress, it is a content management system that was initially designed for blogging. WordPress allows a user to easily create posts and pages using simple web-based forms. Posts tend to be shorter, time-sensitive items, while pages contain longer, more general information.</p><p>When WordPress began to gain popularity, users quickly began to use it for all kinds of websites from personal, to business and shopping. Current estimates are that the WordPress site numbers somewhere north of 55 million, comprising an estimated 15 to 20 percent of the active websites on the Internet.</p><p>With the ease of installation and massive amounts of customization, WordPress has become a darling of the small business community. The one drawback is that the design complexity of a typical WordPress website doesn't always lend itself to a mobile-sized screen and platform. The following screenshot is an example of a standard WordPress style website:</p><div><img src="img/8901OS_08_3.jpg" alt="About WordPress"/></div><p>While this kind of layout appears fine on a desktop or laptop screen, it's not a great use of space for a tablet, and way too <a id="id764" class="indexterm"/>
<a id="id765" class="indexterm"/>much information for a phone-sized screen. We need a mobile-friendly version of the site that makes effective use of the advantages and limitations of tablet and phone platforms. The following screenshot is an example of the approach we want to take:</p><div><img src="img/8901OS_08_4.jpg" alt="About WordPress"/></div><p>Since the data behind the WordPress website already lives in a MySQL database, we just need a way to get it into a data store so we can use it in Sencha Touch.</p><p>The posts from WordPress are <a id="id766" class="indexterm"/>
<a id="id767" class="indexterm"/>available in RSS format, but the pages are not. We are going to need to use a plugin for WordPress in order to get the pages we want as well. You will need to use your own WordPress website to make this work.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec88"/>Using the plugin</h2></div></div></div><p>WordPress plugins <a id="id768" class="indexterm"/>
<a id="id769" class="indexterm"/>
<a id="id770" class="indexterm"/>allow you to extend the basic functions and features of WordPress. In most cases this process is as simple as searching and clicking on the install button. In this case, we will be installing Dan Phiffer's JSON API plugin. This plugin will allow us to make standard API calls into our WordPress site.</p><p>Let's install the plugin and then we can see how it works with a bit of testing:</p><div><ol class="orderedlist arabic"><li class="listitem">From your WordPress admin page, select <strong>Plugins</strong> from the menu.</li><li class="listitem">On the <strong>Plugins</strong> page, click on the <strong>Add New</strong> button.</li><li class="listitem">Enter <code class="literal">JSON API</code> in the <strong>Search</strong> field and click on <strong>Search Plugins</strong>.</li><li class="listitem">Click on <strong>Install</strong> next to the <strong>JSON API</strong> plugin (it should be the first one in the list).</li></ol></div><p>You can test to see if the plugin has been installed correctly by checking the following URL in your web browser(replace <code class="literal">yourwordpressdomain.com</code> with the address <a id="id771" class="indexterm"/>
<a id="id772" class="indexterm"/>
<a id="id773" class="indexterm"/>
<a id="id774" class="indexterm"/>of your WordPress installation):</p><p>
<a class="ulink" href="http://yourwordpressdomain.com/api/get_page_index/">http://yourwordpressdomain.com/api/get_page_index/</a>
</p><p>You should get back a JSON response string with the pages for your site. Note that this string comes back as shown here:</p><div><pre class="programlisting">{"status":"ok",
 "pages":[
  {page 1 data},
  {page 2 data},
  {page 3 data},
  {etc…}
 ]
}</pre></div><p>We need to keep in mind that the <code class="literal">pages</code> array actually contains the data we are looking for. This will get set as <code class="literal">rootProperty</code>
<a id="id775" class="indexterm"/> of the store's reader component when we create our store.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec89"/>Setting up the profiles and app.js</h2></div></div></div><p>We will start with a basic Sencha <a id="id776" class="indexterm"/>
<a id="id777" class="indexterm"/>Touch application, set up from our command-line SDK tools<a id="id778" class="indexterm"/> (as we did in some of our earlier chapters). This creates our application shell and our view, model, store, and controller folders.</p><p>In our <code class="literal">app.js</code> file, we will add lines for our profiles. We also have some common elements in both profiles, specifically, the models and stores for pages and profiles. Since these will need to load for both profiles, we can add them in our <code class="literal">Ext.application</code> declaration, rather than adding them twice, once in each profile file:</p><div><pre class="programlisting"> profiles: ['Phone', 'Tablet']
 models: ['Page', 'Post'],
 stores: ['pageStore', 'postStore'] </pre></div><p>Now that we have our <code class="literal">app.js</code> file set up, we need to create a <code class="literal">profile</code> folder in our <code class="literal">app</code> directory. This is <a id="id779" class="indexterm"/>
<a id="id780" class="indexterm"/>where our two profiles will go.</p><p>Our <code class="literal">Phone.js</code> profile looks like this:</p><div><pre class="programlisting">Ext.define('Evolver.profile.Phone', {
    extend: 'Ext.app.Profile',
    config: {
        name: 'Phone',
        controllers: ['Main'],
        views: ['Main', 'Evolver.view.PostList', 'Evolver.view.PageList', 'PageDetails', 'PostDetails']
    },
    isActive: function() {
       return Ext.os.is.Phone;
    },
    launch: function() {
       Ext.fly('appLoadingIndicator').destroy();
       Ext.create('Evolver.view.phone.Main', {fullscreen: true});
    }
});</pre></div><p>We have three pieces here: the <code class="literal">config</code> section, our <code class="literal">isActive</code> function, and our <code class="literal">launch</code> function.</p><p>Our <code class="literal">config</code> section has the profile <code class="literal">name</code>, <code class="literal">controllers</code> and <code class="literal">views</code> values. Remember that since we are in the profile, the loader will be looking for these files in <code class="literal">app/controller/phone</code> and <code class="literal">app/view/phone</code> respectively.</p><p>Notice that we also have two of our views listed with the full names: <code class="literal">Evolver.view.PostList</code> and <code class="literal">Evolver.view.PageList</code>. These views will actually be shared by both profiles, so we put them in the <code class="literal">app/views</code> folder. We could also just put them in <code class="literal">app.js</code> and it would accomplish the same thing. We included them here to demonstrate that the file location can be overridden if required.</p><p>Our <code class="literal">isActive</code> function<a id="id781" class="indexterm"/> will return true if we are running on a phone.</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>
<strong>isActive, device types, and Safari</strong>
</p><p>If you are testing on Safari with a desktop or laptop, you will run into some issues using this function. Despite the ability to set the user agent in Safari to iPad or iPod, the browser does not correctly report the device type to Sencha Touch.</p><p>When you are testing, you will need to comment out the <code class="literal">return Ext.os.is.Phone</code> or <code class="literal">return Ext.os.is.Tablet</code> lines in the <code class="literal">isActive</code> function. Then you can set the <code class="literal">isActive</code> function in the profile you want to test to <code class="literal">return true;</code> and the other one to <code class="literal">return false;</code>. Just remember to uncomment the correct functions before moving to production.</p><p>If you are testing with the iOS or Android simulators, this is not an issue.</p></div></div><p>The <code class="literal">launch</code> function removes our loading <a id="id782" class="indexterm"/>
<a id="id783" class="indexterm"/>indicator and creates an instance of our <code class="literal">Evolver.view.phone.Main</code> view at full screen size.</p><p>Our <code class="literal">Tablet.js</code> profile follows the same pattern as our phone profile:</p><div><pre class="programlisting">Ext.define('Evolver.profile.Tablet', {
    extend: 'Ext.app.Profile',
    config: {
        name: 'Tablet',
        controllers: ['Main'],
        views: ['Main', 'Evolver.view.PostList', 'Evolver.view.PageList', 'PageDetails', 'PostDetails']
    },
    isActive: function() {
      return Ext.os.is.Tablet;
    },
    launch: function() {
        Ext.fly('appLoadingIndicator').destroy();
        Ext.create('Evolver.view.tablet.Main', {fullscreen: true});
    }
});</pre></div><p>Much like the phone profile, the controllers and views will be loaded from a <code class="literal">tablet</code> folder in our <code class="literal">app/controllers</code> and <code class="literal">app/views</code> folders.</p><p>We are going to take a very brief look at the stores, models, and views for the application as there isn't much new here. Then, we will finish up with the controllers, where the action really happens.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec90"/>Setting up the models and stores</h2></div></div></div><p>Our models are very basic, and they are <a id="id784" class="indexterm"/>
<a id="id785" class="indexterm"/>taken from the data that is sent back from the RSS feed for posts and the JSON API plugin for pages. We are only using some of that data, but you can easily look through the values that are returned from <code class="literal">yoursite/feeds/rss/</code> (posts) and <code class="literal">yoursite/api/get_page_index/</code> (pages) to see if there is any other interesting data you might want to use.</p><p>Our post model looks like this:</p><div><pre class="programlisting">Ext.define('Evolver.model.Post', {
    extend: 'Ext.data.Model',
    config: {
    idProperty: 'guid',
        fields: [
            {
                name: 'guid',
                type: 'string'
            },
            {
                dateFormat: 'D, d M Y H:i:s Z',
                name: 'pubDate',
                type: 'date'
            },
            {
                name: 'title',
                type: 'string'
            },
            {
                name: 'author',
                mapping: 'creator',
                type: 'string'
            },
            {
                name: 'content',
                mapping: 'encoded',
                type: 'string'
            },
            {
                name: 'category',
                type: 'string'
            },
            {
                name: 'link',
                type: 'string'
            }
        ]
    }
});</pre></div><p>The only thing new here is the use of mapping to indicate that, while we will refer to the strings as <code class="literal">author</code> and <code class="literal">content</code>, the data is actually received as <code class="literal">creator</code> and <code class="literal">encoded</code> respectively. This is often helpful to keep values consistent across the application, avoid naming conflicts, or simply preserve a coder's sanity.</p><p>The <code class="literal">postStore</code> attribute<a id="id786" class="indexterm"/> for this model is configured to run from the same server as the WordPress website you are using. This means we can use an <code class="literal">ajax</code> store instead of a <code class="literal">jsonp</code> store. If you want to use this from a different server, you will need to change the proxy to <code class="literal">jsonp</code> and use the JSON <a id="id787" class="indexterm"/>
<a id="id788" class="indexterm"/>API to grab the posts instead of the standard WordPress RSS feed (which is in XML):</p><div><pre class="programlisting">Ext.define('Evolver.store.postStore', {
    extend: 'Ext.data.Store',
    requires: [
        'Evolver.model.Post'
    ],
    config: {
        storeId: 'postStore',
        autoLoad: true,
        model: 'Evolver.model.Post',
        proxy: {
            type: 'ajax',
            url: '/feed/rss/',
            reader: {
                type: 'xml',
                record: 'item'
            }
        }
    }
});</pre></div><p>The <code class="literal">record: 'item'</code> configuration tells the reader to look in the XML for a collection of items to be used as the data for its records.</p><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>
<strong>WordPress RSS feeds</strong>
</p><p>By default, RSS feeds in WordPress are set <a id="id789" class="indexterm"/>to only show a partial text of the post. You can change this in the <strong>Admin</strong> control panel of your WordPress site. In the <strong>Admin</strong> menu select <strong>Settings</strong> | <strong>Reading</strong> and change the feed settings from <strong>Summary</strong> to <strong>Full Text</strong>.</p></div></div><p>Since this store is not a <a id="id790" class="indexterm"/>JSONP store, it has to be run on the same server as the WordPress site it is pulling from. There is not an equivalent <a id="id791" class="indexterm"/>XMLP store, so testing on a local machine will require a bit of a workaround. During testing, you can download the RSS feed from your WordPress site to your local machine and read from the local XML file. Later, when you move to production, <a id="id792" class="indexterm"/>
<a id="id793" class="indexterm"/>you can change the URL to the live link.</p><p>Our <code class="literal">pageStore</code> is designed to use the JSON API plugin, so we will be taking in JSON instead of XML:</p><div><pre class="programlisting">Ext.define('Evolver.store.pageStore', {
    extend: 'Ext.data.Store',
    requires: [
        'Evolver.model.Page'
    ],
    config: {
        model: 'Evolver.model.Page',
        autoLoad: true,
        storeId: 'pageStore',
        proxy: {
            type: 'jsonp',
            url: 'http://yourWordPressSite.com/api/get_page_index/',
            reader: {
                type: 'json',
                rootProperty: 'pages'
            }
        }
    }
});</pre></div><p>With this store we are reading JSON from our API. The <code class="literal">get_page_index</code> function will return a hierarchical list of the pages for the website.</p><div><div><h3 class="title"><a id="note50"/>Note</h3><p>The JSON API plugin for <a id="id794" class="indexterm"/>WordPress has a number of helpful functions you can use to read and write data to your WordPress website. A full list of functions can be found here at <a class="ulink" href="http://wordpress.org/extend/plugins/json-api/other_notes/">http://wordpress.org/extend/plugins/json-api/other_notes/</a>.</p></div></div><p>Our data model for the pages is using a limited set of the data supplied by the JSON API plugin:</p><div><pre class="programlisting">Ext.define('Evolver.model.Page', {
    extend: 'Ext.data.Model',
    config: {
        fields: [
            {
                name: 'id',
                type: 'int'
            },
            {
                name: 'title',
                type: 'string'
            },
            {
                name: 'content',
                type: 'string'
            },
            {
                dateFormat: 'Y-m-d H:i:s',
                name: 'modified',
                type: 'date'
            }
        ]
    }
});</pre></div><p>You can see a full list of all the data available by going to the API URL for your WordPress <a id="id795" class="indexterm"/>site (<a class="ulink" href="http://yourWordPressSite.com/api/get_page_index/?dev=1">http://yourWordPressSite.com/api/get_page_index/?dev=1</a>). The <code class="literal">dev1</code> argument will format the JSON response and make it more readable.</p><p>Now that we have our stores <a id="id796" class="indexterm"/>
<a id="id797" class="indexterm"/>and models, we can work on our views for displaying the data.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec91"/>Creating the views</h2></div></div></div><p>Since we will be sharing the list <a id="id798" class="indexterm"/>views for our post and pages between our two profiles, let's start there. We will be using a data view instead of a list view, as this provides us with a few more display options than a simple list.</p><p>Our <code class="literal">PostList.js</code> file looks like this:</p><div><pre class="programlisting">Ext.define('Evolver.view.PostList', {
    extend: 'Ext.dataview.DataView',
    alias: 'widget.postlist',
    title: 'Posts',
    id: 'postList',
    config: {
        store: 'postStore',
        itemTpl: [
            '&lt;div class="postItem"&gt;',
            '    &lt;div class="postTitle"&gt;{title}&lt;/div&gt;',
            '    &lt;div class="postMeta"&gt;&lt;span class="postAuthor"&gt;{author}&lt;/span&gt; - &lt;span class="postDate"&gt;{[Ext.util.Format.date(values.pubDate, "m/d/Y")]}&lt;/span&gt;&lt;/div&gt;',
            '&lt;/div&gt;'
        ]
    }
});</pre></div><p>Much like our standard list, <code class="literal">DataView</code> takes a data store and displays the items in order from the store. However, <code class="literal">DataView</code> is more flexible from a styling point of view, allowing the creation of tiled lists and other more interesting layouts.</p><p>This view reads from <code class="literal">postStore</code> and uses <code class="literal">itemTpl</code> to display the title, author, and date from each post. Each of our data items is styled with a particular class, which means we can display them in different ways depending on which stylesheet we load, or even turn them off completely. We will <a id="id799" class="indexterm"/>talk about these kinds of conditional stylesheets towards the end of the chapter.</p><p>Our <code class="literal">PageList</code> view follows a similar structure:</p><div><pre class="programlisting">Ext.define('Evolver.view.PageList', {
    extend: 'Ext.dataview.DataView',
    alias: 'widget.pagelist',
    title: 'Pages',
    config: {
        store: 'pageStore',
        itemTpl: [
            '&lt;div class="pageItem"&gt;',
            '    &lt;div class="pageTitle"&gt;{title}&lt;/div&gt;',
            '    &lt;div class="pageMeta"&gt;Updated &lt;span class="pageDate"&gt;{[Ext.util.Format.date(values.modified, "m/d/Y")]}&lt;/span&gt;&lt;/div&gt;',
            '&lt;/div&gt;'
        ]
    }

});</pre></div><p>This shared view reads from our <code class="literal">pageStore</code> and displays just the title and date. As noted, you can add any of the other data generated by the WordPress JSON API, and then use a conditional stylesheet to show it or hide it, based on the device the user is viewing from.</p><p>Our other views will be unique to either the phone or tablet profile. For the purposes of this chapter, each of the views are <a id="id800" class="indexterm"/>similar, each is a simple container with a template to format the record for display. Let's start with our phone details container.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec16"/>Creating the phone details view</h3></div></div></div><p>Since this details container is <a id="id801" class="indexterm"/>part of our phone profile, it is <a id="id802" class="indexterm"/>named <code class="literal">Evolver.view.phone.PageDetails</code> and it will be in the <code class="literal">app/view/phone/</code> folder.</p><div><pre class="programlisting">Ext.define('Evolver.view.phone.PageDetails', {
    extend: 'Ext.Container',
    alias: 'widget.pagedetails', 
    config: {
    layout: 'fit',
    scrollable: {direction: 'vertical', directionLock: true},
    tpl: [
     '&lt;div class="pageDetails"&gt;',
     '    &lt;div class="pageTitle"&gt;{title}&lt;/div&gt;',
     '    &lt;div class="pageMeta"&gt;&lt;span class="pageAuthor"&gt;{author}&lt;/span&gt; &lt;span class="pageDate"&gt;{updated}&lt;/span&gt;&lt;/div&gt;',
     '    &lt;div class="pageContent"&gt;{content}&lt;/div&gt;',
     '&lt;/div&gt;'
     ]
    }
});</pre></div><p>We also set a configuration for <code class="literal">scrollable</code> in this view. Since we are in a navigation view, which can be triggered with a swipe, we set the direction and direction lock to keep the swipe from triggering a page change.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec17"/>Creating the tablet details view</h3></div></div></div><p>The tablet version of <a id="id803" class="indexterm"/>
<a id="id804" class="indexterm"/>our <code class="literal">PageDetails.js</code> view looks like this:</p><div><pre class="programlisting">Ext.define('Evolver.view.tablet.PageDetails', {
 extend: 'Ext.Container',
 alias: 'widget.pagedetails',
 config: {
  tpl: [
   '&lt;div class="pageDetails"&gt;',
   '&lt;div class="pageTitle"&gt;{title}&lt;/div&gt;',
   '&lt;div class="pageMeta"&gt;&lt;span class="pageAuthor"&gt;{author}&lt;/span&gt; &lt;span class="pageDate"&gt;{updated}&lt;/span&gt;&lt;/div&gt;',
   '&lt;div class="pageContent"&gt;{content}&lt;/div&gt;',
   '&lt;div class="pageContent"&gt;&lt;a href="{url}"&gt;View Original Page&lt;/a&gt;&lt;/div&gt;',
   '&lt;/div&gt;'
  ]
 }
});</pre></div><p>The only differences between the two are the name (<code class="literal">Evolver.view.tablet.PageDetails</code>) and the URL for the page which we include at the bottom of <code class="literal">tpl</code>. While a <strong>View Original Page</strong> link is common in most tablet-based apps, it's not really needed for a phone app since we are trying to avoid the original site in the first place.</p><p>We will be handling the scrolling differently in the tablet version, so we do not include a <code class="literal">scrollable</code> configuration here.</p><p>As previously noted, you could make these two containers as different as you want. You could make one of them a panel and the other a container if you prefer. Since only one of them will actually be included, we can even <a id="id805" class="indexterm"/>keep the same value for our <code class="literal">alias</code> attribute of <code class="literal">widget.pageDetails</code>. There <a id="id806" class="indexterm"/>will not be an <code class="literal">xtype</code> conflict because only the phone version or the tablet version will ever be active at one time.</p><p>Our <code class="literal">postDetails</code> object for phone and tablet follow the same format, so we won't bother covering them here. You can see them in the sample code for the chapter. Just remember that the phone versions go in <code class="literal">app/view/phone</code> and the tablet versions go in <code class="literal">app/view/tablet</code>. Also, the view naming conventions will follow the format of <code class="literal">Evolver.view.phone.viewName</code> and <code class="literal">Evolver.view.tablet.viewName</code>.</p><p>Now, we need to put the individual pieces together into a main container for each of our profiles.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec92"/>The main views</h2></div></div></div><p>From our original sketches, we have <a id="id807" class="indexterm"/>two different interfaces. The first one we will look at is the phone interface:</p><div><img src="img/8901OS_08_5.jpg" alt="The main views"/></div><p>Since a phone screen has limited size, we need to create a more compact and layered interface. This will allow us to <a id="id808" class="indexterm"/>display all of our data, while still providing the user with readable text.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec18"/>Creating the phone main view</h3></div></div></div><p>The phone <code class="literal">Main.js</code> interface will consist of a tab view with two DataViews (one for pages and one for posts). Each <a id="id809" class="indexterm"/>DataView is inside a navigation view. <a id="id810" class="indexterm"/>When we click an item in the DataView, the controller will pop our details container onto the navigation view, creating a back button automatically:</p><div><pre class="programlisting">Ext.define('Evolver.view.phone.Main', {
    extend: 'Ext.tab.Panel',
    alias: 'widget.phonemain',
    id: 'mainView',
    config: {
        tabBar: {
            docked: 'bottom'
        },
        items: [
            {
                xtype: 'navigationview',
                iconCls: 'quote_black2',
                iconMask: true,
                title: 'Posts',
                items: [
                  {xtype: 'postlist', title: 'Posts List'}
                ]
            },
            {
                xtype: 'navigationview',
                title: 'Pages',
                iconCls: 'info',
                iconMask: true,
                items: [
                  {xtype: 'pagelist', title: 'Pages List'}
                ]
            }
        ]
    }

});</pre></div><p>We give this view an <code class="literal">id</code> value of <code class="literal">mainView</code> to make it easy to address within our controller. You will notice that the navigation views have a <code class="literal">title</code> configuration, and the DataView inside each navigation view has its own <code class="literal">title</code> configuration as well.</p><p>The two navigation views are direct <a id="id811" class="indexterm"/>children of the overall tab panel. This means that the title on the tabs at the bottom of our main tab panel will <a id="id812" class="indexterm"/>use this title. The DataViews inside the navigation views each have a title bar component, which will display the title for each DataView at the top.</p><p>By using a two-list strategy with the navigation view for popping on the details, we make the best use of our limited phone screen area. With our tablet profile, we have a bit more room to work with, so we can take a different approach.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec19"/>Creating the tablet main view</h3></div></div></div><p>Since we have additional room <a id="id813" class="indexterm"/>available on a tablet-sized screen, <a id="id814" class="indexterm"/>we can use a different view to take advantage of the extra space:</p><div><img src="img/8901OS_08_6.jpg" alt="Creating the tablet main view"/></div><p>Our tablet <code class="literal">Main.js</code> view has the two DataViews in a tab panel much like our phone profile version. However, the tablet version keeps a visible main content area where we can display the currently <a id="id815" class="indexterm"/>selected item. We also include an area above <a id="id816" class="indexterm"/>the content where we can place the website logo using the following code:</p><div><pre class="programlisting">Ext.define('Evolver.view.tablet.Main', {
 extend: 'Ext.Panel',
 id: 'mainView',
 config: {
  layout: 'fit',
  items: [
   {
    xtype: 'tabpanel',
    width: 200,
    docked: 'left',
    items: [
     {
      xtype: 'pagelist',
      title: 'Pages'
     },
     {
      xtype: 'postlist',
      title: 'Posts'
     }
    ]
   },
   {
    xtype: 'container',
    layout: 'vbox',
    scrollable: true,
    items: [
     {
      xtype: 'container',
      layout: 'fit',
      id: 'banner',
      height: 140,
      html: '&lt;img src="img/sb_logo.png"&gt;'
     },
     {
      xtype: 'pagedetails'
     },
     {
      xtype: 'postdetails',
      hidden: true
     }
    ]
   }
  ]
 }
});</pre></div><p>We start by extending the basic <code class="literal">Ext.Panel</code> component and giving it a <code class="literal">fit</code> layout. Inside this panel are a tab panel and two containers.</p><p>The <code class="literal">tabpanel</code> component <a id="id817" class="indexterm"/>contains our two DataViews (pages and posts), just as we had them in the phone version of the application. <a id="id818" class="indexterm"/>We set this up to have a <code class="literal">width</code> value of <code class="literal">200</code>.</p><p>The content container is set <a id="id819" class="indexterm"/>to a <code class="literal">vbox</code> layout with three child containers. The top container for our logo will have a <code class="literal">height</code> value of <code class="literal">140</code> and an HTML link to the logo from our WordPress site. The <code class="literal">vbox</code> layout means that our other containers, with our content for posts and pages, will automatically resize to fit the rest of the available space.</p><p>Notice that our <code class="literal">postdetails</code> container is hidden by default and the page details are visible. We will swap these two <a id="id820" class="indexterm"/>containers based on which DataView is selected in our controller.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec93"/>Creating the controllers</h2></div></div></div><p>The Evolver application <a id="id821" class="indexterm"/>uses a pair of DataViews (one for posts and one for pages), which are shared between both the phone and tablet profiles. In the case of the phone profile, the DataView needs to listen for the tap event and add a new details component to the navigation container. In the case of the tablet profile, the DataView is still listening for the tap event, but it needs to swap the two details containers based on which the DataView is selected.</p><p>By isolating the functionality from the display logic, we can make a single DataView perform two different actions (one in the phone version and another in the tablet version). We start this out in both our <code class="literal">phone.js</code> and <code class="literal">main.js</code> controllers, and our <code class="literal">tablet.js</code> and <code class="literal">main.js</code> controllers like so:</p><div><pre class="programlisting">Ext.define('Evolver.controller.phone.Main', {
 extend: 'Ext.app.Controller',
 config: {
  refs: {
   postList: '#postList',
   pageList: '#pageList',
   mainView: '#mainView'
  },

  control: {
   postList: {
    itemtap: 'onListItemTap'
   },
   pageList: {
    itemtap: 'onListItemTap'
   }
  }
 }
});</pre></div><p>The phone profile version is shown here, but at this point the tablet version is actually the same, just named <code class="literal">Evolver.controller.tablet.Main</code>.</p><p>Our references set up our short hand pointers to our components. Since <code class="literal">postList</code> and <code class="literal">pageList</code> are the same for both applications, and we consistently named our main container for both profiles, the references are the same in both controllers.</p><p>We also use the same code for our <code class="literal">control</code> configurations, where both lists need to listen for the <code class="literal">itemTap</code> event to trigger our function. To make our lives easier, we also make the DataViews trigger the same function called <code class="literal">onListItemTap</code>. We can decide what needs to happen based on which list got tapped.</p><p>Here is where our two <a id="id822" class="indexterm"/>controllers diverge. Let's start with the phone version of the <code class="literal">onListItemTap</code> function:</p><div><pre class="programlisting">onListItemTap: function(dataview, index, target, record) {
 var original = record.get('content');
 var converted = original.replace(/src=\"/g, 'src=\"http://src.sencha.io/120/');
 var final = converted.replace(/((width|height)\s*=\s*"*\d+"*)/g, '');
 record.set('content', final);
 if(dataview.id == 'postList') {
  var details = Ext.create(
   'Evolver.view.phone.PostDetails', {
    title: record.get('title'),
    data: record.data
  });
 } else {
  var details = Ext.create(
   'Evolver.view.phone.PageDetails', {
    title: record.get('title'),
    data: record.data
  });
 }
 this.getMainView().getActiveItem().push(details);
}</pre></div><p>We do some interesting manipulations with the first part of this function to modify our content to display better on a phone-sized screen. Since the content coming back to us has full-sized images, it will often take up a huge amount of space on a phone-sized screen, making the layout kind of crummy.</p><p>To solve this problem, we first grab the content out of the record with this:</p><div><pre class="programlisting">var original = record.get('content');</pre></div><p>Next, we make two passes through the content to find and replace some of the image information so that we can manipulate the sizes the way we want. The first pass looks like this:</p><div><pre class="programlisting">var converted = original.replace(/src=\"/g, 'src=\"http://src.sencha.io/120/');</pre></div><p>This will take an image tag with a <code class="literal">src</code> link that looks like <a class="ulink" href="http://mydomain.com/images/image15.png">http://mydomain.com/images/image15.png</a> and turn it into <code class="literal">http://src.sencha.io/120/http://mydomain.com/images/image15.png</code>.</p><p>This format will grab the image and run it through <code class="literal">src.sencha.io</code> for processing before it is displayed. The value of 120 indicates that the image will be automatically resized to a maximum width of 120 pixels or about half the size of a typical phone screen.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>
<strong>src.sencha.io</strong>
</p><p>src.sencha.io can be used to resize any image on the fly. There are a number of useful features to this service and more information can be found here at <a class="ulink" href="http://docs.sencha.io/current/index.html#!/guide/src">http://docs.sencha.io/current/index.html#!/guide/src</a>.</p></div></div><p>The third and final transformation removes the original height and width configurations from the <code class="literal">&lt;img&gt;</code> tags using a regular expression to match and remove the values. By default, WordPress will insert <code class="literal">height</code> and <code class="literal">width</code> tags when an image is included as part of a post or a page:</p><div><pre class="programlisting">var final = converted.replace(/((width|height)\s*=\s*"*\d+"*)/g, '');</pre></div><p>If we just used our first bit <a id="id823" class="indexterm"/>of code to resize the actual image without removing the height and width configurations, the image will actually appear at the original size, just pixelated and ugly looking.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>
<strong>Regular expressions</strong>
</p><p>Regular Expressions, or <strong>Regexes</strong>, <a id="id824" class="indexterm"/>are an incredibly valuable tool for matching patterns in strings. You can find out more information on Regexes at <a class="ulink" href="http://www.rexv.org/">http://www.rexv.org/</a>.</p></div></div><p>Once, we have done all of our conversions, we set the content value of our record to our new and improved value:</p><div><pre class="programlisting">record.set('content', final);</pre></div><p>With the conversion out of the way, we need to figure out which details container we need. Fortunately, we are passed the view that was clicked as part of our <code class="literal">itemTap</code> handler. We can use this to check to see which DataView is active:</p><div><pre class="programlisting">if(dataview.id == 'postList') {
  var details = Ext.create(
   'Evolver.view.phone.PostDetails', {
    title: record.get('title'),
    data: record.data
  });
 } else {
  var details = Ext.create(
   'Evolver.view.phone.PageDetails', {
    title: record.get('title'),
    data: record.data
  });
 }</pre></div><p>If we have <a id="id825" class="indexterm"/>
<code class="literal">postList</code>, we need to create a new post details container, and if not, we want to create a new page details container. Once we have the new container, we push it onto the active item with this code:</p><div><pre class="programlisting">this.getMainView().getActiveItem().push(details);</pre></div><p>We use <code class="literal">this.getMainView()</code> to grab our main view using the reference we created earlier. By using <code class="literal">getActiveItem()</code>, we are assured of getting the DataView the user is looking at and pushing the container onto the correct navigation view.</p><p>That's all there is to the <a id="id826" class="indexterm"/>phone profile's <code class="literal">Main.js</code> controller file. The tablet version of the <code class="literal">Main.js</code> controller is exactly the same except for the <a id="id827" class="indexterm"/>
<code class="literal">onListItemTap()</code> function, which looks like this:</p><div><pre class="programlisting">onListItemTap: function(dataview, index, target, record, e, options) {
 var original = record.get('content');
 var converted = original.replace(/src=\"/g, 'src=\"http://src.sencha.io/240/');
 var final = converted.replace(/((width|height)\s*=\s*"*\d+"*)/g, '');
 record.set('content', final);
 var pageDetails = this.getMainView().down('pagedetails');
 var postDetails = this.getMainView().down('postdetails');
 if(dataview.id == 'pageList') {
  postDetails.hide();
  pageDetails.setRecord(record)
  pageDetails.show();
 } else {
  pageDetails.hide();
  postDetails.setRecord(record)
  postDetails.show();
 }
}</pre></div><p>In this function we do our conversion the way we did before in the phone version. This time we increase the maximum width to 240 pixels.</p><p>Next, we grab our two details containers with the following:</p><div><pre class="programlisting"> var pageDetails = this.getMainView().down('pagedetails');
 var postDetails = this.getMainView().down('postdetails');</pre></div><p>Once we have those, we use the <code class="literal">dataview id</code> just as we did before to get the currently active DataView. We then hide one and show the other after adding our record to it for display.</p><p>As you can see from the two controllers, we can completely dictate the functions in the application, regardless of whether or not the view itself is shared between profiles. Combined with the ability to include different views based on a particular profile, we can easily target the application to a particular platform's strengths and overcome any potential weaknesses.</p><p>However, as powerful as this is, there is still one other trick we can use to further customize our application based on platform or device, that is, conditional styling.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Conditional styling</h1></div></div></div><p>You should be familiar with the use of CSS stylesheets to control the look of elements of your web page based on <code class="literal">id</code> or <code class="literal">class</code>. Since these can be applied to Sencha components and within xTemplates, we can use these classes and IDs to control the look of our application as well. We do this by checking the device's width using a media query.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec94"/>Media queries</h2></div></div></div><p>Media queries are actually a <a id="id828" class="indexterm"/>part of the CSS standards and not a direct part of Sencha Touch. However, since Sencha Touch uses CSS, we can inherit this tool and use it as an easy way to make decisions based on the environment that the web page is being displayed in. While this functionality has been around for quite some time, it was not standard across all web browsers until recently. Fortunately for us, Sencha Touch is only supported on modern web browsers, so the late adoption of the standard does not affect us.</p><p>If you have used a lot of CSS in the past few years, you may have noticed the use of media in stylesheet links like this:</p><div><pre class="programlisting">&lt;link rel="stylesheet" type="text/css" href="main.css" media="screen" /&gt;
&lt;link rel="stylesheet" type="text/css" href="print.css" media="print" /&gt;</pre></div><p>This setup would use <code class="literal">main.css</code> for displaying in the browser and <code class="literal">print.css</code> when printing the page out to a printer. This was typically used to remove navigation and extraneous page elements during printing.</p><p>However, these same media queries can be used to include stylesheets based on the screen size like so:</p><div><pre class="programlisting">&lt;link rel="stylesheet" type="text/css" media="screen and (max-device-width: 480px)" href="iPhone.css" /&gt;</pre></div><p>This media query will load the stylesheet if the device is using a web browser (screen) with a maximum screen width of 480px (like an iPhone 3G).</p><p>We can even take this a step further and change the stylesheet based on the orientation:</p><div><pre class="programlisting">&lt;link rel="stylesheet" type="text/css" media="screen and (max-device-width: 480px) and (orientation:portrait" href="iPhonePortrait.css" /&gt;
&lt;link rel="stylesheet" type="text/css" media="screen and (max-device-width: 480px) and (orientation:landscape" href="iPhoneLandscape.css" /&gt;</pre></div><p>These two links will include <code class="literal">iPhonePortrait.css</code> when the iPhone is held in portrait orientation and <code class="literal">iPhoneLandscape.css</code> when held in landscape orientation.</p><p>Combining these CSS <a id="id829" class="indexterm"/>media queries with Sencha Touch's profiles allows us to target a particular device at a very granular level.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Summary</h1></div></div></div><p>When designing applications for a mobile environment, it is extremely important to take advantage of any special features of the device and avoid any potential shortfalls the device may have. By tailoring an application directly to the device, you provide a better overall user experience. In this chapter, we showed you how to make the most of this ability by covering the following points:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basics and usage of profiles</li><li class="listitem" style="list-style-type: disc">Setting up WordPress to work with Sencha Touch</li><li class="listitem" style="list-style-type: disc">Creating the basic Evolver application</li><li class="listitem" style="list-style-type: disc">Setting up the controllers to manage functionality on both phone and tablet devices</li><li class="listitem" style="list-style-type: disc">Using media queries to further style your applications for a particular device</li></ul></div><p>In the next chapter we will take a look how to access some of the hardware capabilities of your device, specifically the camera. We also show you how to compile your application to take advantage of more of your device's features.</p></div></body></html>