- en: Chapter 4. Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While creational patterns play the part of flexibly creating objects, structural
    patterns, on the other hand, are patterns about composing objects. In this chapter,
    we are going to talk about structural patterns that fit different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: If we take a closer look at structural patterns, they can be divided into *structural
    class patterns* and *structural object patterns*. Structural class patterns are
    patterns that play with "interested parties" themselves, while structural object
    patterns are patterns that weave pieces together (like Composite Pattern). These
    two kinds of structural patterns complement each other to some degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the patterns we''ll walk through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composite**: Builds tree-like structures using primitive and composite objects.
    A good example would be the DOM tree that forms a complete page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: Adds functionality to classes or objects dynamically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adapter**: Provides a general interface and work with different adaptees
    by implementing different concrete adapters. Consider providing different database
    choices for a single content management system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge**: Decouples the abstraction from its implementation, and make both
    of them interchangeable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Façade**: Provides a simplified interface for the combination of complex
    subsystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flyweight**: Shares stateless objects that are being used many times to improve
    memory efficiency and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: Acts as the surrogate that takes extra responsibilities when accessing
    objects it manages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects under the same class could vary from their properties or even specific
    subclasses, but a complex object can have more than just normal properties. Taking
    DOM elements, for example, all the elements are instances of class `Node`. These
    nodes form tree structures to represent different pages, but every node in these
    trees is complete and uniform compared to the node at the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding HTML represents a DOM structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composite Pattern](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All of the preceding objects are instances of `Node`, they implement the interface
    of a *component* in Composite Pattern. Some of these nodes like HTML elements
    (except for `HTMLImageElement`) in this example have child nodes (components)
    while others don't.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Composite Pattern implementation include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component**: `Node`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface and implement the default behavior for objects of the
    composite. It should also include an interface to access and manage the child
    components of an instance, and optionally a reference to its parent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Composite**: Includes some HTML elements, like `HTMLHeadElement` and `HTMLBodyElement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores child components and implements related operations, and of course its
    own behaviors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Leaf**: `TextNode`, `HTMLImageElement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines behaviors of a primitive component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulates the composite and its components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composite Pattern applies when objects can and should be abstracted recursively
    as components that form tree structures. Usually, it would be a natural choice
    when a certain structure needs to be formed as a tree, such as trees of view components,
    abstract syntax trees, or trees that represent file structures.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a composite that represents simple file structures and
    has limited kinds of components.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s import related node modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Module `path` and `fs` are built-in modules of Node.js, please refer to Node.js
    documentation for more information: [https://nodejs.org/api/](https://nodejs.org/api/).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is my personal preference to have the first letter of a namespace (if it's
    not a function at the same time) in uppercase, which reduces the chance of conflicts
    with local variables. But a more popular naming style for namespace in JavaScript
    does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make abstraction of the components, say `FileSystemObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are using `abstract class` because we are not expecting to use `FileSystemObject`
    directly. An optional `parent` property is defined to allow us to visit the upper
    component of a specific object. And the `basename` property is added as a helper
    for getting the basename of the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileSystemObject` is expected to have subclasses, `FolderObject` and `FileObject`.
    For `FolderObject`, which is a composite that may contain other folders and files,
    we are going to add an `items` property (getter) that returns other `FileSystemObject`
    it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can initialize the `items` property in the `constructor` with actual files
    and folders existing at given `path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed we are forming `items` with different kinds of objects,
    and we are also passing `this` as the `parent` of newly created child components.
  prefs: []
  type: TYPE_NORMAL
- en: 'And for `FileObject`, we''ll add a simple `readAll` method that reads all bytes
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Currently, we are reading the child items inside a folder from the actual filesystem
    when a folder object gets initiated. This might not be necessary if we want to
    access this structure on demand. We may actually create a getter that calls `readdir`
    only when it's accessed, thus the object would act like a proxy to the real filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the primitive object and composite object in Composite Pattern share the
    component interface, which makes it easy for developers to build a composite structure
    with fewer things to remember.
  prefs: []
  type: TYPE_NORMAL
- en: It also enables the possibility of using markup languages like XML and HTML
    to represent a really complex object with extreme flexibility. Composite Pattern
    can also make the rendering easier by having components rendered recursively.
  prefs: []
  type: TYPE_NORMAL
- en: As most components are compatible with having child components or being child
    components of their parents themselves, we can easily create new components that
    work great with existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorator Pattern adds new functionality to an object dynamically, usually without
    compromising the original features. The word decorator in Decorator Pattern does
    share something with the word decorator in the ES-next decorator syntax, but they
    are not exactly the same. Classical Decorator Pattern as a phrase would differ
    even more.
  prefs: []
  type: TYPE_NORMAL
- en: The classical Decorator Pattern works with a composite, and the brief idea is
    to create decorators as components that do the decorating work. As composite objects
    are usually processed recursively, the decorator components would get processed
    automatically. So it becomes your choice to decide what it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inheritance hierarchy could be like the following structure shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorator Pattern](img/image_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The decorators are applied recursively like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorator Pattern](img/image_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two prerequisites for the decorators to work correctly: the awareness
    of context or object that a decorator is decorating, and the ability of the decorators
    being applied. The Composite Pattern can easily create structures that satisfy
    those two prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator knows what it decorates as the `component` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator gets applied when it is rendered recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it doesn't really need to take a structure like a composite to gain
    the benefits from Decorator Pattern in JavaScript. As JavaScript is a dynamic
    language, if you can get your decorators called, you may add whatever you want
    to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking method `log` under `console` object as an example, if we want a timestamp
    before every log, we can simply replace the `log` function with a wrapper that
    has the timestamp prefixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Certainly, this example has little to do with the classical Decorator Pattern,
    but it enables a different way for this pattern to be done in JavaScript. Especially
    with the help of new decorator syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TypeScript provides the decorator syntax transformation as an experimental
    feature. To learn more about decorator syntax, please check out the following
    link: [http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of classical Decorator Pattern implementation include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component**: `UIComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of the objects that can be decorated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**ConcreteComponent**: `TextComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines additional functionalities of the concrete component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Decorator**: `Decorator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines a reference to the component to be decorated, and manages the context.
    Conforms the interface of a component with proper behaviors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**ConcreteDecorator**: `ColorDecorator`, `FontDecorator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines additional features and exposes API if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decorator Pattern usually cares about objects, but as JavaScript is prototype-based,
    decorators would work well with the classes of objects through their prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: The classical implementation of Decorator Pattern could have much in common
    with other patterns we are going to talk about later, while the function one seems
    to share less.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part, we'll talk about two implementations of Decorator Pattern. The
    first one would be classical Decorator Pattern that decorates the target by wrapping
    with new classes that conform to the interface of `UIComponent`. The second one
    would be decorators written in new decorator syntax that processes target objects.
  prefs: []
  type: TYPE_NORMAL
- en: Classical decorators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s get started by defining the outline of objects to be decorated. First,
    we''ll have the `UIComponent` as an abstract class, defining its abstract function
    `draw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a `TextComponent` that extends the  `UIComponent`, as well as its text
    contents of class `Text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s next is to define the interface of decorators to decorate objects that
    are instances of class `TextComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have everything for concrete decorators. In this example, `ColorDecorator`
    and `FontDecorator` look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the implementation just described, `this.texts` in `draw` method calls the
    getter defined on class `Decorator`. As this in that context would ideally be
    an instance of class `ColorDecorator` or `FontDecorator`; the `texts` it accesses
    would finally be the array in its `component` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This could be even more interesting or confusing if we have nested decorators
    like we will soon. Try to draw a schematic diagram if it confuses you later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to actually assemble them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The order of nesting decorators does not matter in this example. As either `ColorDecorator`
    or `FontDecorator` is a valid `UIComponent`, they can be easily dropped in and
    replace previous `TextComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators with ES-next syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a limitation with classical Decorator Pattern that can be pointed
    out directly via its nesting form of decorating. That applies to ES-next decorators
    as well. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What follows the `@` character is an expression that evaluates to a decorator.
    While a decorator is a function that processes target objects, we usually use
    higher-order functions to parameterize a decorator.
  prefs: []
  type: TYPE_NORMAL
- en: We now have two decorators `prefix` and `suffix` decorating the `getContent`
    method. It seems that they are just parallel at first glance, but if we are going
    to add a prefix and suffix onto the content returned, like what the name suggests,
    the procedure would actually be recursive rather than parallel just like the classical
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make decorators cooperate with others as we''d expect, we need to handle
    things carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In current ECMAScript decorator proposal, when decorating a method or property
    (usually with getter or setter), you will have the third argument passed in as
    the property descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out the following link for more information about property descriptors:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).'
  prefs: []
  type: TYPE_NORMAL
- en: The `suffix` decorator would be just like the `prefix` decorator. So I'll save
    the code lines here.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to the Decorator Pattern is being able to add functionalities dynamically,
    and decorators are usually expected to play nice with each other. Those expectations
    of Decorator Pattern make it really flexible to form a customized object. However,
    it would be hard for certain types of decorators to actually work well together.
  prefs: []
  type: TYPE_NORMAL
- en: Consider decorating an object with multiple decorators just like the second
    example of implementation, would the decorating order matter? Or should the decorating
    order matter?
  prefs: []
  type: TYPE_NORMAL
- en: A properly written decorator should always work no matter where it is in the
    decorators list. And it's usually *preferred* that the decorated target behaves
    almost the same with decorators decorated in different orders.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adapter Pattern connects existing classes or objects with another existing client.
    It makes classes that are not designed to work together possible to cooperate
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: An adapter could be either a *class* adapter or an *object* adapter. A class
    adapter extends the adaptee class and exposes extra APIs that would work with
    the client. An object adapter, on the other hand, does not extend the adaptee
    class. Instead, it stores the adaptee as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class adapter is useful when you need to access protected methods or properties
    of the adaptee class. However, it also has some restrictions when it comes to
    the JavaScript world:'
  prefs: []
  type: TYPE_NORMAL
- en: The adaptee class needs to be extendable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the client target is an abstract class other than pure interface, you can't
    extend the adaptee class and the client target with the same adapter class without
    a *mixin*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single class with two sets of methods and properties could be confusing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to those limitations, we are going to talk more about object adapters.
    Taking browser-side storage for example, we''ll assume we have a client working
    with storage objects that have both methods `get` and `set` with correct signatures
    (for example, a storage that stores data online through AJAX). Now we want the
    client to work with IndexedDB for faster response and offline usage; we''ll need
    to create an adapter for IndexedDB that gets and sets data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter Pattern](img/image_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are going to use Promise for receiving results or errors of asynchronous
    operations. See the following link for more information if you are not yet familiar
    with Promise: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Adapter Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target: **`Storage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of existing targets that works with client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Adaptee**: `IndexedDB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation that is not designed to work with the client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Adapter**: `IndexedDBStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conforms the interface of target and interacts with adaptee
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulates the target
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adapter Pattern can be applied when the existing client class is not designed
    to work with the existing adaptees. It focuses on the unique *adapter* part when
    applying to different combinations of clients and adaptees.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start with the `Storage` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We defined the `get` method with generic, so that if we neither specify the
    generic type, nor cast the value type of a returned Promise, the type of the value
    would be `{}`. This would probably fail following type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of examples found on MDN, we can now set up the IndexedDB adapter.
    Visit  `IndexedDBStorage`: [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB).'
  prefs: []
  type: TYPE_NORMAL
- en: The creation of IndexedDB instances is asynchronous. We could put the opening
    operation inside a `get` or `set` method so the database can be opened on demand.
    But for now, let's make it easier by creating an instance of `IndexedDBStorage`
    that has a database instance which is already opened.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, constructors usually don''t have asynchronous code. Even if they do,
    it cannot apply changes to the instance before completing the construction. Fortunately,
    Factory Method Pattern works well with asynchronous initiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the Promise resolver of method `open`, we''ll get the asynchronous work
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we are accessing an instance of `IndexedDBStorage`, we can assume
    it has an opened database and is ready to make queries. To make changes or to
    get values from the database, we need to create a transaction. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Method `set` is similar. But while the transaction is by default read-only,
    we need to explicitly specify `'readwrite'` mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And now we can have a drop-in replacement for the previous storage used by the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By applying Adapter Pattern, we can fill the gap between classes that originally
    would not work together. In this situation, Adapter Pattern is quite a straightforward
    solution that might come to mind.
  prefs: []
  type: TYPE_NORMAL
- en: But in other scenarios like a debugger *adapter* for debugging extensions of
    an IDE, the implementation of Adapter Pattern could be more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bridge Pattern decouples the abstraction manipulated by clients from functional
    implementations and makes it possible to add or replace these abstractions and
    implementations easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a set of *cross-API* UI elements as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridge Pattern](img/image_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have the abstraction `UIElement` that can access different implementations
    of `UIToolkit` for creating different UI based on either SVG or canvas. In the
    preceding structure, the *bridge* is the connection between `UIElement` and `UIToolkit`.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Bridge Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction: **`UIElement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of objects to be manipulated by the client and stores
    the reference to its implementer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Refined abstraction**: `TextElement`, `ImageElement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extends abstraction with specialized behaviors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Implementer**: `UIToolkit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of a general implementer that will eventually carry out
    the operations defined in abstractions. The implementer usually cares only about
    basic operations while the abstraction will handle high-level operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete implementer**: `SVGToolkit`, `CanvasToolkit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements the implementer interface and manipulates low-level APIs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although having abstraction and implementer decoupled provides Bridge Pattern
    with the ability to work with several abstractions and implementers, most of the
    time, bridge patterns work only with a single implementer.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a closer look, you will find Bridge Pattern is extremely similar
    to Adapter Pattern. However, while Adapter Pattern tries to make existing classes
    cooperate and focuses on the adapters part, Bridge Pattern foresees the divergences
    and provides a well-thought-out and universal interface for its abstractions that
    play the part of adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A working implementation could be non-trivial in the example we are talking
    about. But we can still sketch out the skeleton easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with implementer `UIToolkit` and abstraction `UIElement` that are directly
    related to the bridge concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can extend `UIElement` for refined abstractions with different behaviors.
    First the `TextElement`  class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `ImageElement`  class with similar code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating concrete `UIToolkit` subclasses, we can manage to make everything
    together with the client. But as it could lead to hard work we would not want
    to touch now, we''ll skip it by using a variable pointing to `undefined` in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the real world, the render part could also be a heavy lift. But as it's coded
    at a relatively higher-level, it tortures you in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite having completely different names for the abstraction (`UIElement`)
    in the example above and the adapter interface (`Storage`), they play similar
    roles in a static combination.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we mentioned in the pattern scope section, the intentions of Bridge
    Pattern and Adapter Pattern differ.
  prefs: []
  type: TYPE_NORMAL
- en: By decoupling the abstraction and implementer, Bridge Pattern brings great extensibility
    to the system. The client does not need to know about the implementation details,
    and this helps to build more stable systems as it forms a healthier dependency
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Another bonus that might be brought by Bridge Pattern is that, with a properly
    configured build process, it can reduce compilation time as the compiler does
    not need to know information on the other end of the bridge when changes are made
    to a refined abstraction or concrete implementer.
  prefs: []
  type: TYPE_NORMAL
- en: Façade Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Façade Pattern organizes subsystems and provides a unified higher-level
    interface. An example that might be familiar to you is a modular system. In JavaScript
    (and of course TypeScript), people use modules to organize code. A modular system
    makes projects easier to maintain, as a clean project structure can help reveal
    the interconnections among different parts of the project.
  prefs: []
  type: TYPE_NORMAL
- en: It is common that one project gets referenced by others, but obviously the project
    that references other projects doesn't and shouldn't care much about the inner
    structures of its dependencies. Thus a façade can be introduced for a dependency
    project to provide a higher-level API and expose what really matters to its dependents.
  prefs: []
  type: TYPE_NORMAL
- en: Take a robot as an example. People who build a robot and its components will
    need to control every part separately and let them cooperate at the same time.
    However, people who want to use this robot would only need to send simple commands
    like "walk" and "jump".
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most flexible usage, the robot "SDK" can provide classes like `MotionController`,
    `FeedbackController`, `Thigh`, `Shank`, `Foot` and so on. Possibly like the following
    image shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Façade Pattern](img/image_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But certainly, most of the people who want to control or program this robot
    do not want to know as many details as this. What they really want is not a fancy
    tool box with *everything* inbox, but just an integral robot that follows their
    commands. Thus the robot "SDK" can actually provide a façade that controls the
    inner pieces and exposes much simpler APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Façade Pattern](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, Façade Pattern leaves us an open question of how to design the
    façade API and subsystems. Answering this question properly is not easy work.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of a Façade Pattern are relatively simple when it comes to
    their categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Façade**: `Robot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines a set of higher-level interfaces, and makes subsystems cooperate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Subsystems**: `MotionController`, `FeedbackController`, `Thigh`, `Shank`
    and `Foot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements their own functionalities and communicates internally with other
    subsystems if necessary. Subsystems are dependencies of a façade, and they do
    not depend on the façade.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Façades usually act as junctions that connect a higher-level system and its
    subsystems. The key to the Façade Pattern is to draw a line between what a dependent
    should or shouldn't care about of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider putting up a robot with its left and right legs, we can actually add
    another abstraction layer called `Leg` that manages `Thigh`, `Shank` , and `Foot`.
    If we are going to separate motion and feedback controllers to different legs
    respectively, we may also add those two as part of the `Leg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Before we add more details to `Leg`, let's first define `MotionController` and
    `FeedbackController` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MotionController` is supposed to control a whole leg based on a value
    or a set of values. Here we are simplifying that as a single angle for not being
    distracted by this impossible robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `FeedbackController` is supposed to be an instance of `EventEmitter`
    that reports the state changes or useful events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can make class `Leg` relatively complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put two legs together to sketch the skeleton of a robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I'm omitting the definition of classes `Thigh`, `Shank` , and `Foot` as we are
    not actually going to walk the robot. Now for a user that only wants to walk or
    jump a robot via simple API, they can make it via the `Robot` object that has
    everything connected.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Façade Pattern loosens the coupling between client and subsystems. Though it
    does not decouple them completely as you will probably still need to work with
    objects defined in subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: Façades usually forward operations from client to proper subsystems or even
    do heavy work to make them work together.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of Façade Pattern, the system and the relationship and structure
    within the system can stay clean and intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A flyweight in Flyweight Pattern is a stateless object that can be shared across
    objects or maybe classes many times. Obviously, that suggests Flyweight Pattern
    is a pattern about memory efficiency and maybe performance if the construction
    of objects is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Taking drawing snowflakes as an example. Despite real snowflakes being different
    to each other, when we are trying to draw them onto canvas, we usually have a
    limited number of styles. However, by adding *properties* like sizes and transformations,
    we can create a beautiful snow scene with limited snowflake styles.
  prefs: []
  type: TYPE_NORMAL
- en: As a flyweight is stateless, ideally it allows multiple operations simultaneously.
    You might need to be cautious when working with multi-thread stuff. Fortunately,
    JavaScript is usually single-threaded and avoids this issue if all related code
    is synchronous. You will still need to take care in detailed scenarios if your
    code is working asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have some flyweights of class `Snowflake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flyweight Pattern](img/image_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When it snows, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flyweight Pattern](img/image_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the image above, snowflakes in different styles are the result of rendering
    with different properties.
  prefs: []
  type: TYPE_NORMAL
- en: It's common that we would have styles and image resources being loaded dynamically,
    thus we could use a `FlyweightFactory` for creating and managing flyweight objects.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest implementation of Flyweight Pattern has the following participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '**F****lyweight**: `Snowflake`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the class of flyweight objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Flyweight factory**: `FlyweightFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates and manages flyweight objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores states of targets and uses flyweight objects to manipulate these targets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these participants, we assume that the manipulation could be accomplished
    through flyweights with different states. It would also be helpful sometimes to
    have `concrete flyweight` class allowing customized behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flyweight Pattern is a result of efforts to improving memory efficiency and
    performance. The implementation cares about having the instances being stateless,
    and it is usually the client that manages detailed states for different targets.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What makes Flyweight Pattern useful in the snowflake example is that a snowflake
    with the same style usually shares the same image. The image is what consumes
    time to load and occupies notable memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are starting with a fake `Image` class that pretends to load images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Snowflake` class in our example has only a single `image` property, and
    that is a property that will be shared by many snowflakes to be drawn. As the
    instance is now stateless, parameters from context are required for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The flyweights are managed by a factory for easier accessing. We''ll have a
    `SnowflakeFactory` that caches created snowflake objects with certain styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With building blocks ready, we''ll implement the client (`Sky`) that snows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to fill the sky with random snowflakes at random positions. Before
    that let''s create a helper function that generates a number between 0 and a max
    value given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And then complete method `snow` of `Sky`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now we may have thousands of snowflakes in the sky but with only three instances
    of `Snowflake` created. You can continue this example by storing the state of
    snowflakes and animating the snowing.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flyweight Pattern reduces the total number of objects involved in a system.
    As a direct result, it may save quite a lot memory. This saving becomes more significant
    when the flyweights get used by the client that processes a large number of targets.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight Pattern also brings extra logic into the system. When to use or not
    to use this pattern is again a balancing game between development efficiency and
    runtime efficiency from this point of view. Though most of the time, if there's
    not a good reason, we go with development efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Proxy Pattern applies when the program needs to know about or to intervene
    the behavior of accessing objects. There are several detailed scenarios in Proxy
    Pattern, and we can distinguish those scenarios by their different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote proxy**: A proxy with interface to manipulate remote objects, such
    as data items on a remote server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual proxy**: A proxy that manages expensive objects which need to be
    loaded on demand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection proxy**: A proxy that controls access to target objects, typically
    it verifies permissions and validates values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart proxy**: A proxy that does additional operations when accessing target
    objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the section of Adapter Pattern, we used factory method `open` that creates
    an object asynchronously. As a trade-off, we had to let the client wait before
    the object gets created.
  prefs: []
  type: TYPE_NORMAL
- en: With Proxy Pattern, we could now `open` database on demand and create storage
    instances synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxy Pattern](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A proxy is usually dedicated to object or objects with known methods and properties.
    But with the new `Proxy` API provided in ES6, we can get more interesting things
    done by getting to know what methods or properties are being accessed. Please
    refer to the following link for more information: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy).'
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Proxy Pattern include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proxy**: `IndexedDB``Storage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines interface and implements operations to manage access to the subject.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Subject**: `IndexedDB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subject to be accessed by proxy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client**: Accesses subject via proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite having a similar structure to Adapter Pattern, the key of Proxy Pattern
    is to intervene the access to target objects rather than to adapt an incompatible
    interface. Sometimes it might change the result of a specific method or the value
    of a certain property, but that is probably for falling back or exception  handling
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two differences we'll have in this implementation compared to the
    example for pure Adapter Pattern. First, we'll create the `IndexedDBStorage` instance
    with a constructor, and have the database opened on demand. Second, we are going
    to add a useless permission checking for methods `get` and `set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we call the method `get` or `set`, the database could either have
    been opened or not. Promise is a great choice for representing a value that might
    either be pending or settled. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s hard to tell whether Promise `ready` is fulfilled when the second timeout
    fires. But the overall behavior is easy to predict: it will log the `''biu~''` text
    in around 1 second. By replacing the Promise variable `ready` with a method or
    getter, it would be able to start the asynchronous operation only when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start the refactoring of class `IndexedDBStorage` with the getter
    that creates the Promise of the database to be opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now the first time we access property `dbReady`, it will open the database and
    create a Promise that will be fulfilled with the database being opened. To make
    this work with methods `get` and `set`, we just need to wrap what we've implemented
    into a `then` method following the `dbReady` Promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'First for method `get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And followed by updated method `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we finally have the `IndexedDBStorage` property that can do a real drop-in
    replacement for the client that supports the interface. We are also going to add
    simple permission checking with a plain object that describes the permission of
    read and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will add permission checking for method `get` and `set` separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You may recall Decorator Pattern when you are thinking about the permission
    checking part, and decorators could be used to simplify the lines written. Try
    to use decorator syntax to implement this permission checking yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of Proxy Pattern can usually be treated as the encapsulation
    of the operations to specific objects or targets. It is easy to have the encapsulation
    augmented without extra burden on the client.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a working online database proxy could do much more than just acting
    like a plain surrogate. It may cache data and changes locally, or synchronize
    on schedule without the client being aware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about structural design patterns including Composite,
    Decorator, Adapter, Bridge, Façade, Flyweight, and Proxy. Again we found some
    of these patterns are highly inter related and even similar to each other to some
    degree.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we mixed Composite Pattern with Decorator Pattern, Adapter Pattern
    with Proxy Pattern, compared Adapter Pattern and Bridge Pattern. During the journey
    of exploring, we sometimes found it was just a natural result to have our code
    end in a pattern that's similar to what we've listed if we took writing *better
    code* into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Taking Adapter Pattern and Bridge Pattern as an example, when we are trying
    to make two classes cooperate, it comes out with Adapter Pattern and when we are
    planning on connecting with different classes in advance, it goes with Bridge
    Pattern. There are no actual lines between each pattern and the applications of
    those patterns, though the techniques behind patterns could usually be useful.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about behavioral patterns that help
    to form algorithms and assign the responsibilities.
  prefs: []
  type: TYPE_NORMAL
