<html><head></head><body>
		<div><h1 id="_idParaDest-127" class="chapter-number"><a id="_idTextAnchor132"/>4</h1>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor133"/>Asynchronous Programming</h1>
			<p>This chapter will explain in detail how to use all the asynchronous mechanisms that JavaScript offers today, including how to convert callbacks to promises and perform bulk asynchronous operations.</p>
			<p>You will gain an in-depth understanding of all the tools at your disposal for managing both simple and complex asynchronous activities. We’ll begin with callbacks following Node.js Core conventions, then progress to effectively handling asynchronous operations using promises, and <code>async</code>/<code>await</code>. Toward the end of the chapter, we’ll employ the <strong class="bold">Immediately Invoked Function Expression (IIFE)</strong> pattern to execute asynchronous code. Additionally, we will provide a comprehensive overview of how to convert asynchronous operations between different handlers, including callbacks and promises.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>Asynchronous programming in JavaScript</li>
				<li>Understanding callbacks and how to avoid callback hell</li>
				<li>Mastering promises</li>
				<li>Using <code>async</code> and <code>await</code> for handling asynchronous code</li>
			</ul>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor134"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/FHzqWr4dK7s">https://youtu.be/FHzqWr4dK7s</a></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor135"/>Asynchronous programming in JavaScript</h1>
			<p>In JavaScript, asynchronous programming is <a id="_idIndexMarker233"/>a fundamental part of the<a id="_idIndexMarker234"/> language. It is the mechanism that allows us to perform operations in the background, without blocking the execution of the main thread. This is especially important in the browser, where the main thread is responsible for updating the user interface and responding to user actions.</p>
			<p>Overall, asynchronous programming is a complex topic that requires a lot of practice to master, but in my opinion, it <a id="_idIndexMarker235"/>requires a change in your mindset. You will need to start thinking about how to break down your code into small chunks that can be executed in the background, and how to combine them to achieve the desired result. You’ll encounter asynchronous programming regularly while coding with JavaScript. Most operations involving interactions with external resources, such as sending and receiving data from a server or a database and reading the content from a file, will necessitate its use.</p>
			<p class="callout-heading">Previous knowledge</p>
			<p class="callout">In <a href="B21678_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> we introduced the concept of the event loop, which is the mechanism that allows JavaScript to be asynchronous. In this chapter, we will see how to use this mechanism to our advantage.</p>
			<p class="callout">In <a href="B21678_03.xhtml#_idTextAnchor056"><em class="italic">Chapter 3</em></a><em class="italic">, </em>we learned how to use JavaScript in detail; this chapter requires a solid knowledge of functions and arrays.</p>
			<p>Let’s begin by exploring how asynchronous programming differs from conventional programming and how we need to adopt a different mindset.</p>
			<p>This chapter uses isomorphic JavaScript snippets, so the code can be executed in Node.js or in the browser.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor136"/>The asynchronous mindset</h2>
			<p>The first step in mastering asynchronous <a id="_idIndexMarker236"/>programming is to change your mindset. You need to start thinking about your code in a non-linear way; you will think more about “what should happen next” rather than “what should happen first.”</p>
			<p>When we learned about functions in <a href="B21678_03.xhtml#_idTextAnchor056"><em class="italic">Chapter 3</em></a>, we saw that a function is <em class="italic">just</em> a piece of code that can be executed at any time. In this section, we will connect that piece of code to<a id="_idIndexMarker237"/> previous events, and to future events.</p>
			<p>There are many ways to perform asynchronous operations in JavaScript. In this chapter, we will focus on the most common ones, which are as follows:</p>
			<ul>
				<li><strong class="bold">Callbacks</strong>: A callback is a <a id="_idIndexMarker238"/>function that is passed as an argument to another function, and it is executed when a certain event happens. This is the most basic way to perform asynchronous operations in JavaScript, and it is the foundation of all the other mechanisms.</li>
				<li><strong class="bold">Promises</strong>: ES6 introduced the<a id="_idIndexMarker239"/> concept of promises, which you can use to handle asynchronous operations in an advanced way because they use a state machine with several states (pending, fulfilled, and rejected) to keep track of operations. Promises have many advantages over callbacks in terms of readability, reusability, and overall simplicity. This is the most common way to perform asynchronous operations in modern JavaScript today. For more details, check out the <em class="italic">Mastering promises</em> section in this chapter.</li>
				<li><strong class="bold">Async/await</strong>: Async/await acts as a<a id="_idIndexMarker240"/> wrapper over promises to make code more <a id="_idIndexMarker241"/>readable (syntax sugar). Currently is the most popular way of handling asynchronous operations.</li>
			</ul>
			<p>In the next section, we will explore how we can use callbacks effectively in our applications, the error first pattern, and other good practices to follow. Later on, we will explore how to wrap callbacks inside promises.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor137"/>Understanding callbacks</h1>
			<p>Callbacks exploit JavaScript’s<a id="_idIndexMarker242"/> capability to pass functions. There are two essential parts to this technique:</p>
			<ul>
				<li>A function that is passed as an argument to another function</li>
				<li>The passed function is executed when a certain event happens</li>
			</ul>
			<p>Let’s create a basic example to illustrate this concept. In the following code snippets, we will show how the callback is defined as an argument and how a function is passed as an argument when the execution<a id="_idIndexMarker243"/> occurs:</p>
			<ol>
				<li>In this example, we will define a function (<code>doSomething</code>) that expects a function as an argument:<pre class="source-code">
const doSomething = (cb) =&gt; {
  console.log('Doing something...');
  cb();
};</pre></li>				<li>At this point, we have a function called <code>doSomething</code> that receives a function as an argument and executes it as the last step, this illustrates the idea that the callbacks are just a pattern where we expect that the next function to the executed is actually called as the final step (call me back when you are done - callback)  . Let’s see how we can use this function:<pre class="source-code">
const nextStep = () =&gt; {
  console.log('Callback called');
};
doSomething(nextStep);</pre></li>				<li>Once the function is executed, the expected output will be the following:<pre class="source-code">
<strong class="bold">Doing something...</strong>
<strong class="bold">Callback called</strong></pre></li>			</ol>
			<p>Now, we have a function called <code>nextStep</code> that is passed as an argument to <code>doSomething</code>. When <code>doSomething</code> is executed, it will print <code>Doing something...</code>, and then it will execute the function that was passed as an argument, which will print <code>Callback called</code> as the last step.</p>
			<p>It is important to note that the function that is passed as an argument is not executed immediately , as we only want to execute them when the operation is complete. On the other hand, the immediate execution will require the use of parentheses (<code>doSomething(nextStep())</code>) and will produce a different result and an error:</p>
			<pre class="source-code">
doSomething(nextStep())
// Callback called
// Doing something...
// Error: cb is not a function</pre>			<p>We can also pass an anonymous<a id="_idIndexMarker244"/> function as an argument. This is the most common way to use callbacks, as we don’t need to define the functions previously. In most cases, we don’t reuse that function later:</p>
			<pre class="source-code">
doSomething(() =&gt; {
    console.log('Callback called');
});</pre>			<p>It is also possible to pass a function that receives arguments:</p>
			<pre class="source-code">
const calculateNameLength = (name, cb) =&gt; {
  const length = name.length;
  cb(length);
};
calculateNameLength('John', (length) =&gt; {
  console.log(`The name length is ${length}`); // The name length is 4
});</pre>			<p>As you can see, the callback technique is very simple, but we haven’t seen any asynchronous operations yet. At the end of the day, we assume that a callback is literally a “call me back when you are done” approach. Now, let’s see how this can be used to manage asynchronous operations <a id="_idIndexMarker245"/>with timers and intervals.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor138"/>Timers and intervals</h2>
			<p>There are two functions that are commonly <a id="_idIndexMarker246"/>used to delay the execution of a function, <code>setTimeout</code> and <code>setInterval</code>. Both functions receive a callback as an argument and<a id="_idIndexMarker247"/> execute it after a certain amount of time. Now, let’s define and use these functions in examples.</p>
			<p>The <code>setTimeout</code> function is employed to defer the execution of a function by a specified amount of time.</p>
			<p>Let’s see how <code>setTimeout</code> works with a simple example:</p>
			<pre class="source-code">
console.log('Before setTimeout');
const secondInMilliseconds = 1000;
setTimeout(() =&gt; {
  console.log('A second has passed');
}, secondInMilliseconds);
console.log('after setTimeout');</pre>			<p>If we execute this code, we will see the following output:</p>
			<pre class="source-code">
Before setTimeout
after setTimeout
A second has passed</pre>			<p>As you can see, the callback is executed after the rest of the code, even though it was defined before. This is because the callback is executed asynchronously, which means that it is executed in the background, and the rest of the code is executed in the main thread.</p>
			<p>The <code>setTimeout</code> function receives two arguments. The first one is the callback, and the second one is the amount of time that the callback should be delayed. The amount of time is expressed in milliseconds, so in this case, we are delaying the execution of the callback by 1,000 milliseconds, which is 1 <a id="_idIndexMarker248"/>second.</p>
			<p>The <code>setInterval</code> function is used to <a id="_idIndexMarker249"/>execute a function repeatedly, with a fixed time delay between each execution.</p>
			<p>Let’s see how <code>setInterval</code> works with a simple example:</p>
			<pre class="source-code">
const secondInMilliseconds = 1000;
let totalExecutions = 0
console.log('Before setInterval');
setInterval(() =&gt; {
    totalExecutions++;
    console.log(`A second has passed, this is the ${totalExecutions} execution`);
}, secondInMilliseconds);
console.log('After setInterval');</pre>			<p>If we execute this code, we will see the following output:</p>
			<pre class="source-code">
Before setInterval
After setInterval
A second has passed, this is the 1 execution
...
A second has passed, this is the 50 execution</pre>			<p>As you can see, the callback is executed every second, and it is executed in the background, so the rest of the code is executed in the main thread.</p>
			<p>The <code>setInterval</code> function receives two arguments. The first one is the callback, and the second one is the amount of time that the callback should be delayed. The amount of time is expressed in milliseconds, so in this case, we are delaying the execution of the callback by 1,000 milliseconds, which is 1 second.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor139"/>Error first callbacks</h2>
			<p>In the examples in the preceding sections, we saw how to use callbacks to manage asynchronous operations, but <a id="_idIndexMarker250"/>we didn’t see how to handle errors. In this section, we will see how to handle errors in callbacks.</p>
			<p>The most common way to handle errors in callbacks is to use the error first pattern. This pattern consists of passing an error as the first argument of the callback, and the result as the second argument. Let’s see how this works with a simple example:</p>
			<pre class="source-code">
const doSomething = (cb) =&gt; {
  const error = new Error('Something went wrong');
  cb(error, null);
};
doSomething((error, result) =&gt; {
  if (error) {
    console.log('There was an error');
    return;
  }
  console.log('Everything went well');
});</pre>			<p>The output of this code will be as follows:</p>
			<pre class="console">
There was an error</pre>			<p>In this example, we have a function called <code>doSomething</code> that receives a callback as an argument. This callback receives two arguments. The first one is an error, and the second one is the result. In this case, we are passing an error as the first argument, and <code>null</code> as the second argument because an error occurred. When the callback is executed, we check if the first<a id="_idIndexMarker251"/> argument is an error, and if it is, we print <code>There was an error</code>. Otherwise, we print <code>Everything </code><code>went well</code>.</p>
			<p>Let’s see how this works when everything goes well:</p>
			<pre class="source-code">
const doSomething = (cb) =&gt; {
  const result = 'It worked!';
  cb(null, result);
};
doSomething((error, result) =&gt; {
  if (error) {
    console.log('There was an error');
    return;
  }
  console.log(result);
  console.log('Everything went well');
});</pre>			<p>The output of this code<a id="_idIndexMarker252"/> will be as follows:</p>
			<pre class="console">
It worked!
Everything went well</pre>			<p>In this case, we are passing <code>null</code> as the first argument as there is no error, and the result as the second argument. When the callback is executed, we check if the first argument is an error, and if it is, we print <code>There was an error</code>. Otherwise, we print the result, and <code>Everything </code><code>went well</code>.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor140"/>Callback hell</h2>
			<p>Previously, we saw how to use callbacks to manage asynchronous operations and how to handle errors with the error first pattern.</p>
			<p>The problem with callbacks is that they are not very easy to read, and when we have a lot of nested callbacks, the code<a id="_idIndexMarker253"/> becomes very difficult to read. This is called callback hell, and it is a very common problem when using callbacks.</p>
			<p>In the following pseudocode example, you can see how the functions are generated in an inclined pyramid with nested callbacks that make the code really hard to follow. In the following code example, observe<a id="_idIndexMarker254"/> how the functions are structured in an inclined pyramid with nested callbacks, making the code challenging to comprehend:</p>
			<pre class="source-code">
readFile("docs.md", (err, mdContent) =&gt; {
    convertMarkdownToHTML(mdContent, (err, htmlContent) =&gt; {
        addCssStyles(htmlContent, (err, docs) =&gt; {
            saveFile(docs, "docs.html",(err, result) =&gt; {
                ftp.sync((err, result) =&gt; {
                    // ...
                })
            })
        })
    })
})</pre>			<p>As you can see, the code is very difficult to read, and it is very easy to make mistakes. This is why we need a better way to manage asynchronous operations. There are some ways to prevent callback hell, such as using named functions instead of anonymous functions, but one of the most common ways to avoid callback hell is to use promises.</p>
			<p>Promises are a great solution when you need to chain asynchronous operations, let’s explore it in the next section.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor141"/>Mastering promises</h1>
			<p>A promise functions as a state machine, symbolizing the eventual success or failure of an asynchronous operation, along<a id="_idIndexMarker255"/> with its resultant value. It can exist in any of three states: pending, fulfilled, or rejected.</p>
			<p>When a promise is created, it is in the pending state. When a promise is fulfilled, it is in the fulfilled state. When a promise is rejected, it is in the rejected state.</p>
			<p>The following diagram shows the various states of a promise and the connections between them:</p>
			<div><div><img src="img/B21678_04_01.jpg" alt="Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5. https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5. <a href="https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license">https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license</a></p>
			<p>After a promise is fulfilled or rejected, it becomes unchangeable. To manage fulfillment, the <code>then</code> method is employed, while the <code>catch</code> method is used to address the rejection of the promise.</p>
			<p>Now that it is clear what the promises are and how the states are related, it is time to observe them in action. In the next section, we will explore how to use them and control any asynchronous flow effortlessly in JavaScript.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor142"/>Using promises</h2>
			<p>Let’s see how this works with <a id="_idIndexMarker256"/>a simple example using <code>fetch</code> to make a request to an <a id="_idIndexMarker257"/>external <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). This example will be using my simple-api project (<a href="https://github.com/UlisesGascon/simple-api">https://github.com/UlisesGascon/simple-api</a>), which is available at <a href="https://api.demo.foo/__/docs/">https://api.demo.foo/__/docs/</a> and is a fake online <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) API for testing and fast <a id="_idIndexMarker258"/>prototyping.</p>
			<p>So, in the following code example, we will perform a network request and bring data to our application using the internet, as this operation requires network I/O, it is asynchronous, so we will need<a id="_idIndexMarker259"/> to use promises:</p>
			<pre class="source-code">
fetch('https://api.demo.foo/v1/todo')
  .then(response =&gt; response.json())
  .then(json =&gt; console.log(json))
  .catch(error =&gt; console.log(error));</pre>			<p>The output of this code will be as follows:</p>
			<pre class="source-code">
[{
  "id": "fc3f31b9-8d98-42e9-aab3-1586f2273c3a",
  "title": "We need to input the digital DNS capacitor!",
   "completed": true  }
...
]</pre>			<p>In this example, we are using the <code>fetch</code> function to make a request to the API. The function yields a promise, allowing us to employ the <code>then</code> method to manage successful fulfillment and the <code>catch</code> method to handle potential rejections. In this case, we are using the <code>then</code> method twice: the first time to parse the response as JSON, and the second time to print the result to the console. We are also using the <code>catch</code> method to print the error to the console.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor143"/>Creating promises</h2>
			<p>You can create a promise using the <code>Promise</code> constructor, which receives a callback as an argument. This callback<a id="_idIndexMarker260"/> receives two arguments, <code>resolve</code> and <code>reject</code>. The <code>resolve</code> function is used to resolve the promise, and the <code>reject</code> function is used to reject the promise. Let’s see how this works with a simple example:</p>
			<pre class="source-code">
const setTimeoutPromise = (time) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve();
    }, time);
  });
};
console.log('Before setTimeoutPromise');
setTimeoutPromise(1000).then(() =&gt; console.log('one second later'))
console.log('After setTimeoutPromise');</pre>			<p>The output of this code will be as follows:</p>
			<pre class="source-code">
Before setTimeoutPromise
After setTimeoutPromise
one second later</pre>			<p>In this example, we have a function called <code>setTimeoutPromise</code> that receives a <code>time</code> as an argument. This <a id="_idIndexMarker261"/>function returns a promise that will be resolved after the specified time. When the promise is resolved, we print <code>one second later</code> to the console.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor144"/>Callback hell with promises</h2>
			<p>Promises are a great way to deal <a id="_idIndexMarker262"/>with the limitations that callbacks introduce when we need to perform multiple asynchronous operations that should be executed in a consecutive order.</p>
			<p>Promises will handle errors more easily, so the readability of the code should be clearer and easier to maintain in long term.</p>
			<p>In the previous section, we saw that callback hell is a very real thing in JavaScript. By now, you should be more familiar with the inclined pyramid and nested callbacks. Here is the snippet that we used to explain <a id="_idIndexMarker263"/>how Callback hell can be easily achieved in a previous section:</p>
			<pre class="source-code">
readFile("docs.md", (err, mdContent) =&gt; {
    convertMarkdownToHTML(mdContent, (err, htmlContent) =&gt; {
        addCssStyles(htmlContent, (err, docs) =&gt; {
            saveFile(docs, "docs.html",(err, result) =&gt; {
                ftp.sync((err, result) =&gt; {
                    // ...
                })
            })
        })
    })
})</pre>			<p>Now let’s see how we can solve this problem using promises:</p>
			<pre class="source-code">
readFile("docs.md")
  .then(convertMarkdownToHTML)
// shortcut for .then(mdContent =&gt; convertMarkdownToHTML(mdContent))
  .then(addCssStyles)
  .then(docs =&gt; saveFile(docs, "docs.html"))
  .then(ftp.sync)
  .then(result =&gt; {
    // ... other things
  })
  .catch(error =&gt; console.log(error));</pre>			<p>As you can see, the code is much easier to read, and it is much easier to make changes to. This is one of the main advantages of using promises. Now the errors are handled in the last <code>catch</code> method, so we <a id="_idIndexMarker264"/>don’t need to handle the errors in each <code>then</code> method, which makes the code much cleaner.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor145"/>Parallel promises</h2>
			<p>Another advantage of using promises is that we can run multiple promises in parallel. Basically, we provide an <a id="_idIndexMarker265"/>array of promises and we choose a strategy to handle the results (<code>Promise.race()</code> or <code>Promise.all()</code>). This is a great way to reduce the execution time, as we are using Node.js’ abilities to manage I/O operations asynchronously.</p>
			<p>In the following examples, we will use this function to generate a random timeout promise as an example of an asynchronous operation:</p>
			<pre class="source-code">
const randomTimeOutPromise = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const time = Math.floor(Math.random() * 100);
    setTimeout(() =&gt; {
      console.log(`Promise resolved after ${time}ms`);
      resolve(time);
    }, time);
  });
};</pre>			<p>This function will return a promise that will be resolved after a random time between 0 and 100 milliseconds. Now that we have an asynchronous function, we can employ various strategies to group multiple requests together based on our specific needs. In this instance, our goal is to initiate several requests in parallel and await their resolution.</p>
			<p><code>Promise.all()</code>: The <code>all</code> method produces a singular promise that resolves once all the promises are resolved or if any of the promises are rejected:</p>
			<pre class="source-code">
Promise.all([
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
]).then((results) =&gt; {
  console.log("results:", results);
});</pre>			<p>The output of this code will be<a id="_idIndexMarker266"/> something like this when all the promises are resolved successfully:</p>
			<pre class="console">
Promise resolved after 0ms
Promise resolved after 26ms
Promise resolved after 31ms
Promise resolved after 37ms
Promise resolved after 62ms
results: [37, 31, 26, 62, 0]</pre>			<p>As you can see, the <code>then</code> method will be called when all the promises are resolved, and it will receive an array with the results of each promise in the order they are being added in the promise array, not by the order in which they are resolved.</p>
			<p>In the previous example, all the promises were successfully resolved  as they are based on timer operation. But when we relay on promises to access external resources like files in our system or fetching data from the Internet, then we need to take into account that these resources might not be always available. For example, if the Internet is down, then one or multiple promises can fail and this will make our application to crash. Obviously, this crashing situation can be avoided if we handle the errors using a <code>catch</code> statement, but even in that case, it is very important to remember that when we use this parallelism approach, we need to take into account that if a single promise generates an error, the resolved ones will be ignored just the same as if we were using a single promise.</p>
			<p>An alternative approach to <code>Promise.all()</code> is to aggregate all the requests but resolve the promise as soon as the<a id="_idIndexMarker267"/> first one is complete. This way, there’s no need to wait for the fulfillment of all requests.</p>
			<p><code>Promise.race()</code>: The <code>race</code> method returns a single promise that is fulfilled or rejected as soon as one of the promises gets fulfilled or rejected. This can lead to unexpected results if not carefully managed, as the promises won’t stop running even if one of the promises was rejected or fulfilled already:</p>
			<pre class="source-code">
Promise.race([
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
]).then((result) =&gt; {
  console.log("result:", result);
});</pre>			<p>The output of this code will be something like this:</p>
			<pre class="console">
Promise resolved after 30ms
results: 30
Promise resolved after 33ms
Promise resolved after 60ms
Promise resolved after 79ms
Promise resolved after 83ms</pre>			<p>As you can see, the <code>then</code> method will be called when the first promise is resolved, and it will receive the result of the first<a id="_idIndexMarker268"/> promise that is resolved. The other promises will continue running, but the <code>then</code> method will not be called again.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor146"/>Error handling</h2>
			<p>In the previous examples, we <a id="_idIndexMarker269"/>saw how to handle errors using the <code>catch</code> method, but there is another way to handle errors: using the <code>reject</code> function. Let’s see how this works with this example:</p>
			<pre class="source-code">
const generatePromise = shouldFail =&gt; {
  return new Promise((resolve, reject) =&gt; {
    if (shouldFail) {
      return reject(new Error("Rejected!"));
    }
    resolve("Success!");
  });
};
generatePromise(true).catch(error =&gt; console.log("Error message:", error));
// Error message: Error: Rejected!
// ...</pre>			<p>It’s important to notice that the <code>reject</code> function will not stop the execution of the code, so we need to <code>return</code> the function after calling the <code>reject</code> function.</p>
			<p>The final approach is when we need to perform an action once a promise has been concluded, regardless of whether it was successful or rejected. It is important to remember that unhandled promise rejections can lead to runtime errors that will crash your application. We will learn more about this in <a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a>.</p>
			<p><code>Promise.finally()</code>: Sometimes, we don’t care if the promise is resolved or rejected; we just want to know when the promise has been resolved or rejected. For this case, we can<a id="_idIndexMarker270"/> use the <code>finally</code> method:</p>
			<pre class="source-code">
generatePromise(true)
  .then(result =&gt; console.log("Result:", result))
  .catch(error =&gt; console.log("Error message:", error))
  .finally(() =&gt; console.log("Promise settled"));</pre>			<h2 id="_idParaDest-142"><a id="_idTextAnchor147"/>Chaining promises</h2>
			<p>We can also chain promises; we can return a promise in the <code>then</code> method, and this promise will be resolved before<a id="_idIndexMarker271"/> calling the next <code>then</code> method. The <code>catch</code> method will be called if any of the promises in the chain are rejected. Let’s see an example:</p>
			<pre class="source-code">
generatePromise()
  .then(generatePromise)
  .then(result =&gt; {
    return generatePromise(true);
  })
  .then(() =&gt; console.log("This will not be called"))
  .catch(error =&gt; console.log("Error message:", error));</pre>			<p>When the third <code>generatePromise</code> is called, it will return a promise that will be rejected, so the <code>catch</code> method will be called and then the last <code>then</code> won’t be executed.</p>
			<p>We have been utilizing promises for some time, and the syntax can be quite verbose, requiring keywords such as <code>then</code> and <code>catch</code> consistently. A more advanced and aesthetically pleasing syntax involves using <code>async</code> and <code>await</code>. We will delve into this approach in the next section.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor148"/>Using async and await to handle asynchronous code</h1>
			<p>ES2017 introduced a new way to handle asynchronous code, the <code>async</code> and <code>await</code> keywords. These keywords are syntactic sugar for promises; they are not a new way to handle asynchronous code, but they make the code much easier to read and write.</p>
			<p>Essentially, the <code>async</code> keyword is employed to define an asynchronous function, while the <code>await</code> keyword is used to pause and await the resolution of a promise within that function. Even if you use the word <code>async</code> it doesn’t make you code asynchronously, that will only occur when you actually have asynchronous code on it (a promise). To make it more simple, we can say that in order to use <code>await</code>, we need to define the code block using <code>async</code>. Let’s explore more in detail how we can use <code>async</code>.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor149"/>async</h2>
			<p>When a function is defined <a id="_idIndexMarker272"/>with the <code>async</code> keyword, it will always<a id="_idIndexMarker273"/> return a promise that can be handled as any regular promise. Let’s see an example:</p>
			<pre class="source-code">
const asyncFun = async (generateError) =&gt; {
    if (generateError) {
        throw new Error("Error generated");
    }
    return 1;
};
asyncFun().then((result) =&gt; console.log(result));
asyncFun(true).catch((error) =&gt; console.log(error));</pre>			<p>As this is syntactic sugar for promises, we can build a similar function using promises:</p>
			<pre class="source-code">
const asyncFun =  (generateError) =&gt; new Promise((resolve, reject) =&gt; {
    if (generateError) {
        reject(new Error("Error generated"));
    }
    resolve(1);
});
asyncFun().then((result) =&gt; console.log(result));
asyncFun(true).catch((error) =&gt; console.log(error));</pre>			<p>Now, let’s acquaint ourselves<a id="_idIndexMarker274"/> with <code>await</code>; we’ll be able to seamlessly combine both keywords and eliminate the <a id="_idIndexMarker275"/>need to use <code>then</code> or <code>catch</code>.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor150"/>await</h2>
			<p>Let’s see how we can use<a id="_idIndexMarker276"/> the <code>await</code> keyword in order to <a id="_idIndexMarker277"/>wait for promises:</p>
			<pre class="source-code">
// Promises
fetch(' https://api.demo.foo/v1/todo')
  .then(response =&gt; response.json())
  .then(json =&gt; console.log(json))
  .catch(error =&gt; console.log(error));
// Async/Await
const fetchData = async () =&gt; {
  try {
    const response = await fetch('https://api.demo.foo/v1/todo');
    const json = await response.json();
    console.log(json);
  } catch (error) {
      console.log(error);
  }
}
fetchData(); // [{userId: 1, id: 1, title: 'delectus aut autem',
completed: false}]</pre>			<p>As you can see, the code is much <a id="_idIndexMarker278"/>easier to read and write using <code>async</code> and <code>await</code>. The <code>await</code> keyword can only be used inside an <code>async</code> function. We need to use the <code>try</code>/<code>catch</code> block to handle the errors.</p>
			<p><code>try</code>/<code>catch</code> is a mechanism provided by JavaScript that allows us to encapsulate certain code inside the <code>try</code> block, and handle any possible errors with the <code>catch</code> block. So, in the previous example, as we are doing an HTTP request we depend on external factors such as connectivity to the internet or the ability of the external server to return the information that we<a id="_idIndexMarker279"/> are asking for in our request. In our specific case, we are  “silently failing” this error because in the <code>catch</code> block we only print the information about the error, but in other scenarios we might show an alert message in the UI or trigger a retry strategy to try to perform this HTTP request again. It is important to remember that If we don’t handle errors properly, our application might crash. We will explore this topic in detail in <a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a>.</p>
			<p>Now, let’s explore how we can blend <code>async</code> to employ this syntactic sugar even in older Node.js versions.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor151"/>IIFEs</h2>
			<p>In some cases, we want to use the <code>await</code> keyword outside an <code>async</code> function, for example, when we are using the <code>await</code> keyword in the top level of a module. In this case, we can use an IIFE to wrap<a id="_idIndexMarker280"/> the <code>await</code> keyword inside an <code>async</code> function. An IIFE is a function that is executed immediately after it is created. It is a design pattern that is used to avoid polluting the global scope with variables and functions. In the subsequent example, we can observe the fundamental syntax:</p>
			<pre class="source-code">
(function () {
  // ... some code here
})();</pre>			<p>The idea is to create an anonymous function and execute it immediately after it is created. In order to achieve this, we need to wrap the function between parentheses, and then add another pair of parentheses to execute the function: <code>(...)()</code>.</p>
			<p>We can use <code>async</code> and <code>await</code> inside an IIFE easily:</p>
			<pre class="source-code">
(async () =&gt; {
    const response = await fetch(' https://api.demo.foo/v1/todo ');
    const json = await response.json();
    console.log(json);
})()</pre>			<p>This guarantees that the code will be executed immediately after it is created, and we can use the <code>await</code> keyword inside the IIFE.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor152"/>Summary</h1>
			<p>In this chapter, we learned about asynchronous programming in JavaScript. We explored asynchronous APIs such as <code>setTimeout</code> and <code>fetch</code>, and we learned how to handle asynchronous code using callbacks, promises, and <code>async</code>/<code>await</code>. Additionally, we learned about the error first callback convention and how to prevent callback hell using named functions and promises. Finally, we learned how to manage promises, how to bulk operations using the <code>Promise.all</code> and <code>Promise.race</code> methods, and how to use the <code>async</code> and <code>await</code> keywords to handle asynchronous code in a cleaner way.</p>
			<p>In the next chapter, we will learn about HTTP and how the modern web works using REST APIs.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor153"/>Further reading</h1>
			<p>Asynchronous programming in JavaScript is a broad topic that necessitates a considerable amount of time to master and comprehend fully. With the following links, you will discover valuable resources that will aid you in delving deeper into the subjects covered in th<a id="_idTextAnchor154"/>is chapter:</p>
			<ul>
				<li><em class="italic">JavaScript Promise in 100 </em><em class="italic">Seconds</em>: <a href="https://www.youtube.com/watch?v=RvYYCGs45L4">https://www.youtube.com/watch?v=RvYYCGs45L4</a></li>
				<li><em class="italic">Asynchrony: Under the Hood – Shelley Vohr – JSConf </em><em class="italic">EU</em>: <a href="https://www.youtube.com/watch?v=SrNQS8J67zc">https://www.youtube.com/watch?v=SrNQS8J67zc</a></li>
				<li><em class="italic">async/await in JavaScript – What, Why and How – Fun Fun </em><em class="italic">Function: </em><a href="https://www.youtube.com/watch?v=568g8hxJJp4">https://www.youtube.com/watch?v=568g8hxJJp4</a></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-149" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor155"/>Part 2: Node.js Ecosystem and Architecture</h1>
			<p>In <em class="italic">Part 2</em>, you will learn how to use the Node.js core libraries and third-party libraries by using the vast npm ecosystem ecosystem. Also, you will learn how to use and implement event-driven architectures in detail, and you will understand how to use testing and implement unit testing in your projects.</p>
			<p>This part includes the following chapters:</p>
			<ul>
				<li><a href="B21678_05.xhtml#_idTextAnchor156"><em class="italic">Chapter 5</em></a>, <em class="italic">Node.js Core Libraries</em></li>
				<li><a href="B21678_06.xhtml#_idTextAnchor171"><em class="italic">Chapter 6</em></a>, <em class="italic">External Modules and npm</em></li>
				<li><a href="B21678_07.xhtml#_idTextAnchor206"><em class="italic">Chapter 7</em></a>, <em class="italic">Event-Driven Architecture</em></li>
				<li><a href="B21678_08.xhtml#_idTextAnchor218"><em class="italic">Chapter 8</em></a>, <em class="italic">Testing in Node.js</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>