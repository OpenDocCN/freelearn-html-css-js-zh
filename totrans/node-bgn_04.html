<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-127" class="chapter-number"><a id="_idTextAnchor132"/>4</h1>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor133"/>Asynchronous Programming</h1>
			<p>This chapter will explain in detail how to use all the asynchronous mechanisms that JavaScript offers today, including how to convert callbacks to promises and perform bulk <span class="No-Break">asynchronous operations.</span></p>
			<p>You will gain an in-depth understanding of all the tools at your disposal for managing both simple and complex asynchronous activities. We’ll begin with callbacks following Node.js Core conventions, then progress to effectively handling asynchronous operations using promises, and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>. Toward the end of the chapter, we’ll employ the <strong class="bold">Immediately Invoked Function Expression (IIFE)</strong> pattern to execute asynchronous code. Additionally, we will provide a comprehensive overview of how to convert asynchronous operations between different handlers, including callbacks <span class="No-Break">and promises.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Asynchronous programming <span class="No-Break">in JavaScript</span></li>
				<li>Understanding callbacks and how to avoid <span class="No-Break">callback hell</span></li>
				<li><span class="No-Break">Mastering promises</span></li>
				<li>Using <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> for handling <span class="No-Break">asynchronous code</span></li>
			</ul>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor134"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/FHzqWr4dK7s"><span class="No-Break">https://youtu.be/FHzqWr4dK7s</span></a></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor135"/>Asynchronous programming in JavaScript</h1>
			<p>In JavaScript, asynchronous programming is <a id="_idIndexMarker233"/>a fundamental part of the<a id="_idIndexMarker234"/> language. It is the mechanism that allows us to perform operations in the background, without blocking the execution of the main thread. This is especially important in the browser, where the main thread is responsible for updating the user interface and responding to <span class="No-Break">user actions.</span></p>
			<p>Overall, asynchronous programming is a complex topic that requires a lot of practice to master, but in my opinion, it <a id="_idIndexMarker235"/>requires a change in your mindset. You will need to start thinking about how to break down your code into small chunks that can be executed in the background, and how to combine them to achieve the desired result. You’ll encounter asynchronous programming regularly while coding with JavaScript. Most operations involving interactions with external resources, such as sending and receiving data from a server or a database and reading the content from a file, will necessitate <span class="No-Break">its use.</span></p>
			<p class="callout-heading">Previous knowledge</p>
			<p class="callout">In <a href="B21678_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> we introduced the concept of the event loop, which is the mechanism that allows JavaScript to be asynchronous. In this chapter, we will see how to use this mechanism to <span class="No-Break">our advantage.</span></p>
			<p class="callout">In <a href="B21678_03.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, </em>we learned how to use JavaScript in detail; this chapter requires a solid knowledge of functions <span class="No-Break">and arrays.</span></p>
			<p>Let’s begin by exploring how asynchronous programming differs from conventional programming and how we need to adopt a <span class="No-Break">different mindset.</span></p>
			<p>This chapter uses isomorphic JavaScript snippets, so the code can be executed in Node.js or in <span class="No-Break">the browser.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor136"/>The asynchronous mindset</h2>
			<p>The first step in mastering asynchronous <a id="_idIndexMarker236"/>programming is to change your mindset. You need to start thinking about your code in a non-linear way; you will think more about “what should happen next” rather than “what should <span class="No-Break">happen first.”</span></p>
			<p>When we learned about functions in <a href="B21678_03.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we saw that a function is <em class="italic">just</em> a piece of code that can be executed at any time. In this section, we will connect that piece of code to<a id="_idIndexMarker237"/> previous events, and to <span class="No-Break">future events.</span></p>
			<p>There are many ways to perform asynchronous operations in JavaScript. In this chapter, we will focus on the most common ones, which are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Callbacks</strong>: A callback is a <a id="_idIndexMarker238"/>function that is passed as an argument to another function, and it is executed when a certain event happens. This is the most basic way to perform asynchronous operations in JavaScript, and it is the foundation of all the <span class="No-Break">other mechanisms.</span></li>
				<li><strong class="bold">Promises</strong>: ES6 introduced the<a id="_idIndexMarker239"/> concept of promises, which you can use to handle asynchronous operations in an advanced way because they use a state machine with several states (pending, fulfilled, and rejected) to keep track of operations. Promises have many advantages over callbacks in terms of readability, reusability, and overall simplicity. This is the most common way to perform asynchronous operations in modern JavaScript today. For more details, check out the <em class="italic">Mastering promises</em> section in <span class="No-Break">this chapter.</span></li>
				<li><strong class="bold">Async/await</strong>: Async/await acts as a<a id="_idIndexMarker240"/> wrapper over promises to make code more <a id="_idIndexMarker241"/>readable (syntax sugar). Currently is the most popular way of handling <span class="No-Break">asynchronous operations.</span></li>
			</ul>
			<p>In the next section, we will explore how we can use callbacks effectively in our applications, the error first pattern, and other good practices to follow. Later on, we will explore how to wrap callbacks <span class="No-Break">inside promises.</span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor137"/>Understanding callbacks</h1>
			<p>Callbacks exploit JavaScript’s<a id="_idIndexMarker242"/> capability to pass functions. There are two essential parts to <span class="No-Break">this technique:</span></p>
			<ul>
				<li>A function that is passed as an argument to <span class="No-Break">another function</span></li>
				<li>The passed function is executed when a certain <span class="No-Break">event happens</span></li>
			</ul>
			<p>Let’s create a basic example to illustrate this concept. In the following code snippets, we will show how the callback is defined as an argument and how a function is passed as an argument when the <span class="No-Break">execution</span><span class="No-Break"><a id="_idIndexMarker243"/></span><span class="No-Break"> occurs:</span></p>
			<ol>
				<li>In this example, we will define a function (<strong class="source-inline">doSomething</strong>) that expects a function as <span class="No-Break">an argument:</span><pre class="source-code">
const doSomething = (cb) =&gt; {
  console.log('Doing something...');
  cb();
};</pre></li>				<li>At this point, we have a function called <strong class="source-inline">doSomething</strong> that receives a function as an argument and executes it as the last step, this illustrates the idea that the callbacks are just a pattern where we expect that the next function to the executed is actually called as the final step (call me back when you are done - callback)  . Let’s see how we can use <span class="No-Break">this function:</span><pre class="source-code">
const nextStep = () =&gt; {
  console.log('Callback called');
};
doSomething(nextStep);</pre></li>				<li>Once the function is executed, the expected output will be <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">Doing something...</strong>
<strong class="bold">Callback called</strong></pre></li>			</ol>
			<p>Now, we have a function called <strong class="source-inline">nextStep</strong> that is passed as an argument to <strong class="source-inline">doSomething</strong>. When <strong class="source-inline">doSomething</strong> is executed, it will print <strong class="source-inline">Doing something...</strong>, and then it will execute the function that was passed as an argument, which will print <strong class="source-inline">Callback called</strong> as the <span class="No-Break">last step.</span></p>
			<p>It is important to note that the function that is passed as an argument is not executed immediately , as we only want to execute them when the operation is complete. On the other hand, the immediate execution will require the use of parentheses (<strong class="source-inline">doSomething(nextStep())</strong>) and will produce a different result and <span class="No-Break">an error:</span></p>
			<pre class="source-code">
doSomething(nextStep())
// Callback called
// Doing something...
// Error: cb is not a function</pre>			<p>We can also pass an anonymous<a id="_idIndexMarker244"/> function as an argument. This is the most common way to use callbacks, as we don’t need to define the functions previously. In most cases, we don’t reuse that <span class="No-Break">function later:</span></p>
			<pre class="source-code">
doSomething(() =&gt; {
    console.log('Callback called');
});</pre>			<p>It is also possible to pass a function that <span class="No-Break">receives arguments:</span></p>
			<pre class="source-code">
const calculateNameLength = (name, cb) =&gt; {
  const length = name.length;
  cb(length);
};
calculateNameLength('John', (length) =&gt; {
  console.log(`The name length is ${length}`); // The name length is 4
});</pre>			<p>As you can see, the callback technique is very simple, but we haven’t seen any asynchronous operations yet. At the end of the day, we assume that a callback is literally a “call me back when you are done” approach. Now, let’s see how this can be used to manage asynchronous operations <a id="_idIndexMarker245"/>with timers <span class="No-Break">and intervals.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor138"/>Timers and intervals</h2>
			<p>There are two functions that are commonly <a id="_idIndexMarker246"/>used to delay the execution of a function, <strong class="source-inline">setTimeout</strong> and <strong class="source-inline">setInterval</strong>. Both functions receive a callback as an argument and<a id="_idIndexMarker247"/> execute it after a certain amount of time. Now, let’s define and use these functions <span class="No-Break">in examples.</span></p>
			<p>The <strong class="source-inline">setTimeout</strong> function is employed to defer the execution of a function by a specified amount <span class="No-Break">of time.</span></p>
			<p>Let’s see how <strong class="source-inline">setTimeout</strong> works with a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
console.log('Before setTimeout');
const secondInMilliseconds = 1000;
setTimeout(() =&gt; {
  console.log('A second has passed');
}, secondInMilliseconds);
console.log('after setTimeout');</pre>			<p>If we execute this code, we will see the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
Before setTimeout
after setTimeout
A second has passed</pre>			<p>As you can see, the callback is executed after the rest of the code, even though it was defined before. This is because the callback is executed asynchronously, which means that it is executed in the background, and the rest of the code is executed in the <span class="No-Break">main thread.</span></p>
			<p>The <strong class="source-inline">setTimeout</strong> function receives two arguments. The first one is the callback, and the second one is the amount of time that the callback should be delayed. The amount of time is expressed in milliseconds, so in this case, we are delaying the execution of the callback by 1,000 milliseconds, which is <span class="No-Break">1 </span><span class="No-Break"><a id="_idIndexMarker248"/></span><span class="No-Break">second.</span></p>
			<p>The <strong class="source-inline">setInterval</strong> function is used to <a id="_idIndexMarker249"/>execute a function repeatedly, with a fixed time delay between <span class="No-Break">each execution.</span></p>
			<p>Let’s see how <strong class="source-inline">setInterval</strong> works with a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
const secondInMilliseconds = 1000;
let totalExecutions = 0
console.log('Before setInterval');
setInterval(() =&gt; {
    totalExecutions++;
    console.log(`A second has passed, this is the ${totalExecutions} execution`);
}, secondInMilliseconds);
console.log('After setInterval');</pre>			<p>If we execute this code, we will see the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
Before setInterval
After setInterval
A second has passed, this is the 1 execution
...
A second has passed, this is the 50 execution</pre>			<p>As you can see, the callback is executed every second, and it is executed in the background, so the rest of the code is executed in the <span class="No-Break">main thread.</span></p>
			<p>The <strong class="source-inline">setInterval</strong> function receives two arguments. The first one is the callback, and the second one is the amount of time that the callback should be delayed. The amount of time is expressed in milliseconds, so in this case, we are delaying the execution of the callback by 1,000 milliseconds, which is <span class="No-Break">1 second.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor139"/>Error first callbacks</h2>
			<p>In the examples in the preceding sections, we saw how to use callbacks to manage asynchronous operations, but <a id="_idIndexMarker250"/>we didn’t see how to handle errors. In this section, we will see how to handle errors <span class="No-Break">in callbacks.</span></p>
			<p>The most common way to handle errors in callbacks is to use the error first pattern. This pattern consists of passing an error as the first argument of the callback, and the result as the second argument. Let’s see how this works with a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
const doSomething = (cb) =&gt; {
  const error = new Error('Something went wrong');
  cb(error, null);
};
doSomething((error, result) =&gt; {
  if (error) {
    console.log('There was an error');
    return;
  }
  console.log('Everything went well');
});</pre>			<p>The output of this code will be <span class="No-Break">as follows:</span></p>
			<pre class="console">
There was an error</pre>			<p>In this example, we have a function called <strong class="source-inline">doSomething</strong> that receives a callback as an argument. This callback receives two arguments. The first one is an error, and the second one is the result. In this case, we are passing an error as the first argument, and <strong class="source-inline">null</strong> as the second argument because an error occurred. When the callback is executed, we check if the first<a id="_idIndexMarker251"/> argument is an error, and if it is, we print <strong class="source-inline">There was an error</strong>. Otherwise, we print <strong class="source-inline">Everything </strong><span class="No-Break"><strong class="source-inline">went well</strong></span><span class="No-Break">.</span></p>
			<p>Let’s see how this works when everything <span class="No-Break">goes well:</span></p>
			<pre class="source-code">
const doSomething = (cb) =&gt; {
  const result = 'It worked!';
  cb(null, result);
};
doSomething((error, result) =&gt; {
  if (error) {
    console.log('There was an error');
    return;
  }
  console.log(result);
  console.log('Everything went well');
});</pre>			<p>The output of this code<a id="_idIndexMarker252"/> will be <span class="No-Break">as follows:</span></p>
			<pre class="console">
It worked!
Everything went well</pre>			<p>In this case, we are passing <strong class="source-inline">null</strong> as the first argument as there is no error, and the result as the second argument. When the callback is executed, we check if the first argument is an error, and if it is, we print <strong class="source-inline">There was an error</strong>. Otherwise, we print the result, and <strong class="source-inline">Everything </strong><span class="No-Break"><strong class="source-inline">went well</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor140"/>Callback hell</h2>
			<p>Previously, we saw how to use callbacks to manage asynchronous operations and how to handle errors with the error <span class="No-Break">first pattern.</span></p>
			<p>The problem with callbacks is that they are not very easy to read, and when we have a lot of nested callbacks, the code<a id="_idIndexMarker253"/> becomes very difficult to read. This is called callback hell, and it is a very common problem when <span class="No-Break">using callbacks.</span></p>
			<p>In the following pseudocode example, you can see how the functions are generated in an inclined pyramid with nested callbacks that make the code really hard to follow. In the following code example, observe<a id="_idIndexMarker254"/> how the functions are structured in an inclined pyramid with nested callbacks, making the code challenging <span class="No-Break">to comprehend:</span></p>
			<pre class="source-code">
readFile("docs.md", (err, mdContent) =&gt; {
    convertMarkdownToHTML(mdContent, (err, htmlContent) =&gt; {
        addCssStyles(htmlContent, (err, docs) =&gt; {
            saveFile(docs, "docs.html",(err, result) =&gt; {
                ftp.sync((err, result) =&gt; {
                    // ...
                })
            })
        })
    })
})</pre>			<p>As you can see, the code is very difficult to read, and it is very easy to make mistakes. This is why we need a better way to manage asynchronous operations. There are some ways to prevent callback hell, such as using named functions instead of anonymous functions, but one of the most common ways to avoid callback hell is to <span class="No-Break">use promises.</span></p>
			<p>Promises are a great solution when you need to chain asynchronous operations, let’s explore it in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor141"/>Mastering promises</h1>
			<p>A promise functions as a state machine, symbolizing the eventual success or failure of an asynchronous operation, along<a id="_idIndexMarker255"/> with its resultant value. It can exist in any of three states: pending, fulfilled, <span class="No-Break">or rejected.</span></p>
			<p>When a promise is created, it is in the pending state. When a promise is fulfilled, it is in the fulfilled state. When a promise is rejected, it is in the <span class="No-Break">rejected state.</span></p>
			<p>The following diagram shows the various states of a promise and the connections <span class="No-Break">between them:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B21678_04_01.jpg" alt="Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5. https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors is licensed under CC-BY-SA 2.5. <a href="https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license">https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license</a></p>
			<p>After a promise is fulfilled or rejected, it becomes unchangeable. To manage fulfillment, the <strong class="source-inline">then</strong> method is employed, while the <strong class="source-inline">catch</strong> method is used to address the rejection of <span class="No-Break">the promise.</span></p>
			<p>Now that it is clear what the promises are and how the states are related, it is time to observe them in action. In the next section, we will explore how to use them and control any asynchronous flow effortlessly <span class="No-Break">in JavaScript.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor142"/>Using promises</h2>
			<p>Let’s see how this works with <a id="_idIndexMarker256"/>a simple example using <strong class="source-inline">fetch</strong> to make a request to an <a id="_idIndexMarker257"/>external <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). This example will be using my simple-api project (<a href="https://github.com/UlisesGascon/simple-api">https://github.com/UlisesGascon/simple-api</a>), which is available at <a href="https://api.demo.foo/__/docs/">https://api.demo.foo/__/docs/</a> and is a fake online <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) API for testing and <span class="No-Break">fast </span><span class="No-Break"><a id="_idIndexMarker258"/></span><span class="No-Break">prototyping.</span></p>
			<p>So, in the following code example, we will perform a network request and bring data to our application using the internet, as this operation requires network I/O, it is asynchronous, so we will need<a id="_idIndexMarker259"/> to <span class="No-Break">use promises:</span></p>
			<pre class="source-code">
fetch('https://api.demo.foo/v1/todo')
  .then(response =&gt; response.json())
  .then(json =&gt; console.log(json))
  .catch(error =&gt; console.log(error));</pre>			<p>The output of this code will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[{
  "id": "fc3f31b9-8d98-42e9-aab3-1586f2273c3a",
  "title": "We need to input the digital DNS capacitor!",
   "completed": true  }
...
]</pre>			<p>In this example, we are using the <strong class="source-inline">fetch</strong> function to make a request to the API. The function yields a promise, allowing us to employ the <strong class="source-inline">then</strong> method to manage successful fulfillment and the <strong class="source-inline">catch</strong> method to handle potential rejections. In this case, we are using the <strong class="source-inline">then</strong> method twice: the first time to parse the response as JSON, and the second time to print the result to the console. We are also using the <strong class="source-inline">catch</strong> method to print the error to <span class="No-Break">the console.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor143"/>Creating promises</h2>
			<p>You can create a promise using the <strong class="source-inline">Promise</strong> constructor, which receives a callback as an argument. This callback<a id="_idIndexMarker260"/> receives two arguments, <strong class="source-inline">resolve</strong> and <strong class="source-inline">reject</strong>. The <strong class="source-inline">resolve</strong> function is used to resolve the promise, and the <strong class="source-inline">reject</strong> function is used to reject the promise. Let’s see how this works with a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
const setTimeoutPromise = (time) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve();
    }, time);
  });
};
console.log('Before setTimeoutPromise');
setTimeoutPromise(1000).then(() =&gt; console.log('one second later'))
console.log('After setTimeoutPromise');</pre>			<p>The output of this code will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Before setTimeoutPromise
After setTimeoutPromise
one second later</pre>			<p>In this example, we have a function called <strong class="source-inline">setTimeoutPromise</strong> that receives a <strong class="source-inline">time</strong> as an argument. This <a id="_idIndexMarker261"/>function returns a promise that will be resolved after the specified time. When the promise is resolved, we print <strong class="source-inline">one second later</strong> to <span class="No-Break">the console.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor144"/>Callback hell with promises</h2>
			<p>Promises are a great way to deal <a id="_idIndexMarker262"/>with the limitations that callbacks introduce when we need to perform multiple asynchronous operations that should be executed in a <span class="No-Break">consecutive order.</span></p>
			<p>Promises will handle errors more easily, so the readability of the code should be clearer and easier to maintain in <span class="No-Break">long term.</span></p>
			<p>In the previous section, we saw that callback hell is a very real thing in JavaScript. By now, you should be more familiar with the inclined pyramid and nested callbacks. Here is the snippet that we used to explain <a id="_idIndexMarker263"/>how Callback hell can be easily achieved in a <span class="No-Break">previous section:</span></p>
			<pre class="source-code">
readFile("docs.md", (err, mdContent) =&gt; {
    convertMarkdownToHTML(mdContent, (err, htmlContent) =&gt; {
        addCssStyles(htmlContent, (err, docs) =&gt; {
            saveFile(docs, "docs.html",(err, result) =&gt; {
                ftp.sync((err, result) =&gt; {
                    // ...
                })
            })
        })
    })
})</pre>			<p>Now let’s see how we can solve this problem <span class="No-Break">using promises:</span></p>
			<pre class="source-code">
readFile("docs.md")
  .then(convertMarkdownToHTML)
// shortcut for .then(mdContent =&gt; convertMarkdownToHTML(mdContent))
  .then(addCssStyles)
  .then(docs =&gt; saveFile(docs, "docs.html"))
  .then(ftp.sync)
  .then(result =&gt; {
    // ... other things
  })
  .catch(error =&gt; console.log(error));</pre>			<p>As you can see, the code is much easier to read, and it is much easier to make changes to. This is one of the main advantages of using promises. Now the errors are handled in the last <strong class="source-inline">catch</strong> method, so we <a id="_idIndexMarker264"/>don’t need to handle the errors in each <strong class="source-inline">then</strong> method, which makes the code <span class="No-Break">much cleaner.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor145"/>Parallel promises</h2>
			<p>Another advantage of using promises is that we can run multiple promises in parallel. Basically, we provide an <a id="_idIndexMarker265"/>array of promises and we choose a strategy to handle the results (<strong class="source-inline">Promise.race()</strong> or <strong class="source-inline">Promise.all()</strong>). This is a great way to reduce the execution time, as we are using Node.js’ abilities to manage I/O <span class="No-Break">operations asynchronously.</span></p>
			<p>In the following examples, we will use this function to generate a random timeout promise as an example of an <span class="No-Break">asynchronous operation:</span></p>
			<pre class="source-code">
const randomTimeOutPromise = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const time = Math.floor(Math.random() * 100);
    setTimeout(() =&gt; {
      console.log(`Promise resolved after ${time}ms`);
      resolve(time);
    }, time);
  });
};</pre>			<p>This function will return a promise that will be resolved after a random time between 0 and 100 milliseconds. Now that we have an asynchronous function, we can employ various strategies to group multiple requests together based on our specific needs. In this instance, our goal is to initiate several requests in parallel and await <span class="No-Break">their resolution.</span></p>
			<p><strong class="source-inline">Promise.all()</strong>: The <strong class="source-inline">all</strong> method produces a singular promise that resolves once all the promises are resolved or if any of the promises <span class="No-Break">are rejected:</span></p>
			<pre class="source-code">
Promise.all([
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
]).then((results) =&gt; {
  console.log("results:", results);
});</pre>			<p>The output of this code will be<a id="_idIndexMarker266"/> something like this when all the promises are <span class="No-Break">resolved successfully:</span></p>
			<pre class="console">
Promise resolved after 0ms
Promise resolved after 26ms
Promise resolved after 31ms
Promise resolved after 37ms
Promise resolved after 62ms
results: [37, 31, 26, 62, 0]</pre>			<p>As you can see, the <strong class="source-inline">then</strong> method will be called when all the promises are resolved, and it will receive an array with the results of each promise in the order they are being added in the promise array, not by the order in which they <span class="No-Break">are resolved.</span></p>
			<p>In the previous example, all the promises were successfully resolved  as they are based on timer operation. But when we relay on promises to access external resources like files in our system or fetching data from the Internet, then we need to take into account that these resources might not be always available. For example, if the Internet is down, then one or multiple promises can fail and this will make our application to crash. Obviously, this crashing situation can be avoided if we handle the errors using a <strong class="source-inline">catch</strong> statement, but even in that case, it is very important to remember that when we use this parallelism approach, we need to take into account that if a single promise generates an error, the resolved ones will be ignored just the same as if we were using a <span class="No-Break">single promise.</span></p>
			<p>An alternative approach to <strong class="source-inline">Promise.all()</strong> is to aggregate all the requests but resolve the promise as soon as the<a id="_idIndexMarker267"/> first one is complete. This way, there’s no need to wait for the fulfillment of <span class="No-Break">all requests.</span></p>
			<p><strong class="source-inline">Promise.race()</strong>: The <strong class="source-inline">race</strong> method returns a single promise that is fulfilled or rejected as soon as one of the promises gets fulfilled or rejected. This can lead to unexpected results if not carefully managed, as the promises won’t stop running even if one of the promises was rejected or <span class="No-Break">fulfilled already:</span></p>
			<pre class="source-code">
Promise.race([
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
  randomTimeOutPromise(),
]).then((result) =&gt; {
  console.log("result:", result);
});</pre>			<p>The output of this code will be something <span class="No-Break">like this:</span></p>
			<pre class="console">
Promise resolved after 30ms
results: 30
Promise resolved after 33ms
Promise resolved after 60ms
Promise resolved after 79ms
Promise resolved after 83ms</pre>			<p>As you can see, the <strong class="source-inline">then</strong> method will be called when the first promise is resolved, and it will receive the result of the first<a id="_idIndexMarker268"/> promise that is resolved. The other promises will continue running, but the <strong class="source-inline">then</strong> method will not be <span class="No-Break">called again.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor146"/>Error handling</h2>
			<p>In the previous examples, we <a id="_idIndexMarker269"/>saw how to handle errors using the <strong class="source-inline">catch</strong> method, but there is another way to handle errors: using the <strong class="source-inline">reject</strong> function. Let’s see how this works with <span class="No-Break">this example:</span></p>
			<pre class="source-code">
const generatePromise = shouldFail =&gt; {
  return new Promise((resolve, reject) =&gt; {
    if (shouldFail) {
      return reject(new Error("Rejected!"));
    }
    resolve("Success!");
  });
};
generatePromise(true).catch(error =&gt; console.log("Error message:", error));
// Error message: Error: Rejected!
// ...</pre>			<p>It’s important to notice that the <strong class="source-inline">reject</strong> function will not stop the execution of the code, so we need to <strong class="source-inline">return</strong> the function after calling the <span class="No-Break"><strong class="source-inline">reject</strong></span><span class="No-Break"> function.</span></p>
			<p>The final approach is when we need to perform an action once a promise has been concluded, regardless of whether it was successful or rejected. It is important to remember that unhandled promise rejections can lead to runtime errors that will crash your application. We will learn more about this in <a href="B21678_15.xhtml#_idTextAnchor394"><span class="No-Break"><em class="italic">Chapter 15</em></span></a><span class="No-Break">.</span></p>
			<p><strong class="source-inline">Promise.finally()</strong>: Sometimes, we don’t care if the promise is resolved or rejected; we just want to know when the promise has been resolved or rejected. For this case, we can<a id="_idIndexMarker270"/> use the <span class="No-Break"><strong class="source-inline">finally</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
generatePromise(true)
  .then(result =&gt; console.log("Result:", result))
  .catch(error =&gt; console.log("Error message:", error))
  .finally(() =&gt; console.log("Promise settled"));</pre>			<h2 id="_idParaDest-142"><a id="_idTextAnchor147"/>Chaining promises</h2>
			<p>We can also chain promises; we can return a promise in the <strong class="source-inline">then</strong> method, and this promise will be resolved before<a id="_idIndexMarker271"/> calling the next <strong class="source-inline">then</strong> method. The <strong class="source-inline">catch</strong> method will be called if any of the promises in the chain are rejected. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
generatePromise()
  .then(generatePromise)
  .then(result =&gt; {
    return generatePromise(true);
  })
  .then(() =&gt; console.log("This will not be called"))
  .catch(error =&gt; console.log("Error message:", error));</pre>			<p>When the third <strong class="source-inline">generatePromise</strong> is called, it will return a promise that will be rejected, so the <strong class="source-inline">catch</strong> method will be called and then the last <strong class="source-inline">then</strong> won’t <span class="No-Break">be executed.</span></p>
			<p>We have been utilizing promises for some time, and the syntax can be quite verbose, requiring keywords such as <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong> consistently. A more advanced and aesthetically pleasing syntax involves using <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>. We will delve into this approach in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor148"/>Using async and await to handle asynchronous code</h1>
			<p>ES2017 introduced a new way to handle asynchronous code, the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords. These keywords are syntactic sugar for promises; they are not a new way to handle asynchronous code, but they make the code much easier to read <span class="No-Break">and write.</span></p>
			<p>Essentially, the <strong class="source-inline">async</strong> keyword is employed to define an asynchronous function, while the <strong class="source-inline">await</strong> keyword is used to pause and await the resolution of a promise within that function. Even if you use the word <strong class="source-inline">async</strong> it doesn’t make you code asynchronously, that will only occur when you actually have asynchronous code on it (a promise). To make it more simple, we can say that in order to use <strong class="source-inline">await</strong>, we need to define the code block using <strong class="source-inline">async</strong>. Let’s explore more in detail how we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor149"/>async</h2>
			<p>When a function is defined <a id="_idIndexMarker272"/>with the <strong class="source-inline">async</strong> keyword, it will always<a id="_idIndexMarker273"/> return a promise that can be handled as any regular promise. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const asyncFun = async (generateError) =&gt; {
    if (generateError) {
        throw new Error("Error generated");
    }
    return 1;
};
asyncFun().then((result) =&gt; console.log(result));
asyncFun(true).catch((error) =&gt; console.log(error));</pre>			<p>As this is syntactic sugar for promises, we can build a similar function <span class="No-Break">using promises:</span></p>
			<pre class="source-code">
const asyncFun =  (generateError) =&gt; new Promise((resolve, reject) =&gt; {
    if (generateError) {
        reject(new Error("Error generated"));
    }
    resolve(1);
});
asyncFun().then((result) =&gt; console.log(result));
asyncFun(true).catch((error) =&gt; console.log(error));</pre>			<p>Now, let’s acquaint ourselves<a id="_idIndexMarker274"/> with <strong class="source-inline">await</strong>; we’ll be able to seamlessly combine both keywords and eliminate the <a id="_idIndexMarker275"/>need to use <strong class="source-inline">then</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">catch</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor150"/>await</h2>
			<p>Let’s see how we can use<a id="_idIndexMarker276"/> the <strong class="source-inline">await</strong> keyword in order to <a id="_idIndexMarker277"/>wait <span class="No-Break">for promises:</span></p>
			<pre class="source-code">
// Promises
fetch(' https://api.demo.foo/v1/todo')
  .then(response =&gt; response.json())
  .then(json =&gt; console.log(json))
  .catch(error =&gt; console.log(error));
// Async/Await
const fetchData = async () =&gt; {
  try {
    const response = await fetch('https://api.demo.foo/v1/todo');
    const json = await response.json();
    console.log(json);
  } catch (error) {
      console.log(error);
  }
}
fetchData(); // [{userId: 1, id: 1, title: 'delectus aut autem',
completed: false}]</pre>			<p>As you can see, the code is much <a id="_idIndexMarker278"/>easier to read and write using <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>. The <strong class="source-inline">await</strong> keyword can only be used inside an <strong class="source-inline">async</strong> function. We need to use the <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block to handle <span class="No-Break">the errors.</span></p>
			<p><strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> is a mechanism provided by JavaScript that allows us to encapsulate certain code inside the <strong class="source-inline">try</strong> block, and handle any possible errors with the <strong class="source-inline">catch</strong> block. So, in the previous example, as we are doing an HTTP request we depend on external factors such as connectivity to the internet or the ability of the external server to return the information that we<a id="_idIndexMarker279"/> are asking for in our request. In our specific case, we are  “silently failing” this error because in the <strong class="source-inline">catch</strong> block we only print the information about the error, but in other scenarios we might show an alert message in the UI or trigger a retry strategy to try to perform this HTTP request again. It is important to remember that If we don’t handle errors properly, our application might crash. We will explore this topic in detail in <a href="B21678_15.xhtml#_idTextAnchor394"><span class="No-Break"><em class="italic">Chapter 15</em></span></a><span class="No-Break">.</span></p>
			<p>Now, let’s explore how we can blend <strong class="bold">Immediately Invoked Function Expressions</strong> (<strong class="bold">IIFEs</strong>) with <strong class="source-inline">async</strong> to employ this syntactic sugar even in older <span class="No-Break">Node.js versions.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor151"/>IIFEs</h2>
			<p>In some cases, we want to use the <strong class="source-inline">await</strong> keyword outside an <strong class="source-inline">async</strong> function, for example, when we are using the <strong class="source-inline">await</strong> keyword in the top level of a module. In this case, we can use an IIFE to wrap<a id="_idIndexMarker280"/> the <strong class="source-inline">await</strong> keyword inside an <strong class="source-inline">async</strong> function. An IIFE is a function that is executed immediately after it is created. It is a design pattern that is used to avoid polluting the global scope with variables and functions. In the subsequent example, we can observe the <span class="No-Break">fundamental syntax:</span></p>
			<pre class="source-code">
(function () {
  // ... some code here
})();</pre>			<p>The idea is to create an anonymous function and execute it immediately after it is created. In order to achieve this, we need to wrap the function between parentheses, and then add another pair of parentheses to execute the <span class="No-Break">function: </span><span class="No-Break"><strong class="source-inline">(...)()</strong></span><span class="No-Break">.</span></p>
			<p>We can use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> inside an <span class="No-Break">IIFE easily:</span></p>
			<pre class="source-code">
(async () =&gt; {
    const response = await fetch(' https://api.demo.foo/v1/todo ');
    const json = await response.json();
    console.log(json);
})()</pre>			<p>This guarantees that the code will be executed immediately after it is created, and we can use the <strong class="source-inline">await</strong> keyword inside <span class="No-Break">the IIFE.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor152"/>Summary</h1>
			<p>In this chapter, we learned about asynchronous programming in JavaScript. We explored asynchronous APIs such as <strong class="source-inline">setTimeout</strong> and <strong class="source-inline">fetch</strong>, and we learned how to handle asynchronous code using callbacks, promises, and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>. Additionally, we learned about the error first callback convention and how to prevent callback hell using named functions and promises. Finally, we learned how to manage promises, how to bulk operations using the <strong class="source-inline">Promise.all</strong> and <strong class="source-inline">Promise.race</strong> methods, and how to use the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords to handle asynchronous code in a <span class="No-Break">cleaner way.</span></p>
			<p>In the next chapter, we will learn about HTTP and how the modern web works using <span class="No-Break">REST APIs.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor153"/>Further reading</h1>
			<p>Asynchronous programming in JavaScript is a broad topic that necessitates a considerable amount of time to master and comprehend fully. With the following links, you will discover valuable resources that will aid you in delving deeper into the subjects covered in <span class="No-Break">th<a id="_idTextAnchor154"/>is chapter:</span></p>
			<ul>
				<li><em class="italic">JavaScript Promise in 100 </em><span class="No-Break"><em class="italic">Seconds</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=RvYYCGs45L4"><span class="No-Break">https://www.youtube.com/watch?v=RvYYCGs45L4</span></a></li>
				<li><em class="italic">Asynchrony: Under the Hood – Shelley Vohr – JSConf </em><span class="No-Break"><em class="italic">EU</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=SrNQS8J67zc"><span class="No-Break">https://www.youtube.com/watch?v=SrNQS8J67zc</span></a></li>
				<li><em class="italic">async/await in JavaScript – What, Why and How – Fun Fun </em><span class="No-Break"><em class="italic">Function: </em></span><a href="https://www.youtube.com/watch?v=568g8hxJJp4"><span class="No-Break">https://www.youtube.com/watch?v=568g8hxJJp4</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer021" class="Content">
			<h1 id="_idParaDest-149" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor155"/>Part 2: Node.js Ecosystem and Architecture</h1>
			<p>In <em class="italic">Part 2</em>, you will learn how to use the Node.js core libraries and third-party libraries by using the vast npm ecosystem ecosystem. Also, you will learn how to use and implement event-driven architectures in detail, and you will understand how to use testing and implement unit testing in <span class="No-Break">your projects.</span></p>
			<p>This part includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21678_05.xhtml#_idTextAnchor156"><em class="italic">Chapter 5</em></a>, <em class="italic">Node.js Core Libraries</em></li>
				<li><a href="B21678_06.xhtml#_idTextAnchor171"><em class="italic">Chapter 6</em></a>, <em class="italic">External Modules and npm</em></li>
				<li><a href="B21678_07.xhtml#_idTextAnchor206"><em class="italic">Chapter 7</em></a>, <em class="italic">Event-Driven Architecture</em></li>
				<li><a href="B21678_08.xhtml#_idTextAnchor218"><em class="italic">Chapter 8</em></a>, <em class="italic">Testing in Node.js</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer022" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>