- en: Chapter 3. Test Assertions, Specs, and Suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a Backbone.js application integrated into our budding test infrastructure
    and a rough test plan underway, we will now begin expanding our application''s
    test coverage. In this chapter, we will introduce some fundamental testing tools
    and test more parts of the Backbone.js application in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Surveying the Mocha and Chai test library interfaces and styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Chai assertion library API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Mocha runner and the Backbone.js application for tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating Mocha specifications into test suites and preparing test state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing test specifications in Mocha, beginning with Backbone.js collection
    specs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing asynchronous application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing specs and HTML test fixtures for Backbone.js views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with software/test development pitfalls and learning how to write testable
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a test style that fits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocha and Chai both provide different library interfaces for writing tests.
    This conveniently allows developers to choose an appropriate test paradigm or
    style for different projects while still leveraging the same underlying functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha test interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mocha currently offers four interfaces for test suites and specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Behavior-Driven Development** (**BDD**) interface: This interface uses
    test constructs similar to those popularized by the Ruby RSpec framework ([http://rspec.info/](http://rspec.info/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Test-Driven Development** (**TDD**) interface: This interface uses more
    traditional unit test keywords such as `suite` and `test`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **exports** interface: This interface utilizes a modular format familiar
    to Node.js/CommonJS developers, implementing the test functionality as properties
    of a `module.exports` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **QUnit**-styled interface: This interface uses a flat declaration paradigm
    taken from the popular QUnit test framework ([http://qunitjs.com/](http://qunitjs.com/)).
    A suite in this style is declared before and at the *same level* as a test instead
    of *containing* tests like the other interfaces just discussed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chai assertion styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chai provides two assertion styles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **BDD** style: This style enables dot-notation chains of assertions such
    as `expect("foo").to.be.a("string").and.equal("foo")` using either the `expect`
    function or the `should` object prototype extension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **assert** style: This style uses single function assertions attached to
    the `assert` object, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although `expect` and `assert` are functionally equivalent, there are some important
    differences between the BDD constructs `expect` and `should`. Essentially, because
    `should` patches the object prototype, it will not work for certain types of actual
    values (such as `null` and `undefined`) and is incompatible with Internet Explorer
    9\. For these reasons, our Chai BDD examples will use `expect` over `should`.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out some different styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at examples of the two most common interfaces for Mocha and Chai—BDD
    and TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha and Chai BDD interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Mocha BDD interface provides four main functional units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`before()`: This is a setup that occurs *once* before all the tests within
    a suite are run. Mocha also provides a `beforeEach()` function that runs before
    *each* test in a suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after()`: This is a setup that occurs *once* after all tests in a suite are
    run, with the `afterEach()` alternative that runs before *each* test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describe()`: This specifies a test suite and can be nested within other `describe()`
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it()`: This defines a single test function containing one or more assertions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chai's BDD style uses `expect` or `should` to make dot-notation assertion chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a basic test file `chapters/03/test/js/spec/bdd.spec.js`, which
    uses all of these components. We name the suite with `describe()`, add/remove
    a function with `before()`/`after()`, and test it with an `it()` specification
    declaration. We chain together two Chai assertions with an `and` helper, producing
    a composite assertion that reads naturally as "expect the result of `hello()`
    to be a string and equal to text ''hello world''":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test driver web page (`chapters/03/test/test-bdd.html` in the examples)
    adds the Chai `expect` function into the global namespace for convenience and
    configures Mocha to use the BDD style. The relevant configuration snippet is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Mocha TDD and Chai assert styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Mocha TDD interface uses different names for the same basic units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`suiteSetup()` and `setup()`: These are aliases for `before()` and `beforeEach()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suiteTeardown()` and `teardown()`: These are aliases for `after()` and `afterEach()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suite()`: This specifies a test suite (`describe()` in BDD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test()`: This defines a single test function (`test()` in BDD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chai assert style is usually associated with TDD-style tests and provides
    an assert object with single function assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our TDD test file `chapters/03/test/js/test/tdd.js` provides the same test
    setup and assertion series as the BDD version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The driver web page only differs in two configuration lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Opening up `chapters/03/test/test-tdd.html` in a browser should show exactly
    the same test results as the previous BDD example.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on the project style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The style options in Mocha and Chai offer developers a lot of flexibility in
    choosing test paradigms while still leveraging the same underlying test infrastructure.
    In this book we prefer the BDD style for both Mocha and Chai for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Chai `expect` assertion chains read in a natural language format that often
    obviates the need for separate test comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mocha BDD interface components facilitate narrative descriptions of behaviors
    such as "this describes a number calculator" and "it should sum two numbers"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BDD interface is quite popular in the modern JavaScript testing ecosystem
    and encourages developers to describe the *behavior* of the code under test rather
    than to just identify the internal details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonetheless, if you prefer any of the other styles, please use whatever feels
    most natural. All of the test code examples in this book can be translated between
    the various Mocha and Chai interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: A tour of the Chai assertion library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Chai test library provides a robust set of assertions and helpers to aid
    the legibility and organization of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Chai's own unit tests for `expect` (at [https://github.com/chaijs/chai/blob/master/test/expect.js](https://github.com/chaijs/chai/blob/master/test/expect.js))
    provide a great starting point from which the API can be explored. Chai conveniently
    uses Mocha for its test framework (configured with the TDD interface). So the
    entire test suite should feel very familiar.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use a series of assertions to introduce most of the
    Chai BDD APIs. The assertion examples are accumulated into a single driver file
    for this chapter—`chapters/03/test/test-chai.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chai provides aliases for many of the assertions that we will discuss in this
    section. For example, the deep equality assertion `eql` is also available as `eqls`
    and `deep.equal`. See the Chai API documentation for a full listing of aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining objects and assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chai's BDD interface exposes objects that can be chained together to make test
    assertions more comprehensible. We will walk through some basic examples available
    in the file `chapters/03/test/js/spec/chai-chains.spec.js`.
  prefs: []
  type: TYPE_NORMAL
- en: As an introductory example, the assertion `expect("foo").to.be.a("string")`
    uses the chain objects `to` and `be`, which simply proxy through the eventual
    assertion. In this manner, Chai allows us to add any of the chain objects `to`,
    `be`, `been`, `is`, `that`, `and`, `have`, `with`, `at`, and `of` to form more
    naturally readable assertion statements. The statements `a` and `an` are available
    as both assertion chains and comparison functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these statements to create language chain assertions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As all of the statements are equivalent, the highlighted language chains in
    the previous code demonstrate the many different ways of stating the same assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chai also provides language chain objects that *do* modify the ultimate assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '`not`: This negates any following assertions. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`deep`: This sets the deep flag for equality checks. A raw equality check performs
    an identity test, which asserts that the two variables are the *same* object in
    the process memory. With the deep flag, Chai instead asserts that the two variables
    have the same property values, even if they are *different* underlying objects.
    For example, `expect({foo: "bar"}).to.equal({foo: "bar"})` fails an object identity
    test while `expect({foo: "bar"}).to.deep.equal({foo: "bar"})` succeeds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, most other Chai BDD assertion statements are chainable. The following
    example groups several assertion chains together with the `and` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With these basic language chains and helpers, we have a foundation for writing
    readable assertion statements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to chain assertions together when it makes sense for the
    purpose of developer comprehension and writing concise and terse test code. At
    the same time, separate `expect()` statements can often be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Basic value assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chai provides various assertion properties to check input values (see `chapters/03/test/js/spec/chai-values.spec.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`ok`: Value is truthy (for a quick introduction to JavaScript''s permissive
    notion of conditional truth and equality, see [http://www.sitepoint.com/javascript-truthy-falsy/](http://www.sitepoint.com/javascript-truthy-falsy/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`exist`: Value is neither `null` nor `undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`true`: Value is exactly `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`false`: Value is exactly `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`null`: Value is exactly `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`undefined`: Value is exactly `undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`arguments`: Value is the special JavaScript `arguments` object, which contains
    a list of parameters for the current function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comparing values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chai has a diverse array of comparison functions to assess input values (see
    `chapters/03/test/js/spec/chai-comparisons.spec.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`equal`: Strict (`===`) equality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`eql`: Deep equality—equivalent to `deep.equal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`above`: The actual value is greater than the expected value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`least`: The actual value is greater than or equal to the expected value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`below`: The actual value is less than the expected value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`most`: The actual value is less than or equal to the expected value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`within`: The actual value is within the range of the expected values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`closeTo`: The actual value is within the delta of the expected value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`match`: The actual string value is matched by the expected regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`string`: The actual string value contains the expected substring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`satisfy`: The evaluator function takes the actual value as a parameter and
    returns `true` if the assertion should pass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Object and array validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chai provides some useful assertions tailored to objects and arrays (see `chapters/03/test/js/spec/chai-objects.spec.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`a`: When called as a function, this checks the object type building on JavaScript''s
    native `typeof` test, with additional support for correctly inferring objects
    and arrays. Note that when `a` (or `an`) is used as an object property, it acts
    as a language chain instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`instanceof`: Checks whether the object is an instance of an expected constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`property`: Checks if an expected property exists in an object and, optionally,
    if the property''s value matches an expected value. When used in conjunction with
    the `deep` language chain, an object structure can be navigated via the dot or
    array notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ownProperty`: Checks for the presence of a direct property on an object using
    the JavaScript `hasOwnProperty` test, without looking up the object''s prototype
    chain for an inherited property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`length`: Checks the `length` property of an array or object (such as a string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`contain`: Checks for the presence of an object in an array or a substring
    within a string. Note that `contain` (and `include`) can alternatively be used
    as a language chain with `keys`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`keys`: Checks that an object includes all of the expected property names.
    The assertion verifies only a subset of expected property names when combined
    with the `include` or `contain` language chains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chai can also check abnormal code functionality, notably trapping and verifying
    program exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `throw` assertion takes a function as an input that is expected to throw
    an exception when called. The resulting error is then matched against a constructor
    class (for example, `Error`) or a message string/regular expression (for example,
    `/message/`). Note that a function reference (for example, `bad`) is passed to
    the assertion rather than a called function (for example, `bad()`). This enables
    Chai to call the function internally, trap any exceptions, and verify the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Getting the application and tests ready to run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the Chai assertion library API under our belts, it is time
    to write and organize the tests. While we have incidentally covered much of this
    material already, the concise core of a Mocha test infrastructure includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test runner**: Configures the overall test run and report'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test suites**: One or more organization units grouping many specifications/tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setup**/**Teardown**: Setting up a state for each test or suite run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specifications**: Writing the test functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting at the highest level, we look at our test driver web page. As previously
    discussed, this is where our core application libraries, test libraries, and test
    specifications are set up and included. All of the Backbone.js application tests
    in the rest of this chapter are incorporated into the `chapters/03/test/test.html`
    driver page.
  prefs: []
  type: TYPE_NORMAL
- en: The Mocha test runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Mocha `setup()` function controls the overall parameters and environment
    for all test suite and specification executions. The function should be called
    once before execution starts (for example, `mocha.run()`) in the test driver web
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The default settings are quite usable for Backbone.js testing and we use the
    previous code for nearly all of the tests in this book. However, there are many
    more options available, which are described at [http://visionmedia.github.io/mocha/](http://visionmedia.github.io/mocha/).
    Here is an arbitrary sampling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Reconfiguring the application for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backbone.js applications often need specific test-friendly configurations in
    order to make the test environment predictable and to avoid stomping on real data.
    Backend information (for example, host addresses and ports) is often different
    in the development and testing phases. Thus, it is a good practice to abstract
    all of this information into a common file so that we can easily switch values
    from one central location to another.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative and complementary approach for creating a workable test environment
    is to fake out configuration details and dependencies with a library such as Sinon.JS.
    The two Sinon.JS abstractions that can help us here are stubs and mocks, both
    of which can replace object method behaviors during tests. (We will introduce
    and discuss these concepts in detail in [Chapter 5](ch05.html "Chapter 5. Test
    Stubs and Mocks"), *Test Stubs and Mocks*.)
  prefs: []
  type: TYPE_NORMAL
- en: In the following datastore configuration examples, we could use a Sinon.JS stub
    to replace the entire datastore with test-specific simulation code. The stub would
    allow us to use normal application configurations while ensuring that we do not
    modify the real datastore. As an added benefit to this approach, stubbing and
    mocking external dependencies can often make tests run faster, particularly if
    the fake replaces a relatively slow application behavior (for example, network
    communication).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Notes application, we require a unique `localStorage` name for the collection,
    which we specify in the configuration file `notes/app/js/app/config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code populates the `App.Config` namespace with `App.Config.storeName`,
    which we then use for the `App.Collections.Notes` collection in `notes/app/js/app/collections/notes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup, the live application will save data to the `notes` store in
    `localStorage`. However, in our tests we will want to add, remove, and mutate
    the note data without overwriting our development-friendly datastore. So, by adding
    an extra configuration directive in our application''s test driver page, we can
    set the test-only store name to `notes-test` using the Underscore.js `extend()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: By including `config.js` first and then overriding the specific values, we make
    the *other* unmodified configuration values available during the tests. With this
    scheme, we now have a completely separate Backbone.js test datastore, which we
    can change without affecting our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing topics and specifications into test suites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Organizing test code into topics and application components is an important
    step in developing an overall test architecture. To this end, Mocha provides the
    `describe()` test suite function to group logical collections of test specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in `App.Collections.Notes` we might start with two subgroups of
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests that create empty collections and verify the initial default state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests that modify the collection with new `App.Models.Note` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transforming this list into a set of nested Mocha test suites would give us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We have two levels of `describe()` statements here, although Mocha allows a
    much deeper nesting of suites.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up and winding down tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we try to isolate behavior for our test specifications as a general
    practice, tests often have common setup and teardown needs. For example, if a
    group of specs all test the same object, it may make the most sense to create
    the object once and share it with all of the specs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context/member variables in Mocha**'
  prefs: []
  type: TYPE_NORMAL
- en: Mocha allows test code to attach values to the `this` context object for use
    in other sections of the test run. This allows us to share variables across tests
    without having to declare and manage global or higher-level scoped variables.
    A common use of this feature is to add a variable such as `this.myCollection`
    in a `before()` setup statement for a group of tests and then remove it in the
    `after()` statement for the group.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha provides the functions `before()`, `beforeEach()`, `after()`, and `afterEach()`
    to help us with test state management. As mentioned previously, the `before()`/`after()`
    functions run *once* before and *once* after all the tests within a suite. The
    `beforeEach()`/`afterEach()` functions run before and after *each* test within
    a suite.
  prefs: []
  type: TYPE_NORMAL
- en: With these four constructs, we can create nuanced state management for our Mocha
    tests. The setup/teardown functions operate at the level of each test suite. This
    means that nested test suites can provide their own additional setup/teardown
    functions. For example, Mocha will faithfully run each `before()` statement as
    it traverses deeper into the `describe()` statements before executing the first
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another good reason to use the setup/teardown functions is that they *always*
    run—even when the test specs fail or throw exceptions. This prevents a single
    test failure from affecting the data state of other tests in the run and causing
    spurious test failures.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.js collection tests often benefit from using setup and teardown helpers
    to create an initial data state. Usually, this means adding some starting records
    (called data fixtures when loaded from a separate data file) and restoring the
    datastore to a pristine state after the tests have modified the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the test driver page, we have already configured the `App.Collections.Notes`
    class to use a test-only datastore. The `Backbone.localStorage` adapter has an
    internal method `_clear()` that clears the underlying browser storage associated
    with the collection, which we will use to reset our data state in the tests. The
    resulting data sandbox is ready for the following test scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Wipe any existing collection data on suite setup, add a context variable for
    a single collection, and remove the collection on teardown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `modification` suite, add an initial `App.Models.Note` object to the
    collection and wipe the collection after each test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the setup and teardown functions for the test suite looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines in the previous code snippet illustrate the `before()`/`after()`
    calls for all tests in the overall test suite and the `beforeEach()`/`afterEach()`
    calls for only the subsuite `modification`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Mocha test specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With practically everything else in place, we finally turn to writing test
    specifications. Mocha BDD specifications are declared using the `it()` function
    with the following function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The description string, by convention, is a statement of the expected behavior
    under test, and the callback function executes the tests. For example, assuming
    we have an empty `this.notes` collection variable, a test of the default values
    in `App.Collections.Notes` can be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous behavior in tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although basic test specifications are quite simple, flow control complications
    arise when testing asynchronous application code. Given that the Backbone.js application's
    behavior is quite often asynchronous/event-driven, we need to have a solid and
    straightforward test approach.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Mocha provides an asynchronous test function parameter that is
    used to signal that the test is asynchronous. If a parameter is provided in a
    test callback (it is named `done` by convention), Mocha will delay the test completion
    until either `done` is called or the test times out.
  prefs: []
  type: TYPE_NORMAL
- en: 'One asynchronous behavior that we can test in a Backbone.js collection is that
    the `reset` event fires after a `fetch()` method call on the collection. Here
    we create an empty `App.Collections.Notes` object, fetch its backend data, and
    confirm that the event has fired. After all of this is verified, we add a call
    to `done()` to signal that the test has completed successfully. If the `reset`
    event never fires, then `done()` won''t be called and the test will time out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With the extra `done` parameter, we can now run a series of asynchronous assertions
    within a single specification before the test completes.
  prefs: []
  type: TYPE_NORMAL
- en: Some Backbone.js collection tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can write asynchronous specifications, we will finish off our test
    suite for the Notes collection. Keeping in mind our test goals for Backbone.js
    collections from [Chapter 2](ch02.html "Chapter 2. Creating a Backbone.js Application
    Test Plan"), *Creating a Backbone.js Application Test Plan* (that is, modifying
    models, firing events, and synchronizing data), we will create the following specs
    for `App.Collections.Notes` (shown in an outline form here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Creating an empty test outline such as the previous code is a good exercise
    and practice during application development. For example, as part of a test-first
    development process, we can first write the `describe` and `it` declarations without
    callbacks to specify the world of program behavior for the relevant application
    component. Once we are satisfied that the outline approximates the expected use
    cases of the component, we can move on to filling out tests and writing the application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Helpfully, Mocha will treat spec declarations without functions (as shown in
    the previous code snippet) as pending tests. Pending specs are visually distinguished
    from the ordinary tests with different colors in a Mocha HTML test report. With
    pending tests, a developer can scan a test report more easily for unfinished specs
    and then implement the necessary test and application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let''s implement the specifications to complete the test
    file `chapters/03/test/js/spec/collections/notes.spec.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have omitted some of the spec functions from the following code (and elsewhere
    in this book) for brevity and readability. The full spec implementations for `App.Collections.Notes`
    and other Notes test suites are available in the companion code samples for this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This final test file provides a reasonable skeleton using all of the different
    Mocha and Chai parts we have discussed in this chapter. We can see our tests in
    action by opening a browser to the driver page `chapters/03/test/test.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and supporting Backbone.js views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having now created test suites for Backbone.js models and collections, we turn
    to expanding our test coverage to a Backbone.js view.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes application single note view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first Backbone.js view we will examine is `App.Views.NoteView`. This view
    is responsible for rendering `App.Models.Note` Markdown data into full HTML as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notes application single note view](img/5248OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: View rendered Markdown
  prefs: []
  type: TYPE_NORMAL
- en: 'The underlying model data for the figure includes the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`text`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `text` attribute data transforms to HTML as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`App.Views.NoteView` is responsible for performing this conversion. The `notes/app/js/app/views/note-view.js`
    file first provides an `initialize` function, which sets model listeners to re-render
    or clean up the view and then kicks off `render()`. The `render` function uses
    the Showdown library to convert the model `text` Markdown data into HTML and then
    passes the finished data to the view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This view includes an Underscore.js template (`App.Templates["template-note-view"]`
    in `notes/app/js/app/templates/templates.js`), which inserts the `title` and `text`
    data into HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering the model data into an HTML form with `App.Views.NoteView.render()`
    gives us the following resulting HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have introduced a simple view to work with, we will examine how
    to test its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HTML fixtures for view tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Backbone.js application tests that we have written up to this point don't
    interface with the DOM or HTML of a web page. This simplifies our test environment
    because the application's web page (for example, `index.html`) is very different
    from our test driver page (for example, `test.html`). However, Backbone.js views
    nearly always involve a healthy amount of DOM interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, we need an HTML test fixture—one or more DOM elements in the test
    driver page that we can interact with and modify during tests. At the same time,
    we don''t want the fixture HTML causing havoc in the test code of the driver page.
    Accordingly, we create a single, hidden `div` element in the `chapters/03/test/test.html`
    driver page for our application view tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, our tests can reference `$("#fixtures")` in jQuery and get access to the
    fixture container. The tests can then add elements as needed to exercise any desired
    view/DOM interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Advanced HTML fixtures**'
  prefs: []
  type: TYPE_NORMAL
- en: We have scratched only the surface of HTML fixtures in this chapter. More sophisticated
    fixture schemes and libraries exist, with features such as sandboxing application
    HTML code within an iframe to avoid test code cross-pollination and loading HTML
    fixture code from external application files. Two promising management libraries
    that are compatible with Mocha are jsFixtures ([https://github.com/kevindente/jsFixtures](https://github.com/kevindente/jsFixtures))
    and js-fixtures ([https://github.com/badunk/js-fixtures](https://github.com/badunk/js-fixtures)).
  prefs: []
  type: TYPE_NORMAL
- en: Walking through the view test suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make our way through the code in `chapters/03/test/js/spec/views/note-view.spec.js`,
    which is the test suite for `App.Views.NoteView`. Recalling the Backbone.js view
    testing goals in [Chapter 2](ch02.html "Chapter 2. Creating a Backbone.js Application
    Test Plan"), *Creating a Backbone.js Application Test Plan*, we will check if
    the view renders appropriate HTML using a model and template, binds HTML results
    to the expected DOM location, and interacts correctly with the application events.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Writing tests on your own for the examples**'
  prefs: []
  type: TYPE_NORMAL
- en: To make the narrative in this book flow better, we will follow a general scheme
    of presenting a Backbone.js application component and then walking through tests
    that illustrate a particular lesson, technique, or tool. Unfortunately, this is
    the reverse of the recommended Test-Driven Development process, which writes tests
    describing application behavior first, then writes the implementation, and iterates
    until the overall behavior is correct.
  prefs: []
  type: TYPE_NORMAL
- en: For your work with this book, we strongly encourage you to take a moment, before
    the book presents test examples to design and implement your own tests for the
    sample application components. After writing your own tests, you can move on to
    the book's examples to check your work and identify additional testing ideas and
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The suite begins with a `describe` declaration and a setup/teardown code. At
    the commencement of the suite execution, a view fixture (`$("<div id=''note-view-fixture''></div>")`)
    is created and stored in `this.$fixture`. Our setup for each test (`beforeEach()`/`afterEach()`)
    binds the new `this.$fixture` fixture to the HTML fixture holder `$("#fixtures")`
    and creates an `App.Views.NoteView` object with an `App.Models.Note` model. After
    all tests in the suite are done, the fixtures holder `$("#fixtures")` is emptied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With these variables and DOM elements available, we can test whether a default
    model renders the expected HTML, using jQuery. Note that because its `initialize`
    function calls `render`, instantiating an `App.Views.NoteView` object adds the
    rendered HTML to our DOM fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The second spec changes the model attributes `title` and `text` to render more
    complex HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part is waiting until *after* the model listeners call `render()`
    and update the DOM to inspect the new HTML values. Our technique here is to observe
    that `render()` already listens to the model event `change` and add an additional
    one-time `once()` listener on this event to check the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, note that this is a brittle way to handle the asynchronous nature
    of the test behavior. The rendering code could take more time to finish than our
    assertions, thereby breaking the test. A better solution is to wait on the `render()`
    function call to finish and then run the test code—a technique that we can more
    readily perform with Sinon.JS spies, stubs, and mocks, which are discussed in
    detail in the subsequent chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating and running the application tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finishing up the test driver page for both the collection and view tests, we
    integrate the necessary script includes and HTML test fixtures in `chapters/03/test/test.html`
    (shown in the relevant part in the following code snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening a web browser to `chapters/03/test/test.html`, we can see the full
    test report for the collection and view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Aggregating and running the application tests](img/5248OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test report
  prefs: []
  type: TYPE_NORMAL
- en: Test development tips, tricks, and hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we continue to explore the theory and practice of testing Backbone.js
    applications, it remains true that creating test architectures and writing good
    test specifications are more of an art than an exact science. Many lessons can
    only be learned through experience, particularly as your applications encounter
    bugs and development mishaps. In the meantime, we can start you off with some
    techniques and suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating and excluding tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application development is a journey guaranteed to include inexplicable errors,
    sudden application crashes, and complex test failures. When these pitfalls happen,
    it is important to have some directions on how to debug the problems and move
    things forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common scenario during software development is when application changes break
    one or more existing unit tests. In this case, a good practice is to run the test
    suite one test at a time, fix the test, and then move on to the rest. Mocha provides
    two avenues to help in this regard:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grep**: As we have discussed in [Chapter 1](ch01.html "Chapter 1. Setting
    Up a Test Infrastructure"), *Setting Up a Test Infrastructure*, you can click
    on a single test in the test reporter HTML page or directly navigate to a test
    page URL with a grep query parameter appended, such as `test.html?grep=PATTERN`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Only**: Another alternative is to temporarily modify your Mocha test specifications
    to run only a single test using the `only` helper, skipping all other tests and
    suites. Let''s look at an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the other side of this scenario, sometimes we want to ignore a few failing
    tests while still using the rest of the test infrastructure. In this case, we
    look towards `skip`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Skip**: The `skip` modifier omits a single specification from the test run
    and can be applied to multiple specifications. Skipped tests are also considered
    pending and can be visually distinguished in a Mocha HTML test report:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Writing testable application code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beyond the practical aspects of writing tests, an equally important component
    of developing a test infrastructure is writing testable application code. The
    topic of testable JavaScript code is quite large—we will only introduce the issue
    here and start you off with a general goal of developing application code that
    works in harmony with the tests that support it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A comprehensive treatment of the subject is available in the book *Testable
    JavaScript* by *Mark Ethan Trostler* ([http://shop.oreilly.com/product/0636920024699.do](http://shop.oreilly.com/product/0636920024699.do)),
    which covers topics such as application code complexity, event-based architectures,
    and debugging. Also consider general JavaScript application guides such as *Maintainable
    JavaScript* by *Nicholas Zakas* ([http://shop.oreilly.com/product/0636920025245.do](http://shop.oreilly.com/product/0636920025245.do))
    and the seminal *JavaScript: The Good Parts* by *Douglas Crockford* ([http://shop.oreilly.com/product/9780596517748.do](http://shop.oreilly.com/product/9780596517748.do)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Backbone.js application development hints and good practices for testable
    code include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decouple components and limit dependencies**: Many Backbone.js components
    have optional dependencies on other components. For example, a Backbone.js view
    can optionally have a model declared in the view class (for example, `model: Foo`)
    or a model object can be passed to a view on instantiation (for example, `new
    View({model: foo})`). The latter technique often opens up more opportunities for
    injecting mocks or test-friendly models into the view code. The same logic also
    applies to the `el` property in Backbone.js views—it is often more test-friendly
    to provide values via a view object instance than in the view class definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolate configuration information**: Any pure configuration data should get
    its own application file and facilitate the overriding of specific configurations.
    Canonical examples include the backend server host and port information, logging
    levels, and in the case of the Notes application, the name of the `localStorage`
    datastore. The previous examples that override `notes/app/js/app/config.js` provide
    a good introduction on how to both create a configuration file and supersede values
    for testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decompose large functions**: Monolithic functions that try to do everything
    are often difficult to test. Break up large functions into smaller ones, test
    them, and then aggregate the smaller functions into your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid hidden state**: Using techniques such as closures and anonymous functions,
    JavaScript permits classes and code to have a state that is unchangeable and inaccessible
    to other parts of the application and tests. For example, if a class has an internal
    counter, make it a member variable and not a closure-wrapped variable. While this
    is something of a debated topic, it is generally preferred to expose some amount
    of internal state for test (and application) use. At the same time, our tests
    should focus on the application *behavior* and avoid deliberately using a internal
    state that is not part of the overall expected functioning of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that these tips are heuristics and not hard and fast rules. Many
    development situations will favor doing exactly the opposite of one or more of
    these suggestions. Hopefully, some of these guidelines will help make your early
    application decisions easier to live with as your application and test code bases
    grow over time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dug into the Chai and Mocha test frameworks, starting with
    a tour of testing interfaces. We explored the many assertion statements available
    in Chai, then examined the creation of full Mocha test suites with setup/teardown,
    application configuration, and test specifications for Backbone.js components.
    Finally, we reviewed debugging tips and guidelines for a more test-friendly software
    development lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our application has starting test coverage for some Backbone.js
    models, collections, and views. We will continue covering different parts of our
    Backbone.js application while introducing new topics in the subsequent chapters
    and work up to a final application test collection that aggregates all of our
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get more familiar with the Sinon.JS library. We
    will use test spies to verify program behavior and introspect how functions are
    called and respond within a Backbone.js application.
  prefs: []
  type: TYPE_NORMAL
