- en: Chapter 3. Test Assertions, Specs, and Suites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。测试断言、规范和套件
- en: 'With a Backbone.js application integrated into our budding test infrastructure
    and a rough test plan underway, we will now begin expanding our application''s
    test coverage. In this chapter, we will introduce some fundamental testing tools
    and test more parts of the Backbone.js application in the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Backbone.js 应用程序集成到我们正在发展的测试基础设施中，并且有一个粗略的测试计划进行中，我们现在将开始扩展我们应用程序的测试覆盖率。在本章中，我们将介绍一些基本的测试工具，并在以下主题中测试
    Backbone.js 应用程序的更多部分：
- en: Surveying the Mocha and Chai test library interfaces and styles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述 Mocha 和 Chai 测试库的接口和风格
- en: Introducing the Chai assertion library API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Chai 断言库 API
- en: Configuring the Mocha runner and the Backbone.js application for tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Mocha 运行器和 Backbone.js 应用程序以进行测试
- en: Aggregating Mocha specifications into test suites and preparing test state
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Mocha 规范聚合到测试套件中并准备测试状态
- en: Writing test specifications in Mocha, beginning with Backbone.js collection
    specs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Backbone.js 集合规范开始编写 Mocha 测试规范
- en: Testing asynchronous application code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试异步应用程序代码
- en: Writing specs and HTML test fixtures for Backbone.js views
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Backbone.js 视图编写规范和 HTML 测试固定装置
- en: Dealing with software/test development pitfalls and learning how to write testable
    code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对软件/测试开发中的陷阱，并学习如何编写可测试的代码
- en: Choosing a test style that fits
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择适合的测试风格
- en: Mocha and Chai both provide different library interfaces for writing tests.
    This conveniently allows developers to choose an appropriate test paradigm or
    style for different projects while still leveraging the same underlying functionality.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 和 Chai 都为编写测试提供了不同的库接口。这方便开发者为不同的项目选择合适的测试范式或风格，同时仍然利用相同的底层功能。
- en: Mocha test interfaces
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha 测试接口
- en: 'Mocha currently offers four interfaces for test suites and specifications:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 目前为测试套件和规范提供四个接口：
- en: 'The **Behavior-Driven Development** (**BDD**) interface: This interface uses
    test constructs similar to those popularized by the Ruby RSpec framework ([http://rspec.info/](http://rspec.info/)).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）接口：此接口使用与 Ruby RSpec 框架推广的类似测试构造（[http://rspec.info/](http://rspec.info/))。'
- en: 'The **Test-Driven Development** (**TDD**) interface: This interface uses more
    traditional unit test keywords such as `suite` and `test`.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）接口：此接口使用更传统的单元测试关键字，如 `suite` 和 `test`。'
- en: 'The **exports** interface: This interface utilizes a modular format familiar
    to Node.js/CommonJS developers, implementing the test functionality as properties
    of a `module.exports` object.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exports** 接口：此接口利用 Node.js/CommonJS 开发者熟悉的模块格式，将测试功能实现为 `module.exports`
    对象的属性。'
- en: 'The **QUnit**-styled interface: This interface uses a flat declaration paradigm
    taken from the popular QUnit test framework ([http://qunitjs.com/](http://qunitjs.com/)).
    A suite in this style is declared before and at the *same level* as a test instead
    of *containing* tests like the other interfaces just discussed.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QUnit** 风格的接口：此接口使用来自流行的 QUnit 测试框架的平面声明范式（[http://qunitjs.com/](http://qunitjs.com/))。在此风格中，套件是在测试之前和与测试相同的级别上声明的，而不是像其他接口那样包含测试。'
- en: Chai assertion styles
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chai 断言风格
- en: 'Chai provides two assertion styles:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 提供两种断言风格：
- en: 'The **BDD** style: This style enables dot-notation chains of assertions such
    as `expect("foo").to.be.a("string").and.equal("foo")` using either the `expect`
    function or the `should` object prototype extension'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BDD** 风格：此风格允许使用 `expect` 函数或 `should` 对象原型扩展启用断言的点符号链，例如 `expect("foo").to.be.a("string").and.equal("foo")`。'
- en: 'The **assert** style: This style uses single function assertions attached to
    the `assert` object, such as:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**assert** 风格：此风格使用附加到 `assert` 对象的单个函数断言，例如：'
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although `expect` and `assert` are functionally equivalent, there are some important
    differences between the BDD constructs `expect` and `should`. Essentially, because
    `should` patches the object prototype, it will not work for certain types of actual
    values (such as `null` and `undefined`) and is incompatible with Internet Explorer
    9\. For these reasons, our Chai BDD examples will use `expect` over `should`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `expect` 和 `assert` 在功能上等效，但 BDD 构造 `expect` 和 `should` 之间有一些重要的区别。本质上，因为
    `should` 会修补对象原型，所以它不适用于某些类型的实际值（例如 `null` 和 `undefined`），并且与 Internet Explorer
    9 不兼容。因此，我们的 Chai BDD 示例将使用 `expect` 而不是 `should`。
- en: Trying out some different styles
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一些不同的风格
- en: Let's look at examples of the two most common interfaces for Mocha and Chai—BDD
    and TDD.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Mocha 和 Chai 两个最常见接口的示例——BDD 和 TDD。
- en: Mocha and Chai BDD interfaces
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha和Chai BDD接口
- en: 'The Mocha BDD interface provides four main functional units:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha BDD接口提供了四个主要功能单元：
- en: '`before()`: This is a setup that occurs *once* before all the tests within
    a suite are run. Mocha also provides a `beforeEach()` function that runs before
    *each* test in a suite.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before()`: 这是一个在套件中的所有测试运行之前只发生一次的设置。Mocha还提供了一个`beforeEach()`函数，它在套件中的每个测试之前运行。'
- en: '`after()`: This is a setup that occurs *once* after all tests in a suite are
    run, with the `afterEach()` alternative that runs before *each* test.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after()`: 这是一个在套件中所有测试运行后只发生一次的设置，与在每次测试之前运行的`afterEach()`替代方案。'
- en: '`describe()`: This specifies a test suite and can be nested within other `describe()`
    functions.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe()`: 这指定了一个测试套件，可以嵌套在其他`describe()`函数中。'
- en: '`it()`: This defines a single test function containing one or more assertions.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it()`: 这定义了一个包含一个或多个断言的单个测试函数。'
- en: Chai's BDD style uses `expect` or `should` to make dot-notation assertion chains.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Chai的BDD风格使用`expect`或`should`来创建点符号断言链。
- en: 'We can create a basic test file `chapters/03/test/js/spec/bdd.spec.js`, which
    uses all of these components. We name the suite with `describe()`, add/remove
    a function with `before()`/`after()`, and test it with an `it()` specification
    declaration. We chain together two Chai assertions with an `and` helper, producing
    a composite assertion that reads naturally as "expect the result of `hello()`
    to be a string and equal to text ''hello world''":'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个基本的测试文件`chapters/03/test/js/spec/bdd.spec.js`，它使用所有这些组件。我们使用`describe()`命名套件，使用`before()`/`after()`添加/删除函数，并通过`it()`规范声明进行测试。我们使用`and`辅助函数将两个Chai断言链式连接起来，产生一个复合断言，其读起来自然为“期望`hello()`的结果是一个字符串，并且等于文本'hello
    world'”：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our test driver web page (`chapters/03/test/test-bdd.html` in the examples)
    adds the Chai `expect` function into the global namespace for convenience and
    configures Mocha to use the BDD style. The relevant configuration snippet is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试驱动网页（示例中的`chapters/03/test/test-bdd.html`）将Chai的`expect`函数添加到全局命名空间中以便使用，并配置Mocha使用BDD风格。相关的配置片段是：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Mocha TDD and Chai assert styles
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha TDD和Chai断言风格
- en: 'The Mocha TDD interface uses different names for the same basic units:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha TDD接口对相同的基本单元使用不同的名称：
- en: '`suiteSetup()` and `setup()`: These are aliases for `before()` and `beforeEach()`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suiteSetup()`和`setup()`: 这些是`before()`和`beforeEach()`的别名'
- en: '`suiteTeardown()` and `teardown()`: These are aliases for `after()` and `afterEach()`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suiteTeardown()`和`teardown()`: 这些是`after()`和`afterEach()`的别名'
- en: '`suite()`: This specifies a test suite (`describe()` in BDD)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suite()`: 这指定了一个测试套件（在BDD中为`describe()`）'
- en: '`test()`: This defines a single test function (`test()` in BDD)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test()`: 这定义了一个单个测试函数（在BDD中为`test()`）'
- en: The Chai assert style is usually associated with TDD-style tests and provides
    an assert object with single function assertions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Chai断言风格通常与TDD风格的测试相关联，并提供了一个具有单个函数断言的断言对象。
- en: 'Our TDD test file `chapters/03/test/js/test/tdd.js` provides the same test
    setup and assertion series as the BDD version:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的TDD测试文件`chapters/03/test/js/test/tdd.js`提供了与BDD版本相同的测试设置和断言系列：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The driver web page only differs in two configuration lines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动网页只在两行配置上有所不同：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Opening up `chapters/03/test/test-tdd.html` in a browser should show exactly
    the same test results as the previous BDD example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`chapters/03/test/test-tdd.html`应显示与上一个BDD示例完全相同的测试结果。
- en: Deciding on the project style
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定项目风格
- en: 'The style options in Mocha and Chai offer developers a lot of flexibility in
    choosing test paradigms while still leveraging the same underlying test infrastructure.
    In this book we prefer the BDD style for both Mocha and Chai for a few reasons:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha和Chai中的风格选项为开发者提供了在利用相同底层测试基础设施的同时选择测试范例的很大灵活性。在这本书中，我们出于几个原因更喜欢Mocha和Chai的BDD风格：
- en: Chai `expect` assertion chains read in a natural language format that often
    obviates the need for separate test comments
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chai `expect`断言链以自然语言格式读取，通常可以免除单独的测试注释的需要。
- en: The Mocha BDD interface components facilitate narrative descriptions of behaviors
    such as "this describes a number calculator" and "it should sum two numbers"
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha BDD接口组件简化了诸如“这是一个数字计算器”和“它应该求和两个数字”等行为的叙述性描述。
- en: The BDD interface is quite popular in the modern JavaScript testing ecosystem
    and encourages developers to describe the *behavior* of the code under test rather
    than to just identify the internal details
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BDD接口在现代JavaScript测试生态系统中非常流行，并鼓励开发者描述被测试代码的*行为*，而不仅仅是识别内部细节。
- en: Nonetheless, if you prefer any of the other styles, please use whatever feels
    most natural. All of the test code examples in this book can be translated between
    the various Mocha and Chai interfaces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你更喜欢其他风格，请使用最自然的感觉。本书中的所有测试代码示例都可以在 Mocha 和 Chai 接口之间进行翻译。
- en: A tour of the Chai assertion library
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chai 断言库之旅
- en: The Chai test library provides a robust set of assertions and helpers to aid
    the legibility and organization of tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 测试库提供了一套强大的断言和辅助工具，以帮助测试的可读性和组织。
- en: Chai's own unit tests for `expect` (at [https://github.com/chaijs/chai/blob/master/test/expect.js](https://github.com/chaijs/chai/blob/master/test/expect.js))
    provide a great starting point from which the API can be explored. Chai conveniently
    uses Mocha for its test framework (configured with the TDD interface). So the
    entire test suite should feel very familiar.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 对 `expect` 的自身单元测试（在 [https://github.com/chaijs/chai/blob/master/test/expect.js](https://github.com/chaijs/chai/blob/master/test/expect.js)）提供了一个很好的起点，从该起点可以探索
    API。Chai 方便地使用 Mocha 作为其测试框架（配置了 TDD 接口）。因此，整个测试套件应该非常熟悉。
- en: In this section, we will use a series of assertions to introduce most of the
    Chai BDD APIs. The assertion examples are accumulated into a single driver file
    for this chapter—`chapters/03/test/test-chai.html`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一系列断言来介绍 Chai BDD API 的大部分内容。断言示例被累积到本章的单个驱动文件中——`chapters/03/test/test-chai.html`。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Chai provides aliases for many of the assertions that we will discuss in this
    section. For example, the deep equality assertion `eql` is also available as `eqls`
    and `deep.equal`. See the Chai API documentation for a full listing of aliases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 为本节中将要讨论的许多断言提供了别名。例如，深度相等断言 `eql` 也可用作 `eqls` 和 `deep.equal`。有关别名完整列表，请参阅
    Chai API 文档。
- en: Chaining objects and assertions
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接对象和断言
- en: Chai's BDD interface exposes objects that can be chained together to make test
    assertions more comprehensible. We will walk through some basic examples available
    in the file `chapters/03/test/js/spec/chai-chains.spec.js`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 的 BDD 接口公开了可以链式组合以使测试断言更易于理解的对象。我们将通过文件 `chapters/03/test/js/spec/chai-chains.spec.js`
    中的基本示例进行说明。
- en: As an introductory example, the assertion `expect("foo").to.be.a("string")`
    uses the chain objects `to` and `be`, which simply proxy through the eventual
    assertion. In this manner, Chai allows us to add any of the chain objects `to`,
    `be`, `been`, `is`, `that`, `and`, `have`, `with`, `at`, and `of` to form more
    naturally readable assertion statements. The statements `a` and `an` are available
    as both assertion chains and comparison functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为入门示例，断言 `expect("foo").to.be.a("string")` 使用了链式对象 `to` 和 `be`，它们简单地代理到最后一个断言。通过这种方式，Chai
    允许我们添加任何链式对象 `to`、`be`、`been`、`is`、`that`、`and`、`have`、`with`、`at` 和 `of`，以形成更易于阅读的断言语句。`a`
    和 `an` 既可以作为断言链，也可以作为比较函数。
- en: 'We can use these statements to create language chain assertions such as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些语句创建语言链断言，例如：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As all of the statements are equivalent, the highlighted language chains in
    the previous code demonstrate the many different ways of stating the same assertion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有语句都是等效的，前一个代码中突出显示的语言链展示了表达相同断言的许多不同方式。
- en: 'Chai also provides language chain objects that *do* modify the ultimate assertion:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 还提供了修改最终断言的语言链对象：
- en: '`not`: This negates any following assertions. For example:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`：这否定任何后续的断言。例如：'
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`deep`: This sets the deep flag for equality checks. A raw equality check performs
    an identity test, which asserts that the two variables are the *same* object in
    the process memory. With the deep flag, Chai instead asserts that the two variables
    have the same property values, even if they are *different* underlying objects.
    For example, `expect({foo: "bar"}).to.equal({foo: "bar"})` fails an object identity
    test while `expect({foo: "bar"}).to.deep.equal({foo: "bar"})` succeeds.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deep`：这设置了深度检查的深度标志。原始的相等检查执行一个身份测试，它断言两个变量在进程内存中是相同的对象。使用深度标志，Chai 相反地断言两个变量具有相同的属性值，即使它们是不同的底层对象。例如，`expect({foo:
    "bar"}).to.equal({foo: "bar"})` 在对象身份测试中失败，而 `expect({foo: "bar"}).to.deep.equal({foo:
    "bar"})` 则成功。'
- en: 'Finally, most other Chai BDD assertion statements are chainable. The following
    example groups several assertion chains together with the `and` helper:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，大多数其他 Chai BDD 断言语句都是可链式的。以下示例使用 `and` 辅助函数将几个断言链组合在一起：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With these basic language chains and helpers, we have a foundation for writing
    readable assertion statements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些基本语言链和辅助工具，我们为编写可读的断言语句打下了基础。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a good practice to chain assertions together when it makes sense for the
    purpose of developer comprehension and writing concise and terse test code. At
    the same time, separate `expect()` statements can often be more appropriate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当为了开发者的理解以及编写简洁的测试代码时，将断言链在一起是一种良好的实践。同时，单独的 `expect()` 语句通常更为合适。
- en: Basic value assertions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本值断言
- en: 'Chai provides various assertion properties to check input values (see `chapters/03/test/js/spec/chai-values.spec.js`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'Chai 提供了各种断言属性来检查输入值（请参阅 `chapters/03/test/js/spec/chai-values.spec.js`）:'
- en: '`ok`: Value is truthy (for a quick introduction to JavaScript''s permissive
    notion of conditional truth and equality, see [http://www.sitepoint.com/javascript-truthy-falsy/](http://www.sitepoint.com/javascript-truthy-falsy/))'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`: 值是真值（有关 JavaScript 的条件真值和相等性的宽容概念快速介绍，请参阅 [http://www.sitepoint.com/javascript-truthy-falsy/](http://www.sitepoint.com/javascript-truthy-falsy/)）'
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`exist`: Value is neither `null` nor `undefined`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exist`: 值既不是 `null` 也不是 `undefined`'
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`true`: Value is exactly `true`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`: 值正好是 `true`'
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`false`: Value is exactly `false`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`: 值正好是 `false`'
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`null`: Value is exactly `null`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`: 值正好是 `null`。'
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`undefined`: Value is exactly `undefined`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`: 值正好是 `undefined`'
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`arguments`: Value is the special JavaScript `arguments` object, which contains
    a list of parameters for the current function'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`: 值是特殊的 JavaScript `arguments` 对象，它包含当前函数的参数列表'
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Comparing values
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较值
- en: 'Chai has a diverse array of comparison functions to assess input values (see
    `chapters/03/test/js/spec/chai-comparisons.spec.js`):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'Chai 提供了各种比较函数来评估输入值（请参阅 `chapters/03/test/js/spec/chai-comparisons.spec.js`）:'
- en: '`equal`: Strict (`===`) equality'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal`: 严格（`===`）相等'
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`eql`: Deep equality—equivalent to `deep.equal`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eql`: 深度相等——等同于 `deep.equal`'
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`above`: The actual value is greater than the expected value'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`above`: 实际值大于预期值'
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`least`: The actual value is greater than or equal to the expected value'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`least`: 实际值大于或等于预期值'
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`below`: The actual value is less than the expected value'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`below`: 实际值小于预期值'
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`most`: The actual value is less than or equal to the expected value'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`most`: 实际值小于或等于预期值'
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`within`: The actual value is within the range of the expected values'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`within`: 实际值在预期值的范围内'
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`closeTo`: The actual value is within the delta of the expected value'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeTo`: 实际值在预期值的范围内'
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`match`: The actual string value is matched by the expected regular expression'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match`: 实际字符串值与预期正则表达式匹配'
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`string`: The actual string value contains the expected substring'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`: 实际字符串值包含预期的子字符串'
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`satisfy`: The evaluator function takes the actual value as a parameter and
    returns `true` if the assertion should pass'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`satisfy`: 评估函数将实际值作为参数，如果断言应该通过则返回 `true`'
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Object and array validation
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象和数组验证
- en: 'Chai provides some useful assertions tailored to objects and arrays (see `chapters/03/test/js/spec/chai-objects.spec.js`):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'Chai 提供了一些针对对象和数组的定制化断言（请参阅 `chapters/03/test/js/spec/chai-objects.spec.js`）:'
- en: '`a`: When called as a function, this checks the object type building on JavaScript''s
    native `typeof` test, with additional support for correctly inferring objects
    and arrays. Note that when `a` (or `an`) is used as an object property, it acts
    as a language chain instead.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`: 当作为函数调用时，这会基于 JavaScript 的原生 `typeof` 测试检查对象类型，并额外支持正确推断对象和数组。注意，当 `a`（或
    `an`）用作对象属性时，它作为语言链起作用。'
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`instanceof`: Checks whether the object is an instance of an expected constructor.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceof`: 检查对象是否是预期构造函数的实例。'
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`property`: Checks if an expected property exists in an object and, optionally,
    if the property''s value matches an expected value. When used in conjunction with
    the `deep` language chain, an object structure can be navigated via the dot or
    array notation.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`property`: 检查对象中是否存在预期属性，以及可选地，该属性值是否与预期值匹配。当与 `deep` 语言链一起使用时，可以通过点或数组符号导航对象结构。'
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`ownProperty`: Checks for the presence of a direct property on an object using
    the JavaScript `hasOwnProperty` test, without looking up the object''s prototype
    chain for an inherited property.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ownProperty`: 使用 JavaScript 的 `hasOwnProperty` 测试检查对象上是否存在直接属性，而无需在对象的原型链上查找继承属性。'
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`length`: Checks the `length` property of an array or object (such as a string).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`: 检查数组或对象的 `length` 属性（例如字符串）。'
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`contain`: Checks for the presence of an object in an array or a substring
    within a string. Note that `contain` (and `include`) can alternatively be used
    as a language chain with `keys`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contain`：检查对象是否在数组中或字符串中的子串。请注意，`contain`（和`include`）可以作为带有`keys`的语言链的替代使用。'
- en: '[PRE31]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`keys`: Checks that an object includes all of the expected property names.
    The assertion verifies only a subset of expected property names when combined
    with the `include` or `contain` language chains.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys`：检查对象是否包含所有预期的属性名称。当与`include`或`contain`语言链结合使用时，断言仅验证预期属性名称的子集。'
- en: '[PRE32]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Errors
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误
- en: Chai can also check abnormal code functionality, notably trapping and verifying
    program exceptions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 还可以检查异常代码的功能，特别是捕获和验证程序异常。
- en: 'The `throw` assertion takes a function as an input that is expected to throw
    an exception when called. The resulting error is then matched against a constructor
    class (for example, `Error`) or a message string/regular expression (for example,
    `/message/`). Note that a function reference (for example, `bad`) is passed to
    the assertion rather than a called function (for example, `bad()`). This enables
    Chai to call the function internally, trap any exceptions, and verify the results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 断言接受一个函数作为输入，该函数在调用时预期会抛出异常。然后，结果错误与构造函数类（例如，`Error`）或消息字符串/正则表达式（例如，`/message/`）进行匹配。请注意，传递给断言的是函数引用（例如，`bad`），而不是被调用的函数（例如，`bad()`）。这使
    Chai 能够在内部调用函数，捕获任何异常，并验证结果：'
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Getting the application and tests ready to run
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序和测试以运行
- en: 'Now that we have the Chai assertion library API under our belts, it is time
    to write and organize the tests. While we have incidentally covered much of this
    material already, the concise core of a Mocha test infrastructure includes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 Chai 断言库 API，是时候编写和组织测试了。虽然我们意外地覆盖了大部分材料，但 Mocha 测试基础设施的简洁核心包括：
- en: '**Test runner**: Configures the overall test run and report'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**：配置总体测试运行和报告'
- en: '**Test suites**: One or more organization units grouping many specifications/tests'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**: 一个或多个组织单元，将许多规格/测试分组在一起'
- en: '**Setup**/**Teardown**: Setting up a state for each test or suite run'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**/**清理**: 为每个测试或套件运行设置状态'
- en: '**Specifications**: Writing the test functions'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规格说明**: 编写测试函数'
- en: Starting at the highest level, we look at our test driver web page. As previously
    discussed, this is where our core application libraries, test libraries, and test
    specifications are set up and included. All of the Backbone.js application tests
    in the rest of this chapter are incorporated into the `chapters/03/test/test.html`
    driver page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从最高级别开始，我们查看我们的测试驱动网页。如前所述，这是我们的核心应用程序库、测试库和测试规格设置和包含的地方。本章其余部分的所有 Backbone.js
    应用程序测试都包含在 `chapters/03/test/test.html` 驱动网页中。
- en: The Mocha test runner
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha 测试运行器
- en: 'The Mocha `setup()` function controls the overall parameters and environment
    for all test suite and specification executions. The function should be called
    once before execution starts (for example, `mocha.run()`) in the test driver web
    page:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 的 `setup()` 函数控制所有测试套件和规格执行的总体参数和环境。该函数应在测试驱动网页中执行开始之前（例如，`mocha.run()`）调用一次：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The default settings are quite usable for Backbone.js testing and we use the
    previous code for nearly all of the tests in this book. However, there are many
    more options available, which are described at [http://visionmedia.github.io/mocha/](http://visionmedia.github.io/mocha/).
    Here is an arbitrary sampling:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置对于 Backbone.js 测试来说相当可用，我们在这本书的几乎所有测试中都使用了之前的代码。然而，还有许多其他选项可用，这些选项在 [http://visionmedia.github.io/mocha/](http://visionmedia.github.io/mocha/)
    中进行了描述。以下是一个任意的样本：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Reconfiguring the application for testing
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新配置应用程序以进行测试
- en: Backbone.js applications often need specific test-friendly configurations in
    order to make the test environment predictable and to avoid stomping on real data.
    Backend information (for example, host addresses and ports) is often different
    in the development and testing phases. Thus, it is a good practice to abstract
    all of this information into a common file so that we can easily switch values
    from one central location to another.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js 应用程序通常需要特定的测试友好配置，以便使测试环境可预测并避免覆盖真实数据。后端信息（例如，主机地址和端口）在开发和测试阶段通常不同。因此，将所有这些信息抽象到一个公共文件中是一个好的做法，这样我们就可以轻松地在中央位置切换值：
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An alternative and complementary approach for creating a workable test environment
    is to fake out configuration details and dependencies with a library such as Sinon.JS.
    The two Sinon.JS abstractions that can help us here are stubs and mocks, both
    of which can replace object method behaviors during tests. (We will introduce
    and discuss these concepts in detail in [Chapter 5](ch05.html "Chapter 5. Test
    Stubs and Mocks"), *Test Stubs and Mocks*.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可工作的测试环境的一种替代和补充方法是使用 Sinon.JS 等库来伪造配置细节和依赖项。这里可以帮助我们的 Sinon.JS 抽象是存根和模拟，两者都可以在测试期间替换对象方法的行为。（我们将在第
    5 章[“第 5 章。测试存根和模拟”](ch05.html "Chapter 5. Test Stubs and Mocks")中详细介绍和讨论这些概念。）
- en: In the following datastore configuration examples, we could use a Sinon.JS stub
    to replace the entire datastore with test-specific simulation code. The stub would
    allow us to use normal application configurations while ensuring that we do not
    modify the real datastore. As an added benefit to this approach, stubbing and
    mocking external dependencies can often make tests run faster, particularly if
    the fake replaces a relatively slow application behavior (for example, network
    communication).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下数据存储配置示例中，我们可以使用 Sinon.JS 存根用测试特定的模拟代码替换整个数据存储。存根将允许我们使用正常的应用程序配置，同时确保我们不会修改真实的数据存储。作为这种方法的一个额外好处，存根和模拟外部依赖项通常可以使测试运行得更快，尤其是如果伪造替换了一个相对较慢的应用程序行为（例如，网络通信）。
- en: 'In the Notes application, we require a unique `localStorage` name for the collection,
    which we specify in the configuration file `notes/app/js/app/config.js`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记应用中，我们要求集合有一个唯一的 `localStorage` 名称，我们在配置文件 `notes/app/js/app/config.js` 中指定它：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code populates the `App.Config` namespace with `App.Config.storeName`,
    which we then use for the `App.Collections.Notes` collection in `notes/app/js/app/collections/notes.js`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将 `App.Config` 命名空间填充为 `App.Config.storeName`，然后我们将其用于 `notes/app/js/app/collections/notes.js`
    中的 `App.Collections.Notes` 集合：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this setup, the live application will save data to the `notes` store in
    `localStorage`. However, in our tests we will want to add, remove, and mutate
    the note data without overwriting our development-friendly datastore. So, by adding
    an extra configuration directive in our application''s test driver page, we can
    set the test-only store name to `notes-test` using the Underscore.js `extend()`
    function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，实时应用将数据保存到 `localStorage` 中的 `notes` 存储。然而，在我们的测试中，我们希望添加、删除和修改笔记数据，而不覆盖我们开发友好的数据存储。因此，通过在我们的应用程序测试驱动程序页面中添加额外的配置指令，我们可以使用
    Underscore.js 的 `extend()` 函数将测试专用存储名称设置为 `notes-test`：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By including `config.js` first and then overriding the specific values, we make
    the *other* unmodified configuration values available during the tests. With this
    scheme, we now have a completely separate Backbone.js test datastore, which we
    can change without affecting our development environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先包含 `config.js` 然后覆盖特定值，我们使测试期间可用的其他未修改的配置值。使用这种方案，我们现在有一个完全独立的 Backbone.js
    测试数据存储，我们可以更改它而不会影响我们的开发环境。
- en: Organizing topics and specifications into test suites
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将主题和规范组织到测试套件中
- en: Organizing test code into topics and application components is an important
    step in developing an overall test architecture. To this end, Mocha provides the
    `describe()` test suite function to group logical collections of test specifications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试代码组织到主题和应用程序组件中是开发整体测试架构的重要步骤。为此，Mocha 提供了 `describe()` 测试套件函数来分组逻辑集合的测试规范。
- en: 'For example, in `App.Collections.Notes` we might start with two subgroups of
    tests:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `App.Collections.Notes` 中，我们可能从两个测试子组开始：
- en: Tests that create empty collections and verify the initial default state
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建空集合并验证初始默认状态的测试
- en: Tests that modify the collection with new `App.Models.Note` objects
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的 `App.Models.Note` 对象修改集合的测试
- en: 'Transforming this list into a set of nested Mocha test suites would give us:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将此列表转换为一系列嵌套的 Mocha 测试套件将给我们：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have two levels of `describe()` statements here, although Mocha allows a
    much deeper nesting of suites.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两种级别的 `describe()` 语句，尽管 Mocha 允许更深的套件嵌套。
- en: Starting up and winding down tests
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和关闭测试
- en: Although we try to isolate behavior for our test specifications as a general
    practice, tests often have common setup and teardown needs. For example, if a
    group of specs all test the same object, it may make the most sense to create
    the object once and share it with all of the specs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们试图将测试规范的行为隔离作为一般做法，但测试通常有共同的设置和拆解需求。例如，如果一组规范都测试同一个对象，那么最合理的方法可能是创建该对象一次，并与所有规范共享。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Context/member variables in Mocha**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocha 中的上下文/成员变量**'
- en: Mocha allows test code to attach values to the `this` context object for use
    in other sections of the test run. This allows us to share variables across tests
    without having to declare and manage global or higher-level scoped variables.
    A common use of this feature is to add a variable such as `this.myCollection`
    in a `before()` setup statement for a group of tests and then remove it in the
    `after()` statement for the group.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 允许测试代码将值附加到 `this` 上下文对象，以便在测试运行的其它部分使用。这允许我们在不需要声明和管理全局或更高作用域变量的情况下，在测试之间共享变量。此功能的常见用途是在一组测试的
    `before()` 设置语句中添加一个变量，例如 `this.myCollection`，然后在组的 `after()` 语句中移除它。
- en: Mocha provides the functions `before()`, `beforeEach()`, `after()`, and `afterEach()`
    to help us with test state management. As mentioned previously, the `before()`/`after()`
    functions run *once* before and *once* after all the tests within a suite. The
    `beforeEach()`/`afterEach()` functions run before and after *each* test within
    a suite.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 提供了 `before()`, `beforeEach()`, `after()`, 和 `afterEach()` 函数来帮助我们管理测试状态。如前所述，`before()`/`after()`
    函数在每个套件中的所有测试之前和之后各运行一次。`beforeEach()`/`afterEach()` 函数在每个套件中的每个测试之前和之后运行。
- en: With these four constructs, we can create nuanced state management for our Mocha
    tests. The setup/teardown functions operate at the level of each test suite. This
    means that nested test suites can provide their own additional setup/teardown
    functions. For example, Mocha will faithfully run each `before()` statement as
    it traverses deeper into the `describe()` statements before executing the first
    test.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这四个构造，我们可以为我们的 Mocha 测试创建细微的状态管理。设置/拆解函数在测试套件的级别上操作。这意味着嵌套的测试套件可以提供它们自己的附加设置/拆解函数。例如，Mocha
    将忠实地运行每个 `before()` 语句，在执行第一个测试之前，它将深入到 `describe()` 语句中。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another good reason to use the setup/teardown functions is that they *always*
    run—even when the test specs fail or throw exceptions. This prevents a single
    test failure from affecting the data state of other tests in the run and causing
    spurious test failures.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设置/拆解函数的另一个好理由是它们**总是**运行——即使测试规范失败或抛出异常也是如此。这防止单个测试失败影响运行中其他测试的数据状态，并导致虚假的测试失败。
- en: Backbone.js collection tests often benefit from using setup and teardown helpers
    to create an initial data state. Usually, this means adding some starting records
    (called data fixtures when loaded from a separate data file) and restoring the
    datastore to a pristine state after the tests have modified the collection.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js 集合测试通常受益于使用设置和拆解辅助函数来创建初始数据状态。通常，这意味着添加一些起始记录（当从单独的数据文件加载时称为数据固定），并在测试修改集合后，将数据存储恢复到原始状态。
- en: 'In the test driver page, we have already configured the `App.Collections.Notes`
    class to use a test-only datastore. The `Backbone.localStorage` adapter has an
    internal method `_clear()` that clears the underlying browser storage associated
    with the collection, which we will use to reset our data state in the tests. The
    resulting data sandbox is ready for the following test scenario:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试驱动页面上，我们已配置 `App.Collections.Notes` 类使用仅测试的数据存储。`Backbone.localStorage` 适配器有一个内部方法
    `_clear()`，它清除与集合关联的底层浏览器存储，我们将使用它来在测试中重置我们的数据状态。结果的数据沙盒已准备好以下测试场景：
- en: Wipe any existing collection data on suite setup, add a context variable for
    a single collection, and remove the collection on teardown
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在套件设置中清除任何现有的集合数据，为单个集合添加一个上下文变量，并在拆解时移除该集合
- en: In the `modification` suite, add an initial `App.Models.Note` object to the
    collection and wipe the collection after each test
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `modification` 套件中，向集合添加一个初始的 `App.Models.Note` 对象，并在每个测试后清除集合
- en: 'The implementation of the setup and teardown functions for the test suite looks
    like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件的设置和拆解函数的实现如下：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The highlighted lines in the previous code snippet illustrate the `before()`/`after()`
    calls for all tests in the overall test suite and the `beforeEach()`/`afterEach()`
    calls for only the subsuite `modification`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码片段中突出显示的行说明了整体测试套件中所有测试的 `before()`/`after()` 调用以及子套件 `modification` 的 `beforeEach()`/`afterEach()`
    调用。
- en: Writing Mocha test specifications
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Mocha 测试规范
- en: 'With practically everything else in place, we finally turn to writing test
    specifications. Mocha BDD specifications are declared using the `it()` function
    with the following function signature:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他所有内容都就绪的情况下，我们最终转向编写测试规范。Mocha BDD 规范使用 `it()` 函数声明，该函数具有以下函数签名：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The description string, by convention, is a statement of the expected behavior
    under test, and the callback function executes the tests. For example, assuming
    we have an empty `this.notes` collection variable, a test of the default values
    in `App.Collections.Notes` can be as simple as the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，描述字符串是对测试中预期行为的陈述，回调函数执行测试。例如，假设我们有一个空的 `this.notes` 集合变量，对 `App.Collections.Notes`
    中的默认值进行测试可以像以下这样简单：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Asynchronous behavior in tests
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试中的异步行为
- en: Although basic test specifications are quite simple, flow control complications
    arise when testing asynchronous application code. Given that the Backbone.js application's
    behavior is quite often asynchronous/event-driven, we need to have a solid and
    straightforward test approach.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基本的测试规范相当简单，但在测试异步应用程序代码时会出现流程控制复杂性。鉴于 Backbone.js 应用程序的行为通常是异步/事件驱动的，我们需要有一个坚实且直接的测试方法。
- en: Fortunately, Mocha provides an asynchronous test function parameter that is
    used to signal that the test is asynchronous. If a parameter is provided in a
    test callback (it is named `done` by convention), Mocha will delay the test completion
    until either `done` is called or the test times out.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Mocha 提供了一个异步测试函数参数，用于表示测试是异步的。如果在测试回调中提供了一个参数（按照惯例命名为 `done`），Mocha 将延迟测试完成，直到
    `done` 被调用或测试超时。
- en: 'One asynchronous behavior that we can test in a Backbone.js collection is that
    the `reset` event fires after a `fetch()` method call on the collection. Here
    we create an empty `App.Collections.Notes` object, fetch its backend data, and
    confirm that the event has fired. After all of this is verified, we add a call
    to `done()` to signal that the test has completed successfully. If the `reset`
    event never fires, then `done()` won''t be called and the test will time out:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Backbone.js 集合中测试的一种异步行为是，在集合上调用 `fetch()` 方法后，会触发 `reset` 事件。在这里，我们创建一个空的
    `App.Collections.Notes` 对象，获取其后端数据，并确认事件已触发。在所有这些都被验证后，我们添加一个调用 `done()` 的操作来表示测试成功完成。如果
    `reset` 事件从未触发，则不会调用 `done()`，测试将超时：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With the extra `done` parameter, we can now run a series of asynchronous assertions
    within a single specification before the test completes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用额外的 `done` 参数，我们现在可以在测试完成之前在单个规范中运行一系列异步断言。
- en: Some Backbone.js collection tests
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些 Backbone.js 集合测试
- en: 'Now that we can write asynchronous specifications, we will finish off our test
    suite for the Notes collection. Keeping in mind our test goals for Backbone.js
    collections from [Chapter 2](ch02.html "Chapter 2. Creating a Backbone.js Application
    Test Plan"), *Creating a Backbone.js Application Test Plan* (that is, modifying
    models, firing events, and synchronizing data), we will create the following specs
    for `App.Collections.Notes` (shown in an outline form here):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们可以编写异步规范，我们将完成 Notes 集合的测试套件。考虑到 [第 2 章](ch02.html "第 2 章。创建 Backbone.js
    应用程序测试计划") 中 Backbone.js 集合的测试目标，即 *创建 Backbone.js 应用程序测试计划*（即修改模型、触发事件和同步数据），我们将为
    `App.Collections.Notes` 创建以下规范（此处以概要形式展示）：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Creating an empty test outline such as the previous code is a good exercise
    and practice during application development. For example, as part of a test-first
    development process, we can first write the `describe` and `it` declarations without
    callbacks to specify the world of program behavior for the relevant application
    component. Once we are satisfied that the outline approximates the expected use
    cases of the component, we can move on to filling out tests and writing the application
    code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发期间创建一个空白的测试概要是一个很好的练习和实践。例如，作为测试驱动开发过程的一部分，我们可以首先编写 `describe` 和 `it`
    声明而不使用回调，以指定相关应用程序组件的程序行为世界。一旦我们满意地认为概要近似于组件的预期用例，我们就可以继续填写测试和编写应用程序代码。
- en: Helpfully, Mocha will treat spec declarations without functions (as shown in
    the previous code snippet) as pending tests. Pending specs are visually distinguished
    from the ordinary tests with different colors in a Mocha HTML test report. With
    pending tests, a developer can scan a test report more easily for unfinished specs
    and then implement the necessary test and application code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于，Mocha 将没有函数的 spec 声明（如前一个代码片段所示）视为挂起的测试。挂起的 spec 与普通测试在 Mocha HTML 测试报告中以不同的颜色区分。有了挂起的测试，开发者可以更容易地扫描测试报告以查找未完成的
    spec，然后实现必要的测试和应用程序代码。
- en: 'With this in mind, let''s implement the specifications to complete the test
    file `chapters/03/test/js/spec/collections/notes.spec.js`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们实现规范以完成测试文件 `chapters/03/test/js/spec/collections/notes.spec.js`：
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have omitted some of the spec functions from the following code (and elsewhere
    in this book) for brevity and readability. The full spec implementations for `App.Collections.Notes`
    and other Notes test suites are available in the companion code samples for this
    book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁和可读性，我们从以下代码（以及本书的其他地方）中省略了一些 spec 函数。`App.Collections.Notes` 和其他笔记测试套件的完整
    spec 实现可在本书的配套代码示例中找到。
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This final test file provides a reasonable skeleton using all of the different
    Mocha and Chai parts we have discussed in this chapter. We can see our tests in
    action by opening a browser to the driver page `chapters/03/test/test.html`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的测试文件使用本章中讨论的所有不同的 Mocha 和 Chai 部分，提供了一个合理的框架。我们可以通过打开浏览器到驱动页面 `chapters/03/test/test.html`
    来看到我们的测试在行动。
- en: Testing and supporting Backbone.js views
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和支持 Backbone.js 视图
- en: Having now created test suites for Backbone.js models and collections, we turn
    to expanding our test coverage to a Backbone.js view.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 Backbone.js 模型和集合创建了测试套件，我们将转向扩展我们的测试覆盖率到 Backbone.js 视图。
- en: The Notes application single note view
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记应用单条笔记视图
- en: 'The first Backbone.js view we will examine is `App.Views.NoteView`. This view
    is responsible for rendering `App.Models.Note` Markdown data into full HTML as
    shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一个 Backbone.js 视图是 `App.Views.NoteView`。这个视图负责将 `App.Models.Note` 的
    Markdown 数据渲染成完整的 HTML，如下面的截图所示：
- en: '![The Notes application single note view](img/5248OS_03_01.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![笔记应用单条笔记视图](img/5248OS_03_01.jpg)'
- en: View rendered Markdown
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 视图渲染的 Markdown
- en: 'The underlying model data for the figure includes the following attributes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的底层模型数据包括以下属性：
- en: '`title`:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`:'
- en: '[PRE46]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`text`:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：'
- en: '[PRE47]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `text` attribute data transforms to HTML as:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 属性数据转换为 HTML 的方式如下：'
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`App.Views.NoteView` is responsible for performing this conversion. The `notes/app/js/app/views/note-view.js`
    file first provides an `initialize` function, which sets model listeners to re-render
    or clean up the view and then kicks off `render()`. The `render` function uses
    the Showdown library to convert the model `text` Markdown data into HTML and then
    passes the finished data to the view template:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.Views.NoteView` 负责执行这个转换。`notes/app/js/app/views/note-view.js` 文件首先提供了一个
    `initialize` 函数，该函数设置模型监听器以重新渲染或清理视图，然后启动 `render()`。`render` 函数使用 Showdown 库将模型的
    `text` Markdown 数据转换为 HTML，然后将完成的数据传递给视图模板：'
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This view includes an Underscore.js template (`App.Templates["template-note-view"]`
    in `notes/app/js/app/templates/templates.js`), which inserts the `title` and `text`
    data into HTML:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图包括一个 Underscore.js 模板（`notes/app/js/app/templates/templates.js` 中的 `App.Templates["template-note-view"]`），它将
    `title` 和 `text` 数据插入到 HTML 中：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Rendering the model data into an HTML form with `App.Views.NoteView.render()`
    gives us the following resulting HTML:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `App.Views.NoteView.render()` 将模型数据渲染成 HTML 表单，我们得到以下结果 HTML：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that we have introduced a simple view to work with, we will examine how
    to test its behavior.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一个简单的视图来工作，我们将检查如何测试其行为。
- en: Creating HTML fixtures for view tests
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为视图测试创建 HTML 固定数据
- en: The Backbone.js application tests that we have written up to this point don't
    interface with the DOM or HTML of a web page. This simplifies our test environment
    because the application's web page (for example, `index.html`) is very different
    from our test driver page (for example, `test.html`). However, Backbone.js views
    nearly always involve a healthy amount of DOM interaction.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的 Backbone.js 应用程序测试并不与网页的 DOM 或 HTML 接口。这简化了我们的测试环境，因为应用程序的网页（例如，`index.html`）与我们测试驱动页面（例如，`test.html`）非常不同。然而，Backbone.js
    视图几乎总是涉及大量的 DOM 交互。
- en: 'To this end, we need an HTML test fixture—one or more DOM elements in the test
    driver page that we can interact with and modify during tests. At the same time,
    we don''t want the fixture HTML causing havoc in the test code of the driver page.
    Accordingly, we create a single, hidden `div` element in the `chapters/03/test/test.html`
    driver page for our application view tests:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们需要一个HTML测试固定元素——在测试驱动页面中的一个或多个DOM元素，我们可以在测试期间与之交互和修改。同时，我们不想让固定HTML在驱动页面的测试代码中造成混乱。因此，我们在`chapters/03/test/test.html`驱动页面中为我们的应用程序视图测试创建了一个单独的、隐藏的`div`元素：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, our tests can reference `$("#fixtures")` in jQuery and get access to the
    fixture container. The tests can then add elements as needed to exercise any desired
    view/DOM interaction.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试可以在jQuery中引用`$("#fixtures")`并获取对固定容器的访问权限。然后，测试可以添加所需元素以练习任何期望的视图/DOM交互。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Advanced HTML fixtures**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级HTML固定元素**'
- en: We have scratched only the surface of HTML fixtures in this chapter. More sophisticated
    fixture schemes and libraries exist, with features such as sandboxing application
    HTML code within an iframe to avoid test code cross-pollination and loading HTML
    fixture code from external application files. Two promising management libraries
    that are compatible with Mocha are jsFixtures ([https://github.com/kevindente/jsFixtures](https://github.com/kevindente/jsFixtures))
    and js-fixtures ([https://github.com/badunk/js-fixtures](https://github.com/badunk/js-fixtures)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只是触及了HTML固定元素的表面。存在更复杂的固定方案和库，例如在iframe中沙盒化应用HTML代码以避免测试代码交叉污染，以及从外部应用程序文件中加载HTML固定元素代码。两个与Mocha兼容的、有潜力的管理库是jsFixtures
    ([https://github.com/kevindente/jsFixtures](https://github.com/kevindente/jsFixtures))
    和 js-fixtures ([https://github.com/badunk/js-fixtures](https://github.com/badunk/js-fixtures))。
- en: Walking through the view test suite
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历视图测试套件
- en: Let's make our way through the code in `chapters/03/test/js/spec/views/note-view.spec.js`,
    which is the test suite for `App.Views.NoteView`. Recalling the Backbone.js view
    testing goals in [Chapter 2](ch02.html "Chapter 2. Creating a Backbone.js Application
    Test Plan"), *Creating a Backbone.js Application Test Plan*, we will check if
    the view renders appropriate HTML using a model and template, binds HTML results
    to the expected DOM location, and interacts correctly with the application events.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步查看`chapters/03/test/js/spec/views/note-view.spec.js`中的代码，这是`App.Views.NoteView`的测试套件。回忆一下[第2章](ch02.html
    "第2章。创建Backbone.js应用程序测试计划")中Backbone.js视图测试的目标，即*创建Backbone.js应用程序测试计划*，我们将检查视图是否使用模型和模板渲染适当的HTML，将HTML结果绑定到预期的DOM位置，并且与应用程序事件正确交互。
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Writing tests on your own for the examples**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**为示例编写自己的测试**'
- en: To make the narrative in this book flow better, we will follow a general scheme
    of presenting a Backbone.js application component and then walking through tests
    that illustrate a particular lesson, technique, or tool. Unfortunately, this is
    the reverse of the recommended Test-Driven Development process, which writes tests
    describing application behavior first, then writes the implementation, and iterates
    until the overall behavior is correct.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本书的叙述更加流畅，我们将遵循一个一般方案：首先展示一个Backbone.js应用程序组件，然后通过测试来阐述特定的课程、技巧或工具。不幸的是，这与推荐的测试驱动开发过程相反，后者首先编写描述应用程序行为的测试，然后编写实现代码，并迭代直到整体行为正确。
- en: For your work with this book, we strongly encourage you to take a moment, before
    the book presents test examples to design and implement your own tests for the
    sample application components. After writing your own tests, you can move on to
    the book's examples to check your work and identify additional testing ideas and
    techniques.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您与本书的工作，我们强烈建议您在本书展示测试示例之前，设计和实现您自己的测试来测试示例应用程序组件。在编写自己的测试后，您可以继续阅读本书的示例，以检查您的作品并识别额外的测试想法和技术。
- en: 'The suite begins with a `describe` declaration and a setup/teardown code. At
    the commencement of the suite execution, a view fixture (`$("<div id=''note-view-fixture''></div>")`)
    is created and stored in `this.$fixture`. Our setup for each test (`beforeEach()`/`afterEach()`)
    binds the new `this.$fixture` fixture to the HTML fixture holder `$("#fixtures")`
    and creates an `App.Views.NoteView` object with an `App.Models.Note` model. After
    all tests in the suite are done, the fixtures holder `$("#fixtures")` is emptied:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件以一个`describe`声明和设置/清理代码开始。在套件执行开始时，创建一个视图测试用例（`$("<div id='note-view-fixture'></div>")`）并存储在`this.$fixture`中。每个测试的设置（`beforeEach()`/`afterEach()`）将新的`this.$fixture`测试用例绑定到HTML测试用例持有者`$("#fixtures")`，并创建一个带有`App.Models.Note`模型的`App.Views.NoteView`对象。在套件中的所有测试完成后，测试用例持有者`$("#fixtures")`将被清空：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With these variables and DOM elements available, we can test whether a default
    model renders the expected HTML, using jQuery. Note that because its `initialize`
    function calls `render`, instantiating an `App.Views.NoteView` object adds the
    rendered HTML to our DOM fixture:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些变量和DOM元素可用的情况下，我们可以使用jQuery测试默认模型是否渲染了预期的HTML。请注意，因为其`initialize`函数调用了`render`，实例化一个`App.Views.NoteView`对象会将渲染后的HTML添加到我们的DOM测试用例中：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The second spec changes the model attributes `title` and `text` to render more
    complex HTML.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个规范更改了模型的属性`title`和`text`以渲染更复杂的HTML。
- en: The tricky part is waiting until *after* the model listeners call `render()`
    and update the DOM to inspect the new HTML values. Our technique here is to observe
    that `render()` already listens to the model event `change` and add an additional
    one-time `once()` listener on this event to check the HTML.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分是在模型监听器调用`render()`并更新DOM之后等待，以检查新的HTML值。我们在这里的技术是观察`render()`已经监听模型事件`change`，并在此事件上添加一个额外的单次`once()`监听器来检查HTML。
- en: 'However, note that this is a brittle way to handle the asynchronous nature
    of the test behavior. The rendering code could take more time to finish than our
    assertions, thereby breaking the test. A better solution is to wait on the `render()`
    function call to finish and then run the test code—a technique that we can more
    readily perform with Sinon.JS spies, stubs, and mocks, which are discussed in
    detail in the subsequent chapters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，这是一种处理测试行为异步性质脆弱的方法。渲染代码可能需要更多的时间来完成，从而破坏测试。更好的解决方案是在`render()`函数调用完成后等待，然后再运行测试代码——这是一种我们可以更方便地使用Sinon.JS间谍、存根和模拟来执行的技术，这些将在后续章节中详细讨论：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Aggregating and running the application tests
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合并运行应用程序测试
- en: 'Finishing up the test driver page for both the collection and view tests, we
    integrate the necessary script includes and HTML test fixtures in `chapters/03/test/test.html`
    (shown in the relevant part in the following code snippet):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 完成集合和视图测试的测试驱动页面，我们在`chapters/03/test/test.html`中集成必要的脚本包含和HTML测试用例（在以下代码片段的相关部分中显示）：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Opening a web browser to `chapters/03/test/test.html`, we can see the full
    test report for the collection and view:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网络浏览器到`chapters/03/test/test.html`，我们可以看到集合和视图的完整测试报告：
- en: '![Aggregating and running the application tests](img/5248OS_03_02.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![聚合并运行应用程序测试](img/5248OS_03_02.jpg)'
- en: Test report
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 测试报告
- en: Test development tips, tricks, and hints
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试开发技巧、窍门和提示
- en: While we continue to explore the theory and practice of testing Backbone.js
    applications, it remains true that creating test architectures and writing good
    test specifications are more of an art than an exact science. Many lessons can
    only be learned through experience, particularly as your applications encounter
    bugs and development mishaps. In the meantime, we can start you off with some
    techniques and suggestions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续探索Backbone.js应用程序的理论和实践时，创建测试架构和编写良好的测试规范更多的是一种艺术，而不是精确的科学。许多经验教训只能通过经验来学习，尤其是在你的应用程序遇到错误和开发失误时。同时，我们可以从一些技术和建议开始：
- en: Isolating and excluding tests
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离和排除测试
- en: Application development is a journey guaranteed to include inexplicable errors,
    sudden application crashes, and complex test failures. When these pitfalls happen,
    it is important to have some directions on how to debug the problems and move
    things forward.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发是一次保证会包括无法解释的错误、突然的应用程序崩溃和复杂的测试失败的旅程。当这些陷阱发生时，了解如何调试问题并继续前进的方向是很重要的。
- en: 'A common scenario during software development is when application changes break
    one or more existing unit tests. In this case, a good practice is to run the test
    suite one test at a time, fix the test, and then move on to the rest. Mocha provides
    two avenues to help in this regard:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发过程中，一个常见的场景是应用程序的更改破坏了一个或多个现有的单元测试。在这种情况下，一个良好的实践是逐个运行测试套件，修复测试，然后再继续进行其他测试。Mocha
    提供了两个途径来帮助解决这个问题：
- en: '**Grep**: As we have discussed in [Chapter 1](ch01.html "Chapter 1. Setting
    Up a Test Infrastructure"), *Setting Up a Test Infrastructure*, you can click
    on a single test in the test reporter HTML page or directly navigate to a test
    page URL with a grep query parameter appended, such as `test.html?grep=PATTERN`.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grep**：正如我们在 [第 1 章](ch01.html "第 1 章。设置测试基础设施") 中讨论的，*设置测试基础设施*，你可以在测试报告
    HTML 页面上点击单个测试，或者直接导航到一个带有 grep 查询参数的测试页面 URL，例如 `test.html?grep=PATTERN`。'
- en: '**Only**: Another alternative is to temporarily modify your Mocha test specifications
    to run only a single test using the `only` helper, skipping all other tests and
    suites. Let''s look at an example:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅限使用**：另一个选择是临时修改你的 Mocha 测试规范，使用 `only` 辅助函数仅运行单个测试，跳过所有其他测试和套件。让我们看看一个例子：'
- en: '[PRE57]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: On the other side of this scenario, sometimes we want to ignore a few failing
    tests while still using the rest of the test infrastructure. In this case, we
    look towards `skip`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景的另一面，有时我们希望在仍然使用其余的测试基础设施的同时忽略一些失败的测试。在这种情况下，我们会转向 `skip`。
- en: '**Skip**: The `skip` modifier omits a single specification from the test run
    and can be applied to multiple specifications. Skipped tests are also considered
    pending and can be visually distinguished in a Mocha HTML test report:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过**：`skip` 修饰符会从测试运行中省略单个规范，并且可以应用于多个规范。跳过的测试也被视为挂起的，可以在 Mocha HTML 测试报告中通过视觉区分：'
- en: '[PRE58]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Writing testable application code
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可测试的应用程序代码
- en: Beyond the practical aspects of writing tests, an equally important component
    of developing a test infrastructure is writing testable application code. The
    topic of testable JavaScript code is quite large—we will only introduce the issue
    here and start you off with a general goal of developing application code that
    works in harmony with the tests that support it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写测试的实际方面之外，开发测试基础设施同样重要的一个组成部分是编写可测试的应用程序代码。关于可测试 JavaScript 代码的主题相当广泛——我们在这里只介绍这个问题，并从开发与支持其测试协同工作的应用程序代码的一般目标开始。
- en: 'A comprehensive treatment of the subject is available in the book *Testable
    JavaScript* by *Mark Ethan Trostler* ([http://shop.oreilly.com/product/0636920024699.do](http://shop.oreilly.com/product/0636920024699.do)),
    which covers topics such as application code complexity, event-based architectures,
    and debugging. Also consider general JavaScript application guides such as *Maintainable
    JavaScript* by *Nicholas Zakas* ([http://shop.oreilly.com/product/0636920025245.do](http://shop.oreilly.com/product/0636920025245.do))
    and the seminal *JavaScript: The Good Parts* by *Douglas Crockford* ([http://shop.oreilly.com/product/9780596517748.do](http://shop.oreilly.com/product/9780596517748.do)).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '在 *Mark Ethan Trostler* 的书籍 *Testable JavaScript* 中可以找到对这一主题的全面处理，该书涵盖了诸如应用程序代码复杂性、基于事件的架构和调试等主题。[http://shop.oreilly.com/product/0636920024699.do](http://shop.oreilly.com/product/0636920024699.do)。同时，还可以考虑一些通用的
    JavaScript 应用程序指南，如 *Nicholas Zakas* 的 *Maintainable JavaScript* ([http://shop.oreilly.com/product/0636920025245.do](http://shop.oreilly.com/product/0636920025245.do))
    和 *Douglas Crockford* 的开创性作品 *JavaScript: The Good Parts* ([http://shop.oreilly.com/product/9780596517748.do](http://shop.oreilly.com/product/9780596517748.do))。'
- en: 'Some Backbone.js application development hints and good practices for testable
    code include:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Backbone.js 应用程序开发提示和可测试代码的良好实践包括：
- en: '**Decouple components and limit dependencies**: Many Backbone.js components
    have optional dependencies on other components. For example, a Backbone.js view
    can optionally have a model declared in the view class (for example, `model: Foo`)
    or a model object can be passed to a view on instantiation (for example, `new
    View({model: foo})`). The latter technique often opens up more opportunities for
    injecting mocks or test-friendly models into the view code. The same logic also
    applies to the `el` property in Backbone.js views—it is often more test-friendly
    to provide values via a view object instance than in the view class definition.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦组件并限制依赖**：许多 Backbone.js 组件对其他组件有可选的依赖。例如，一个 Backbone.js 视图可以可选地在视图类中声明一个模型（例如，`model:
    Foo`）或模型对象可以在实例化视图时传递给视图（例如，`new View({model: foo})`）。后一种技术通常为将模拟或测试友好的模型注入视图代码提供了更多机会。相同的逻辑也适用于
    Backbone.js 视图中的 `el` 属性——通过视图对象实例提供值通常比在视图类定义中提供值更适合测试。'
- en: '**Isolate configuration information**: Any pure configuration data should get
    its own application file and facilitate the overriding of specific configurations.
    Canonical examples include the backend server host and port information, logging
    levels, and in the case of the Notes application, the name of the `localStorage`
    datastore. The previous examples that override `notes/app/js/app/config.js` provide
    a good introduction on how to both create a configuration file and supersede values
    for testing purposes.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离配置信息**：任何纯配置数据都应该有自己的应用程序文件，并便于覆盖特定配置。典型的例子包括后端服务器的主机和端口信息、日志级别，以及在笔记应用程序的情况下，`localStorage`
    数据存储的名称。之前覆盖 `notes/app/js/app/config.js` 的例子提供了如何创建配置文件以及为测试目的覆盖值的良好介绍。'
- en: '**Decompose large functions**: Monolithic functions that try to do everything
    are often difficult to test. Break up large functions into smaller ones, test
    them, and then aggregate the smaller functions into your application.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解大型函数**：试图做所有事情的单一函数通常很难测试。将大型函数分解成更小的部分，测试它们，然后将较小的函数聚合到你的应用程序中。'
- en: '**Avoid hidden state**: Using techniques such as closures and anonymous functions,
    JavaScript permits classes and code to have a state that is unchangeable and inaccessible
    to other parts of the application and tests. For example, if a class has an internal
    counter, make it a member variable and not a closure-wrapped variable. While this
    is something of a debated topic, it is generally preferred to expose some amount
    of internal state for test (and application) use. At the same time, our tests
    should focus on the application *behavior* and avoid deliberately using a internal
    state that is not part of the overall expected functioning of the application.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免隐藏状态**：使用闭包和匿名函数等技术，JavaScript 允许类和代码拥有不可更改且对应用程序和测试的其他部分不可访问的状态。例如，如果一个类有一个内部计数器，请将其作为成员变量而不是闭包包装的变量。虽然这是一个有争议的话题，但通常更倾向于为了测试（和应用）使用而暴露一些内部状态。同时，我们的测试应该关注应用程序的*行为*，并避免故意使用不属于应用程序整体预期功能的内部状态。'
- en: Please note that these tips are heuristics and not hard and fast rules. Many
    development situations will favor doing exactly the opposite of one or more of
    these suggestions. Hopefully, some of these guidelines will help make your early
    application decisions easier to live with as your application and test code bases
    grow over time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些提示是启发式方法，而不是铁的规则。许多开发情况可能会倾向于做与这些建议相反的事情。希望这些建议中的一些能帮助你使早期应用程序决策更容易随着时间的推移而适应。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dug into the Chai and Mocha test frameworks, starting with
    a tour of testing interfaces. We explored the many assertion statements available
    in Chai, then examined the creation of full Mocha test suites with setup/teardown,
    application configuration, and test specifications for Backbone.js components.
    Finally, we reviewed debugging tips and guidelines for a more test-friendly software
    development lifecycle.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Chai 和 Mocha 测试框架，从测试接口的概览开始。我们研究了 Chai 中可用的多种断言语句，然后检查了创建带有设置/清理、应用程序配置和
    Backbone.js 组件测试规范的完整 Mocha 测试套件。最后，我们回顾了调试技巧和指南，以使软件开发周期更加适合测试。
- en: At this point, our application has starting test coverage for some Backbone.js
    models, collections, and views. We will continue covering different parts of our
    Backbone.js application while introducing new topics in the subsequent chapters
    and work up to a final application test collection that aggregates all of our
    work.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序已经对一些 Backbone.js 模型、集合和视图开始了测试覆盖。在后续章节中介绍新主题的同时，我们将继续覆盖 Backbone.js
    应用程序的不同部分，并最终构建一个汇总所有工作的最终应用程序测试集合。
- en: In the next chapter, we will get more familiar with the Sinon.JS library. We
    will use test spies to verify program behavior and introspect how functions are
    called and respond within a Backbone.js application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更加熟悉 Sinon.JS 库。我们将使用测试间谍来验证程序行为，并内省在 Backbone.js 应用程序中函数是如何被调用以及如何响应的。
