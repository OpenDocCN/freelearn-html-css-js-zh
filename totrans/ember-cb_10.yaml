- en: Chapter 10. Awesome Tasks with Ember
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ember validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using D3.js with Ember.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ember with Sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ember with Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll learn everything from validating form data to looking
    at Ember's server-side rendering. Each recipe will show you the power and possibilities
    that Ember gives to create ambitious applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ember validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data form validation is a very common use case in web development. The end user
    will know immediately if they've made a mistake when you create validation rules
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a look at two examples on validation. In the first
    example, we'll use a component and check data based on a few simple validation
    rules. In the second example, we'll use a popular Ember add-on to make things
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, create two components and install the validation add-on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `val-example` component will be the first example. The `val-example2` component
    will be the second example using the `ember-cp-validations` add-on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `val-example.hbs` component template file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This component asks for an age. If the button is clicked, the `'check'` action
    will be triggered. A simple `input` helper is used to capture the input. The `{{error}}`
    property displays the error text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `val-example.js` component file, add a `check` action and simple `validation`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `check` action calls the `validation` method. The `validation` method's
    only purpose is to return `true` if the value is a number and return `false` if
    the value is not. This result is used to set the `error` property that will be
    used in the template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is a fairly simple example. It shows what you might need to validate the
    field. Another example might be creating a new computed property and have it depend
    on the `num` property. Either way will work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the component to the `application.hbs` template file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `val-example` component will render at `{{val-example}}`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` and enter a non-numeric value in the textbox. The following
    window will be displayed:![How to do it...](img/00073.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Error in box!** message is displayed because a number was not entered.
    This was triggered after the **Check** button was clicked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the next example, we'll use an Ember add-on instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `val-example2.hbs` template file so that it can accept an e-mail
    and number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This second component is a little more complicated than the first. We'll be
    validating two form fields, a number field and e-mail field. In addition, we'll
    be surrounding the message in a `div` tag that will be used to help set `color`
    of the text. Both fields will be validated after pressing the `check` button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `validations.js` file in the `components` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file is needed for the `ember-cp-validations` add-on. In this file, we
    define our validation rules. We begin by naming each property and defining the
    validations needed. We can validate many different types of inputs. A list of
    these validations can be found at [http://offirgolan.github.io/ember-cp-validations/docs/index.html](http://offirgolan.github.io/ember-cp-validations/docs/index.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `validator` add-on comes with several prebuilt messages. We can overwrite
    these messages by setting the `message` property. In the preceding code, the `num`
    and `email` validators have custom messages. The `num` validator checks to see
    whether any value is in the field and whether it's a number. The e-mail field
    checks to see whether the value is in the format of an e-mail address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new `check` action to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After setting up the `validations` file, you can add it to the component as
    a mixin. After adding the `validations` mixin, you''ll have access to the `validate()`
    method. This is a promise that returns after it validates the fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `validations` have an `isValid` property. This will only return `true` if
    both properties, `num` and `email`, passed `validation`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can check each individual validation as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can access the `model` properties in the component. This `model` will have
    both the `num` and email `properties`. We can use `validations.attrs.num.isInvalid`
    to check whether the validation failed. If it did, we can set `message` we created
    earlier with `validations.attrs.num.messages`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding code, if the validation is not valid, then we set the error
    message that will be displayed in the template after the `check` action is triggered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This add-on is very flexible. We can create our own custom validations if needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `application.hbs` file with the second component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will display the second component example in our application template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the Ember server and enter invalid values for age and e-mail, and click
    on the **Check** button. The following image will be displayed:![How to do it...](img/00074.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking on the **Check** button, an action is triggered. The validators
    we created earlier check the text and return whether the text is valid or not.
    In this instance, the text is not valid so it displays an error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data form validation is an extremely important feature of any web app. Any Ember
    application that has any type of user forms will need to validate data. Ember.js
    can retrieve data from templates and validate it. Other properties can be used
    to toggle or set error messages to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The Ember CP validations add-on makes this process easier. You can create your
    own validations or use some of the built-in ones. This code uses computed properties
    and other methods to validate and report back issues to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other popular validation add-ons available on Ember. Check
    out this website for more information: [http://emberobserver.com/categories/validations](http://emberobserver.com/categories/validations)'
  prefs: []
  type: TYPE_NORMAL
- en: Using D3.js with Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3.js is a JavaScript library used to manipulate document data. It can be used
    to create shapes, animations, and powerful visualizations. It uses web standards
    such as HTML, SVG, and CSS to accomplish its goals.
  prefs: []
  type: TYPE_NORMAL
- en: Ember.js can use D3 by importing it as a library using Bower or using it as
    an add-on. We'll be trying it out using Bower. However, you can install the popular
    `ember-cli-d3` package (`ember install ember-cli-d3`) instead and get some extra
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, run these commands in the `application` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `bower` command will install D3 and save it to the `bower.json` file. The
    component will end up holding all our D3 code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `ember-cli-build.js` file and add the `d3` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file is where we can add all our third-party libraries. To add D3, we have
    to add the `app.import` statement pointing to the directory where the D3 library
    is. At this point, D3 will be available to use anywhere in the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `d3-code.js` template file and add a `div` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be our placeholder for the animation we'll be creating later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `d3-code.js` file in the `components` folder. Add a new circle animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This component's purpose is to use D3 to create a new `svg` tag and a new `circle`
    object in it. To accomplish this, we want to render it on screen after the component
    loads. Ember.js views (`components`) have `didInsertElement`, `willInsertElement`,
    and `willDestroyElement` hooks. These all correspond to different points in the
    component's application life cycle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `willInsertElement` hook takes place after the view has rendered but before
    it has been inserted into the DOM. The `didInsertElement` hook occurs after the
    view has been inserted into the DOM. It's the most useful hook to use when dealing
    with third-party libraries such as D3\. The `willDestroyElement` hook is called
    before the element is removed from the DOM. This is a good place to put code that
    removes event handlers that you might have added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `svgContainer` variable creates the `svg` tag and appends it to the `div`
    holder we created earlier. The `circle` variable appends the `circle` tag that
    will be animated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the component to the application template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds the component to the application template so that it can be rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `ember server` and you'll see the circle move from one side of the screen
    to the other:![How to do it...](img/00075.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The circle will move from the top left-hand side corner to the bottom right-hand
    side corner after the page loads. This occurs after the component is completely
    rendered on screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3 uses web standards to generate powerful visualizations. Ember can import
    any third-party library using the built-in Broccoli library. Once a library is
    loaded, it can be accessed throughout the application. We can use the `didInsertElement`
    hook in our view to manipulate the DOM. D3 will render a circle on the screen
    and animate it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ember with Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebSockets** make it possible to open a communication session with a server.
    Ember.js does not handle this natively. However, there are some easy-to-use add-ons
    that can be used to make this possible.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, generate a new route and install the WebSockets add-on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install the component route and add-on that we need to begin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `components` template folder, edit the `w-s.hbs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this template, we have a `message` property and button that sends an action,
    `sendButtonPressed`. When the action is triggered, a message is sent to the server.
    The `message` property will display any messages returned from the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `w-s.js` component file so that it can handle the action from the
    template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The add-on installs a service called `websockets` in the application. It can
    be accessed by injecting it into the component using `Ember.inject.service`. As
    the property name matches the service name, we don't need to specify the service
    name in the inject statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To begin, we''ll set up the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `init` function in a component is called on when the object is instantiated.
    You can override this by setting up your own `init`. To make sure that nothing
    odd occurs, we must call `this._super()` so that Ember sets up the component correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `socket.on` method creates three events called `open`, `message`, and `close`.
    During instantiation, these three event handlers are created. The first one handles
    events that occur when a connection is made with the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The WebSocket service can be set up using the `socketFor` method. This tells
    the service where the server is located.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the connection is established, a message is logged to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second event is triggered when a message is received from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a message is received, it''s set to the `message` property. The last
    event is triggered when the connection with the server is closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This logs a message to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `sendButtonPressed` action creates a message and sends it to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the action is triggered, we use the existing `socket` property to send
    a message out to the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `w-s` component to the `ws.hbs` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The component will render at `{{w-s}}`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Load the server and navigate to the `w-s` route at `/ws`. You'll see the following
    message:![How to do it...](img/00076.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This message displays the values from the server. Pressing the button sends
    a message to the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can see how we can take this simple example and create a complete chat server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSockets helps facilitate communication between a server and browser. The
    browser can send and receive data over sockets. This can be used with event-driven
    messages or APIs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to implement a WebSockets server. A great way to do this
    is to use the ws library. In the following steps, we''ll create a basic WebSockets
    server to use with this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new empty directory and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Follow the prompts and create your project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install the `ws` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install the `ws` `npm` package and save it to the `package.json` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `server.js` file. Create a simple WebSockets server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the node server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This server creates `port` open at `7000`. It then waits for a connection. If
    it receives a message, it outputs it to the console and returns a new message.
    This will be displayed in the Ember template file and received by the message
    handler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Ember with Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is a backend as a service provider. It can store data and authenticate
    your users with just a few lines of code. It integrates well with many different
    frameworks, including Ember.js.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a look at a few of the features of Firebase by creating
    a blogging application. This app will allow users to create, edit, or delete posts.
    Users will be able to log in with Twitter and be authenticated as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before getting started, we must set up an account with Firebase at [http://www.firebase.com](http://www.firebase.com).
    Google owns Firebase so this should be really easy. In fact, you should be able
    to log in directly with your Google credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in, you''ll need to create a new application and set up a new
    provider. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application in the Firebase dashboard. It should look like the
    following image. Write down **APP URL** for later:![Getting ready](img/00077.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the app, click on **manage** and then click on the left-hand
    side, where it says **Login & Auth**. Click on **Twitter** and enter your **Twitter
    API Key** and **Twitter API Secret**:![Getting ready](img/00078.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get these keys, you'll need to create a new application through Twitter.
    To do this, go to `apps.twitter.com` and click on **CREATE NEW APP**. Follow the
    onscreen instructions. Make sure to set the callback URL to `https://auth.firebase.com/auth/twitter/callback`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should be it. Make sure that you write down the name of the URL that Firebase
    created. You'll need it later when you set everything up in the `environment.js`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, generate and install these files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The files generated will be the skeleton of our application. The two `install`
    commands will install the necessary files for Firebase with authentication using
    an add-on called `torii`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that the application adapter is set up for Firebase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adapter is automatically generated for us when we install the `emberfire`
    add-on. It injects the Firebase service into our application and data store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure the `emberfire` adapter by editing the `environment.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To use Firebase, you must set the `firebase` property to your Firebase URL that
    you created earlier. Make sure that the `torii` property is also set so that we
    can use the `session` object in our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new folder called `torii-adapters` and add the `application.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Torii is a type of authentication abstraction for Ember.js. This will make it
    possible to use the session variable in our program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `clean.j`s file in the `utils` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file is simply used to clean a URL and return it. In other words, it removes
    anything other than dashes and the characters, `a-z`. We'll be using this later
    for our URLs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take a look at the model file and make sure that it looks *OK*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The model contains all the data we'll be using for each post in our application.
    This should have been generated earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `router.js` file using the `titleURL` as the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some of this was generated for us when we created the posts and new route. However,
    we want to make sure that `titleURL` is set to the path of each individual post.
    We do this by passing the `:titleURL` dynamic segment to the path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the query for each individual post to the posts route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the user navigates to the `/posts` URL, the model will expect a parameter
    passed in. For example, if you navigate to `/posts/my_post`, the `my_post` segment
    will be passed as a parameter that can be accessed in the route. We'll use this
    parameter in the Firebase `this.store.query` method. The first argument is the
    name of the model. We can then use `orderBy` and `equalTo` to specify the exact
    post that we are looking for.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Uniqueness**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can imagine, when creating a new post, the title may or may not be unique.
    The `this.store.query` method will return all results as an array to the model.
    We could enforce uniqueness in Firebase by making the `titleURL` unique. Another
    possibility would be to check the uniqueness of the post title during creation.
    Either way, for this example, we'll assume that all titleURLs are unique.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the application route file and add the model and a few actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want the main application to have access to the model route so that we can
    use the `findAll` method to retrieve all posts. This is basically the same as
    the Ember Data method we've used in previous recipes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are two actions, `login` and `logout`. As we injected, using `torii`,
    our session into the program, we can access it from anywhere. By invoking `this.get('session')`,
    we can `open` or `close` a session. Firebase has several built-in authenticators,
    including Twitter and Facebook. The `login` action in this example will `open`
    a window to `twitter` so that the user can be authenticated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Firebase security**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With any JavaScript browser application, security can be tricky. Firebase makes
    this a little easier for us. Firebase keeps track of users that are authenticated.
    In the Firebase dashboard, you can set rules that make it possible for only authenticated
    users to receive data. This is a little beyond the scope of this recipe. However,
    it is possible to secure your data with Firebase using a third-party authenticator
    such as Twitter or Facebook.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the application template file. Add a navigation bar at the top and buttons
    to log in, log out, and add a new post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we have installed the `ember-bootstrap` add-on, we can create a really simple
    top navigation bar. The `login` and `logout` buttons are surrounded by the `if`
    helper. In every template, you have access to the `session` property. This property
    has a method called `isAuthenticated` that returns `true` if the user is logged
    in and `false` if the user is not logged in. We can use this to show the `login`
    button only if the user is *NOT* logged in. If the user is logged in, they'll
    see a `logout` button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We don't have an application controller, so these actions will bubble up to
    the application route where they'll be handled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now update the `index.hbs` file with a link to each individual post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `model` loops through each post and displays the `title` on the screen.
    Each `titleURL` is passed as a parameter to the posts route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the new template, add some textboxes so that the user can add a post. Add
    a section to preview a post as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new template will be used to create a new post. The `textarea` helper creates
    two textboxes. The form has a `save` action that will be triggered when the form
    is submitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When setting up the project, we installed a `markdown` add-on. This allows us
    to use `markdown` in the body of the post. Markdown is a text-to-HTML conversion
    tool. It makes it easier to write HTML in your text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the posts template, display each post and show a way to edit the post as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This displays each individual post. If the user is authenticated, they can either
    delete or edit the post.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once again, we use the `textarea` template helpers to display the textboxes.
    The form has an edit action attached that will set the `isEditing` property to
    `true` so that the post can be edited. The `delete` action deletes the post.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `save` action to the new controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `save` action is used to save the data to Firebase. First, it takes the
    title of the post and uses the utility, `cleanURI`, to remove all special characters
    and spaces. Firebase has a function called `createRecord` that is used to create
    new records. We then save the record to the store and `set` the values back to
    default. Finally, the application transitions back to the index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the posts controller, add actions for `edit`, `delete`, and `save`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break this down into more detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The edit function sets the `isEditing` property to `true`. The posts template
    uses this property to show or not show the editing window:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `delete` action deletes the record. To do this, we must use the `forEach`
    method on our `model`. In the route, we used the `query` method, which returns
    an array. Therefore, we have to go through every record returned, and delete it.
    Once again, we''ll assume that every title is unique and only has one record.
    Remember to always .`save()` so that the record is persisted in Firebase. After
    the record is deleted, we transition to the index route:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `save` function gets the title, cleans it, sets it, and saves the model.
    In this example, we must use the `forEach` method to iterate over the array. Afterward,
    we set the `isEditing` property back to `false` and transition back to the `index`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the application and the following screen will be displayed:![How to do it...](img/00079.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This displays the top left corner of the screen. No posts are listed as we
    haven''t added them yet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00080.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The top right corner of the screen will show the **Login** button. We'll need
    to log in by pressing this button. This will bring a popup asking for credentials
    to our Twitter account. After logging in, the **Add New Post** text will be displayed:![How
    to do it...](img/00081.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on **Add New Post** will display the following screen:![How to do it...](img/00082.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that the preview takes the markdown and converts it to HTML. After
    adding the new post, it will then be listed:![How to do it...](img/00083.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the title will bring us to an edit screen. Here, we can **Edit**
    or **Delete** the post:![How to do it...](img/00084.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the **Edit** button will bring up the edit screen:![How to do it...](img/00085.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, we can make any changes and save it back again. Each time a save
    occurs, the post is persisted in Firebase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firebase talks to its backend service via the `emberfire` and `torii` add-ons.
    EmberFire is an official Ember Data adapter. It has many of the same features
    as other popular adapters. It can save, delete, edit, and query data fairly easily.
    One of its purposes is to make it really easy to persist and save data without
    having to set up your own backend.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase also has authentication providers that it can hook into. Firebase handles
    all the authentication between the provider and application. All that this requires
    is that the provider is set up in Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: Using server side rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember.js runs in the browser. It uses JavaScript to handle all the routing and
    rendering of data. It only talks to the server on the initial page load and to
    retrieve JSON data. This can have some limitations. Larger applications might
    take longer to load on slower connections and there is still some concern around
    search engine optimization.
  prefs: []
  type: TYPE_NORMAL
- en: To help alleviate these concerns, the Ember team created **FastBoot**. FastBoot
    is an Ember CLI add-on that allows Ember.js to render and serve applications on
    the server. It's a work in progress as of writing this and has some limitations.
    It's not recommended for production and doesn't work with jQuery or `didInsertElement`.
    It will hopefully be production-ready by Ember v2.4.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, it's improving and is an important add-on for Ember.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new application, run these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: FastBoot requires the `canary` version of Ember to work. We must delete the
    `bower_components` folder before installing. During installation, you may get
    a message that Bower cannot find a suitable version of Ember. This is normal;
    make sure to choose `ember#canary` from the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build the application for production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will build the production server and minify all the files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the Ember FastBoot server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will run the FastBoot server. Let''s break down these arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**--serve-assets**: This serves the assets out of the `dist` folder.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--port 4200**: This specifies the port. The default is 3000\. In this case,
    we can use `4200` to match the test server that we normally use.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--environment production**: The default is development. Use production. It
    works better as Ember FastBoot is faster with minified files.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open up localhost at port `4200` to see the web page load:![How to do it...](img/00086.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The page doesn't look any different. However, if you look at the browser console,
    you'll notice that the Ember application rendered without downloading all the
    JavaScript it normally needs to run in the browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember FastBoot is an Ember add-on that's being worked on. As of writing this,
    it has a lot of limitations. With this said, it will eventually allow you to render
    your Ember.js application on the server, or at least part of the application,
    for the initial page load. This will help reduce page load times significantly.
    To learn more about Ember FastBoot, check out their website at [https://github.com/tildeio/ember-cli-fastboot](https://github.com/tildeio/ember-cli-fastboot).
  prefs: []
  type: TYPE_NORMAL
