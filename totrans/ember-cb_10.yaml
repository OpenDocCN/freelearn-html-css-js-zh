- en: Chapter 10. Awesome Tasks with Ember
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. 使用 Ember 的精彩任务
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍以下菜谱：
- en: Using Ember validations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ember 验证
- en: Using D3.js with Ember.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 D3.js 与 Ember.js
- en: Using Ember with Sockets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ember 与 Sockets
- en: Using Ember with Firebase
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ember 与 Firebase
- en: Using server-side rendering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器端渲染
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you'll learn everything from validating form data to looking
    at Ember's server-side rendering. Each recipe will show you the power and possibilities
    that Ember gives to create ambitious applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习从验证表单数据到查看 Ember 的服务器端渲染的每一件事。每个菜谱都将向你展示 Ember 为创建雄心勃勃的应用程序所提供的强大功能和可能性。
- en: Using Ember validations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ember 验证
- en: Data form validation is a very common use case in web development. The end user
    will know immediately if they've made a mistake when you create validation rules
    in your application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表单验证在Web开发中是一个非常常见的用例。当你在应用程序中创建验证规则时，最终用户会立即知道他们是否犯了错误。
- en: In this recipe, we'll take a look at two examples on validation. In the first
    example, we'll use a component and check data based on a few simple validation
    rules. In the second example, we'll use a popular Ember add-on to make things
    easier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看两个验证示例。在第一个示例中，我们将使用一个组件并根据一些简单的验证规则检查数据。在第二个示例中，我们将使用一个流行的 Ember
    插件来简化操作。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, create two components and install the validation add-on:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用中，创建两个组件并安装验证插件：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `val-example` component will be the first example. The `val-example2` component
    will be the second example using the `ember-cp-validations` add-on.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`val-example` 组件将是第一个示例。`val-example2` 组件将使用 `ember-cp-validations` 插件作为第二个示例。'
- en: 'Update the `val-example.hbs` component template file:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `val-example.hbs` 组件模板文件：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This component asks for an age. If the button is clicked, the `'check'` action
    will be triggered. A simple `input` helper is used to capture the input. The `{{error}}`
    property displays the error text.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此组件要求输入年龄。如果点击按钮，将触发 `'check'` 动作。使用简单的 `input` 辅助器来捕获输入。`{{error}}` 属性显示错误文本。
- en: 'In the `val-example.js` component file, add a `check` action and simple `validation`
    method:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `val-example.js` 组件文件中，添加一个 `check` 动作和简单的 `validation` 方法：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `check` action calls the `validation` method. The `validation` method's
    only purpose is to return `true` if the value is a number and return `false` if
    the value is not. This result is used to set the `error` property that will be
    used in the template.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`check` 动作调用 `validation` 方法。`validation` 方法的唯一目的是如果值是数字则返回 `true`，如果值不是数字则返回
    `false`。这个结果用于设置模板中将要使用的 `error` 属性。'
- en: This is a fairly simple example. It shows what you might need to validate the
    field. Another example might be creating a new computed property and have it depend
    on the `num` property. Either way will work.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个相当简单的示例。它展示了你可能需要验证字段的内容。另一个示例可能是创建一个新的计算属性，使其依赖于 `num` 属性。无论哪种方式都行得通。
- en: 'Add the component to the `application.hbs` template file:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件添加到 `application.hbs` 模板文件：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `val-example` component will render at `{{val-example}}`.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`val-example` 组件将在 `{{val-example}}` 处渲染。'
- en: Run `ember server` and enter a non-numeric value in the textbox. The following
    window will be displayed:![How to do it...](img/00073.jpeg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server` 并在文本框中输入一个非数字值。以下窗口将显示：![如何操作...](img/00073.jpeg)
- en: The **Error in box!** message is displayed because a number was not entered.
    This was triggered after the **Check** button was clicked.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**框内错误** 消息显示是因为没有输入数字。这是在点击 **检查** 按钮后触发的。'
- en: For the next example, we'll use an Ember add-on instead.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于下一个示例，我们将使用一个 Ember 插件。
- en: 'Update the `val-example2.hbs` template file so that it can accept an e-mail
    and number:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `val-example2.hbs` 模板文件，使其能够接受电子邮件和数字：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This second component is a little more complicated than the first. We'll be
    validating two form fields, a number field and e-mail field. In addition, we'll
    be surrounding the message in a `div` tag that will be used to help set `color`
    of the text. Both fields will be validated after pressing the `check` button.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个组件比第一个复杂一些。我们将验证两个表单字段，一个数字字段和一个电子邮件字段。此外，我们将在一个 `div` 标签中包围消息，该标签将用于帮助设置文本的
    `color`。在按下 `check` 按钮后，这两个字段都将被验证。
- en: 'Create a new `validations.js` file in the `components` folder:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 文件夹中创建一个新的 `validations.js` 文件：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This file is needed for the `ember-cp-validations` add-on. In this file, we
    define our validation rules. We begin by naming each property and defining the
    validations needed. We can validate many different types of inputs. A list of
    these validations can be found at [http://offirgolan.github.io/ember-cp-validations/docs/index.html](http://offirgolan.github.io/ember-cp-validations/docs/index.html).
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件是 `ember-cp-validations` 插件所需的。在这个文件中，我们定义我们的验证规则。我们首先命名每个属性并定义所需的验证。我们可以验证许多不同类型的输入。这些验证的列表可以在
    [http://offirgolan.github.io/ember-cp-validations/docs/index.html](http://offirgolan.github.io/ember-cp-validations/docs/index.html)
    找到。
- en: The `validator` add-on comes with several prebuilt messages. We can overwrite
    these messages by setting the `message` property. In the preceding code, the `num`
    and `email` validators have custom messages. The `num` validator checks to see
    whether any value is in the field and whether it's a number. The e-mail field
    checks to see whether the value is in the format of an e-mail address.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`validator` 插件附带了一些预构建的消息。我们可以通过设置 `message` 属性来覆盖这些消息。在上面的代码中，`num` 和 `email`
    验证器有自定义消息。`num` 验证器检查字段中是否有任何值，并且它是否是一个数字。电子邮件字段检查值是否为电子邮件地址的格式。'
- en: 'Add a new `check` action to the component:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向组件添加一个新的 `check` 动作：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After setting up the `validations` file, you can add it to the component as
    a mixin. After adding the `validations` mixin, you''ll have access to the `validate()`
    method. This is a promise that returns after it validates the fields:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好 `validations` 文件后，你可以将其作为混合添加到组件中。添加 `validations` 混合后，你将能够访问 `validate()`
    方法。这是一个在验证字段后返回的承诺：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `validations` have an `isValid` property. This will only return `true` if
    both properties, `num` and `email`, passed `validation`.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`validations` 有一个 `isValid` 属性。只有当 `num` 和 `email` 这两个属性都通过了 `validation`，它才会返回
    `true`。'
- en: 'We can check each individual validation as well:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以检查每个单独的验证：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can access the `model` properties in the component. This `model` will have
    both the `num` and email `properties`. We can use `validations.attrs.num.isInvalid`
    to check whether the validation failed. If it did, we can set `message` we created
    earlier with `validations.attrs.num.messages`.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在组件中访问 `model` 属性。这个 `model` 将包含 `num` 和电子邮件 `properties`。我们可以使用 `validations.attrs.num.isInvalid`
    来检查验证是否失败。如果失败了，我们可以使用 `validations.attrs.num.messages` 设置我们之前创建的 `message`。
- en: In the preceding code, if the validation is not valid, then we set the error
    message that will be displayed in the template after the `check` action is triggered.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上面的代码中，如果验证无效，那么在触发 `check` 动作后，我们将设置要在模板中显示的错误消息。
- en: This add-on is very flexible. We can create our own custom validations if needed.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此插件非常灵活。如果需要，我们可以创建自己的自定义验证。
- en: 'Update the `application.hbs` file with the second component:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第二个组件更新 `application.hbs` 文件：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will display the second component example in our application template.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在我们的应用模板中显示第二个组件示例。
- en: Start the Ember server and enter invalid values for age and e-mail, and click
    on the **Check** button. The following image will be displayed:![How to do it...](img/00074.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Ember 服务器，并输入无效的年龄和电子邮件值，然后点击 **检查** 按钮。以下图像将被显示：![如何操作...](img/00074.jpeg)
- en: After clicking on the **Check** button, an action is triggered. The validators
    we created earlier check the text and return whether the text is valid or not.
    In this instance, the text is not valid so it displays an error message.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在点击 **检查** 按钮后，将触发一个动作。我们之前创建的验证器将检查文本并返回文本是否有效。在这个例子中，文本无效，因此显示了一个错误消息。
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Data form validation is an extremely important feature of any web app. Any Ember
    application that has any type of user forms will need to validate data. Ember.js
    can retrieve data from templates and validate it. Other properties can be used
    to toggle or set error messages to be displayed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表单验证是任何网络应用的一个极其重要的功能。任何具有任何类型用户表单的 Ember 应用都需要验证数据。Ember.js 可以从模板中检索数据并进行验证。其他属性可以用来切换或设置要显示的错误消息。
- en: The Ember CP validations add-on makes this process easier. You can create your
    own validations or use some of the built-in ones. This code uses computed properties
    and other methods to validate and report back issues to the user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ember CP 验证插件使这个过程更容易。你可以创建自己的验证或使用一些内置的验证。此代码使用计算属性和其他方法来验证并向用户报告问题。
- en: 'There are several other popular validation add-ons available on Ember. Check
    out this website for more information: [http://emberobserver.com/categories/validations](http://emberobserver.com/categories/validations)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ember 中还有其他几个流行的验证插件可用。查看此网站获取更多信息：[http://emberobserver.com/categories/validations](http://emberobserver.com/categories/validations)
- en: Using D3.js with Ember.js
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ember.js 与 D3.js
- en: D3.js is a JavaScript library used to manipulate document data. It can be used
    to create shapes, animations, and powerful visualizations. It uses web standards
    such as HTML, SVG, and CSS to accomplish its goals.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 是一个用于操作文档数据的 JavaScript 库。它可以用来创建形状、动画和强大的可视化。它使用 Web 标准，如 HTML、SVG 和
    CSS 来实现其目标。
- en: Ember.js can use D3 by importing it as a library using Bower or using it as
    an add-on. We'll be trying it out using Bower. However, you can install the popular
    `ember-cli-d3` package (`ember install ember-cli-d3`) instead and get some extra
    functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 可以通过使用 Bower 或作为插件来导入 D3。我们将使用 Bower 来尝试它。然而，你也可以安装流行的 `ember-cli-d3`
    包（`ember install ember-cli-d3`）并获取一些额外的功能。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, run these commands in the `application` folder:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新应用程序中，在 `application` 文件夹中运行以下命令：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `bower` command will install D3 and save it to the `bower.json` file. The
    component will end up holding all our D3 code.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`bower` 命令将安装 D3 并将其保存到 `bower.json` 文件中。组件最终将包含我们所有的 D3 代码。'
- en: 'Edit the `ember-cli-build.js` file and add the `d3` file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `ember-cli-build.js` 文件并添加 `d3` 文件：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This file is where we can add all our third-party libraries. To add D3, we have
    to add the `app.import` statement pointing to the directory where the D3 library
    is. At this point, D3 will be available to use anywhere in the application.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个文件是我们添加所有第三方库的地方。要添加 D3，我们必须添加指向 D3 库目录的 `app.import` 语句。此时，D3 将在应用程序的任何地方可用。
- en: 'Open the `d3-code.js` template file and add a `div` tag:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `d3-code.js` 模板文件并添加一个 `div` 标签：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will be our placeholder for the animation we'll be creating later.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将是我们在稍后创建的动画的占位符。
- en: 'Edit the `d3-code.js` file in the `components` folder. Add a new circle animation:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `components` 文件夹中的 `d3-code.js` 文件。添加一个新的圆圈动画：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This component's purpose is to use D3 to create a new `svg` tag and a new `circle`
    object in it. To accomplish this, we want to render it on screen after the component
    loads. Ember.js views (`components`) have `didInsertElement`, `willInsertElement`,
    and `willDestroyElement` hooks. These all correspond to different points in the
    component's application life cycle.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个组件的目的是使用 D3 创建一个新的 `svg` 标签和一个新的 `circle` 对象。为了实现这一点，我们希望在组件加载后将其渲染到屏幕上。Ember.js
    视图（`components`）有 `didInsertElement`、`willInsertElement` 和 `willDestroyElement`
    钩子。这些都与组件的应用程序生命周期中的不同点相对应。
- en: The `willInsertElement` hook takes place after the view has rendered but before
    it has been inserted into the DOM. The `didInsertElement` hook occurs after the
    view has been inserted into the DOM. It's the most useful hook to use when dealing
    with third-party libraries such as D3\. The `willDestroyElement` hook is called
    before the element is removed from the DOM. This is a good place to put code that
    removes event handlers that you might have added.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`willInsertElement` 钩子在视图渲染后但插入到 DOM 之前发生。`didInsertElement` 钩子在视图被插入到 DOM
    之后发生。当处理第三方库如 D3 时，这是最有用的钩子。`willDestroyElement` 钩子在元素从 DOM 中移除之前被调用。这是一个放置代码的好地方，这些代码可以移除你可能添加的事件处理器。'
- en: The `svgContainer` variable creates the `svg` tag and appends it to the `div`
    holder we created earlier. The `circle` variable appends the `circle` tag that
    will be animated.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`svgContainer` 变量创建 `svg` 标签并将其附加到我们之前创建的 `div` 持有器中。`circle` 变量附加了将被动画化的 `circle`
    标签。'
- en: 'Add the component to the application template:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件添加到应用程序模板中：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This adds the component to the application template so that it can be rendered.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会将组件添加到应用程序模板中，以便它可以被渲染。
- en: Run `ember server` and you'll see the circle move from one side of the screen
    to the other:![How to do it...](img/00075.jpeg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ember server`，你会看到圆圈从屏幕的一侧移动到另一侧：![如何操作...](img/00075.jpeg)
- en: The circle will move from the top left-hand side corner to the bottom right-hand
    side corner after the page loads. This occurs after the component is completely
    rendered on screen.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面加载后，圆圈将从左上角移动到右下角。这发生在组件完全渲染到屏幕上之后。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: D3 uses web standards to generate powerful visualizations. Ember can import
    any third-party library using the built-in Broccoli library. Once a library is
    loaded, it can be accessed throughout the application. We can use the `didInsertElement`
    hook in our view to manipulate the DOM. D3 will render a circle on the screen
    and animate it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: D3使用网络标准生成强大的可视化。Ember可以使用内置的Broccoli库导入任何第三方库。一旦加载了库，就可以在整个应用程序中访问它。我们可以使用视图中的`didInsertElement`钩子来操作DOM。D3将在屏幕上绘制一个圆并对其动画化。
- en: Using Ember with Sockets
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ember和Sockets
- en: '**WebSockets** make it possible to open a communication session with a server.
    Ember.js does not handle this natively. However, there are some easy-to-use add-ons
    that can be used to make this possible.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket**使与服务器建立通信会话成为可能。Ember.js本身不处理这个功能。然而，有一些易于使用的扩展包可以用来实现这一点。'
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In a new application, generate a new route and install the WebSockets add-on:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用程序中，生成一个新的路由并安装WebSocket扩展包：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will install the component route and add-on that we need to begin.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装我们开始所需的组件路由和扩展包。
- en: 'In the `components` template folder, edit the `w-s.hbs` file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`模板文件夹中，编辑`w-s.hbs`文件：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this template, we have a `message` property and button that sends an action,
    `sendButtonPressed`. When the action is triggered, a message is sent to the server.
    The `message` property will display any messages returned from the server.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个模板中，我们有一个`message`属性和发送操作的按钮，即`sendButtonPressed`。当操作被触发时，会向服务器发送一条消息。`message`属性将显示从服务器返回的任何消息。
- en: 'Update the `w-s.js` component file so that it can handle the action from the
    template:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`w-s.js`组件文件，使其能够处理来自模板的操作：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The add-on installs a service called `websockets` in the application. It can
    be accessed by injecting it into the component using `Ember.inject.service`. As
    the property name matches the service name, we don't need to specify the service
    name in the inject statement.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展包在应用程序中安装了一个名为`websockets`的服务。可以通过使用`Ember.inject.service`将其注入到组件中来访问它。由于属性名与服务名匹配，我们不需要在注入语句中指定服务名。
- en: 'To begin, we''ll set up the `init` function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将设置`init`函数：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `init` function in a component is called on when the object is instantiated.
    You can override this by setting up your own `init`. To make sure that nothing
    odd occurs, we must call `this._super()` so that Ember sets up the component correctly.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件中的`init`函数在对象实例化时被调用。你可以通过设置自己的`init`来覆盖它。为了确保不会发生奇怪的事情，我们必须调用`this._super()`，这样Ember就可以正确设置组件。
- en: The `socket.on` method creates three events called `open`, `message`, and `close`.
    During instantiation, these three event handlers are created. The first one handles
    events that occur when a connection is made with the server.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`socket.on`方法创建了三个事件，分别称为`open`、`message`和`close`。在实例化过程中，创建了这三个事件处理器。第一个处理器处理与服务器建立连接时发生的事件。'
- en: The WebSocket service can be set up using the `socketFor` method. This tells
    the service where the server is located.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用`socketFor`方法设置WebSocket服务。这告诉服务服务器所在的位置。
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the connection is established, a message is logged to the console.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当连接建立时，会在控制台记录一条消息。
- en: 'The second event is triggered when a message is received from the server:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个事件是在从服务器接收到消息时触发的：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After a message is received, it''s set to the `message` property. The last
    event is triggered when the connection with the server is closed:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收消息后，它被设置为`message`属性。当与服务器断开连接时，触发最后一个事件：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This logs a message to the console.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在控制台记录一条消息。
- en: 'The `sendButtonPressed` action creates a message and sends it to the server:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sendButtonPressed`操作创建一条消息并将其发送到服务器：'
- en: '[PRE22]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After the action is triggered, we use the existing `socket` property to send
    a message out to the server.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作被触发后，我们使用现有的`socket`属性向服务器发送消息。
- en: 'Add the `w-s` component to the `ws.hbs` route:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`w-s`组件添加到`ws.hbs`路由：
- en: '[PRE23]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The component will render at `{{w-s}}`.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件将在`{{w-s}}`处渲染。
- en: Load the server and navigate to the `w-s` route at `/ws`. You'll see the following
    message:![How to do it...](img/00076.jpeg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载服务器并导航到`/ws`路由的`w-s`。你会看到以下消息：![如何做...](img/00076.jpeg)
- en: This message displays the values from the server. Pressing the button sends
    a message to the server.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这条消息显示了来自服务器的值。按下按钮会将消息发送到服务器。
- en: You can see how we can take this simple example and create a complete chat server.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到我们如何从这个简单的例子中创建一个完整的聊天服务器。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: WebSockets helps facilitate communication between a server and browser. The
    browser can send and receive data over sockets. This can be used with event-driven
    messages or APIs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 有助于促进服务器和浏览器之间的通信。浏览器可以通过套接字发送和接收数据。这可以与事件驱动的消息或 API 一起使用。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are many ways to implement a WebSockets server. A great way to do this
    is to use the ws library. In the following steps, we''ll create a basic WebSockets
    server to use with this recipe:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 WebSockets 服务器有许多方法。一种很好的方法是使用 ws 库。在以下步骤中，我们将创建一个基本的 WebSockets 服务器，用于本菜谱：
- en: 'Create a new empty directory and run this command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空目录并运行此命令：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Follow the prompts and create your project.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照提示创建你的项目。
- en: 'Install the `ws` package:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `ws` 包：
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will install the `ws` `npm` package and save it to the `package.json` file.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装 `ws` `npm` 包并将其保存到 `package.json` 文件中。
- en: 'Create a new `server.js` file. Create a simple WebSockets server:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `server.js` 文件。创建一个简单的 WebSockets 服务器：
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start the node server:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动节点服务器：
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This server creates `port` open at `7000`. It then waits for a connection. If
    it receives a message, it outputs it to the console and returns a new message.
    This will be displayed in the Ember template file and received by the message
    handler.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个服务器在 `7000` 端口上创建了一个 `port`。然后它等待连接。如果它收到一条消息，它将输出到控制台并返回一条新消息。这将显示在 Ember
    模板文件中并由消息处理程序接收。
- en: Using Ember with Firebase
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ember 与 Firebase
- en: Firebase is a backend as a service provider. It can store data and authenticate
    your users with just a few lines of code. It integrates well with many different
    frameworks, including Ember.js.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 是一个后端即服务提供商。它只需几行代码即可存储数据和认证你的用户。它与许多不同的框架很好地集成，包括 Ember.js。
- en: In this recipe, we'll take a look at a few of the features of Firebase by creating
    a blogging application. This app will allow users to create, edit, or delete posts.
    Users will be able to log in with Twitter and be authenticated as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过创建一个博客应用来查看 Firebase 的几个功能。这个应用将允许用户创建、编辑或删除帖子。用户可以使用 Twitter 登录并完成认证。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before getting started, we must set up an account with Firebase at [http://www.firebase.com](http://www.firebase.com).
    Google owns Firebase so this should be really easy. In fact, you should be able
    to log in directly with your Google credentials.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们必须在 Firebase 上创建一个账户，网址为 [http://www.firebase.com](http://www.firebase.com)。由于
    Google 拥有 Firebase，所以这应该非常简单。实际上，你应该可以直接使用你的 Google 凭证登录。
- en: 'After logging in, you''ll need to create a new application and set up a new
    provider. Follow these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你需要创建一个新的应用并设置一个新的提供者。按照以下步骤操作：
- en: Create a new application in the Firebase dashboard. It should look like the
    following image. Write down **APP URL** for later:![Getting ready](img/00077.jpeg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Firebase 控制台中创建一个新的应用。它应该看起来像以下图片。记下**应用 URL**以备后用：![准备工作](img/00077.jpeg)
- en: After creating the app, click on **manage** and then click on the left-hand
    side, where it says **Login & Auth**. Click on **Twitter** and enter your **Twitter
    API Key** and **Twitter API Secret**:![Getting ready](img/00078.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用后，点击**管理**，然后点击左侧的**登录与认证**。点击**Twitter**并输入你的**Twitter API 密钥**和**Twitter
    API 密钥**：![准备工作](img/00078.jpeg)
- en: To get these keys, you'll need to create a new application through Twitter.
    To do this, go to `apps.twitter.com` and click on **CREATE NEW APP**. Follow the
    onscreen instructions. Make sure to set the callback URL to `https://auth.firebase.com/auth/twitter/callback`.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要获取这些密钥，你需要通过 Twitter 创建一个新的应用。为此，请访问 `apps.twitter.com` 并点击**创建新应用**。遵循屏幕上的说明。确保将回调
    URL 设置为 `https://auth.firebase.com/auth/twitter/callback`。
- en: This should be it. Make sure that you write down the name of the URL that Firebase
    created. You'll need it later when you set everything up in the `environment.js`
    file.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就足够了。确保你记下 Firebase 创建的 URL 名称。你稍后设置 `environment.js` 文件中的所有内容时需要它。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In a new application, generate and install these files:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用中，生成并安装这些文件：
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The files generated will be the skeleton of our application. The two `install`
    commands will install the necessary files for Firebase with authentication using
    an add-on called `torii`.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的文件将是我们的应用程序的骨架。两个 `install` 命令将使用名为 `torii` 的附加组件安装 Firebase 认证所需的文件。
- en: 'Verify that the application adapter is set up for Firebase:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证应用程序适配器是否已为 Firebase 设置：
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This adapter is automatically generated for us when we install the `emberfire`
    add-on. It injects the Firebase service into our application and data store.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此适配器在我们安装 `emberfire` 扩展时自动为我们生成。它将 Firebase 服务注入到我们的应用程序和数据存储中。
- en: 'Configure the `emberfire` adapter by editing the `environment.js` file:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑 `environment.js` 文件来配置 `emberfire` 适配器：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To use Firebase, you must set the `firebase` property to your Firebase URL that
    you created earlier. Make sure that the `torii` property is also set so that we
    can use the `session` object in our application.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用 Firebase，您必须将 `firebase` 属性设置为之前创建的 Firebase URL。确保 `torii` 属性也已设置，这样我们就可以在我们的应用程序中使用
    `session` 对象。
- en: 'Add a new folder called `torii-adapters` and add the `application.js` file:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `torii-adapters` 的新文件夹中添加 `application.js` 文件：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Torii is a type of authentication abstraction for Ember.js. This will make it
    possible to use the session variable in our program.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Torii 是 Ember.js 的认证抽象类型。这将使我们在程序中使用会话变量成为可能。
- en: 'Update the `clean.j`s file in the `utils` folder:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `utils` 文件夹中的 `clean.j`s 文件：
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This file is simply used to clean a URL and return it. In other words, it removes
    anything other than dashes and the characters, `a-z`. We'll be using this later
    for our URLs.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件仅用于清理 URL 并返回它。换句话说，它移除了除破折号和字符 `a-z` 之外的所有内容。我们将在稍后为我们的 URL 使用此功能。
- en: 'Let''s take a look at the model file and make sure that it looks *OK*:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一下模型文件，确保它看起来 *OK*：
- en: '[PRE33]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The model contains all the data we'll be using for each post in our application.
    This should have been generated earlier.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型包含我们将用于应用程序中每个帖子的所有数据。这应该是在之前生成的。
- en: 'Update the `router.js` file using the `titleURL` as the path:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `titleURL` 作为路径来更新 `router.js` 文件：
- en: '[PRE34]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Some of this was generated for us when we created the posts and new route. However,
    we want to make sure that `titleURL` is set to the path of each individual post.
    We do this by passing the `:titleURL` dynamic segment to the path.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中一些是在我们创建帖子和新路由时为我们生成的。然而，我们想确保 `titleURL` 被设置为每个单独帖子的路径。我们通过传递 `:titleURL`
    动态段到路径来实现这一点。
- en: 'Add the query for each individual post to the posts route:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个单独帖子的查询添加到帖子路由中：
- en: '[PRE35]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the user navigates to the `/posts` URL, the model will expect a parameter
    passed in. For example, if you navigate to `/posts/my_post`, the `my_post` segment
    will be passed as a parameter that can be accessed in the route. We'll use this
    parameter in the Firebase `this.store.query` method. The first argument is the
    name of the model. We can then use `orderBy` and `equalTo` to specify the exact
    post that we are looking for.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户导航到 `/posts` URL 时，模型将期望传递一个参数。例如，如果您导航到 `/posts/my_post`，则 `my_post` 段将作为参数传递，可以在路由中访问。我们将在
    Firebase `this.store.query` 方法中使用此参数。第一个参数是模型的名称。然后我们可以使用 `orderBy` 和 `equalTo`
    来指定我们正在寻找的确切帖子。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Uniqueness**'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**唯一性**'
- en: As you can imagine, when creating a new post, the title may or may not be unique.
    The `this.store.query` method will return all results as an array to the model.
    We could enforce uniqueness in Firebase by making the `titleURL` unique. Another
    possibility would be to check the uniqueness of the post title during creation.
    Either way, for this example, we'll assume that all titleURLs are unique.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所想象，在创建新帖子时，标题可能唯一，也可能不唯一。`this.store.query` 方法将所有结果作为数组返回给模型。我们可以在 Firebase
    中通过使 `titleURL` 唯一来强制执行唯一性。另一种可能性是在创建帖子时检查标题的唯一性。无论如何，在这个例子中，我们将假设所有标题 URL 都是唯一的。
- en: 'Edit the application route file and add the model and a few actions:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑应用程序路由文件并添加模型和几个操作：
- en: '[PRE36]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We want the main application to have access to the model route so that we can
    use the `findAll` method to retrieve all posts. This is basically the same as
    the Ember Data method we've used in previous recipes.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望主应用程序能够访问模型路由，以便我们可以使用 `findAll` 方法检索所有帖子。这基本上与我们在之前的食谱中使用的 Ember Data 方法相同。
- en: There are two actions, `login` and `logout`. As we injected, using `torii`,
    our session into the program, we can access it from anywhere. By invoking `this.get('session')`,
    we can `open` or `close` a session. Firebase has several built-in authenticators,
    including Twitter and Facebook. The `login` action in this example will `open`
    a window to `twitter` so that the user can be authenticated.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有两个操作，`login` 和 `logout`。正如我们通过 `torii` 注入会话到程序中一样，我们可以从任何地方访问它。通过调用 `this.get('session')`，我们可以
    `打开` 或 `关闭` 会话。Firebase 有几个内置的认证器，包括 Twitter 和 Facebook。此例中的 `login` 操作将 `打开`
    一个到 `twitter` 的窗口，以便用户可以进行认证。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Firebase security**'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Firebase 安全性**'
- en: With any JavaScript browser application, security can be tricky. Firebase makes
    this a little easier for us. Firebase keeps track of users that are authenticated.
    In the Firebase dashboard, you can set rules that make it possible for only authenticated
    users to receive data. This is a little beyond the scope of this recipe. However,
    it is possible to secure your data with Firebase using a third-party authenticator
    such as Twitter or Facebook.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于任何 JavaScript 浏览器应用程序，安全性可能比较复杂。Firebase 让这变得容易一些。Firebase 跟踪已认证的用户。在 Firebase
    控制台中，你可以设置规则，使得只有已认证的用户才能接收数据。这超出了本食谱的范围。然而，使用第三方认证器（如 Twitter 或 Facebook）可以与
    Firebase 一起确保数据安全。
- en: 'Open the application template file. Add a navigation bar at the top and buttons
    to log in, log out, and add a new post:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用程序模板文件。在顶部添加一个导航栏，并添加登录、登出和添加新帖子的按钮：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we have installed the `ember-bootstrap` add-on, we can create a really simple
    top navigation bar. The `login` and `logout` buttons are surrounded by the `if`
    helper. In every template, you have access to the `session` property. This property
    has a method called `isAuthenticated` that returns `true` if the user is logged
    in and `false` if the user is not logged in. We can use this to show the `login`
    button only if the user is *NOT* logged in. If the user is logged in, they'll
    see a `logout` button.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们已安装了 `ember-bootstrap` 扩展包，我们可以创建一个非常简单的顶部导航栏。`login` 和 `logout` 按钮被 `if`
    辅助器包围。在每一个模板中，你都可以访问 `session` 属性。这个属性有一个名为 `isAuthenticated` 的方法，如果用户已登录则返回 `true`，如果用户未登录则返回
    `false`。我们可以使用这个方法仅在用户未登录时显示 `login` 按钮。如果用户已登录，他们将看到 `logout` 按钮。
- en: We don't have an application controller, so these actions will bubble up to
    the application route where they'll be handled.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们没有应用程序控制器，所以这些动作将冒泡到应用程序路由，在那里它们将被处理。
- en: 'Now update the `index.hbs` file with a link to each individual post:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新 `index.hbs` 文件，为每个单独的帖子添加链接：
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `model` loops through each post and displays the `title` on the screen.
    Each `titleURL` is passed as a parameter to the posts route.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model` 会遍历每个帖子，并在屏幕上显示 `title`。每个 `titleURL` 都作为参数传递给帖子路由。'
- en: 'In the new template, add some textboxes so that the user can add a post. Add
    a section to preview a post as well:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新模板中，添加一些文本框，以便用户可以添加帖子。添加一个预览帖子的部分：
- en: '[PRE39]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The new template will be used to create a new post. The `textarea` helper creates
    two textboxes. The form has a `save` action that will be triggered when the form
    is submitted.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新模板将用于创建新帖子。`textarea` 辅助器创建了两个文本框。表单有一个 `save` 动作，当表单提交时将被触发。
- en: When setting up the project, we installed a `markdown` add-on. This allows us
    to use `markdown` in the body of the post. Markdown is a text-to-HTML conversion
    tool. It makes it easier to write HTML in your text.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置项目时，我们安装了一个 `markdown` 扩展包。这允许我们在帖子的正文中使用 `markdown`。Markdown 是一种文本到 HTML
    的转换工具。它使得在文本中编写 HTML 更加容易。
- en: 'In the posts template, display each post and show a way to edit the post as
    well:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在帖子模板中，显示每个帖子，并展示编辑帖子的方式：
- en: '[PRE40]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This displays each individual post. If the user is authenticated, they can either
    delete or edit the post.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会显示每个单独的帖子。如果用户已认证，他们可以删除或编辑帖子。
- en: Once again, we use the `textarea` template helpers to display the textboxes.
    The form has an edit action attached that will set the `isEditing` property to
    `true` so that the post can be edited. The `delete` action deletes the post.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次使用 `textarea` 模板辅助器来显示文本框。表单有一个附加的 `edit` 动作，它将 `isEditing` 属性设置为 `true`，以便可以编辑帖子。`delete`
    动作会删除帖子。
- en: 'Add the `save` action to the new controller:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `save` 动作添加到新控制器中：
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `save` action is used to save the data to Firebase. First, it takes the
    title of the post and uses the utility, `cleanURI`, to remove all special characters
    and spaces. Firebase has a function called `createRecord` that is used to create
    new records. We then save the record to the store and `set` the values back to
    default. Finally, the application transitions back to the index.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`save` 动作用于将数据保存到 Firebase。首先，它获取帖子的标题，并使用 `cleanURI` 工具去除所有特殊字符和空格。Firebase
    有一个名为 `createRecord` 的函数，用于创建新记录。然后我们将记录保存到存储中，并将值 `set` 回默认。最后，应用程序返回到索引页面。'
- en: 'In the posts controller, add actions for `edit`, `delete`, and `save`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在帖子控制器中，添加 `edit`、`delete` 和 `save` 动作：
- en: '[PRE42]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s break this down into more detail:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更详细地分解一下：
- en: '[PRE43]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The edit function sets the `isEditing` property to `true`. The posts template
    uses this property to show or not show the editing window:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑函数将`isEditing`属性设置为`true`。帖子模板使用此属性来显示或隐藏编辑窗口：
- en: '[PRE44]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `delete` action deletes the record. To do this, we must use the `forEach`
    method on our `model`. In the route, we used the `query` method, which returns
    an array. Therefore, we have to go through every record returned, and delete it.
    Once again, we''ll assume that every title is unique and only has one record.
    Remember to always .`save()` so that the record is persisted in Firebase. After
    the record is deleted, we transition to the index route:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`delete`操作删除记录。为此，我们必须在我们的`model`上使用`forEach`方法。在路由中，我们使用了`query`方法，它返回一个数组。因此，我们必须遍历返回的每个记录，并删除它。再次假设每个标题都是唯一的，并且只有一个记录。请记住始终`.save()`，以便在Firebase中持久化记录。记录被删除后，我们将过渡到index路由：'
- en: '[PRE45]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `save` function gets the title, cleans it, sets it, and saves the model.
    In this example, we must use the `forEach` method to iterate over the array. Afterward,
    we set the `isEditing` property back to `false` and transition back to the `index`.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`save`函数获取标题，清理它，设置它，并保存模型。在这个例子中，我们必须使用`forEach`方法遍历数组。之后，我们将`isEditing`属性设置回`false`，并过渡回`index`。'
- en: Run the application and the following screen will be displayed:![How to do it...](img/00079.jpeg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，将显示以下屏幕：![如何操作...](img/00079.jpeg)
- en: 'This displays the top left corner of the screen. No posts are listed as we
    haven''t added them yet:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这显示了屏幕的左上角。由于我们还没有添加帖子，所以没有列出帖子：
- en: '![How to do it...](img/00080.jpeg)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00080.jpeg)'
- en: The top right corner of the screen will show the **Login** button. We'll need
    to log in by pressing this button. This will bring a popup asking for credentials
    to our Twitter account. After logging in, the **Add New Post** text will be displayed:![How
    to do it...](img/00081.jpeg)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕右上角将显示**登录**按钮。我们需要通过按下此按钮来登录。这将弹出一个请求我们Twitter账户凭证的窗口。登录后，将显示**添加新帖子**文本：![如何操作...](img/00081.jpeg)
- en: Clicking on **Add New Post** will display the following screen:![How to do it...](img/00082.jpeg)
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加新帖子**将显示以下屏幕：![如何操作...](img/00082.jpeg)
- en: You can see that the preview takes the markdown and converts it to HTML. After
    adding the new post, it will then be listed:![How to do it...](img/00083.jpeg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到预览将Markdown转换为HTML。添加新帖子后，它将被列出：![如何操作...](img/00083.jpeg)
- en: Clicking on the title will bring us to an edit screen. Here, we can **Edit**
    or **Delete** the post:![How to do it...](img/00084.jpeg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标题将带我们到编辑屏幕。在这里，我们可以**编辑**或**删除**帖子：![如何操作...](img/00084.jpeg)
- en: Clicking on the **Edit** button will bring up the edit screen:![How to do it...](img/00085.jpeg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑**按钮将弹出编辑屏幕：![如何操作...](img/00085.jpeg)
- en: From here, we can make any changes and save it back again. Each time a save
    occurs, the post is persisted in Firebase.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这里，我们可以进行任何更改并将其保存回来。每次保存时，帖子都会在Firebase中持久化。
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firebase talks to its backend service via the `emberfire` and `torii` add-ons.
    EmberFire is an official Ember Data adapter. It has many of the same features
    as other popular adapters. It can save, delete, edit, and query data fairly easily.
    One of its purposes is to make it really easy to persist and save data without
    having to set up your own backend.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase通过`emberfire`和`torii`插件与其后端服务通信。EmberFire是官方的Ember Data适配器。它具有许多与其他流行适配器相同的特性。它可以相对容易地保存、删除、编辑和查询数据。其中一个目的是使其能够非常容易地持久化和保存数据，而无需设置自己的后端。
- en: Firebase also has authentication providers that it can hook into. Firebase handles
    all the authentication between the provider and application. All that this requires
    is that the provider is set up in Firebase.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase还有可以连接的认证提供者。Firebase处理提供者与应用程序之间的所有认证。这只需要在Firebase中设置提供者。
- en: Using server side rendering
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器端渲染
- en: Ember.js runs in the browser. It uses JavaScript to handle all the routing and
    rendering of data. It only talks to the server on the initial page load and to
    retrieve JSON data. This can have some limitations. Larger applications might
    take longer to load on slower connections and there is still some concern around
    search engine optimization.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js在浏览器中运行。它使用JavaScript来处理所有路由和数据渲染。它仅在初始页面加载时与服务器通信，以检索JSON数据。这可能会有些限制。较大的应用程序在较慢的连接上可能加载时间更长，并且仍然存在一些关于搜索引擎优化的担忧。
- en: To help alleviate these concerns, the Ember team created **FastBoot**. FastBoot
    is an Ember CLI add-on that allows Ember.js to render and serve applications on
    the server. It's a work in progress as of writing this and has some limitations.
    It's not recommended for production and doesn't work with jQuery or `didInsertElement`.
    It will hopefully be production-ready by Ember v2.4.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助缓解这些担忧，Ember 团队创建了 **FastBoot**。FastBoot 是一个 Ember CLI 插件，允许 Ember.js 在服务器上渲染和提供应用程序。截至撰写本文时，它仍在开发中，有一些限制。它不建议用于生产，并且不与
    jQuery 或 `didInsertElement` 一起工作。它有望在 Ember v2.4 中准备好用于生产。
- en: Nevertheless, it's improving and is an important add-on for Ember.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它正在改进，并且是 Ember 的重要插件。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, run these commands:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用程序中，运行以下命令：
- en: '[PRE46]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: FastBoot requires the `canary` version of Ember to work. We must delete the
    `bower_components` folder before installing. During installation, you may get
    a message that Bower cannot find a suitable version of Ember. This is normal;
    make sure to choose `ember#canary` from the list.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FastBoot 需要 Ember 的 `canary` 版本来运行。在安装之前，我们必须删除 `bower_components` 文件夹。在安装过程中，你可能会收到一条消息，表明
    Bower 找不到 Ember 的合适版本。这是正常的；请确保从列表中选择 `ember#canary`。
- en: 'Build the application for production:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为生产构建应用程序：
- en: '[PRE47]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will build the production server and minify all the files.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将构建生产服务器并压缩所有文件。
- en: 'Run the Ember FastBoot server:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Ember FastBoot 服务器：
- en: '[PRE48]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will run the FastBoot server. Let''s break down these arguments:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将运行 FastBoot 服务器。让我们分析这些参数：
- en: '**--serve-assets**: This serves the assets out of the `dist` folder.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--serve-assets**：这将从 `dist` 文件夹中提供资源。'
- en: '**--port 4200**: This specifies the port. The default is 3000\. In this case,
    we can use `4200` to match the test server that we normally use.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--port 4200**：这指定了端口。默认是 3000。在这种情况下，我们可以使用 `4200` 来匹配我们通常使用的测试服务器。'
- en: '**--environment production**: The default is development. Use production. It
    works better as Ember FastBoot is faster with minified files.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--environment production**：默认是开发环境。使用生产环境。它效果更好，因为 Ember FastBoot 使用压缩文件运行得更快。'
- en: Open up localhost at port `4200` to see the web page load:![How to do it...](img/00086.jpeg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口 `4200` 打开 localhost 以查看网页加载：![如何操作...](img/00086.jpeg)
- en: The page doesn't look any different. However, if you look at the browser console,
    you'll notice that the Ember application rendered without downloading all the
    JavaScript it normally needs to run in the browser.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面看起来没有不同。然而，如果你查看浏览器控制台，你会注意到 Ember 应用程序在浏览器中运行时没有下载所有通常需要的 JavaScript。
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember FastBoot is an Ember add-on that's being worked on. As of writing this,
    it has a lot of limitations. With this said, it will eventually allow you to render
    your Ember.js application on the server, or at least part of the application,
    for the initial page load. This will help reduce page load times significantly.
    To learn more about Ember FastBoot, check out their website at [https://github.com/tildeio/ember-cli-fastboot](https://github.com/tildeio/ember-cli-fastboot).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Ember FastBoot 是一个正在开发中的 Ember 插件。截至撰写本文时，它有很多限制。话虽如此，它最终将允许你在服务器上渲染你的 Ember.js
    应用程序，或者至少是应用程序的一部分，用于初始页面加载。这将显著减少页面加载时间。要了解更多关于 Ember FastBoot 的信息，请访问他们的网站 [https://github.com/tildeio/ember-cli-fastboot](https://github.com/tildeio/ember-cli-fastboot)。
