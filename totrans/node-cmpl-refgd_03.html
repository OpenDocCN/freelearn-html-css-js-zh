<html><head></head><body><div><h1 class="header-title">Node.js Modules</h1>
                
            
            
                
<p>Before writing Node.js applications, you must learn about Node.js modules and packages. Modules and packages are the building blocks for breaking down your application into smaller pieces.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Defining a module</li>
<li>The CommonJS and ES2015 module specifications</li>
<li>Using ES2015/2016/2017 coding practices in Node.js</li>
<li>Using the ES6 module format in Node.js code</li>
<li>Understanding how Node.js finds modules</li>
<li>The npm package management system</li>
</ul>
<p>So, let's get on with it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Defining a module</h1>
                
            
            
                
<p>Modules are the basic building blocks for constructing Node.js applications. A Node.js module encapsulates functions, hiding details inside a well-protected container, and exposing an explicitly-declared list of functions.</p>
<p>There are two module formats that we must consider:</p>
<ul>
<li>The traditional Node.js format based on the CommonJS standard has been used since Node.js was created.</li>
<li>With ES2015/2016 a new format, ES6 Modules, has been defined with a new <kbd>import</kbd> keyword. ES6 modules will be (or is) supported in all JavaScript implementations.</li>
</ul>
<p>Because ES6 modules are now the standard module format, the Node.js <strong>Technical Steering Committee</strong> (<strong>TSC</strong>) is committed to first-class support for ES6 modules.</p>
<p>We have already seen modules in action in the previous chapter. Every JavaScript file we use in Node.js is itself a module. It's time to see what they are and how they work. We'll start with CommonJS modules and then quickly bring in ES6 modules.</p>
<p>In the <kbd>ls.js</kbd> example in <a href="">Chapter 2</a>, <em>Setting up Node.js</em>, we wrote the following code to pull in the <kbd>fs</kbd> module, giving us access to its functions:</p>
<pre>const fs = require('fs'); </pre>
<p>The <kbd>require</kbd> function searches for the named module, loading the module definition into the Node.js runtime, and making its functions available. In this case, the <kbd>fs</kbd> object contains the code (and data) exported by the <kbd>fs</kbd> module. The <kbd>fs</kbd> module is part of the Node.js core and provides filesystem functions.</p>
<p>By declaring <kbd>fs</kbd> as <kbd>const</kbd>, we have a little bit of assurance against making coding mistakes that would modify the object holding the module reference.</p>
<p>In every Node.js module, the <kbd>exports</kbd> object within the module is the interface exported to other code. Anything assigned to a field of the <kbd>exports</kbd> object is available to other pieces of code, and everything else is hidden. By the way, this object is actually <kbd>module.exports</kbd>. The <kbd>exports</kbd> object is an alias for <kbd>module.exports</kbd>.</p>
<p>The <kbd>require</kbd> function and <kbd>module.exports</kbd> objects both come from the CommonJS specification. ES6 modules have similar concepts, but a different implementation.</p>
<p>Let's look at a brief example of this before diving into the details. Ponder over the <kbd>simple.js</kbd> module:</p>
<pre>var count = 0;<br/>exports.next = function() { return ++count; };<br/>exports.hello = function() {<br/>  return "Hello, world!";<br/>};</pre>
<p>We have one variable, <kbd>count</kbd>, which is not attached to the <kbd>exports</kbd> object, and a function, <kbd>next</kbd>, which is attached. Now, let's use it:</p>
<pre class="p1"><strong>$ node<br/>&gt; const s = require('./simple');<br/>undefined<br/>&gt; s.hello();<br/>'Hello, world!'<br/>&gt; s.next();<br/>1<br/>&gt; s.next();<br/>2<br/>&gt; s.next();<br/>3</strong><br/><strong>&gt; console.log(s.count);</strong><br/><strong>undefined</strong><br/><strong>undefined</strong><br/><strong>&gt;</strong> </pre>
<p>The <kbd>exports</kbd> object in the module is the object that is returned by <kbd>require('./simple')</kbd>. Therefore, each call to <kbd>s.next</kbd> calls the <kbd>next</kbd> function in <kbd>simple.js</kbd>. Each returns (and increments) the value of the local variable, <kbd>count</kbd>. An attempt to access the private field, <kbd>count</kbd>, shows it's unavailable from outside the module.</p>
<p>To reiterate the rule:</p>
<ul>
<li>Anything (functions or objects) assigned as a field of <kbd>exports</kbd> (as known as <kbd>module.exports</kbd>) is available to other code outside the module</li>
<li>Objects not assigned to <kbd>exports</kbd> are not available to code outside the module, unless the module exports those objects via another mechanism</li>
</ul>
<p>This is how Node.js solves the global object problem of browser-based JavaScript. The variables that look like they're global variables are only global to the module containing that variable. These variables are not visible to any other code.</p>
<p>Now that we've got a taste for modules, let's take a deeper look.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">CommonJS and ES2015 module formats</h1>
                
            
            
                
<p>Node.js's module implementation is strongly inspired by, but not identical to, the CommonJS module specification. The differences between them might only be important if you need to share code between Node and other CommonJS systems.</p>
<p>Among the changes in ES2015 is a standard module format meant for use everywhere. It has some interesting features, and by existing everywhere it should advance the state of JavaScript. Since it is incompatible with the CommonJS/Node.js module system, adopting ES2015 modules in Node.js means reworking our practices and accepted norms.</p>
<p>As a practical matter, Node.js programmers will be dealing with both module formats for some time during a transition period. Our long-term goal should be to adopt ES2015 modules across the board. The Node.js platform is slated to bring in support for ES2015 modules in Node.js 10. As of Node.js 8.5, the feature is available by setting a command-line flag.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">CommonJS/Node.js module format</h1>
                
            
            
                
<p>We've already seen a couple of examples of this module format, with the <kbd>simple.js</kbd> example, and the programs we examined in <a href="">Chapter 2</a>, <em>Setting up Node.js</em>. So let's take a closer look.</p>
<p>CommonJS modules are stored in files with the extension <kbd>.js</kbd>. </p>
<p>Loading a CommonJS module is a synchronous operation. That means that when the <kbd>require('modulename')</kbd> function call returns, the module has been located and completely read into memory and is ready to go. The module is cached in memory so that subsequent <kbd>require('modulename')</kbd> calls return immediately, and all return the exact same object.</p>
<p>Node.js modules provide a simple encapsulation mechanism to hide implementation details while exposing an API. Modules are treated as if they were written as follows:</p>
<pre>(function() { ... contents of module file ... })(); </pre>
<p>Thus, everything within the module is contained within an anonymous private namespace context. This is how the global object problem is resolved; everything in a module that looks global is actually contained within this private context.</p>
<p>Objects and functions can be exposed from a CommonJS module by means of two free variables Node.js inserts into this private context: <kbd>module</kbd> and <kbd>exports</kbd>:</p>
<ul>
<li>The <kbd>module</kbd> object contains several fields that you might find useful. Refer to the online Node.js documentation for details.</li>
<li>The <kbd>exports</kbd> object is an alias of the <kbd>module.exports</kbd> field. This means that the following two lines of code are equivalent:</li>
</ul>
<pre>exports.funcName = function(arg, arg1) { ... };
module.exports.funcName = function(arg, arg2) { .. }; </pre>
<p>Your code can break the alias between the two if you do this:</p>
<pre>exports = function(arg, arg1) { ... };</pre>
<p>Do not do that, because <kbd>exports</kbd> will no longer be equivalent to <kbd>module.exports</kbd>. If your intent is to assign a single object or function to be what's returned by <kbd>require</kbd>, do this instead:</p>
<pre>module.exports = function(arg, arg1) { ... };</pre>
<p>Some modules do export a single function because that's how the module author envisioned delivering the desired functionality.</p>
<p>The Node.js package format is derived from the CommonJS module system (<a href="http://commonjs.org">http://commonjs.org</a>). When developed, the CommonJS team aimed to fill a gap in the JavaScript ecosystem. At that time, there was no standard module system, making it trickier to package JavaScript applications. The <kbd>require</kbd> function, the <kbd>exports</kbd> object, and other aspects of Node.js modules come directly from the CommonJS <kbd>Modules/1.0</kbd> spec.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ES6 module format</h1>
                
            
            
                
<p>ES6 modules are a new module format designed for all JavaScript environments. While Node.js has had a good module system for its whole existence, browser-side JavaScript has not. That left the browser-side community with either relying on the <kbd>&lt;script&gt;</kbd> tag, or using non-standardized solutions. For that matter, traditional Node.js modules were never standardized, outside of the CommonJS effort. Therefore, ES6 modules stand to be a big improvement for the entire JavaScript world, by getting everyone on the same page with a common module format and mechanisms.</p>
<p>The side effect is that the Node.js community needs to start looking at, learning about, and adopting the ES2015 module format.</p>
<p>ES6 modules are referred to by Node.js with the extension <kbd>.mjs</kbd>. When it came to implementing the new module format, the Node.js team determined that they could not support both CommonJS and ES6 modules with the <kbd>.js</kbd> extension. The <kbd>.mjs</kbd> extension was decided as the solution, and you may see tongue-in-cheek references to <em>Michael Jackson Script</em> for this file extension. </p>
<p>One interesting detail is that ES6 modules load asynchronously. This may not have an impact on Node.js programmers, except that this is part of the rationale behind requiring the new <kbd>.mjs</kbd> extension.</p>
<p>Create a file named <kbd>simple2.mjs</kbd> in the same directory as the <kbd>simple.js</kbd> example that we looked at earlier:</p>
<div><pre>var count = 0;<br/>export function next() { return ++count; }<br/>function squared() { return Math.pow(count, 2); }<br/>export function hello() {<br/>    return "Hello, world!";<br/>}<br/>export default function() { return count; }<br/>export const meaning = 42;<br/>export let nocount = -1;<br/>export { squared };</pre></div>
<p>ES6 items exported from a module are declared with the <kbd>export</kbd> keyword. This keyword can be put in front of any top-level declaration, such as variable, function, or class declarations:</p>
<pre> export function next() { .. }</pre>
<p>The effect of this is similar to the following:</p>
<pre>module.exports.next = function() { .. }</pre>
<p>The intent of both is essentially the same: to make a function, or other object, available to code outside the module. A statement such as <kbd>export function next()</kbd> is a named export, meaning the exported thing has a name, and that code outside the module uses that name to access the object. As we see here, named <kbd>exports</kbd> can be functions or objects, and they may also be class definitions.</p>
<p>Using <kbd>export default</kbd> can be done once per module, and is the <kbd>default</kbd> export from the module. The <kbd>default</kbd> export is what code outside the module accesses when using the module object itself, rather than when using one of the exports from the module.</p>
<p>You can also declare something, such as the <kbd>squared</kbd> function, and then export it later.</p>
<p>Now let's see how to use this ES2015 module. Create a <kbd>simpledemo.mjs</kbd> file with the following:</p>
<pre>import * as simple2 from './simple2.mjs';<br/><br/>console.log(simple2.hello());<br/>console.log(`${simple2.next()} ${simple2.squared()}`);<br/>console.log(`${simple2.next()} ${simple2.squared()}`);<br/>console.log(`${simple2.default()} ${simple2.squared()}`);<br/>console.log(`${simple2.next()} ${simple2.squared()}`);<br/>console.log(`${simple2.next()} ${simple2.squared()}`);<br/>console.log(`${simple2.next()} ${simple2.squared()}`);<br/>console.log(simple2.meaning);</pre>
<p>The <kbd>import</kbd> statement does what it means: it imports objects exported from a module. This version of the <kbd>import</kbd> statement is most similar to a traditional Node.js <kbd>require</kbd> statement, meaning that it creates an object through which you access the objects exported from the module.</p>
<p>This is how the code executes:</p>
<pre class="p1"><strong>$ node --experimental-modules simpledemo.mjs </strong><br/><strong>(node:63937) ExperimentalWarning: The ESM module loader is experimental.</strong><br/><strong>Hello, world!</strong><br/><strong>1 1</strong><br/><strong>2 4</strong><br/><strong>2 4</strong><br/><strong>3 9</strong><br/><strong>4 16</strong><br/><strong>5 25</strong><br/><strong>42</strong></pre>
<p>As of Node.js 8.5, the new module format is available behind an option flag as shown here. You're also presented with this nice warning that it's an experimental feature. Accessing the <kbd>default</kbd> export is accomplished by accessing the field named <kbd>default</kbd>. Accessing an exported value, such as the <kbd>meaning</kbd> field, is done without parentheses because it is a value and not a function.</p>
<p>Now to see a different way to import objects from a module, create another file, named <kbd>simpledemo2.mjs</kbd>, containing the following:</p>
<pre>import { <br/>    default as simple, hello, next <br/>} from './simple2.mjs';<br/>console.log(hello());<br/>console.log(next());<br/>console.log(next());<br/>console.log(simple());<br/>console.log(next());<br/>console.log(next());<br/>console.log(next());</pre>
<p>In this case, each imported object is its own thing rather than being attached to another object. Instead of writing <kbd>simple2.next()</kbd>, you simply write <kbd>next()</kbd>. The <kbd>as</kbd> clause is a way to declare an alias, if nothing else so you can use the default export. We already used an <kbd>as</kbd> clause earlier, and it can be used in other instances where you wish to provide an alias for the value being exported or imported.</p>
<p>Node.js modules can be used from ES2015 <kbd>.mjs</kbd> code. Create a file named <kbd>ls.mjs</kbd>, containing the following:</p>
<div><pre><strong>import _fs from 'fs';<br/>const fs = _fs.promises;<br/>import util from 'util';<br/><br/>(async () =&gt; {<br/>  const files = await fs.readdir('.');<br/>  for (let fn of files) {<br/>    console.log(fn);<br/>  }<br/>})().catch(err =&gt; { console.error(err); });</strong></pre></div>
<p>You cannot, however, <kbd>require</kbd> an ES2015 module into regular Node.js code. The lookup algorithm for ES2015 modules is different, and as we mentioned earlier, ES2015 modules are loaded asynchronously.</p>
<p>Another wrinkle is handling the <kbd>fs.promises</kbd> submodule.  We are using that submodule in the example, but how?    This <kbd>import</kbd> statement does not work:</p>
<pre><strong>import { promises as fs } from 'fs';</strong></pre>
<p>This fails as so:</p>
<pre><strong>$ node --experimental-modules ls.mjs </strong><br/><strong>(node:45186) ExperimentalWarning: The ESM module loader is experimental.</strong><br/><strong>file:///Volumes/Extra/book-4th/chap03/ls.mjs:1</strong><br/><strong>import { promises as fs } from 'fs';</strong><br/><strong>         ^^^^^^^^</strong><br/><strong>SyntaxError: The requested module 'fs' does not provide an export named 'promises'</strong><br/><strong> at ModuleJob._instantiate (internal/modules/esm/module_job.js:89:21)</strong></pre>
<p>That leaves us with this construct:</p>
<pre>import _fs from 'fs';<br/>const fs = _fs.promises;</pre>
<p>Executing the script gives the following:</p>
<pre class="p1"><strong>$ node --experimental-modules ls.mjs<br/>(node:65359) ExperimentalWarning: The ESM module loader is experimental.<br/>(node:37671) ExperimentalWarning: The fs.promises API is experimental<br/>ls.mjs<br/>module1.js<br/>module2.js<br/>simple.js<br/>simple2.mjs<br/>simpledemo.mjs<br/>simpledemo2.mjs</strong></pre>
<p>The last thing to note about ES2015 module code is that <kbd>import</kbd> and <kbd>export</kbd> statements must be top-level code. Even putting an <kbd>export</kbd> inside a simple block like this:</p>
<div><pre>{<br/>   export const meaning = 42;<br/>}</pre></div>
<p>Results in an error:</p>
<pre><strong>$ node --experimental-modules badexport.mjs </strong><br/><strong>(node:67984) ExperimentalWarning: The ESM module loader is experimental.</strong><br/><strong>SyntaxError: Unexpected token export</strong><br/><strong> at ModuleJob.loaders.set [as moduleProvider] (internal/loader/ModuleRequest.js:32:13)</strong><br/><strong> at &lt;anonymous&gt;</strong></pre>
<p>While there are a few more details about ES2015 modules, these are their most important attributes.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">JSON modules</h1>
                
            
            
                
<p>Node.js supports using <kbd>require('/path/to/file-name.json')</kbd> to import a JSON file. It is equivalent to this code:</p>
<pre>const fs = require('fs');<br/>module.exports = JSON.parse(<br/>        fs.readFileSync('/path/to/file-name.json', 'utf8'));</pre>
<p>That is, the JSON file is read synchronously, and the text is parsed as JSON. The resultant object is available as the object exported from the module. Create a file named <kbd>data.json</kbd>, containing the following:</p>
<pre>{ <br/>    "hello": "Hello, world!", <br/>    "meaning": 42 <br/>}</pre>
<p>Now create a file named <kbd>showdata.js</kbd>, containing the following:</p>
<pre>const util = require('util');<br/>const data = require('./data');<br/>console.log(util.inspect(data));</pre>
<p>It will execute as follows:</p>
<pre><strong>$ node showdata.js </strong><br/><strong>{ hello: 'Hello, world!', meaning: 42 }</strong></pre>
<p>The <kbd>util.inspect</kbd> function is a useful way to present an object in an easy-to-read fashion. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Supporting ES6 modules on older Node.js versions</h1>
                
            
            
                
<p>While support for ES6 modules arrived as an experimental feature in Node.js 8.5, there are two ways to use these modules on earlier Node.js implementations. </p>
<p>One method is to use the Babel transpiler to rewrite ES6 code so it can execute on older Node.js versions. For an example, see <a href="https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b">https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b</a>.</p>
<p>The better method is the <kbd>esm</kbd> package in the Node.js registry. Simply do the following:</p>
<pre class="p1"><strong>$ nvm install 6<br/>Downloading and installing node v6.14.1...<br/>Downloading https://nodejs.org/dist/v6.14.1/node-v6.14.1-darwin-x64.tar.xz...<br/>######################################################################## 100.0%<br/>Computing checksum with shasum -a 256<br/>Checksums matched!<br/>Now using node v6.14.1 (npm v3.10.10)<br/>$ nvm use 6<br/>Now using node v6.14.1 (npm v3.10.10)<br/>$ npm install esm<br/>... npm output<br/>$ node --require esm simpledemo.mjs <br/>Hello, world!<br/>1 1<br/>2 4<br/>2 4<br/>3 9<br/>4 16<br/>5 25<br/>42</strong><br/></pre>
<p>To use this module, one simply invokes <kbd>require('esm')</kbd> once, and ES6 modules are retrofitted into Node.js.  The <kbd>--require</kbd> flag automatically loads the named module.  Without rewriting the code, we can selectively use the esm module with this the command-line option.  </p>
<p>This example demonstrates retrofitting ES6 modules into older Node.js releases.  To successfully execute the <kbd>ls.mjs</kbd> example   we must have support for <kbd>async</kbd>/<kbd>await</kbd> functions, and arrow functions.  Since Node.js 6.x does not support either, the <kbd>ls.mjs</kbd> example will fail, and will necessitate rewriting such code:</p>
<pre><strong>$ node --version</strong><br/><strong>v6.14.1</strong><br/><strong>$ node -r esm ls.mjs </strong><br/><strong>/Users/David/chap03/ls.mjs:5</strong><br/><strong>(async () =&gt; {</strong><br/><strong>       ^</strong><br/><br/><strong>SyntaxError: Unexpected token (</strong><br/><strong> at exports.runInThisContext (vm.js:53:16)</strong><br/><strong> at Module._compile (module.js:373:25)</strong></pre>
<p>For more information, see: <br/>
<a href="https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b">https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b</a>.  That article describes an older release of the <kbd>esm</kbd> module, at the time named <kbd>@std/esm</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Demonstrating module-level encapsulation</h1>
                
            
            
                
<p>A key attribute of modules is encapsulation. The objects that are not exported from the module are private to the module, and cannot be accessed from code outside the module. To reiterate, modules are treated as if they were written as follows:</p>
<pre>(function() { ... contents of module file ... })();</pre>
<p>This JavaScript idiom defines an anonymous private scope. Anything declared within that scope cannot be accessed by code outside the scope. That is, unless some code makes object references available to other code outside this private scope. That's what the <kbd>module.exports</kbd> object does: it is a mechanism for the module author to expose object references from the module. Other code can then access resources inside the module in a controlled fashion.</p>
<p>The top-level variables inside a module look like they exist in the global scope. Instead of being truly Global, they're safely private to the module and are completely inaccessible to other code.</p>
<p>Let's take a look at a practical demonstration of that encapsulation. Create a file named <kbd>module1.js</kbd>, containing the following:</p>
<pre>const A = "value A";<br/>const B = "value B";<br/>exports.values = function() {<br/>   return { A: A, B: B };<br/>}</pre>
<p>Then, create a file named <kbd>module2.js</kbd>, containing the following:</p>
<pre>const util = require('util');<br/>const A = "a different value A";<br/>const B = "a different value B";<br/>const m1 = require('./module1');<br/>console.log(`A=${A} B=${B} values=${util.inspect(m1.values())}`);<br/>console.log(`${m1.A} ${m1.B}`);<br/>const vals = m1.values();<br/>vals.B = "something completely different";<br/>console.log(util.inspect(vals));<br/>console.log(util.inspect(m1.values()));</pre>
<p>Then, run it as follows (you must have Node.js already installed):</p>
<pre><strong>$ node module2.js </strong><br/><strong>A=a different value A B=a different value B values={ A: 'value A', B: 'value B' }</strong><br/><strong>undefined undefined</strong><br/><strong>{ A: 'value A', B: 'something completely different' }</strong><br/><strong>{ A: 'value A', B: 'value B' }</strong></pre>
<p>This artificial example demonstrates encapsulation of the values in <kbd>module1.js</kbd> from those in <kbd>module2.js</kbd>. The <kbd>A</kbd> and <kbd>B</kbd> values in <kbd>module1.js</kbd> don't overwrite <kbd>A</kbd> and <kbd>B</kbd> in <kbd>module2.js</kbd> because they're encapsulated within <kbd>module1.js</kbd>. The <kbd>values</kbd> function in <kbd>module1.js</kbd> does allow code in <kbd>module2.js</kbd> access to the values; however, <kbd>module2.js</kbd> cannot directly access those values. We can modify the object <kbd>module2.js</kbd> received from <kbd>module1.js</kbd>. But doing so does not change the values within <kbd>module1.js</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Finding and loading CommonJS and JSON modules using require</h1>
                
            
            
                
<p>We have talked about several types of modules: CommonJS, JSON, ES2015, and native code modules. All but the ES2015 modules are loaded using the <kbd>require</kbd> function. That function has a very powerful and flexible algorithm for locating modules within a directory hierarchy. This algorithm, coupled with the npm package management system, gives the Node.js platform a lot of power and flexibility.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">File modules</h1>
                
            
            
                
<p>The CommonJS and ES2015 modules we've just looked at are what the Node.js documentation describes as a <strong>file module</strong>. Such modules are contained within a single file, whose filename ends with <kbd>.js</kbd>, <kbd>.mjs</kbd>, <kbd>.json</kbd>, or <kbd>.node</kbd>. The latter are compiled from C or C++ source code, or even other languages such as Rust, while the former are of course written in JavaScript or JSON.</p>
<p>We've already looked at several examples of using these modules, as well as the difference between the CommonJS format traditionally used in Node.js, and the new ES2015 modules that are now supported.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Modules baked into Node.js binary</h1>
                
            
            
                
<p>Some modules are pre-compiled into the Node.js binary. These are the core Node.js modules documented on the Node.js website at <a href="https://nodejs.org/api/index.html">https://nodejs.org/api/index.html</a>.</p>
<p>They start out as source code within the Node.js build tree. The build process compiles them into the binary so that the modules are always available.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Directories as modules</h1>
                
            
            
                
<p>A module can contain a whole directory structure full of stuff. Stuff here is a technical term referring to internal file modules, data files, template files, documentation, tests, assets, and more. Once stored within a properly constructed directory structure, Node.js will treat these as a module that satisfies a <kbd>require('moduleName')</kbd> call.</p>
<p>This may be a little confusing because the word <em>module</em> is being overloaded with two meanings. In some cases, a module is a file, and in other cases, a module is a directory containing one or more file modules.</p>
<p>In most cases, a directory-as-module contains a <kbd>package.json</kbd> file. This file contains data about the module (known as package) that Node.js uses while loading the module. The Node.js runtime recognizes these two fields:</p>
<pre>{ name: "myAwesomeLibrary", 
  main: "./lib/awesome.js" }</pre>
<p>If this <kbd>package.json</kbd> file is in a directory named <kbd>awesomelib</kbd>, then <kbd>require('./awesomelib')</kbd> will load the file module in <kbd>./awesomelib/lib/awesome.js</kbd>. </p>
<p>If there is no <kbd>package.json</kbd>, then Node.js will look for either <kbd>index.js</kbd> or <kbd>index.node</kbd>. In such a case, <kbd>require('./awesomelib')</kbd> will load the file module in <kbd>./awesomelib/index.js</kbd>.</p>
<p>In either case, the directory module can easily contain other file modules. The module that's initially loaded would simply use <kbd>require('./anotherModule')</kbd> one or more times to load other, private modules.</p>
<p>The npm package management system can recognize a lot more data in the <kbd>package.json</kbd> file. That includes the package name, its author, the home page URL, the issue-queue URL, package dependencies, and more. We'll go over this later.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Module identifiers and pathnames</h1>
                
            
            
                
<p>Generally speaking, the module name is a pathname, but with the file extension removed. Earlier, when we wrote <kbd>require('./simple')</kbd>, Node.js knew to add <kbd>.js</kbd> to the filename and load in <kbd>simple.js</kbd>. Similarly, Node.js would recognize <kbd>simple.json</kbd> or <kbd>simple.node</kbd> as the filename legitimately satisfying <kbd>require('./simple')</kbd>.</p>
<p>There are three types of module identifiers: relative, absolute, and top-level:</p>
<ul>
<li><strong>Relative module identifiers</strong>: These begin with <kbd>./</kbd> or <kbd>../</kbd> and absolute identifiers begin with <kbd>/</kbd>. The module name is identical with POSIX filesystem semantics. The resultant pathname is interpreted relative to the location of the file being executed. That is, a module identifier beginning with <kbd>./</kbd> is looked for in the current directory, whereas one starting with <kbd>../</kbd> is looked for in the parent directory.</li>
<li><strong>Absolute module identifiers</strong>: These begin with<kbd>/</kbd>and are, of course, looked for in the root of the filesystem, but this is not a recommended practice.</li>
<li><strong>Top-level module identifiers</strong>: These begin with none of those strings and are just the module name, or else <kbd>module-name/path/to/module</kbd>. These must be stored in a <kbd>node_modules</kbd> directory, and the Node.js runtime has a nicely flexible algorithm for locating the correct <kbd>node_modules</kbd> directory:
<ul>
<li>In the case of <kbd>module-name/path/to/module</kbd> specifiers, what will be loaded is a module <kbd>path/to/module</kbd> within the top-level module named <kbd>module-name</kbd></li>
<li>The baked-in modules are specified using top-level module names</li>
</ul>
</li>
</ul>
<p>The search begins in the directory containing the file calling <kbd>require()</kbd>. If that directory contains a <kbd>node_modules</kbd> directory, which then contains either a matching directory module or a matching file module, then the search is satisfied. If the local <kbd>node_modules</kbd> directory does not contain a suitable module, it tries again in the parent directory, and it will continue upward in the filesystem until it either finds a suitable module or it reaches the root directory.</p>
<p>That is, with a <kbd>require</kbd> call in <kbd>/home/david/projects/notes/foo.js</kbd>, the following directories will be consulted:</p>
<ul>
<li><kbd>/home/david/projects/notes/node_modules</kbd></li>
<li><kbd>/home/david/projects/node_modules</kbd></li>
<li><kbd>/home/david/node_modules</kbd></li>
<li><kbd>/home/node_modules</kbd></li>
<li><kbd>/node_modules</kbd></li>
</ul>
<p>If the module is not found through this search, there are global folders in which modules can be located. The first is specified in the <kbd>NODE_PATH</kbd> environment variable. This is interpreted as a colon-delimited list of absolute paths similar to the <kbd>PATH</kbd> environment variable. On Windows, the elements of <kbd>NODE_PATH</kbd> are of course separated by semicolons. Node.js will search those directories for a matching module.</p>
<p>The <kbd>NODE_PATH</kbd> approach is not recommended, because of surprising behavior which can happen if people are unaware that this variable must be set. If a specific module located in a specific directory referenced in <kbd>NODE_PATH</kbd> is required for proper function, and the variable is not set, the application will likely fail. As the Twelve-Factor Application model suggests, it is best for all dependencies to be explicitly declared, and with Node.js that means listing all dependencies in the <kbd>package.json</kbd> so that <kbd>npm</kbd> or <kbd>yarn</kbd> can manage the dependencies.<br/>
<br/>
<p>This variable was implemented before the module resolution algorithm just described was finalized. Because of that algorithm, <kbd>NODE_PATH</kbd> is largely unnecessary. </p>
</p>
<p>There are three additional locations that can hold modules:</p>
<ul>
<li><kbd>$HOME/.node_modules</kbd></li>
<li><kbd>$HOME/.node_libraries</kbd></li>
<li><kbd>$PREFIX/lib/node</kbd></li>
</ul>
<p>In this case, <kbd>$HOME</kbd> is what you expect, the user's home directory, and <kbd>$PREFIX</kbd> is the directory where Node.js is installed.</p>
<p>Some are beginning to recommend against using global modules. The rationale is the desire for repeatability and deployability. If you've tested an app, and all its code is conveniently located within a directory tree, you can copy that tree for deployment to other machines. But, what if the app depended on some other file that was magically installed elsewhere on the system? Will you remember to deploy such files?</p>


            

            
        
    </div>



  
<div><h1 class="header-title">An example of application directory structure</h1>
                
            
            
                
<p>Let's take a look at the filesystem structure of a typical Node.js Express application:</p>
<div><img src="img/d5c0a49b-762d-4675-9c45-5bcd4afb99e0.png" width="1026" height="521"/></div>
<p>This is an Express application (we'll start using Express in <a href="e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml">Chapter 5</a>, <em>Your First Express Application</em>) containing a few modules installed in the <kbd>node_modules</kbd> directory. One of those, Express, has its own <kbd>node_modules</kbd> directory containing a couple of modules.</p>
<p>For <kbd>app.js</kbd> to load <kbd>models-sequelize/notes.js</kbd>, it uses the following <kbd>require</kbd> call:</p>
<pre>const notesModel = require('./models-sequelize/notes'); </pre>
<p>This is a relative module identifier, where the pathname is resolved relative to the directory containing the file making the reference.</p>
<p>Use the following code to do the reverse in <kbd>models-sequelize/notes.js</kbd>:</p>
<pre>const app = require('../app'); </pre>
<p>Again, this is a relative module identifier, this time resolved relative to the subdirectory containing <kbd>models-sequelize/notes.js</kbd>.</p>
<p>Any reference to a top-level module identifier will first look in the <kbd>node_modules</kbd> directory shown here. This directory is populated from the dependencies listed in the <kbd>package.json</kbd>, as we'll see in a few pages:</p>
<div><pre>const express = require('express');<br/>const favicon = require('serve-favicon');<br/>const logger = require('morgan');<br/>const cookieParser = require('cookie-parser');<br/>const bodyParser = require('body-parser');</pre></div>
<p>All of these are typical modules included in an Express application. Most of them are readily visible in the screenshot shown earlier. What's loaded is the main file in the corresponding subdirectory of <kbd>node_modules</kbd>, for example, <kbd>node_modules/express/index.js</kbd>.</p>
<p>But the application cannot directly reference the dependencies of the Express module that are in its internal <kbd>node_modules</kbd> directory. The module search algorithm only moves upward in the filesystem; it does not descend into subsidiary directory trees. </p>
<p>One side effect of the upward search direction is the handling of conflicting dependencies. </p>
<p>Suppose two modules (modules A and B) listed a dependency on the same module (C)?  In the normal case, the two dependencies on module C could be handled by the same instance of that module. As we'll see in a few pages, npm's dependency list in <kbd>package.json</kbd> can use loose or precise version number references. Depending on the current version number for module C, modules A and B may, or may not, be in agreement as to which version to use. If they do not agree, npm can arrange the module installation such that both module A and B get the version of module C they depend on, without either stepping on the other. If both are agreeable with the same module C instance, only one copy will be installed, but if they disagree then npm will install two copies. The two copies will be located such that the module search algorithm will cause each module to find the correct version of module C.</p>
<p>Let's try a concrete example to clarify what was just said. In the screenshot earlier, you see two instances of the <kbd>cookie</kbd> module. We can use npm to query for all references to this module:</p>
<pre class="p1"><strong>$ npm ls cookie<br/>notes@0.0.0 /Users/David/chap05/notes<br/>├─┬ cookie-parser@1.3.5<br/>│ └── cookie@0.1.3 <br/>└─┬ express@4.13.4<br/>  └── cookie@0.1.5</strong></pre>
<p>This says the <kbd>cookie-parser</kbd> module depends on version 0.1.3 of <kbd>cookie</kbd>, while Express depends on version 0.1.5. How does npm avoid problems with these two conflicting versions?  By putting one inside the <kbd>node_modules</kbd> directory inside the <kbd>express</kbd> module. This way, when <em>Express</em> refers to this module, it will use the <kbd>0.1.5</kbd> instance in its own <kbd>node_modules</kbd> directory, while the <kbd>cookie-parser</kbd> module will use the <kbd>0.1.3</kbd> instance in the top-level <kbd>node_modules</kbd> directory.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Finding and loading ES6 modules using import</h1>
                
            
            
                
<p>The <kbd>import</kbd> statement is used to load ES6 modules, and it only works inside an ES6 module. Because ES6 modules are loaded asynchronously, the <kbd>require()</kbd> statement cannot load ES6 modules. As we said earlier, ES6 modules are recognized by Node.js by the <kbd>.mjs</kbd> extension.  The ECMAScript TC-39 committee has (or plans to) officially register that file extension with the recognized authorities so that regular tools will recognize both file extensions as JavaScript.</p>
<p>The module specifier one hands to the <kbd>import</kbd> statement is interpreted as a URL. For the time being, Node.js will only accept <kbd>file:</kbd> URL because of the security implications of loading modules over the Internet. Because it's a URL, some characters such as <kbd>:</kbd>, <kbd>?</kbd>, <kbd>#</kbd>, or <kbd>%</kbd> must receive special treatment. For example:</p>
<pre>import './foo?search';
import './foo#hash';</pre>
<p>These are valid module specifiers where <kbd>?search</kbd> and <kbd>#hash</kbd> have the sort of meaning you'd expect in a URL. So long as Node.js only supports <kbd>file:</kbd> URL for <kbd>import</kbd> statements, we cannot make use of that feature, but we have to keep it in mind and avoid using these strings in module URL.</p>
<p>One can install custom module loader hooks that could conceivably use those URL parts for some purpose.</p>
<p>The module search algorithm is similar to what we described for <kbd>require</kbd>. If the specifier begins with <kbd>./</kbd>, <kbd>../</kbd>, or <kbd>/</kbd>, the specifier is interpreted as a pathname. Otherwise, it is interpreted as a top-level module similar to the <kbd>require</kbd> statement, with one big difference. The <kbd>import</kbd> statement will not search for a global module. This is frowned on, but if one must use a global module, that can be accomplished with a symbolic link.</p>
<p>For documentation, see <a href="https://nodejs.org/api/esm.html">https://nodejs.org/api/esm.html</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hybrid CommonJS/Node.js/ES6 module scenarios</h1>
                
            
            
                
<p>We've gone over the format for CommonJS/Node.js modules, the format for ES6 modules, and the algorithm for locating and importing both. The last thing to cover is those hybrid situations where our code will use both module formats at the same time.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As a practical matter, ES6 modules are very new to the Node.js platform, and therefore we have a large body of existing code written as CommonJS/Node.js modules. Many tools in the Node.js market have implementation dependencies on the CommonJS format. This means we'll be facing situations where ES6 modules will need to use CommonJS modules, and vice versa:</p>
<ul>
<li>CommonJS module loads other CommonJS modules with <kbd>require()</kbd></li>
</ul>
<ul>
<li>CommonJS module cannot load ES6 modules—except for two methods:
<ul>
<li>Dynamic import, also known as <kbd>import()</kbd>, can load an ES6 module as an asynchronous operation</li>
<li>The <kbd>@std/esm</kbd> package supplies a <kbd>require()</kbd> function with one that can load ES6 modules as an asynchronous operation</li>
</ul>
</li>
<li>ES6 modules load other ES6 modules with <kbd>import</kbd>, with the full semantics of the <kbd>import</kbd> statement</li>
<li>ES6 modules load CommonJS modules using <kbd>import</kbd></li>
</ul>
<p>Therefore, out of the box, three of the scenarios are directly supported. The fourth is supported with a workaround module.</p>
<p>When an ES6 module loads a CommonJS module, its <kbd>module.exports</kbd> object is exposed as the <kbd>default</kbd> export of the module. This means your code uses this pattern:</p>
<pre>import cjsModule from 'common-js-module';<br/>...<br/>cjsModule.functionName();</pre>
<p>This is extremely similar to using a CommonJS module in another CommonJS module. You are simply transliterating the <kbd>require()</kbd> call into an <kbd>import</kbd> statement.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dynamic imports with import()</h1>
                
            
            
                
<p>ES6 modules do not cover all the requirements to fully replace Node.js/CommonJS modules. One of the missing capabilities is being addressed with the Dynamic Import feature currently on its way through the TC-39 committee.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Support for dynamic imports landed in Node.js 9.7. See the documentation at: <br/>
<a href="https://github.com/tc39/proposal-dynamic-import">https://github.com/tc39/proposal-dynamic-import</a>.<a href="https://github.com/tc39/proposal-dynamic-import"/></p>
<p>We'll use dynamic imports to solve an issue in <a href="">Chapter 7</a>, <em>Data Storage and Retrieval</em>, about dynamically choosing the module to load.  In normal usage of the <kbd>require()</kbd> statement, can use a simple string literal to specify the module name.  But it is also possible to use a string literal to compute the module name, like so:</p>
<pre>// Node.js dynamically determined module loading<br/>const moduleName = require(`../models/${process.env.MODEL_NAME}`);</pre>
<p>We used this technique in earlier editions of this book to dynamically choose between several implementations of the same model API. The ES6 <kbd>import</kbd> statement does not support anything but a simple string literal, and therefore cannot compute the module specifier like this example.</p>
<p>With dynamic imports, we have an <kbd>import()</kbd> function where the module specifier is a regular string, letting us make a similar dynamic choice of module. Unlike the <kbd>require()</kbd> function, which is synchronous, <kbd>import()</kbd> is asynchronous, and returns a Promise. Hence, it's not a direct replacement for <kbd>require()</kbd> in that it's not terribly useful as a top-level function. You'll see how to use it in <a href="">Chapter 7</a>, <em>Data Storage and Retrieval</em>.</p>
<p>Perhaps the most important feature it brings is that CommonJS modules can use <kbd>import()</kbd> to load an ES6 module.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The import.meta feature</h1>
                
            
            
                
<p>Another new feature, <kbd>import.meta</kbd>, is making its way through the TC-39 committee, and is being implemented for Node.js 10.x. It is an object existing within the scope of an ES6 module providing some metadata about the module. See <a href="https://github.com/tc39/proposal-import-meta">https://github.com/tc39/proposal-import-meta</a>.</p>
<p>A partial implementation, supporting just <kbd>import.meta.url</kbd>, has landed in the Node.js source. Its use requires the <kbd>--harmony-import-meta</kbd> command-line flag. The content of <kbd>import.meta.url</kbd> is a fully qualified <kbd>file:</kbd> URL for the current module, such as <kbd>file:///Users/david/chap10/notes/app.mjs</kbd>.</p>
<p>Where this becomes important is that ES6 modules do not support the <kbd>__dirname</kbd>, <kbd>__filename</kbd>, and other global variables used historically in Node.js modules. The <kbd>__dirname</kbd> variable is routinely used to read in resource data from files sitting in the package directory. It is intended that for such cases, one parses the directory name out of <kbd>import.meta.url</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">npm - the Node.js package management system</h1>
                
            
            
                
<p>As described in <a href="">Chapter2</a>, <em>Setting </em><em>up </em><em>Node.js</em>, npm is a package management and distribution system for Node.js. It has become the de facto standard for distributing modules (packages) for use with Node.js. Conceptually, it's similar to tools such as <kbd>apt-get</kbd> (Debian), <kbd>rpm</kbd>/<kbd>yum</kbd> (Red Hat/Fedora), <kbd>MacPorts</kbd> (macOS), <kbd>CPAN</kbd> (Perl), or <kbd>PEAR</kbd> (PHP). Its purpose is publishing and distributing Node.js packages over the Internet using a simple command-line interface. With npm, you can quickly find packages to serve specific purposes, download them, install them, and manage packages you've already installed.</p>
<p>The <kbd>npm</kbd> application extends on the package format for Node.js, which in turn is largely based on the CommonJS package specification. It uses the same <kbd>package.json</kbd> file that's supported natively by Node.js, but with additional fields to build in additional functionality.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The npm package format</h1>
                
            
            
                
<p>An npm package is a directory structure with a <kbd>package.json</kbd> file describing the package. This is exactly what was referred to earlier as a directory module, except that npm recognizes many more <kbd>package.json</kbd> tags than Node.js does. The starting point for npm's <kbd>package.json</kbd> are the CommonJS Packages/1.0 specification. The documentation for npm's <kbd>package.json</kbd> implementation is accessed using the following command:</p>
<pre><strong>$  npm help json</strong></pre>
<p>A basic <kbd>package.json</kbd> file is as follows:</p>
<pre>{ "name": "packageName", 
   "version": "1.0", 
   "main": "mainModuleName", 
   "modules": { 
    "mod1": "lib/mod1", 
    "mod2": "lib/mod2" 
  } 
} </pre>
<p>The file is in JSON format, which, as a JavaScript programmer, you should be familiar with.</p>
<p>The most important tags are <kbd>name</kbd> and <kbd>version</kbd>. The name will appear in URLs and command names, so choose one that's safe for both. If you desire to publish a package in the public <kbd>npm</kbd> repository, it's helpful to check whether a particular name is already being used at <a href="http://npmjs.com">http://npmjs.com</a> or with the following command:</p>
<pre><strong>$ npm search packageName</strong></pre>
<p>The <kbd>main</kbd> tag is treated the same as we discussed in the previous section on directory modules. It defines which file module will be returned when invoking <kbd>require('packageName')</kbd>. Packages can contain many modules within themselves and they can be listed in the <kbd>modules</kbd> list.</p>
<p>Packages can be bundled as tar-gzip archives (tarballs), especially to send them over the internet.</p>
<p>A package can declare dependencies on other packages. That way, npm can automatically install other modules required by the module being installed. Dependencies are declared as follows:</p>
<pre>"dependencies": { 
    "foo" : "1.0.0 - 2.x.x", <br/>    "bar" : "&gt;=1.0.2 &lt;2.1.2" 
 } </pre>
<p>The <kbd>description</kbd> and <kbd>keyword</kbd> fields help people find the package when searching in an npm repository (<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>). Ownership of a package can be documented in the <kbd>homepage</kbd>, <kbd>author</kbd>, or <kbd>contributors</kbd> fields:</p>
<pre>"description": "My wonderful package that walks dogs",<br/>"homepage": "http://npm.dogs.org/dogwalker/",<br/>"author": "dogwhisperer@dogs.org"</pre>
<p>Some <kbd>npm</kbd> packages provide executable programs meant to be in the user's <kbd>PATH</kbd>. These are declared using the <kbd>bin</kbd> tag. It's a map of command names to the script that implements that command. The command scripts are installed into the directory containing the node executable using the name given:</p>
<pre>bin: { 
  'nodeload.js': './nodeload.js',<br/>  'nl.js': './nl.js' <br/>},</pre>
<p>The <kbd>directories</kbd> tag describes the package directory structure. The <kbd>lib</kbd> directory is automatically scanned for modules to load. There are other directory tags for binaries, manuals, and documentation:</p>
<pre>directories: { lib: './lib', bin: './bin' }, </pre>
<p>The script tags are script commands run at various events in the life cycle of the package. These events include <kbd>install</kbd>, <kbd>activate</kbd>, <kbd>uninstall</kbd>, <kbd>update</kbd>, and more. For more information about script commands, use the following command:</p>
<pre><strong>$ npm help scripts </strong> </pre>
<p>We've already used the scripts feature when showing how to set up Babel. We'll use these later for automating the build, test, and execution processes.</p>
<p>This was only a taste of the npm package format; see the documentation (<kbd>npm help json</kbd>) for more.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Finding npm packages</h1>
                
            
            
                
<p>By default, <kbd>npm</kbd> modules are retrieved over the internet from the public package registry maintained on <a href="http://npmjs.com">http://npmjs.com</a>. If you know the module name, it can be installed simply by typing the following:</p>
<pre><strong>$ npm install moduleName </strong> </pre>
<p>But what if you don't know the module name? How do you discover the interesting modules? The website <a href="http://npmjs.com">http://npmjs.com</a> publishes a searchable index of the modules in that registry.</p>
<p>The npm package also has a command-line search function to consult the same index:</p>
<div><img src="img/da103ddf-0088-4106-b1d3-7c9e1a79bc9e.png" width="927" height="311"/></div>
<p>Of course, upon finding a module, it's installed as follows:</p>
<pre><strong>$ npm install acoustid </strong> </pre>
<p>After installing a module, you may want to see the documentation, which would be on the module's website. The <kbd>homepage</kbd> tag in <kbd>package.json</kbd> lists that URL. The easiest way to look at the <kbd>package.json</kbd> file is with the <kbd>npm view</kbd> command, as follows:</p>
<pre><strong>$ npm view akasharender
...
{ name: 'akasharender',
  description: 'Rendering support for generating static HTML websites <br/>  or EPUB eBooks',
  'dist-tags': { latest: '0.6.15' },
  versions: 
   [ '0.0.1',
  ...
  author: 'David Herron &lt;david@davidherron.com&gt; </strong><br/><strong>  (http://davidherron.com)',
  repository: { type: 'git', url: </strong><br/><strong>  'git://github.com/akashacms/akasharender.git' },
  homepage: 'http://akashacms.com/akasharender/toc.html',
...
} </strong> </pre>
<p>You can use <kbd>npm view</kbd> to extract any tag from <kbd>package.json</kbd>, like the following, which lets you view just the <kbd>homepage</kbd> tag:</p>
<pre><strong>$ npm view akasharender homepage
http://akashacms.org/akasharender/toc.html </strong></pre>
<p>Other fields in the <kbd>package.json</kbd> can be viewed by simply giving the desired tag name.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Other npm commands</h1>
                
            
            
                
<p>The main <kbd>npm</kbd> command has a long list of subcommands for specific package management operations. These cover every aspect of the life cycle of publishing packages (as a package author), and downloading, using, or removing packages (as an npm consumer).</p>
<p>You can view the list of these commands just by typing <kbd>npm</kbd> (with no arguments). If you see one you want to learn more about, view the help information:</p>
<pre><strong>$ npm help &lt;command&gt;
The help text will be shown on your screen.
Or, see the website: http://docs.npmjs.com </strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing an npm package</h1>
                
            
            
                
<p>The <kbd>npm install</kbd> command makes it easy to install packages upon finding the one of your dreams, as follows:</p>
<pre><strong>$ npm install express
/home/david/projects/notes/
- express@4.13.4
... </strong> </pre>
<p>The named module is installed in <kbd>node_modules</kbd> in the current directory. The specific version installed depends on any version number listed on the command line, as we see in the next section. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing a package by version number</h1>
                
            
            
                
<p>Version number matching in npm is powerful and flexible. The same sort of version specifiers used in <kbd>package.json</kbd> dependencies can also be used with the <kbd>npm install</kbd> command:</p>
<pre><strong>$ npm install package-name@tag</strong><br/><strong>$ npm install package-name@version</strong><br/><strong>$ npm install package-name@version-range</strong></pre>
<p>The last two are what they sound like. You can specify <kbd>express@4.16.2</kbd> to target a precise version, or <kbd>express@"&gt;4.1.0 &lt; 5.0"</kbd> to  target a range of Express V4 versions.</p>
<p>The version match specifiers include these choices:</p>
<ul>
<li><strong>Exact version match</strong>: 1.2.3</li>
<li><strong>At least version N</strong>: &gt;1.2.3</li>
<li><strong>Up to version N</strong>: &lt;1.2.3</li>
<li><strong>Between two releases</strong>: &gt;=1.2.3 &lt;1.3.0</li>
</ul>
<p>The <kbd>@tag</kbd> attribute is a symbolic name such as <kbd>@latest</kbd>, <kbd>@stable</kbd>, or <kbd>@canary</kbd>. The package owner assigns these symbolic names to specific version numbers, and can reassign them as desired. The exception is <kbd>@latest</kbd>, which is updated whenever a new release of the package is published.</p>
<p>For more documentation, run these commands: <kbd>npm help json</kbd> and <kbd>npm help npm-dist-tag</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Global package installs</h1>
                
            
            
                
<p>In some instances you want to install a module globally, so that it can be used from any directory. For example, the Grunt or Gulp build tools are widely useful, and conceivably you will find it useful if these tools are installed globally. Simply add the <kbd>-g</kbd> option:</p>
<pre><strong>$ npm install -g grunt-cli </strong> </pre>
<p>If you get an error, and you're on a Unix-like system (Linux/Mac), you may need to run this with <kbd>sudo</kbd>:</p>
<pre><strong>$ sudo npm install -g grunt-cli</strong></pre>
<p>A global install is most important for those packages which install executable commands. We'll get into this shortly.</p>
<p>If a local package install lands in <kbd>node_modules</kbd>, where does a global package install land?  On a Unix-like system it lands in <kbd>PREFIX/lib/node_modules</kbd>, and on Windows it lands in <kbd>PREFIX/node_modules</kbd>. In this case PREFIX means the directory where Node.js is installed. You can inspect the location of this directory like so:</p>
<pre class="p1"><strong>$ npm config get prefix<br/>/Users/david/.nvm/versions/node/v8.9.1</strong></pre>
<p>The algorithm used by Node.js for the <kbd>require</kbd> function automatically searches this directory for packages if the package is not found elsewhere.</p>
<p>Remember that ES6 modules do not support global packages.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Avoiding global module installation</h1>
                
            
            
                
<p>Some in the Node.js community now frown on installing a package globally. One rationale exists in the Twelve Factor model. Namely, a software project is more reliable if all its dependencies are explicitly declared. If a build tool such as Grunt is required, but is not explicitly declared in <kbd>package.json</kbd>, the users of the application would have to receive instructions to install Grunt, and they would have to follow those instructions. </p>
<p>Users being users, they might skip over the instructions, fail to install the dependency, and then complain the application doesn't work. Surely most of us have done that once or twice.</p>
<p>It's recommended to avoid this potential problem by installing everything locally via one mechanism—the <kbd>npm install</kbd> command.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Maintaining package dependencies with npm</h1>
                
            
            
                
<p>As we mentioned earlier, the <kbd>npm install</kbd> command by itself installs the packages listed in the <kbd>dependencies</kbd> section of <kbd>package.json</kbd>. This is easy and convenient. Simply by listing all the dependencies, it's quick and easy to install the dependencies required for using the package. What happens is npm looks in <kbd>package.json</kbd> for the <kbd>dependencies</kbd> or <kbd>devDependencies</kbd> field, and it will automatically install the mentioned packages.</p>
<p>You can manage the dependencies manually by editing <kbd>package.json</kbd>. Or you can use npm to assist you with editing the dependencies. You can add a new dependency like so:</p>
<pre><strong>$ npm install akasharender --save </strong> </pre>
<p>In response, npm will add a <kbd>dependencies</kbd> tag to <kbd>package.json</kbd>:</p>
<pre>"dependencies": { 
    "akasharender": "^0.6.15" 
} </pre>
<p>Now, when your application is installed, <kbd>npm</kbd> will automatically also install that package along with any <kbd>dependencies</kbd> listed by that package.</p>
<p>The <kbd>devDependencies</kbd> are modules used during development. That field is initialized the same as above, but with the <kbd>--save-dev</kbd> flag.</p>
<p>By default, when an <kbd>npm</kbd> install is run, modules listed in both <kbd>dependencies</kbd> and <kbd>devDependencies</kbd> are installed. Of course, the purpose for having two lists is to not install the <kbd>devDependencies</kbd> in some cases:</p>
<pre><strong>$ npm install --production </strong> </pre>
<p>This installs only the modules listed in <kbd>dependencies</kbd> and none of the <kbd>devDependencies</kbd> modules.</p>
<p>In the Twelve-Factor application model, it's suggested that we explicitly identify the dependencies required by the application. This way we can reliably build our application, knowing that we've tested against a specific set of dependencies that we've carefully identified. By installing exactly the dependencies against which the application has been tested, we have more confidence in the application. On the Node.js platform, npm gives us this dependencies section, including a flexible mechanism to declare compatible package versions by their version number.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Automatically updating package.json dependencies</h1>
                
            
            
                
<p>With npm@5 (also known as npm version 5), one change was that it's no longer required to add <kbd>--save</kbd> to the <kbd>npm install</kbd> command. Instead, <kbd>npm</kbd> by default acts as if you ran the command with <kbd>--save</kbd>, and will automatically add the dependency to your <kbd>package.json</kbd>. This is meant to simplify using <kbd>npm</kbd>, and it is arguably more convenient that <kbd>npm</kbd> now does this. At the same time it can be very surprising and inconvenient for <kbd>npm</kbd> to go ahead and modify <kbd>package.json</kbd> for you. The behavior can be disabled by using the <kbd>--no-save</kbd> flag. This behavior can be permanently disabled using the following:</p>
<pre><strong>$ npm config set save false</strong></pre>
<p>The <kbd>npm config</kbd> command supports a long list of settable options for tuning behavior of npm. See <kbd>npm help config</kbd> for the documentation, and <kbd>npm help 7 config</kbd> for the list of options.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Fixing bugs by updating package dependencies</h1>
                
            
            
                
<p>Bugs exist in every piece of software. An update to the Node.js platform may break an existing package, as might an upgrade to packages used by the application. Your application may trigger a bug in a package it uses. In these and other cases, fixing the problem might be as simple as updating a package dependency to a later (or earlier) version.</p>
<p>First identify whether the problem exists in the package or in your code. After determining it's a problem in another package, investigate whether the package maintainers have already fixed the bug. Is the package hosted on GitHub or another service with a public issue queue? Look for an open issue on this problem. That investigation will tell you whether to update the package dependency to a later version. Sometimes, it will tell you to revert to an earlier version; for example, if the package maintainer introduced a bug that doesn't exist in an earlier version.</p>
<p>Sometimes, you will find that the package maintainers are unprepared to issue a new release. In such a case, you can fork their repository and create a patched version of their package.</p>
<p>One approach to fixing this problem is <strong>pinning</strong> the package version number to one that's known to work. You might know that version 6.1.2 was the last release against which your application functioned, and that starting with version 6.2.0 your application breaks. Hence, in <kbd>package.json</kbd>:</p>
<pre>"dependencies": {<br/>    "module1": "6.1.2"<br/>}</pre>
<p>This freezes your dependency to the specific version number. You're free, then, to take your time updating your code to work against later releases of that module.  Once your code is updated, or the upstream project is updated, change the dependency appropriately.</p>
<p>Another approach is to host a version of the package somewhere outside of the npm repository. This is covered in a later section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Packages that install commands</h1>
                
            
            
                
<p>Some packages install command-line programs. A side effect of installing such packages is a new command that you can type at the shell prompt or use in shell scripts. An example is the hexy program that we briefly used in <a href="">Chapter 2</a>, <em>Setting up Node.js</em>. Another example is the widely used Grunt or Gulp build tools.</p>
<p>The <kbd>package.json</kbd> file in such packages specifies the command-line tools that are installed. The command can be installed to one of two places:</p>
<ul>
<li><strong>Global Install</strong>: It is installed either to a directory such as <kbd>/usr/local</kbd>, or to the <kbd>bin</kbd> directory where Node.js was installed. The <kbd>npm bin -g</kbd> command tells you the absolute pathname for this directory.</li>
<li><strong>Local Install</strong>: To <kbd>node_modules/.bin</kbd> in the package where the module is being installed. The <kbd>npm bin</kbd> command tells you the absolute pathname for this directory.</li>
</ul>
<p>To run the command, simply type the command name at a shell prompt. Except there's a little bit of configuration required to make that simple.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Configuring the PATH variable to handle commands installed by modules</h1>
                
            
            
                
<p>Typing the full pathname is not a user-friendly requirement to execute the command. We want to use the commands installed by modules, and we want a simple process for doing so. Meaning, we must add an appropriate value in the <kbd>PATH</kbd> variable, but what is it?</p>
<p>For global package installations, the executable lands in a directory that is probably already in your <kbd>PATH</kbd> variable, like <kbd>/usr/bin</kbd> or <kbd>/usr/local/bin</kbd>. Local package installations are what require special handling. The full path for the <kbd>node_modules/.bin</kbd> directory varies for each project, and obviously it won't work to add the full path for every <kbd>node_modules/.bin</kbd> directory to your <kbd>PATH</kbd>.</p>
<p>Adding <kbd>./node_modules/.bin</kbd> to the <kbd>PATH</kbd> variable (or, on Windows, <kbd>.\node_modules\.bin</kbd>) works great. Any time your shell is in the root of a Node.js project, it will automatically find locally-installed commands from Node.js packages.</p>
<p>How we do this depends on the command shell you use, and your operating system.</p>
<p>On a Unix-like system the command shells are <kbd>bash</kbd> and <kbd>csh</kbd>. Your <kbd>PATH</kbd> variable would be set up in one of these ways:</p>
<pre><strong>$ export PATH=./node_modules/.bin:${PATH}     # bash</strong><br/><strong>$ setenv PATH ./node_modules/.bin:${PATH}     # csh</strong></pre>
<p>The next step is adding the command to your login scripts so the variable is always set. On <kbd>bash</kbd>, add the corresponding line to your <kbd>~/.bashrc</kbd>, and on <kbd>csh</kbd> add it to your <kbd>~/.cshrc</kbd>.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Configuring the PATH variable on Windows</h1>
                
            
            
                
<p>On Windows, this task is handled through a system-wide settings panel:</p>
<div><img src="img/a75f2b97-76d6-4507-82e1-45df40c66272.png" width="1039" height="669"/></div>
<p>This pane of the System Properties panel is found by searching for <kbd>PATH</kbd> in the Windows Settings screen. Click on the Environment Variables button, then select the Path variable, and finally click on the Edit button. In the screen here click the New button to add an entry to this variable, and enter <kbd>.\node_modules\.bin</kbd> as shown. You'll have to restart any open command shell windows. Once you do, the effect will be as shown previously.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Avoiding modifications to the PATH variable</h1>
                
            
            
                
<p>What if you don't want to add these variables to your <kbd>PATH</kbd> at all times?  The <kbd>npm-path</kbd> module may be of interest. This is a small program that computes the correct <kbd>PATH</kbd> variable for your shell and operating system. See the package at  <a href="https://www.npmjs.com/package/npm-path">https://www.npmjs.com/package/npm-path</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Updating outdated packages you've installed</h1>
                
            
            
                
<p>The coder codes, updating their package, leaving you in their dust unless you keep up.</p>
<p>To find out if your installed packages are out of date, use the following command:</p>
<pre><strong>$ npm outdated  </strong></pre>
<p>The report shows the current npm packages, the currently-installed version, as well as the current version in the <kbd>npm</kbd> repository. Updating the outdated packages is very simple:</p>
<pre><strong>$ npm update express
$ npm update</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing packages from outside the npm repository</h1>
                
            
            
                
<p>As awesome as the npm repository is, we don't want to push everything we do through their service. This is especially true for internal development teams who cannot publish their code for all the world to see. While you can rent or install a private npm repository, there's another way. Packages can be installed from other locations. Details about this are in <kbd>npm help package.json</kbd> in the <kbd>dependencies</kbd> section. Some examples are:</p>
<ul>
<li><strong>URL</strong>: You can specify any URL that downloads a tarball, that is, a <kbd>.tar.gz</kbd> file. For example, GitHub or GitLab repositories can easily export tarball URL. Simply go to the Releases tab to find them.</li>
<li><strong>Git URL</strong>: Similarly, any Git repository can be accessed with the right URL. For example:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ npm install git+ssh://user@hostname:project.git#tag --save </strong> </pre>
<ul>
<li><strong>GitHub Shortcut</strong>: For GitHub repositories you can list just the repository specifier, such as <kbd>expressjs/express</kbd>.  A tag or a commit can be referenced using <kbd>expressjs/express#tag-name</kbd>.</li>
<li><strong>Local filesystem</strong>: You can install from a local directory using a URL like this:  <kbd>file:../../path/to/dir</kbd>.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Initializing a new npm package</h1>
                
            
            
                
<p>If you want to create a new package, you can create the <kbd>package.json</kbd> file by hand or you can get npm's help. The <kbd>npm init</kbd> command leads you through a little dialog to get starting values for the <kbd>package.json</kbd> file.</p>
<p>Once you get through the questions, the <kbd>package.json</kbd> file is written to disk.</p>
<p>Expect to have to edit that file considerably before publishing to the npm repository. A few fields help give a good impression to folks looking at the package listing on <kbd>npmjs.com</kbd>:</p>
<ul>
<li>Link to the home page, and issue queue URL</li>
<li>Keywords, so it can be linked with other similar packages</li>
<li>A good description that helps folks understand the purpose</li>
<li>A good <kbd>README.md</kbd> file so folks can read some documentation right away</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Declaring Node.js version compatibility</h1>
                
            
            
                
<p>It's important that your Node.js software runs on the correct version of Node.js.  The primary reason being when new features are added to the platform.  You'll want to use those new features, whether it is the async functions added in 8.x or the ES Modules supported added in 10.x.  We need a way to declare the Node.js version required to run our software.</p>
<p>This dependency is declared in <kbd>package.json</kbd> using the <kbd>engines</kbd> tag:</p>
<pre>"engines": { 
    "node": "&gt;= 8.x" 
} </pre>
<p>This, of course, uses the same version number matching scheme discussed earlier.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Publishing an npm package</h1>
                
            
            
                
<p>All those packages in the npm repository came from people like you with an idea of a better way of doing something. It is very easy to get started with publishing packages. Online docs can be found at <a href="https://docs.npmjs.com/getting-started/publishing-npm-packages">https://docs.npmjs.com/getting-started/publishing-npm-packages</a>.</p>
<p>You first use the <kbd>npm adduser</kbd> command to register yourself with the npm repository. You can also sign up with the website. Next, you log in using the <kbd>npm login</kbd> command.</p>
<p>Finally, while sitting in the package root directory, use the <kbd>npm publish</kbd> command. Then, stand back so that you don't get stampeded by the crush of thronging fans. Or, maybe not. There are almost 600,000 packages in the repository, with almost 400 packages added every day. To get yours to stand out, you will require some marketing skill, which is another topic beyond the scope of this book.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Explicitly specifying package dependency version numbers</h1>
                
            
            
                
<p>One feature of the Twelve-Factor methodology is step two, explicitly declaring your dependencies. We've already touched on this, but it's worth reiterating and to seeing npm makes this easy to accomplish.</p>
<p>Step one of the Twelve-Factor methodology is ensuring that your application code is checked into a source code repository. You probably already know this, and even have the best of intentions to ensure that everything is checked in. With Node.js, each module should have its own repository rather than putting every single last piece of code in one repository.</p>
<p>Each module can then progress on its own timeline. A breakage in one module is easy to back out by changing the version dependency in <kbd>package.json</kbd>.</p>
<p>This gets us to Twelve-Factor step two. There are two aspects of this step, one of which is the package versioning that we discussed previously. The next is explicitly declaring version numbers, which can be declared in <kbd>dependencies</kbd> and <kbd>devDependencies</kbd> sections of <kbd>package.json</kbd>. This ensures that everyone on the team is on the same page, developing against the same versions of the same modules. When it's time to deploy to testing, staging, or production servers, and the deployment script runs <kbd>npm install</kbd> or <kbd>npm update</kbd>, the code will use a known version of the module that everyone tested against.</p>
<p>The lazy way of declaring dependencies is putting <kbd>*</kbd> in the version field. That uses the latest version in the npm repository. Maybe this will work, until one day the maintainers of that package introduce a bug. You'll type <kbd>npm update</kbd>, and all of a sudden your code doesn't work. You'll head over to the GitHub site for the package, look in the issue queue, and possibly see that others have already reported the problem you're seeing. Some of them will say that they've pinned on the previous release until this bug is fixed. What that means is their <kbd>package.json</kbd> file does not depend on <kbd>*</kbd> for the latest version, but on a specific version number before the bug was created.</p>
<p>Don't do the lazy thing, do the smart thing.</p>
<p>The other aspect of explicitly declaring dependencies is to not implicitly depend on global packages. Earlier, we said that some in the Node.js community caution against installing modules in the global directories. This might seem like an easy shortcut to sharing code between applications. Just install it globally, and you don't have to install the code in each application.</p>
<p>But, doesn't that make deployment harder? Will the new team member be instructed on all the special files to install here and there to make the application run? Will you remember to install that global module on all destination machines?</p>
<p>For Node.js, that means listing all the module dependencies in <kbd>package.json</kbd>, and then the installation instructions are simply <kbd>npm install</kbd>, followed perhaps by editing a configuration file.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Yarn package management system</h1>
                
            
            
                
<p>As powerful as npm is, it is not the only package management system for Node.js. Because the Node.js core team does not dictate a package management system, the Node.js community is free to roll up their sleeves and develop any system they feel best. That the vast majority of us use npm is a testament to its value and usefulness. But there is a competitor.</p>
<p>Yarn (see <a href="https://yarnpkg.com/en/">https://yarnpkg.com/en/</a>) is a collaboration between engineers at Facebook, Google, and several other companies. They proclaim that Yarn is ultra fast, ultra-secure (by using checksums of everything), and ultra reliable (by using a <kbd>yarn-lock.json</kbd> file to record precise dependencies).</p>
<p>Instead of running their own package repository, Yarn runs on top of npm's package repository at <kbd>npmjs.com</kbd>. This means that the Node.js community is not forked by Yarn, but enhanced by having an improved package management tool.</p>
<p>The npm team responded to Yarn in npm@5 (also known as npm version 5) by improving performance, and by introducing a <kbd>package-lock.json</kbd> file to improve reliability.  The npm team have announced additional improvements in npm@6. </p>
<p>Yarn has become very popular and is widely recommended over npm. They perform extremely similar functions, and the performance is not that different to npm@5. The command-line options are worded differently. An important benefit Yarn brings to the Node.js community is that competition between Yarn and npm seems to be breeding faster advances in Node.js package management.</p>
<p>To get you started, these are the most important commands:</p>
<ul>
<li><kbd>yarn add</kbd>: Adds a package to use in your current package</li>
<li><kbd>yarn init</kbd>: Initializes the development of a package</li>
<li><kbd>yarn install</kbd>: Installs all the dependencies defined in a <kbd>package.json</kbd> file</li>
<li><kbd>yarn publish</kbd>: Publishes a package to a package manager</li>
<li><kbd>yarn remove</kbd>: Removes an unused package from your current package</li>
</ul>
<p>Running <kbd>yarn</kbd> by itself does the <kbd>yarn install</kbd> behavior. There are several other commands in Yarn, and <kbd>yarn help</kbd> will list them all.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>You learned a lot in this chapter about modules and packages for Node.js.</p>
<p>Specifically, we covered implementing modules and packages for Node.js, managing installed modules and packages, and saw how Node.js locates modules.</p>
<p>Now that you've learned about modules and packages, we're ready to use them to build applications, which is the topic of the next chapter.</p>


            

            
        
    </div>



  </body></html>