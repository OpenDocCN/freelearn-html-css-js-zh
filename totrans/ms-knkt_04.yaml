- en: Chapter 4. Application Development with Components and Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, time to get back to application development. We touched briefly on this
    back in [Chapter 1](part0015_split_000.html#page "Chapter 1. Knockout Essentials"),
    *Knockout Essentials*; we will be returning to it here. This chapter is all about
    how to work with Knockout inside modern web applications. In this chapter, we
    will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using modules with RequireJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Knockout with custom component loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Page Application** (**SPA**) routing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because Knockout is a library—a fact it proclaims proudly on the home page—it
    doesn't cover everything you need in complete web applications. This allows Knockout
    to specialize by focusing on a limited feature set, but it leaves the task of
    deciding how to build the rest of the application to you, the developer. The methods
    we cover in this chapter are not the only available options—we don't have that
    kind of time or space—but they should provide enough general guidance to help
    you make your own decisions while keeping in mind Knockout's strengths.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to transform the `Contacts List` application to an SPA—an
    application that uses JavaScript to change the template of the current view, mimicking
    a page change instead of using browser navigation. This pattern has become so
    popular that most developers consider it a given when working on new JavaScript
    web clients, so it's important to understand how Knockout fits into this model
    of development.
  prefs: []
  type: TYPE_NORMAL
- en: RequireJS – AMD viewmodels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RequireJS ([http://requirejs.org/](http://requirejs.org/)) is a library that
    you should have at least heard of already, if not used. This is still a book about
    Knockout, and if you are planning to use RequireJS in an application, you should
    read up on it first, but I will still give you a brief overview here.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of RequireJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RequireJS's purpose is to allow your code to be broken into modules that declare
    their dependencies so that they can be injected at runtime. This has several important
    benefits. As RequireJS loads your JavaScript, you don't have to include each script
    with a `script` tag in your HTML. As RequireJS loads the scripts based on their
    dependencies, you don't have to worry about the order they are loaded in. As each
    module's dependencies are injected, the module can be tested easily with mocks.
    RequireJS also keeps all the objects it loads out of the global scope, which decreases
    the likelihood of namespace collisions in addition to being considered a good
    general practice.
  prefs: []
  type: TYPE_NORMAL
- en: By default, RequireJS will asynchronously load all of your scripts on demand
    at runtime. In some cases, this lazy loading is beneficial, but in production,
    you will want your code bundled into a single file most of the time. RequireJS
    provides **r.js**, its optimizer, for this. RequireJS can even combine these techniques
    by bundling multiple groups of files together and then loading these groups on
    demand at runtime. The best part is that your code won't have to change, regardless
    of which mode you work in!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won't be covering `r.js`, but if you are developing web applications, it
    might be worth investigating this (see [http://requirejs.org/docs/optimization.html](http://requirejs.org/docs/optimization.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Module Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Asynchronous Module Definitions** (**AMD**) is an important concept in RequireJS:
    it declares a function whose return value represents the module. In form, it isn''t
    too different from the **Immediately Evaluating Function Expressions** (**IEFE**)
    we saw in [Chapter 1](part0015_split_000.html#page "Chapter 1. Knockout Essentials"),
    *Knockout Essentials*. This is a typical module definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `define` method forms the first and only top-level statement in the file.
    RequireJS actually enforces a one-module-per-file limit by ignoring multiple calls
    to `define`. The `define` call takes the following three parameters, and the first
    two are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Module name**: This parameter is often ignored, as the standard way to reference
    modules is by their path. Hence, we will not use this parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: This is an array of module names or paths that the module
    depends on. Paths do not require the `.js` suffix; RequireJS already knows it''s
    loading JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module function**: This function receives each dependency from the previous
    array as a parameter and should return the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When RequireJS tries to load a module, it locates the module by path or name
    and runs the `define` method it finds in that file. First, it checks whether all
    of the dependencies have been loaded; if they have not been loaded, it recursively
    loads them, asynchronously and in parallel. When all dependent modules are loaded,
    it runs the module function, passing in each dependency as a parameter in the
    same order in which they were declared as dependencies. The return value of the
    module-loading function is the value that is passed as a parameter to any modules
    that require it as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Starting RequireJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are actually multiple ways to start an app using RequireJS, but by far,
    the most common way is with a `script` tag that points to the initial script of
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `data-main` attribute indicates which script will configure RequireJS and
    start the application. Note that the `.js` suffix is not necessary, as with normal
    module paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `script` tag typically goes in your shell (or layout) file, and it replaces
    all of the `script` tags that RequireJS is responsible for loading. In many cases,
    this means that the only JavaScript `script` tag is the one that loads RequireJS.
    This is one of the killer features of RequireJS: as we develop, we no longer need
    to add `script` tags to our HTML code.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the path starts with a forward slash, which makes it an absolute path.
    It's required because the shell is used on multiple pages, and a relative path
    will not work on a URL such as `/contacts/1`, as it will look in `/contacts/app/main.js`
    for our script.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `main.js` file (the conventional name for the entry point of an AMD application)
    typically contains a configuration section before the start. Here is the configuration
    that we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `paths` section allows us to map paths to module names for use in the dependency
    arrays. This is a good practice for all library code so that our application code
    can use a simple, consistent name. Again, the use of absolute paths is important.
  prefs: []
  type: TYPE_NORMAL
- en: The `shim` section is necessary for loading scripts that depend on globally
    available objects. In the preceding example, the shim for `bootstrap` declares
    jQuery as a dependency and indicates that it exports `$.fn.popover`. Normally,
    you would look for a new namespace such as `$.bootstrap`, but as `bootstrap` doesn't
    create a single endpoint; we are looking for one of the plugins it adds. Any exported
    value can be used here; `popover` was just the chosen one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many libraries are starting to support being loaded as AMD: they look for RequireJS
    or other module loaders and use them if they are available. Not all libraries
    do this, though, and the standard model of JavaScript libraries has always been
    to just look for dependencies in the global scope. As `bootstrap` needs `jQuery`
    but does not indicate this dependency to RequireJS, it will fail if we tried to
    load it normally. The shim tells RequireJS that this library is an old global-scope
    style script and manually indicates its dependencies. The `exports` section provides
    an object that RequireJS can look for to check whether the script has finished
    loading. RequireJS will wait until the specified object exists before allowing
    any AMDs that depend on `bootstrap` to start. Essentially, the `shim` section
    is how RequireJS uses non-AMD code as an asynchronous dependency. If you need
    to use jQuery plugins or other non-AMD compatible libraries, just make a shim
    for them.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other options for the RequireJS configuration—too many to cover
    here. If you want to learn more, check out their documentation, which is available
    at [http://requirejs.org/docs/api.html#config](http://requirejs.org/docs/api.html#config).
  prefs: []
  type: TYPE_NORMAL
- en: Starting the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that RequireJS is configured, it''s time to start the application. The
    main script, which contains our configuration, is also where RequireJS looks for
    the initial module, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The main module is just like other modules, except that RequireJS will run it
    as soon as its dependencies are available. This code is the same startup code
    that used to be in the **Contacts** page's script. You might notice that the dependencies
    for this module don't match the names of the parameters being passed in. jQuery
    is being injected as `$`, Knockout as `ko`, and the **Contacts** page constructor
    as `ContactsPageViewModel`. All of these are conventional JavaScript names for
    their matching objects. The modules are injected in the order of the dependency
    array; RequireJS doesn't actually look at the name of the parameter. This is no
    different from standard functions; callers don't care about the names of parameters,
    they only care about the order. This isn't always obvious to new users, though.
  prefs: []
  type: TYPE_NORMAL
- en: You probably also noticed that `bootstrap` doesn't even have a parameter. This
    is because `bootstrap` doesn't get its own object; all it does is add functions
    to jQuery. However, RequireJS won't load it (or shim it, in this case) until a
    dependency requires it to. It's common to see plugin-style dependencies initialized
    in this manner, as we want them to be available as soon as the app starts.
  prefs: []
  type: TYPE_NORMAL
- en: To see the `Contacts List` application after it is converted into AMD modules,
    open the `cp4-contacts` branch. The code was already in IEFE blocks, so not much
    has changed. The `app` object is no longer required, as namespacing has been replaced
    with the dependency injection. All of the `script` tags, except for RequireJS,
    have been removed from the HTML code. The application still functions in the same
    manner, but by using RequireJS, we no longer have to worry about loading the script.
    This might seem like a minor gain now, but it will make a big difference when
    your app starts to grow.
  prefs: []
  type: TYPE_NORMAL
- en: The text plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing HTML templates can be tricky, because there is no native way to reference
    or embed external HTML files like there is with scripts. If you are familiar with
    the Knockout community, you might have encountered some of the plugins designed
    to solve the problem, such as *Knockout-External-Templates* (which has been discontinued).
    RequireJS solves this problem cleanly with the text plugin. The text plugin works
    much like standard modules: you declare a dependency on external text, and RequireJS
    injects it into the module just like a normal JavaScript module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, you should add the text library to your RequireJS config. Using
    a name such as `text` is standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the text plugin is available, you can use it in external files like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This configuration part is optional if the text plugin is at the root of your
    app and you use the `text!` prefix for dependencies. As we have been putting our
    third-party libraries in a different folder, the configuration is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to combine this ability with components
    in order to create reusable templates with external, isolated HTML views.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Version 3.2, Knockout added components using the combination of a template
    (view) with a viewmodel to create reusable, behavior-driven DOM objects. Knockout
    components are inspired by web components, a new (and experimental, at the time
    of writing this) set of standards that allow developers to define custom HTML
    elements paired with JavaScript that create packed controls. Like web components,
    Knockout allows the developer to use custom HTML tags to represent these components
    in the DOM. Knockout also allows components to be instantiated with a binding
    handler on standard HTML elements. Knockout binds components by injecting an HTML
    template, which is bound to its own viewmodel.
  prefs: []
  type: TYPE_NORMAL
- en: This is probably the single largest feature Knockout has ever added to the core
    library. The reason we started with RequireJS is that components can optionally
    be loaded and defined with module loaders, including their HTML templates! This
    means that our entire application (even the HTML) can be defined in independent
    modules, instead of as a single hierarchy, and loaded asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The basic component registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike extenders and binding handlers, which are created by just adding an
    object to Knockout, components are created by calling the `ko.components.register`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new component named `contact-list`, which uses the object
    returned by the `viewModel` function as a binding context, and the template as
    its view. It is recommended that you use lowercase, dash-separated names for components
    so that they can easily be used as custom elements in your HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this newly created component, you can use a custom element or the component
    binding. All the following three tags produce equivalent results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the custom element syntax is much cleaner and easier to read. It
    is important to note that custom elements cannot be self-closing tags. This is
    a restriction of the HTML parser and *cannot* be controlled by Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one advantage of using the component binding: the name of the component
    can be an observable. If the name of the component changes, the previous component
    will be disposed (just like it would if a control flow binding removed it) and
    the new component will be initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: The `params` attribute of custom elements work in a manner that is similar to
    the `data-bin`d attribute. Comma-separated key/value pairs are parsed to create
    a property bag, which is given to the component. The values can contain JavaScript
    literals, observable properties, or expressions. It is also possible to register
    a component without a viewmodel, in which case, the object created by `params`
    is directly used as the binding context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, we''ll convert the list of contacts into a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML code for the list is replaced with a custom element with parameters
    for the list as well as callbacks for the two buttons, which are `edit` and `delete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This component registration uses an inline template. You can see this component
    in the `cp4-inline-component` branch. Everything still looks and works the same,
    but the resulting HTML now includes our custom element.
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic component registration](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Custom elements in IE 8 and higher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IE 9 and later versions as well as all other major browsers have no issue with
    seeing custom elements in the DOM before they have been registered. However, older
    versions of IE will remove the element if it hasn't been registered. The registration
    can be done either with Knockout, with `ko.components.register('component-name')`,
    or with the standard `document.createElement('component-name')` expression statement.
    One of these must come before the custom element, either by the script containing
    them being first in the DOM, or by the custom element being added at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using RequireJS, being in the DOM first won''t help as the loading is
    asynchronous. If you need to support older IE versions, it is recommended that
    you include a separate script to register the custom element names at the top
    of the `body` tag or in the `head` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once this has been done, components will work in IE 6 and higher even with custom
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Template registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `template` property of the configuration sent to register can take any
    of the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The element ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you specify the ID of an element in the DOM, the contents of that element
    will be used as the template for the component. Although it isn't supported in
    IE yet, the template element is a good candidate, as browsers do not visually
    render the contents of template elements.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be seen in the `cp4-component-id` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The element instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass a real DOM element to the template to be used. This might be useful
    in a scenario where the template was constructed programmatically. Like the element
    ID method, only the contents of the elements will be used as the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method can be seen in the `cp4-component-instance` branch.
  prefs: []
  type: TYPE_NORMAL
- en: An array of DOM nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass an array of DOM nodes to the template configuration, then the entire
    array will be used as a template and not just the descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This can be seen in the `cp4-component-arrray` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Document fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a document fragment, the entire fragment will be used as a template
    instead of just the descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This example works because template elements wrap their contents in a document
    fragment in order to stop the normal rendering. Using the content is the same
    method that Knockout uses internally when a template element is supplied. This
    example can be seen in the `cp4-component-fragment` branch.
  prefs: []
  type: TYPE_NORMAL
- en: HTML strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already saw an example for HTML strings in the previous section. While using
    the value inline is probably uncommon, supplying a string would be an easy thing
    to do if your build system provided it for you.
  prefs: []
  type: TYPE_NORMAL
- en: Registering templates using the AMD module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If a `require` property is passed to the configuration object of a template,
    the default module loader will load the module and use it as the template. The
    module can return any of the preceding formats. This is especially useful for
    the RequireJS text plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using this method, we can extract the HTML template into its own file, drastically
    improving its organization. By itself, this is a huge benefit to development.
    An example of this can be seen in the `cp4-component-text` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The viewmodel registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like template registration, viewmodels can be registered using several different
    formats. To demonstrate this, we''ll use a simple viewmodel of our contacts list
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To verify that things are getting wired up properly, you'll want something interactive;
    hence, we use the fake `delete` function.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you supply a function to the `viewModel` property, it will be treated as
    a constructor. When the component is instantiated, `new` will be called on the
    function, with the `params` object as its first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method can be seen in the `cp4-components-constructor` branch.
  prefs: []
  type: TYPE_NORMAL
- en: A singleton object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you want all your component instances to be backed by a shared object—though
    this is not recommended—you can pass it as the `instance` property of a configuration
    object. Because the object is shared, parameters cannot be passed to the viewmodel
    using this method.
  prefs: []
  type: TYPE_NORMAL
- en: The factory function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is useful because it supplies the container element of the component
    to the second parameter on `componentInfo.element`. It also provides you with
    the opportunity to perform any other setup, such as modifying or extending the
    constructor parameters. The `createViewModel` function should return an instance
    of a viewmodel component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example can be seen in the `cp4-component-factory` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Registering viewmodels using an AMD module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Just like templates, viewmodels can be registered with an AMD module that returns
    any of the preceding formats.
  prefs: []
  type: TYPE_NORMAL
- en: In the `cp4-component-module` branch, you can see an example of this. The component
    registration has been moved to the `main.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Registering AMD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to registering the template and the viewmodel as AMD modules individually,
    you can register the entire component with a require call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The AMD module will return the entire component configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As the Knockout documentation points out, this method has several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The registration call is just a `require` path, which is easy to manage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The component is composed of two parts: a JavaScript module and an HTML module.
    This provides both simple organization and clean separation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RequireJS optimizer, which is `r.js`, can use the text dependency on the
    HTML module to bundle the HTML code with the bundled output. This means your entire
    application, including the HTML templates, can be a single file in production
    (or a collection of bundles if you want to take advantage of lazy loading).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see an example of this in the `cp4-component-amd` branch. This is the
    recommended pattern for components and is the one that will be used for the rest
    of the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Observing changes in component parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Component parameters will be passed via the `params` object to the component''s
    viewmodel in one of the following three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No observable expression evaluation needs to occur, and the value is passed
    literally:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In all of these cases, the value is passed directly to the component on the
    `params` object. This means that changes to these values will change the property
    on the instantiating viewmodel, except for the first case (literal values). Observable
    values can be subscribed to normally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An observable expression needs to be evaluated, so it is wrapped in a computed
    observable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, `params.name` is not the original property. Calling `params.name()`
    will evaluate the computed wrapper. Trying to modify the value will fail, as the
    computed value is not writable. The value can be subscribed to normally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An observable expression evaluates an observable instance, so it is wrapped
    in an observable that unwraps the result of the expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, `firstName` and `lastName` are both observable properties.
    If calling `params.name()` returned the observable, you will need to call `params.name()()`
    to get the actual value, which is rather ugly. Instead, Knockout automatically
    unwraps the expression so that calling `params.name()` returns the actual value
    of either `firstNam`e or `lastName`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you need to access the actual observable instances to, for example, write
    a value to them, trying to write to `params.name` will fail, as it is a computed
    observable. To get the unwrapped value, you can use the `params.$raw` object,
    which provides the unwrapped values. In this case, you can update the name by
    calling `params.$raw.name('New')`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this case should be avoided by removing the logic from the binding
    expression and placing it in a computed observable in the viewmodel.
  prefs: []
  type: TYPE_NORMAL
- en: The component's life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a component binding is applied, Knockout takes the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: The component loader asynchronously creates the viewmodel factory and template.
    This result is cached so that it is only performed once per component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The template is cloned and injected into the container (either the custom element
    or the element with the component binding).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the component has a viewmodel, it is instantiated. This is done synchronously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component is bound to either the viewmodel or the `params` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component is left *active* until it is disposed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component is disposed. If the viewmodel has a `dispose` method, it is called,
    and then the template is removed from the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component's disposal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the component is removed from the DOM by Knockout, either because of the
    name of the component binding or a control flow binding being changed (for example,
    `if` and `foreach`), the component will be disposed. If the component''s viewmodel
    has a `dispose` function, it will be called. Normal Knockout bindings in the components
    view will be automatically disposed, just as they would in a normal control flow
    situation. However, anything set up by the viewmodel needs to be manually cleaned
    up. Some examples of viewmodel cleanup include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `setInterval` callbacks can be removed with `clearInterval`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed observables can be removed by calling their `dispose` method. Pure
    computed observables don't need to be disposed. Computed observables that are
    only used by bindings or other viewmodel properties also do not need to be disposed,
    as garbage collection will catch them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable subscriptions can be disposed by calling their `dispose` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers can be created by components that are not part of a normal Knockout
    binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see a simple dispose handler in the `cp4-dispose` branch. It just logs
    to the console to demonstrate when it will fire; try editing a contact to make
    the control flow remove the list from the page.
  prefs: []
  type: TYPE_NORMAL
- en: Combining components with data bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is only one restriction of `data-bind` attributes that are used on custom
    elements with the component binding: the binding handlers cannot use `controlsDescendantBindings`.
    This isn''t a new restriction; two bindings that control descendants cannot be
    on a single element, and since components control descendant bindings that cannot
    be combined with a binding handler that also controls descendants. It is worth
    remembering, though, as you might be inclined to place an `if` or `foreach` binding
    on a component; doing this will cause an error. Instead, wrap the component with
    an element or a containerless binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It's also worth noting that bindings such as `text` and `html` will replace
    the contents of the element they are on. When used with components, this will
    potentially result in the component being lost, so it's not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom component loaders**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered the behavior of the default component loader. It is
    quite flexible, and for many developers, it will be quite sufficient for most
    use cases. However, it is possible to implement the custom component-loading functionality.
    In fact, you can have multiple component loaders active simultaneously, each providing
    different capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: This section will deal with creating custom component loaders. If you are satisfied
    with the functionality of the default loader, you might want to skip this section
    and continue to single page application routing.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s cover how the component-loading system works. Component loading
    is only done once per component. Knockout caches the loaded components. This cache
    provides the following two public functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ko.components.get(name, callback)`: This function loops through all the loaders
    until one of them returns a component. This component is cached, and then the
    callback is invoked with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ko.components.clearCachedDefinition(name)`: This function removes the component
    from the registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knockout maintains an array of loaders on `ko.components.loaders`. By default,
    this array only contains a single loader, which also lives on `ko.components.defaultLoader`.
    When a component binding requests a component, or you call `ko.components.get`,
    Knockout loops through the loaders, calling `getConfig` on each component until
    it gets a non-null object. This configuration is then passed to each loader until
    a valid component object is returned. The loaded component is then cached. A valid
    component object has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template`: This is an array of DOM nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createViewModel(params, componentInfo)`: This is an optional factory method
    to build components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a component loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the methods are optional on a component loader, as Knockout will run
    through each method on each loader until it gets a valid response before repeating
    it on the next method. All component loader functions are asynchronous by supplying
    a callback. Remember, the result will be cached unless manually cleared with `ko.components.clearCachedDefinition(componentName)`.
    The following are the methods used to implement a component loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getConfig(name, callback)`: This returns a component configuration object.
    A configuration object is anything that any loader''s `loadComponent` function
    can understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadComponent(name, componentConfig, callback)`: This supplies a component
    object of the `{ template: domNodeArray, createViewModel(params, componentInfo)
    }` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadTemplate(name, templateConfig, callback)`: This supplies an array of DOM
    nodes to be used as the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadViewModel(name, viewModelConfig, callback)`: This supplies a function
    to be used as the `createViewModel(params, componentInfo)` factory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement a method, just include it in your loader. To have your loader skip
    a method that it has implemented, call `callback(null)`.
  prefs: []
  type: TYPE_NORMAL
- en: The last two methods are not directly called by the Knockout component system
    but by the default loader's `loadComponent` method.
  prefs: []
  type: TYPE_NORMAL
- en: The default loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how the methods on a custom loader can be made optional, you
    must understand how the default loader works. The default loader has an internal
    registry for component configurations—not to be confused with the cache for components.
    The default loader adds the following methods to the `ko.components` object in
    order to work with the component configuration registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ko.components.register(name, configuration)`: This is covered in the previous
    section in detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ko.components.isRegistered(name)`: This returns `true` if the component configuration
    is in the registry; otherwise, it returns `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ko.unregister(name)`: This removes the named configuration if it exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Knockout tries to load a component for the first time, it calls `getConfig`
    on each loader in `ko.components.loaders` until one returns a non-null object.
    Then, it passes that configuration object to `loadComponent` on each loader until
    one returns a non-null component object. If a loader other than the default loader
    returns a component from `loadComponent`, the chain ends there.
  prefs: []
  type: TYPE_NORMAL
- en: However, the default loader's `loadComponent` method calls `loadTemplate` and
    `loadViewModel` on each loader (including itself) until it gets both a template
    and a viewmodel. These calls are independent; the default loader will take the
    first template it gets and the first viewmodel it gets even if they are from different
    loaders. If your custom loader has a higher priority than the default loader,
    or if the default loader can't understand your configuration, your custom loader
    will have a chance to supply its own template and/or viewmodel by implementing
    `loadTemplate` or `loadViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a custom loader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike `ko.bindingHandlers` and `ko.extenders`, which are both objects, `ko.components.loaders`
    is an array. Once you have created your custom loader, you can add it to the `loaders`
    array. The order of the `loaders` array determines the priority; Knockout always
    loops through the loaders from the first to the last:'
  prefs: []
  type: TYPE_NORMAL
- en: For a lower priority custom loader, use `ko.components.loaders.push(loader)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a higher priority custom loader, use `ko.components.loaders.unshift(loader)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a fine-grained control custom loader, use `ko.components.loaders.splice(priority,
    0, loader)`, where priority is the 0-index rank of the new loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you remove the default loader from `ko.component.loaders`, then `loadTemplate`
    and `loadViewModel` will no longer be called (unless they are called by another
    custom loader). As it is possible to simply add a custom loader with a higher
    priority, there is little value in removing the default loader.
  prefs: []
  type: TYPE_NORMAL
- en: Registering custom elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom elements work in Knockout by wrapping the component binding. There are
    two options that can be used to get Knockout to treat a custom element as a component:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `ko.components.register('component-name', { /* config */ }`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override `ko.components.getComponentNameForNode(node)` so that it returns the
    name of a component. Components do not need to be registered as long as a loader
    that can load the name returned by this method exists. The default loader will
    only load components registered with `ko.components.register`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading components with custom configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alright, it''s time to look at an example. This one is taken from the Knockout
    component''s documentation. Let''s say you are using our own asynchronous loading
    library for the HTML, and you want your custom loader to use it. This could be
    true for a JavaScript loader, which the documentation provides as an example,
    but it would be similar enough to be redundant here. It will use its own configuration
    property name in order to avoid confusion with the default loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As the default loader will pass this configuration to the `loadTemplate` method
    of each loader, we can just implement that one method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This loader will use jQuery to retrieve and parse the template if it has the
    `fromUrl` property; otherwise, it will do nothing. The only thing that''s left
    is to add the loader to Knockout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can see this custom loader in the `cp4-loader` branch; it is in the `main.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout's default component loader is already flexible, but the ability to
    provide your own custom loader for both configuration and instantiation gives
    the Knockout component system the ability to work with whichever format you want
    to create.
  prefs: []
  type: TYPE_NORMAL
- en: Single Page Application (SPA) routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big part of the appeal of Knockout (or any MV* framework) is that its template
    engine allows us to rerender parts of the page without the need to talk to the
    server. Being able to make incremental page updates on the client side means less
    latency, giving the application a much snappier feel. SPAs take this concept to
    the next level by letting the JavaScript client control navigation between pages.
    When the browser navigates, it has to rerender the whole page, which means reloading
    the JavaScript, HTML, CSS, and everything. When JavaScript *navigates*, it just
    has to change part of the HTML, which ends up being much faster in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout can provide this virtual page-changing functionality relatively easily,
    but an important component of SPAs is that page changes still update the URL.
    This helps the user check whether a change has occurred, but more importantly,
    it means that if the user refreshes the page or shares the link, the application
    will go to the right page. Without the URL update, the user will always end up
    on the home screen. This feature is commonly known as **routing**. Knockout does
    not provide this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: To explore how Knockout fits into an SPA scenario, we are going to use SammyJS
    ([http://sammyjs.org/](http://sammyjs.org/)). SammyJS is a popular library used
    for routing; Knockout even uses it on its tutorial site. There are many other
    options, of course, but the concept should be very similar regardless of which
    library you use.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of SammyJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SammyJS''s default routing uses hash-change navigation, which uses the URL
    hash to store the current state. As the hash is not sent to the server by the
    browser, the server always sees the URL as a request for the home page. Once the
    page loads, Sammy will inspect the hash and locate the matching route, if one
    exists. If it finds a route, it runs the callback for that route. The callback
    is responsible for performing whatever application logic is necessary for navigation.
    The following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is a typical Sammy application configuration. The `Sammy` object is a function
    that takes an element's ID, which it will scope the handler to, and an initialization
    handler and returns the application object. Inside the initialization handler,
    this has methods for each HTTP verb that registers routes. The preceding sample
    registers a route for `#/` (a standard *home* route) and a route for `#/contacts/:id`.
    The `:id` part of the route indicates a parameter that will match any contents
    and provide the value on the `params` object inside the route's callback.
  prefs: []
  type: TYPE_NORMAL
- en: The application object that is returned from `Sammy()` will not start until
    `run()` is called, which should wait for the DOM to be ready. The `run()` method
    takes a default route, which will be loaded if no hash is present (such as when
    navigating to the bare domain URL).
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SammyJS monitors the `window.location.hash` property for any changes and runs
    the matching route handler. This can happen when a user clicks on an a tag with
    an `href` attribute containing a hash or by setting `window.location.hash` from
    JavaScript. Using the window object inside viewmodels is generally discouraged,
    as it is difficult to mock in unit tests. It would also be nice to keep the navigation
    logic centralized, just in case it needs to be changed later. To do this, we will
    encapsulate the navigation into a router module. For now, it only needs a single
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once injected with RequireJS, viewmodels can be navigated by calling `router.navigate`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating page components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a lot of different ways to organize Knockout viewmodels in SPAs and
    web apps in general. As we just learned how to create components, we are going
    to look at a method used to structure each page as a component. This gives us
    a few solid advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The pages will be decoupled from each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each page will have its own HTML and JavaScript file, which feels natural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single component binding on the shell can hold the *body* of the page while
    maintaining a static layout for the navigation bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, we will need to introduce a folder structure that will keep these
    files organized, so we might as well start now.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating page components](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The home page (which was just a greeting) has been removed, but the placeholder
    settings page is still there so that we have at least two links to test navigation
    with. The router and mock data service have been moved into the `core` folder
    (a name I prefer because it's shorter than `common`). The rest of the code, which
    consists of the contact model and the two pages, has been moved into the `contacts`
    folder. The `main.js` starting file hasn't moved.
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, group files whichever way you want; nothing we have covered
    so far will require any specific file structure.
  prefs: []
  type: TYPE_NORMAL
- en: The edit page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, both pages were managed by a single viewmodel that switched between
    them using a null *editing* contact. However, it was clear that this combined
    viewmodel was serving multiple roles. Splitting the editing code should reduce
    some confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only three real changes here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, instead of clearing the `entryContact` object to indicate that editing
    is finished, the viewmodel calls `router.navigate('/')`. As we don't have a home
    page anymore, the list page will be used as the default page, which will be tied
    to the `/` route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, as editing will occur based on navigation instead of the `entryContact`
    object being set directly, the viewmodel uses the `params` component to look for
    an ID. If an ID isn't present, it is assumed that we are creating a new contact;
    if an ID is present, the contact is loaded from the data service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a `dispose` method has been added, which will clear the `entryContact`
    object. This isn't actually necessary, but it demonstrates how the clean up will
    be done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML code hasn't really changed, except that it will be in its own file
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The list page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The list page will be the new home page. Like the edit page, it will need to
    use the router to navigate to the edit page instead of using the `entryContact`
    object. The list page doesn''t need any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here too, the HTML code hasn't changed much, except that the `contact-list`
    component has been removed, so its view has been re-added to the list page.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinating pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the example server has been responsible for putting each page into
    our shell/layout HTML by performing a string replace. To get the experience of
    a real SPA, we are going to change the server to return an index file without
    performing any parsing or rendering on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `appHost` element in the preceding code contains a containerless component
    binding that uses an observable `name` and `params` value. It's wrapped in an
    `if` binding that ensures that the component binding isn't active until a page
    has been selected. All the root viewmodel has to do is supply the `name` and `params`
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, our `main.js` will contain a simple viewmodel that contains each
    property. The SammyJS route handlers will set this viewmodel when the routes are
    activated. The `main.js` file will also be responsible for registering the page
    components with Knockout. It''s long, so we are going to break it up into chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: SammyJS has been added as a dependency and injected in. The RequireJS configuration
    isn't shown, but it doesn't require a shim. SammyJS plays nicely as an AMD. The
    `pageVm` object is created with two observable properties and a helper method
    for setting them. The order is important because component viewmodels are instantiated
    synchronously, and the data bound to the `params` object needs to already be in
    place when the component name changes; otherwise, the component will initialize
    before the `params` objects are set.
  prefs: []
  type: TYPE_NORMAL
- en: After SammyJS has been set up, the document-ready handler starts it using a
    default route and then applies bindings with the `pageVm` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to perform the SammyJS configuration would be to write out each component
    register and route handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Personally, I think this ends up being a bit messy. It also duplicates the
    component name in `register` and `setRoute`. SammyJS also doesn''t allow you to
    bind multiple routes to the same handler in a single call; you have to write both
    of them out. This is especially annoying for the home page, because SammyJS treats
    an empty route and the `#/` route as different routes, even though they both conventionally
    mean *home*. To solve these, we can combine the component and route definitions
    into a page object, and then loop over them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Much better. Now, it's easy to see how the routes and components are related,
    and defining multiple routes for a single component is simple. It also removes
    the duplicated component name.
  prefs: []
  type: TYPE_NORMAL
- en: The `instanceof` check lets us use an array or a string for the `page.route`
    property by always making it an array. The `params` section will include any parameters
    captured by the route handler and will pass them as the data used by the component
    binding for the `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: All the code we just covered can be seen in the `cp4-spa` branch. Be sure to
    use each page on the app, and notice the URL change. If you go to a page, such
    as a specific contact, and refresh the browser, SammyJS will make sure that the
    correct page is loaded instead of always going to the home page. This gives the
    application a very natural feel. You should also notice that moving between pages
    happens with little or no delay (depending on your CPU). For comparison, try to
    view changes between the `/contacts` and `/settings` pages in the `cp4-contacts`
    branch. The SPA navigation is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should have a good idea or two about how to structure a Knockout
    web application, specifically, a single page application. The Knockout components
    feature gives you a powerful tool that will help you create reusable, behavior-driven
    DOM elements, and writing custom loaders allows you to fully control how components
    are used. The RequireJS AMD patterns make application organization easy by splitting
    up JavaScript and HTML into independent modules. Because these modules use dependency
    injection, creating mocks for unit testing is also possible. Finally, you saw
    how SammyJS can create fast client-side JavaScript navigation with pages controlled
    by components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the Durandal framework, which will make
    the single page application development even easier.
  prefs: []
  type: TYPE_NORMAL
