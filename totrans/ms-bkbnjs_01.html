<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Architecture of a Backbone application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Architecture of a Backbone application</h1></div></div></div><p>One of the best things about Backbone is the freedom to build applications with the libraries of your choice, no batteries included. Note that Backbone is not a framework but a library; due to this, building applications with Backbone can be challenging as no structure is provided. You, as a developer, are responsible for code organization and how to wire the pieces of the code across the application; it's a big responsibility. Bad decisions can lead to buggy and unmaintainable applications that nobody wants to work with.</p><p>Code organization on small Backbone applications is not a big deal. Create a directory for models, collections, and views; put a router for all possible routes; and write the business logic directly in the views. However, this way of developing Backbone applications is not suitable for bigger projects. There should be a better way to separate responsibilities and file organization in order to create maintainable applications.</p><p>This chapter can be difficult to understand if you don't know Backbone at all; to understand the principles that are exposed here better, you will need to understand at least the basics of Backbone. Therefore, if you are a beginner in Backbone, I would encourage you to first understand what Backbone is and how it works.</p><p>The goal of this chapter is to explore the best practices of project organization on two main levels: logic organization and file structure. In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Delegating the right responsibilities to the objects provided by Backbone</li><li class="listitem" style="list-style-type: disc">Defining plain JavaScript objects in order to deal with logic out of scope of Backbone objects</li><li class="listitem" style="list-style-type: disc">Splitting the application in to small and maintainable scripts</li><li class="listitem" style="list-style-type: disc">Creating a clean file structure for your projects</li></ul></div><div class="section" title="Subapplications based architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Subapplications based architecture</h1></div></div></div><p>We can compose a <a id="id0" class="indexterm"/>Backbone application with many independent subapplications. The subapplications should work independently. You can think about each one as a small Backbone application, with its own dependencies and responsibilities; it should not depend on other subapplications directly.</p><p>Subapplications should be focused on a specific domain area. For example, you can have a subapplication for invoices, another for the mailbox, and one more for payments; with these subapplications in place, you can build an application in order to manage payments through email.</p><p>To decouple subapplications from each other, we can build an infrastructure application responsible for managing the subapplications, bootstrapping the whole application, and providing the subapplications with common functions and services:</p><div class="mediaobject"><img src="graphics/B01962_01_01.jpg" alt="Subapplications based architecture"/><div class="caption"><p>Figure 1.1. Composition of a Backbone application with subapplications</p></div></div><p>You can use the infrastructure application to provide your subapplications with services such as confirmation and dialog messages, notification pop-ups, modal boxes, and so on. The infrastructure application does nothing by itself, it behaves as a framework for the subapplications.</p><p>When a subapplication wants to communicate with another subapplication, the infrastructure application can be used as a communication channel, it can take advantage of the <code class="literal">Backbone.Event</code> object in order to send and receive messages.</p><p>In the following figure, you can see a scenario where the subapplications communicate through the infrastructure application. When the user clicks on <span class="strong"><strong>Compose message</strong></span> in the Mailbox subapplication, the infrastructure application creates and renders the <span class="strong"><strong>Compose mail</strong></span> subapplication and allows the user to write an e-mail.</p><p>When the user is done, they have to click on the <span class="strong"><strong>Send</strong></span> button in the <span class="strong"><strong>Compose</strong></span> subapplication; then the e-mail is sent through a RESTful API or using plain SMTP, don't care, the important thing is that, when it finishes, it triggers an event in the <code class="literal">email:sent</code> infrastructure application.</p><p>The infrastructure <a id="id1" class="indexterm"/>application forwards the event to the Mailbox subapplication, so that the list of emails that are sent can be updated. Another interesting thing is that the infrastructure application can use the <code class="literal">email:sent</code> event to show a successful pop-up message to the user to tell them that the email was successfully sent:</p><div class="mediaobject"><img src="graphics/B01962_01_02.jpg" alt="Subapplications based architecture"/><div class="caption"><p>Figure 1.2. Communication between subapplications</p></div></div><div class="section" title="Subapplication anatomy"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Subapplication anatomy</h2></div></div></div><p>As mentioned earlier, a <a id="id2" class="indexterm"/>subapplication is like a small Backbone application; they should be independent of other subapplications and work as a standalone. You should be able to put the Compose mail subapplication on a blank page without any other subapplication and still be able to send emails.</p><p>To achieve this, the subapplications should contain all the necessary objects that are to be auto-contained. You can see that the entry point of the subapplication is <code class="literal">Backbone.Router</code>. When the browser changes the URL and a route is matched for a given subapplication, the router creates a subapplication controller and delegates it the route handling.</p><p>The subapplication controller coordinates the models/collections and how they are shown. The controller can instruct the <span class="strong"><strong>Application</strong></span> infrastructure to show a loading message while the data is fetched and when it's done, the controller can build the necessary views with the models and collections that are recently fetched in order to show them in the DOM.</p><p>In short, a subapplication behaves exactly like a small Backbone application, with the main difference being that it uses the Application infrastructure to delegate common tasks and a communication channel between the subapplications.</p><p>In the next sections, we will examine how these parts are connected and I will show you the code for a working <a id="id3" class="indexterm"/>Contacts application. The following figure shows an anatomy view of a subapplication:</p><div class="mediaobject"><img src="graphics/B01962_01_03.jpg" alt="Subapplication anatomy"/><div class="caption"><p>Figure 1.3. Anatomy of a subapplication</p></div></div></div></div></div>
<div class="section" title="Responsibilities of Backbone objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Responsibilities of Backbone objects</h1></div></div></div><p>One of the biggest issues with the <a id="id4" class="indexterm"/>Backbone documentation is not to have a clue about how to use its objects. You, as developers, should figure out the responsibilities for each object across the application; if you have some experience working with Backbone, then you would know how difficult it would be to build a Backbone application.</p><p>In this section, I will describe the best uses of the Backbone objects. Starting at this point, you will have a clearer idea about the scope of responsibilities in Backbone and this will lead the design of our application architecture. Keep in mind that Backbone is a library with only the foundation objects; therefore, you will need to bring your own objects and structure to make scalable, testable, and robust Backbone applications.</p><div class="section" title="Views"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Views</h2></div></div></div><p>The only<a id="id5" class="indexterm"/> responsibilities of views are to handle the <span class="strong"><strong>Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>) <a id="id6" class="indexterm"/>and listen for low-level events (jQuery/DOM events), and transform them into domain ones. The Backbone Views<a id="id7" class="indexterm"/> works closely with template engines in order to create markups that represent the information that is contained in models and collections.</p><p>Views abstract the user interactions, transforming their actions into business value data structures for the application. For example, when a click event is triggered from a Save button in the DOM, the view should transform the event into something similar to a <code class="literal">save:contact</code> event using Backbone Events with the data written in the form. Then, a domain-specific object can apply some business logic to the data and show a result.</p><p>It is a rule that business logic on views should be avoided; however, basic form validations such as accept only numbers are allowed. Complex validations should still be done on the model or the controller.</p></div><div class="section" title="Models"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Models</h2></div></div></div><p>Backbone Models<a id="id8" class="indexterm"/> are like database gateways in the server side, their main use is to fetch and save data to and from a RESTful server and then provide an API to the rest of the application in order to handle the information. They can run general-purpose business logic, such as validation and data transformation, handle other server connections, and upload an image for a model.</p><p>The models<a id="id9" class="indexterm"/> do not know anything about views; however, they can implement functionality that is useful for views. For example, you can have a view that shows the total of an invoice and the invoice model can implement a method that does the calculation, leaving the view without knowledge of the computation.</p></div><div class="section" title="Collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Collections</h2></div></div></div><p>You can think of <a id="id10" class="indexterm"/>Backbone Collections as a container of a set of Backbone Models, for example, a Collection of <code class="literal">Contacts</code> models. With a model, you can only fetch a single document at time; however, Collections<a id="id11" class="indexterm"/> allow us to fetch lists of Models.</p><p>A big difference from Models is that Collections should be used as read-only, they fetch the data but they should not write in the server; also it is not usual to see business logic here.</p><p>Another use for Collection is to abstract RESTful APIs responses as each server has different ways to deal with a list of resources. For instance, while some servers accept a <code class="literal">skip</code> parameter for pagination, others have a <code class="literal">page</code> parameter for the same purpose. Another case is on responses, a server can respond with a plain array, while others prefer to send an object with a <code class="literal">data</code>, <code class="literal">list</code>, or other key, where the array of objects is placed. There is no standard way. Collections can deal with these issues, making server requests transparent for the rest of the application.</p></div><div class="section" title="Routers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Routers</h2></div></div></div><p>Routers <a id="id12" class="indexterm"/>have a simple<a id="id13" class="indexterm"/> responsibility: listening for URL changes in the browser and transforming them into a call to a handler. A router knows which handler to call for a given URL. Also, they have to decode URL parameters and pass them to the handlers. The infrastructure application bootstraps the application; however, routers decide which subapplication will be executed. In this way, routers are a kind of entry point.</p></div></div>
<div class="section" title="Objects not provided by Backbone"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Objects not provided by Backbone</h1></div></div></div><p>It is possible to <a id="id14" class="indexterm"/>develop Backbone applications only using the Backbone objects that are described in the previous section; however, for a medium-to-large application, it's not sufficient. We need to introduce a new kind of object with delimited responsibilities that use and coordinate Backbone foundation objects.</p><div class="section" title="Subapplication façade"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Subapplication façade</h2></div></div></div><p>This object is the public <a id="id15" class="indexterm"/>interface of the subapplications. Any interaction <a id="id16" class="indexterm"/>with the subapplications should be done through its methods. The calls made directly to internal objects of the subapplication are discouraged. Typically, methods on this controller are called from the router; however, they can be called from anywhere.</p><p>The main responsibility of this object is to simplify subapplication internals. Its main work is to fetch data from the server through models or collections and, if an error occurs during the process, it is responsible to show an error message to the user. Once the data is loaded in a model or <a id="id17" class="indexterm"/>collection, it creates a subapplication controller<a id="id18" class="indexterm"/> that knows the views which should be rendered and have the handlers deal with its events.</p></div><div class="section" title="Subapplication controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Subapplication controller</h2></div></div></div><p>A controller acts <a id="id19" class="indexterm"/>like an air traffic controller for views, models, and <a id="id20" class="indexterm"/>collections. When given a Backbone data object, it will instantiate and render the appropriate views and then coordinate them. On complex layouts, it is not an easy task to coordinate the views with the models and collections.</p><p>The Business logic for the use cases should be implemented here. The subapplication controller implements a <a id="id21" class="indexterm"/>
<span class="strong"><strong>mediator pattern</strong></span>, allowing other basic objects such as views and models keep it simple and loose coupling.</p><p>Due to loose coupling reasons, a view should not directly call to methods or events of other views Instead of this, a view triggers events and the controller handles the event and orchestrates the views behavior if necessary. Note how views are isolated, handling just its owned portion of DOM and triggering events when required to communicate something.</p></div></div>
<div class="section" title="Contacts application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Contacts application</h1></div></div></div><p>In this book, we will develop a simple <a id="id22" class="indexterm"/>contacts application in order to demonstrate how to develop Backbone applications following the principles explained throughout this book. The application should be able to list all the available contacts in RESTful API and provide the mechanisms to show and edit them.</p><p>The application starts when the Application infrastructure is loaded in the browser and the <code class="literal">start()</code> method on it is called. It will bootstrap all the common components and then instantiate all the available routers in the subapplications:</p><div class="mediaobject"><img src="graphics/B01962_01_04.jpg" alt="Contacts application"/><div class="caption"><p>Figure 1.4. Application instantiates all the routers available in the subapplications</p></div></div><div class="informalexample"><pre class="programlisting">// app.js
var App = {
  Models: {},
  Collections: {},
  Routers: {},
  start() {
    // Initialize all available routes
    _.each(_.values(this.Routers), function(Router) {
      new Router();
    });

    // Create a global router to enable sub-applications to
    // redirect to other urls
    App.router = new DefaultRouter();
    Backbone.history.start();
  }
}</pre></div><p>The entry point of <a id="id23" class="indexterm"/>subapplication is given by its routes, which ideally share the same namespace. For instance, in the contacts subapplication, all the routes start with the <code class="literal">contacts/</code> prefix:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Contacts</code>: This lists all available contacts</li><li class="listitem" style="list-style-type: disc"><code class="literal">contacts/new</code>: This shows a form to create a new contact</li><li class="listitem" style="list-style-type: disc"><code class="literal">contacts/view/:id</code>: This shows an invoice given its ID</li><li class="listitem" style="list-style-type: disc"><code class="literal">contacts/edit/:id</code>: This shows a form to edit a contact</li></ul></div><p>Subapplications <a id="id24" class="indexterm"/>should register its routers in the <code class="literal">App.Routers</code> global object in order to be initialized. For the Contacts subapplication, the <code class="literal">ContactsRouter</code> does the job:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/router.js
'use strict';

App.Routers = App.Routers || {};

class ContactsRouter extends Backbone.Router {
  constructor(options) {
    super(options);
    this.routes = {
      'contacts': 'showContactList',
      'contacts/page/:page': 'showContactList',
      'contacts/new': 'createContact',
      'contacts/view/:id': 'showContact',
      'contacts/edit/:id': 'editContact'
    };
    this._bindRoutes();
  }

  showContactList(page) {
    // Page should be a postive number grater than 0
    page = page || 1;
    page = page &gt; 0 ? page : 1;

    var app = this.startApp();
    app.showContactList(page);
  }

  createContact() {
    var app = this.startApp();
    app.showNewContactForm();
  }

  showContact(contactId) {
    var app = this.startApp();
    app.showContactById(contactId);
  }

  editContact(contactId) {
    var app = this.startApp();
    app.showContactEditorById(contactId);
  }

  startApp() {
    return App.startSubApplication(ContactsApp);
  }
}

// Register the router to be initialized by the infrastructure
// Application
App.Routers.ContactsRouter = ContactsRouter;</pre></div><p>When the user points <a id="id25" class="indexterm"/>its browser to one of these routes, a route handler is triggered. The handler function parses the URL and delegates the request to the subapplication façade:</p><div class="mediaobject"><img src="graphics/B01962_01_05.jpg" alt="Contacts application"/><div class="caption"><p>Figure 1.5. Route delegation to Subapplication Façade</p></div></div><p>The <code class="literal">startSubApplication()</code> method in the <code class="literal">App</code> object starts a new subapplication and closes any other subapplication that is running at a given time, this is useful to free resources in the user's browser:</p><div class="informalexample"><pre class="programlisting">var App = {
  // ...
  // Only a subapplication can be running at once, destroy any
  // current running subapplication and start the asked one
  startSubApplication(SubApplication) {
    // Do not run the same subapplication twice
    if (this.currentSubapp &amp;&amp;
        this.currentSubapp instanceof SubApplication) {
      return this.currentSubapp;
    }

    // Destroy any previous subapplication if we can
    if (this.currentSubapp &amp;&amp; this.currentSubapp.destroy) {
      this.currentSubapp.destroy();
    }

    // Run subapplication
    this.currentSubapp = new SubApplication({
      region: App.mainRegion
    });
    return this.currentSubapp;
  },
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The <code class="literal">App.mainRegion</code> attribute is an instance of a <code class="literal">Region</code> object that points to a DOM element in the page; regions are useful to render views in a contained region of the DOM. We will learn more about this object in <a class="link" href="ch02.html" title="Chapter 2. Managing Views">Chapter 2</a>, <span class="emphasis"><em>Managing views</em></span>.</p><p>When the<a id="id26" class="indexterm"/> subapplication is started, a façade method is called on it to handle the user request. The responsibility of the façade is to fetch the necessary data from the RESTful API and pass the data to a controller:</p><div class="mediaobject"><img src="graphics/B01962_01_06.jpg" alt="Contacts application"/><div class="caption"><p>Figure 1.6. Façade responsibility</p></div></div><div class="informalexample"><pre class="programlisting">// apps/contacts/app.js
'use strict';

class ContactsApp {
  constructor(options) {
    this.region = options.region;
  }

  showContactList() {
    App.trigger('loading:start');
    App.trigger('app:contacts:started');

    new ContactCollection().fetch({
      success: (collection) =&gt; {
        // Show the contact list subapplication if
        // the list can be fetched
        this.showList(collection);
        App.trigger('loading:stop');
      },
      fail: (collection, response) =&gt; {
        // Show error message if something goes wrong
        App.trigger('loading:stop');
        App.trigger('server:error', response);
      }
    });
  }

  showNewContactForm() {
    App.trigger('app:contacts:new:started');
    this.showEditor(new Contact());
  }

  showContactEditorById(contactId) {
    App.trigger('loading:start');
    App.trigger('app:contacts:started');

    new Contact({id: contactId}).fetch({
      success: (model) =&gt; {
        this.showEditor(model);
        App.trigger('loading:stop');
      },
      fail: (collection, response) =&gt; {
        App.trigger('loading:stop');
        App.trigger('server:error', response);
      }
    });
  }

  showContactById(contactId) {
    App.trigger('loading:start');
    App.trigger('app:contacts:started');

    new Contact({id: contactId}).fetch({
      success: (model) =&gt; {
        this.showViewer(model);
        App.trigger('loading:stop');
      },
      fail: (collection, response) =&gt; {
        App.trigger('loading:stop');
        App.trigger('server:error', response);
      }
    });
  }

  showList(contacts) {
    var contactList = this.startController(ContactList);
    contactList.showList(contacts);
  }

  showEditor(contact) {
    var contactEditor = this.startController(ContactEditor);
    contactEditor.showEditor(contact);
  }

  showViewer(contact) {
    var contactViewer = this.startController(ContactViewer);
    contactViewer.showContact(contact);
  }

  startController(Controller) {
    if (this.currentController &amp;&amp;
        this.currentController instanceof Controller) {
      return this.currentController;
    }

    if (this.currentController &amp;&amp;
        this.currentController.destroy) {
      this.currentController.destroy();
    }

    this.currentController = new Controller({
      region: this.region
    });
    return this.currentController;
  }
}</pre></div><p>The façade <a id="id27" class="indexterm"/>object receives a region object as argument in order to indicate to the subapplication where it should be rendered. The <code class="literal">Region</code> objects will be explained in detail in <a class="link" href="ch02.html" title="Chapter 2. Managing Views">Chapter 2</a>, <span class="emphasis"><em>Managing views</em></span>.</p><p>When the façade is fetching data from the RESTful server, a <code class="literal">loading:start</code> event is emitted on the <code class="literal">App</code> object in order to allow us to show the loading in progress view for the user. When the loading finishes, it creates and uses a controller that knows how to deal with the model or fetched collection.</p><p>The business logic starts when the controller is invoked, it will render all the necessary views for the request and show them to the user, then it will listen for user interactions in the views:</p><div class="mediaobject"><img src="graphics/B01962_01_07.jpg" alt="Contacts application"/><div class="caption"><p>Figure 1.7. Controller creates the necessary views</p></div></div><p>For the <code class="literal">ContactList</code> controller, here<a id="id28" class="indexterm"/> is a very simple code:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactLst.js
class ContactList {
  constructor(options) {
    // Region where the application will be placed
    this.region = options.region;

    // Allow subapplication to listen and trigger events,
    // useful for subapplication wide events
    _.extend(this, Backbone.Events);
  }

  showList(contacts) {
    // Create the views
    var layout = new ContactListLayout();
    var actionBar = new ContactListActionBar();
    var contactList = new ContactListView({collection: contacts});

    // Show the views
    this.region.show(layout);
    layout.getRegion('actions').show(actionBar);
    layout.getRegion('list').show(contactList);

    this.listenTo(contactList, 'item:contact:delete',
      this.deleteContact);
  }

  createContact() {
    App.router.navigate('contacts/new', true);
  }

  deleteContact(view, contact) {
    let message = 'The contact will be deleted';
    App.askConfirmation(message, (isConfirm) =&gt; {
      if (isConfirm) {
        contact.destroy({
          success() {
            App.notifySuccess('Contact was deleted');
          },
          error() {
            App.notifyError('Ooops... Something went wrong');
          }
        });
      }
    });
  }

  // Close any active view and remove event listeners
  // to prevent zombie functions
  destroy() {
    this.region.remove();
    this.stopListening();
  }
}</pre></div><p>The function that handles the request is very simple and follows the same pattern for all other controllers, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It creates all the necessary views with the model or collection that is passed</li><li class="listitem" style="list-style-type: disc">It renders the views in a region of the DOM</li><li class="listitem" style="list-style-type: disc">It listens for events in the views</li></ul></div><p>If you don't entirely <a id="id29" class="indexterm"/>understand what region and layout means, don't worry, I will cover the implementation of these objects in detail in <a class="link" href="ch02.html" title="Chapter 2. Managing Views">Chapter 2</a>, <span class="emphasis"><em>Managing views</em></span>. Here, the important thing is the algorithm described earlier:</p><div class="mediaobject"><img src="graphics/B01962_01_08.jpg" alt="Contacts application"/><div class="caption"><p>Figure 1.8. ContactList controller result</p></div></div><p>As you can see in the above figure, the contact list shows a set of cards for each contact in the list. The user is allowed to delete a contact by clicking on the <span class="strong"><strong>delete</strong></span> button. When this happens, a <code class="literal">contact:delete</code> event is triggered, the controller is listening for the event and uses the <code class="literal">deleteContact()</code> method to handle the event:</p><div class="informalexample"><pre class="programlisting">  deleteContact(view, contact) {
    let message = 'The contact will be deleted';
    App.askConfirmation(message, (isConfirm) =&gt; {
      if (isConfirm) {
        contact.destroy({
          success() {
            App.notifySuccess('Contact was deleted');
          },
          error() {
            App.notifyError('Ooops... Something went wrong');
          }
        });
      }
    });
  }</pre></div><p>The handler is <a id="id30" class="indexterm"/>pretty easy to understand, it uses the <code class="literal">askConfirmation()</code> method in the infrastructure app to ask for the user confirmation. If the user confirms the deletion, the contact is destroyed. The infrastructure App provides two methods to show notifications to the user: <code class="literal">notifySuccess()</code> and <code class="literal">notifyError()</code>.</p><p>The cool thing about these App methods is that the controllers do not need to know the details about the confirmation and notification mechanisms. From the controller point of view, it just works.</p><p>The method that asks for the confirmation can be a simple <code class="literal">confirm()</code> call, as follows:</p><div class="informalexample"><pre class="programlisting">// app.js
var App = {
  // ...
  askConfirmation(message, callback) {
    var isConfirm = confirm(message);
    callback(isConfirm);
  }
};</pre></div><p>However, in the modern web applications, using the plain <code class="literal">confirm()</code> function is not the best way to ask for confirmation. Instead, we can show a Bootstrap dialog box or use an available library for that. For simplicity, we will use the nice JavaScript <code class="literal">SweetAlert</code> library; however, you can use whatever you want:</p><div class="informalexample"><pre class="programlisting">// app.js
var App = {
  // ...

  askConfirmation(message, callback) {
    var options = {
      title: 'Are you sure?',
      type: 'warning',
      text: message,
      showCancelButton: true,
      confirmButtonText: 'Yes, do it!',
      confirmButtonColor: '#5cb85c',
      cancelButtonText: 'No'
    };

    // Show the message
    swal(options, function(isConfirm) {
      callback(isConfirm);
    });
  }
};</pre></div><div class="mediaobject"><img src="graphics/B01962_01_09.jpg" alt="Contacts application"/><div class="caption"><p>Figure 1.9. Using SweetAlert for confirmation messages</p></div></div><p>We can implement <a id="id31" class="indexterm"/>the notification methods in a similar way. We will use the JavaScript <code class="literal">noty</code> library; however, you can use whatever you want:</p><div class="informalexample"><pre class="programlisting">// app.js
var App = {
  // ...

    notifySuccess(message) {
    new noty({
      text: message,
      layout: 'topRight',
      theme: 'relax',
      type: 'success',
      timeout: 3000 // close automatically
    });
  },

  notifyError(message) {
    new noty({
      text: message,
      layout: 'topRight',
      theme: 'relax',
      type: 'error',
      timeout: 3000 // close automatically
    });
  }
};	</pre></div><div class="mediaobject"><img src="graphics/B01962_01_10.jpg" alt="Contacts application"/><div class="caption"><p>Figure 1.10. Using noty to show notification messages</p></div></div><p>This is how you can implement a robust and maintainable Backbone application; please go to the GitHub repo for this book in order to see the complete code for the application. The views are not covered in the chapter as we will see them in detail in <a class="link" href="ch02.html" title="Chapter 2. Managing Views">Chapter 2</a>, <span class="emphasis"><em>Managing views</em></span>.</p><div class="section" title="File organization"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>File organization</h2></div></div></div><p>When you work with MVC frameworks, file organization<a id="id32" class="indexterm"/> is trivial. However, Backbone is not an MVC framework, therefore, bringing your own file structure is the rule. You can organize the code on these paths:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">apps/</code>: This directory is where modules or subapplications live. All subapplications should be on this path</li><li class="listitem" style="list-style-type: disc"><code class="literal">Components/</code>: These are the common components that multiple subapplications require or use on the common layout as a breadcrumbs component</li><li class="listitem" style="list-style-type: disc"><code class="literal">core/</code>: Under this path, we can put all the core functions such as utilities, helpers, adapters, and so on</li><li class="listitem" style="list-style-type: disc"><code class="literal">vendor/</code>: On vendor, you can put all third-party libraries; here you can put Backbone and its dependencies.</li><li class="listitem" style="list-style-type: disc"><code class="literal">app.js</code>: This is the entry point of the application that is loaded from <code class="literal">index.html</code></li><li class="listitem" style="list-style-type: disc">Subapplications can have a file structure as they are a small Backbone Application.</li><li class="listitem" style="list-style-type: disc"><code class="literal">models/</code>: This defines the models and collections</li><li class="listitem" style="list-style-type: disc"><code class="literal">app.js</code>: This is the application façade that is called from the router</li><li class="listitem" style="list-style-type: disc"><code class="literal">router.js</code>: This is the router of the application that is instantiated by the root application at bootstrap process</li><li class="listitem" style="list-style-type: disc"><code class="literal">contactList.js</code>, <code class="literal">contactEditor.js</code>, <code class="literal">contactViewer.js</code>: These are the controllers for the application</li></ul></div><p>For a <code class="literal">contacts</code> application, the code organization can be as shown in the following:</p><div class="mediaobject"><img src="graphics/B01962_01_11.jpg" alt="File organization"/><div class="caption"><p>Figure 1.11. File structure</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>We started by describing, in a general way, how a Backbone application works. It describes two main parts: a root application and subapplications. The root application provides a common infrastructure to other smaller and focused applications that we call subapplications.</p><p>Subapplications should be loose coupled with other subapplications and should own its resources such as views, controllers, routers, and so on. A subapplication manages a small part of the system with a well-focused business value and the communication between subapplications and infrastructure application is made through an events-driven bus with <code class="literal">Backbone.Events</code>.</p><p>The user interacts with the application using views that a subapplication renders. A subapplication controller orchestrates interaction between views, models, and collections and owns the business logic for the use case.</p><p>Finally, a file system organization explains the right sites to put your files and keep your project clean and organized. This organization does not follow an MVC pattern; however, it is powerful and simple. It encapsulates all the necessary code for a module in a single path (subapplication paths) instead of putting all the code across multiple paths.</p><p>In this way the structure of Backbone applications has been proven to be robust, a proof for this is that several open source applications such as TodoMVC follow (more or less) the principles exposed here. It facilitates the testability of the code due to separation of responsibilities so that each object can be tested separately.</p><p>Large Backbone applications are often built on top of Backbone Marionette as it reduces the boilerplate code; however, Marionette uses its own conventions to work. If you are fine with it using its own conventions, you will be happy to use Marionette on top of Backbone.</p><p>However, if you love the freedom of doing things your way, you may prefer plain Backbone and create your own utilities and classes.</p><p>In the next chapter, I will show you how to manage and organize views and simplify the complex layouts, identifying the common uses of the views. You will build general purpose views that will be useful for all your projects and forget about the implementation of the <code class="literal">render()</code> method. </p></div></body></html>