<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Runtime &amp;#x2013; The Event Loop and the this Operator</h1>
                </header>
            
            <article>
                
<p>Over the next two chapters, we are going to learn about some concepts that are closely related to the TypeScript runtime. TypeScript is only used at design time; the TypeScript code is then compiled into JavaScript and finally executed at runtime. The JavaScript runtime oversees the execution of the JavaScript code. It is essential to understand that we will never execute TypeScript code and we will always execute JavaScript code; for this reason, when we refer to the TypeScript runtime, we will, in fact, be talking about the JavaScript runtime.</p>
<p>Understanding the runtime is crucial because it will help us to understand the implementation of a number of functional programming techniques that we will explore later in this book.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The environment</li>
<li>The <kbd>event</kbd> loop</li>
<li>The <kbd>this</kbd> operator</li>
</ul>
<p>Let's start by learning about the environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The environment</h1>
                </header>
            
            <article>
                
<p>The runtime environment is one of the first things that we must think about before we can start developing a TypeScript application. Once we have compiled our TypeScript code into JavaScript, it can be executed in many different environments. While most of those environments will be part of a web browser such as Chrome, Internet Explorer, or Firefox, we might also want to be able to run our code on the server side or, in a desktop application, in environments such as Node.js, RingoJS, or Electron.</p>
<p>It is essential to keep in mind that there are some variables and objects available at runtime that are environment-specific. For example, we could create a library and access the <kbd>document.layers</kbd> variable. While <kbd>document</kbd> is part of the W3C <strong>Document Object Model</strong> (<strong>DOM</strong>) standard, the <kbd>layers</kbd> property is only available in Internet Explorer and is not part of the W3C DOM standard.</p>
<p>The <em>W3C</em> defines the DOM as:</p>
<div class="packt_quote">The Document Object Model is a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure, and style of documents. The document can be further processed, and the results of that processing can be incorporated back into the presented page.</div>
<p>Similarly, we can also access a set of objects known as the <strong>Browser Object Model</strong> (<strong>BOM</strong>) from a web browser runtime environment. The BOM consists of the <kbd>navigator</kbd>, <kbd>history</kbd>, <kbd>screen</kbd>, <kbd>location</kbd>, and <kbd>document</kbd> <span>objects, </span>which are properties of the <kbd>window</kbd> object.</p>
<p>We need to keep in mind that the DOM is only available in web browsers. If we want to run our application in a web browser, we will be able to access the DOM and BOM. However, in environments such as Node.js or RingoJS, these APIs will not be available since they are standalone JavaScript environments completely independent of a web browser. We can also find other objects in the server-side environments (such as <kbd>process.stdin</kbd> in Node.js) that will not be available if we attempt to execute our code in a web browser.</p>
<p>We also need to keep in mind the existence of multiple versions of these JavaScript environments. In some cases, we will have to support multiple browsers and various versions of Node.js. The recommended practice when dealing with this problem is to use conditional statements that check for the availability of features:</p>
<pre>if (Promise &amp;&amp; typeof Promise.all === "function") {<br/>    // User Promise.all here...<br/>}</pre>
<p>This is executed instead of <span>checking</span> the availability of an environment or version:</p>
<pre>if (<br/>    navigator.userAgent.toLowerCase().indexOf('chrome') &gt; -1 &amp;&amp;<br/>    navigator.vendor.toLowerCase().indexOf("google") &gt; -1<br/>) {<br/>    // Use Promise.all here...<br/>}</pre>
<div class="packt_infobox">
<p>An excellent library is available that can help us to implement feature detection when developing for web browsers. The library is called <strong>Modernizr</strong>, and can be downloaded at <a href="http://modernizr.com/">http://modernizr.com/</a>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the event loop</h1>
                </header>
            
            <article>
                
<p>The TypeScript runtime (JavaScript) has a concurrency model based on an <kbd>event</kbd> loop. This model is quite different from the model in other languages, such as C or Java. Before focusing on the <kbd>event</kbd> loop itself, we must first understand a number of runtime concepts.</p>
<p>What follows is a visual representation of some critical runtime concepts: <strong>HEAP</strong>, <strong>STACK</strong>, <strong>QUEUE</strong>, and <strong>FRAME</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8e641809-0c6f-4ed4-92d5-fe712fe54760.png" style="width:20.33em;height:20.42em;"/></p>
<p>We will now look at the role of each of these runtime concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Frames</h1>
                </header>
            
            <article>
                
<p>A <strong>frame</strong> is a sequential unit of work. In the preceding diagram, frames are represented by the blocks inside the stack.</p>
<p>When a <kbd>function</kbd> is invoked in JavaScript, the runtime creates a frame in the stack. The frame holds that function's arguments and local variables. When the function returns, the frame is removed from the stack. Let's look at an example:</p>
<pre>function foo(a: number): number {<br/>    const localFooValue = 12;<br/>    return localFooValue + a;<br/>}<br/><br/>function bar(b: number): number {<br/>    const localBarValue = 4;<br/>    return foo(localBarValue * b);<br/>}</pre>
<p>After declaring the <kbd>foo</kbd> and <kbd>bar</kbd> functions, we invoke the <kbd>bar</kbd> function:</p>
<pre>bar(21);</pre>
<p>When the <kbd>bar</kbd> function is executed, the runtime will create a new frame containing the arguments of <kbd>bar</kbd> and all its local variables (<kbd>b</kbd> and <kbd>localBarValue</kbd>). The frame (represented as a black square in the preceding diagram) is then added to the top of the stack.</p>
<p>Internally, the <kbd>bar</kbd> function invokes the <kbd>foo</kbd> function. When <kbd>foo</kbd> is invoked, a new frame is created and allocated to the top of the stack. When the execution of <kbd>foo</kbd> is finished (<kbd>foo</kbd> has returned), the top frame is removed from the stack. When the execution of <kbd>bar</kbd> is also completed, it is removed from the stack as well.</p>
<p>Now, let's imagine what would happen if the <kbd>foo</kbd> function invoked the <kbd>bar</kbd> function:</p>
<pre>function foo(a: number): number {<br/>    const localFooValue = 12;<br/>    return bar(localFooValue + a);<br/>}<br/><br/>function bar(b: number): number {<br/>    const localBarValue = 4;<br/>    return foo(localBarValue * b);<br/>}</pre>
<p>The preceding code snippet creates a never-ending <kbd>function call</kbd> loop. With each function call, a new frame is added to the stack, and eventually there will be no more space in the stack and an error will be thrown. Most software engineers are familiar with this error, known as a <strong>stack overflow</strong> error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stack</h1>
                </header>
            
            <article>
                
<p>The <strong>stack</strong> contains sequential steps (frames). A stack is a data structure that represents a simple <strong>Last-in-first-out</strong> (<strong>LIFO</strong>) collection of objects. Therefore, when a frame is added to the stack, it is always added to the top of the stack.</p>
<p>Since the stack is a LIFO collection, the <kbd>event</kbd> loop processes the frames stored in it from top to bottom. The dependencies of a frame are added to the top of it in the stack to ensure that all the dependencies of each of the frames are met.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queue</h1>
                </header>
            
            <article>
                
<p>The <strong>queue</strong> contains a list of waiting to be processed. Each is associated with a function. When the stack is empty, a message is taken out of the queue and processed. The processing consists of calling the associated function and adding the frames to the stack. Message processing ends when the stack becomes empty again.</p>
<p>In the previous runtime diagram, the blocks inside the queue represent the messages. The messages are usually generated by user or applications events. For example, when the user clicks in an element with an event handler, a new message is added to the queue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Heap</h1>
                </header>
            
            <article>
                
<p>The <strong>heap</strong> is a memory container that is not aware of the order of the items stored in it. The heap contains all the variables and objects currently in use. It may also contain frames that are currently out of scope but have not yet been removed from the memory by the garbage collector.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The event loop</h1>
                </header>
            
            <article>
                
<p>Concurrency is the ability to execute two or more operations simultaneously. The JavaScript runtime execution takes place on a single thread, which means that we cannot achieve real concurrency.</p>
<p>The <strong>event loop</strong> follows a run-to-completion approach, which means that it will process a message from beginning to end before any other message is processed.</p>
<div class="packt_infobox">
<p>As we saw in <a href="3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml" target="_blank">Chapter 3</a>, <em>Mastering Asynchronous Programming</em>, we can use the <kbd>yield</kbd> keyword and generators to pause the execution of a function.</p>
</div>
<p>Every time a function is invoked, a new message is added to the queue. If the stack is empty, the function is processed (the frames are added to the stack).</p>
<p>When all the frames have been added to the stack, the stack is cleared from top to bottom. At the end of the process, the stack is empty, and the next message is processed.</p>
<div class="packt_infobox">
<p>Web workers can perform background tasks in a different thread. They have their queue, heap, and stack.</p>
</div>
<p>One of the advantages of the <kbd>event</kbd> loop is that the execution order is quite predictable and easy to follow. <span>A disadvantage of this approach is that, if a message takes too long to complete, the application becomes unresponsive. A good practice to follow is to make message processing short and, if possible, split one message into several messages.</span></p>
<div class="packt_infobox">The Node.js runtime features a non-blocking I/O model in combination with a single-thread event loop model, which means that, when the application is waiting for an I/O operation to finish, it can still process other things, such as user input.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The this operator</h1>
                </header>
            
            <article>
                
<p>In JavaScript, the <kbd>this</kbd> operator behaves a little differently compared to other languages. The value of the <kbd>this</kbd> operator is often determined by the way a function is invoked. Its value cannot be set by assignment during execution, and it may be different each time a function is invoked.</p>
<div class="packt_infobox">
<p>The <kbd>this</kbd> operator also has some differences when using <strong>strict</strong> and <strong>non-strict</strong> modes. <span>ECMAScript 5's strict mode is a way to opt into a restricted variant of JavaScript. You can learn more about strict mode at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode.</a></span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The this operator in the global context</h1>
                </header>
            
            <article>
                
<p>In the global context, the <kbd>this</kbd> operator will always point to the global object. In a web browser, the <kbd>window</kbd> object is the global object:</p>
<pre>console.log(this === window); // true<br/>this.a = 37;<br/>console.log(window.a); // 37<br/>console.log(window.document === this.document); // true<br/>console.log(this.document === document); // true<br/>console.log(window.document === document); // true</pre>
<div class="packt_infobox">
<p><span>The preceding example should </span><span>be implemented using JavaScript. </span>The preceding code will fail in TypeScript if the <kbd>strict</kbd> compilation flag is enabled because the <kbd>strict</kbd> flag enables the <span><kbd>noImplicitThis </kbd></span><span>flag, which prevents us from using the <kbd>this</kbd> operator in a scope in which its value is not clear, such as a global scope.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The this operator in the function context</h1>
                </header>
            
            <article>
                
<p>The value of <kbd>this</kbd> inside a function depends on how the function is invoked. If we invoke a function in non-strict mode, the value of <kbd>this</kbd> within the function will point to the global object:</p>
<pre>function f1() {<br/>  return this;<br/>}<br/><br/>f1() === window; // true</pre>
<div class="packt_infobox">
<p><span>The preceding example should </span><span>be implemented using JavaScript.</span> <span>The preceding code will fail in TypeScript when the </span><kbd>strict</kbd><span> compilation flag is enabled because it also enables the <kbd>noImplicitThis</kbd> flag.</span></p>
</div>
<p>However, if we invoke a function in strict mode, the value of <kbd>this</kbd> within the function's body will be <kbd>undefined</kbd>:</p>
<pre>console.log(this); // global (window)<br/><br/>function f2() {<br/>  "use strict";<br/>  return this; // undefined<br/>}<br/><br/>console.log(f2()); // undefined<br/>console.log(this); // window</pre>
<div class="packt_infobox">
<p><span>The preceding example should </span><span>be implemented using JavaScript.</span></p>
</div>
<p>However, the value of the <kbd>this</kbd> operator inside a function invoked as an instance method points to the instance. In other words, the value of the <kbd>this</kbd> operator within a function that is part of a class (a method) points to the class instance:</p>
<pre>const person = {<br/>  age: 37,<br/>  getAge: function() {<br/>    return this.age; // this points to the instance (person)<br/>  }<br/>};<br/><br/>console.log(person.getAge()); // 37</pre>
<div class="packt_infobox">
<p><span>The preceding example should </span><span>be implemented using JavaScript.</span></p>
</div>
<p>In the preceding example, we have used object literal notation to define an object named <kbd>person</kbd>, but the same applies when declaring objects using classes:</p>
<pre>class Person {<br/>  public age: number;<br/>  public constructor(age: number) {<br/>    this.age = age;<br/>  }<br/>  public getAge() {<br/>    return this.age; // this points to the instance (person)<br/>  }<br/>}<br/><br/>const person = new Person(37);<br/>console.log(person.getAge()); // 37</pre>
<div class="packt_infobox"><span>The preceding example should </span><span>be implemented using TypeScript.</span></div>
<p>At runtime, classes are implemented (using what are known as prototypes) as a prototype chain. Don't worry if you don't know much about prototypes because we will learn more about them in the next chapter. All we need to know for now is that the behavior described in the preceding section takes place when working with prototypes:</p>
<pre>function Person(age) {<br/>    this.age = age;<br/>}<br/><br/>Person.prototype.getAge = function () {<br/>    return this.age; // this points to the instance (person)<br/>};<br/><br/>var person = new Person(37);<br/>console.log(person.getAge()); // 37</pre>
<div class="packt_infobox">
<p><span>The preceding example should </span><span>be implemented using JavaScript.</span></p>
</div>
<p>When a function is used as a constructor (with the <kbd>new</kbd> keyword), the <kbd>this</kbd> operator points to the object being constructed:</p>
<pre>function Person() { // function used as a constructor<br/>  this.age = 37;<br/>}<br/><br/>const person = new Person();<br/>console.log(person.age); // logs 37</pre>
<div class="packt_infobox">
<p>The preceding example should be implemented using JavaScript.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The call, apply, and bind methods</h1>
                </header>
            
            <article>
                
<p>All functions inherit the <kbd>call</kbd>, <kbd>apply</kbd>, and <kbd>bind</kbd> methods from <kbd>Function.prototype</kbd>. We can use these methods to set the value of <kbd>this</kbd>.</p>
<p>The <kbd>call</kbd> and <kbd>apply</kbd> methods are almost identical; both methods allow us to invoke a function and set the value of the <kbd>this</kbd> operator within the function. The main difference between <kbd>call</kbd> and <kbd>apply</kbd> is that, while <kbd>apply</kbd> lets us invoke the function with arguments as an array, <kbd>call</kbd> requires that function parameters be listed explicitly.</p>
<div class="packt_tip">
<p>A useful mnemonic is A (apply) for an array and C (call) for a comma.</p>
</div>
<p>Let's look at an example. We will start by declaring a class named <kbd>Person</kbd>. This class has two properties (<kbd>name</kbd> and <kbd>surname</kbd>) and one method (<kbd>greet</kbd>). The <kbd>greet</kbd> method uses the <kbd>this</kbd> operator to access the <kbd>name</kbd> and <kbd>surname</kbd> instance properties:</p>
<pre>class Person {<br/><br/>  public name: string;<br/>  public surname: string;<br/><br/>  public constructor(name: string, surname: string) {<br/>    this.name = name;<br/>    this.surname = surname;<br/>  }<br/><br/>  public greet(city: string, country: string) {<br/>    // we use the this operator to access name and surname<br/>    let msg = `Hi, my name is ${this.name} ${this.surname}.`;<br/>    msg += `I'm from ${city} (${country}).`;<br/>    console.log(msg);<br/>  }<br/><br/>}</pre>
<p><span>After declaring the <kbd>Person</kbd> class, we will create an instance:</span></p>
<pre>const person = new Person("remo", "Jansen");</pre>
<p>If we invoke the <kbd>greet</kbd> method, it will work as expected:</p>
<pre>person.greet("Seville", "Spain");</pre>
<p>Alternatively, we can invoke the method using the <kbd>call</kbd> and <kbd>apply</kbd> functions. We have supplied the <kbd>person</kbd> object as the first parameter of both functions because we want the <kbd>this</kbd> operator (inside the <kbd>greet</kbd> method) to take <kbd>person</kbd> as its value:</p>
<pre>person.greet.call(person, "Seville", "Spain");<br/>person.greet.apply(person, ["Seville", "Spain"]);</pre>
<p>If we provide a different value to be used as the value of <kbd>this</kbd>, we will not be able to access the <kbd>name</kbd> and <kbd>surname</kbd> properties within the <kbd>greet</kbd> function:</p>
<pre>person.greet.call(null, "Seville", "Spain");<br/>person.greet.apply(null, ["Seville", "Spain"]);</pre>
<p>The two preceding examples may seem useless because the first one invoked the function directly and the second one caused unexpected behavior. The <kbd>apply</kbd> and <kbd>call</kbd> methods only make sense when we want the <kbd>this</kbd> operator to take a different value when a function is invoked:</p>
<pre>const valueOfThis = { name : "Anakin", surname : "Skywalker" };<br/>person.greet.call(valueOfThis, "Mos espa", "Tatooine");<br/>person.greet.apply(valueOfThis, ["Mos espa", "Tatooine"]);</pre>
<p>The <kbd>bind</kbd> method can be used to set the value of the <kbd>this</kbd> operator (within a function), regardless of how it is invoked.</p>
<p>When we invoke a function's <kbd>bind</kbd> method, it returns a new function with the same body and scope as the original function, but the <kbd>this</kbd> operator (within the body function) is permanently bound to the first argument of <kbd>bind</kbd>, regardless of how the function is being used.</p>
<p>Let's look at an example. We will start by creating an instance of the <kbd>Person</kbd> class that we declared in the previous example:</p>
<pre>const person = new Person("Remo", "Jansen");</pre>
<p>Then we can use <kbd>bind</kbd> to set the <kbd>greet</kbd> function as a new function with the same scope and body:</p>
<pre>const greet = person.greet.bind(person);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If we try to invoke the <kbd>greet</kbd> function using <kbd>bind</kbd> and <kbd>apply</kbd>, just like we did in the previous example, we will be able to observe that, this time, the <kbd>this</kbd> operator will always point to the object instance, irrespective of how the function is invoked:</p>
<pre>greet.call(person, "Seville", "Spain");<br/>greet.apply(person, ["Seville", "Spain"]);<br/>// Hi, my name is Remo Jansen. I'm from Seville Spain.<br/><br/>greet.call(null, "Seville", "Spain");<br/>greet.apply(null, ["Seville", "Spain"]);<br/>// Hi, my name is Remo Jansen. I'm from Seville Spain.<br/><br/>const valueOfThis = { name: "Anakin", surname: "Skywalker" };<br/>greet.call(valueOfThis, "Mos espa", "Tatooine");<br/>greet.apply(valueOfThis, ["Mos espa", "Tatooine"]);<br/>// Hi, my name is Remo Jansen. I'm from Mos espa Tatooine.</pre>
<div class="packt_infobox">
<p>Using the <kbd>apply</kbd>, <kbd>call</kbd>, and <kbd>bind</kbd> methods is not recommended unless you are very familiar with what you are doing, because they can result in other developers encountering complex and hard-to-debug runtime issues.</p>
</div>
<p>Once we bind an object to a function with <kbd>bind</kbd>, we cannot override it:</p>
<pre>const valueOfThis = { name: "Anakin", surname: "Skywalker" };<br/>const greet = person.greet.bind(valueOfThis);<br/>greet.call(valueOfThis, "Mos espa", "Tatooine");<br/>greet.apply(valueOfThis, ["Mos espa", "Tatooine"]);<br/>// Hi, my name is Remo Jansen. I'm from Mos espa Tatooine.</pre>
<div class="packt_infobox">
<p>The use of <kbd>bind</kbd>, <kbd>apply</kbd>, and <kbd>call</kbd> is discouraged in JavaScript because it can lead to confusion. Modifying the default behavior of the <kbd>this</kbd> operator can lead to unexpected results. Remember to use these methods only when strictly necessary and to document your code correctly to reduce the risk caused by potential maintainability issues. However, TypeScript 3.2.0 introduces a new compilation flag, known as <kbd>strictBindCallApply</kbd>, that makes <span>the </span><kbd>bind</kbd><span>, </span><kbd>apply</kbd><span>, and </span><kbd>call</kbd> methods safer.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned some fundamental aspects of the TypeScript and JavaScript runtime. We have learned that a potential differences lies in the execution environments of web browsers and platforms such as Node.js. We have also learned the functions are processed and executed by the <kbd>event</kbd> loop and how the value of the <kbd>this</kbd> operator can change in different contexts.</p>
<p>In the next chapter, we will learn more about the runtime, and we will explore closures and prototypes. We will then be fully ready to delve into the implementation of a wide variety of functional programming techniques.</p>


            </article>

            
        </section>
    </body></html>