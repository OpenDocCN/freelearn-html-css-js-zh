- en: Chapter 9. Promises and Proxies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。承诺和代理
- en: This chapter introduces the important concept of **asynchronous programming**
    and how JavaScript is an ideal language to utilize it. The other topic that we
    will cover in this chapter is meta programming with proxies. These two concepts
    are introduced in ES6.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了重要的概念**异步编程**以及JavaScript如何成为利用这一特性的理想语言。本章还将涵盖使用代理的元编程。这两个概念都是在ES6中引入的。
- en: In this chapter, our primary focus is to understand asynchronous programming,
    before we jump into the language - specific constructs, let's spend time in understanding
    the concept first.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的主要重点是理解异步编程，在我们深入研究特定语言的构造之前，让我们花时间先理解这个概念。
- en: 'The first model-the **synchronous model-**is where it all began. This is the
    simplest model of programming. Each task is executed one at a time, and only after
    the first task completes execution can, the next task start. When you program
    in this model, we expect that all tasks before the current task are complete and
    there is no error. Take a look at the following figure:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模型——**同步模型**——是所有一切的开始。这是编程中最简单的模型。每个任务一次执行一个，并且只有当第一个任务完成执行后，下一个任务才能开始。当你以这种模型编程时，我们期望当前任务之前的所有任务都已完成且没有错误。看看下面的图：
- en: '![Promises and Proxies](img/image_09_001.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![承诺和代理](img/image_09_001.jpg)'
- en: 'The **single threaded asynchronous model** is a familiar model we all know.
    However, this model can be wasteful and optimized. For any nontrivial programs
    composed of several different tasks, this model can be slow. Consider the following
    hypothetical scenario as an example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**单线程异步模型**是我们都熟悉的一个模型。然而，这个模型可能是浪费的并且可以优化。对于由几个不同任务组成的任何非平凡程序，这个模型可能会很慢。以下是一个假设场景的例子：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the synchronous model in mind, two tasks are executed one after the other.
    This means that the second statement will only be executed once the first has
    completed execution. Assuming the first statement is a costly one and takes 10
    seconds (it is normal to take even more time to read from a remote database),
    the second statement will be blocked.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑同步模型的情况下，两个任务一个接一个地执行。这意味着第二个语句只有在第一个语句完成执行后才会执行。假设第一个语句是一个昂贵的语句，需要10秒钟（从远程数据库读取可能需要更多时间是很正常的），第二个语句将被阻塞。
- en: This is a serious problem when you need to write high - performance and scalable
    systems. There is another problem that manifests when you are writing programs
    where you need to write interfaces for human interactions like we do on websites
    that run on a browser. While you are performing a task that may take some time,
    you cannot block the user. They may be entering something in an input field while
    the costly task is running; it would be a terrible experience if we block user
    input while we are busy doing a costly operation. In such scenarios, the costly
    tasks need to be run in the background while we can happily take input from the
    user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要编写高性能和可扩展的系统时，这是一个严重的问题。当你编写需要编写用于人类交互的接口的程序时，比如我们在浏览器上运行的网站，也会出现另一个问题。当你执行可能需要一些时间的任务时，你不能阻塞用户。他们可能在输入字段中输入某些内容，而昂贵的任务正在运行；如果我们在我们忙于执行昂贵操作时阻塞用户输入，这将是一个糟糕的体验。在这种情况下，昂贵的任务需要在后台运行，同时我们可以愉快地接收用户的输入。
- en: 'To solve this, one solution is to split each task into its own thread of control.
    This is called the **multi-threaded** or **threaded model**. Consider the following
    figure:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，一个解决方案是将每个任务分割成它自己的控制线程。这被称为**多线程**或**线程模型**。考虑以下图：
- en: '![Promises and Proxies](img/image_09_002.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![承诺和代理](img/image_09_002.jpg)'
- en: The difference is how the tasks are split. In the threaded model, each task
    is performed in its own thread of control. Usually, threads are managed by the
    operating system and can be run in parallel on different CPU cores or on a single
    core with appropriate thread scheduling done by the CPU. With modern CPUs, the
    threaded model can be extremely optimal in performance. Several languages support
    this popular model. Although a popular model, the threaded model can be complex
    to implement in practice. The threads need to communicate and coordinate with
    each other. Inter-thread communication can get tricky very quickly. There are
    variations of the threaded model where the state is immutable. In such cases,
    the model becomes simpler as each thread is responsible for immutable state and
    there is no need to manage state between threads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于任务的分割方式。在线程模型中，每个任务都在自己的控制线程中执行。通常，线程由操作系统管理，可以在不同的CPU核心或单个核心上并行运行，这取决于CPU进行的适当线程调度。在现代CPU中，线程模型在性能上可以非常优化。几种语言支持这种流行的模型。尽管这是一个流行的模型，但在实践中实现线程模型可能会很复杂。线程需要相互通信和协调。线程间的通信可能会很快变得复杂。线程模型有变体，其中状态是不可变的。在这种情况下，模型变得更简单，因为每个线程负责不可变状态，且不需要在线程之间管理状态。
- en: Asynchronous programming model
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程模型
- en: 'The third model is what interests us the most. In this model, tasks are interleaved
    in a single thread of control. Consider the following figure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个模型是我们最感兴趣的。在这个模型中，任务在一个控制线程中交错执行。考虑以下图示：
- en: '![Asynchronous programming model](img/image_09_003.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![异步编程模型](img/image_09_003.jpg)'
- en: The **asynchronous model** is simpler because you have only one thread. When
    you are executing one task, you are sure that only that task is being executed.
    This model doesn't require complex mechanism for inter-thread coordination and,
    hence, is more predictable. There is one more difference between the threaded
    and the asynchronous models; in the threaded model, you don't have a way to control
    the thread execution as the thread scheduling is mostly done by the operating
    system. However, in the asynchronous model, there is no such challenge.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步模型**更简单，因为你只有一个线程。当你执行一个任务时，你可以确信只有那个任务正在执行。这种模型不需要复杂的线程间协调机制，因此更可预测。线程模型和异步模型之间还有一个区别；在线程模型中，你无法控制线程的执行，因为线程调度主要是由操作系统完成的。然而，在异步模型中，没有这样的挑战。'
- en: In which scenarios can the asynchronous model outperform the synchronous model?
    If we are simply splitting tasks into smaller chunks, intuitively, even the smaller
    chunks will take quite an amount of time when you add them up in the end.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪些场景下异步模型能优于同步模型？如果我们只是简单地将任务分割成更小的块，直观上，当你最终将它们加起来时，即使是更小的块也会花费相当多的时间。
- en: 'There is a significant factor we have not yet considered. When you execute
    a task, you will end up waiting on something-a disk read, a database query, or
    a network call; these are blocking operations. When you enter a blocked mode,
    your task simply waits in the synchronous model. Take a look at the following
    figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有考虑的一个显著因素是，当你执行一个任务时，你最终会等待某事——磁盘读取、数据库查询或网络调用；这些都是阻塞操作。当你进入阻塞模式时，在同步模型中，你的任务只是简单地等待。看看以下图示：
- en: '![Asynchronous programming model](img/image_09_004.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![异步编程模型](img/image_09_004.jpg)'
- en: In the preceding diagram, the black blocks are where a task is waiting on something.
    What are the typical operations that can cause such a block? A task is performed
    in a CPU and RAM. A typical CPU and RAM can handle data transfer orders of magnitude
    faster than a typical disc read or a network call.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，黑色块表示任务正在等待某事。什么典型的操作会导致这种阻塞？任务在CPU和RAM中执行。典型的CPU和RAM可以比典型的磁盘读取或网络调用快几个数量级地处理数据传输命令。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please refer to a comparison ([https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832))
    of latencies between CPU, internal memory, and discs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考CPU、内部内存和磁盘之间延迟的比较([https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832))。
- en: When your tasks wait on an **I**/**O** (**Input**/**Output**) from such sources,
    the latency is unpredictable. For a synchronous program that does a lot of I/O,
    this is a recipe for bad performance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的任务等待来自这样的I/O（**输入**/**输出**）源时，延迟是不可预测的。对于执行大量I/O的同步程序，这可能导致性能不佳。
- en: 'The most important difference between the synchronous and asynchronous models
    is the way they handle blocking operations. In the asynchronous model, a program,
    when faced with a task that encounters a block, executes another task without
    waiting for the blocking operation to finish. In a program where there are potential
    blocks, an asynchronous program outperforms an equivalent synchronous program
    because less time is spent on waiting. A slightly inaccurate visualization of
    such a model would be as seen in the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同步模型和异步模型之间最重要的区别是它们处理阻塞操作的方式。在异步模型中，当程序遇到一个阻塞的任务时，它会执行另一个任务，而不等待阻塞操作完成。在一个可能存在阻塞的程序中，异步程序的性能优于等效的同步程序，因为花费在等待上的时间更少。这种模型的略微不准确的可视化可以参考以下图示：
- en: '![Asynchronous programming model](img/image_09_005.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![异步编程模型](img/image_09_005.jpg)'
- en: With this conceptual background of the asynchronous model with us, we can look
    at language - specific constructs to support this model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 带着异步模型的这一概念背景，我们可以查看特定于语言的构造来支持这一模型。
- en: JavaScript call stack
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript调用栈
- en: 'In JavaScript, function calls form a stack of frames. Consider the following
    example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数调用形成一个帧栈。考虑以下示例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we call function `a()`, the first frame in the stack is created with arguments
    to the function and all local variables in the `a()`function. When function `a()`
    calls function `b()`, a second frame is created and pushed to the top of the stack.
    This goes on for all function calls. When the `c()`function returns, the top frame
    from the stack is popped out, leaving functions `b()` and `a()`; this goes on
    until the entire stack is empty. This is necessary to maintain because once the
    function finishes execution, JavaScript will need to know where to return.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数`a()`时，栈中的第一个帧被创建，其中包含传递给函数的参数和`a()`函数中的所有局部变量。当函数`a()`调用函数`b()`时，第二个帧被创建并推送到栈顶。对于所有函数调用都是这样。当`c()`函数返回时，栈顶的帧被弹出，留下函数`b()`和`a()`；这个过程一直持续到整个栈为空。这是必要的，因为一旦函数执行完成，JavaScript需要知道返回的位置。
- en: Message queue
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息队列
- en: The JavaScript runtime contains a message queue. This queue contains the list
    of messages to be processed. These messages are queued in response to events such
    as `click` or an HTTP response received. Each message is associated with a callback
    function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript运行时包含一个消息队列。这个队列包含要处理的邮件列表。这些消息是在响应诸如`click`或接收到的HTTP响应等事件时入队的。每个消息都与一个回调函数相关联。
- en: Event loop
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: A browser tab runs in a single thread-an event loop. This loop continuously
    picks messages from the message queue and executes the callbacks associated with
    them. The event loop simply keeps picking tasks from the message queues while
    other processes add tasks to the message queue. Other processes such as timers
    and event handlers run in parallel and keep adding tasks to the queue.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器标签页在一个单独的线程中运行——一个事件循环。这个循环持续地从消息队列中选取消息并执行与它们关联的回调函数。事件循环简单地从消息队列中选取任务，同时其他进程向消息队列添加任务。其他进程，如计时器和事件处理器，并行运行并持续向队列中添加任务。
- en: Timers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时器
- en: 'The `setTimeout()`method creates a timer and waits until it fires. When the
    timer is executed, a task is added to the message queue. The `setTimeOut()` method
    takes two arguments: a callback, and the duration in milliseconds. After the duration,
    the callback is added to the message queue. Once the callback is added to the
    message queue, the event loop will eventually pick it up and execute it. There
    is, however, no guarantee when the callback will be picked up by the event loop.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`方法创建一个计时器并等待它触发。当计时器执行时，一个任务被添加到消息队列中。`setTimeout()`方法接受两个参数：一个回调函数和以毫秒为单位的持续时间。在持续时间过后，回调函数被添加到消息队列中。一旦回调函数被添加到消息队列中，事件循环最终会选取它并执行。然而，没有保证回调函数何时会被事件循环选取。'
- en: Run to completion
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行至完成
- en: When the event loop picks up a message from the queue, the associated callback
    is run to completion. This means that a message is processed completely before
    the next message from the queue is processed. This property gives the asynchronous
    model a sense of predictability. As there is no intervention to preempt any of
    the messages in between execution, this model is much simpler than other models,
    where any unit of execution can be halted in between. However, once the message
    is picked up, even if the execution takes too long, any other interaction on the
    browser is blocked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件循环从队列中获取一条消息时，将执行相关的回调函数直到完成。这意味着在处理队列中的下一条消息之前，消息会被完全处理。这种特性使得异步模型具有可预测性。由于在执行过程中没有干预来中断任何消息，因此这种模型比其他模型简单得多，在其他模型中，任何执行单元都可能在中间被中断。然而，一旦获取到消息，即使执行时间过长，浏览器上的任何其他交互都将被阻塞。
- en: Events
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'You can register event handlers for an object and receive results of a method
    asynchronously. The following example shows how we can set up event handlers for
    the `XMLHttpRequest` API:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为对象注册事件处理器并异步接收方法的结果。以下示例展示了我们如何为 `XMLHttpRequest` API 设置事件处理器：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding snippet, we are creating the object of the `XMLHttpRequest`
    class. Once the request object is created, we will register event handlers for
    it. Event handlers, such as `onload()`, are triggered asynchronously when the
    response is received from the `open()` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在创建 `XMLHttpRequest` 类的对象。一旦请求对象被创建，我们将为它注册事件处理器。事件处理器，如 `onload()`，在从
    `open()` 方法接收到响应时异步触发。
- en: The `send()` method doesn't actually initiate the request, it adds the request
    to the message queue for the event loop to pick it up and execute necessary callbacks
    associated with it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 方法实际上并不启动请求，它只是将请求添加到事件循环的消息队列中，以便事件循环可以获取它并执行与之相关的必要回调。'
- en: Callbacks
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调
- en: The Node.js application popularized this style of receiving asynchronous data.
    A callback is a function passed as the last argument to the asynchronous function
    call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js应用程序普及了这种接收异步数据的方式。回调是一个函数，作为异步函数调用的最后一个参数传递。
- en: 'To illustrate the usage, let''s use the following example of reading a file
    in Node.js:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明用法，让我们使用以下Node.js中读取文件的示例：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don't worry about a few details here. We are using the filesystem module as
    an `fs` alias. This module has a `readFile` method to read a file asynchronously.
    We will pass the file path and filename as the first argument and a callback function
    as the last argument of the function. We are using an anonymous function as the
    callback in the example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不必担心一些细节。我们正在使用文件系统模块作为 `fs` 别名。此模块有一个 `readFile` 方法用于异步读取文件。我们将文件路径和文件名作为函数的第一个参数，将回调函数作为函数的最后一个参数传递。在示例中，我们使用匿名函数作为回调。
- en: The callback function has two arguments-error and data. When the `readFile()`
    method is successful, the callback function receives `data`, and if it fails,
    the `error` argument will have the error details.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数有两个参数——错误和数据。当 `readFile()` 方法成功时，回调函数接收 `data`，如果失败，`error` 参数将包含错误详情。
- en: 'We can also use a slightly functional style to write the same callback. Consider
    the following example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用稍微函数式的方式来编写相同的回调。考虑以下示例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This style of passing callbacks is also called **continuous-passing style**
    (**CPS**); the next step of execution or continuation is passed as a parameter.
    The following example further illustrates the CPS style of callbacks:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传递回调的方式也被称为**连续传递风格**（**CPS**）；执行的下一步或后续操作作为参数传递。以下示例进一步说明了CPS风格的回调：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will provide the continuation (the next callback) to each step. This nested
    callback style also causes a problem sometimes referred to as callback hell.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个步骤提供后续操作（下一个回调）。这种嵌套回调风格有时也导致被称为回调地狱的问题。
- en: Callbacks and the CPS introduce a radically different style of programming.
    Although it is easier to understand callbacks compared to other constructs, callbacks
    can create slightly difficult to understand code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回调和CPS引入了一种截然不同的编程风格。虽然与其它结构相比，回调更容易理解，但回调可能会创建稍微难以理解的代码。
- en: Promises
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: ES6 introduces promises as an alternate to callbacks. Like callbacks, promises
    are used to retrieve the results of an asynchronous function call. Using promises
    is easier than callbacks and produces more readable code. However, to implement
    promises for your asynchronous functions requires more work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了承诺作为回调的替代方案。像回调一样，承诺用于检索异步函数调用的结果。使用承诺比回调更容易，并且生成的代码更易读。然而，为了为你的异步函数实现承诺需要做更多的工作。
- en: A promise object represents a value that may be available now or in the future,
    or possibly never. As the name suggests, a promise may be fulfilled or rejected.
    A promise acts as a placeholder for the eventual result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺对象代表一个现在可能可用或在将来可能可用，或者可能永远不可用的值。正如其名所示，承诺可能被实现或拒绝。承诺充当最终结果的占位符。
- en: 'A promise has three mutually exclusive states, which are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺有三个互斥的状态，如下所示：
- en: A promise is **pending** before the result is ready; this is the initial state.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果准备好之前，承诺是**挂起**的；这是初始状态。
- en: A promise is **fulfilled** when the result is ready.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当结果准备好时，承诺会被**实现**。
- en: On an error, a promise is **rejected**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现错误时，承诺会被**拒绝**。
- en: When a pending promise is either fulfilled or rejected, associated callbacks/handlers
    that are queued up by the `then()` method of the promise are executed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个挂起的承诺被实现或拒绝时，通过承诺的`then()`方法排队的相关回调/处理程序会被执行。
- en: 'The purpose of promises is to provide a better syntax for the CPS callbacks.
    The typical CPS style asynchronous functions like the following one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的目的是为了提供一个更好的CPS回调语法。以下是一个典型的CPS风格异步函数：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code can be written a bit differently with promises, as shown
    in the following lines of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以用承诺稍微改写一下，如下面的代码行所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The asynchronous function now returns a promise, which is the placeholder for
    an eventual result. Callbacks registered with the `then()` method are notified
    when the result is ready.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数现在返回一个承诺，这是最终结果的占位符。当结果准备好时，通过`then()`方法注册的回调会被通知。
- en: 'You can chain the `then()` method. When the `then()` method sees that the callback
    triggered another asynchronous action that returns a promise, it returns that
    promise. Take a look at the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以链式调用`then()`方法。当`then()`方法看到回调触发了另一个返回承诺的异步操作时，它会返回那个承诺。看看下面的例子：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s see a real example of how we can use promises. We saw a typical example
    of asynchronous file reads in Node.js; now let''s see what that example will look
    like when used with promises. To jog our memories, we wrote something like the
    following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用承诺的一个真实例子。我们看到了Node.js中异步文件读取的典型例子；现在让我们看看当使用承诺时，这个例子会是什么样子。为了唤起我们的记忆，我们写了如下内容：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We see callbacks as continuation here; now let''s see how the same function
    can be written using promises:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回调视为这里的延续；现在让我们看看如何使用承诺来编写相同的函数：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now the callbacks are invoked via the result and methods `then()` and `catch()`.
    The error handling is much cleaner because we are not writing the `if...else`
    and `try...catch` constructs anymore.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回调是通过结果和方法`then()`和`catch()`来调用的。错误处理变得更加清晰，因为我们不再需要编写`if...else`和`try...catch`结构了。
- en: Creating promises
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建承诺
- en: We saw how we can consume promises. Now, let's look at how we can produce them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何消费承诺。现在，让我们看看我们如何产生它们。
- en: 'As a producer, you can create a `Promise` object and send a result via the
    `Promise`. The construct looks like the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为生产者，你可以创建一个`Promise`对象，并通过`Promise`发送一个结果。该结构如下代码片段所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The parameter to `Promise` is an executor function. The executor handles two
    states of the promise, which are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`的参数是一个执行器函数。执行器处理承诺的两个状态，如下所示：'
- en: '**Resolving**: If the result was generated successfully, the executor sends
    the results back via the `resolve()` method. This method usually fulfills the
    `Promise` object.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决**：如果结果成功生成，执行器通过`resolve()`方法发送结果。此方法通常满足`Promise`对象。'
- en: '**Rejecting**: If an error happened, the executor notifies the consumer via
    the `reject()` method. If an exception occurs, it is notified via the `reject()`
    method as well.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝**：如果发生错误，执行器通过`reject()`方法通知消费者。如果发生异常，它也会通过`reject()`方法通知。'
- en: 'As a consumer, you are notified of either fulfillment of promise or rejection
    of promise via the `then()` and `catch()` methods. Consider the following piece
    of code as an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为消费者，你通过`then()`和`catch()`方法被通知承诺的实现或拒绝。以下代码片段作为例子：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have some background on how to produce promises, let''s rewrite
    our earlier example of the asynchronous file''s `read` method to produce promises.
    We will use Node.js''s filesystem module and the `readFile()` method as we did
    last time. If you don''t understand any Node.js specific construct in the following
    snippet, please don''t worry. Consider the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何生成 `Promise`，让我们重写之前异步文件的 `read` 方法示例以生成 `Promise`。我们将使用 Node.js
    的文件系统模块和 `readFile()` 方法，就像上次一样。如果你不理解以下代码片段中的任何 Node.js 特定结构，请不要担心。以下代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding snippet, we are creating a new `Promise` object and returning
    it to the consumer. As we saw earlier, the parameter to the `Promise` object is
    the executor function and the executor function takes care of two states of `Promise`-fulfilled
    and rejected. The executor function takes in two arguments, `resolve` and `reject`.
    These are the functions that notify the state of the `Promise` object to the consumer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在创建一个新的 `Promise` 对象并将其返回给消费者。正如我们之前看到的，`Promise` 对象的参数是执行器函数，执行器函数负责处理
    `Promise` 的两种状态——已解决和被拒绝。执行器函数接受两个参数，`resolve` 和 `reject`。这些函数负责通知消费者 `Promise`
    对象的状态。
- en: Inside the executor function, we will call the actual function-the `readFile()`
    method; if this function is successful, we will return the result using the `resolve()`
    method and if there is an error, we will notify the consumer using the `reject()`
    method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行器函数内部，我们将调用实际函数——`readFile()` 方法；如果这个函数成功，我们将使用 `resolve()` 方法返回结果，如果发生错误，我们将使用
    `reject()` 方法通知消费者。
- en: 'If an error happens in one of the `then()` reactions, they are caught in the
    subsequent `catch()` block. Take a look at the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个 `then()` 反应中发生错误，它们会被后续的 `catch()` 块捕获。看看以下代码：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the `then()` reaction causes an exception or error, and the subsequent
    `catch()` block can handle this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`then()` 反应导致异常或错误，后续的 `catch()` 块可以处理它。
- en: 'Similarly, an exception thrown inside a `then()` or `catch()` handler is passed
    to the next error handler. Consider the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 `then()` 或 `catch()` 处理器内部抛出的异常会被传递给下一个错误处理器。考虑以下代码片段：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Promise.all()
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise.all()
- en: 'One interesting use case is to create an iterable over promises. Let''s assume
    that you have a list of URLs you want to visit and parse the results. You can
    create promises for each of the fetch URL calls and use them individually, or
    you can create an iterator with all the URLs and use the promise in one go. The
    `Promise.all()` method takes the iterable of promises as an argument. When all
    of the promises are fulfilled, an array is filled with their results. Consider
    the following code as an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的使用案例是创建一个遍历 `Promise` 的迭代器。假设你有一系列想要访问和解析的 URL，你可以为每个 `fetch URL` 调用创建
    `Promise`，然后单独使用它们，或者你可以创建一个包含所有 URL 的迭代器，一次性使用这个 `Promise`。`Promise.all()` 方法接受一个
    `Promise` 迭代器作为参数。当所有的 `Promise` 都被解决时，一个数组会被填充它们的返回结果。以下代码作为示例：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Metaprogramming and proxies
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元编程和代理
- en: Metaprogramming refers to a method of programming where the program is aware
    of its structure and can manipulate itself. Many languages have support for metaprogramming
    in the form of macros. Macros are important constructs in functional languages
    such as **LISP** (**Locator/ID Separation Protocol**). In languages such as Java
    and C#, reflection is a form of metaprogramming because a program can examine
    information about itself using reflection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程是指一种编程方法，其中程序了解其结构并可以操纵自身。许多语言通过宏的形式支持元编程。宏是函数式语言（如 **LISP** （**定位器/ID 分离协议**））中的重要结构。在
    Java 和 C# 等语言中，反射是一种元编程形式，因为程序可以使用反射检查有关自身的信息。
- en: 'In JavaScript, you can say that methods of object allow you to examine the
    structure and hence, they offer metaprogramming. There are three types of metaprogramming
    paradigms (*The Art of the Metaobject Protocol,* Kiczales et al, [https://mitpress.mit.edu/books/art-metaobject-protocol](https://mitpress.mit.edu/books/art-metaobject-protocol)):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，可以说对象的方法允许你检查结构，因此它们提供了元编程。有三种元编程范式（*《元对象协议的艺术》，Kiczales 等人，[https://mitpress.mit.edu/books/art-metaobject-protocol](https://mitpress.mit.edu/books/art-metaobject-protocol)）：
- en: '**Introspection**: This gives a read-only access to the internals of a program'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内省**：这提供了对程序内部的只读访问'
- en: '**Self-modification**: This makes structural changes possible to the program'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我修改**：这使得对程序的结构进行更改成为可能'
- en: '**Intercession**: This changes language semantics'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**干预**：这改变了语言语义'
- en: 'The `Object.keys()` method is an example of introspection. In the following
    example, the program is examining its own structure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys()`方法是一个内省的例子。在以下示例中，程序正在检查其自身的结构：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Self-modification is also possible in JavaScript by mutating the properties
    of an object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，也可以通过修改对象的属性来实现自我修改。
- en: However, intercession, or the ability to change language semantics, is something
    not available in JavaScript till ES6\. Proxies are introduced to open up this
    possibility.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，干预，或改变语言语义的能力，在ES6之前在JavaScript中是不可用的。代理的引入是为了打开这种可能性。
- en: Proxy
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: You can use a proxy to determine the behavior of an object, which is called
    the target, whenever its properties are accessed. A proxy is used to define custom
    behavior for basic operations on an object, such as looking up a property, function
    invocation, and assignment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用代理来确定目标对象的行为，目标对象是指当其属性被访问时的对象。代理用于定义对象基本操作上的自定义行为，例如查找属性、函数调用和赋值。
- en: 'A proxy needs two parameters, which are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代理需要两个参数，如下所示：
- en: '**Handler**: For each operation you want to customize, you need a `handler`
    method. This method intercepts the operations and is sometimes called a trap.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理程序**：对于您想要定制的每个操作，您需要一个`handler`方法。这个方法拦截操作，有时也被称为陷阱。'
- en: '**Target**: When the `handler` does not intercept the operation, the `target`
    is used as a fallback.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：当`handler`没有拦截操作时，使用`target`作为后备。'
- en: 'Let''s take a look at the following example to understand this concept better:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，以更好地理解这个概念：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we are trapping the operation of getting a property from the
    object. We return `42` as a default property value if the property does not exist.
    We are using the `get` handler to trap this operation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在捕获从对象中获取属性的操作。如果属性不存在，我们返回`42`作为默认属性值。我们使用`get`处理程序来捕获这个操作。
- en: 'You can use proxies to validate values before setting them on an object. For
    this, we can trap the `set` handler as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用代理在将值设置到对象上之前验证这些值。为此，我们可以如下捕获`set`处理程序：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we are trapping the `set` handler. When we set a property
    of the object, we are trapping that operation and introducing validation of values.
    If the value is valid, we will set the property.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在捕获`set`处理程序。当我们设置对象的属性时，我们正在捕获这个操作并引入值的验证。如果值有效，我们将设置属性。
- en: Function traps
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数陷阱
- en: 'There are two operations that can be trapped if the target is a function: `apply`
    and `construct`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是函数，有两种操作可以被捕获：`apply`和`construct`。
- en: To intercept function calls, you will need to trap the `get` and `apply` operations.
    First get the function and then apply to call the function. So, you `get` the
    function and return the function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截函数调用，您需要捕获`get`和`apply`操作。首先获取函数，然后应用以调用函数。所以，您`get`函数并返回函数。
- en: 'Let''s consider the following example to understand how method interception
    works:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例，以了解方法拦截是如何工作的：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we are trapping the `get` operation. If the type of
    the property being `get` is a function, we will use `apply` to invoke that function.
    If you see the output, we are getting two `console.logs`; the first is from the
    proxy where we trapped the `get` operation and the second is from the actual method
    call.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在捕获`get`操作。如果正在`get`的属性的类型是函数，我们将使用`apply`来调用该函数。如果您看到输出，我们会得到两个`console.logs`；第一个是从捕获`get`操作的代理那里来的，第二个是从实际方法调用那里来的。
- en: Metaprogramming is an interesting construct to use. However, any kind of introspection
    or reflection comes at the cost of performance. Care should be taken while using
    proxies as they can be slow.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程是一个有趣的构造，可以使用。然而，任何类型的内省或反射都会以性能为代价。在使用代理时要小心，因为它们可能会很慢。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked at two important concepts. ES6 proxies are useful
    meta programming constructs used to define custom behavior for fundamental operations
    (for example, property lookup, assignment, enumeration, function invocation, and
    so on). We looked at how to use handlers, traps, and proxy targets to intercept
    and modify the default behavior of operations. This gives us very powerful meta
    programming capabilities earlier lacking in JavaScript.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们探讨了两个重要概念。ES6 代理是用于定义基本操作（例如，属性查找、赋值、枚举、函数调用等）自定义行为的元编程结构。我们探讨了如何使用处理程序（handlers）、陷阱（traps）和代理目标（proxy
    targets）来拦截和修改操作的默认行为。这为我们提供了在 JavaScript 中早期缺乏的非常强大的元编程能力。
- en: The other important construct we discussed in this chapter was ES6 promises.
    Promises are important because they make asynchronous programming constructs easier
    to work with. A promise acts as a proxy for a value not necessarily known when
    the promise is created. This lets asynchronous methods return values like synchronous
    methods - instead of the final value, the asynchronous method returns a promise
    for the value at some point in the future.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的另一个重要构造是 ES6 的承诺（promises）。承诺之所以重要，是因为它们使得异步编程结构更容易处理。承诺充当了一个代理，用于一个在承诺创建时可能未知的价值。这使得异步方法可以像同步方法一样返回值——而不是最终值，异步方法返回的是未来某个时刻该值的承诺。
- en: These are two very powerful constructs in ES6 that greatly enhance the language's
    core capabilities.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 ES6 中两个非常强大的构造，极大地增强了语言的核心功能。
- en: In the next chapter, we will look at the fascinating possibilities around browsers
    and DOM manipulation using JavaScript.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用 JavaScript 在浏览器和 DOM 操作方面的迷人可能性。
