- en: Chapter 12. Authentication in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application we have built so far allows users to choose a username to identify
    themselves. However, they only retain this identity for the duration of their
    browser session. It's important to allow users to retain a consistent identity
    from one session to the next. This allows us to build richer user experiences.
    Some websites (such as Facebook) couldn't offer their main functionality at all
    without being able to identify users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifying users requires us to implement authentication. In this chapter,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing third-party authentication via social networking sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating third-party identities with our own user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating user authentication to support integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Passport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passport is an authentication framework for Node.js. It can act as Express middleware,
    making it easy to integrate with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Like some of the other libraries we've discussed so far, Passport is very modular.
    Its core package provides a common paradigm for authentication. Passport's middleware
    performs authentication and augments the request object with a `user` property.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Passport npm packages support hundreds of different **strategies**
    for authentication. Each Passport strategy provides a different mechanism for
    identifying users. We'll look at a few of these strategies in this chapter. Passport
    makes it easy to add new strategies to suit the needs of each application.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an authentication strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common introductory example is username/password-based authentication. This
    uses a login form to verify users' credentials against the application's database.
    Although this is one of the simplest authentication mechanisms to understand,
    it's not the most useful. Forcing users to create an account for our site is an
    extra hurdle to them using it. Users also get tired of creating an account and
    picking a password for every new website.
  prefs: []
  type: TYPE_NORMAL
- en: Passport does support this kind of authentication, via the `passport-local`
    strategy. We'll make use of this strategy for test purposes later on in this chapter,
    but not in our production code. It's better to allow users to authenticate using
    an identity already established elsewhere. This saves users from having to pick
    new credentials and also saves our website from having to manage these. This is
    just good separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: If you log in to StackOverflow, you'll notice that it suggests logging in using
    Google+ or Facebook. It also supports OpenID and other providers. Implementing
    support for each of these login mechanisms from scratch would be a lot of work.
    Fortunately there are Passport strategies for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding third-party authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passport will do most of the heavy lifting for us, but it's still worth having
    a basic understanding of how third-party authentication works. When a client wants
    to log into a website, it sends them to a third-party provider. The third-party
    provider gives the client back a token they can use to authenticate with the website.
    When the client is a web browser, this process can be made almost invisible to
    the user, via automatic redirects.
  prefs: []
  type: TYPE_NORMAL
- en: The website must then verify that the token presented to it by the client really
    came from the third-party provider. The website and the third-party provider might
    have established a pre-shared key for this purpose, which could be used to create
    a cryptographically verifiable token. Alternatively, the website might call the
    third-party provider directly to verify the token. In practice, a website will
    often want to call a third-party provider anyway to gain more information associated
    with the user's identity, for example, their username or other profile information.
  prefs: []
  type: TYPE_NORMAL
- en: Using Express sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many of Passport''s strategies are based on HTTP sessions. At the moment, our
    application is just using simple cookies to store user IDs. To use Passport for
    third-party authentication, we''ll need to add session support into our application.
    Express provides session support in the `express-session` module. First, we add
    this to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need somewhere to store session data. Express supports a variety of
    session stores via additional modules. Redis is well suited to this task and we
    already have a Redis instance available. We can use the `connect-redis` module
    to store sessions in Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a new configuration module to keep all our session logic
    in one place. Since this will return middleware, we''ll put it in the `middleware`
    folder here `src/middleware/sessions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We configure the Express `session` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the value of an environment variable as the session secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only save sessions that contain some data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not resave sessions unless they have changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Redis is available, use it as the session store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider each of the configuration properties in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a session secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Express uses a session secret to protect session data from being tampering
    with. You should specify this by setting the `SESSION_SECRET` environment variable
    locally. The value is arbitrary and can be anything, as long as it''s not empty.
    We also need to specify this in our integration test so it can run on the CI server.
    The following code is from `gulpfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Deciding when the session gets saved
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Avoiding unnecessary saves is a minor optimization and can avoid certain race
    conditions. Only saving initialized sessions allows you to request user consent
    before storing any cookies. This might be necessary for compliance with regional
    laws, most notably in the EU. See [https://www.cookiechoices.org/](https://www.cookiechoices.org/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Using alternative session stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Express will use an in-memory session store. This is fine for development
    purposes and in test environments where we only have one application process,
    but is not suitable for production use. Storing sessions out of process in Redis
    is important if we want to scale across multiple instances. We configure the Redis
    store with our existing Redis URL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, you might want to use different Redis instances for session data
    and other application data. These are quite different use cases, so they might
    benefit from a different configuration of Redis. For example, session data is
    likely to be higher load, but can afford to be more volatile. For small-scale
    applications such as our example application in this book, a single Redis instance
    will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Using session middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now use sessions elsewhere in our application instead of directly setting
    cookies. The following code is from `src/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `src/middleware/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `src/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Implementing social login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our first example, we'll use Twitter as our third-party authentication provider.
    If you want to follow along with the example you will need a Twitter account,
    which is very quick to set up.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Twitter application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for Twitter to recognize our application, we need to create a new
    app in Twitter''s developer portal:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://apps.twitter.com/](https://apps.twitter.com/) and click on **Create
    New App**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the Name, Description, Website, and Callback URL fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've deployed your application to Heroku, you can use its Heroku URL here
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, just fill in placeholder values for both fields (for example, `http://test.example.com/callback`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Create your Twitter application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Settings** tab and ensure that **Enable Callback Locking** is
    unchecked (leaving this unchecked allows you to use placeholder values for the
    URLs and is also useful for local testing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Keys and Access Tokens** tab to view your application's **Consumer
    Key (API Key)** and **Consumer Secret (API Secret)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set new local environment variables named `TWITTER_API_KEY` and `TWITTER_API_SECRET`,
    containing the corresponding values from Twitter. You might want to create a shell
    script or batch file to set these in the console or configure them as Heroku environment
    variables (see [Chapter 11](part0066.xhtml#aid-1UU542 "Chapter 11. Deploying Node.js
    Applications"), *Deploying Node.js Applications*)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Passport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll now make use of Passport to allow users to log into our site via Twitter.
    First, we need to install the relevant npm packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can configure Passport to authenticate with Twitter. We add the following
    code under `src/config/passport.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `TwitterStrategy` for authentication with Twitter, passing in
    our API key and secret on a configuration object. The second constructor parameter
    is a function that Passport will invoke after authenticating with Twitter (referred
    to as the **verify callback** in Passport's documentation). Here we set the current
    user's name based on the `profile.username` or `profile.displayName` provided
    from Twitter by Passport.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `profile` object contains the user profile returned by the authentication
    provider. Passport standardizes profile data to make it easier to work with multiple
    strategies. There's a standard set of fields, such as `displayName`, which all
    Passport strategies will populate if possible. We'd prefer to use the Twitter
    username (for example, hgcummings) than the display name (for example, Harry Cummings).
    The `profile.username` field contains the Twitter username. This is not one of
    the standard fields, but many strategies will return a field with this name. So
    we use `profile.username` first, but fall back to the more standard `profile.displayName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to make use of our new passport module in Express. The following
    code is from `src/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells our application to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Passport's Express middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate users via Twitter when they POST to `/auth/twitter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle Twitter authentication results at `/auth/twitter/callback` before redirecting
    users to the homepage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we need to provide a login button to reach our new endpoint as shown
    here in `src/views/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application and click **Log in using Twitter**, the following
    will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The application will redirect your browser to Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter will prompt you to log in if you have not already
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter will ask whether you're happy with the application seeing your profile
    details and other public data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter will then redirect your browser to the `/auth/twitter/callback` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your browser will make a request to this endpoint with your authentication token
    from Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passport will validate this token then invoke our login handler function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When our function completes, Passport will return a redirect response to the
    homepage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now integrated Twitter authentication with our application! However,
    we're not really using it to allow users to log in. We're just associating a Twitter
    username with our existing user IDs created for each session. You can see this
    by opening up two separate browser sessions. Try logging in with each of them.
    If you create a new game in one browser, it appears in the other browser in the
    list of games created by other users. This is because you now have two user IDs
    associated with the same Twitter username.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to recognize the same user whenever they log in with the same Twitter
    account. This should not depend on being in the same browser session. To address
    this, we''ll need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Persist user accounts to our database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tell Passport how to store and retrieve users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let Passport associate a user with the current session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting user data with Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already use Redis to associate usernames with user IDs. Now we want to be
    able to associate user IDs with Twitter accounts as well. The first time a user
    logs in with an external provider, we want to create a new user with the name
    taken from the external profile. Subsequent requests authenticated with the same
    provider will see the same user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this functionality using Redis''s `SETNX` operation. This
    will only set a key if it does not already exist and return whether this was the
    case. Our implementation is as follows from `src/services/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new user ID and tell Redis to associate it with the external
    provider (for example, Twitter) account. If we have seen the external account
    before, we return the user that was already associated with it. Otherwise, we
    persist a new user ID and associate it with the username from the external profile.
    Tests for this functionality can be found in the companion code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Passport with persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a way of persisting users, we need to tell Passport how to
    make use of this. First, we update our verify callback to make use of our new
    `getOrCreate` function rather than just setting a username. Then we need to tell
    Passport how to identify and retrieve users associated with a session by serializing
    users to and from a string.The following code is from `src/config/passport.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Passport stores the string version of the user (returned by our `serializeUser`
    callback) on the session. It uses our `deserializeUser` callback to turn this
    string into a user object which it adds to the request. In our case, the string
    representation of the user is just their ID and deserialization is just a lookup
    in the users service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this to work, we also need to tell our application to use Passport''s
    own session middleware, which works together with Express sessions. To avoid repetition,
    we''ll specify all of our session-related middleware in our session middleware
    module. The following is the code from `src/middleware/sessions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This module now returns three middleware instances. We want to use this with
    both Express and Socket.IO. The first of these is simple, since we can pass multiple
    middleware objects to the Express `app.use` function as here `src/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For Socket.IO, we need to adapt each middleware in turn as here `src/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in both cases, our users middleware is no longer needed and can now
    be deleted. However, this middleware previously ensured that there was always
    a user object on the request. This will now only be the case when there is a logged
    in user, so we need to update the rest of our application accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few places in our application that assume there will always be
    a user on the request. Since this is no longer guaranteed, there are two ways
    to resolve this: we can update our code to cope with no user being present on
    the request or we can hide functionality from unauthenticated users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We still want unauthenticated users to be able to view public chat and to see
    and play games, so we update this functionality accordingly. The code from `src/realtime/chat.js`
    is updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `src/realtime/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `src/routes/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Hiding functionality from unauthenticated users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We certainly want unauthenticated users to be able to visit the home page of
    our application, but might not want to display all of the application''s functionality
    to them. To achieve this, we''ll update our index route as follows from `src/routes/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this adds a `loggedIn` property to the view data instead of the user
    ID. The value of this property comes from the `isAuthenticated` function, which
    is added to the request by Passport. We use this to hide features that will no
    longer work for unauthenticated users and hide the login button from authenticated
    users. The following code is from `src/views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Integration testing with Passport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We still have one problem, which is that our integration tests won't work anymore.
    Only logged-in users can create games now. It would be a good idea to write a
    new integration test to check that Twitter authentication works. We don't want
    to introduce a Twitter account dependency to our current test though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we''ll make use of the passport-local strategy to allow our test to
    log in. We''ll install this as a dev dependency so it can''t accidentally run
    in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We configure Passport to accept any username and password. If using passport-local
    for real, this is where you would check against credentials in your data store.
    The following code is from `src/config/passport.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add a new local authentication endpoint to our application as here
    `src/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally update our test to login as a first step as code from `integration-test/game.js`
    shown follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Allowing users to log out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users will also expect us to provide a way to log out of our application. Passport
    makes this easy by adding a `logout` function to the request. We just need to
    make use of this in one of our routes here `src/routes/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a log out button to our view to make use of this new route as in
    `src/views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Adding other login providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the general infrastructure for authentication, adding
    additional providers is easy. Let''s add Facebook authentication as an example.
    First, we need to install the relevant Passport strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can update our Passport config file from `src/config/passport.js` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here we've generalized our verify callback function to take different provider
    names, then used this with both Twitter and Facebook authentication strategies.
    We can re-use this to add further strategies in the same way. We just need to
    set the relevant environment variables for them to work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To obtain a Facebook App ID and Secret, create a new Facebook application at
    [https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)
    (which requires you to have a Facebook account). This is very similar to the process
    for Twitter. Just create a new application of type Website, with a URL that matches
    your development environment (for example, `http://localhost:3000`). Once created,
    the App ID and App Secret will be visible on the Dashboard page for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add Facebook authentication routes to our application config
    file. These are just the same as the corresponding Twitter routes. As with the
    Passport `config` file, we can commonize by parameterizing the provider name.
    The code from `src/app.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a button to allow users to log in with Facebook. The
    following code is from `src/views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding additional providers is easy. To add Google+ authentication, we would
    just need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `passport-google npm` module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new application as described at [https://developers.google.com/identity/protocols/OpenIDConnect](https://developers.google.com/identity/protocols/OpenIDConnect)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the three files listed above, passing the Google provider to our new
    common functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have added authentication to our Express application using
    Passport, introduced Express sessions using Redis for session storage, leveraged
    multiple Passport strategies to support different external providers, and persisted
    user data in Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our example web application. In the next chapter we will look
    at how to create different kinds of Node.js project: a library and a command-line
    tool.'
  prefs: []
  type: TYPE_NORMAL
