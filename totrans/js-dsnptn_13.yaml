- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asset Loading Strategies and Executing Code off the Main Thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations in the life cycle of an application where loading more
    JavaScript is inevitable. This chapter details techniques to mitigate the impact
    of such situations. You’ll learn about asset loading optimizations such as a script
    element’s `async`, the `defer` attribute, the impact of `type="module"`, and the
    link element’s `rel` (relationship) attribute’s `preconnect`, `preload`, and `prefetch`
    values. Next, you will further optimize script loading using Next.js’ `Script`
    component and its different options. The chapter wraps up with an exploration
    of reasons to execute JavaScript code off the main thread and an approach to do
    so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to control asset loading more granularly with a script’s **async** and **defer**
    attributes, and links with **preconnect**, **preload**, and **prefetch**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further optimization opportunities in Next.js using the **Script** component
    and its **strategy** prop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When and how to run code off the main thread via Next.js and Partytown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have the skills to exert more control over
    asset loading and JavaScript loading and execution in a web context.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  prefs: []
  type: TYPE_NORMAL
- en: Asset loading optimization – async, defer, preconnect, preload, and prefetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `script` to load and execute JavaScript, there are HTML attributes
    of `script` we can use to control the loading and execution.
  prefs: []
  type: TYPE_NORMAL
- en: We can rely on the difference between external scripts and inline scripts; we
    can also use the `async`, `defer`, and `type="module"` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by defining external and inline scripts, then the `async` and `defer`
    attributes. Finally, we’ll look at `type="module"` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'External scripts use the `src` attribute to point to a separate JavaScript
    file; for example, what follows is an external script that will load and evaluate
    `./script.js` when it’s encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<script src="img/script.js"></script>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with inline scripts, where there is no `src` attribute; instead,
    the JavaScript code is in the `script` tag contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The default load/execution cycle of scripts is what we call `script` tag’s JavaScript
    to complete execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `async` and `defer` attributes on the `script` HTML tag can change the behavior
    of loading and executing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding `async` to a script will mean it’s fetched while the rest of the HTML
    document is parsed. An `async` script will be evaluated as soon as it’s loaded.
    This is a large change to the default document parsing behavior of `script`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have an `async.js` file that inserts a paragraph with the text `async.js:
    async` `script executed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we also have a `script.js` file that also inserts a paragraph with `script.js:
    blocking` `script executed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, say we have a document that has inline script snippets that also add
    paragraphs to track their execution before and after two additional `script` tags.
    One script loads `async.js` with an `async` attribute on the script, and the second
    script loads the `script.js` element using the default render-blocking load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is displayed as follows in a browser when loaded with an empty cache:
    the inline script 1 executes first, then `script.js`, then inline script 2, and
    finally `async.js`. Note how `async.js` was in the document *before* `script.js`
    but executed after; that’s the effect of the `async` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Inline scripts, external script, and external script with async
    execution order](img/B19109_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Inline scripts, external script, and external script with async
    execution order'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see how `defer` affects the loading of a script.
  prefs: []
  type: TYPE_NORMAL
- en: '`defer` indicates to the browser that the script should only be loaded *after*
    the document has been parsed. However, the `DOMContentLoaded` event will not fire
    until all scripts with the `defer` attribute are loaded and executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we add a `defer.js` file that will insert a paragraph with `defer.js: defer
    script executed`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we extend the HTML document from the previous `async` example by adding
    `<script src="img/defer.js" defer></script>` before `<script src="img/async.js"
    async></script>`. This will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we load this document in a browser, we see the following output where the
    deferred script adds its paragraph after all the other ones despite being *before*
    the `async.js`, `script.js`, and inline script 2 in the parse order of the document.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Inline scripts, external script, external script with async,
    and external script with the defer execution order](img/B19109_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Inline scripts, external script, external script with async, and
    external script with the defer execution order'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see how “module” and “classic” scripts are affected differently
    by `async` and `defer`.
  prefs: []
  type: TYPE_NORMAL
- en: When a script receives the type of attribute with the `module` value, that script
    will get interpreted as a JavaScript module. We’ll call these “module” scripts,
    as opposed to “classic” scripts, which don’t have a type of attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`type="module"` defers the execution of the script. This means that “module”
    scripts aren’t affected by the `defer` attribute (since that behavior is applied
    to their execution by default).'
  prefs: []
  type: TYPE_NORMAL
- en: The `async` attribute overall has a similar effect on “module” scripts as it
    does on “classic” scripts, in that the script will be loaded in parallel to document
    parsing and executed once loading has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: One additional effect of the `async` attribute on “module” scripts is that since
    JavaScript modules have syntax to denote dependency loading, the module script
    itself, and once loaded, all the dependencies it loads via the `import` syntax,
    will be loaded in parallel to the document parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have the following `module.js`, which inserts `module.js: type="module"
    executed` when it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we also have the following `module-async.js`, which inserts `module-async.js:
    type="module" async executed` when it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We add script tags with `type="module"` with an inline module that inserts
    `inline: type="module" executed`, and module scripts referencing `module.js` and
    `module-async.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we load this document in the browser, we see the following. This illustrates
    that the default load/execution of `type="module"` is deferred since even the
    inline module script executes after `async` scripts. One point of interest is
    that `async` on module scripts can make it execute earlier than scripts without
    `async`. This makes sense since `async` means there’s parallel loading and execution
    is “as soon as available,” as opposed to the module script’s default execution
    method, which is `defer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Inline scripts, external script, external script with async,
    external script with the defer execution order, inline module script, and external
    module scripts with async and without](img/B19109_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Inline scripts, external script, external script with async, external
    script with the defer execution order, inline module script, and external module
    scripts with async and without'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now contrasted different characteristics of script load/execution: inline
    versus external, the impact of `async` and `defer` attributes, and classic versus
    module. The following diagram recapitulates the execution order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Script load/execute order versus browser document parsing](img/B19109_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Script load/execute order versus browser document parsing'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to improve page performance by adapting how JavaScript is
    loaded and executed. Next, we’ll learn how to use resource hints to improve page
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Resource hints, per the HTML specification, allow consumers to preemptively
    complete an operation. They’re used as `rel` values on link elements. The values
    relevant to our use case are `preconnect`, `prefetch`, and `preload`.
  prefs: []
  type: TYPE_NORMAL
- en: '`preconnect`’s definition per the HTML standard is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '“`preconnect`: Specifies that the user agent should preemptively connect to
    the target resource’s origin”, HTML standard – 4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `preconnect` allows developers to “tell” browsers to create a connection
    to an origin, enabling subsequent requests to the origin to occur faster, especially
    in an HTTP/2 context where more requests can be done in parallel (via multiplexing)
    and connections are efficiently reused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `preload`’s definition per the HTML specification is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '“`preload`: Specifies that the user agent must preemptively fetch and cache
    the target resource for current navigation according to the potential destination
    given by the as attribute (and the priority associated with the corresponding
    destination).” HTML standard – 4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  prefs: []
  type: TYPE_NORMAL
- en: '`preload` can be used to load resources before they’re detected on the page.
    This can be especially useful in single-page applications or other highly dynamic
    JavaScript-driven contexts where resources might not be in the initial returned
    HTML payload, but we know which resources might be necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `preload` requires a fully qualified resource path (e.g., [https://example.com/assets/resource-1.js](https://example.com/assets/resource-1.js)),
    as opposed to `preconnect`, which uses the origin only. Also, note that `preload`
    is not designed for use on module scripts; for that, we need `rel="modulepreload"`,
    which is defined as follows in the HTML standard specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '“`modulepreload`: Specifies that the user agent must preemptively fetch the
    module script and store it in the document’s module map for later evaluation.
    Optionally, the module’s dependencies can be fetched as well.” HTML standard –
    4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our current example, we could request pre-loading of some of our `async`
    resources ahead of time (before they’re “seen” by the browser in the HTML), where
    our resource loading looks as follows by default. The load order is defined by
    the order of the script tags in the HTML element and the priority for all resources
    is `Normal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Page load including the Network tab without any preload](img/B19109_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Page load including the Network tab without any preload'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate preload, we can add a `preload` link for `async.js` and a `modulepreload`
    link for `module-async.js` inside the HTML `head` element like in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we reload our example page, we’ll see that `async.js` and `module-async.js`
    are now loaded with `Highest` priority, and before the rest of the scripts on
    the page. Also note that due to the `async` attribute being loaded earlier, the
    scripts are executed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Page load including Network tab with async.js having preload
    and module-async.js having modulepreload](img/B19109_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Page load including Network tab with async.js having preload and
    module-async.js having modulepreload'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `prefetch` is defined as follows in the HTML specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '“`prefetch`: Specifies that the user agent should preemptively fetch and cache
    the target resource as it is likely to be required for a follow-up navigation”
    HTML standard – 4.6.7 link types: [https://html.spec.whatwg.org/#linkTypes](https://html.spec.whatwg.org/#linkTypes)'
  prefs: []
  type: TYPE_NORMAL
- en: This means that `prefetch` will not only connect (like `preconnect` does), but
    do a full load and cache cycle. `prefetch` is useful for when resources will be
    necessary on the next load as opposed to for the current page (which is where
    `preload` and `modulepreload` should be used).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to optimize asset loading via the `async` and `defer` attributes
    on `script` elements and via `preconnect`, `preload`, and `prefetch` on `link`
    elements. Next, we’ll look at how the Next.js `Script` component’s `strategy`
    can be used to achieve similar results in a Next.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Next.js Script’s strategy option to optimize asset loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Next.js `Script` component gives us more control over script loading behavior,
    allowing us to improve page load performance.
  prefs: []
  type: TYPE_NORMAL
- en: The `strategy` prop allows us to control the loading strategy; it defaults to
    `afterInteractive`, which will begin loading after some of the Next.js code has
    run. It can be set to `beforeInteractive`, in which case the script is loaded
    and executed before all Next.js code. `lazyOnLoad` can be used for lower-priority
    scripts to delay loading until there’s browser idle time.
  prefs: []
  type: TYPE_NORMAL
- en: The final option is experimental; it’s the `worker` strategy, which will load
    and run the script in a web worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Per the Next.js docs for the `Script#strategy` option, the following list contains
    the loading strategies of the script (see the docs: [https://nextjs.org/docs/pages/api-reference/components/script#strategy](https://nextjs.org/docs/pages/api-reference/components/script#strategy)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different strategies that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**beforeInteractive**: Load before any Next.js code and before any page hydration
    occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**afterInteractive** (default): Load early but after some hydration on the
    page occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lazyOnload**: Load during browser idle time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**worker** (experimental): Load in a web worker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the benefits of the `Script` component over the `script` native element
    is that the loading strategy can be used even on inline scripts. For example,
    say we have a `pages/index.js` page in a Next.js application; we add some `Script`
    components with two approaches to adding inline scripts. We set the latter `Script`
    to use `beforeInteractive`, remembering that the default strategy is `afterInteractive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the Next.js server with `npx next dev` or `npx next build && npx
    next start`, we see that `inline script 2` is printed in the console before `inline
    script 1` is; this is the `Script` strategies being applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: Second inline Script logging to the console before the first
    due to the strategy of each Script](img/B19109_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Second inline Script logging to the console before the first due
    to the strategy of each Script'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now showcase how we can use the loading strategy with external scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have `public/afterInteractive.js`, which contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**console.log(''afterInteractive.js: loaded'');**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `public/beforeInteractive.js` and `public/lazyOnload.js` contain
    a `console.log` function call with the relevant content, `beforeInteractive.js:
    loaded` and `lazyOnload.js:` `loaded` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load them using the following changes to `pages/index.js`; note that
    we’ve put them in a rough “reverse” order of loading to showcase the effect of
    `strategy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the Next.js server with `npx next dev` or `npx next build && npx
    next start`, we see that `beforeInteractive` is printed on the console before
    `afterInteractive`, which is printed before `lazyOnLoad`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: Script’s logging in order based on strategy](img/B19109_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Script’s logging in order based on strategy'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how Next.js `Script` and its `strategy` prop allow us to control
    script asset loading in a Next.js context to achieve additional page load performance.
    Next, we’ll cover how to run scripts in a worker thread.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and running scripts in a worker thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the Next.js `Script` strategy options is `worker`, which loads and runs
    the script in a web worker. In current Next.js versions, this is achieved via
    a library called **Partytown** ([https://partytown.builder.io/](https://partytown.builder.io/)).
    The following is from the Partytown documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: “Partytown is a lazy-loaded library to help relocate resource-intensive scripts
    into a web worker, and off of the main thread. Its goal is to help speed up sites
    by dedicating the main thread to your code, and offloading third-party scripts
    to a web worker.” Partytown home page – [https://partytown.builder.io/](https://partytown.builder.io/)
  prefs: []
  type: TYPE_NORMAL
- en: To expand on that definition, JavaScript runs in a single-threaded environment
    in the browser. “Single-threaded” means we only have one entity able to execute
    compute operations; non-asynchronous work cannot be done in parallel. The main
    thread in this context is the browser’s JavaScript execution thread. When loading
    and executing compute-heavy scripts, they can starve other scripts of the execution
    environment. By running said compute-heavy scripts in a web worker, it gets a
    different JavaScript environment or execution thread, meaning the main thread
    is freed up to service the rest of the JavaScript execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `strategy="worker"` for Next.js `Script` is experimental, in order to
    use it, we need to enable it in `next.config.js` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When running `npx run dev`, you’ll see a warning about the `nextScriptWorkers`
    experimental feature in the terminal in which you’re running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate how we can use `strategy="worker"` powered by Partytown, we can
    write an `analytics.js` script that will log on, load, and make an API call to
    `jsonplaceholder` with some information about the page. We store `analytics.js`
    in `public/analytics.js` to simulate a third-party script being loaded (or more
    generally, a dependency that cannot be bundled, i.e., one we can’t import into
    our application code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a new `pages/worker.js` file in our Next.js application,
    which renders a heading and a few Next.js scripts, including `/analytics.js`.
    The other scripts are to illustrate the load order of the `worker` strategy versus
    alternative strategy values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we load `npx next build && npx next start`, the production server starts,
    and with the `strategy="worker"` loads after all the other strategies. We also
    see that the `fetch()` call to `jsonplaceholder` completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: worker strategy loading after other strategies and fetch call
    response logging](img/B19109_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: worker strategy loading after other strategies and fetch call
    response logging'
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of loading via the `worker` strategy is that `analytics.js` is
    not loaded as a script; it’s loaded via `fetch`. This can be seen by inspecting
    the `XMLHttpRequest`, the precursor to `fetch`) and inspecting the `jsonplaceholder`
    request appears here (as two requests, an `OPTIONS` request to ensure we can make
    the cross-origin request followed by the `POST` request).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder](img/B19109_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder'
  prefs: []
  type: TYPE_NORMAL
- en: If we dig into the `analytics.js` request further, we’ll see that the `Referer`
    header value (which helps us keep track of the source of the request) is `_next/static/~partytown/partytown-sandbox-sw.html`,
    which is a Partytown-generated document.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: analytics.js Referer is the Partytown service worker-generated
    HTML file](img/B19109_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: analytics.js Referer is the Partytown service worker-generated
    HTML file'
  prefs: []
  type: TYPE_NORMAL
- en: In short, using `strategy="worker"` loads and executes our script in a different
    JavaScript context to the main window, although Partytown is designed so that
    it should have a high level of similarity with the origin window.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to use `strategy="worker"` and Partytown to execute scripts
    off the main thread in a web worker context.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve covered techniques to control asset and JavaScript loading
    more granularly.
  prefs: []
  type: TYPE_NORMAL
- en: In order to control script loading using browser built-in functionality, we
    can use `async` and `defer` attributes; we covered their effect on module scripts
    versus classic scripts. We also looked at using the `rel` attribute on a `link`
    element for resource hints, and what impact `preconnect`, `preload`, `modulepreload`,
    and `prefetch` have on resource loading.
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage the Next.js `Script` component’s `strategy` prop to control
    script loading and execution beyond `async` and `defer` in the context of a Next.js
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the possibility of running certain scripts off the main
    JavaScript thread using the Next.js `Script` `worker` strategy, powered by the
    Partytown library.
  prefs: []
  type: TYPE_NORMAL
- en: In this final chapter, we covered asset loading strategies and optimizations
    such as executing code off the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of this book. Hopefully, you’ve achieved a better
    understanding of design patterns in JavaScript and how to implement them. You
    will be able to discuss and contrast implementations and the usefulness of language-agnostic
    patterns that fall into the creational, structural, and behavioral design pattern
    categories. In addition, you should be confident with JavaScript-specific patterns
    that will help you scale your applications, reactive view library patterns, rendering
    strategies, and asynchronous and event-driven programming patterns in JavaScript.
    Furthermore, you are now familiar with performance and architecture patterns relevant
    to JavaScript such as micro frontends, lazy-loading, code-splitting, and further
    asset loading optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all these patterns are meant to be used and you will discover new
    ways to compose them and even notice them in places you didn’t expect. The JavaScript
    and web platform space is ever-evolving, and I hope this book stands you in good
    stead for using more of its great features.
  prefs: []
  type: TYPE_NORMAL
