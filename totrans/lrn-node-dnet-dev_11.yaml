- en: Chapter 11. Deploying Node.js Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only run our application in our local development environment.
    In this chapter, we will deploy it to the Web. There are many different options
    for hosting an application. We will work through one deployment option to quickly
    get an application up and running. We will also discuss broader principles and
    alternative options for deploying Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying our application to the Web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using application logs to diagnose issues on remote servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up database servers and environmental configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying automatically from Travis CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to follow along with this chapter, you can use the code from [https://github.com/NodeJsForDevelopers/chapter10/](https://github.com/NodeJsForDevelopers/chapter10/)
    as a starting point. This contains the example code from the end of [Chapter 10](part0058.xhtml#aid-1NA0K1
    "Chapter 10. Creating Real-time Web Apps"), *Creating Real-time Web Apps*, which
    we will build on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Heroku** is a cloud-based platform for web applications. It aims to allow
    developers to focus on applications rather than infrastructure. It provides a
    low-friction workflow for deploying a new application quickly, while also supporting
    long-term scalability. It also offers a marketplace of add-on services, such as
    databases and monitoring.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several similar services to Heroku, some of which we will cover later
    in this chapter. Heroku was one of the first services of its kind. In particular,
    it was one of the first to support Node.js as a first-class citizen. It also offers
    many features for free, including everything needed for the worked example in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Heroku's free features are sufficient for deploying an application
    for development, demonstration, or experimental purposes. It would not be sufficient
    for a production deployment of an application serving end users. See [https://www.heroku.com/pricing](https://www.heroku.com/pricing)
    for details of Heroku's pricing tiers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Heroku account and tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow the example in this section, you will first need to sign up for Heroku
    at [https://signup.heroku.com/](https://signup.heroku.com/).
  prefs: []
  type: TYPE_NORMAL
- en: We will also be using the heroku toolbelt, a CLI for configuring Heroku. Download
    and install the version for your platform from [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that the heroku toolbelt is installed correctly and available on your
    path. Open a new command prompt and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the help text with a list of available commands. Configure the
    toolbelt to use your Heroku account by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running an application locally with Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heroku requires a small configuration file (similar to `.travis.yml`) telling
    it how to run our application. This is a file named **Procfile**, which in our
    case contains a single line as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This tells Heroku that our application consists of a single web process, which
    can be started with `npm start`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note, especially if you are used to the Windows filesystem, that the uppercase
    P in the filename is important. The application will be deployed to a Unix-like
    system, where filenames are case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify our `Procfile`, we can run our application locally using Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will launch our application using the `Procfile`. Note that it also sets
    a default port of `5000`. You should now be able to visit the application at `http://localhost:5000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `heroku local` command also sets up environment variables for our application.
    These are read from a local `.env` file at the root of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this by starting up local instances of MongoDB and Redis. Run
    the following commands in separate prompts (setting the `--dbpath` as appropriate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Having this `.env` file means that we can use `npm start` directly (as we have
    before) to run with mock datastores and `heroku local` when we want a more realistic
    environment, without having to keep track of our current environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application to Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created a `Procfile`, deploying our application to the web
    is easy. First, we need to create a new Heroku application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By default, this provisions a minimal application on Heroku, with a randomly
    assigned name. You can optionally specify an application name as a third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command also returns the public URL for our newly-created app, which we
    can visit now. The following response is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying an application to Heroku](img/image00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s not much to see because we haven''t deployed anything yet. The quickest
    way to deploy an application to Heroku is via Git. The `heroku create` command
    also created a new Git remote for us to push to. You can see this by viewing the
    list of Git remotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a Git remote named `heroku`. Make sure the new `Procfile` has been
    committed. Now, when we push our master branch to this remote, it is automatically
    built and deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we visit the application''s URL again now, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying an application to Heroku](img/image00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our application has deployed but is now returning an error. To diagnose the
    problem with our application, we'll need to look at the logs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Heroku logs, config, and services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can view the logs from our application by running `heroku logs`. If you
    look through the logs to the error stacktrace, you''ll see the following error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `mockgoose` package is unavailable because Heroku builds our application
    using the `dependencies` in `package.json` and not the `devDependencies`. Recall
    from [Chapter 9](part0052.xhtml#aid-1HIT82 "Chapter 9. Persisting Data"), *Persisting
    Data*, that this error is intentional. We wanted the application to fail in live
    environments if no MongoDB URL is configured.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this error, we need to set up a MongoDB instance and configure our application
    to connect to it. We'll need to do the same for our Redis DB. Both of these data
    stores are available as services from the Heroku marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add Heroku marketplace services via the command line. MongoLab is a
    third-party service providing MongoDB instances. We can add an instance to our
    application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This creates a sandbox (free tier) MongoDB instance, suitable for demo purposes.
    Note from the output of this command that it also created a `MONGOLAB_URI` config
    variable. Heroku will provide this to our application as an environment variable
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application is expecting an environment variable named `MONGODB_URL`. We''ll
    need to create this and set it to the same value as `MONGOLAB_URI`. You can view
    and set config variables for an application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should fill in the value of `MONGODB_URL` to match the value of `MONGOLAB_URI`
    returned by the first command.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Redis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Heroku also provides a Redis service via its marketplace. We''ll add it to
    our application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Again we use the free tier version of this service (hobby-dev) for demo purposes.
    It's easy to re-scale services to different tiers later.
  prefs: []
  type: TYPE_NORMAL
- en: The Redis service also allows you to specify an alias for the created service
    instance. Aliases are specified using the `--as` parameter with `heroku addons:create`.
    This is useful for Redis as we may have several Redis instances associated with
    a single application. It's particularly useful for us, since, by aliasing our
    instance as REDIS, Heroku will create a `REDIS_URL` environment variable. This
    is exactly what our application expects to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `heroku addons:create` command restarts our application immediately. Our
    new database instances will take a minute or two to become available though. Wait
    a minute before restarting the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can now visit the application URL in our browser and see it running on the
    Web!
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Redis](img/image00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying from Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying via Git is a quick way to get up and running and is useful for developers.
    It's not a robust way of pushing out changes though. If we are practicing Continuous
    Delivery then we may want to deploy on every commit, at least to a UAT environment.
    But we still want our CI server to act as a gatekeeper and ensure that we only
    deploy good builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Travis CI supports deployment to a wide range of hosting providers (as well
    as arbitrary deployment via custom scripts). We can tell Travis CI to deploy to
    Heroku by adding a `deploy` section to our `travis.yml` as follows (replacing
    `application-name-12345` with the name of our previously created Heroku application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Travis CI will only deploy our application if the build passes. In order for
    Travis CI to communicate with Heroku, it requires our Heroku API key. But we may
    not want to commit this to source control (especially if our Git repository is
    public). Travis CI allows you to avoid this by specifying encrypted environment
    variables for the build.
  prefs: []
  type: TYPE_NORMAL
- en: Setting encrypted Travis CI environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Environment variables can be encrypted using a public key that Travis CI associates
    with our repository. Travis CI then uses the corresponding private key to decrypt
    these variables at build time.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to encrypt environment variables with the correct key is to
    use the Travis CLI. This is available as a Ruby package.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not have Ruby installed on your system already, see [https://www.ruby-lang.org/en/documentation/installation/](https://www.ruby-lang.org/en/documentation/installation/).
    The best way to install on Windows is to use `RubyInstaller`, from [http://rubyinstaller.org/](http://rubyinstaller.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether Ruby is installed and configured on your path by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should have version 2.0.0 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an encrypted environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have Ruby installed and on your path, you can install the Travis CLI
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Gem** is the Ruby package manager, similar to `npm`. The `--no-doc` and `--no-ri`
    arguments here skip installation of low-level API docs, which we don''t need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add our encrypted environment variable. First we need to obtain
    the Heroku API key for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add this to our `.travis.yml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`[AUTH_TOKEN]` is the output from the previous command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This encrypts the API key and automatically adds the encrypted version into
    our `.travis.yml` file. Before committing, try updating something in the application,
    for example the page title from `src/routes/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now commit and push the master branch (to `origin`, not directly to `heroku`)
    and wait for the Travis CI build to complete. The build output shows our application
    being deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an encrypted environment variable](img/image00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you visit the application again, you should see the new version with the
    updated title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that Travis CI is actually building our application for multiple versions
    of Node.js. By default, Travis CI deploys our application at the end of each build
    job. This is unnecessary and slows down our overall build. We can tell Travis
    CI to deploy only from a specific build job by altering our `.travis.yml` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we commit and check the output from Travis CI again, we can see that only
    the Node.js v6 build job performs a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Further resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further considerations on deploying web apps, see The Twelve-Factor App
    ([http://12factor.net/](http://12factor.net/)). This is a detailed resource about
    important considerations for running enterprise-grade web applications on services
    such as Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, a great many options for hosting a web application. Azure's
    web app service and AWS's Elastic Beanstalk both support Node.js as a first-class
    citizen. Modulus ([https://modulus.io/](https://modulus.io/)) provides Node.js
    and Mongo DB hosting, with powerful scaling, monitoring, and load-balancing features.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding are all examples of application hosting platforms (**Platform-as-a-Service**
    (**PaaS**), in cloud terminology). You can, of course, also deploy Node.js applications
    to bare infrastructure (either cloud infrastructure or your own machines). For
    a detailed guide, see [https://certsimple.com/blog/deploy-node-on-linux](https://certsimple.com/blog/deploy-node-on-linux).
  prefs: []
  type: TYPE_NORMAL
- en: You may need to manage releases of your application through multiple environments.
    Your CI server might first deploy your application to an integration environment
    and run tests on it there before deploying to UAT. You may then want to be able
    to push the exact same release from UAT to Stage and Live environments at the
    click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku Pipelines and Azure Web App deployment slots allow you to manage the
    release of your application through different environments. **Wercker** ([http://wercker.com/](http://wercker.com/))
    is a build and deployment service that can automate more complex workflows. It
    also provides isolated environments based on Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have deployed an application to the web using Heroku, configured
    environment settings and provisioned databases, set up Travis CI to automatically
    deploy successful builds, and learned about further options and considerations
    for deploying Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our application is available online, we can start thinking about how
    to integrate it with the wider Web. In the next chapter, we'll look at allowing
    users to log in using third party social media services as an identity provider.
  prefs: []
  type: TYPE_NORMAL
