<html><head></head><body>
  <div><h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-233" class="chapterTitle">Behavioral Design Patterns</h1>
    <p class="normal">In the last two chapters, we have learned patterns that aid us in the creation of objects and with building complex object structures. Now it's time to move onto another aspect of software design, which concerns the behavior of components. In this chapter, we will learn how to combine objects and how to define the way they communicate so that the behavior of the resulting structure becomes extensible, modular, reusable, and adaptable. Problems such as "How do I change parts of an algorithm at runtime?", "How can I change the behavior of an object based on its state?", and "How can I iterate over a collection without knowing its implementation?" are the typical kinds of problems solved by the patterns presented in this chapter.</p>
    <p class="normal">You've already met a notable member of this category of patterns, and that is the Observer pattern, which we presented in <em class="chapterRef">Chapter 3</em>, <em class="italic">Callbacks and Events</em>. The Observer pattern is one of the foundational patterns of the Node.js platform as it provides us with a simple interface for dealing with events and subscriptions, which are the life force of Node's event-driven architecture.</p>
    <p class="normal">If you are already familiar with the <strong class="keyword">Gang of Four</strong> (<strong class="keyword">GoF</strong>) design patterns, in this chapter, you will witness once again how the implementation of some of those patterns can be radically different in JavaScript compared to a purer object-oriented approach. A great example of this thesis can be found in the Iterator pattern, which you will meet later in the chapter. To implement the Iterator pattern, in fact, we won't need to extend any class or build any complex hierarchy. Instead, we will just need to add a special method to a class. Moreover, one particular pattern in this chapter, Middleware, tightly resembles another popular GoF pattern, which is the Chain of Responsibility pattern, but its implementation in Node.js has become such a standard that it can be considered a pattern of its own.</p>
    <p class="normal">Now, it's time to roll up your sleeves and get your hands dirty with some behavioral design patterns. In this chapter, you will learn about the following:</p>
    <ul>
      <li class="Bullet--PACKT-">The Strategy pattern, which helps us change parts of a component to adapt it to specific needs</li>
      <li class="Bullet--PACKT-">The State pattern, which allows us to change the behavior of a component based on its state</li>
      <li class="Bullet--PACKT-">The Template pattern, which allows us to reuse the structure of a component to define new ones</li>
      <li class="Bullet--PACKT-">The Iterator pattern, which provides us with a common interface to iterate over a collection</li>
      <li class="Bullet--PACKT-">The Middleware pattern, which allows us to define a modular chain of processing steps</li>
      <li class="Bullet-End--PACKT-">The Command pattern, which materializes the information required to execute a routine, allowing such information to be easily transferred, stored, and processed</li>
    </ul>
    <h1 id="_idParaDest-234" class="title">Strategy</h1>
    <p class="normal">The <strong class="keyword">Strategy</strong> pattern enables an<a id="_idIndexMarker708"/> object, called the <strong class="keyword">context</strong>, to support <a id="_idIndexMarker709"/>variations in its logic<a id="_idIndexMarker710"/> by extracting the <em class="italic">variable</em> parts into separate, interchangeable<a id="_idIndexMarker711"/> objects called <strong class="keyword">strategies</strong>. The context implements <a id="_idIndexMarker712"/>the common logic of a family of algorithms, while a strategy implements the mutable parts, allowing the context to adapt its behavior depending on different factors, such as an input value, a system configuration, or user preferences.</p>
    <p class="normal">Strategies are usually part of a family of solutions and all of them implement the same interface expected by the context. The following figure shows the situation we just described:</p>
    <figure class="mediaobject"><img src="img/B15729_09_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.1: General structure of the Strategy pattern</p>
    <p class="normal"><em class="italic">Figure 9.1</em> shows you how the context object can plug different strategies into its structure as if they were replaceable parts of a piece of machinery. Imagine a car; its tires can be considered its strategy for adapting to different road conditions. We can fit winter tires to go on snowy roads thanks to their studs, while we can decide to fit high-performance tires for<a id="_idIndexMarker713"/> traveling mainly on motorways for a long trip. On the one hand, we don't want to change the entire car for this to be possible, and on the other, we don't want a car with eight wheels so that it can go on every possible road.</p>
    <p class="normal">We quickly understand how powerful this pattern is. Not only does it help with separating the concerns within a given problem, but it also enables our solution to have better flexibility and adapt to different variations of the same problem.</p>
    <p class="normal">The Strategy pattern is particularly useful in all those situations where supporting variations in the behavior of a component requires complex conditional logic (lots of <code class="Code-In-Text--PACKT-">if...else</code> or <code class="Code-In-Text--PACKT-">switch</code> statements) or mixing different components of the same family. Imagine an object called <code class="Code-In-Text--PACKT-">Order</code> that represents an online order on an e-commerce website. The object has a method called <code class="Code-In-Text--PACKT-">pay()</code> that, as it says, finalizes the order and transfers the funds from the user to the online store.</p>
    <p class="normal">To support different payment systems, we have a couple of options:</p>
    <ul>
      <li class="Bullet--PACKT-">Use an <code class="Code-In-Text--PACKT-">if...else</code> statement in the <code class="Code-In-Text--PACKT-">pay()</code> method to complete the operation based on the chosen payment option</li>
      <li class="Bullet-End--PACKT-">Delegate the logic of the payment to a strategy object that implements the logic for the specific payment gateway selected by the user</li>
    </ul>
    <p class="normal">In the first solution, our <code class="Code-In-Text--PACKT-">Order</code> object cannot support other payment methods unless its code is modified. Also, this can become quite complex when the number of payment options grows. Instead, using the Strategy pattern enables the <code class="Code-In-Text--PACKT-">Order</code> object to support a virtually unlimited number of <a id="_idIndexMarker714"/>payment methods and keeps its scope limited to only managing the details of the user, the purchased items, and the relative price while delegating the job of completing the payment to another object.</p>
    <p class="normal">Let's now demonstrate this pattern with a simple, realistic example.</p>
    <h2 id="_idParaDest-235" class="title">Multi-format configuration objects</h2>
    <p class="normal">Let's consider an <a id="_idIndexMarker715"/>object called <code class="Code-In-Text--PACKT-">Config</code> that holds a set of configuration parameters used by an application, such as the database URL, the listening port of the server, and so on. The <code class="Code-In-Text--PACKT-">Config</code> object should be able to provide a simple interface to access these parameters, but also a way to import and export the configuration using persistent storage, such as a file. We want to be able to support different formats to store the configuration, for example, JSON, INI, or YAML.</p>
    <p class="normal">By applying what we learned about the Strategy pattern, we can immediately identify the variable part of the <code class="Code-In-Text--PACKT-">Config</code> object, which is the functionality that allows us to serialize and deserialize the configuration. This is going to be implemented by our strategies.</p>
    <p class="normal">Let's create a new module called <code class="Code-In-Text--PACKT-">config.js</code>, and let's define the <em class="italic">generic</em> part of our configuration manager:</p>
    <pre class="programlisting code"><code class="hljs-code">import { promises as fs } from 'fs'
import objectPath from 'object-path'
export class Config {
  constructor (formatStrategy) {                           // (1)
    this.data = {}
    this.formatStrategy = formatStrategy
  }
  get (configPath) {                                       // (2)
    return objectPath.get(this.data, configPath)
  }
  set (configPath, value) {                                // (2)
    return objectPath.set(this.data, configPath, value)
  }
  async load (filePath) {                                  // (3)
    console.log(`Deserializing from ${filePath}`)
    this.data = this.formatStrategy.deserialize(
      await fs.readFile(filePath, 'utf-8')
    )
  }
  async save (filePath) {                                  // (3)
    console.log(`Serializing to ${filePath}`)
    await fs.writeFile(filePath,
      this.formatStrategy.serialize(this.data))
  }
}
</code></pre>
    <p class="normal">This is what's happening in the <a id="_idIndexMarker716"/>preceding code:</p>
    <ol>
      <li class="numbered">In the constructor, we create an instance variable called <code class="Code-In-Text--PACKT-">data</code> to hold the configuration data. Then we also store <code class="Code-In-Text--PACKT-">formatStrategy</code>, which represents the component that we will use to parse and serialize the data.</li>
      <li class="numbered">We provide two methods, <code class="Code-In-Text--PACKT-">set()</code> and <code class="Code-In-Text--PACKT-">get()</code>, to access the configuration properties using a dotted path notation (for example, <code class="Code-In-Text--PACKT-">property.subProperty</code>) by leveraging a library called <code class="Code-In-Text--PACKT-">object-path</code> (<a href="http://nodejsdp.link/object-path">nodejsdp.link/object-path</a>).</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">load()</code> and <code class="Code-In-Text--PACKT-">save()</code> methods are where we delegate, respectively, the deserialization and serialization of the data to our strategy. This is where the logic of the <code class="Code-In-Text--PACKT-">Config</code> class is altered based on the <code class="Code-In-Text--PACKT-">formatStrategy</code> passed as an input in the constructor.</li>
    </ol>
    <p class="normal">As we can see, this very simple and neat design allows the <code class="Code-In-Text--PACKT-">Config</code> object to seamlessly support different file formats when loading and saving its data. The best part is that the logic to support those various formats is not hardcoded anywhere, so the <code class="Code-In-Text--PACKT-">Config</code> class can adapt without any modification to virtually any file format, given the right strategy.</p>
    <p class="normal">To demonstrate this characteristic, let's now create a couple of format strategies in a file called <code class="Code-In-Text--PACKT-">strategies.js</code>. Let's start with a strategy for parsing and serializing data using the INI file format, which is a widely used configuration format (more info about it here: <a href="http://nodejsdp.link/ini-format">nodejsdp.link/ini-format</a>). </p>
    <p class="normal">For the task, we will use an npm package called <code class="Code-In-Text--PACKT-">ini</code> (<a href="http://nodejsdp.link/ini">nodejsdp.link/ini</a>):</p>
    <pre class="programlisting code"><code class="hljs-code">import ini from 'ini'
export const iniStrategy = {
  deserialize: data =&gt; ini.parse(data),
  serialize: data =&gt; ini.stringify(data)
}
</code></pre>
    <p class="normal">Nothing really complicated! Our strategy simply implements the agreed interface, so that it can be used by the <code class="Code-In-Text--PACKT-">Config</code> object.</p>
    <p class="normal">Similarly, the next strategy that we are going to create allows us to support the JSON file format, widely used in JavaScript and in the web development ecosystem in general:</p>
    <pre class="programlisting code"><code class="hljs-code">export const jsonStrategy = {
  deserialize: data =&gt; JSON.parse(data),
  serialize: data =&gt; JSON.stringify(data, null, '  ')
}
</code></pre>
    <p class="normal">Now, to show you how<a id="_idIndexMarker717"/> everything comes together, let's create a file named <code class="Code-In-Text--PACKT-">index.js</code>, and let's try to load and save a sample configuration using different formats:</p>
    <pre class="programlisting code"><code class="hljs-code">import { Config } from './config.js'
import { jsonStrategy, iniStrategy } from './strategies.js'
async function main () {
  const iniConfig = new Config(iniStrategy)
  await iniConfig.load('samples/conf.ini')
  iniConfig.set('book.nodejs', 'design patterns')
  await iniConfig.save('samples/conf_mod.ini')
  const jsonConfig = new Config(jsonStrategy)
  await jsonConfig.load('samples/conf.json')
  jsonConfig.set('book.nodejs', 'design patterns')
  await jsonConfig.save('samples/conf_mod.json')
}
main()
</code></pre>
    <p class="normal">Our test module reveals the core properties of the Strategy pattern. We defined only one <code class="Code-In-Text--PACKT-">Config</code> class, which implements the common parts of our configuration manager, then, by using different strategies for serializing and deserializing data, we created different <code class="Code-In-Text--PACKT-">Config</code> class instances supporting different file formats.</p>
    <p class="normal">The example we've just seen showed us only one of the possible alternatives that we had for selecting a strategy. Other valid approaches might have been the following:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Creating two different strategy families</strong>: One for the deserialization and the other for the serialization. This would have <a id="_idIndexMarker718"/>allowed reading from a format and saving to another.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Dynamically selecting the strategy</strong>: Depending on the extension of the file provided, the <code class="Code-In-Text--PACKT-">Config</code> object could have maintained a map <code class="Code-In-Text--PACKT-">extension → strategy</code> and used it to select the right algorithm for the given extension.</li>
    </ul>
    <p class="normal">As we can see, we have <a id="_idIndexMarker719"/>several options for selecting the strategy to use, and the right one only depends on your requirements and the tradeoff in terms of features and the simplicity you want to obtain.</p>
    <p class="normal">Furthermore, the implementation of the pattern itself can vary a lot as well. For example, in its simplest form, the context and the strategy can both be simple functions:</p>
    <pre class="programlisting code"><code class="hljs-code">function context(strategy) {...}
</code></pre>
    <p class="normal">Even though this may seem insignificant, it should not be underestimated in a programming language such as JavaScript, where functions are first-class citizens and used as much as fully-fledged objects.</p>
    <p class="normal">Between all these variations, though, what does not change is the idea behind the pattern; as always, the implementation can slightly change but the core concepts that drive the pattern are always the same.</p>
    <div><p class="Tip--PACKT-">The structure of the Strategy pattern may look similar to that of the Adapter pattern. However, there is a substantial difference between the two. The adapter object does not add any behavior to the adaptee; it just makes it available under another interface. This can also require some extra logic to be implemented to convert one interface into another, but this logic is limited to this task only. In the Strategy pattern, however, the context and the strategy implement two different parts of an algorithm and therefore both implement some kind of logic and both are essential to build the final algorithm (when combined together).</p>
    </div>
    <h2 id="_idParaDest-236" class="title">In the wild</h2>
    <p class="normal">Passport (<a href="http://nodejsdp.link/passportjs">nodejsdp.link/passportjs</a>) is an <a id="_idIndexMarker720"/>authentication<a id="_idIndexMarker721"/> framework for<a id="_idIndexMarker722"/> Node.js, which allows a web server to support different authentication schemes. With Passport, we can provide a <em class="italic">login with Facebook</em> or <em class="italic">login with Twitter</em> functionality to our web application with minimal effort. Passport uses the Strategy pattern to separate the common logic used during an authentication process from the parts that can <a id="_idIndexMarker723"/>change, namely the actual authentication step. For example, we might want to use OAuth in order to obtain an access token to access a Facebook or Twitter profile, or simply use a local database to verify a username/password pair. For <a id="_idIndexMarker724"/>Passport, these are all different strategies for completing the authentication process and, as we can imagine, this allows the library to support a virtually unlimited <a id="_idIndexMarker725"/>number of authentication services. Take a look at the number of different authentication providers supported at <a href="http://nodejsdp.link/passport-strategies">nodejsdp.link/passport-strategies</a> to get an idea of what the Strategy pattern can do.</p>
    <h1 id="_idParaDest-237" class="title">State</h1>
    <p class="normal">The <strong class="keyword">State</strong> pattern is a specialization of the<a id="_idIndexMarker726"/> Strategy pattern where the strategy changes depending on the <em class="italic">state</em> of the context.</p>
    <p class="normal">We have seen in the <a id="_idIndexMarker727"/>previous section how a strategy can be selected based on different variables such as a configuration property or an input parameter, and once this selection is done, the strategy remains unchanged for the rest of the lifespan of the context object. In the State pattern, instead, the strategy (also called the <strong class="keyword">state</strong> in this circumstance) is dynamic and can change during the lifetime of the context, thus allowing its behavior to adapt depending on its internal state.</p>
    <p class="normal">The following figure shows us a representation of the pattern:</p>
    <figure class="mediaobject"><img src="img/B15729_09_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.2: The State pattern</p>
    <p class="normal"><em class="italic">Figure 9.2</em> shows how a context object transitions through three states (A, B, and C). With the State pattern, at each different context state, we select a different strategy. This means that the context object will adopt a different behavior based on the state it's in.</p>
    <p class="normal">To make this easier to <a id="_idIndexMarker728"/>understand, let's consider an example: imagine we have a hotel booking system and an object called <code class="Code-In-Text--PACKT-">Reservation</code> that models a room reservation. This is a typical situation where we have to adapt the behavior of an object based on its state.</p>
    <p class="normal">Consider the following series of events:</p>
    <ul>
      <li class="Bullet--PACKT-">When the reservation is initially created, the user can confirm (using a method called <code class="Code-In-Text--PACKT-">confirm()</code>) the reservation. Of course, they cannot cancel it (using <code class="Code-In-Text--PACKT-">cancel()</code>), because it's still not confirmed (the caller would receive an exception, for example). They can, however, delete it (using <code class="Code-In-Text--PACKT-">delete()</code>) if they change their mind before buying.</li>
      <li class="Bullet--PACKT-">Once the reservation is confirmed, using the <code class="Code-In-Text--PACKT-">confirm()</code> method again does not make any sense; however, now it should be possible to cancel the reservation but no longer delete it, because it has to be kept for the records.</li>
      <li class="Bullet-End--PACKT-">On the day before the reservation date, it should not be possible to cancel the reservation anymore; it's too late for that.</li>
    </ul>
    <p class="normal">Now, imagine that we have to implement the reservation system that we just described in one monolithic object. We can already picture all the <code class="Code-In-Text--PACKT-">if...else</code> or <code class="Code-In-Text--PACKT-">switch</code> statements that we would have to write to enable/disable each action depending on the state of the reservation.</p>
    <figure class="mediaobject"><img src="img/B15729_09_03.png" alt="A screenshot of a cell phone  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 9.3: An example application of the State pattern</p>
    <p class="normal">As illustrated in <em class="italic">Figure 9.3</em>, the State <a id="_idIndexMarker729"/>pattern is, instead, perfect in this situation: there would be three strategies, all implementing the three methods described (<code class="Code-In-Text--PACKT-">confirm()</code>, <code class="Code-In-Text--PACKT-">cancel()</code>, and <code class="Code-In-Text--PACKT-">delete()</code>) and each one implementing only one behavior—the one corresponding to the modeled state. By using this pattern, it should be very easy for the <code class="Code-In-Text--PACKT-">Reservation</code> object to switch from one behavior to another; this would simply require the <strong class="keyword">activation</strong> of a different strategy (state object) on each state change.</p>
    <div><p class="Information-Box--PACKT-">The <strong class="keyword">state transition</strong> can be initiated <a id="_idIndexMarker730"/>and controlled by the context object, by the client code, or by the state objects themselves. This last option usually provides the best results in terms of flexibility and decoupling, as the context does not have to know about all the possible states and how to transition between them.</p>
    </div>
    <p class="normal">Let's now work on a more concrete example so that we can apply what we learned about the State pattern.</p>
    <h2 id="_idParaDest-238" class="title">Implementing a basic failsafe socket</h2>
    <p class="normal">Let's build a TCP client socket that <a id="_idIndexMarker731"/>does not fail when the connection with the server is lost; instead, we want to queue all the data sent during the time in which the server is offline and then try to send it again as soon as the connection is reestablished. We want to leverage this socket in the context of a simple monitoring system, where a set of machines sends some statistics about their resource utilization at regular intervals. If the server that collects these resources goes down, our socket will continue to queue the data locally until the server comes back online.</p>
    <p class="normal">Let's start by creating a <a id="_idIndexMarker732"/>new module called <code class="Code-In-Text--PACKT-">failsafeSocket.js</code> that defines our context object:</p>
    <pre class="programlisting code"><code class="hljs-code">import { OfflineState } from './offlineState.js'
import { OnlineState } from './onlineState.js'
export class FailsafeSocket {
  constructor (options) {                                  // (1)
    this.options = options
    this.queue = []
    this.currentState = null
    this.socket = null
    this.states = {
      offline: new OfflineState(this),
      online: new OnlineState(this)
    }
    this.changeState('offline')
  }
  changeState (state) {                                    // (2)
    console.log(`Activating state: ${state}`)
    this.currentState = this.states[state]
    this.currentState.activate()
  }
  send (data) {                                            // (3)
    this.currentState.send(data)
  }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">FailsafeSocket</code> class is made of three main elements:</p>
    <ol>
      <li class="numbered">The constructor initializes various data structures, including the queue that will contain any data sent while the socket is offline. Also, it creates a set of two states: one for implementing the behavior of the socket while it's offline, and another one when the socket is online.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">changeState()</code> method is responsible for transitioning from one state to another. It simply updates the <code class="Code-In-Text--PACKT-">currentState</code> instance variable and calls <code class="Code-In-Text--PACKT-">activate()</code> on the target state.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">send()</code> method contains the main functionality of the <code class="Code-In-Text--PACKT-">FailsafeSocket</code> class. This is where we want to have a different behavior based on the offline/online state. As we can see, this is done by delegating the operation to the currently active state.</li>
    </ol>
    <p class="normal">Let's now see what the two <a id="_idIndexMarker733"/>states look like, starting from the <code class="Code-In-Text--PACKT-">offlineState.js</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code">import jsonOverTcp from 'json-over-tcp-2'                  // (1)
export class OfflineState {
  constructor (failsafeSocket) {
    this.failsafeSocket = failsafeSocket
  }
  send (data) {                                            // (2)
    this.failsafeSocket.queue.push(data)
  }
  activate () {                                            // (3)
    const retry = () =&gt; {
      setTimeout(() =&gt; this.activate(), 1000)
    }
    console.log('Trying to connect...')
    this.failsafeSocket.socket = jsonOverTcp.connect(
      this.failsafeSocket.options,
      () =&gt; {
        console.log('Connection established')
        this.failsafeSocket.socket.removeListener('error', retry)
        this.failsafeSocket.changeState('online')
      }
    )
    this.failsafeSocket.socket.once('error', retry)
  }
}
</code></pre>
    <p class="normal">The module that we just created is responsible for managing the behavior of the socket while it's offline. This is how it works:</p>
    <ol>
      <li class="numbered">Instead of using a raw TCP socket, we will use a little library called <code class="Code-In-Text--PACKT-">json-over-tcp-2</code> (<a href="http://nodejsdp.link/json-over-tcp-2">nodejsdp.link/json-over-tcp-2</a>). This will greatly simplify our work since the library will take care of all the parsing and formatting of the data going through the socket into JSON objects.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">send()</code> method is only responsible for queuing any data it receives. We are assuming that we are offline, so we'll save those data objects for later. That's all we need to do here.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">activate()</code> method tries to<a id="_idIndexMarker734"/> establish a connection with the server using the <code class="Code-In-Text--PACKT-">json-over-tcp-2</code> socket. If the operation fails, it tries again after one second. It continues trying until a valid connection is established, in which case the state of <code class="Code-In-Text--PACKT-">failsafeSocket</code> is transitioned to online.</li>
    </ol>
    <p class="normal">Next, let's create the <code class="Code-In-Text--PACKT-">onlineState.js</code> module, which is where we will implement the <code class="Code-In-Text--PACKT-">OnlineState</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">export class OnlineState {
  constructor (failsafeSocket) {
    this.failsafeSocket = failsafeSocket
    this.hasDisconnected = false
  }
  send (data) {                                            // (1)
    this.failsafeSocket.queue.push(data)
    this._safeWrite(data)
  }
  _safeWrite (data) {                                      // (2)
    this.failsafeSocket.socket.write(data, (err) =&gt; {
      if (!this.hasDisconnected &amp;&amp; !err) {
        this.failsafeSocket.queue.shift()
      }
    })
  }
  activate () {                                            // (3)
    this.hasDisconnected = false
    for (const data of this.failsafeSocket.queue) {
      this._safeWrite(data)
    }
    this.failsafeSocket.socket.once('error', () =&gt; {
      this.hasDisconnected = true
      this.failsafeSocket.changeState('offline')
    })
  }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">OnlineState</code> class models the behavior of the <code class="Code-In-Text--PACKT-">FailsafeSocket</code> when there is an active connection with the server. This is how it works:</p>
    <ol>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">send()</code> method queues the data and then immediately tries to write it directly into the socket, as we assume that we are online. It'll use the internal <code class="Code-In-Text--PACKT-">_safeWrite()</code> method to do that.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">_safeWrite()</code> method tries to write the data into the socket writable stream (see the official docs at <a href="http://nodejsdp.link/writable-write">nodejsdp.link/writable-write</a>) and it waits for the data to be written into the underlying resource. If no errors are returned and if the socket didn't disconnect in the meantime, it means that the data was sent successfully and therefore we<a id="_idIndexMarker735"/> remove it from the queue.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">activate()</code> method flushes any data that was queued while the socket was offline and it also starts listening for any <code class="Code-In-Text--PACKT-">error</code> event; we will take this as a symptom that the socket went offline (for simplicity). When this happens, we transition to the <code class="Code-In-Text--PACKT-">offline</code> state.</li>
    </ol>
    <p class="normal">That's it for our <code class="Code-In-Text--PACKT-">FailsafeSocket</code>. Now we are ready to build a sample client and a server to try it out. Let's put the server code in a module named <code class="Code-In-Text--PACKT-">server.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import jsonOverTcp from 'json-over-tcp-2'
const server = jsonOverTcp.createServer({ port: 5000 })
server.on('connection', socket =&gt; {
  socket.on('data', data =&gt; {
    console.log('Client data', data)
  })
})
server.listen(5000, () =&gt; console.log('Server started'))
</code></pre>
    <p class="normal">Then, the client-side code, which is what we are really interested in, goes into <code class="Code-In-Text--PACKT-">client.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import { FailsafeSocket } from './failsafeSocket.js'
const failsafeSocket = new FailsafeSocket({ port: 5000 })
setInterval(() =&gt; {
  // send current memory usage
  failsafeSocket.send(process.memoryUsage())
}, 1000)
</code></pre>
    <p class="normal">Our server simply prints to the console any JSON message it receives, while our clients are sending a measurement of their memory utilization every second, leveraging a <code class="Code-In-Text--PACKT-">FailsafeSocket</code> object.</p>
    <p class="normal">To try the small system that we built, we should run both the client and the server, then we can test the features of <code class="Code-In-Text--PACKT-">failsafeSocket</code> by stopping and then restarting the server. We should see that the state of the client changes between <code class="Code-In-Text--PACKT-">online</code> and <code class="Code-In-Text--PACKT-">offline</code> and that any memory measurement collected while the server is offline is queued and then resent as soon as the server<a id="_idIndexMarker736"/> goes back online.</p>
    <p class="normal">This sample should be a clear demonstration of how the State pattern can help increase the modularity and readability of a component that has to adapt its behavior depending on its state.</p>
    <div><p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">FailsafeSocket</code> class that we built in this section is only for demonstrating the State pattern and doesn't want to be a complete and 100% reliable solution for handling connectivity issues with TCP sockets. For example, we are not verifying that all the data written into the socket stream is received by the server, which would <a id="_idIndexMarker737"/>require some more code not strictly related to the pattern that we wanted to describe. For a production alternative, you can count on ZeroMQ (<a href="http://nodejsdp.link/zeromq">nodejsdp.link/zeromq</a>). We'll talk about some patterns using ZeroMQ later in the book in <em class="chapterRef">Chapter 13</em>, <em class="italic">Messaging and Integration Patterns</em>.</p>
    </div>
    <h1 id="_idParaDest-239" class="title">Template</h1>
    <p class="normal">The next pattern that we are<a id="_idIndexMarker738"/> going to analyze is called <strong class="keyword">Template</strong> and it has a lot in common with the Strategy <a id="_idIndexMarker739"/>pattern. The Template pattern defines an abstract class that implements the skeleton (representing the common parts) of a component, where some of its steps are left undefined. Subclasses can then <em class="italic">fill</em> the gaps in the component by implementing the missing<a id="_idIndexMarker740"/> parts, called <strong class="keyword">template methods</strong>. The intent of this pattern is to make it possible to define a family of classes that are all variations of a family of components. The following UML diagram shows the structure that we just described:</p>
    <figure class="mediaobject"><img src="img/B15729_09_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.4: UML diagram of the Template pattern</p>
    <p class="normal">The three concrete classes shown in <em class="italic">Figure 9.4</em>, extend the template class and provide an implementation for <code class="Code-In-Text--PACKT-">templateMethod()</code>, which is <em class="italic">abstract</em> or <em class="italic">pure virtual</em>, to use C++ terminology. In JavaScript, we don't have a formal way to define abstract classes, so all we can do is leave the method undefined or assign it to a function that always throws an exception, indicating that the method has to be implemented. The Template pattern can be considered a more traditionally object-oriented pattern than the other patterns we have seen so far, because inheritance is a core part of its implementation.</p>
    <p class="normal">The purpose of Template and <a id="_idIndexMarker741"/>Strategy is very similar, but the main difference between the two lies in their structure and implementation. Both allow us to change the variable parts of a component while reusing the common parts. However, while Strategy allows us to do it <em class="italic">dynamically</em> at runtime, with Template, the complete component is determined the moment the<a id="_idIndexMarker742"/> concrete class is defined. Under these assumptions, the Template pattern might be more suitable in those circumstances where we want to create prepackaged variations of a component. As always, the choice between one pattern and the other is up to the developer, who has to consider the various pros and cons for each use case.</p>
    <p class="normal">Let's now work on an example.</p>
    <h2 id="_idParaDest-240" class="title">A configuration manager template</h2>
    <p class="normal">To have a better idea of the <a id="_idIndexMarker743"/>differences between Strategy and Template, let's now reimplement the <code class="Code-In-Text--PACKT-">Config</code> object that we defined in the <em class="italic">Strategy</em> pattern section, but this time using Template. As in the previous version of the <code class="Code-In-Text--PACKT-">Config</code> object, we want to have the ability to load and save a set of configuration properties using different file formats.</p>
    <p class="normal">Let's start by defining the template class. We will call it <code class="Code-In-Text--PACKT-">ConfigTemplate</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import { promises as fsPromises } from 'fs'
import objectPath from 'object-path'
export class ConfigTemplate {
  async load (file) {
    console.log(`Deserializing from ${file}`)
    this.data = this._deserialize(
      await fsPromises.readFile(file, 'utf-8'))
  }
  async save (file) {
    console.log(`Serializing to ${file}`)
    await fsPromises.writeFile(file, this._serialize(this.data))
  }
  get (path) {
    return objectPath.get(this.data, path)
  }
  set (path, value) {
    return objectPath.set(this.data, path, value)
  }
  _serialize () {
    throw new Error('_serialize() must be implemented')
  }
  _deserialize () {
    throw new Error('_deserialize() must be implemented')
  }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">ConfigTemplate</code> class implements the common parts of the configuration management logic, namely setting and getting properties, plus loading and saving it to the disk. However, it leaves the implementation of <code class="Code-In-Text--PACKT-">_serialize()</code> and <code class="Code-In-Text--PACKT-">_deserialize()</code> open; those are in fact our<a id="_idIndexMarker744"/> template methods, which will allow the creation of concrete <code class="Code-In-Text--PACKT-">Config</code> classes supporting specific configuration formats. The underscore at the beginning of the template methods' names indicates that they are for internal use only, an easy way to flag protected methods. Since in JavaScript we cannot declare a method as abstract, we simply define them as <strong class="keyword">stubs</strong>, throwing <a id="_idIndexMarker745"/>an error if they are invoked (in other words, if they are not overridden by a concrete subclass).</p>
    <p class="normal">Let's now create a concrete class using our template, for example, one that allows us to load and save the configuration using the JSON format:</p>
    <pre class="programlisting code"><code class="hljs-code">import { ConfigTemplate } from './configTemplate.js'
export class JsonConfig extends ConfigTemplate {
  _deserialize (data) {
    return JSON.parse(data)
  }
  _serialize (data) {
    return JSON.stringify(data, null, '  ')
  }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">JsonConfig</code> class extends our template class, <code class="Code-In-Text--PACKT-">ConfigTemplate</code>, and provides a concrete implementation for the <code class="Code-In-Text--PACKT-">_deserialize()</code> and <code class="Code-In-Text--PACKT-">_serialize()</code> methods.</p>
    <p class="normal">Similarly, we can implement an <code class="Code-In-Text--PACKT-">IniConfig</code> class supporting the <code class="Code-In-Text--PACKT-">.ini</code> file format using the same template class:</p>
    <pre class="programlisting code"><code class="hljs-code">import { ConfigTemplate } from './configTemplate.js'
import ini from 'ini'
export class IniConfig extends ConfigTemplate {
  _deserialize (data) {
    return ini.parse(data)
  }
  _serialize (data) {
    return ini.stringify(data)
  }
}
</code></pre>
    <p class="normal">Now we can use our concrete configuration manager classes to load and save some configuration data:</p>
    <pre class="programlisting code"><code class="hljs-code">import { JsonConfig } from './jsonConfig.js'
import { IniConfig } from './iniConfig.js'
async function main () {
  const jsonConfig = new JsonConfig()
  await jsonConfig.load('samples/conf.json')
  jsonConfig.set('nodejs', 'design patterns')
  await jsonConfig.save('samples/conf_mod.json')
  const iniConfig = new IniConfig()
  await iniConfig.load('samples/conf.ini')
  iniConfig.set('nodejs', 'design patterns')
  await iniConfig.save('samples/conf_mod.ini')
}
main()
</code></pre>
    <p class="normal">Note the difference with the Strategy <a id="_idIndexMarker746"/>pattern: the logic for formatting and parsing the configuration data is <em class="italic">baked into</em> the class itself, rather than being chosen at runtime.</p>
    <p class="normal">With minimal effort, the Template pattern allowed us to obtain a new, fully working configuration manager by reusing the logic and the interface inherited from the parent template class and providing only the implementation of a few abstract methods.</p>
    <h2 id="_idParaDest-241" class="title">In the wild</h2>
    <p class="normal">This pattern should not look entirely<a id="_idIndexMarker747"/> new to us. We already encountered it in <em class="chapterRef">Chapter 6</em>, <em class="italic">Coding with Streams</em>, when we were extending the different stream classes to implement our custom streams. In that context, the template methods were the <code class="Code-In-Text--PACKT-">_write()</code>, <code class="Code-In-Text--PACKT-">_read()</code>, <code class="Code-In-Text--PACKT-">_transform()</code>, or <code class="Code-In-Text--PACKT-">_flush()</code> methods, depending on the stream class that we wanted to implement. To create a new custom stream, we needed to inherit from a specific abstract stream class, providing an implementation for the template methods.</p>
    <p class="normal">Next, we are going to learn about a very important and ubiquitous pattern that is also built into the JavaScript language itself, which is the Iterator pattern.</p>
    <h1 id="_idParaDest-242" class="title">Iterator</h1>
    <p class="normal">The <strong class="keyword">Iterator</strong> pattern is a fundamental <a id="_idIndexMarker748"/>pattern and it's so important and commonly used that it's usually built into the programming language itself. All major <a id="_idIndexMarker749"/>programming languages implement the pattern in one way or another, including, of course, JavaScript (starting from the ECMAScript2015 specification).</p>
    <p class="normal">The Iterator pattern defines a common interface or protocol for iterating the elements of a container, such as an array or a tree data structure. Usually, the algorithm for iterating over the elements of a container is different depending on the actual structure of the data. Think about iterating over an array versus traversing a tree: in the first situation, we need just a simple loop; in the second, a more complex tree traversal algorithm is required (<a href="http://nodejsdp.link/tree-traversal">nodejsdp.link/tree-traversal</a>). With the Iterator pattern, we hide the details about the algorithm being used or the structure of the data and provide a common interface for iterating over any type of container. In essence, the Iterator pattern allows us to decouple the implementation of the traversal algorithm from the way we consume the results (the elements) of the traversal operation.</p>
    <p class="normal">In JavaScript, however, iterators work great even with other types of constructs, which are not necessarily containers, such as event emitters and streams. Therefore, we can say in more general terms that the Iterator pattern defines an interface to iterate over elements produced or retrieved in sequence.</p>
    <h2 id="_idParaDest-243" class="title">The iterator protocol</h2>
    <p class="normal">In JavaScript, the Iterator <a id="_idIndexMarker750"/>pattern is implemented through <strong class="keyword">protocols</strong> rather than through formal constructs, such as inheritance. This essentially means that the interaction between the implementer and the consumer of the Iterator pattern will communicate using interfaces and objects whose shape is agreed in advance.</p>
    <p class="normal">The starting point for implementing the Iterator pattern in JavaScript is the <strong class="keyword">iterator protocol</strong>, which defines an interface for <a id="_idIndexMarker751"/>producing a sequence of values. So, we'll call <strong class="keyword">iterator</strong> an object implementing a <code class="Code-In-Text--PACKT-">next()</code> method having the following behavior: each time the method is called, the function returns the next element in the iteration through an object, called the <strong class="keyword">iterator result</strong>, having two<a id="_idIndexMarker752"/> properties—<code class="Code-In-Text--PACKT-">done</code> and <code class="Code-In-Text--PACKT-">value</code>:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">done</code> is set to <code class="Code-In-Text--PACKT-">true</code> when <a id="_idIndexMarker753"/>the iteration is complete, or in other words, when there are no more elements to return. Otherwise, <code class="Code-In-Text--PACKT-">done</code> will be <code class="Code-In-Text--PACKT-">undefined</code> or <code class="Code-In-Text--PACKT-">false</code>.</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">value</code> contains the current <a id="_idIndexMarker754"/>element of the iteration and it can be left undefined if <code class="Code-In-Text--PACKT-">done</code> is <code class="Code-In-Text--PACKT-">true</code>. If <code class="Code-In-Text--PACKT-">value</code> is set even when <code class="Code-In-Text--PACKT-">done</code> is <code class="Code-In-Text--PACKT-">true</code>, then it is said that <code class="Code-In-Text--PACKT-">value</code> contains the <strong class="keyword">return value</strong> of the iteration, a value which is not part of the elements being iterated, but it's related to the iteration itself as a whole (for example, the time spent iterating all the elements or the average of all the elements iterated if the elements are numbers).</li>
    </ul>
    <div><p class="Tip--PACKT-">Nothing prevents us from adding extra properties to the object returned by an iterator. However, those properties will be simply ignored by the built-in constructs or APIs consuming the iterator (we'll meet those in a moment).</p>
    </div>
    <p class="normal">Let's use a quick example to demonstrate how to implement the iterator protocol. Let's implement a factory function called <code class="Code-In-Text--PACKT-">createAlphabetIterator()</code>, which creates an iterator that allows us to traverse all the letters of the English alphabet. Such a function would look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">const A_CHAR_CODE = 65
const Z_CHAR_CODE = 90
function createAlphabetIterator () {
  let currCode = A_CHAR_CODE
  return {
    next () {
      const currChar = String.fromCodePoint(currCode)
      if (currCode &gt; Z_CHAR_CODE) {
        return { done: true }
      }
      currCode++
      return { value: currChar, done: false }
    }
  }
}
</code></pre>
    <p class="normal">The logic of the iteration is actually very straightforward; at each invocation of the <code class="Code-In-Text--PACKT-">next()</code> method, we simply increment a number representing the letter's character code, convert it to a <a id="_idIndexMarker755"/>character, and then return it using the object shape defined by the iterator protocol.</p>
    <div><p class="Information-Box--PACKT-">It's not a <a id="_idIndexMarker756"/>requirement for an iterator to ever return <code class="Code-In-Text--PACKT-">done: true</code>. In fact, there can be many situations in which an iterator is <strong class="keyword">infinite</strong>. An example is an iterator that returns a random number at each iteration. Another example is an iterator that calculates a mathematical series, such as the Fibonacci series or the digits of the constant <code class="Code-In-Text--PACKT-">pi</code> (as an exercise, you can try to convert the following <a id="_idIndexMarker757"/>algorithm to use iterators: <a href="http://nodejsdp.link/pi-js">nodejsdp.link/pi-js</a>). Note that even if an iterator is theoretically infinite, it doesn't mean that it won't have computational or spatial limits. For example, the number returned by the Fibonacci sequence will get very big very soon.</p>
    </div>
    <p class="normal">The important aspect to note is that an iterator is very often a stateful object since we have to keep track in some way of the current <em class="italic">position</em> of the iteration. In the previous example, we managed to keep the state in a closure (the <code class="Code-In-Text--PACKT-">currCode</code> variable) but this is just one of the ways we can do so. We could have, for example, kept the state in an instance variable. This is usually better in terms of debuggability since we can read the status of the iteration from the iterator itself at any time, but on the other side, it does not prevent external code from modifying the instance variable and hence tampering with the status of the iteration. It's up to you to decide the pros and cons of each option.</p>
    <p class="normal">Iterators can indeed be fully stateless as well. Examples are iterators returning random elements and either completing randomly or never completing, and iterators stopping at the first iteration.</p>
    <p class="normal">Now, let's see how we can use the iterator we just built. Consider the following code fragment:</p>
    <pre class="programlisting code"><code class="hljs-code">const iterator = createAlphabetIterator()
let iterationResult = iterator.next()
while (!iterationResult.done) {
  console.log(iterationResult.value)
  iterationResult = iterator.next()
}
</code></pre>
    <p class="normal">As we can see from the previous code, the code that consumes an iterator can be considered a pattern itself. However, as we will see later in this section, it's not the only way we have to consume an iterator. JavaScript has, in fact, much more convenient and elegant ways to use<a id="_idIndexMarker758"/> iterators.</p>
    <div><p class="Information-Box--PACKT-">Iterators can <a id="_idIndexMarker759"/>optionally specify two additional methods: <code class="Code-In-Text--PACKT-">return([value])</code> and <code class="Code-In-Text--PACKT-">throw(error)</code>. The first is by convention used to signal to the iterator that the consumer has stopped the iteration before its completion, while the second is used to communicate to the iterator that an error condition has occurred. Both methods are rarely used by built-in iterators.</p>
    </div>
    <h2 id="_idParaDest-244" class="title">The iterable protocol</h2>
    <p class="normal">The <strong class="keyword">iterable protocol</strong> defines a <a id="_idIndexMarker760"/>standardized means for an object to return <a id="_idIndexMarker761"/>an iterator. Such objects are called <strong class="keyword">iterables</strong>. Usually, an iterable is a container of elements, such as a data structure, but it can also be an object <a id="_idIndexMarker762"/>virtually representing a set of elements, such as a <code class="Code-In-Text--PACKT-">Directory</code> object, which would allow us to iterate over the files in a directory.</p>
    <p class="normal">In JavaScript, we can define an iterable by making<a id="_idIndexMarker763"/> sure it implements the <strong class="codeHighlighted">@@iterator</strong><strong class="keyword"> method</strong>, or in other words, a method accessible through the built-in symbol <code class="Code-In-Text--PACKT-">Symbol.iterator</code>.</p>
    <div><p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">@@name</code> convention indicates a <em class="italic">well-known</em> symbol according to the ES6 specification. To find out more, you can check out the relative section of the ES6 specification at <a href="http://nodejsdp.link/es6-well-known-symbols">nodejsdp.link/es6-well-known-symbols</a>.</p>
    </div>
    <p class="normal">Such an <code class="Code-In-Text--PACKT-">@@iterator</code> method <a id="_idIndexMarker764"/>should return an iterator object, which can be used to iterate over the elements represented by the iterable. For example, if our iterable is a class, we would have something like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">class MyIterable {
  // other methods...
  [Symbol.iterator] () {
    // return an iterator
  }
}
</code></pre>
    <p class="normal">To show how this works in practice, let's build a class to manage information organized in a bidimensional matrix structure. We want this class to be implementing the iterable protocol, so that we can scan all the elements in the matrix using an iterator. Let's create a file called <code class="Code-In-Text--PACKT-">matrix.js</code> containing the following content:</p>
    <pre class="programlisting code"><code class="hljs-code">export class Matrix {
  constructor (inMatrix) {
    this.data = inMatrix
  }
  get (row, column) {
    if (row &gt;= this.data.length ||
      column &gt;= this.data[row].length) {
      throw new RangeError('Out of bounds')
    }
    return this.data[row][column]
  }
  set (row, column, value) {
    if (row &gt;= this.data.length ||
      column &gt;= this.data[row].length) {
      throw new RangeError('Out of bounds')
    }
    this.data[row][column] = value
  }
  [Symbol.iterator] () {
    let nextRow = 0
    let nextCol = 0
    return {
      next: () =&gt; {
        if (nextRow === this.data.length) {
          return { done: true }
        }
        const currVal = this.data[nextRow][nextCol]
        if (nextCol === this.data[nextRow].length - 1) {
          nextRow++
          nextCol = 0
        } else {
          nextCol++
        }
        return { value: currVal }
      }
    }
  }
}
</code></pre>
    <p class="normal">As we can see, the class contains the basic methods for getting and setting values in the matrix, as well as the <code class="Code-In-Text--PACKT-">@@iterator</code> method, implementing our iterable protocol. The <code class="Code-In-Text--PACKT-">@@iterator</code> method will return<a id="_idIndexMarker765"/> an iterator, as specified by the iterable protocol and such an iterator adheres to the iterator protocol. The logic of the iterator is very straightforward: we are<a id="_idIndexMarker766"/> simply traversing the matrix's cells from the top left to the bottom right, by scanning each column of each row; we are doing that by leveraging two indexes, <code class="Code-In-Text--PACKT-">nextRow</code> and <code class="Code-In-Text--PACKT-">nextCol</code>.</p>
    <p class="normal">Now, it's time to try out our iterable <code class="Code-In-Text--PACKT-">Matrix</code> class. We can do that in a file called <code class="Code-In-Text--PACKT-">index.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import { Matrix } from './matrix.js'
const matrix2x2 = new Matrix([
  ['11', '12'],
  ['21', '22']
])
const iterator = matrix2x2[Symbol.iterator]()
let iterationResult = iterator.next()
while (!iterationResult.done) {
  console.log(iterationResult.value)
  iterationResult = iterator.next()
}
</code></pre>
    <p class="normal">All we are doing in the previous code is creating a sample <code class="Code-In-Text--PACKT-">Matrix</code> instance and then obtaining an iterator using the <code class="Code-In-Text--PACKT-">@@iterator</code> method. What comes next, as we already know, is just boilerplate code that iterates over the elements returned by the iterator. The output of the iteration should be <code class="Code-In-Text--PACKT-">'11'</code>, <code class="Code-In-Text--PACKT-">'12'</code>, <code class="Code-In-Text--PACKT-">'21'</code>, <code class="Code-In-Text--PACKT-">'22'</code>.</p>
    <h2 id="_idParaDest-245" class="title">Iterators and iterables as a native JavaScript interface</h2>
    <p class="normal">At this point, you may ask: "what's<a id="_idIndexMarker767"/> the point of having all these <a id="_idIndexMarker768"/>protocols for defining iterators and iterables?" Well, having a standardized interface allows third party code as well as the language itself to be modeled around the two protocols we've just seen. This way, we can have APIs (even native) as well as syntax constructs accepting iterables as an input.</p>
    <p class="normal">For example, the most obvious syntax construct accepting an iterable is the <code class="Code-In-Text--PACKT-">for...of</code> loop. We've just seen in the last code sample that iterating over a JavaScript iterator is a pretty standard operation, and its code is mostly boilerplate. In fact, we'll always have an invocation to <code class="Code-In-Text--PACKT-">next()</code> to retrieve the next element and a check to verify if the <code class="Code-In-Text--PACKT-">done</code> property of the<a id="_idIndexMarker769"/> iteration result is set to <code class="Code-In-Text--PACKT-">true</code>, which indicates the end of the iteration. But, worry not, simply pass an iterable to the <code class="Code-In-Text--PACKT-">for...of</code> instruction to seamlessly loop over the elements returned <a id="_idIndexMarker770"/>by its iterator. This allows us to process the iteration with an intuitive and compact syntax:</p>
    <pre class="programlisting code"><code class="hljs-code">for (const element of matrix2x2) {
  console.log(element)
}
</code></pre>
    <p class="normal">Another construct compatible with iterables is the spread operator:</p>
    <pre class="programlisting code"><code class="hljs-code">const flattenedMatrix = [...matrix2x2]
console.log(flattenedMatrix)
</code></pre>
    <p class="normal">Similarly, we can use an<a id="_idIndexMarker771"/> iterable with the destructuring assignment operation:</p>
    <pre class="programlisting code"><code class="hljs-code">const [oneOne, oneTwo, twoOne, twoTwo] = matrix2x2
console.log(oneOne, oneTwo, twoOne, twoTwo)
</code></pre>
    <p class="normal">The following are some JavaScript built-in APIs accepting iterables:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Map([iterable])</code>: <a href="http://nodejsdp.link/map-constructor">nodejsdp.link/map-constructor</a></li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">WeakMap([iterable])</code>: <a href="http://nodejsdp.link/weakmap-constructor">nodejsdp.link/weakmap-constructor</a></li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Set([iterable])</code>: <a href="http://nodejsdp.link/set-constructor">nodejsdp.link/set-constructor</a></li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">WeakSet([iterable])</code>: <a href="http://nodejsdp.link/weakset-constructor">nodejsdp.link/weakset-constructor</a></li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Promise.all(iterable)</code>: <a href="http://nodejsdp.link/promise-all">nodejsdp.link/promise-all</a></li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">Promise.race(iterable)</code>: <a href="http://nodejsdp.link/promise-race">nodejsdp.link/promise-race</a></li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">Array.from(iterable)</code>: <a href="http://nodejsdp.link/array-from">nodejsdp.link/array-from</a></li>
    </ul>
    <p class="normal">On the Node.js side, one notable API accepting an iterable is <code class="Code-In-Text--PACKT-">stream.Readable.from(iterable, [options])</code> (<a href="http://nodejsdp.link/readable-from">nodejsdp.link/readable-from</a>), which creates a readable stream out of an iterable object.</p>
    <div><p class="Tip--PACKT-">Note that all the APIs and syntax constructs we've just seen accept as input an iterable and not an iterator. But, what can we do if we have a function returning an iterator, such as in our <code class="Code-In-Text--PACKT-">createAlphabetIterator()</code> example? How can we leverage all the built-in APIs and syntax constructs? A possible solution is implementing the <code class="Code-In-Text--PACKT-">@@iterator</code> method in the iterator object itself, which will simply return the iterator object itself. This way we'll be able to write something such as the following:</p>
      <pre class="programlisting code"><code class="hljs-code">for (const letter of createAlphabetIterator()) {
  //...
}
</code></pre>
    </div>
    <p class="normal">JavaScript itself defines<a id="_idIndexMarker772"/> many iterables that can be used with the APIs and constructs we've just seen. The most notable iterable is <code class="Code-In-Text--PACKT-">Array</code>, but also other data<a id="_idIndexMarker773"/> structures, such as <code class="Code-In-Text--PACKT-">Map</code> and <code class="Code-In-Text--PACKT-">Set</code>, and even <code class="Code-In-Text--PACKT-">String</code> all implement the <code class="Code-In-Text--PACKT-">@@iterable</code> method. In Node.js land, <code class="Code-In-Text--PACKT-">Buffer</code> is probably the most notable iterable.</p>
    <div><p class="Tip--PACKT-">A trick to make sure that an array doesn't contain duplicate elements is the following: <code class="Code-In-Text--PACKT-">const uniqArray = Array.from(new Set(arrayWithDuplicates))</code>. This also shows us how iterables offer a way for different components to talk to each other using a shared interface.</p>
    </div>
    <h2 id="_idParaDest-246" class="title">Generators</h2>
    <p class="normal">The ES2015 specification introduced a syntax construct that is closely related to iterators. We are talking about <strong class="keyword">generators</strong>, also known <a id="_idIndexMarker774"/>as <strong class="keyword">semicoroutines</strong>. They are a generalization of standard functions, in which there can be different entry points. In a standard function, we can have<a id="_idIndexMarker775"/> only one entry point, which corresponds to the invocation of the function itself, but a generator can be suspended (using the <code class="Code-In-Text--PACKT-">yield</code> statement) and then resumed at a later time. Among other things, generators are very well suited to implement iterators, in fact, as we will see in a bit, the generator object returned by a generator function is indeed both an iterator and an iterable.</p>
    <h3 id="_idParaDest-247" class="title">Generators in theory</h3>
    <p class="normal">To<a id="_idIndexMarker776"/> define a <strong class="keyword">generator function</strong>, we <a id="_idIndexMarker777"/>need to use the <code class="Code-In-Text--PACKT-">function*</code> declaration (the <code class="Code-In-Text--PACKT-">function</code> keyword followed by an asterisk):</p>
    <pre class="programlisting code"><code class="hljs-code">function * myGenerator () {
  // generator body
}
</code></pre>
    <p class="normal">Invoking a generator function will not execute its body immediately. Rather, it will return a <strong class="keyword">generator object</strong>, which, as we <a id="_idIndexMarker778"/>already mentioned, is both an iterator and an iterable. But it doesn't end here; invoking <code class="Code-In-Text--PACKT-">next()</code> on the generator object will start or resume the execution<a id="_idIndexMarker779"/> of the generator until the <code class="Code-In-Text--PACKT-">yield</code> instruction is invoked or the generator returns (either implicitly or explicitly with a <code class="Code-In-Text--PACKT-">return</code> instruction). Within the generator, using the keyword <code class="Code-In-Text--PACKT-">yield</code> followed by a value <code class="Code-In-Text--PACKT-">x</code> is equivalent to returning <code class="Code-In-Text--PACKT-">{done: false, value: x}</code> from the iterator, while returning a value <code class="Code-In-Text--PACKT-">x</code> is equivalent to returning <code class="Code-In-Text--PACKT-">{done: true, value: x}</code>.</p>
    <h3 id="_idParaDest-248" class="title">A simple generator function</h3>
    <p class="normal">To demonstrate what we<a id="_idIndexMarker780"/> just learned, let's see a simple generator called <code class="Code-In-Text--PACKT-">fruitGenerator()</code>, which will yield two names of fruits and return their ripening season:</p>
    <pre class="programlisting code"><code class="hljs-code">function * fruitGenerator () {
  yield 'peach'
  yield 'watermelon'
  return 'summer'
}
const fruitGeneratorObj = fruitGenerator()
console.log(fruitGeneratorObj.next())                      // (1)
console.log(fruitGeneratorObj.next())                      // (2)
console.log(fruitGeneratorObj.next())                      // (3)
</code></pre>
    <p class="normal">The preceding code will print the following text:</p>
    <pre class="programlisting con"><code class="hljs-con">    { value: 'peach', done: false }
    { value: 'watermelon', done: false }
    { value: 'summer', done: true }
</code></pre>
    <p class="normal">This is a short explanation of what happened:</p>
    <ol>
      <li class="numbered">The first time <code class="Code-In-Text--PACKT-">fruitGeneratorObj.next()</code> was invoked, the generator started its execution until it reached the first <code class="Code-In-Text--PACKT-">yield</code> command, which put the generator on pause and returned the value <code class="Code-In-Text--PACKT-">'peach'</code> to the caller.</li>
      <li class="numbered">At the second invocation of <code class="Code-In-Text--PACKT-">fruitGeneratorObj.next()</code>, the generator resumed, starting from the second <code class="Code-In-Text--PACKT-">yield</code> command, which in turn put the execution on pause again, while returning the value <code class="Code-In-Text--PACKT-">'watermelon'</code> to the caller.</li>
      <li class="numbered">The last invocation of <code class="Code-In-Text--PACKT-">fruitGeneratorObj.next()</code> caused the execution of the generator to resume from its last instruction, a <code class="Code-In-Text--PACKT-">return</code> statement, which terminates the generator, returns the value <code class="Code-In-Text--PACKT-">'summer'</code>, and sets the <code class="Code-In-Text--PACKT-">done</code> property to <code class="Code-In-Text--PACKT-">true</code> in the <code class="Code-In-Text--PACKT-">result</code> object.</li>
    </ol>
    <p class="normal">Since a generator<a id="_idIndexMarker781"/> object is also an iterable, we can use it in a <code class="Code-In-Text--PACKT-">for...of</code> loop. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">for (const fruit of fruitGenerator()) {
  console.log(fruit)
}
</code></pre>
    <p class="normal">The preceding loop will print:</p>
    <pre class="programlisting con"><code class="hljs-con">peach
watermelon
</code></pre>
    <div><p class="Information-Box--PACKT-">Why is <code class="Code-In-Text--PACKT-">summer</code> not being printed? Well, <code class="Code-In-Text--PACKT-">summer</code> is not yielded by our generator, but instead, it is returned, which indicates that the iteration is complete with <code class="Code-In-Text--PACKT-">summer</code> as a return value (not as an element).</p>
    </div>
    <h3 id="_idParaDest-249" class="title">Controlling a generator iterator</h3>
    <p class="normal">Generator objects are <a id="_idIndexMarker782"/>more than standard iterators, in fact, their <code class="Code-In-Text--PACKT-">next()</code> method optionally accepts an argument (whereas, as specified by the iterator protocol, it does not need to accept one). Such an argument is passed as the return value of the <code class="Code-In-Text--PACKT-">yield</code> instruction. To show this, let's create a new simple generator:</p>
    <pre class="programlisting code"><code class="hljs-code">function * twoWayGenerator () {
  const what = yield null
  yield 'Hello ' + what
}
const twoWay = twoWayGenerator()
twoWay.next()
console.log(twoWay.next('world'))
</code></pre>
    <p class="normal">When executed, the preceding code prints <code class="Code-In-Text--PACKT-">Hello world</code>. This means that the following has happened:</p>
    <ol>
      <li class="numbered">The first time the <code class="Code-In-Text--PACKT-">next()</code> method is invoked, the generator reaches the first <code class="Code-In-Text--PACKT-">yield</code> statement and is then put on pause.</li>
      <li class="numbered">When <code class="Code-In-Text--PACKT-">next('world')</code> is invoked, the generator resumes from the point where it was put on pause, which is on the <code class="Code-In-Text--PACKT-">yield</code> instruction, but this time we have a value that is passed back to the generator. This value will then be set to the <code class="Code-In-Text--PACKT-">what</code> variable. The generator then appends the <code class="Code-In-Text--PACKT-">what</code> variable to the string <code class="Code-In-Text--PACKT-">'Hello '</code> and yields the result.</li>
    </ol>
    <p class="normal">Two other extra features <a id="_idIndexMarker783"/>provided by generator objects are the optional <code class="Code-In-Text--PACKT-">throw()</code> and <code class="Code-In-Text--PACKT-">return()</code> iterator methods. The first behaves like <code class="Code-In-Text--PACKT-">next()</code> but it will also throw an exception within the generator as if it was thrown at the point of the last <code class="Code-In-Text--PACKT-">yield</code>, and returns the canonical iterator object with the <code class="Code-In-Text--PACKT-">done</code> and <code class="Code-In-Text--PACKT-">value</code> properties. The second, the <code class="Code-In-Text--PACKT-">return()</code> method, forces the generator to terminate and returns an object such as the following: <code class="Code-In-Text--PACKT-">{done: true, value: returnArgument}</code> where <code class="Code-In-Text--PACKT-">returnArgument</code> is the argument passed to the <code class="Code-In-Text--PACKT-">return()</code> method.</p>
    <p class="normal">The following code shows a demonstration of these two methods:</p>
    <pre class="programlisting code"><code class="hljs-code">function * twoWayGenerator () {
  try {
    const what = yield null
    yield 'Hello ' + what
  } catch (err) {
    yield 'Hello error: ' + err.message
  }
}
console.log('Using throw():')
const twoWayException = twoWayGenerator()
twoWayException.next()
console.log(twoWayException.throw(new Error('Boom!')))
console.log('Using return():')
const twoWayReturn = twoWayGenerator()
console.log(twoWayReturn.return('myReturnValue'))
</code></pre>
    <p class="normal">Running the previous code will print the following to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Using throw():
{ value: 'Hello error: Boom!', done: false }
Using return():
{ value: 'myReturnValue', done: true }
</code></pre>
    <p class="normal">As we can see, the <code class="Code-In-Text--PACKT-">twoWayGenerator()</code> function will receive an exception as soon as the first <code class="Code-In-Text--PACKT-">yield</code> instruction returns. This works exactly as if an exception was thrown from inside the generator, and this means<a id="_idIndexMarker784"/> that it can be caught and handled like any other exception using a <code class="Code-In-Text--PACKT-">try...catch</code> block. The <code class="Code-In-Text--PACKT-">return()</code> method, instead, will simply stop the execution of the generator causing the given value to be provided as a return value by the generator.</p>
    <h3 id="_idParaDest-250" class="title">How to use generators in place of iterators</h3>
    <p class="normal">Generator objects are also iterators. This means<a id="_idIndexMarker785"/> that generator functions can be used to implement the <code class="Code-In-Text--PACKT-">@@iterator</code> method of iterable objects. To demonstrate this, let's convert our previous <code class="Code-In-Text--PACKT-">Matrix</code> iteration example to generators. Let's update our <code class="Code-In-Text--PACKT-">matrix.js</code> file as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">export class Matrix {
  // ...rest of the methods (stay unchanged)
  * [Symbol.iterator] () {                                 // (1)
    let nextRow = 0                                        // (2)
    let nextCol = 0
    while (nextRow !== this.data.length) {                 // (3)
      yield this.data[nextRow][nextCol]
      if (nextCol === this.data[nextRow].length - 1) {
        nextRow++
        nextCol = 0
      } else {
        nextCol++
      }
    }
  }
}
</code></pre>
    <p class="normal">There are a few interesting aspects in the code fragment we've just seen. Let's analyze them in more detail:</p>
    <ol>
      <li class="numbered">The first thing to notice is that the <code class="Code-In-Text--PACKT-">@@iterator</code> method is now a generator (note the asterisk <code class="Code-In-Text--PACKT-">*</code> before the method name).</li>
      <li class="numbered">The variables we use to maintain the state of the iteration are now just local variables for the generator, while in the previous version of the <code class="Code-In-Text--PACKT-">Matrix</code> class, those two variables were part of a closure. This is possible because when a generator is invoked, its local state is preserved between reentries.</li>
      <li class="numbered">We are using a standard loop to iterate over the elements of the matrix. This is certainly more intuitive than trying to imagine a loop that invokes the <code class="Code-In-Text--PACKT-">next()</code> method of an iterator.</li>
    </ol>
    <p class="normal">As we can see, generators<a id="_idIndexMarker786"/> are an excellent alternative to writing iterators from scratch. They will improve the readability of our iteration routine and will offer the <a id="_idIndexMarker787"/>same level of functionality (or even better).</p>
    <div><p class="Tip--PACKT-">The <strong class="keyword">generator delegation</strong> instruction, <code class="Code-In-Text--PACKT-">yield * iterable</code>, is another example of a JavaScript built-in syntax accepting an iterable as an argument. The instruction will loop over the elements of the iterable and yield each element one by one.</p>
    </div>
    <h2 id="_idParaDest-251" class="title">Async iterators</h2>
    <p class="normal">The iterators we've seen so <a id="_idIndexMarker788"/>far return a value synchronously from their <code class="Code-In-Text--PACKT-">next()</code> method. However, in JavaScript and especially in Node.js, it's very common to have iterations over items that require an asynchronous operation to be produced.</p>
    <p class="normal">Imagine, for example, to iterate<a id="_idIndexMarker789"/> over the requests received by an HTTP server, or over the results of an SQL query, or over the elements of a paginated REST API. In all those situations, it would be handy to be able to return a promise from the <code class="Code-In-Text--PACKT-">next()</code> method of an iterator, or even better, use the async/await construct.</p>
    <p class="normal">Well, that's exactly what <strong class="keyword">async iterators</strong> are; they are iterators returning a promise, and since that's the only extra requirement, it means that we can also use an async function to define the <code class="Code-In-Text--PACKT-">next()</code> method of the<a id="_idIndexMarker790"/> iterator. Similarly, <strong class="keyword">async iterables</strong> are objects that implement an <code class="Code-In-Text--PACKT-">@@asyncIterator</code> method, or in other words, a method accessible through the <code class="Code-In-Text--PACKT-">Symbol.asyncIterator</code> key, which returns (synchronously) an async iterator.</p>
    <p class="normal">Async iterables can<a id="_idIndexMarker791"/> be looped over using the <code class="Code-In-Text--PACKT-">for await...of</code> syntax, which can only be used inside an async function. With the <code class="Code-In-Text--PACKT-">for await...of</code> syntax, we are essentially implementing a sequential asynchronous execution flow on top of the Iterator pattern. Essentially, it's just syntactic sugar for the following loop:</p>
    <pre class="programlisting code"><code class="hljs-code">const asyncIterator = iterable[Symbol.asyncIterator]()
let iterationResult = await asyncIterator.next()
while (!iterationResult.done) {
  console.log(iterationResult.value)
  iterationResult = await asyncIterator.next()
}
</code></pre>
    <p class="normal">This means that the <code class="Code-In-Text--PACKT-">for await...of</code> syntax can also be used to iterate over a simple iterable (not just async iterables) as, for example, over an array of promises. It will work even if not all the elements (or none) of the iterator are promises.</p>
    <p class="normal">To quickly<a id="_idIndexMarker792"/> demonstrate this, let's build a class that takes a list of URLs as input and allows us to iterate over their availability status (<code class="Code-In-Text--PACKT-">up</code>/<code class="Code-In-Text--PACKT-">down</code>). Let's call the class <code class="Code-In-Text--PACKT-">CheckUrls</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import superagent from 'superagent'
export class CheckUrls {
  constructor (urls) {                                     // (1)
    this.urls = urls
  }
  [Symbol.asyncIterator] () {
    const urlsIterator = this.urls[Symbol.iterator]()      // (2)
    return {
      async next () {                                      // (3)
        const iteratorResult = urlsIterator.next()         // (4)
        if (iteratorResult.done) {
          return { done: true }
        }
        const url = iteratorResult.value
        try {
          const checkResult = await superagent             // (5)
            .head(url)
            .redirects(2)
          return {
            done: false,
            value: `${url} is up, status: ${checkResult.status}`
          }
        } catch (err) {
          return {
            done: false,
            value: `${url} is down, error: ${err.message}`
          }
        }
      }
    }
  }
}
</code></pre>
    <p class="normal">Let's analyze the previous <a id="_idIndexMarker793"/>code's most important parts:</p>
    <ol>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">CheckUrls</code> class constructor takes as input a list of URLs. Since we now know how to use iterators and iterables, we can say that this list of URLs can be just any iterable.</li>
      <li class="numbered">In our <code class="Code-In-Text--PACKT-">@@asyncIterator</code> method, we obtain an iterator from the <code class="Code-In-Text--PACKT-">this.urls</code> object, which, as we just said, should be an iterable. We can do that by simply invoking its <code class="Code-In-Text--PACKT-">@@iterable</code> method.</li>
      <li class="numbered">Note how the <code class="Code-In-Text--PACKT-">next()</code> method is now an <code class="Code-In-Text--PACKT-">async</code> function. This means that it will always return a promise, as requested by the async iterable protocol.</li>
      <li class="numbered">In the <code class="Code-In-Text--PACKT-">next()</code> method, we use the <code class="Code-In-Text--PACKT-">urlsIterator</code> to get the next URL in the list, unless there are no more, in which case we simply return <code class="Code-In-Text--PACKT-">{done: true}</code>.</li>
      <li class="numbered">Note how we can now use the <code class="Code-In-Text--PACKT-">await</code> instruction to asynchronously get the result of the <code class="Code-In-Text--PACKT-">HEAD</code> request sent to the current URL.</li>
    </ol>
    <p class="normal">Now, let's use the <code class="Code-In-Text--PACKT-">for await...of</code> syntax we mentioned earlier to iterate over a <code class="Code-In-Text--PACKT-">CheckUrls</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">import { CheckUrls } from './checkUrls.js'
async function main () {
  const checkUrls = new CheckUrls([
    'https://nodejsdesignpatterns.com',
    'https://example.com',
    'https://mustbedownforsurehopefully.com'
  ])
  for await (const status of checkUrls) {
    console.log(status)
  }
}
main()
</code></pre>
    <p class="normal">As we can see, the <code class="Code-In-Text--PACKT-">for await...of</code> syntax is a very intuitive way to iterate over an async iterable and, as we will see in a while, it can be used in conjunction with some interesting built-in iterables to obtain <a id="_idIndexMarker794"/>alternative new ways to access asynchronous information.</p>
    <div><p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">for await...of</code> loop (as well as its synchronous version) will call the optional <code class="Code-In-Text--PACKT-">return()</code> method of the iterator if it's prematurely interrupted with a <code class="Code-In-Text--PACKT-">break</code>, a <code class="Code-In-Text--PACKT-">return</code>, or an <code class="Code-In-Text--PACKT-">exception</code>. This can be used to immediately perform any cleanup task that would usually be performed when the iteration completes.</p>
    </div>
    <h2 id="_idParaDest-252" class="title">Async generators</h2>
    <p class="normal">As well as <a id="_idIndexMarker795"/>async iterators, we<a id="_idIndexMarker796"/> can also have <strong class="keyword">async generators</strong>. To define an <strong class="keyword">async generator function</strong>, simply <a id="_idIndexMarker797"/>prepend the keyword <code class="Code-In-Text--PACKT-">async</code> to the function definition:</p>
    <pre class="programlisting code"><code class="hljs-code">async function * generatorFunction() {
  // ...generator body
}
</code></pre>
    <p class="normal">As you can well imagine, async generators allow the use of the <code class="Code-In-Text--PACKT-">await</code> instruction within their body and the return value of their <code class="Code-In-Text--PACKT-">next()</code> method is a promise that resolves to an object having the canonical <code class="Code-In-Text--PACKT-">done</code> and <code class="Code-In-Text--PACKT-">value</code> properties. This <a id="_idIndexMarker798"/>way, <strong class="keyword">async generator objects</strong> are also valid async iterators. They are also valid async iterables, so they can be used in <code class="Code-In-Text--PACKT-">for await...of</code> loops.</p>
    <p class="normal">To demonstrate how async generators can simplify the implementation of async iterators, let's convert the <code class="Code-In-Text--PACKT-">CheckUrls</code> class we saw in the previous example to use an async generator:</p>
    <pre class="programlisting code"><code class="hljs-code">export class CheckUrls {
  constructor (urls) {
    this.urls = urls
  }
  async * [Symbol.asyncIterator] () {
    for (const url of this.urls) {
      try {
        const checkResult = await superagent
          .head(url)
          .redirects(2)
        yield `${url} is up, status: ${checkResult.status}`
      } catch (err) {
        yield `${url} is down, error: ${err.message}`
      }
    }
  }
}
</code></pre>
    <p class="normal">Interestingly, using an <a id="_idIndexMarker799"/>async generator in place of a bare async iterator allowed us to save a few lines of code and the resulting logic is also more readable and explicit.</p>
    <h2 id="_idParaDest-253" class="title">Async iterators and Node.js streams</h2>
    <p class="normal">If we stop for a second and<a id="_idIndexMarker800"/> think about the relationship between async iterators and Node.js readable streams, we would be surprised by how similar they are in both purpose and behavior. In fact, we can say that async iterators are indeed a stream construct, as they can be used to process the data of an asynchronous resource piece by piece, exactly as it happens for readable streams.</p>
    <p class="normal">It's not a coincidence that <code class="Code-In-Text--PACKT-">stream.Readable</code> implements the <code class="Code-In-Text--PACKT-">@@asyncIterator</code> method, making it an async iterable. This provides us with an additional, and probably even more intuitive, mechanism to read data from a readable stream, thanks to the <code class="Code-In-Text--PACKT-">for await...of</code> construct.</p>
    <p class="normal">To quickly demonstrate this, consider the following example where we take the <code class="Code-In-Text--PACKT-">stdin</code> stream of the current process and we pipe it into the <code class="Code-In-Text--PACKT-">split()</code> transform stream, which will emit a new chunk when it finds a newline character. Then, we iterate over each line using the <code class="Code-In-Text--PACKT-">for await...of</code> loop:</p>
    <pre class="programlisting code"><code class="hljs-code">import split from 'split2'
async function main () {
  const stream = process.stdin.pipe(split())
  for await (const line of stream) {
    console.log(`You wrote: ${line}`)
  }
}
main()
</code></pre>
    <p class="normal">This sample code will print back whatever we have written to the standard input only after we have pressed the Return key. To quit the program, you can just press Ctrl + C.</p>
    <p class="normal">As we can see, this alternative way of consuming a readable stream is indeed very intuitive and compact. The previous example also shows us how similar the two paradigms—iterators<a id="_idIndexMarker801"/> and streams—are. They are so similar that they can interoperate almost seamlessly. To prove this point even further, just consider that the function <code class="Code-In-Text--PACKT-">stream.Readable.from(iterable, [options])</code> takes an iterable as an argument, which can be both synchronous or asynchronous. The function will return a readable stream that wraps the provided iterable, "adapting" its interface to that of a readable stream (this is also a good example of the Adapter pattern, which we have already met in <em class="chapterRef">Chapter 8</em>, <em class="italic">Structural Design Patterns</em>.</p>
    <p class="normal">So, if streams and async iterators as so closely related, which one should you actually use? This, as always, depends on the use case and many other factors; however, to help you with the decision, this is a list of aspects that set the two constructs apart:</p>
    <ul>
      <li class="Bullet--PACKT-">Streams are <em class="italic">push</em>, meaning that data is pushed into the internal buffers by the stream and then consumed from the buffers. Async iterators are <em class="italic">pull</em> by default (unless another logic is explicitly implemented by the iterator), meaning that data is only retrieved/produced on demand by the consumer.</li>
      <li class="Bullet--PACKT-">Streams are better suited to process binary data since they natively provide internal buffering and backpressure.</li>
      <li class="Bullet-End--PACKT-">Streams can be composed using a well-known and streamlined API, <code class="Code-In-Text--PACKT-">pipe()</code>, while async iterators do not offer any standardized composition method.</li>
    </ul>
    <div><p class="Tip--PACKT-">We can iterate an <code class="Code-In-Text--PACKT-">EventEmitter</code> as well. Using the <code class="Code-In-Text--PACKT-">events.on(emitter, eventName)</code> utility function, we can in fact get an async iterable whose iterator will return all the events matching the specified <code class="Code-In-Text--PACKT-">eventName</code>.</p>
    </div>
    <h2 id="_idParaDest-254" class="title">In the wild</h2>
    <p class="normal">Iterators and, in particular, async iterators are quickly gaining popularity in the Node.js ecosystem. In fact, in many <a id="_idIndexMarker802"/>circumstances, they are becoming a preferred alternative to streams and are replacing custom-built iteration mechanisms.</p>
    <p class="normal">For example, the packages <code class="Code-In-Text--PACKT-">@databases/pg</code>, <code class="Code-In-Text--PACKT-">@databases/mysql</code> and <code class="Code-In-Text--PACKT-">@databases/sqlite</code> are popular libraries for accessing Postgres, MySQL, and SQLite databases respectively (more at <a href="http://nodejsdp.link/atdatabases">nodejsdp.link/atdatabases</a>). </p>
    <p class="normal">They all expose<a id="_idIndexMarker803"/> a function called <code class="Code-In-Text--PACKT-">queryStream()</code>, which returns an async iterable, which can be used to easily iterate over the results of a query. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">for await (const record of db.queryStream(sql`SELECT * FROM my_table`)) {
  // do something with record
}
</code></pre>
    <p class="normal">Internally, the iterator will automatically handle the cursor for a query result, so all we have to do is simply loop with the <code class="Code-In-Text--PACKT-">for await...of</code> construct.</p>
    <p class="normal">Another example of a library heavily relying<a id="_idIndexMarker804"/> on iterators for its API is the <code class="Code-In-Text--PACKT-">zeromq</code> package (<a href="http://nodejsdp.link/npm-zeromq">nodejsdp.link/npm-zeromq</a>). We'll see a detailed example of it in the next section, about the Middleware pattern, as we move on to other behavioral patterns.</p>
    <h1 id="_idParaDest-255" class="title">Middleware</h1>
    <p class="normal">One of the most <a id="_idIndexMarker805"/>distinctive patterns in Node.js is definitely <strong class="keyword">Middleware</strong>. Unfortunately, it's also one of the most confusing for the inexperienced, especially for developers coming from the enterprise programming world. The<a id="_idIndexMarker806"/> reason for the disorientation is probably connected to the traditional meaning of the term middleware, which in enterprise architecture jargon represents the various software suites that help to abstract lower-level mechanisms such as OS APIs, network communications, memory management, and so on, allowing the developer to focus only on the business case of the application. In this context, the term middleware recalls topics such as CORBA, enterprise service bus, Spring, JBoss, and WebSphere, but in its more generic meaning, it can also define any kind of software layer that acts as glue between lower-level services and the application (literally, the <em class="italic">software in the middle</em>).</p>
    <h2 id="_idParaDest-256" class="title">Middleware in Express</h2>
    <p class="normal">Express (<a href="http://nodejsdp.link/express">nodejsdp.link/express</a>) popularized<a id="_idIndexMarker807"/> the term middleware in the Node.js world, binding it to a very specific design pattern. In Express, in fact, middleware<a id="_idIndexMarker808"/> represents a set of services, typically functions, that are organized in a pipeline and are responsible for processing incoming<a id="_idIndexMarker809"/> HTTP requests and relative responses.</p>
    <p class="normal">Express is famous for being a very non-opinionated and minimalist web framework and the Middleware pattern is the main reason for that. Express middleware is, in fact, an effective strategy for allowing developers to easily create and distribute new features that can be easily added to an application, without the need to grow the minimalistic core of the framework.</p>
    <p class="normal">An Express middleware has the following signature:</p>
    <pre class="programlisting code"><code class="hljs-code">function (req, res, next) { ... }
</code></pre>
    <p class="normal">Here, <code class="Code-In-Text--PACKT-">req</code> is the incoming HTTP request, <code class="Code-In-Text--PACKT-">res</code> is the response, and <code class="Code-In-Text--PACKT-">next</code> is the callback to be invoked when the current middleware has completed its tasks, and that in turn triggers the next middleware in the pipeline.</p>
    <p class="normal">Examples of the tasks carried out by Express middleware include the following:</p>
    <ul>
      <li class="Bullet--PACKT-">Parsing the body of the request</li>
      <li class="Bullet--PACKT-">Compressing/decompressing requests and responses</li>
      <li class="Bullet--PACKT-">Producing access logs</li>
      <li class="Bullet--PACKT-">Managing sessions</li>
      <li class="Bullet--PACKT-">Managing encrypted cookies</li>
      <li class="Bullet-End--PACKT-">Providing <strong class="keyword">Cross-Site Request Forgery</strong> (<strong class="keyword">CSRF</strong>) protection</li>
    </ul>
    <p class="normal">If we think about it, these are all tasks that are not strictly related to the main business logic of an application, nor are they essential parts of the minimal core of a web server. They are accessories, components providing support to the rest of the application and allowing the actual request handlers to focus only on their main business logic. Essentially, those tasks are "software in the middle."</p>
    <h2 id="_idParaDest-257" class="title">Middleware as a pattern</h2>
    <p class="normal">The technique used to<a id="_idIndexMarker810"/> implement middleware in Express is not<a id="_idIndexMarker811"/> new, in fact, it can be considered the Node.js incarnation of the <strong class="keyword">Intercepting Filter</strong> pattern and<a id="_idIndexMarker812"/> the <strong class="keyword">Chain of Responsibility</strong> pattern. In more generic terms, it also represents a processing <strong class="keyword">pipeline</strong>, which reminds<a id="_idIndexMarker813"/> us of streams. Today, in Node.js, the word middleware is used well beyond the boundaries of the Express framework, and indicates a particular pattern whereby a set of processing units, filters, and handlers, under the form of functions, are connected to form an asynchronous sequence in order to perform the preprocessing and postprocessing of any kind of data. The main advantage of this pattern is <em class="italic">flexibility</em>. In fact, the Middleware pattern allows us to obtain a plugin<a id="_idIndexMarker814"/> infrastructure with incredibly little effort, providing an unobtrusive way to extend a system with new filters and handlers.</p>
    <div><p class="Information-Box--PACKT-">If you want to know more about the Intercepting Filter pattern, the following article is a <a id="_idIndexMarker815"/>good starting point: <a href="http://nodejsdp.link/intercepting-filter">nodejsdp.link/intercepting-filter</a>. Similarly, a nice overview of the Chain of Responsibility pattern is<a id="_idIndexMarker816"/> available at this URL: <a href="http://nodejsdp.link/chain-of-responsibility">nodejsdp.link/chain-of-responsibility</a>.</p>
    </div>
    <p class="normal">The following diagram shows the components of the Middleware pattern:</p>
    <figure class="mediaobject"><img src="img/B15729_09_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.5: The structure of the Middleware pattern</p>
    <p class="normal">The essential component of the <a id="_idIndexMarker817"/>pattern is the <strong class="keyword">Middleware Manager</strong>, which is responsible for organizing and executing the middleware functions. The most important implementation details of the pattern are as follows:</p>
    <ul>
      <li class="Bullet--PACKT-">New middleware can be registered by invoking the <code class="Code-In-Text--PACKT-">use()</code> function (the name of this function is a common convention in many implementations of the Middleware pattern, but we can choose any name). Usually, new middleware can only be appended at <a id="_idIndexMarker818"/>the end of the pipeline, but this is not a strict rule.</li>
      <li class="Bullet--PACKT-">When new data is received for processing, the registered middleware is invoked in an asynchronous sequential execution flow. Each unit in the pipeline receives the result of the execution of the previous unit as input.</li>
      <li class="Bullet-End--PACKT-">Each piece of middleware can decide to stop further processing of the data. This can be done by invoking a special function, by not invoking the callback (in case the middleware uses callbacks), or by propagating an error. An error situation usually triggers the execution of another sequence of middleware that is specifically dedicated to handling errors.</li>
    </ul>
    <p class="normal">There is no strict rule on how the data is processed and propagated in the pipeline. The strategies for propagating the data modifications in the pipeline include:</p>
    <ul>
      <li class="Bullet--PACKT-">Augmenting the data received as input with additional properties or functions</li>
      <li class="Bullet-End--PACKT-">Maintaining the immutability of the data and always return fresh copies as the result of the processing</li>
    </ul>
    <p class="normal">The right approach depends on the way the Middleware Manager is implemented and on the type of processing carried out by the middleware itself.</p>
    <h2 id="_idParaDest-258" class="title">Creating a middleware framework for ZeroMQ</h2>
    <p class="normal">Let's now demonstrate the pattern <a id="_idIndexMarker819"/>by building a middleware framework around the <strong class="keyword">ZeroMQ</strong> (<a href="http://nodejsdp.link/zeromq">nodejsdp.link/zeromq</a>) messaging library. ZeroMQ (also <a id="_idIndexMarker820"/>known as ZMQ, or ØMQ) provides a simple interface for exchanging atomic messages<a id="_idIndexMarker821"/> across the network using a variety of protocols. It shines for its<a id="_idIndexMarker822"/> performance, and its <a id="_idIndexMarker823"/>basic set of abstractions are specifically built to facilitate the implementation of custom messaging architectures. For this reason, ZeroMQ is often chosen to <a id="_idIndexMarker824"/>build complex distributed systems.</p>
    <div><p class="Tip--PACKT-">In <em class="chapterRef">Chapter 13</em>, <em class="italic">Messaging and Integration Patterns</em>, we will have the chance to analyze the features of ZeroMQ in more detail.</p>
    </div>
    <p class="normal">The interface of ZeroMQ is pretty low-level as it only allows us to use strings and binary buffers for messages. So, any encoding or custom formatting of data has to be implemented by the users of the library.</p>
    <p class="normal">In the next example, we are going to build a middleware infrastructure to abstract the preprocessing and postprocessing of<a id="_idIndexMarker825"/> the data passing through a ZeroMQ socket, so that we can transparently work with JSON objects, but also seamlessly compress messages traveling over the<a id="_idIndexMarker826"/> wire.</p>
    <h3 id="_idParaDest-259" class="title">The Middleware Manager</h3>
    <p class="normal">The first step<a id="_idIndexMarker827"/> toward building a middleware infrastructure around ZeroMQ is to create a component that is responsible for executing the middleware pipeline when a new message is received or sent. For this purpose, let's create a new module called <code class="Code-In-Text--PACKT-">zmqMiddlewareManager.js</code> and let's define it:</p>
    <pre class="programlisting code"><code class="hljs-code">export class ZmqMiddlewareManager {
  constructor (socket) {                                     // (1)
    this.socket = socket
    this.inboundMiddleware = []
    this.outboundMiddleware = []
    this.handleIncomingMessages()
      .catch(err =&gt; console.error(err))
  }
  async handleIncomingMessages () {                          // (2)
    for await (const [message] of this.socket) {
      await this
        .executeMiddleware(this.inboundMiddleware, message)
        .catch(err =&gt; {
          console.error('Error while processing the message', err)
        })
    }
  }
  async send (message) {                                     // (3)
    const finalMessage = await this
      .executeMiddleware(this.outboundMiddleware, message)
    return this.socket.send(finalMessage)
  }
  use (middleware) {                                         // (4)
    if (middleware.inbound) {
      this.inboundMiddleware.push(middleware.inbound)
    }
    if (middleware.outbound) {
      this.outboundMiddleware.unshift(middleware.outbound)
    }
  }
  async executeMiddleware (middlewares, initialMessage) {    // (5)
    let message = initialMessage
    for await (const middlewareFunc of middlewares) {
      message = await middlewareFunc.call(this, message)
    }
    return message
  }
}
</code></pre>
    <p class="normal">Let's discuss in detail how we implemented our <code class="Code-In-Text--PACKT-">ZmqMiddlewareManager</code>:</p>
    <ol>
      <li class="numbered">In the first part of the <a id="_idIndexMarker828"/>class, we define the constructor that accepts a ZeroMQ socket as an argument. In the constructor, we create two empty lists that will contain our middleware functions, one for inbound messages and another one for outbound messages. Next, we immediately start processing the messages coming from the socket. We do that in the <code class="Code-In-Text--PACKT-">handleIncomingMessages()</code> method.</li>
      <li class="numbered">In the <code class="Code-In-Text--PACKT-">handleIncomingMessages()</code> method, we use the ZeroMQ socket as an async iterable and with a <code class="Code-In-Text--PACKT-">for await...of</code> loop, we process any incoming message and we pass it down the <code class="Code-In-Text--PACKT-">inboundMiddleware</code> list of middlewares.</li>
      <li class="numbered">Similarly to <code class="Code-In-Text--PACKT-">handleIncomingMessages()</code>, the <code class="Code-In-Text--PACKT-">send()</code> method will pass the <code class="Code-In-Text--PACKT-">message</code> received as an argument down the <code class="Code-In-Text--PACKT-">outboundMiddleware</code> pipeline. The result of the processing is stored in the <code class="Code-In-Text--PACKT-">finalMessage</code> variable and then sent through the socket.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">use()</code> method is used for appending new middleware functions to our internal pipelines. In our implementation, each middleware comes in pairs; it's an object that contains two properties, <code class="Code-In-Text--PACKT-">inbound</code> and <code class="Code-In-Text--PACKT-">outbound</code>. Each property can be used to define the middleware function to be added to the respective list. It's important to observe here that the inbound middleware is pushed to the end of the <code class="Code-In-Text--PACKT-">inboundMiddleware</code> list, while the outbound middleware is inserted (using <code class="Code-In-Text--PACKT-">unshift()</code>) at the beginning of the <code class="Code-In-Text--PACKT-">outboundMiddleware</code> list. This is because complementary inbound/outbound middleware functions usually need to be executed in inverted order. For example, if we want to decompress and then deserialize an inbound message using JSON, it means that for the outbound, we should instead first serialize and then compress. This convention for organizing the middleware in pairs is not strictly part of the general pattern, but only an implementation detail of our specific example.</li>
      <li class="numbered">The last method, <code class="Code-In-Text--PACKT-">executeMiddleware()</code>, represents the core of our component as it's the part responsible for executing the middleware functions. Each function in the <code class="Code-In-Text--PACKT-">middleware</code> array received as input is executed one after the other, and the result of the execution of a middleware function is passed to the next. Note that we are using the <code class="Code-In-Text--PACKT-">await</code> instruction on each result returned by each middleware <a id="_idIndexMarker829"/>function; this allows the middleware function to return a value synchronously as well as asynchronously using a promise. Finally, the result of the last middleware function is returned back to the caller.</li>
    </ol>
    <div><p class="Information-Box--PACKT-">For brevity, we are not supporting an error middleware pipeline. Normally, when a middleware function propagates an error, another set of middleware functions specifically dedicated to handling errors is executed. This can be easily implemented using the same technique that we are demonstrating here. For instance, we could accept an extra (optional) <code class="Code-In-Text--PACKT-">errorMiddleware</code> function in addition to <code class="Code-In-Text--PACKT-">inboundMiddleware</code> and <code class="Code-In-Text--PACKT-">outboundMiddleware</code>.</p>
    </div>
    <h3 id="_idParaDest-260" class="title">Implementing the middleware to process messages</h3>
    <p class="normal">Now that we have<a id="_idIndexMarker830"/> implemented our Middleware Manager, we can create our first pair of middleware functions to demonstrate how to process inbound and outbound messages. As we said, one of the goals of our middleware infrastructure is to have a filter that serializes and deserializes JSON messages. So, let's create a new middleware to take care of this. In a new module called <code class="Code-In-Text--PACKT-">jsonMiddleware.js</code>, let's include the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">export const jsonMiddleware = function () {
  return {
    inbound (message) {
      return JSON.parse(message.toString())
    },
    outbound (message) {
      return Buffer.from(JSON.stringify(message))
    }
  }
}
</code></pre>
    <p class="normal">The inbound part of our middleware deserializes the message received as input, while the outbound part serializes the data into a string, which is then converted into a buffer.</p>
    <p class="normal">In a similar way, we can implement a pair of middleware functions in a file called <code class="Code-In-Text--PACKT-">zlibMiddleware.js</code>, to inflate/deflate the message using the <code class="Code-In-Text--PACKT-">zlib</code> core module (<a href="http://nodejsdp.link/zlib">nodejsdp.link/zlib</a>):</p>
    <pre class="programlisting code"><code class="hljs-code">import { inflateRaw, deflateRaw } from 'zlib'
import { promisify } from 'util'
const inflateRawAsync = promisify(inflateRaw)
const deflateRawAsync = promisify(deflateRaw)
export const zlibMiddleware = function () {
  return {
    inbound (message) {
      return inflateRawAsync(Buffer.from(message))
    },
    outbound (message) {
      return deflateRawAsync(message)
    }
  }
}
</code></pre>
    <p class="normal">Compared to the JSON <a id="_idIndexMarker831"/>middleware, our zlib middleware functions are asynchronous and return a promise as a result. As we already know, this is perfectly supported by our Middleware Manager.</p>
    <p class="normal">You can note how the middleware used by our framework is quite different from the one used in Express. This is totally normal and a perfect demonstration of how we can adapt this pattern to fit our specific needs.</p>
    <h3 id="_idParaDest-261" class="title">Using the ZeroMQ middleware framework</h3>
    <p class="normal">We are now ready to use the middleware infrastructure that we just created. To do that, we are going to build a <a id="_idIndexMarker832"/>very simple application, with a client sending a <em class="italic">ping</em> to a server at regular intervals and the server echoing back the message received.</p>
    <p class="normal">From an implementation perspective, we are going to rely on a Request/Reply messaging pattern using the req/rep <a id="_idIndexMarker833"/>socket pair provided by ZeroMQ (<a href="http://nodejsdp.link/zmq-req-rep">nodejsdp.link/zmq-req-rep</a>). We will then wrap the sockets with our <code class="Code-In-Text--PACKT-">ZmqMiddlewareManager</code> to get all the advantages from the middleware<a id="_idIndexMarker834"/> infrastructure that we built, including the middleware for serializing/deserializing JSON messages.</p>
    <div><p class="Tip--PACKT-">We'll analyze the Request/Reply pattern and other messaging patterns in <em class="chapterRef">Chapter 13</em>, <em class="italic">Messaging and Integration Patterns</em>.</p>
    </div>
    <h4 class="title">The server</h4>
    <p class="normal">Let's start by creating the <a id="_idIndexMarker835"/>server-side of our application in a file called <code class="Code-In-Text--PACKT-">server.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import zeromq from 'zeromq'                                  // (1)
import { ZmqMiddlewareManager } from './zmqMiddlewareManager.js'
import { jsonMiddleware } from './jsonMiddleware.js'
import { zlibMiddleware } from './zlibMiddleware.js'
async function main () {
  const socket = new zeromq.Reply()                          // (2)
  await socket.bind('tcp://127.0.0.1:5000')
  const zmqm = new ZmqMiddlewareManager(socket)              // (3)
  zmqm.use(zlibMiddleware())
  zmqm.use(jsonMiddleware())
  zmqm.use({                                                 // (4)
    async inbound (message) {
      console.log('Received', message)
      if (message.action === 'ping') {
        await this.send({ action: 'pong', echo: message.echo })
      }
      return message
    }
  })
  console.log('Server started')
}
main()
</code></pre>
    <p class="normal">The server-side of our application works as follows:</p>
    <ol>
      <li class="numbered">We first load the necessary dependencies. The <code class="Code-In-Text--PACKT-">zeromq</code> package is essentially a JavaScript interface over the native ZeroMQ library. See <a href="http://nodejsdp.link/npm-zeromq">nodejsdp.link/npm-zeromq</a>.</li>
      <li class="numbered">Next, in the <code class="Code-In-Text--PACKT-">main()</code> function, we create a new ZeroMQ <code class="Code-In-Text--PACKT-">Reply</code> socket and bind it to port <code class="Code-In-Text--PACKT-">5000</code> on localhost.</li>
      <li class="numbered">Then comes the part where we wrap ZeroMQ with our middleware manager and then add the zlib and JSON middlewares.</li>
      <li class="numbered">Finally, we are ready to handle a request coming from the client. We will do this by simply adding another middleware, this time using it as a request handler.</li>
    </ol>
    <p class="normal">Since our request <a id="_idIndexMarker836"/>handler comes after the zlib and JSON middlewares, we will receive a decompressed and deserialized version of the received message. On the other hand, any data passed to <code class="Code-In-Text--PACKT-">send()</code> will be processed by the outbound middleware, which in our case will serialize and then compress the data.</p>
    <h4 class="title">The client</h4>
    <p class="normal">On the client-side of our little <a id="_idIndexMarker837"/>application, in a file called <code class="Code-In-Text--PACKT-">client.js</code>, we will have the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">import zeromq from 'zeromq'
import { ZmqMiddlewareManager } from './zmqMiddlewareManager.js'
import { jsonMiddleware } from './jsonMiddleware.js'
import { zlibMiddleware } from './zlibMiddleware.js'
async function main () {
  const socket = new zeromq.Request()                      // (1)
  await socket.connect('tcp://127.0.0.1:5000')
  const zmqm = new ZmqMiddlewareManager(socket)
  zmqm.use(zlibMiddleware())
  zmqm.use(jsonMiddleware())
  zmqm.use({
    inbound (message) {
      console.log('Echoed back', message)
      return message
    }
  })
  setInterval(() =&gt; {                                      // (2)
    zmqm.send({ action: 'ping', echo: Date.now() })
      .catch(err =&gt; console.error(err))
  }, 1000)
  console.log('Client connected')
}
main()
</code></pre>
    <p class="normal">Most of the code of the client application is very similar to that of the server. The notable differences are:</p>
    <ol>
      <li class="numbered">We create a <code class="Code-In-Text--PACKT-">Request</code> socket, rather than a <code class="Code-In-Text--PACKT-">Reply</code> socket, and we connect it to a remote (or local) host rather than binding it on a local port. The rest of the middleware setup is exactly the same as in the server, except for the fact that our request handler now just prints any message it receives. Those messages should be the <em class="italic">pong</em> reply to our <em class="italic">ping</em> requests.</li>
      <li class="numbered">The core logic of the client application is a timer that sends a <em class="italic">ping</em> message every second.</li>
    </ol>
    <p class="normal">Now, we're ready to try <a id="_idIndexMarker838"/>our client/server pair and see the application in action. First, start the server:</p>
    <pre class="programlisting con"><code class="hljs-con">node server.js
</code></pre>
    <p class="normal">We can then start the client in another terminal with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">node client.js
</code></pre>
    <p class="normal">At this point, we should see the client sending messages and the server echoing them back.</p>
    <p class="normal">Our middleware framework did its job. It allowed us to decompress/compress and deserialize/serialize our messages transparently, leaving the handlers free to focus on their business logic.</p>
    <h2 id="_idParaDest-262" class="title">In the wild</h2>
    <p class="normal">We opened this section<a id="_idIndexMarker839"/> by saying that the library that popularized the Middleware pattern in Node.js is Express (<a href="http://nodejsdp.link/express">nodejsdp.link/express</a>). So, we can easily say that Express is also the most notable example of the Middleware pattern out there.</p>
    <p class="normal">Two other interesting examples are:</p>
    <ul>
      <li class="Bullet--PACKT-">Koa (<a href="http://nodejsdp.link/koa">nodejsdp.link/koa</a>), which is<a id="_idIndexMarker840"/> known as the successor of Express. It was created by the same team behind Express and it shares with it its philosophy and main design principles. Koa's middleware is slightly different than that of Express since it uses modern programming techniques such as async/await instead of callbacks.</li>
      <li class="Bullet-End--PACKT-">Middy (<a href="http://nodejsdp.link/middy">nodejsdp.link/middy</a>) is a classic <a id="_idIndexMarker841"/>example of the Middleware pattern applied to something different than a web framework. Middy is, in fact, a middleware engine for AWS Lambda functions.</li>
    </ul>
    <p class="normal">Next, we are going to explore the Command pattern, which, as we will see shortly, is a very flexible and multiform pattern.</p>
    <h1 id="_idParaDest-263" class="title">Command</h1>
    <p class="normal">Another design pattern <a id="_idIndexMarker842"/>with huge importance in Node.js is <strong class="keyword">Command</strong>. In its most generic definition, we can consider a command any object that<a id="_idIndexMarker843"/> encapsulates all the information necessary to perform an action at a later time. So, instead of invoking a method or a function directly, we create an object representing the intention to perform such an invocation. It will then be the responsibility of another component to materialize the intent, transforming it into an actual action. Traditionally, this pattern is built around four major components, as shown in <em class="italic">Figure 9.6</em>:</p>
    <figure class="mediaobject"><img src="img/B15729_09_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.6: The components of the Command pattern</p>
    <p class="normal">The typical configuration of the Command pattern can be described as follows:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Command</strong> is the object encapsulating <a id="_idIndexMarker844"/>the information necessary to invoke a method or function.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Client</strong> is the component that<a id="_idIndexMarker845"/> creates the command and provides it to the invoker.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Invoker</strong> is the component<a id="_idIndexMarker846"/> responsible for executing the command on the target.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Target</strong> (or <strong class="keyword">receiver</strong>) is the subject<a id="_idIndexMarker847"/> of the invocation. It can be a lone function or a method of an object.</li>
    </ul>
    <p class="normal">As we will see, these four components can vary a lot depending on the way we want to implement the pattern. This should not sound new at this point.</p>
    <p class="normal">Using the Command <a id="_idIndexMarker848"/>pattern instead of directly executing an operation has several applications:</p>
    <ul>
      <li class="Bullet--PACKT-">A command can be scheduled for execution at a later time.</li>
      <li class="Bullet--PACKT-">A command can be easily serialized and sent over the network. This simple property allows us to distribute jobs across remote machines, transmit commands from the browser to the <a id="_idIndexMarker849"/>server, create <strong class="keyword">remote procedure call</strong> (<strong class="keyword">RPC</strong>) systems, and so on.</li>
      <li class="Bullet--PACKT-">Commands make it easy to keep a history of all the operations executed on a system.</li>
      <li class="Bullet--PACKT-">Commands are an important part of some algorithms for data synchronization and conflict resolution.</li>
      <li class="Bullet--PACKT-">A command scheduled for execution can be canceled if it's not yet executed. It can also be reverted (undone), bringing the state of the application to the point before the command was executed.</li>
      <li class="Bullet--PACKT-">Several commands can be grouped together. This can be used to create atomic transactions or to implement a mechanism whereby all the operations in the group are executed at once.</li>
      <li class="Bullet-End--PACKT-">Different kinds of transformation can be performed on a set of commands, such as duplicate removal, joining and <a id="_idIndexMarker850"/>splitting, or applying more complex algorithms such as <strong class="keyword">operational transformation</strong> (<strong class="keyword">OT</strong>), which is the base for most of today's real-time collaborative software, such as collaborative text editing.</li>
    </ul>
    <div><p class="Tip--PACKT-">A great explanation of how OT works can be found at <a href="http://nodejsdp.link/operational-transformation">nodejsdp.link/operational-transformation</a>.</p>
    </div>
    <p class="normal">The preceding list clearly shows <a id="_idIndexMarker851"/>us how important this pattern is, especially on a platform such as Node.js where networking and asynchronous execution are essential players.</p>
    <p class="normal">Now, we are<a id="_idIndexMarker852"/> going to explore in more detail a couple of different implementations of the Command pattern, just to give you an idea of its scope.</p>
    <h2 id="_idParaDest-264" class="title">The Task pattern</h2>
    <p class="normal">We can start off with the most basic <a id="_idIndexMarker853"/>and trivial implementation of the Command pattern: the <strong class="keyword">Task pattern</strong>. The easiest way in JavaScript to create an object representing<a id="_idIndexMarker854"/> an invocation is, of course, by creating a closure around a function definition or <a id="_idIndexMarker855"/>a <strong class="keyword">bound function</strong>:</p>
    <pre class="programlisting code"><code class="hljs-code">function createTask(target, ...args) {
  return () =&gt; {
    target(...args)
  }
}
</code></pre>
    <p class="normal">This is (mostly) equivalent to doing:</p>
    <pre class="programlisting code"><code class="hljs-code">const task = target.bind(null, ...args)
</code></pre>
    <p class="normal">This should not look new at all. In fact, we have used this pattern already so many times throughout the book, and in particular in <em class="chapterRef">Chapter 4</em>, <em class="italic">Asynchronous Control Flow Patterns with Callbacks</em>. This technique allowed us to use a separate component to control and schedule the execution of our tasks, which is essentially equivalent to the invoker of the Command pattern.</p>
    <h2 id="_idParaDest-265" class="title">A more complex command</h2>
    <p class="normal">Let's now work on a more <a id="_idIndexMarker856"/>articulated example leveraging the Command pattern. This time, we want to support <em class="italic">undo</em> and <em class="italic">serialization</em>. Let's start with the <em class="italic">target</em> of our commands, a little object that is responsible for sending status updates to a Twitter-like service. We will use a mockup of such a service for simplicity (the <code class="Code-In-Text--PACKT-">statusUpdateService.js</code> file):</p>
    <pre class="programlisting code"><code class="hljs-code">const statusUpdates = new Map()
// The Target
export const statusUpdateService = {
  postUpdate (status) {
    const id = Math.floor(Math.random() * 1000000)
    statusUpdates.set(id, status)
    console.log(`Status posted: ${status}`)
    return id
  },
  destroyUpdate (id) =&gt; {
    statusUpdates.delete(id)
    console.log(`Status removed: ${id}`)
  }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">statusUpdateService</code> we just created represents the target of our Command pattern. Now, let's implement a<a id="_idIndexMarker857"/> factory function that creates a command to represent the posting of a new status update. We'll do that in a file called <code class="Code-In-Text--PACKT-">createPostStatusCmd.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">export function createPostStatusCmd (service, status) {
  let postId = null
  // The Command
  return {
    run () {
      postId = service.postUpdate(status)
    },
    undo () {
      if (postId) {
        service.destroyUpdate(postId)
        postId = null
      }
    },
    serialize () {
      return { type: 'status', action: 'post', status: status }
    }
  }
}
</code></pre>
    <p class="normal">The preceding function is a factory that produces commands to model "post status" intentions. Each command implements the following three functionalities:</p>
    <ul>
      <li class="Bullet--PACKT-">A <code class="Code-In-Text--PACKT-">run()</code> method that, when invoked, will trigger the action. In other words, it implements the <em class="italic">Task</em> pattern that we have seen before. The command, when executed, will post a new status update using the methods of the target service.</li>
      <li class="Bullet--PACKT-">An <code class="Code-In-Text--PACKT-">undo()</code> method that reverts the effects of the <em class="italic">post</em> operation. In our case, we are simply invoking the <code class="Code-In-Text--PACKT-">destroyUpdate()</code> method on the target service.</li>
      <li class="Bullet-End--PACKT-">A <code class="Code-In-Text--PACKT-">serialize()</code> method that builds a JSON object that contains all the necessary information to reconstruct the same command object.</li>
    </ul>
    <p class="normal">After this, we can build <a id="_idIndexMarker858"/>an invoker. We can start by implementing its constructor and its <code class="Code-In-Text--PACKT-">run()</code> method (the <code class="Code-In-Text--PACKT-">invoker.js</code> file):</p>
    <pre class="programlisting code"><code class="hljs-code">import superagent from 'superagent'
// The Invoker
export class Invoker {
  constructor () {
    this.history = []
  }
  run (cmd) {
    this.history.push(cmd)
    cmd.run()
    console.log('Command executed', cmd.serialize())
  }
  // ...rest of the class
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">run()</code> method is the basic functionality of our <code class="Code-In-Text--PACKT-">Invoker</code>. It is responsible for saving the command into the <code class="Code-In-Text--PACKT-">history</code> instance variable and then triggering the execution of the command itself.</p>
    <p class="normal">Next, we can add to the <code class="Code-In-Text--PACKT-">Invoker</code> a new method that delays the execution of a command:</p>
    <pre class="programlisting code"><code class="hljs-code">delay (cmd, delay) {
  setTimeout(() =&gt; {
    console.log('Executing delayed command', cmd.serialize())
    this.run(cmd)
  }, delay)
}
</code></pre>
    <p class="normal">Then, we can implement an <code class="Code-In-Text--PACKT-">undo()</code> method that reverts the last command:</p>
    <pre class="programlisting code"><code class="hljs-code">undo () {
  const cmd = this.history.pop()
  cmd.undo()
  console.log('Command undone', cmd.serialize())
}
</code></pre>
    <p class="normal">Finally, we also want to be able to run a command on a remote server, by serializing and then transferring it over the network using a web service:</p>
    <pre class="programlisting code"><code class="hljs-code">async runRemotely (cmd) {
  await superagent
    .post('http://localhost:3000/cmd')
    .send({ json: cmd.serialize() })
  console.log('Command executed remotely', cmd.serialize())
}
</code></pre>
    <p class="normal">Now that we have the<a id="_idIndexMarker859"/> command, the invoker, and the target, the only component missing is the client, which we will implement in a file called <code class="Code-In-Text--PACKT-">client.js</code>. Let's start by importing all the necessary dependencies and by instantiating <code class="Code-In-Text--PACKT-">Invoker</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">import { createPostStatusCmd } from './createPostStatusCmd.js'
import { statusUpdateService } from './statusUpdateService.js'
import { Invoker } from './invoker.js'
const invoker = new Invoker()
</code></pre>
    <p class="normal">Then, we can create a command using the following line of code:</p>
    <pre class="programlisting code"><code class="hljs-code">const command = createPostStatusCmd(statusUpdateService, 'HI!')
</code></pre>
    <p class="normal">We now have a command representing the posting of a status message. We can then decide to dispatch it immediately:</p>
    <pre class="programlisting code"><code class="hljs-code">invoker.run(command)
</code></pre>
    <p class="normal">Oops, we made a mistake, let's revert our timeline to the state it was before posting the last message:</p>
    <pre class="programlisting code"><code class="hljs-code">invoker.undo()
</code></pre>
    <p class="normal">We can also decide to schedule the message to be sent in 3 seconds from now:</p>
    <pre class="programlisting code"><code class="hljs-code">invoker.delay(command, 1000 * 3)
</code></pre>
    <p class="normal">Alternatively, we can distribute the load of the application by migrating the task to another machine:</p>
    <pre class="programlisting code"><code class="hljs-code">invoker.runRemotely(command)
</code></pre>
    <p class="normal">The little example that we have just implemented shows how wrapping an operation in a command can open a world of possibilities, and that's just the tip of the iceberg.</p>
    <p class="normal">As the last remarks, it is worth noting that a fully-fledged Command pattern should be used only when strictly necessary. We saw, in fact, how much additional code we had to write to simply invoke a method of the <code class="Code-In-Text--PACKT-">statusUpdateService</code>. If all that we need is only an invocation, then a<a id="_idIndexMarker860"/> complex command would be overkill. If, however, we need to schedule the execution of a task or run an asynchronous operation, then the simpler <em class="italic">Task pattern</em> offers the best compromise. If instead, we need more advanced features such as undo support, transformations, conflict resolution, or one of the other fancy use cases that we described previously, using a more complex representation for the command is almost necessary.</p>
    <h1 id="_idParaDest-266" class="title">Summary</h1>
    <p class="normal">We opened this chapter with three closely related patterns, which are Strategy, State, and Template.</p>
    <p class="normal">Strategy allows us to extract the common parts of a family of closely related components into a component called the context and allows us to define strategy objects that the context can use to implement specific behaviors. The State pattern is a variation of the Strategy pattern where the strategies are used to model the behavior of a component when under different states. The Template pattern, instead, can be considered the "static" version of the Strategy pattern, where the different specific behaviors are implemented as subclasses of the template class, which models the common parts of the component.</p>
    <p class="normal">Next, we learned about what has now become a core pattern in Node.js, which is Iterator. We learned how JavaScript offers native support for the pattern (with the iterator and iterable protocols), and how async iterators can be used as an alternative to complex async iteration patterns and even to Node.js streams.</p>
    <p class="normal">Then, we examined Middleware, which is a very distinctive pattern born from within the Node.js ecosystem. We learned how it can be used to preprocess and postprocess data and requests.</p>
    <p class="normal">Finally, we had a taste of the possibilities offered by the Command pattern, which can be used to implement a myriad of functionality, from simple undo/redo and serialization, to more complex operational transformation algorithms.</p>
    <p class="normal">We have now arrived at the end of the last chapter dedicated to "traditional" design patterns. By now, you should have added to your toolbelt a series of patterns that will be enormously useful in your everyday programming endeavors.</p>
    <p class="normal">In the next chapter, we'll shift our attention to a topic that goes beyond the boundaries of server-side development. Thanks to Node.js, in fact, we can create "Universal" JavaScript applications, or in other words, applications that can run as seamlessly on the server as they run on the browser. Stay tuned, then, to learn about the most useful Universal JavaScript patterns.</p>
    <h1 id="_idParaDest-267" class="title">Exercises</h1>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Exercise 9.1 Logging with Strategy</strong>: Implement a logging component having at least the following methods: <code class="Code-In-Text--PACKT-">debug()</code>, <code class="Code-In-Text--PACKT-">info()</code>, <code class="Code-In-Text--PACKT-">warn()</code>, and <code class="Code-In-Text--PACKT-">error()</code>. The logging component should also accept a strategy that defines where the log messages are sent. For example, we might have a <code class="Code-In-Text--PACKT-">ConsoleStrategy</code> to send the messages to the console, or a <code class="Code-In-Text--PACKT-">FileStrategy</code> to save the log messages to a file.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Exercise 9.2 Logging with Template</strong>: Implement the same logging component we defined in the previous exercise, but this time using the Template pattern. We would then obtain a <code class="Code-In-Text--PACKT-">ConsoleLogger</code> class to log to the console or <code class="Code-In-Text--PACKT-">FileLogger</code> class to log to a file. Appreciate the differences between the Template and the Strategy approaches.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Exercise 9.3 Warehouse item</strong>: Imagine we are working on a warehouse management program. Our next task is to create a class to model a warehouse item and help track it. Such a <code class="Code-In-Text--PACKT-">WarehouseItem</code> class has a constructor, which accepts an <code class="Code-In-Text--PACKT-">id</code> and the initial <code class="Code-In-Text--PACKT-">state</code> of the item (which can be one of <code class="Code-In-Text--PACKT-">arriving</code>, <code class="Code-In-Text--PACKT-">stored</code>, or <code class="Code-In-Text--PACKT-">delivered</code>). It has three public methods:<ul>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">store(locationId)</code> moves the item into the <code class="Code-In-Text--PACKT-">stored</code> state and records the <code class="Code-In-Text--PACKT-">locationId</code> where it's stored.</li>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">deliver(address)</code> changes the state of the item to <code class="Code-In-Text--PACKT-">delivered</code>, sets the delivery <code class="Code-In-Text--PACKT-">address</code>, and clears the <code class="Code-In-Text--PACKT-">locationId</code>.</li>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">describe()</code> returns a string representation of the current state of the item (for example, "Item 5821 is on its way to the warehouse," or "Item 3647 is stored in location 1ZH3," or "Item 3452 was delivered to John Smith, 1st Avenue, New York."</li>
        </ul>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">arriving</code> state can be set only when the object is created as it cannot be transitioned to from the other states. An item can't move back to the <code class="Code-In-Text--PACKT-">arriving</code> state once it's <code class="Code-In-Text--PACKT-">stored</code> or <code class="Code-In-Text--PACKT-">delivered</code>, it cannot be moved back to <code class="Code-In-Text--PACKT-">stored</code> once it's <code class="Code-In-Text--PACKT-">delivered</code>, and it cannot be <code class="Code-In-Text--PACKT-">delivered</code> if it's not <code class="Code-In-Text--PACKT-">stored</code> first. Use the State pattern to implement the <code class="Code-In-Text--PACKT-">WarehouseItem</code> class.</p>
      </li>
      <li class="Bullet--PACKT-"><strong class="keyword">Exercise 9.4 Logging with Middleware</strong>: Rewrite the logging component you implemented for exercises 9.1 and 9.2, but this time use the Middleware pattern to postprocess each log message allowing different middlewares to customize how to handle the messages and how to output them. We could, for example, add a <code class="Code-In-Text--PACKT-">serialize()</code> middleware to convert the log messages to a string representation ready to be sent over the wire or saved somewhere. Then, we could add a <code class="Code-In-Text--PACKT-">saveToFile()</code> middleware that saves each message to a file. This exercise should highlight the flexibility and universality of the Middleware pattern.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Exercise 9.5 Queues with iterators</strong>: Implement an <code class="Code-In-Text--PACKT-">AsyncQueue</code> class similar to one of the <code class="Code-In-Text--PACKT-">TaskQueue</code> classes we defined in <em class="chapterRef">Chapter 5</em>, <em class="italic">Asynchronous Control Flow Patterns with Promises and Async/Await</em>, but with a slightly different behavior and interface. Such an <code class="Code-In-Text--PACKT-">AsyncQueue</code> class will have a method called <code class="Code-In-Text--PACKT-">enqueue()</code> to append new items to the queue and then expose an <code class="Code-In-Text--PACKT-">@@asyncIterable</code> method, which should provide the ability to process the elements of the queue asynchronously, one at a time (so, with a concurrency of 1). The async iterator returned from <code class="Code-In-Text--PACKT-">AsyncQueue</code> should terminate only after the <code class="Code-In-Text--PACKT-">done()</code> method of <code class="Code-In-Text--PACKT-">AsyncQueue</code> is invoked <em class="italic">and</em> only after all items in the queue are consumed. Consider that the <code class="Code-In-Text--PACKT-">@@asyncIterable</code> method could be invoked in more than one place, thus returning an additional async iterator, which would allow you to increase the concurrency with which the queue is consumed.</li>
    </ul>
  </div>
</body></html>