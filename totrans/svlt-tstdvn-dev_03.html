<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor050"/>3</h1>
<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Loading Data into a Route</h1>
<p><code>/birthdays</code> route that we’ll work on in this chapter. Part of that routing is ensuring that the route has the data available to it. In this chapter, you’ll see how you can test-drive SvelteKit’s <code>load</code> function for pulling that data into a component.</p>
<p>You’ll also see how Playwright can be used to build an end-to-end test that proves all the various components of this system.</p>
<p>This chapter covers the following:</p>
<ul>
<li>Using Playwright to specify end-to-end behavior</li>
<li>Deciding an approach to make the end-to-end test pass</li>
<li>Test-driving the load function</li>
<li>Test-driving the page component</li>
</ul>
<p>By the end of the chapter, you’ll have test-driven a functioning SvelteKit route that you can view in your web browser, and you’ll have learned the key differences between Playwright end-to-end tests and Vitest unit tests.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start</a>.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Using Playwright to specify end-to-end behavior</h1>
<p>In this section, you will<a id="_idIndexMarker075"/> write your first Playwright test and learn about the various function calls within it, and you’ll learn about differentiating between Playwright end-to-end tests and Vitest unit tests.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Writing the test and watching it fail</h2>
<p>The test we are <a id="_idIndexMarker076"/>going to write is entitled <code>lists all birthdays</code> and it will perform the following steps:</p>
<ol>
<li>Browse to the <code>/</code><code>birthdays</code> location.</li>
<li>Look for the text <code>Hercules</code> and <code>Athena</code>, which it will take as evidence that the test has passed.</li>
</ol>
<p>Once the test is in place, we’ll stop to think about how this <code>Hercules</code> and <code>Athena</code> data should get into our system.</p>
<p>Create a new file named <code>tests/birthdays.test.js</code> and add the following content:</p>
<pre class="source-code">
import { expect, test } from '@playwright/test';
test('lists all birthdays', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  await expect(
    page.getByText('Hercules')
  ).toBeVisible();
  await expect(
    page.getByText('Athena')
  ).toBeVisible();
});</pre>
<p>You can see some things here that are similar to the Vitest tests, such as the use of <code>expect</code> and the <code>toBeVisible</code> matcher.</p>
<p>However, some things are different. For a start, the test is marked as <code>async</code> and all the function calls (including the <code>expect</code> function calls) are marked with <code>await</code>.</p>
<p>That’s necessary because Playwright is driving a headless browser, meaning it’s started a real browser process that runs in the background and is invisible to you. Playwright has no mechanism for determining when the browser has completed working, beyond waiting patiently and frequently checking the browser state. Therefore, most of its internal logic is driven by waits and timeouts: the browser is given a certain amount of time, generally a few seconds, to get things displayed.</p>
<p>The <code>page.goto</code> call is instructing this headless browser to navigate to the <code>/birthdays</code> endpoint. Playwright takes care of spinning up a real dev server in the background and ensuring that any relative URLs (such as <code>/birthdays</code>) are converted to absolute URLs pointing at this dev server (like <code>https://localhost:5173/birthdays</code>).</p>
<p>Go ahead and run<a id="_idIndexMarker077"/> the test now, using the <code>npm test</code> shell command. You should see an almost immediate failure appear:</p>
<pre class="source-code">
     1 birthdays.test.js:3:1 › lists all birthdays
  ✓  2 test.js:3:1 › index page has expected h1 (618ms)
[WebServer] Error: Not found: /birthdays</pre>
<p>With the test complete, let’s take a more detailed look at the difference between Vitest tests and Playwright tests.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Understanding the difference between Vitest tests and Playwright tests</h2>
<p>There are <a id="_idIndexMarker078"/>fundamental differences between how Vitest tests<a id="_idIndexMarker079"/> work and how Playwright tests work. Both play their part in TDD.</p>
<p><em class="italic">Figure 3</em><em class="italic">.1</em> shows how each type of test encompasses your code. Playwright tests are often referred to as end-to-end tests and they are high-level, with each test exercising a whole lot of code. Vitest tests are often called unit tests. They are very detailed and exercise just a small piece of the code.</p>
<div><div><img alt="Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project" height="793" src="img/Figure_3.1_B19611.jpg" width="1484"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project</p>
<p>Playwright tests are often a good starting point when embarking on building a new feature. They may even be written by project stakeholders who are not developers but still participate in defining features. In <a href="B19611_13.xhtml#_idTextAnchor148"><em class="italic">Chapter </em><em class="italic">13</em></a>, <em class="italic">Adding Cucumber Tests</em>, we’ll see how this can be done with plain English syntax rather than JavaScript code.</p>
<p>Playwright tests are often written against the browser UI. They exercise the whole system, including the web browser and any out-of-process resources such as databases. When working with a SvelteKit application, the Playwright test runner starts up the SvelteKit web server and executes all of the SvelteKit runtime code for managing routes.</p>
<p>In contrast, the <a id="_idIndexMarker080"/>Vitest test runner does not load up the SvelteKit <a id="_idIndexMarker081"/>web server and does not execute any of its code. Instead, it loads your JavaScript files directly into the same Node process that Vitest and your test suites are loaded into.</p>
<p>While Playwright tests are good for focusing a team on what needs to be built, they often have nothing to say about the internal design of the software or even the architecture of the system as a whole. This is where Vitest unit tests come in. They can be used by developers to work out the <em class="italic">how</em> of a system.</p>
<p>There are a number of ways that unit tests help with design. For example, if a unit test is proving difficult to write, that’s sometimes a sign that the application design is too complex. Breaking apart the units in a different way can lead to the unit tests becoming much simpler.</p>
<p>Playwright tests are often kept low on specifics leaving the unit tests to cover the details. For example, in the test we just wrote, we are interested in the listing of the birthdays that the system knows about but notice that we only checked by looking for the names of people, and not the birthdays. We leave the complete birthday checks to the unit tests for the <code>Birthday</code> component, which we already wrote in <a href="B19611_02.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing the </em><em class="italic">Red-Green-Refactor Workflow</em>.</p>
<p>This way, we <a id="_idIndexMarker082"/>end up with lots of low-level Vitest unit tests <a id="_idIndexMarker083"/>and a few higher-level Playwright tests. This is the classic test automation pyramid as described by Mike Cohn in the book <em class="italic">Succeeding with Agile</em>. It encourages a testing strategy that includes many unit tests, some service tests, and just a dollop of UI tests.</p>
<p><em class="italic">Figure 3</em><em class="italic">.2</em> shows how the test automated pyramid can be applied to SvelteKit projects. Playwright end-to-end tests can be written against both the UI and also against specific API endpoints, and your unit tests are written for the Vitest runner.</p>
<div><div><img alt="Figure 3.2 – The testing pyramid as applied to SvelteKit projects" height="660" src="img/Figure_3.2_B19611.jpg" width="1239"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The testing pyramid as applied to SvelteKit projects</p>
<p>One reason for structuring automated tests in this way is that unit tests are cheap to create and maintain, whereas UI tests are expensive in terms of time and energy put into them.</p>
<p>The service<a id="_idIndexMarker084"/> tests are like the UI tests in that they cover a whole<a id="_idIndexMarker085"/> flow through a system but avoid the UI. For example, they may call HTTP API endpoints directly. That can be helpful because the UI tends to be the most brittle component of the system, and driving a UI can take a while as you wait for the on-screen changes to be rendered.</p>
<p class="callout-heading">Note</p>
<p class="callout">Modern web browser environments, together with modern test runners such as Playwright, have gotten much better at handling automated UI tests.</p>
<p>Another reason the classic test automation pyramid makes sense is that unit tests are often very fast to execute. You can have many unit tests, each of which executes just a tiny fraction of the code surface. When one of those tests breaks, it’s very quick to read the test description or test code and figure out where in the application code the failure lies.</p>
<p>It’s also worth remembering that unit tests serve to document all of the technical design decisions taken when writing the code, and this documentation is invaluable in understanding the history of a project.</p>
<p>Finally, keep in mind that<a id="_idIndexMarker086"/> Vitest unit tests do not test the SvelteKit <a id="_idIndexMarker087"/>server-side runtime environment. That means, for example, that a Vitest unit test can test that you correctly defined a <code>load</code> function, but it cannot test that the route is hooked up correctly. For that, you need a Playwright test that compiles and runs your components and routes just as if it was a real browser environment.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Deciding an approach to make the end-to-end test pass</h1>
<p>With <a id="_idIndexMarker088"/>that all said, how do we begin writing Vitest unit tests now that we have a Playwright test that defines what we want?</p>
<p>The Playwright test looks for the names <code>Hercules</code> and <code>Athena</code>. The test makes an assumption that these two people have their birthdays listed in the system and that the page at <code>/birthdays</code> lists them. But how do we get them into the system in the first place?</p>
<p>In true TDD style, we can defer this decision and simply hardcode these two birthdays in the system. After all, the test doesn’t seem to care about how the data gets into the system, only about how it is presented.</p>
<p>We can come back to how the birthdays are added later. In fact, we’ll do this in <a href="B19611_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Matchers to Simplify Tests</em>. We can also make use of our <code>Birthday</code> component from <a href="B19611_02.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing the Red-Green-Refactor Workflow</em>, to display each birthday in turn.</p>
<p>Therefore, what we need to do is the following:</p>
<ol>
<li>Create a <code>load</code> function that returns hardcoded birthday data for Hercules and Athena. This needs to exist within the <code>src/routes/birthdays/+page.server.js</code> file.</li>
<li>Create a <code>page</code> component that takes the data from <code>load</code> and displays a <code>Birthday</code> component for each of the birthdays given. This needs to exist as <code>src/routes/birthdays/+page.svelte</code>.</li>
</ol>
<p>SvelteKit takes care of matching the <code>/birthdays</code> route to our files in the <code>src/routes/birthdays</code> directory. After calling <code>load</code>, it will pass the result into the <code>data</code> prop in the <code>+</code><code>page.svelte</code> component.</p>
<p>That covers <a id="_idIndexMarker089"/>how to write a basic Playwright end-to-end test. We’ve discussed the differences between Playwright end-to-end and Vitest unit tests, and we’ve come up with a plan for the rest of the chapter.</p>
<p>The next section covers how to test-drive a basic, hardcoded version of our <code>load</code> function.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Test-driving the load function</h1>
<p>Now that <a id="_idIndexMarker090"/>we’ve decided to implement a <code>load</code> function that returns hardcoded birthday data for Hercules and Athena, the actual change has become very simple.</p>
<p>The <code>load</code> function is a special SvelteKit function that will be invoked when a request comes in for the given route. So, when the user navigates to the <code>/birthdays</code> route, SvelteKit calls the <code>load</code> function in the <code>src/routes/birthdays/+page.server.js</code> file and then renders the component in the <code>src/routes/birthdays/+page.svelte</code> file.</p>
<p>Follow these steps to create the <code>load</code> function using TDD:</p>
<ol>
<li>Create a new Vitest test file named <code>src/routes/birthdays/page.server.test.js</code> and start it off as shown. We are importing the <code>load</code> function from a <code>+page.server.js</code> file that doesn’t yet exist. We call the function in our test and store the result:<pre class="source-code">
import { describe, it, expect } from 'vitest';
import { load } from './+page.server.js';
describe('/birthdays - load', () =&gt; {
  it('returns a fixture of two items', () =&gt; {
    const result = load();
  });
});</pre></li>
</ol>
<p class="callout-heading">Naming describe blocks for load functions</p>
<p class="callout">I’ve named the <code>describe</code> block <code>/birthdays - load</code>, which demonstrates a standard naming pattern that can be used for the <code>load</code> functions for routes.</p>
<ol>
<li value="2">Complete<a id="_idIndexMarker091"/> the test with the following expectation:<pre class="source-code">
it('returns a fixture of two items', () =&gt; {
  const result = load();
<strong class="bold">  expect(result.birthdays).toEqual([</strong>
<strong class="bold">    { name: 'Hercules', dob: '1994-02-02' },</strong>
<strong class="bold">    { name: 'Athena', dob: '1989-01-01' }</strong>
<strong class="bold">  ]);</strong>
});</pre></li>
</ol>
<p class="callout-heading">One expectation per test</p>
<p class="callout">This entire test contains just a single call to <code>expect</code>. Generally, when writing tests, I find it’s useful to stick to just one expectation if possible. That helps to keep a strong link between the test description and the contents of the <code>expect</code> call.</p>
<p class="callout">It’s often the case (as in this test) that you can stuff a whole lot of checks in a single expectation.</p>
<p class="callout">The <code>toEqual</code> matcher has a special <em class="italic">deep equality</em> mechanism that means each level of an object or array can be checked for its value, rather than its identity. And moreover, we can use constraint functions such as <code>objectContaining</code>, which we’ll see in <a href="B19611_06.xhtml#_idTextAnchor079"><em class="italic">Chapter 6</em></a>, <em class="italic">Editing </em><em class="italic">Form Data</em>.</p>
<ol>
<li value="3">Go <a id="_idIndexMarker092"/>ahead and run the test with your Vitest test runner. This gives the following output:<pre class="source-code">
<strong class="bold"> FAIL  </strong><strong class="bold">src/routes/birthdays/page.server.test.js [ src/routes/birthdays/page.server.test.js ]</strong>
<strong class="bold">Error: Failed to load url ./+page.server.js (resolved id: ./+page.server.js). Does the file exist?</strong></pre></li>
<li>Do as it suggests and create an empty file at the <code>src/routes/birthdays/+page.server.js</code> location, and then rerun your tests. You should see the following:<pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - load &gt; returns a fixture of two items</strong>
<strong class="bold">TypeError: load is not a function</strong>
<strong class="bold"> </strong><strong class="bold">❯</strong><strong class="bold"> src/routes/birthdays/page.server.test.js:6:18</strong>
<strong class="bold">      4| describe('/birthdays - load', () =&gt; {</strong>
<strong class="bold">      5|  it('returns a fixture of two items', () =&gt; {</strong>
<strong class="bold">      6|  </strong><strong class="bold"> const result = load();</strong>
<strong class="bold">       |                  ^</strong>
<strong class="bold">      7|   expect(result.birthdays).toEqual([</strong>
<strong class="bold">      8|    expect.objectContaining({</strong></pre></li>
<li>Okay, marvelous: <code>load is not a function</code>. Let’s create a basic <code>load</code> function, then, with absolutely nothing in it. Add this to the new file:<pre class="source-code">
export const load = () =&gt; ({});</pre></li>
<li>Rerun your<a id="_idIndexMarker093"/> tests. You’ll get the following:<pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - load &gt; returns a fixture of two items</strong>
<strong class="bold"> AssertionError: expected [ { name: 'Hercules', …(2) }, …(1) ] to deeply equal [ { name: 'Hercules', …(1) }, …(1) ]</strong>
<strong class="bold"> </strong><strong class="bold">❯</strong><strong class="bold"> src/routes/birthdays/page.server.test.js:14:28</strong>
<strong class="bold">     12|  it('returns a fixture of two items', () =&gt; {</strong>
<strong class="bold">     13|   const result = load();</strong>
<strong class="bold">     14|  </strong><strong class="bold"> expect(result.birthdays).toEqual([</strong>
<strong class="bold">       |                            ^</strong>
<strong class="bold">     15|    { name: 'Hercules', dob: '1994-02-02' },</strong>
<strong class="bold">     16|    { name: 'Athena', dob: '1989-01-01' }</strong>
<strong class="bold">  - Expected  - 10</strong>
<strong class="bold">  + Received</strong><strong class="bold">  + 1</strong>
<strong class="bold">  - Array [</strong>
<strong class="bold">  -   Object {</strong>
<strong class="bold">  -     "dob": "1994-02-02",</strong>
<strong class="bold">  -     "name": "Hercules",</strong>
<strong class="bold">  </strong><strong class="bold">-   },</strong>
<strong class="bold">  -   Object {</strong>
<strong class="bold">  -     "dob": "1989-01-01",</strong>
<strong class="bold">  -     "name": "Athena",</strong>
<strong class="bold">  -   },</strong>
<strong class="bold">  </strong><strong class="bold">- ]"</strong>
<strong class="bold">  + "undefined"</strong></pre></li>
<li>To fix the<a id="_idIndexMarker094"/> issue, all we need to do is fill in the hardcoded values. Update the code in <code>src/routes/birthdays/+page.server.js</code> to look as follows:<pre class="source-code">
export const load = () =&gt; ({
<strong class="bold">  birthdays: [</strong>
<strong class="bold">    { name: 'Hercules', dob: '1994-02-02' },</strong>
<strong class="bold">    { name: 'Athena', dob: '1989-01-01' }</strong>
<strong class="bold">  ]</strong>
});</pre></li>
</ol>
<p class="callout-heading">Plumbing and hardcoded values</p>
<p class="callout">It may feel a bit pointless doing this, but the value is in getting the plumbing into place. The test we’ve written here will serve as a useful regression test when we come to fill in the <em class="italic">real</em> implementation, which does more than simply return hardcoded data. (We’ll improve upon this implementation in <a href="B19611_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Saving </em><em class="italic">Form Data</em>).</p>
<ol>
<li value="8">Run your tests again and you’ll see the test succeeds:<pre class="source-code">
<strong class="bold"> </strong><strong class="bold">✓</strong><strong class="bold"> src/routes/birthdays/page.server.test.js (1)</strong>
<strong class="bold">   </strong><strong class="bold">✓</strong><strong class="bold"> /birthdays - load (1)</strong>
<strong class="bold">     </strong><strong class="bold">✓</strong><strong class="bold"> returns a fixture of two items</strong></pre></li>
</ol>
<p>That completes a<a id="_idIndexMarker095"/> working <code>load</code> function. You’ve now covered the basics of test-driving a route’s <code>load</code> function so that it meets SvelteKit’s requirements.</p>
<p>Now we can build the <code>page</code> component for the route.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Test-driving the page component</h1>
<p>It’s time to create the <code>page</code> component<a id="_idIndexMarker096"/> that exists for the route. As ever, we’ll start with a test:</p>
<ol>
<li>Create the <code>src/routes/birthdays/page.test.js</code> file and add the following imports. The last of these is for the <code>page</code> component itself. Because SvelteKit expects the component for a route to exist in a file named <code>+page.svelte</code>, we may as well give the component the name <code>Page</code> (that is what it is, after all):<pre class="source-code">
import { describe, it, expect } from 'vitest';
import {
  render,
  screen
} from '@testing-library/svelte';
import Page from './+page.svelte';</pre></li>
<li>Next, let’s <a id="_idIndexMarker097"/>write out the test. The key part here is that <code>Page</code> gets passed a <code>data</code> prop, which needs to match the structure of our <code>load</code> function. In the actual runtime environment, SvelteKit will invoke the <code>load</code> function and then render the component in <code>+page.svelte</code> with the <code>data</code> prop set to the result of the <code>load</code> function:<pre class="source-code">
describe('/birthdays', () =&gt; {
  const birthdays = [
    { name: 'Hercules', dob: '1994-02-02' },
    { name: 'Athena', dob: '1989-01-01' }
  ];
  it('displays all the birthdays passed to it', () =&gt;
  {
    render(Page, { data: { birthdays } });
    expect(
      screen.queryByText('Hercules')
    ).toBeVisible();
    expect(
      screen.queryByText('Athena')
    ).toBeVisible();
  });
});</pre></li>
</ol>
<p class="callout-heading">Test data fixtures</p>
<p class="callout">Even though they have the same values, there’s no connection between the <code>birthdays</code> value set here and the hardcoded values in the <code>load</code> function. The <code>load</code> function will eventually lose its <em class="italic">seeded</em> data.</p>
<ol>
<li value="3">If you go <a id="_idIndexMarker098"/>ahead and run the test now, you should see the usual failure of the missing file:<pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.test.js [ src/routes/birthdays/page.test.js ]</strong>
<strong class="bold">Error: Failed to load url ./+page.svelte (resolved id: ./+page.svelte). Does the file exist?</strong></pre></li>
<li>Create an empty file at <code>src/routes/birthdays/+page.svelte</code>, and then run tests again:<pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.test.js &gt; /birthdays &gt; displays all the birthdays passed to it</strong>
<strong class="bold">Error: expect(received).toBeVisible()</strong>
<strong class="bold">received value must be an HTMLElement or an SVGElement.</strong></pre></li>
<li>It’s time for the real implementation. Copy the following code, which uses the <code>data</code> prop to display an <code>ol</code> element with a <code>li</code> for each birthday. We use the <code>Birthday</code> component from <a href="B19611_02.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing the Red-Green-Refactor Workflow</em>, to display the birthday for each item in the <code>data.birthdays</code> array:<pre class="source-code">
&lt;script&gt;
  import Birthday from './Birthday.svelte';
  export let data;
&lt;/script&gt;
&lt;h1&gt;Birthday list&lt;/h1&gt;
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
      &lt;Birthday {...birthday} /&gt;
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
</ol>
<p class="callout-heading">Using HTML lists for testability</p>
<p class="callout">When rendering <em class="italic">arrays</em> of items as we have here, it’s always a good idea to use either an <code>ol</code> element (for an ordered list) or a <code>ul</code> element (for an unordered list) as the parent container, and then use <code>li</code> elements for each item in the list. Using list elements increases the testability of your components because you can use locator functions that look specifically for the <code>listitem</code> role, which we’ll see in <a href="B19611_06.xhtml#_idTextAnchor079"><em class="italic">Chapter 6</em></a>, <em class="italic">Editing </em><em class="italic">Form Data</em>.</p>
<p>Notice<a id="_idIndexMarker099"/> also that we’re using the <code>Birthday</code> component to make our tests pass. But our test didn’t explicitly request a <code>Birthday</code> component; the expectations looked like this:</p>
<pre class="source-code">
expect(
  screen.queryByText('Hercules')
).toBeVisible();</pre>
<p>You could argue that the simplest way to make this test pass would be to simply print out the name of the birthday. But that would be ignoring the intent of our testing, which is to display a list of <code>Birthday</code> components.</p>
<p>In <a href="B19611_12.xhtml#_idTextAnchor134"><em class="italic">Chapter 12</em></a><em class="italic">, Using Component Mocks to Clarify Tests</em>, we will look at how we can use component mocks to explicitly state that we want to use a <code>Birthday</code> component here.</p>
<p>With the implementation complete, you can now verify your passing tests.</p>
<ol>
<li value="6">Run the <a id="_idIndexMarker100"/>Vitest test runner and you should see that the test is now passing:<pre class="source-code">
<strong class="bold"> </strong><strong class="bold">✓</strong><strong class="bold"> src/routes/birthdays/page.test.js (1)</strong>
<strong class="bold">   </strong><strong class="bold">✓</strong><strong class="bold"> /birthdays (1)</strong>
<strong class="bold">     </strong><strong class="bold">✓</strong><strong class="bold"> displays all the birthdays passed to it</strong></pre></li>
<li>You can now also run Playwright and see your passing test:<pre class="source-code">
<strong class="bold">  </strong><strong class="bold">✓</strong><strong class="bold">  1 test.js:3:1 › index page has expected h1 (402ms)</strong>
<strong class="bold">  </strong><strong class="bold">✓</strong><strong class="bold">  2 birthdays.test.js:3:1 › lists all birthdays (430ms)</strong>
<strong class="bold">  2 passed (4s)</strong></pre></li>
<li>You can add some styles to the <code>src/routes/birthdays/+page.svelte</code> file:<pre class="source-code">
&lt;style&gt;
  ol {
    list-style-type: none;
    padding-left: 0;
  }
  li {
    padding: 10px;
    margin: 5px;
    border: 1px solid #ccc;
    border-radius: 2px;
  }
&lt;/style&gt;</pre></li>
<li>Finally, run the dev server with <code>npm run dev</code>. Make a note of the base URL for your application and then fire up your browser, and load the <code>/birthdays</code> URL to check <a id="_idIndexMarker101"/>out your work.</li>
</ol>
<p class="callout-heading">Working out the path to load</p>
<p class="callout">The route we’ve built will end up at a location such as <code>https://localhost:5173/birthdays</code>. But the port number is likely to be different for you: you’ll need to run the <code>npm run dev</code> command and look for the base URL that is marked with the <code>Local</code> label.</p>
<p>This section has shown <a id="_idIndexMarker102"/>you how you can test-drive a <code>page</code> component in a file named <code>+page.svelte</code>, which SvelteKit will render for you when you browse to a known route.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Summary</h1>
<p>This chapter has shown you how to write an end-to-end test with Playwright and use that as a scaffold for your Vitest unit tests. The Playwright tests check that all the units are working together, and the framework is doing its job. The Vitest tests check that you are satisfying the contract required from SvelteKit, such as the <code>load</code> function working in the correct fashion.</p>
<p>You’ve also seen how TDD can be used to delay design decisions that aren’t immediately relevant, like how we hardcoded sample data rather than implement any kind of persisted database of birthdays.</p>
<p>In the next chapter, we’ll expand on the same ideas by implementing a SvelteKit form action, enabling you to add new birthdays to the list.</p>
</div>
</div></body></html>