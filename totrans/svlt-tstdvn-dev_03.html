<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor050"/>3</h1>
<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Loading Data into a Route</h1>
<p><strong class="bold">SvelteKit</strong> is very <a id="_idIndexMarker073"/>much about <em class="italic">routing</em>: figuring out what to display once your browser requests a page at a <a id="_idIndexMarker074"/>specific location. For example, the <strong class="source-inline">/birthdays</strong> route that we’ll work on in this chapter. Part of that routing is ensuring that the route has the data available to it. In this chapter, you’ll see how you can test-drive SvelteKit’s <strong class="source-inline">load</strong> function for pulling that data into <span class="No-Break">a component.</span></p>
<p>You’ll also see how Playwright can be used to build an end-to-end test that proves all the various components of <span class="No-Break">this system.</span></p>
<p>This chapter covers <span class="No-Break">the following:</span></p>
<ul>
<li>Using Playwright to specify <span class="No-Break">end-to-end behavior</span></li>
<li>Deciding an approach to make the end-to-end <span class="No-Break">test pass</span></li>
<li>Test-driving the <span class="No-Break">load function</span></li>
<li>Test-driving the <span class="No-Break">page component</span></li>
</ul>
<p>By the end of the chapter, you’ll have test-driven a functioning SvelteKit route that you can view in your web browser, and you’ll have learned the key differences between Playwright end-to-end tests and Vitest <span class="No-Break">unit tests.</span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Using Playwright to specify end-to-end behavior</h1>
<p>In this section, you will<a id="_idIndexMarker075"/> write your first Playwright test and learn about the various function calls within it, and you’ll learn about differentiating between Playwright end-to-end tests and Vitest <span class="No-Break">unit tests.</span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Writing the test and watching it fail</h2>
<p>The test we are <a id="_idIndexMarker076"/>going to write is entitled <strong class="source-inline">lists all birthdays</strong> and it will perform the <span class="No-Break">following steps:</span></p>
<ol>
<li>Browse to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">birthdays</strong></span><span class="No-Break"> location.</span></li>
<li>Look for the text <strong class="source-inline">Hercules</strong> and <strong class="source-inline">Athena</strong>, which it will take as evidence that the test <span class="No-Break">has passed.</span></li>
</ol>
<p>Once the test is in place, we’ll stop to think about how this <strong class="source-inline">Hercules</strong> and <strong class="source-inline">Athena</strong> data should get into <span class="No-Break">our system.</span></p>
<p>Create a new file named <strong class="source-inline">tests/birthdays.test.js</strong> and add the <span class="No-Break">following content:</span></p>
<pre class="source-code">
import { expect, test } from '@playwright/test';
test('lists all birthdays', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  await expect(
    page.getByText('Hercules')
  ).toBeVisible();
  await expect(
    page.getByText('Athena')
  ).toBeVisible();
});</pre>
<p>You can see some things here that are similar to the Vitest tests, such as the use of <strong class="source-inline">expect</strong> and the <span class="No-Break"><strong class="source-inline">toBeVisible</strong></span><span class="No-Break"> matcher.</span></p>
<p>However, some things are different. For a start, the test is marked as <strong class="source-inline">async</strong> and all the function calls (including the <strong class="source-inline">expect</strong> function calls) are marked <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break">.</span></p>
<p>That’s necessary because Playwright is driving a headless browser, meaning it’s started a real browser process that runs in the background and is invisible to you. Playwright has no mechanism for determining when the browser has completed working, beyond waiting patiently and frequently checking the browser state. Therefore, most of its internal logic is driven by waits and timeouts: the browser is given a certain amount of time, generally a few seconds, to get <span class="No-Break">things displayed.</span></p>
<p>The <strong class="source-inline">page.goto</strong> call is instructing this headless browser to navigate to the <strong class="source-inline">/birthdays</strong> endpoint. Playwright takes care of spinning up a real dev server in the background and ensuring that any relative URLs (such as <strong class="source-inline">/birthdays</strong>) are converted to absolute URLs pointing at this dev server (<span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">https://localhost:5173/birthdays</strong></span><span class="No-Break">).</span></p>
<p>Go ahead and run<a id="_idIndexMarker077"/> the test now, using the <strong class="source-inline">npm test</strong> shell command. You should see an almost immediate <span class="No-Break">failure appear:</span></p>
<pre class="source-code">
     1 birthdays.test.js:3:1 › lists all birthdays
  ✓  2 test.js:3:1 › index page has expected h1 (618ms)
[WebServer] Error: Not found: /birthdays</pre>
<p>With the test complete, let’s take a more detailed look at the difference between Vitest tests and <span class="No-Break">Playwright tests.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Understanding the difference between Vitest tests and Playwright tests</h2>
<p>There are <a id="_idIndexMarker078"/>fundamental differences between how Vitest tests<a id="_idIndexMarker079"/> work and how Playwright tests work. Both play their part <span class="No-Break">in TDD.</span></p>
<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> shows how each type of test encompasses your code. Playwright tests are often referred to as end-to-end tests and they are high-level, with each test exercising a whole lot of code. Vitest tests are often called unit tests. They are very detailed and exercise just a small piece of <span class="No-Break">the code.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project" height="793" src="image/Figure_3.1_B19611.jpg" width="1484"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project</p>
<p>Playwright tests are often a good starting point when embarking on building a new feature. They may even be written by project stakeholders who are not developers but still participate in defining features. In <a href="B19611_13.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter </em></span><span class="No-Break"><em class="italic">13</em></span></a>, <em class="italic">Adding Cucumber Tests</em>, we’ll see how this can be done with plain English syntax rather than <span class="No-Break">JavaScript code.</span></p>
<p>Playwright tests are often written against the browser UI. They exercise the whole system, including the web browser and any out-of-process resources such as databases. When working with a SvelteKit application, the Playwright test runner starts up the SvelteKit web server and executes all of the SvelteKit runtime code for <span class="No-Break">managing routes.</span></p>
<p>In contrast, the <a id="_idIndexMarker080"/>Vitest test runner does not load up the SvelteKit <a id="_idIndexMarker081"/>web server and does not execute any of its code. Instead, it loads your JavaScript files directly into the same Node process that Vitest and your test suites are <span class="No-Break">loaded into.</span></p>
<p>While Playwright tests are good for focusing a team on what needs to be built, they often have nothing to say about the internal design of the software or even the architecture of the system as a whole. This is where Vitest unit tests come in. They can be used by developers to work out the <em class="italic">how</em> of <span class="No-Break">a system.</span></p>
<p>There are a number of ways that unit tests help with design. For example, if a unit test is proving difficult to write, that’s sometimes a sign that the application design is too complex. Breaking apart the units in a different way can lead to the unit tests becoming <span class="No-Break">much simpler.</span></p>
<p>Playwright tests are often kept low on specifics leaving the unit tests to cover the details. For example, in the test we just wrote, we are interested in the listing of the birthdays that the system knows about but notice that we only checked by looking for the names of people, and not the birthdays. We leave the complete birthday checks to the unit tests for the <strong class="source-inline">Birthday</strong> component, which we already wrote in <a href="B19611_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Introducing the </em><span class="No-Break"><em class="italic">Red-Green-Refactor Workflow</em></span><span class="No-Break">.</span></p>
<p>This way, we <a id="_idIndexMarker082"/>end up with lots of low-level Vitest unit tests <a id="_idIndexMarker083"/>and a few higher-level Playwright tests. This is the classic test automation pyramid as described by Mike Cohn in the book <em class="italic">Succeeding with Agile</em>. It encourages a testing strategy that includes many unit tests, some service tests, and just a dollop of <span class="No-Break">UI tests.</span></p>
<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em> shows how the test automated pyramid can be applied to SvelteKit projects. Playwright end-to-end tests can be written against both the UI and also against specific API endpoints, and your unit tests are written for the <span class="No-Break">Vitest runner.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 3.2 – The testing pyramid as applied to SvelteKit projects" height="660" src="image/Figure_3.2_B19611.jpg" width="1239"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The testing pyramid as applied to SvelteKit projects</p>
<p>One reason for structuring automated tests in this way is that unit tests are cheap to create and maintain, whereas UI tests are expensive in terms of time and energy put <span class="No-Break">into them.</span></p>
<p>The service<a id="_idIndexMarker084"/> tests are like the UI tests in that they cover a whole<a id="_idIndexMarker085"/> flow through a system but avoid the UI. For example, they may call HTTP API endpoints directly. That can be helpful because the UI tends to be the most brittle component of the system, and driving a UI can take a while as you wait for the on-screen changes to <span class="No-Break">be rendered.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Modern web browser environments, together with modern test runners such as Playwright, have gotten much better at handling automated <span class="No-Break">UI tests.</span></p>
<p>Another reason the classic test automation pyramid makes sense is that unit tests are often very fast to execute. You can have many unit tests, each of which executes just a tiny fraction of the code surface. When one of those tests breaks, it’s very quick to read the test description or test code and figure out where in the application code the <span class="No-Break">failure lies.</span></p>
<p>It’s also worth remembering that unit tests serve to document all of the technical design decisions taken when writing the code, and this documentation is invaluable in understanding the history of <span class="No-Break">a project.</span></p>
<p>Finally, keep in mind that<a id="_idIndexMarker086"/> Vitest unit tests do not test the SvelteKit <a id="_idIndexMarker087"/>server-side runtime environment. That means, for example, that a Vitest unit test can test that you correctly defined a <strong class="source-inline">load</strong> function, but it cannot test that the route is hooked up correctly. For that, you need a Playwright test that compiles and runs your components and routes just as if it was a real <span class="No-Break">browser environment.</span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Deciding an approach to make the end-to-end test pass</h1>
<p>With <a id="_idIndexMarker088"/>that all said, how do we begin writing Vitest unit tests now that we have a Playwright test that defines what <span class="No-Break">we want?</span></p>
<p>The Playwright test looks for the names <strong class="source-inline">Hercules</strong> and <strong class="source-inline">Athena</strong>. The test makes an assumption that these two people have their birthdays listed in the system and that the page at <strong class="source-inline">/birthdays</strong> lists them. But how do we get them into the system in the <span class="No-Break">first place?</span></p>
<p>In true TDD style, we can defer this decision and simply hardcode these two birthdays in the system. After all, the test doesn’t seem to care about how the data gets into the system, only about how it <span class="No-Break">is presented.</span></p>
<p>We can come back to how the birthdays are added later. In fact, we’ll do this in <a href="B19611_08.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Creating Matchers to Simplify Tests</em>. We can also make use of our <strong class="source-inline">Birthday</strong> component from <a href="B19611_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Introducing the Red-Green-Refactor Workflow</em>, to display each birthday <span class="No-Break">in turn.</span></p>
<p>Therefore, what we need to do is <span class="No-Break">the following:</span></p>
<ol>
<li>Create a <strong class="source-inline">load</strong> function that returns hardcoded birthday data for Hercules and Athena. This needs to exist within the <span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.server.js</strong></span><span class="No-Break"> file.</span></li>
<li>Create a <strong class="source-inline">page</strong> component that takes the data from <strong class="source-inline">load</strong> and displays a <strong class="source-inline">Birthday</strong> component for each of the birthdays given. This needs to exist <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.svelte</strong></span><span class="No-Break">.</span></li>
</ol>
<p>SvelteKit takes care of matching the <strong class="source-inline">/birthdays</strong> route to our files in the <strong class="source-inline">src/routes/birthdays</strong> directory. After calling <strong class="source-inline">load</strong>, it will pass the result into the <strong class="source-inline">data</strong> prop in the <strong class="source-inline">+</strong><span class="No-Break"><strong class="source-inline">page.svelte</strong></span><span class="No-Break"> component.</span></p>
<p>That covers <a id="_idIndexMarker089"/>how to write a basic Playwright end-to-end test. We’ve discussed the differences between Playwright end-to-end and Vitest unit tests, and we’ve come up with a plan for the rest of <span class="No-Break">the chapter.</span></p>
<p>The next section covers how to test-drive a basic, hardcoded version of our <span class="No-Break"><strong class="source-inline">load</strong></span><span class="No-Break"> function.</span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Test-driving the load function</h1>
<p>Now that <a id="_idIndexMarker090"/>we’ve decided to implement a <strong class="source-inline">load</strong> function that returns hardcoded birthday data for Hercules and Athena, the actual change has become <span class="No-Break">very simple.</span></p>
<p>The <strong class="source-inline">load</strong> function is a special SvelteKit function that will be invoked when a request comes in for the given route. So, when the user navigates to the <strong class="source-inline">/birthdays</strong> route, SvelteKit calls the <strong class="source-inline">load</strong> function in the <strong class="source-inline">src/routes/birthdays/+page.server.js</strong> file and then renders the component in the <span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.svelte</strong></span><span class="No-Break"> file.</span></p>
<p>Follow these steps to create the <strong class="source-inline">load</strong> function <span class="No-Break">using TDD:</span></p>
<ol>
<li>Create a new Vitest test file named <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong> and start it off as shown. We are importing the <strong class="source-inline">load</strong> function from a <strong class="source-inline">+page.server.js</strong> file that doesn’t yet exist. We call the function in our test and store <span class="No-Break">the result:</span><pre class="source-code">
import { describe, it, expect } from 'vitest';
import { load } from './+page.server.js';
describe('/birthdays - load', () =&gt; {
  it('returns a fixture of two items', () =&gt; {
    const result = load();
  });
});</pre></li>
</ol>
<p class="callout-heading">Naming describe blocks for load functions</p>
<p class="callout">I’ve named the <strong class="source-inline">describe</strong> block <strong class="source-inline">/birthdays - load</strong>, which demonstrates a standard naming pattern that can be used for the <strong class="source-inline">load</strong> functions <span class="No-Break">for routes.</span></p>
<ol>
<li value="2">Complete<a id="_idIndexMarker091"/> the test with the <span class="No-Break">following expectation:</span><pre class="source-code">
it('returns a fixture of two items', () =&gt; {
  const result = load();
<strong class="bold">  expect(result.birthdays).toEqual([</strong>
<strong class="bold">    { name: 'Hercules', dob: '1994-02-02' },</strong>
<strong class="bold">    { name: 'Athena', dob: '1989-01-01' }</strong>
<strong class="bold">  ]);</strong>
});</pre></li>
</ol>
<p class="callout-heading">One expectation per test</p>
<p class="callout">This entire test contains just a single call to <strong class="source-inline">expect</strong>. Generally, when writing tests, I find it’s useful to stick to just one expectation if possible. That helps to keep a strong link between the test description and the contents of the <span class="No-Break"><strong class="source-inline">expect</strong></span><span class="No-Break"> call.</span></p>
<p class="callout">It’s often the case (as in this test) that you can stuff a whole lot of checks in a <span class="No-Break">single expectation.</span></p>
<p class="callout">The <strong class="source-inline">toEqual</strong> matcher has a special <em class="italic">deep equality</em> mechanism that means each level of an object or array can be checked for its value, rather than its identity. And moreover, we can use constraint functions such as <strong class="source-inline">objectContaining</strong>, which we’ll see in <a href="B19611_06.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Editing </em><span class="No-Break"><em class="italic">Form Data</em></span><span class="No-Break">.</span></p>
<ol>
<li value="3">Go <a id="_idIndexMarker092"/>ahead and run the test with your Vitest test runner. This gives the <span class="No-Break">following output:</span><pre class="source-code">
<strong class="bold"> FAIL  </strong><strong class="bold">src/routes/birthdays/page.server.test.js [ src/routes/birthdays/page.server.test.js ]</strong>
<strong class="bold">Error: Failed to load url ./+page.server.js (resolved id: ./+page.server.js). Does the file exist?</strong></pre></li>
<li>Do as it suggests and create an empty file at the <strong class="source-inline">src/routes/birthdays/+page.server.js</strong> location, and then rerun your tests. You should see <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - load &gt; returns a fixture of two items</strong>
<strong class="bold">TypeError: load is not a function</strong>
<strong class="bold"> </strong><strong class="bold">❯</strong><strong class="bold"> src/routes/birthdays/page.server.test.js:6:18</strong>
<strong class="bold">      4| describe('/birthdays - load', () =&gt; {</strong>
<strong class="bold">      5|  it('returns a fixture of two items', () =&gt; {</strong>
<strong class="bold">      6|  </strong><strong class="bold"> const result = load();</strong>
<strong class="bold">       |                  ^</strong>
<strong class="bold">      7|   expect(result.birthdays).toEqual([</strong>
<strong class="bold">      8|    expect.objectContaining({</strong></pre></li>
<li>Okay, marvelous: <strong class="source-inline">load is not a function</strong>. Let’s create a basic <strong class="source-inline">load</strong> function, then, with absolutely nothing in it. Add this to the <span class="No-Break">new file:</span><pre class="source-code">
export const load = () =&gt; ({});</pre></li>
<li>Rerun your<a id="_idIndexMarker093"/> tests. You’ll get <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.server.test.js &gt; /birthdays - load &gt; returns a fixture of two items</strong>
<strong class="bold"> AssertionError: expected [ { name: 'Hercules', …(2) }, …(1) ] to deeply equal [ { name: 'Hercules', …(1) }, …(1) ]</strong>
<strong class="bold"> </strong><strong class="bold">❯</strong><strong class="bold"> src/routes/birthdays/page.server.test.js:14:28</strong>
<strong class="bold">     12|  it('returns a fixture of two items', () =&gt; {</strong>
<strong class="bold">     13|   const result = load();</strong>
<strong class="bold">     14|  </strong><strong class="bold"> expect(result.birthdays).toEqual([</strong>
<strong class="bold">       |                            ^</strong>
<strong class="bold">     15|    { name: 'Hercules', dob: '1994-02-02' },</strong>
<strong class="bold">     16|    { name: 'Athena', dob: '1989-01-01' }</strong>
<strong class="bold">  - Expected  - 10</strong>
<strong class="bold">  + Received</strong><strong class="bold">  + 1</strong>
<strong class="bold">  - Array [</strong>
<strong class="bold">  -   Object {</strong>
<strong class="bold">  -     "dob": "1994-02-02",</strong>
<strong class="bold">  -     "name": "Hercules",</strong>
<strong class="bold">  </strong><strong class="bold">-   },</strong>
<strong class="bold">  -   Object {</strong>
<strong class="bold">  -     "dob": "1989-01-01",</strong>
<strong class="bold">  -     "name": "Athena",</strong>
<strong class="bold">  -   },</strong>
<strong class="bold">  </strong><strong class="bold">- ]"</strong>
<strong class="bold">  + "undefined"</strong></pre></li>
<li>To fix the<a id="_idIndexMarker094"/> issue, all we need to do is fill in the hardcoded values. Update the code in <strong class="source-inline">src/routes/birthdays/+page.server.js</strong> to look <span class="No-Break">as follows:</span><pre class="source-code">
export const load = () =&gt; ({
<strong class="bold">  birthdays: [</strong>
<strong class="bold">    { name: 'Hercules', dob: '1994-02-02' },</strong>
<strong class="bold">    { name: 'Athena', dob: '1989-01-01' }</strong>
<strong class="bold">  ]</strong>
});</pre></li>
</ol>
<p class="callout-heading">Plumbing and hardcoded values</p>
<p class="callout">It may feel a bit pointless doing this, but the value is in getting the plumbing into place. The test we’ve written here will serve as a useful regression test when we come to fill in the <em class="italic">real</em> implementation, which does more than simply return hardcoded data. (We’ll improve upon this implementation in <a href="B19611_04.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Saving </em><span class="No-Break"><em class="italic">Form Data</em></span><span class="No-Break">).</span></p>
<ol>
<li value="8">Run your tests again and you’ll see the <span class="No-Break">test succeeds:</span><pre class="source-code">
<strong class="bold"> </strong><strong class="bold">✓</strong><strong class="bold"> src/routes/birthdays/page.server.test.js (1)</strong>
<strong class="bold">   </strong><strong class="bold">✓</strong><strong class="bold"> /birthdays - load (1)</strong>
<strong class="bold">     </strong><strong class="bold">✓</strong><strong class="bold"> returns a fixture of two items</strong></pre></li>
</ol>
<p>That completes a<a id="_idIndexMarker095"/> working <strong class="source-inline">load</strong> function. You’ve now covered the basics of test-driving a route’s <strong class="source-inline">load</strong> function so that it meets <span class="No-Break">SvelteKit’s requirements.</span></p>
<p>Now we can build the <strong class="source-inline">page</strong> component for <span class="No-Break">the route.</span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Test-driving the page component</h1>
<p>It’s time to create the <strong class="source-inline">page</strong> component<a id="_idIndexMarker096"/> that exists for the route. As ever, we’ll start with <span class="No-Break">a test:</span></p>
<ol>
<li>Create the <strong class="source-inline">src/routes/birthdays/page.test.js</strong> file and add the following imports. The last of these is for the <strong class="source-inline">page</strong> component itself. Because SvelteKit expects the component for a route to exist in a file named <strong class="source-inline">+page.svelte</strong>, we may as well give the component the name <strong class="source-inline">Page</strong> (that is what it is, <span class="No-Break">after all):</span><pre class="source-code">
import { describe, it, expect } from 'vitest';
import {
  render,
  screen
} from '@testing-library/svelte';
import Page from './+page.svelte';</pre></li>
<li>Next, let’s <a id="_idIndexMarker097"/>write out the test. The key part here is that <strong class="source-inline">Page</strong> gets passed a <strong class="source-inline">data</strong> prop, which needs to match the structure of our <strong class="source-inline">load</strong> function. In the actual runtime environment, SvelteKit will invoke the <strong class="source-inline">load</strong> function and then render the component in <strong class="source-inline">+page.svelte</strong> with the <strong class="source-inline">data</strong> prop set to the result of the <span class="No-Break"><strong class="source-inline">load</strong></span><span class="No-Break"> function:</span><pre class="source-code">
describe('/birthdays', () =&gt; {
  const birthdays = [
    { name: 'Hercules', dob: '1994-02-02' },
    { name: 'Athena', dob: '1989-01-01' }
  ];
  it('displays all the birthdays passed to it', () =&gt;
  {
    render(Page, { data: { birthdays } });
    expect(
      screen.queryByText('Hercules')
    ).toBeVisible();
    expect(
      screen.queryByText('Athena')
    ).toBeVisible();
  });
});</pre></li>
</ol>
<p class="callout-heading">Test data fixtures</p>
<p class="callout">Even though they have the same values, there’s no connection between the <strong class="source-inline">birthdays</strong> value set here and the hardcoded values in the <strong class="source-inline">load</strong> function. The <strong class="source-inline">load</strong> function will eventually lose its <span class="No-Break"><em class="italic">seeded</em></span><span class="No-Break"> data.</span></p>
<ol>
<li value="3">If you go <a id="_idIndexMarker098"/>ahead and run the test now, you should see the usual failure of the <span class="No-Break">missing file:</span><pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.test.js [ src/routes/birthdays/page.test.js ]</strong>
<strong class="bold">Error: Failed to load url ./+page.svelte (resolved id: ./+page.svelte). Does the file exist?</strong></pre></li>
<li>Create an empty file at <strong class="source-inline">src/routes/birthdays/+page.svelte</strong>, and then run <span class="No-Break">tests again:</span><pre class="source-code">
<strong class="bold"> FAIL  src/routes/birthdays/page.test.js &gt; /birthdays &gt; displays all the birthdays passed to it</strong>
<strong class="bold">Error: expect(received).toBeVisible()</strong>
<strong class="bold">received value must be an HTMLElement or an SVGElement.</strong></pre></li>
<li>It’s time for the real implementation. Copy the following code, which uses the <strong class="source-inline">data</strong> prop to display an <strong class="source-inline">ol</strong> element with a <strong class="source-inline">li</strong> for each birthday. We use the <strong class="source-inline">Birthday</strong> component from <a href="B19611_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Introducing the Red-Green-Refactor Workflow</em>, to display the birthday for each item in the <span class="No-Break"><strong class="source-inline">data.birthdays</strong></span><span class="No-Break"> array:</span><pre class="source-code">
&lt;script&gt;
  import Birthday from './Birthday.svelte';
  export let data;
&lt;/script&gt;
&lt;h1&gt;Birthday list&lt;/h1&gt;
&lt;ol&gt;
  {#each data.birthdays as birthday}
    &lt;li&gt;
      &lt;Birthday {...birthday} /&gt;
    &lt;/li&gt;
  {/each}
&lt;/ol&gt;</pre></li>
</ol>
<p class="callout-heading">Using HTML lists for testability</p>
<p class="callout">When rendering <em class="italic">arrays</em> of items as we have here, it’s always a good idea to use either an <strong class="source-inline">ol</strong> element (for an ordered list) or a <strong class="source-inline">ul</strong> element (for an unordered list) as the parent container, and then use <strong class="source-inline">li</strong> elements for each item in the list. Using list elements increases the testability of your components because you can use locator functions that look specifically for the <strong class="source-inline">listitem</strong> role, which we’ll see in <a href="B19611_06.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Editing </em><span class="No-Break"><em class="italic">Form Data</em></span><span class="No-Break">.</span></p>
<p>Notice<a id="_idIndexMarker099"/> also that we’re using the <strong class="source-inline">Birthday</strong> component to make our tests pass. But our test didn’t explicitly request a <strong class="source-inline">Birthday</strong> component; the expectations looked <span class="No-Break">like this:</span></p>
<pre class="source-code">
expect(
  screen.queryByText('Hercules')
).toBeVisible();</pre>
<p>You could argue that the simplest way to make this test pass would be to simply print out the name of the birthday. But that would be ignoring the intent of our testing, which is to display a list of <span class="No-Break"><strong class="source-inline">Birthday</strong></span><span class="No-Break"> components.</span></p>
<p>In <a href="B19611_12.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic">Chapter 12</em></span></a><em class="italic">, Using Component Mocks to Clarify Tests</em>, we will look at how we can use component mocks to explicitly state that we want to use a <strong class="source-inline">Birthday</strong> <span class="No-Break">component here.</span></p>
<p>With the implementation complete, you can now verify your <span class="No-Break">passing tests.</span></p>
<ol>
<li value="6">Run the <a id="_idIndexMarker100"/>Vitest test runner and you should see that the test is <span class="No-Break">now passing:</span><pre class="source-code">
<strong class="bold"> </strong><strong class="bold">✓</strong><strong class="bold"> src/routes/birthdays/page.test.js (1)</strong>
<strong class="bold">   </strong><strong class="bold">✓</strong><strong class="bold"> /birthdays (1)</strong>
<strong class="bold">     </strong><strong class="bold">✓</strong><strong class="bold"> displays all the birthdays passed to it</strong></pre></li>
<li>You can now also run Playwright and see your <span class="No-Break">passing test:</span><pre class="source-code">
<strong class="bold">  </strong><strong class="bold">✓</strong><strong class="bold">  1 test.js:3:1 › index page has expected h1 (402ms)</strong>
<strong class="bold">  </strong><strong class="bold">✓</strong><strong class="bold">  2 birthdays.test.js:3:1 › lists all birthdays (430ms)</strong>
<strong class="bold">  2 passed (4s)</strong></pre></li>
<li>You can add some styles to the <span class="No-Break"><strong class="source-inline">src/routes/birthdays/+page.svelte</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;style&gt;
  ol {
    list-style-type: none;
    padding-left: 0;
  }
  li {
    padding: 10px;
    margin: 5px;
    border: 1px solid #ccc;
    border-radius: 2px;
  }
&lt;/style&gt;</pre></li>
<li>Finally, run the dev server with <strong class="source-inline">npm run dev</strong>. Make a note of the base URL for your application and then fire up your browser, and load the <strong class="source-inline">/birthdays</strong> URL to check <a id="_idIndexMarker101"/>out <span class="No-Break">your work.</span></li>
</ol>
<p class="callout-heading">Working out the path to load</p>
<p class="callout">The route we’ve built will end up at a location such as <strong class="source-inline">https://localhost:5173/birthdays</strong>. But the port number is likely to be different for you: you’ll need to run the <strong class="source-inline">npm run dev</strong> command and look for the base URL that is marked with the <span class="No-Break"><strong class="source-inline">Local</strong></span><span class="No-Break"> label.</span></p>
<p>This section has shown <a id="_idIndexMarker102"/>you how you can test-drive a <strong class="source-inline">page</strong> component in a file named <strong class="source-inline">+page.svelte</strong>, which SvelteKit will render for you when you browse to a <span class="No-Break">known route.</span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Summary</h1>
<p>This chapter has shown you how to write an end-to-end test with Playwright and use that as a scaffold for your Vitest unit tests. The Playwright tests check that all the units are working together, and the framework is doing its job. The Vitest tests check that you are satisfying the contract required from SvelteKit, such as the <strong class="source-inline">load</strong> function working in the <span class="No-Break">correct fashion.</span></p>
<p>You’ve also seen how TDD can be used to delay design decisions that aren’t immediately relevant, like how we hardcoded sample data rather than implement any kind of persisted database <span class="No-Break">of birthdays.</span></p>
<p>In the next chapter, we’ll expand on the same ideas by implementing a SvelteKit form action, enabling you to add new birthdays to <span class="No-Break">the list.</span></p>
</div>
</div></body></html>