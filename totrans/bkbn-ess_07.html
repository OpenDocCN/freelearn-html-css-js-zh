<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Fitting Square Pegs in Round Holes – Advanced Backbone Techniques</h1></div></div></div><p>In this chapter, we will look at various advanced uses of Backbone, including the following:</p><div><ul class="itemizedlist"><li class="listitem">Using methods in place of properties</li><li class="listitem">Overriding a class's constructor</li><li class="listitem">Using mixins to share logic between classes</li><li class="listitem">Implementing the publish/subscribe pattern</li><li class="listitem">Wrapping widgets from other libraries in Backbone <code class="literal">Views</code></li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Taking it up a notch</h1></div></div></div><p>In the previous chapters, we've discussed the basics of using Backbone's four classes, and while these basics are more than enough to make you productive with Backbone, we've deliberately left out a few of the more complicated details. In this chapter, we'll explore those left-out details and how they relate to certain advanced Backbone techniques.</p><p>Before we proceed, however, it is important to note that all of the techniques discussed in this chapter are intended to be used to solve specific problems, and not as general-purpose patterns. While there is certainly nothing "wrong" with using any of these techniques, they will make your code more complex and thus, less intuitive and harder to maintain. Thus, it is recommended that you avoid using any of the techniques discussed in this chapter unless you specifically need to do so to solve a particular problem.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Methods in place of properties</h1></div></div></div><p>Many of the properties of <a id="id235" class="indexterm"/>Backbone classes have the option of being defined as functions instead of as primitives. In fact, we've already seen one instance of this behavior in the <code class="literal">url</code> property of <code class="literal">Models</code> and <code class="literal">Collections</code>. As we learned in <a class="link" title="Chapter 3. Accessing Server Data with Models" href="part0029.xhtml#aid-RL0A1">Chapter 3</a>, <em>Accessing Server Data with Models</em>, this property can be a simple string, but if you have a more complex URL that requires logic to generate, you can instead use a function that returns a string.</p><p>This same approach can be used with a number of Backbone properties, including the following:</p><div><ul class="itemizedlist"><li class="listitem">For Models:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">defaults</code></li><li class="listitem"><code class="literal">url</code></li><li class="listitem"><code class="literal">urlRoot</code></li></ul></div></li><li class="listitem">For Views:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">attributes</code></li><li class="listitem"><code class="literal">className</code></li><li class="listitem"><code class="literal">events</code></li><li class="listitem"><code class="literal">id</code></li><li class="listitem"><code class="literal">tagName</code></li></ul></div></li><li class="listitem">For Routers:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">routes</code></li></ul></div></li></ul></div><p>For instance, let's say you wanted to have <code class="literal">View</code> that can generate either <code class="literal">&lt;input&gt;</code> or <code class="literal">&lt;select&gt;</code> based on whether or not it has <code class="literal">Collection</code>. By using a function in place of a string for our <code class="literal">Views</code>
<code class="literal"> tagName</code> property of the <code class="literal">Views</code>, we can do exactly that:</p><div><pre class="programlisting">var VariableTagView = Backbone.View.extend({
    tagName: function() {
        if (this.collection) {
            return 'select';
        } else {
            return 'input';
        }
    }
});</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec30"/>Collection.model as a factory method</h2></div></div></div><p>The <code class="literal">Collection</code> class <a id="id236" class="indexterm"/>also has a property that can be replaced with a function, but unlike the other properties, this one isn't normally a primitive… it's a Backbone <code class="literal">Model</code> subclass. As discussed in <a class="link" title="Chapter 4. Organizing Models with Collections" href="part0037.xhtml#aid-1394Q1">Chapter 4</a>, <em>Organizing Models with Collections</em>, the <em>model</em> property of a <code class="literal">Collection</code> class determines what type of <code class="literal">Model</code> will be created by that <code class="literal">Collection</code>. Normally, each <code class="literal">Collection</code> class can have only a single <em>model</em> property and thus, can only create a single type of <code class="literal">Model</code>.</p><p>However, there is a way around this limitation: If we replace the <em>model</em> property of our <code class="literal">Collection</code> with a function that returns new <code class="literal">Models</code>, Backbone will cheerfully overlook the fact that the <code class="literal">model</code> property isn't actually a <code class="literal">Model</code> subclass at all. For example, let's say our server has a "/book" API endpoint that returns JSON for two types of books: fiction and nonfiction. Let's also say that we have two different <code class="literal">Model</code> classes, one for each type of book. If we wanted to be able to have a <code class="literal">Collection</code> class that fetches the JSON for both types of books from a single end point but uses the appropriate <code class="literal">model</code> function to instantiate each type of book, we could use a factory "model" function, as follows:</p><div><pre class="programlisting">var FictionBook = Backbone.Model.extend({
    // insert logic for fiction books here});
var NonFictionBook = Backbone.Model.extend({
    // insert logic for non-fiction books here});
var FictionAndNonFictionBooks = Backbone.Collection.extend({
    model: function(attributes, options) {
        if (attributes.isFiction) {
            return new FictionBook(attributes, options);
        } else {
            return new NonFictionBook(attributes, options);
        }
    },
    url: '/book'});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Overriding a class constructor</h1></div></div></div><p>Whenever a<a id="id237" class="indexterm"/> Backbone class is instantiated, it runs the code defined in its <code class="literal">initialize</code> method. However, this code isn't run until after the new object has been instantiated. This means that even if you define an <code class="literal">initialize</code> method for a <code class="literal">Model</code> class, the attributes of that <code class="literal">Model</code> class will already have been set before your <code class="literal">initialize</code> code is even called.</p><p>Normally, this is a good thing, as it is convenient to have things like the attributes of the <code class="literal">Model</code> class already set, but sometimes, we want to take control before this happens. For example, let's reimagine our previous scenario of fiction and nonfiction books, only this time instead of having a single <code class="literal">Collection</code> class that can create both types of books, we want a <code class="literal">Collection</code> that only creates one type and we want this type decided by the first book that we give the <code class="literal">Collection</code> class when its instantiated.</p><p>In other words, if the first book given to our <code class="literal">Collection</code> class has the <code class="literal">isFiction</code> property, we want our <code class="literal">Collection</code> class to have the <code class="literal">Models</code> property of <code class="literal">FictionBook</code>; otherwise, we want it to have the <code class="literal">Models</code> property of <code class="literal">NonFictionBook</code>. If we do this inside an <code class="literal">initialize</code> method, the "model" option will already have been set on the <code class="literal">Collection</code> class before the <code class="literal">initialize</code> method is run, and any <code class="literal">Model</code> attributes that we pass in it will already have been converted into <code class="literal">Models</code>. Therefore, we need to add logic that runs before <code class="literal">initialize</code>. We <a id="id238" class="indexterm"/>can do this by overriding the constructor of the <code class="literal">Collection Constructor</code> method, as follows:</p><div><pre class="programlisting">var FictionOrNonFictionBooks = Backbone.Collection.extend({
    constructor: function(models, options) {
        if (models[0].isFiction) {
            options.model = FictionBook;
        } else {
            options.model = NonFictionBook;
        }
        return Backbone.Collection.apply(models, options);
    }
});</pre></div><p>Notice how we still called the original <code class="literal">Collection</code>
<code class="literal"> Constructor</code> method from within our overridden version; if we hadn't done so, none of Backbone's normal logic would run and we wouldn't even have a proper <code class="literal">Collection</code> class when we're done.</p><p>As with the other techniques discussed in this chapter, it is not recommended that you override constructors very often. If at all possible you should override the <code class="literal">initialize</code> method instead. Constructor overriding should mainly be left to cases where you want to preprocess the arguments that go into a Backbone object before that object actually gets created.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Class mixins</h1></div></div></div><p>Backbone provides a <a id="id239" class="indexterm"/>very powerful class system, but sometimes, even this class system isn't enough. For instance, let's say you have several classes that all contain several identical methods. The popular <strong>Don't Repeat Yourself</strong> (<strong>DRY)</strong> <a id="id240" class="indexterm"/>programming principle suggests that you should eliminate the duplicate versions of the methods and instead, define them all together in just one place in your code.</p><p>Normally, you could do so by refactoring these methods into a common parent class of these classes. But what if these classes can't share a common parent class? For instance, what if one of these classes is a <code class="literal">Model</code> class and the other a <code class="literal">Collection</code> class?</p><p>In this case, you need to rely on something called a mixin. A mixin is just an object that holds one or more methods (or even primitive properties) that you want to share between several classes. For example, if we wanted to share a couple of logging-related methods between several classes, we could create a mixin of these methods, as follows:</p><div><pre class="programlisting">var loggingMixin = {
    startLogging: function() {
        Logger.startLogging(this);
    },
    stopLogging: function() {
        Logger.stopLogging(this);
    }
}</pre></div><p>Once you've defined your mixin, the next step is to "mix it in" to the definition of your class. This means modifying the <code class="literal">prototype</code> of the class to include the methods from our mixin. For instance, let's say we have a book <code class="literal">Model</code>:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({
    defaults: {currentPage: 1},

    read: function() {
        // TODO: add logic to read a book here
    }
});</pre></div><p>Because Backbone's syntax makes<a id="id241" class="indexterm"/> creating our new class so simple, it's easy to miss the fact that we're actually defining a prototype object here, but if we change things just a little, it suddenly becomes more obvious:</p><div><pre class="programlisting">var bookPrototype = {
    defaults: {currentPage: 1},

    read: function() {
        // TODO: add logic to read a book here
    }
};Book = Backbone.Model.extend(bookPrototype);</pre></div><p>Once we've separated the Book prototype, we can augment it with our mixin. We could do this manually:</p><div><pre class="programlisting">bookPrototype.startLogging = loggingMixin.startLogging;
bookPrototype.stopLogging = loggingMixin.stopLogging;</pre></div><p>However, this won't work well if we have a lot of methods to mixin, or if our mixin later gets new methods added. Instead, we can use Underscore's <code class="literal">extend</code> function to extend all of the methods in our mixin on to the <code class="literal">Book</code> prototype in a single command: <code class="literal">_.extend(bookPrototype, loggingMixin);</code>
</p><p>With just this one line, we've added a whole set of logging-related methods to our <code class="literal">Book</code> class. Plus, we can now share these methods with any other class, again by using only a single line, all without having to change the parent class of any of the classes involved.</p><p>Of course, it's important to note that because we are applying our mixin on top of the existing prototype, it will overwrite any properties that it has in common with the prototype. In other words, assume that our <code class="literal">Book</code> class already has its own <code class="literal">startLogging</code> method that prevents logging:</p><div><pre class="programlisting">bookPrototype = {
    defaults: {currentPage: 1},

    read: function() {
        // TODO: add logic to read a book here
    },
    startLogging: $.noop // don't log this class
};</pre></div><p>We will erase this method by <a id="id242" class="indexterm"/>applying our mixin, giving us logging on our class even though we don't want it. Further, even if <code class="literal">Book</code> doesn't have such a method, a future developer might add one and then, be confused when it doesn't work. If the future developer doesn't see (or doesn't understand) the mixin line, he might spend hours looking through the parent classes of <code class="literal">Book</code>, trying to figure out what's happening.</p><p>Because of this issue, it is usually better to rely on standard object-oriented programming as much as possible when designing your classes, and only use mixins when you can't share methods through a normal class hierarchy. In these cases, however, mixins can be a powerful tool and serve as yet another example of what is possible in JavaScript but not in most other languages (Good luck mixing methods into a Java class!).</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Publish/subscribe</h1></div></div></div><p>Backbone classes often <a id="id243" class="indexterm"/>wind up being tightly coupled together. For instance, a <code class="literal">View</code> class might listen to a <code class="literal">Model</code> class for changes in its data, and then, when this data changes, it might look at the <code class="literal">attributes</code> of the <code class="literal">Model</code> to determine what to render. This practice couples the <code class="literal">View</code> class to the <code class="literal">Model</code> class, which normally is a good thing as it lets you define the exact relationship you need between the two classes, while still keeping your code fairly simple and maintainable.</p><p>When you only have a few <code class="literal">Models</code> and <code class="literal">Views</code>, it's easy enough to manage their relationships in this way. However, if you are building a particularly complex user interface, then this same coupling can instead become a hindrance. Imagine having a single page with a large number of <code class="literal">Collections</code>, <code class="literal">Models</code>, and <code class="literal">Views</code>, all listening and responding to changes in one another. Whenever a single change occurs, it can cause a ripple effect, resulting in further changes, which can then result in still further changes, and these changes can … well, you get the idea! This can make it nearly impossible to understand what changes are occurring and what effect they will have; in the worst case scenario, they can create infinite loops or make it difficult to fix bugs.</p><p>The solution for a <a id="id244" class="indexterm"/>complex system like this is to decouple the various components (<code class="literal">Collections</code>, <code class="literal">Models</code>, and <code class="literal">Views</code>) involved with each other by using the Publish/Subscribe pattern (or pub/sub for short). In this pattern, all of the components still communicate via events, but instead of each <code class="literal">Collection</code> and <code class="literal">Model</code> class having its own event bus, all of the <code class="literal">Collection</code> and <code class="literal">Model</code> classes involved share a single, global event bus, eliminating direct connections between them. Whenever one component wants to communicate with another, it publishes (triggers) an event that the other component has subscribed (listened) to.</p><p>To implement this pattern in Backbone, we need a global event bus, and it turns out that Backbone already includes one for us: the Backbone object itself. Like <code class="literal">Models</code> and <code class="literal">Collections</code>, the Backbone object has both an "on" (subscription) method and a "trigger" (publishing) method. Both these methods work the same way as they do on other Backbone objects.</p><p>One type of application that often benefits from the pub/sub pattern is games, because they often have many different UI pieces being updated by a variety of different data sources. Let's imagine that we're building a three-player game where each player is represented by a <code class="literal">Model</code> class. Since we want to keep the player <code class="literal">Models</code> updated with changes from the server, we fetch those <code class="literal">Model</code> at periodic intervals:</p><div><pre class="programlisting">var Player = Backbone.Model.extend();
var bob = new Player({name: 'Robert', score: 2});
var jose = new Player({name: 'Jose', score: 7});
var sep = new Player({name: 'Sepehr', score: 4});
window.setInterval(1000, function() {
    bob.fetch();
    jose.fetch();
    sep.fetch();
});</pre></div><p>Let's further imagine that we have a scoreboard <code class="literal">View</code>, which needs to update itself in response to changes in the players' scores. Now, of course, in the real world, if we just had a single <code class="literal">View</code>, we most likely wouldn't even need the pub/sub pattern, but let's keep this example as simple as possible. To avoid coupling our <code class="literal">View</code> to our player <code class="literal">Models</code> directly we'll instead have it listen for a <code class="literal">scoreChange</code> event on the Backbone object:</p><div><pre class="programlisting">var Scoreboard = Backbone.View.extend({
    renderScore: function(player, score) {
        this.$('input[name="' + player + '"]').html(score);
    });
});
var scoreboard = new Scoreboard();
Backbone.on('scoreChange', scoreboard.renderScore, scoreboard);</pre></div><p>Now, in order to have <a id="id245" class="indexterm"/>these <code class="literal">scoreChange</code> events occur, we'll need to make our <code class="literal">Player</code> class trigger them. We'll also need a way to tell if a score has changed, but luckily for us, each of the <code class="literal">Model</code> classes has a <code class="literal">hasChanged</code> method, which does exactly that. We can use this method, inside an overwritten <code class="literal">fetch</code> method, to trigger our <code class="literal">scoreChange</code> event as follows:</p><div><pre class="programlisting">Player = Backbone.Model.extend({
    fetch: function() {
        var promise = Backbone.Model.prototype.fetch.apply(
                          this, arguments
                      );
        promise.done(function() {
            if (this.hasChanged('score')) {
                Backbone.trigger('scoreChange', this.get('name'), 
                                 this.get('score'));
            }
        });
        return promise;
   }
});</pre></div><p>As you can see, the <code class="literal">Model</code> class and the <code class="literal">View</code> are now completely separate. The <code class="literal">Model</code> class passes any information that the <code class="literal">View</code> requires through the event itself, when it makes the <code class="literal">Backbone.trigger</code> call; otherwise, all classes involved remain oblivious to one another.</p><p>Of course, as with any of these advanced techniques, there are also disadvantages to this approach, primarily the lack of encapsulation. When you have a <code class="literal">View</code> fetch a <code class="literal">Model</code> class directly, you know exactly what code connects the two, and if you want to refactor or otherwise change that code, it's easy to determine what will be affected. However, with the pub/sub pattern, it can be much more difficult to determine what code will be impacted by a potential change.</p><p>In many ways, this is very similar to the trade-off between using global variables and using local variables: While the former are much more powerful and easy to work with, initially, their very lack of limits can make them much harder to work with in the long run. Therefore, as much as possible, you should avoid relying on the pub/sub pattern and instead, rely on event listeners bound to particular Backbone objects. However, when you do have a problem that requires communication between many disparate parts of your code, relying on this pattern and listening for/triggering events on the Backbone object itself can allow for a much more elegant solution.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Wrapping widgets of other libraries</h1></div></div></div><p>Backbone is an incredibly <a id="id246" class="indexterm"/>powerful framework, but it can't do everything. If<a id="id247" class="indexterm"/> you want to add a calendar widget, a rich text editor, or a node tree to your site, you'll probably want to use another library, which can provide such a component for you (for example, jQuery UI, TinyMCE, or jsTree). However, just because you want to use a tool other than Backbone, it doesn't mean you have to give up all of the convenience and power of Backbone classes. In fact, there are a number of benefits of creating a Backbone <code class="literal">View</code> class that wraps your third-party component.</p><p>First, wrapping the component in a <code class="literal">View</code> allows you to specify a common way of using this component. For instance, let's say you wanted to use the JQuery UI calendar widget (or <code class="literal">datepicker</code>) in your site. In jQuery UI, if you want your calendar to include a month-picking control, you have to supply a <code class="literal">changeMonth: true</code> option in every place in your code that creates a calendar:</p><div><pre class="programlisting">// File #1
$('#datepicker1').datepicker({changeMonth: true});
// File #2
$('#datepicker2').datepicker({changeMonth: true});</pre></div><p>However, assume that you create a <code class="literal">View</code> class that wraps the <code class="literal">datepicker</code> widget as follows:</p><div><pre class="programlisting">var CalendarView = Backbone.View.extend({
    initialize: function() {
        this.$el.datepicker({changeMonth: true});
    }
});</pre></div><p>You can use this class anywhere in your code that needs a calendar, and you won't have to worry about forgetting to provide the <code class="literal">changeMonth</code> option:</p><div><pre class="programlisting">// File #1
new CalendarView({el: '#datepicker1'});
// File #2
new CalendarView({el: '#datepicker2'});</pre></div><p>If a completely different developer on your team wants to add a calendar, even if he knows nothing about jQuery UI or the <code class="literal">changeMonth</code> option, he'll still be able to create a calendar with the appropriate options for your site just by using the <code class="literal">View</code> you've created. This ability to encapsulate all logic related to a particular component and define your own interface for using it is another major benefit of this wrapping approach.</p><p>Yet another benefit is the ability to easily make changes to a component. For instance, let's say one day, we decide that we want all the calendars on our site to also have a year-picking drop-down (in other words, we want them all to have a <code class="literal">changeYear: true</code> option). Without a wrapping Backbone <code class="literal">View</code>, we'd have to find every place on our site that uses the <code class="literal">datepicker</code> widget and change its options, but with our <code class="literal">View</code>, we only have a single place in the code to update.</p><p>Of course, there are disadvantages to this technique as well. One obvious one is that if we add any components to our site that don't use the same options as the rest, such as a <code class="literal">datepicker</code> widget without a month selector, we'll need to refactor our wrapping <code class="literal">View</code> to allow for such a possibility.</p><p>Another problem is <a id="id248" class="indexterm"/>that wrapped components can remove themselves <a id="id249" class="indexterm"/>from the DOM without calling remove on their wrapping <code class="literal">View</code>, preventing this <code class="literal">View</code> from being garbage collected. Normally, this won't be a problem, as a few extra "zombie" <code class="literal">Views</code> widgets in the memory won't meaningfully impact performance. However, if you have a significant number of these wrapped widgets, then you may want to use the widget's event system to ensure that the wrapping <code class="literal">View</code> always has <code class="literal">remove</code> called on it when its wrapped widget leaves the page. For instance:</p><div><pre class="programlisting">CalendarView = Backbone.View.extend({
    initialize: function() {
        this.$el.datepicker({
            changeMonth: true,
                         onClose: _.bind(function() {
                             this.remove();
                         }, this)
        });
    }
});</pre></div><p>Finally, while hiding the details of a widget's usage inside a <code class="literal">View</code> may be convenient, it can also inadvertently hide relevant details about this widget from your fellow developers. For instance, a widget might have a certain side effect, but because other developers just use the widget's wrapping <code class="literal">View</code> and never read the original widget's documentation, they won't be aware of this side effect.</p><p>For this reason, it is important to ensure that such <code class="literal">Views</code> are properly documented. If the wrapped component has any sort of side effect, performance or otherwise, this side effect should also be carefully documented on the <code class="literal">View</code> itself or you should ensure that all developers on the team understand the workings of the underlying component.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Summary</h1></div></div></div><p>In this chapter, we explored several advanced techniques for using Backbone. First, we learned how many of Backbone's properties can be replaced with methods, and in particular, how the <code class="literal">model</code> property of a <code class="literal">Collection</code> class can be used in this way to generate different types of <code class="literal">Models</code>. We then learned how to override a class <code class="literal">constructor</code> to gain access to and/or manipulate its arguments before <code class="literal">initialize</code>, and how to use mixins to share methods between otherwise unrelated classes. Finally, we examined how to use the Backbone object itself to implement the pub/sub pattern, and how Backbone <code class="literal">Views</code> can be used to "wrap" components from other JavaScript libraries.</p><p>In the next chapter, we'll look at some of the performance implications of Backbone and how you can avoid the most common performance pitfalls.</p></div></body></html>