<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Learn about Swipes through the making of Sokoban</h1></div></div></div><p>Do you know the Sokoban game? It's a funny puzzle game featuring a player pushing crates to some <a id="id148" class="indexterm"/>designated places. Normally, on a computer, these kinds of games—called <a id="id149" class="indexterm"/>tile-based games—are controlled by arrow keys, but since our game has to be cross-platform, we will let the player control in-game movements using swipes.</p><p>The game we will <a id="id150" class="indexterm"/>build is very similar to an iOS game I made called BWBan. It's <a id="id151" class="indexterm"/>free; you can play it at <a class="ulink" href="http://bit.ly/1fUXP8c">http://bit.ly/1fUXP8c</a>.</p><p>In the process of making this game, which we'll call Cocosban, you will learn about the following topics: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to detect swipes</li><li class="listitem" style="list-style-type: disc">How to load graphic assets through a sprite sheet</li><li class="listitem" style="list-style-type: disc">How to create 8-bit-like pixel games by playing with anti-aliasing</li></ul></div><p>There's a lot to do, so let's start with the good old blueprint made in the first chapter and work on it.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Loading graphic assets</h1></div></div></div><p>Needless to <a id="id152" class="indexterm"/>say, the first thing you should do is place your graphic assets in the <code class="literal">assets</code> folder, but there is something new about this step.</p><p>In previous <a id="id153" class="indexterm"/>examples, we always filled our <code class="literal">assets</code> folder with one <code class="literal">PNG</code> image for each game actor—the spaceship and asteroid had their own image. This also applies for all Concentration tiles and so on.</p><p>Cocos2d-JS has no problems in dealing with multiple images, but as a golden rule, remember the less images you have to deal with, the better your game performs.</p><p>So, where's the trick? In order to have a spaceship and an asteroid, you would think you have to <a id="id154" class="indexterm"/>load a spaceship image and an asteroid image, but there's another better way to do it, using <strong>sprite sheets</strong>.</p><p>A sprite sheet is a single image made by combining various small images into it. If you are in to web <a id="id155" class="indexterm"/>designing, they are called <strong>CSS sprites</strong>, and if you have already made <a id="id156" class="indexterm"/>some native iOS applications, they are <a id="id157" class="indexterm"/>called texture atlases.</p><p>Does this mean that you have to manually create a large image and place all your graphic assets inside of it? Well, although you can do it manually, there are several software solutions to <a id="id158" class="indexterm"/>speed up the process. The one I use and <a id="id159" class="indexterm"/>recommend to you is TexturePacker, which you can find at <a class="ulink" href="http://www.codeandweb.com/texturepacker">www.codeandweb.com/texturepacker</a>. It works with an intuitive drag-and-drop <a id="id160" class="indexterm"/>interface and supports Cocos2d export.</p><p>These are the <a id="id161" class="indexterm"/>four images I created for the game, directly from my Photoshop:</p><div><img src="img/0075OS_04_01.jpg" alt="Loading graphic assets"/></div><p>I would like you to notice the zoom factor of the images—actually, they are really tiny. Since we are making a pixel game, the image I made are really small, from 96 x 64 pixels for the title image down to 5 x 5 pixels for the crate and the player.</p><p>Once processed by TexturePacker and exported to Cocos2d, your assets folder should contain the following two files:</p><div><img src="img/0075OS_04_02.jpg" alt="Loading graphic assets"/></div><p>You should easily recognize all previously drawn graphic assets packed into <code class="literal">spritesheet.png</code>, and you will wonder why we need the <code class="literal">spritesheet.plist</code> file.</p><p>Open it and you <a id="id162" class="indexterm"/>will basically find an XML file with all the information for the images, from their original file names to their current sizes and coordinates <a id="id163" class="indexterm"/>inside <code class="literal">spritesheet.plist</code>:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPEplist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;frames&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;background.png&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;frame&lt;/key&gt;
                &lt;string&gt;{{2,2},{96,64}}&lt;/string&gt;
                &lt;key&gt;offset&lt;/key&gt;
                &lt;string&gt;{0,0}&lt;/string&gt;
                &lt;key&gt;rotated&lt;/key&gt;
                &lt;false/&gt;
                &lt;key&gt;sourceColorRect&lt;/key&gt;
                &lt;string&gt;{{0,0},{96,64}}&lt;/string&gt;
                &lt;key&gt;sourceSize&lt;/key&gt;
                &lt;string&gt;{96,64}&lt;/string&gt;
            &lt;/dict&gt;
            &lt;key&gt;crate.png&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;frame&lt;/key&gt;
                &lt;string&gt;{{39,68},{5,5}}&lt;/string&gt;
                &lt;key&gt;offset&lt;/key&gt;
                &lt;string&gt;{0,0}&lt;/string&gt;
                &lt;key&gt;rotated&lt;/key&gt;
                &lt;false/&gt;
                &lt;key&gt;sourceColorRect&lt;/key&gt;
                &lt;string&gt;{{0,0},{5,5}}&lt;/string&gt;
                &lt;key&gt;sourceSize&lt;/key&gt;
                &lt;string&gt;{5,5}&lt;/string&gt;
            &lt;/dict&gt;
        &lt;/dict&gt;
    &lt;/plist&gt;</pre></div><p>In various Cocos2d-JS guides and references, this is referred to as a sprite sheet. Actually, it's <a id="id164" class="indexterm"/>more of a texture atlas; thanks to the XML file, which explains and describes each image included in the sheet.</p><p>So, it's time to load <a id="id165" class="indexterm"/>both files with <code class="literal">loadassets.js</code>:</p><div><pre class="programlisting">var gameResources = [
  "assets/spritesheet.plist",
  "assets/spritesheet.png"
];</pre></div><p>Meanwhile, <code class="literal">main.js</code> will set our resolution policy at 480 x 320 pixels in portrait mode:</p><div><pre class="programlisting">cc.game.onStart = function(){
  cc.view.setDesignResolutionSize(480, 320, cc.ResolutionPolicy.SHOW_ALL);
  cc.LoaderScene.preload(gameResources, function () {
    cc.director.runScene(new gameScene());
  }, this);
};
cc.game.run();

varmyGame = new cocos2dGame(gameScene);</pre></div><p>Now, it's time to create the game itself.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Building a level</h1></div></div></div><p>Normally, tile-based <a id="id166" class="indexterm"/>levels are stored in two-dimensional arrays, and Cocosban follows this trend. So, the first global variable we'll declare <a id="id167" class="indexterm"/>in <code class="literal">gamescript.js</code>, which is an array containing level data, is as follows:</p><div><pre class="programlisting">var level = [
  [1,1,1,1,1,1,1],
  [1,1,0,0,0,0,1],
  [1,1,3,0,2,0,1],
  [1,0,0,4,0,0,1],
  [1,0,3,1,2,0,1],
  [1,0,0,1,1,1,1],
  [1,1,1,1,1,1,1]
];</pre></div><p>Each item represents a tile, and each value represents an item, which I coded this way:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0</code>: This item is an empty tile</li><li class="listitem" style="list-style-type: disc"><code class="literal">1</code>: This item is a wall</li><li class="listitem" style="list-style-type: disc"><code class="literal">2</code>: This item is the place where to drop a crate</li><li class="listitem" style="list-style-type: disc"><code class="literal">3</code>: This item is the crate</li><li class="listitem" style="list-style-type: disc"><code class="literal">4</code>: This item is the player</li><li class="listitem" style="list-style-type: disc"><code class="literal">5</code>: This item is the crate on a place where to drop a crate (3+2)</li><li class="listitem" style="list-style-type: disc"><code class="literal">6</code>: This item is the player on a place where to drop a crate (4+2)</li></ul></div><p>Our <code class="literal">gameScene</code> <a id="id168" class="indexterm"/>declaration is always the same:</p><div><pre class="programlisting">var gameScene = cc.Scene.extend({
  onEnter:function () {
  this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});</pre></div><p>And finally, we are ready to extend the <code class="literal">game</code> class.</p><p>Before we start, I want to quickly discuss mobile tile-based games.</p><p>If you look at the <code class="literal">level</code> array, you will see it's a <em>7x7=49</em> items array. This means we are going to place <em>49 tiles = 49 sprites</em> on the screen.</p><p>That's OK, but placing stuff on the screen costs performance. Since we don't know on which devices our game <a id="id169" class="indexterm"/>will run, the less potentially moving stuff on the screen, the better the performances.</p><p>Since the only moving stuff in our game are the crates and the hero, while all wall and floor tiles always remain in their place, I simply hand-drew the level, adding only moveable characters as tiles.</p><p>You should do the same when designing for cross-platform purposes unless you are using random or procedurally generated content.</p><p>That said, this is how the <code class="literal">game</code> class is declared:</p><div><pre class="programlisting">var game  = cc.Layer.extend({
  init:function () {
    this._super();
    cache = cc.spriteFrameCache;
    cache.addSpriteFrames("assets/spritesheet.plist", "assets/spritesheet.png");
    var backgroundSprite = cc.Sprite.create(cache.getSpriteFrame("background.png"));
    backgroundSprite.setPosition(240,160);
    backgroundSprite.setScale(5);
    this.addChild(backgroundSprite);
    var levelSprite =  cc.Sprite.create(cache.getSpriteFrame("level.png"));
    levelSprite.setPosition(240,110);
    levelSprite.setScale(5);
    this.addChild(levelSprite);
  }</pre></div><p>As you can see, most <a id="id170" class="indexterm"/>of the code has already been explained in the previous chapters. We enable the game to be touch-driven and add some sprites on the <a id="id171" class="indexterm"/>stage. Just look at how I am loading the sprite sheet:</p><div><pre class="programlisting">cache = cc.spriteFrameCache;
cache.addSpriteFrames("assets/spritesheet.plist", "assets/spritesheet.png");</pre></div><p>And this is how you can select a single image from a sprite sheet:</p><div><pre class="programlisting">var backgroundSprite = cc.Sprite.create(cache.getSpriteFrame("background.png"));</pre></div><p>Finally, since our sprites are very, very tiny, they need to be scaled up. The <code class="literal">setScale</code> method allows us to scale sprites:</p><div><pre class="programlisting">backgroundSprite.setScale(5);</pre></div><p>Now, we are ready to launch the game and see our sprites scaled up by 5x:</p><div><img src="img/0075OS_04_03.jpg" alt="Building a level"/></div><p>The preceding image is not a blurred, low-resolution image. It's the actual game as you will see on the <a id="id172" class="indexterm"/>screen, because Cocos2d-JS applies an anti-aliasing effect, which, in this case, wastes the 8-bit look we wanted to give the game. Anti-aliasing is very useful when you want to get smooth images, but will make your game look really bad if you plan to create a pixel game.</p><p>You can prevent <a id="id173" class="indexterm"/>anti-aliasing from being applied to a texture with the <code class="literal">setAliasTexParameters</code> method by just adding this line:</p><div><pre class="programlisting">var game  = cc.Layer.extend({
  init:function () {
    this._super();
    cache = cc.spriteFrameCache;
    cache.addSpriteFrames("assets/spritesheet.plist", "assets/spritesheet.png");
    var backgroundSprite = cc.Sprite.create(cache.getSpriteFrame("background.png"));
    <strong>backgroundSprite.getTexture().setAliasTexParameters();</strong>
    backgroundSprite.setPosition(240,160);
    backgroundSprite.setScale(5);
    this.addChild(backgroundSprite);
    var levelSprite =  cc.Sprite.create(cache.getSpriteFrame("level.png"));
    levelSprite.setPosition(240,110);
    levelSprite.setScale(5);
    this.addChild(levelSprite);
  }
});</pre></div><p>Run the game again, and you will see your pixel-perfect game:</p><div><img src="img/0075OS_04_04.jpg" alt="Building a level"/></div><p>Also, I would like you to notice that the <code class="literal">setAliasTexParameters</code> method is called once and works on both sprites—and will work on every other sprite created in this game—because it's applied on the whole sprite sheet.</p><p>At this time, we can create the player and the crates. They are just sprites manually positioned in the right <a id="id174" class="indexterm"/>place according to their position in the <code class="literal">level</code> array and the position of the level image in the stage.</p><p>The rest of the <a id="id175" class="indexterm"/>script to build the level has nothing to do with Cocos2d-JS since it's pure JavaScript, so I am going to speed up a bit. First, I need three more global variables:</p><div><pre class="programlisting">var cratesArray = [];
var playerPosition;
var playerSprite;</pre></div><p>This is what they represent:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">cratesArray</code>: This <a id="id176" class="indexterm"/>is the array that will contain all crate sprites</li><li class="listitem" style="list-style-type: disc"><code class="literal">playerPosition</code>: This <a id="id177" class="indexterm"/>is the variable that will be used to store a player's position inside the maze</li><li class="listitem" style="list-style-type: disc"><code class="literal">playerSprite</code>: This <a id="id178" class="indexterm"/>variable represents the player itself</li></ul></div><p>Then, after the line that added the <code class="literal">level</code> sprite, we can place the player and the crates:</p><div><pre class="programlisting">var game  = cc.Layer.extend({
  init:function () {
    this._super();
    // same as before
    <strong>this.addChild(levelSprite);</strong>
    <strong>for(i=0;i&lt;7;i++){</strong>
      <strong>cratesArray[i]=[];</strong>
      <strong>for(j=0;j&lt;7;j++){</strong>
        <strong>switch(level[i][j]){</strong>
          <strong>case 4:</strong>
          <strong>case 6:</strong>
          <strong>playerSprite = cc.Sprite.create(cache.getSpriteFrame("player.png"));</strong>
          <strong>playerSprite.setPosition(165+25*j,185-25*i);</strong>
          <strong>playerSprite.setScale(5);</strong>
          <strong>this.addChild(playerSprite);</strong>
          <strong>playerPosition = {x:j,y:i};</strong>
          <strong>cratesArray[i][j]=null;</strong>
          <strong>break;</strong>
          <strong>case 3:</strong>
          <strong>case 5:</strong>
          <strong>var crateSprite = cc.Sprite.create(cache.getSpriteFrame("crate.png"));</strong>
          <strong>crateSprite.setPosition(165+25*j,185-25*i);</strong>
          <strong>crateSprite.setScale(5);</strong>
          <strong>this.addChild(crateSprite);</strong>
          <strong>cratesArray[i][j]=crateSprite;</strong>
          <strong>break;</strong>
          <strong>default:</strong>
          <strong>cratesArray[i][j]=null;</strong>
        <strong>}</strong>
      <strong>}</strong>
    <strong>}</strong>
  }
});</pre></div><p>Did you see? Through pure JavaScript, we just added the crate sprite when the <code class="literal">level</code> array item is 3 or 5 and the player sprite when the <code class="literal">level</code> array item is 4 or 6.</p><p>The strange math <a id="id179" class="indexterm"/>operations are just used to place tiles in the right place according to their position.</p><p>This following screenshot is the result you should see when you run the script:</p><div><img src="img/0075OS_04_05.jpg" alt="Building a level"/></div><p>And that's it! You <a id="id180" class="indexterm"/>have your pixel level ready to be played. Let's <a id="id181" class="indexterm"/>detect player movements.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Detecting swipes</h1></div></div></div><p>If we <a id="id182" class="indexterm"/>analyze a swipe, we can break it down into three parts:</p><div><ol class="orderedlist arabic"><li class="listitem">The <a id="id183" class="indexterm"/>player is touching the stage at a certain point.</li><li class="listitem">The player is dragging their finger in a certain direction.</li><li class="listitem">The player is releasing the finger.</li></ol></div><p>By comparing the coordinates of the points where the drag started and ended, we can determine the direction of the swipe and move the player accordingly.</p><p>We need to add three new global variables:</p><div><pre class="programlisting">var startTouch;
var endTouch;
var swipeTolerance = 10;</pre></div><p>Their names are quite self-explicative: <code class="literal">startTouch</code> and <code class="literal">endTouch</code> will store the starting and ending points of the swipe, while <code class="literal">swipeTolerance</code> is the minimum allowed distance in pixels between <code class="literal">startTouch</code> and <code class="literal">endTouch</code> in order to consider the whole action as a swipe.</p><p>Now, we will let <code class="literal">game</code> detect when a touch starts or ends:</p><div><pre class="programlisting">var game  = cc.Layer.extend({
  init:function () {
    // same as before
    <strong>cc.eventManager.addListener(listener, this);</strong>
     }
});</pre></div><p>As usual, we <a id="id184" class="indexterm"/>added a listener attached to a variable called <code class="literal">listener</code>, which we'll define this way:</p><div><pre class="programlisting">var listener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  swallowTouches: true,
  onTouchBegan:function (touch,event) {
    startTouch = touch.getLocation();
    return true;
  },
  onTouchEnded:function(touch, event){
    endTouch = touch.getLocation();
    swipeDirection();
  }
});</pre></div><p>The <code class="literal">onTouchBegan</code> <a id="id185" class="indexterm"/>function will register the initial touch and update the <code class="literal">startTouch</code> content; thanks to the <code class="literal">getLocation</code> method. Also, notice the function <a id="id186" class="indexterm"/>returns <code class="literal">true</code>. It's very important you make this function return <code class="literal">true</code>, or <code class="literal">onTouchEnded</code> won't be triggered.</p><p>The same applies for <code class="literal">onTouchEnded</code>, which will update <code class="literal">endTouch</code>. Then, the <code class="literal">swipeDirection</code> function is called. It will allow us to move the player:</p><div><pre class="programlisting">function swipeDirection(){
  var distX = startTouch.x - endTouch.x;
  var distY = startTouch.y - endTouch.y;
  if(Math.abs(distX)+Math.abs(distY)&gt;swipeTolerance){
    if(Math.abs(distX)&gt;Math.abs(distY)){
      if(distX&gt;0){
        playerSprite.setPosition(playerSprite.getPosition().x-25,playerSprite.getPosition().y);
        //move(-1,0);
      }
      else{
        playerSprite.setPosition(playerSprite.getPosition().x+25,playerSprite.getPosition().y);
        //move(1,0);
      }
    }
    else{
      if(distY&gt;0){
        playerSprite.setPosition(playerSprite.getPosition().x,playerSprite.getPosition().y-25);
        //move(0,1);
      }
      else{
        playerSprite.setPosition(playerSprite.getPosition().x,playerSprite.getPosition().y+25);
        //move(0,-1);
      }
    }
  }
}</pre></div><p>Run the game <a id="id187" class="indexterm"/>and the following screenshot is what you <a id="id188" class="indexterm"/>will see:</p><div><img src="img/0075OS_04_06.jpg" alt="Detecting swipes"/></div><p>Once you swipe in a direction, the player moves accordingly.</p><p>Let's see what happens in the <code class="literal">swipeDirection</code> function:</p><div><pre class="programlisting">var distX = startTouch.x - endTouch.x;
var distY = startTouch.y - endTouch.y;</pre></div><p>Horizontal and <a id="id189" class="indexterm"/>vertical distances from the start to the end of the touch are calculated:</p><div><pre class="programlisting">if(Math.abs(distX)+Math.abs(distY)&gt;swipeTolerance){</pre></div><p>The whole function is executed only if the sum of horizontal and vertical distances is greater than the minimum pixel tolerance allowed to say that the movement is actually a swipe:</p><div><pre class="programlisting">if(Math.abs(distX)&gt;Math.abs(distY)){</pre></div><p>The next step is to determine whether the player swiped horizontally or vertically. There's no check to see whether a swipe was strictly horizontal or vertical; so, diagonal swipes will be seen as either horizontal or vertical, according to their biggest component:</p><div><pre class="programlisting">if(distX&gt;0){</pre></div><p>Once we know <a id="id190" class="indexterm"/>whether the movement is horizontal or vertical, it's time to check for the direction: left or right? Up or down? The rest of the code just checks for these questions and moves the player by 25 pixels accordingly. Unfortunately, you will be able to walk through crates and walls. It's time to code <a id="id191" class="indexterm"/>game rules.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Completing the game</h1></div></div></div><p>The code I am about <a id="id192" class="indexterm"/>to write has nothing to do with Cocos2d-JS as it's just plain JavaScript, and explaining it would go beyond the scope of this book. I am just checking for legal moves and will move the player and the crates accordingly.</p><p>Everything is managed by the <code class="literal">move</code> function, which will check for legal moves and update crates and player positions. The <code class="literal">move</code> function has two arguments, <code class="literal">deltaX</code> and <code class="literal">deltaY</code>, which represent the amount of tiles the player is trying to move horizontally or vertically.</p><p>This means <code class="literal">move(0,1)</code> will try to move the player up (0 tiles horizontally, 1 tile vertically), <code class="literal">move(-1,0)</code> will try to move the player left, and so on.</p><p>The <code class="literal">swipeDirection</code> function changes this:</p><div><pre class="programlisting">function swipeDirection(){
  var distX = startTouch.x - endTouch.x;
  var distY = startTouch.y - endTouch.y;
  if(Math.abs(distX)+Math.abs(distY)&gt;swipeTolerance){
    if(Math.abs(distX)&gt;Math.abs(distY)){
      if(distX&gt;0){
        move(-1,0);
      }
      else{
        move(1,0);
      }
    }
    else{
      if(distY&gt;0){
        move(0,1);
      }
      else{
        move(0,-1);
      }
    }
  }
}</pre></div><p>A valid swipe is detected each time the <code class="literal">move</code> function is called.</p><p>This is <a id="id193" class="indexterm"/>the <code class="literal">move</code> function:</p><div><pre class="programlisting">function move(deltaX,deltaY){
  switch(level[playerPosition.y+deltaY][playerPosition.x+deltaX]){
    case 0:
    case 2:
    level[playerPosition.y][playerPosition.x]-=4;
    playerPosition.x+=deltaX;
    playerPosition.y+=deltaY;
    level[playerPosition.y][playerPosition.x]+=4;
    playerSprite.setPosition(165+25*playerPosition.x,185-25*playerPosition.y);
    break;
    case 3:
    case 5:
    if(level[playerPosition.y+deltaY*2][playerPosition.x+deltaX*2]==0 || level[playerPosition.y+deltaY*2][playerPosition.x+deltaX*2]==2){
      level[playerPosition.y][playerPosition.x]-=4;
      playerPosition.x+=deltaX;
      playerPosition.y+=deltaY;
      level[playerPosition.y][playerPosition.x]+=1;
      playerSprite.setPosition(165+25*playerPosition.x,185-25*playerPosition.y);
      level[playerPosition.y+deltaY][playerPosition.x+deltaX]+=3;
      var movingCrate = cratesArray[playerPosition.y][playerPosition.x];
      movingCrate.setPosition(movingCrate.getPosition().x+25*deltaX,movingCrate.getPosition().y-25*deltaY);
      cratesArray[playerPosition.y+deltaY][playerPosition.x+deltaX]=movingCrate;
      cratesArray[playerPosition.y][playerPosition.x]=null;
    }
    break;
  }
}</pre></div><p>Enjoy <a id="id194" class="indexterm"/>your game.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, you learned how to use sprite sheets to manage your assets, create pixel-perfect games, and detect swipes. You also created a great puzzle game called Cocosban.</p><p>If you noticed, player and crate movements are made by making assets jump to their destination. Why don't you add a tween to create a smooth movement? It would be a great achievement for you to do it.</p><p>Also, there's no check to see whether the player completed the level. A completed level has no crates outside crate goals. Try to develop it.</p><p>Then, follow me through a path full of music; we will add sound effects to our games!</p></div></body></html>