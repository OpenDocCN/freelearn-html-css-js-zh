- en: Exploring the ServiceNow Glide Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the the ServiceNow Glide class. We will look
    at the exposed JavaScript APIs that allow developers to conveniently and rapidly
    write ServiceNow scripts. We will then look at the different classes on the server
    and client sides before looking at some examples of some of the most commonly
    used classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use ServiceNow exposed JavaScript APIs, including GlideRecord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side Glide classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side Glide classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples covering some commonly used Glide classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ServiceNow exposed JavaScript APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ServiceNow provides developers with some exposed JavaScript APIs to aid them
    with the scripts they write. This saves a lot of time in accessing records and
    fields in scripts in ServiceNow. There are a number of different classes and objects
    available to developers, some of which very helpful and others rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: GlideRecord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common JavaScript APIs is the `GlideRecord` class, which is
    extremely handy and will fast become a staple of most scripting. `GlideRecord`
    is a way of finding and counting records in ServiceNow based on many different
    queries. It is quite similar to a SQL statement if that is something you are familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how to use `GlideRecord`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at how to query all the records in a particular table. The
    format of the `GlideRecord` script for this is shown in the following, with `table_name`
    being the only parameter. This needs to be the table name rather than the table
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will set a variable to hold the `GlideRecord` object and define the table
    that will be used to query. In this example, we will use the incident table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `glideRecord` variable now holds a `GlideRecord` object for the incident
    table. We then query the table and add any filtering. In this case, we will add
    no filter and simply return all records for the incident table, therefore showing
    the full script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a very important part of ServiceNow scripting as it is the way coders
    can access the records in ServiceNow by cycling through them and applying some
    code to each relevant record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how to set up a `GlideRecord` query, let''s have a look
    at the script line that can filter a `GlideRecord` for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we filter based on a field name and compare the value in that field using
    the operator to the value we define. The default `operator` is that the value
    equals the value in the field so if this is the operator we need, we can just
    leave it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at another example. This time, we''ll look to query all
    the problem records with a critical priority using our filter line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we omitted the operator because we want
    problem records with a priority equal to `1` and therefore we did not need to
    include it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples so far, we have cycled through all of the records, but we can
    amend the loop to return just one if it exists by changing the `while` to an `if`.
    This is often helpful when checking whether all tasks of a parent record are complete.
    Let''s look at how it would change our script from our last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code could be used to check whether any priority critical problems exist
    and will run some code against it if one does.
  prefs: []
  type: TYPE_NORMAL
- en: You can add more than one query and each record that is returned will need to
    satisfy each filter being defined. In that respect, it is quite like searching
    for a house. You could just search for all houses, but you more likely would want
    to build filters up to find exactly what you are looking for – price range, bedrooms,
    location, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of these filters adding up and essentially creating a series of logical
    `AND` statements, we also need a way of creating a logical `OR` statement. In
    the same way you can add a query line, you can also add an `OR` condition line
    of script. Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the original condition is stored in a variable, `orQuery`, and
    then the `OR` condition is added to this variable before the query takes place.
    This type of query is handy if you want certain code to execute when a record
    is in a certain set of states.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to achieve the same goal in ServiceNow and to show this,
    we can set up the same filter on change records using a different operator. This
    uses the fact that many values of choice lists in ServiceNow are numbers so we
    can just search for all change requests with a risk of greater than or equal to
    `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This second example would usually be considered better than the first, as it
    is using fewer lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have looked at how to get the records we want, we will look at how to
    alter the records we have found. First, we''ll take a look at a simple update
    to a record. In this example, we will update all incident records with a high
    urgency and move it down to medium:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When updating a record, you can amend many of the fields and then use `update`
    to save the changes. This is a very important method and is relatively simple
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: The final examples we will look at are how to delete records. Obviously, be
    careful when deleting records and ensure the query you have written is correct
    before executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main methods of deleting records: either individually through
    looping or all in one go. Let''s look at deleting individual records first. In
    this example, we''ll delete all of the `network` category incidents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll look at how to delete all of the queried records in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script for both of these `delete` methods is quite different,
    but the end result is the same. The `deleteMultiple` method is a quicker, more
    efficient method; however, it will delete everything in one go. If there is a
    large amount of data to be deleted, this can cause resources to be tied up for
    a long time. I have used the `deleteRecord` method instead in the case of a large
    volume of data to stagger the deletion of records in smaller groups of records.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a `delete` script, try executing it first with the `delete` method
    commented out and some logging to show what you have deleted. If the logging brings
    back the records you want, then go ahead with the deletion. This helps to ensure
    the wrong records are not removed.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes `GlideRecord` for now, but it will feature again throughout the
    book, further proving how important it is.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side Glide classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will look at some of the server-side classes that we can use for our
    scripts. Remember these methods will not work on the client side so make sure
    you are aware whether the script you are writing is on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: GlideSystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GlideSystem` is probably the most commonly used server-side classes. Let''s
    have a look at how we can utilize this class to aid us in our scripting.'
  prefs: []
  type: TYPE_NORMAL
- en: ServiceNow shortens `GlideSystem` to `gs` in scripts so the methods of `GlideSystem`
    will be prefixed with `gs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by seeing how to get a user''s `sys_id` using `GlideSystem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This puts the logged-in user's `sys_id` in the `userID` variable. This can be
    helpful as you can use this in scripts where you may want to execute different
    lines of script depending on the attributes of the user. Now we have the user's
    `sys_id`, we could use a `GlideRecord` query to return the fields we desire. ServiceNow
    does allow us to obtain some of this information in an easier way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the `user` object and then use some helpful functions to access
    further information about the user. To get the `user` object, we simply write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let us see some of the most helpful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Most of the preceding code is fairly self-explanatory, but the ID functions
    will return the `sys_id` of the record in the same way as the user `sys_id`.
  prefs: []
  type: TYPE_NORMAL
- en: The user's details can be useful for sending notifications and setting up approvals
    and condition scripts based on locations or companies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whilst we are on user data, it is often important to find out which roles a
    user has to decide what they should have access to. `GlideSystem` allows us to
    see whether a user has a certain role in the script, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `hasRole` method is especially useful when using script to allow or restrict
    data to a user. It can also be used to hide or show UI actions that would require
    an elevated privilege to use. One thing to note is that the `hasRole` method will
    always return `true` for an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '`GlideSystem` is also good for letting the user know what has happened during
    a script through an output message for the user. This is done using an `Info`
    or `Error` message. The `Info` message is displayed in a nice blue box and the
    `Error` message, unsurprisingly, in a red one at the top of the form once processing
    has completed and the next screen has loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how to script these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These are fairly simple lines, but are very handy in keeping a user updated
    with how scripts performed when processed and whether there were any problems.
    I tend to use the info message to let a user know an action completed successfully
    when it is not immediately obvious on the screen they are returned to. An `Error`
    message is good when something in a script goes wrong. Remember that this message
    will be displayed to a variety of users so it is best to not get too technical
    in the message.
  prefs: []
  type: TYPE_NORMAL
- en: '`GlideSystem` also allows us to perform logging so that we can debug our server-side
    scripts. As server-side scripts are running behind the scenes, we need a way of
    logging what happened in the script so we can look at it later and review and
    debug if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The little bit of script that is the most common for this is `log`. Simply
    used, this is just a string of text to send to the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This message will now be visible in the Script Log Statements module in the
    application navigator. If you are looking through older script in a ServiceNow
    instance, you will often find these log messages. Sometimes they are commented
    out in case they are needed again for debugging and sometimes they should have
    been commented out and the developer forgot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If many logs are being created, it can be helpful to give your log a unique
    source so you can more easily search for only logs from your particular source.
    Let''s have a look at what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This message will then appear in the system log with a source of `My Script
    Log`. One thing to note is that it will no longer appear in the Script Log Statements
    module as you have changed the source to a custom source.
  prefs: []
  type: TYPE_NORMAL
- en: '`GlideSystem` is probably the most useful server-side Glide class and there
    are more methods on top of the ones we have discussed.'
  prefs: []
  type: TYPE_NORMAL
- en: GlideDateTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GlideDateTime` is, unsurprisingly, about scripting with dates and times, specifically
    the `GlideDateTime` object. The `GlideDateTime` object is mainly used to populate
    Date/Time fields and the methods around them to manipulate dates and times to
    add or remove time to a field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at defining a new `GlideDateTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will put the current date and time in GMT format in the `glideDT` field
    as part of a `GlideDateTime` object. This can be helpful if you want to compare
    a date in a field with the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with any date and time scripting, time zones are always an issue. One
    of the best ways to get around this is to use the display value to make sure dates
    and times are displayed to users in the correct format for the user who is viewing
    it. Let''s look at how this is done by logging the display value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is very helpful in scripting to ensure that all users see the correct times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes there will also be the requirement to add or remove time from a Date/Time
    field using script. There are a few methods to add various amounts of time to
    or from a Date/Time field. We''ll have a look at one of these; the others work
    in a very similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we would be adding 1 day, so 24 hours, to the current day
    and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using a negative number, we actually subtract time from the object so the
    preceding example would actually give you the date and time of this time yesterday.
  prefs: []
  type: TYPE_NORMAL
- en: '`GlideDateTime` is helpful when dealing with dates and times, which can often
    be a headache in coding. Remember, when using negative figures in `addtime` methods,
    this reduces the time instead of increasing it.'
  prefs: []
  type: TYPE_NORMAL
- en: GlideElement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GlideElement` provides methods for dealing with the fields in a `GlideRecord`
    object. This class is one of the smaller ones in ServiceNow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One very handy set of methods in this class is detecting changes to a field.
    This is very helpful in closing down records. Sometimes we may want to run some
    script on closure of the record, but not every time the record is updated. This
    is when the `changesTo` method can be used. We''ll assume we are using an incident,
    in this case where the closed state is `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This preceding example will allow for some script to run when the record is
    closed, but only when it moves to being closed. If the closed record is subsequently
    updated, then this script will not run again. That is why this method is so helpful.
    You can also use `changes` and `changesFrom` methods as part of this set.
  prefs: []
  type: TYPE_NORMAL
- en: You may or may not be aware of what `current` refers to at this point, but we
    will take a closer look at this when we look at business rules in [Chapter 5](170b38f0-5b60-4c8d-aef3-6833efee13f1.xhtml),
    *Introduction to Server-Side Scripting*.
  prefs: []
  type: TYPE_NORMAL
- en: Another helpful set of methods in `GlideElement` is checking whether a user
    is able to create, read, or write to records. We can use this to see whether a
    user should be able to perform these actions, which can be very helpful in UI
    action conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will check whether the logged-in user is able to create a record of the
    current type (incident, change request, and so on) and, if so, then run the script
    inside the `if` statement. We can also use the `canRead` and `canWrite` methods
    in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: With `GlideElement` being a smaller class, it is not as well used as some of
    the other server-side classes, but some of its methods are very helpful, particularly
    in UI actions.
  prefs: []
  type: TYPE_NORMAL
- en: GlideAggregate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GlideAggregate` class is an extension of `GlideRecord` and works in a similar
    way. The difference is that `GlideRecord` tends to give you database objects whereas
    `GlideAggregate` deals in counts and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a quick look at how `GlideAggregate` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This first example will give us the number of incidents in the database and
    place it in the `noOfIncidents` field. We can add `addQuery` lines in exactly
    the same way we would for `GlideRecord` if we wanted to reduce the number of incident
    records we returned.
  prefs: []
  type: TYPE_NORMAL
- en: As well as `COUNT`, we can also use `SUM`, `MAX`, `MIN`, and `AVG` to get the
    total sum, maximum number, minimum number, and average, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: I don't find `GlideAggregate` used that regularly, but it is an efficient way
    to count records.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side Glide classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client-side Glide classes are for use in scripts that are run directly in
    front of the user. These include manipulating and working with form fields and
    user data and being able to call server-side scripts to return values in the database.
  prefs: []
  type: TYPE_NORMAL
- en: GlideForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I would say that GlideForm or `g_form` is the most used client-side class. It
    is mainly used for getting data from the fields on the form and setting values
    to those fields as well. We can also change elements of those fields using `g_form`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by looking at how to get and set values from and into fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The string value inside the speech marks is the database name for the field.
    Make sure you use the name rather than the label when getting a value using `g_form`.
    The `getValue` method essentially puts the value of a field into a variable for
    you. This then allows you to use that variable to check against other data or
    pass as a parameter into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `setValue` method will immediately set the value of the field on the screen
    to what the script dictates. In this example, presuming we are on the incident
    table, the state field would change to resolved. Remember, here, we are using
    the number `6` as that is the choice value for the resolved state in ServiceNow.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that the value at this point will only have changed
    on the screen in front of the user. The field in the database will not be updated
    until the record itself is.
  prefs: []
  type: TYPE_NORMAL
- en: Using `g_form`, we can also change elements of the field itself and not just
    the value it holds. Let's have a look at how to make a field mandatory, show and
    hide a field, and make a field read-only. The best practice for these actions
    is to use a UI policy; however, the conditions in a UI policy are limited so sometimes
    we need to use a script to perform these actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by setting a field to `mandatory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This example would set the short description field to `mandatory`. If we want
    to reverse this, we just need to change `true` to `false` in the line. This can
    be helpful when using UI actions to move through states of a record and to ensure
    certain fields are filled in before moving to the next stage. This change to the
    mandatory state of the field is just temporary; if the form is reloaded, then
    the field will go back to its original mandatory or non-mandatory state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change whether a field is visible, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This example will hide the assigned to field, but we can show it again by changing
    `false` to `true` in the line of script. This method isn't used that often as
    this action can usually be performed by a UI policy. This method will allow the
    space the field has left behind to be reclaimed by other fields. The `setVisible`
    method is very similar to the `setDisplay` method except a blank space is left
    where the field used to be, which tends to make `setDisplay` the better aesthetic
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method for setting a field to be read-only is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will set the description field to read-only, meaning the
    field cannot be edited. This will only be while the current form is loaded and
    will revert back to its original state of read-only or not when the form reloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some useful bits of information that `g_form` can get for you
    as well. To begin with, let''s see how you can get the unique value or `sys_id`
    of a record using `g_form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The example puts the `sys_id` of the record in the `sysID` variable. This can
    be useful if you want the `sys_id` value even before the record is saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use code to check whether the record has been saved or not yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This `isNewRecord` method allows us to write script for only new records or
    for only records that have already been saved. This can help you to decide whether
    to insert or update a record at the end of the script.
  prefs: []
  type: TYPE_NORMAL
- en: GlideUser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GlideUser` or `g_user` is a class all about the attributes of the user. It
    is not the biggest class, but some of the properties and methods can be used quite
    frequently.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most helpful of these is being able to get the user ID, the `sys_id`
    of the user, through a property. This can be very helpful to send to another script
    so that the script knows which user is currently logged in or for getting the
    user record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how to get this ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the `userSys_ID` variable will be the `sys_id` of the logged-in
    user.
  prefs: []
  type: TYPE_NORMAL
- en: When getting a user record, it is best practice to use the `sys_id` rather than
    a name to obtain the record. This is because there is a chance users in the database
    may have the same name, whereas the `sys_id` of a user will always be unique.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use `g_user` to get the full name of the logged-in user. This can
    be helpful if we want to display a user's name in messages displayed to them or
    in fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a user''s full name by using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This preceding example sets the name variable to be the user's full name. Let's
    assume I am the logged-in user here. The `alert` method shows a pop-up message
    to the user, so in this scenario, it would say `The logged in user is Andrew Kindred`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes when scripting, we want to know whether the user has a specific role
    so we can decide whether or not a piece of code should run for them or not. To
    do this on the client side, we can use the `hasRole` method. It works in a very
    similar way to the server-side `GlideSystem` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of the `hasRole` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code is very similar to the server-side code. We can use
    an `if` statement to ensure that we only run certain code for users with a certain
    role.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other methods relating to basic user data and roles, but we
    have covered the most useful ones here.
  prefs: []
  type: TYPE_NORMAL
- en: Additional client-side Glide classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two classes we have looked at so far are the most useful and also the easiest
    to begin with. However, there are some other helpful client-side Glide classes.
    We will look at these other Glide classes later in the book, as they tie in nicely
    with some of the types of client-side script and specific actions you may want
    to achieve with your code.
  prefs: []
  type: TYPE_NORMAL
- en: Script examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we've looked at some server- and client-side Glide classes, we can take
    a look at some examples of using these methods and properties in some slightly
    more complex blocks of code to achieve our goals in ServiceNow.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by having a look at some `GlideRecord` examples.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we'll use `GlideRecord` multiple times, one inside another. This
    is a technique you will no doubt use quite often as you progress with your scripting.
    It has certainly served me well over the years.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll take a look at creating a problem record for every
    critical priority incident:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we've found all critical incidents using a `GlideRecord`
    query. Once we find a matching incident record, we create a new problem record
    using `insert`, copying the configuration item and short description fields from
    the incident over to the problem record also. Once the problem record has been
    inserted, we store its unique value in the `newInsertedRecord` variable so that
    we can add that value into the incident record-related problem field. This ensures
    the two records are linked and that the incident will appear in the related list
    on the problem record.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what this script would look like in a scheduled job in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddd9fd64-a39d-4e95-a550-4a6a601a4d5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Scheduled job for creating problems from critical incidents'
  prefs: []
  type: TYPE_NORMAL
- en: We will take an in-depth look at scheduled jobs in [Chapter 6](a0052657-c9a2-4b4e-93ab-6c78ecac434c.xhtml), *Advanced
    Server-Side Scripting*. This figure gives you an idea of seeing the layout of
    Glide classes in a ServiceNow script field.
  prefs: []
  type: TYPE_NORMAL
- en: Using a `GlideRecord` inside a `GlideRecord` is incredibly useful, as we can
    create, update, or search within a `GlideRecord` query `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: If we know the `sys_id` of a record, there is a shortcut called `get` we can
    use to obtain the record directly. We can use our user-based methods to show a
    quick way of getting the user record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script uses this `get` method to quickly access the user record
    we require:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using the `get` method, we have quickly retrieved the currently logged-in user's
    user record, also using our `GlideSystem` method to get the user ID. We could
    also put a `sys_id` contained in quotes here for the `get` method parameter. The
    example then sets the title of the user to be a manager and saves the record.
    Running this code will make any logged-in user have a manager as their title.
  prefs: []
  type: TYPE_NORMAL
- en: This technique saves us having to use a full `GlideRecord` query to get the
    user record that we need. This means not having to search through the user table,
    which saves resources and also extra lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what this example code would look like in a business rule in ServiceNow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aae22bff-0d7a-4b9a-9696-7405438ae38b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Business rule making logged-in users managers'
  prefs: []
  type: TYPE_NORMAL
- en: We will take an in-depth look at business rules in [Chapter 5](612c28de-49ab-47a2-8bcd-3cadf9c0179c.xhtml),
    *Introduction to Server-Side Scripting*. They are often used for server-side scripting.
    We would also need to add a value to the table field so that our business rule
    knows which table to run this script against.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use some of the techniques we''ve learned in this chapter to send
    specific messages to users. Let''s assume we want to give users a different message
    depending on what roles they have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This server-side example will display an error message to a user based on what
    roles they have. This can be useful to display additional information to users
    who will understand it and it will keep the details simple for users who do not
    have as much technical expertise.
  prefs: []
  type: TYPE_NORMAL
- en: This code adds error messages that are displayed to the user when the form loads
    at the top of the screen. By using the `if` statements, we will only ever display
    one message to the user and, in our example, the most suitable one for the role
    of that user.
  prefs: []
  type: TYPE_NORMAL
- en: We can also set some values on a form based on whether it is a new form or not.
    Perhaps we want to make all new incident forms have an inquiry/help category,
    but not change any incidents that already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the script we would need for this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With this client-side script example, we would only set the category field to
    `inquiry`/`help` if it was a new record. Remember that this would only set the
    field on the screen on the client side and would not save the field as this value
    until the record was saved.
  prefs: []
  type: TYPE_NORMAL
- en: This type of code can be very useful for setting up records in a certain way
    whilst they are being created. Sometimes it can be that fields are not shown on
    creation of a new record and are only viewed once the record has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this code in a client script in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83d964aa-c271-41c7-9eee-3054c7979ffc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Client script setting the incident category'
  prefs: []
  type: TYPE_NORMAL
- en: We will look at client scripts further in the next chapter and they are usually
    the main source of client-side scripting in an instance.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to only run script when the record is not new, we can simply place
    a exclamation mark in front of the `if` condition to negate the expression and
    give us the option to add code for updating existing records.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement would instead look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use many of the methods we saw earlier in the chapter
    together to achieve the scripting goals we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at using exposed JavaScript APIs and the well-used
    `GlideRecord` class. We also looked at server-side and client-side Glide classes
    and the properties and methods of each that can be used to enhance your scripting.
    Finally, we looked at some more complex examples of scripting, combining these
    properties and methods to show what can be achieved and how the properties and
    methods can be used together.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the basics of client-side scripting. We
    will look at client scripts, UI policies, when to use these scripts, and how to
    test them. Plus we'll add some helpful examples to show some great ways to get
    the most out of client-side scripting.
  prefs: []
  type: TYPE_NORMAL
