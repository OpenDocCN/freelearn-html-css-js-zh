<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer100">&#13;
    <h1 class="chapterNumber">13</h1>&#13;
    <h1 id="_idParaDest-387" class="chapterTitle">Concurrency</h1>&#13;
    <p class="normal">It's time for a more advanced topic. You're ready! We are going to deal with the topic of asynchronous code and some options for multitasking with code. This concept is called concurrency. Don't worry if you find this chapter a bit of a struggle; this is programming in JavaScript at a high level. These are the topics we'll be dealing with:</p>&#13;
    <ul>&#13;
      <li class="bullet">Concurrency</li>&#13;
      <li class="bullet">Callbacks</li>&#13;
      <li class="bullet">Promises</li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">async</code>/<code class="Code-In-Text--PACKT-">await</code></li>&#13;
      <li class="bullet">Event loop</li>&#13;
    </ul>&#13;
    <p class="normal">Yes, this is tough, but understanding how to leverage concurrency can really enhance the performance of your program by speeding up the process, which is more than enough reason to dive into this advanced topic!</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Note: exercise, project, and self-check quiz answers can be found in the <em class="italic">Appendix</em>.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-388" class="title">Introducing concurrency</h1>&#13;
    <p class="normal"><strong class="keyword">Concurrency</strong> is whenever things are happening "at the same time" or <em class="italic">in parallel</em>. To give a non-code example, let's talk <a id="_idIndexMarker660"/>about managing my household. When I come home on a Friday night, I have a series of tasks: the kids need to eat, to shower, and to be brought to bed, the laundry needs to be folded and laundry needs to be put in the machine, and to be fair, a lot more, but this is enough to illustrate the example.</p>&#13;
    <p class="normal">If I were to do this without being able to do multiple things at once, it would be a very tough night and get very late. I would first make dinner—put a pizza in the oven and wait next to it—feed the kids, shower them afterward, then bring them to bed, and then fold the laundry afterward, turn the machine on again, and wait until it's done. Luckily, I can multitask, so it looks more like this: I put the pizza in the oven, in the meantime, I turn the washing machine on and maybe fold a few pieces of laundry, then I feed the kids, do the rest of the laundry while they shower, and I'm done a lot quicker.</p>&#13;
    <p class="normal">This is the same for your computer and the applications that you use. If it weren't able to do multiple things at the same time, you would probably be very annoyed. You wouldn't be able to <a id="_idIndexMarker661"/>check your mail while you are writing code, you wouldn't be able to listen to music while writing code, and a lot more. This is your computer switching between different tasks. The same thing can happen at the application level. For example, we can do a call to some API and not wait for the reply but do something useful in the meantime instead. We can do so using the concept of <strong class="keyword">concurrency</strong>.</p>&#13;
    <p class="normal">There are three strategies in JavaScript that you'll need to know of when working with concurrency: <strong class="keyword">callbacks</strong>, <strong class="keyword">Promises</strong>, and the <strong class="keyword">async</strong> and <strong class="keyword">await</strong> keywords.</p>&#13;
    <h1 id="_idParaDest-389" class="title">Callbacks</h1>&#13;
    <p class="normal"><strong class="keyword">Callbacks</strong> are the first thing we should understand when we are talking about concurrency. The good news is that the <code class="Code-In-Text--PACKT-">callback</code> principle is not too hard to understand. It is just a <a id="_idIndexMarker662"/>function that takes another function as an argument, which is then called when the rest of the initial function has finished. In other words, it's just a function calling a function, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">doSomething</span><span class="hljs-function">(</span><span class="hljs-params">callback</span><span class="hljs-function">) </span>{  &#13;
    callback();&#13;
}&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">sayHi</span><span class="hljs-function">() </span>{&#13;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi!"</span>);&#13;
}&#13;
doSomething(sayHi);&#13;
</code></pre>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">doSomething()</code> function, which is created with the parameter <code class="Code-In-Text--PACKT-">callback</code>, is just calling whatever function is being passed in as an argument. We call it using the <code class="Code-In-Text--PACKT-">sayHi()</code> function as an argument, so this code snippet is just a very complicated way to get <code class="Code-In-Text--PACKT-">Hi!</code> printed to the console.</p>&#13;
    <p class="normal">Here is an <a id="_idIndexMarker663"/>example of the <code class="Code-In-Text--PACKT-">callback</code> principle actually doing something:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">judge</span><span class="hljs-function">(</span><span class="hljs-params">grade</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) {&#13;
        <span class="hljs-keyword">case</span> grade == <span class="hljs-string">"A"</span>:&#13;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"You got an"</span>, grade, <span class="hljs-string">": amazing!"</span>);&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">case</span> grade == <span class="hljs-string">"B"</span>:&#13;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"You got a"</span>, grade, <span class="hljs-string">": well done!"</span>);&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">case</span> grade == <span class="hljs-string">"C"</span>:&#13;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"You got a"</span>, grade, <span class="hljs-string">": alright."</span>);&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">case</span> grade == <span class="hljs-string">"D"</span>:&#13;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"You got a"</span>, grade, <span class="hljs-string">": hmmm..."</span>);&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">default</span>:&#13;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"An"</span>, grade, <span class="hljs-string">"! What?!"</span>);&#13;
    }&#13;
}&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">getGrade</span><span class="hljs-function">(</span><span class="hljs-params">score, callback</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">let</span> grade;&#13;
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) {&#13;
        <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">90</span>:&#13;
            grade = <span class="hljs-string">"A"</span>;&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">80</span>:&#13;
            <span class="hljs-built_in">console</span>.log(score);&#13;
            grade = <span class="hljs-string">"B"</span>;&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">70</span>:&#13;
            grade = <span class="hljs-string">"C"</span>;&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">60</span>:&#13;
            grade = <span class="hljs-string">"D"</span>;&#13;
            <span class="hljs-keyword">break</span>;&#13;
        <span class="hljs-keyword">default</span>:&#13;
            grade = <span class="hljs-string">"F"</span>;&#13;
    }&#13;
    callback(grade);&#13;
}&#13;
getGrade(<span class="hljs-number">85</span>, judge);&#13;
</code></pre>&#13;
    <p class="normal">There are two functions here: <code class="Code-In-Text--PACKT-">judge()</code> and <code class="Code-In-Text--PACKT-">getGrade()</code>. We call the function <code class="Code-In-Text--PACKT-">getGrade()</code> with two arguments: <code class="Code-In-Text--PACKT-">85</code> and the function <code class="Code-In-Text--PACKT-">judge()</code>. Note that when calling the function as an argument, we do not include the parantheses. The <code class="Code-In-Text--PACKT-">judge()</code> function gets stored in a <code class="Code-In-Text--PACKT-">callback</code>. After determining the grade, the function that is stored in a callback (<code class="Code-In-Text--PACKT-">judge()</code> in this case) gets called with the grade.</p>&#13;
    <p class="normal">This could also be another function that does something more useful than judging, for example, sending a certain email based on test results. If we wanted that, we actually wouldn't need to change the <code class="Code-In-Text--PACKT-">getGrade()</code> function; we just need to write a new function to do this and call <code class="Code-In-Text--PACKT-">getGrade()</code> with the new function as a second argument.</p>&#13;
    <p class="normal">You might be very disappointed right now, because this is not too exciting. Callbacks become really valuable in an asynchronous context, for example, when one function is still waiting for <a id="_idIndexMarker664"/>the results of a call to the database before calling the <code class="Code-In-Text--PACKT-">callback</code> function that is going to process the data.</p>&#13;
    <p class="normal">Some JavaScript built-in functions work with this callback principle, for example, the <code class="Code-In-Text--PACKT-">setTimeOut()</code> and <code class="Code-In-Text--PACKT-">setInterval()</code> functions. They will take a function that is executed after a certain time in the case of a timeout and every certain amount of time for the specified interval. We have seen these already, but just as a reminder:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">setInterval</span>(encourage, <span class="hljs-number">500</span>);&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">encourage</span><span class="hljs-function">() </span>{&#13;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"You're doing great, keep going!"</span>);&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The functions that are inserted as arguments are called callbacks here. Understanding concurrency really starts with callbacks, but multiple nested callbacks make code difficult to read. </p>&#13;
    <p class="normal">When this is all written as one function with anonymous functions inside, this gets very indented as well. We call this <strong class="keyword">callback hell</strong> or the <strong class="keyword">Christmas tree problem</strong> (because the code gets nested so much, it looks like a Christmas tree on its side).</p>&#13;
    <p class="normal">Callbacks are a great concept, but they can create ugly code very fast. There is often a better solution, we promise.</p>&#13;
    <h2 id="_idParaDest-390" class="title">Practice exercise 13.1</h2>&#13;
    <p class="normal">This exercise will demonstrate how to use a callback function, creating a way to pass a value from one function to another by invoking a callback function. We will create a greeting callback using a full name in a string.</p>&#13;
    <ol>&#13;
      <li class="numbered">Create a function named <code class="Code-In-Text--PACKT-">greet()</code> that takes one argument, <code class="Code-In-Text--PACKT-">fullName</code>. That argument should be an array. Output the items of the array into the console interpolated into a greeting message string.</li>&#13;
      <li class="numbered">Create a second function that has two arguments: the first one is a string for the user's full name, and the second is the <code class="Code-In-Text--PACKT-">callback</code> function.</li>&#13;
      <li class="numbered">Split the string into an array using the <code class="Code-In-Text--PACKT-">split()</code> method.</li>&#13;
      <li class="numbered">Send the full-name array to the <code class="Code-In-Text--PACKT-">greet()</code> function created in the first step.</li>&#13;
      <li class="numbered">Invoke the process of the <code class="Code-In-Text--PACKT-">callback</code> function.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-391" class="title">Promises</h1>&#13;
    <p class="normal">With <strong class="keyword">Promises</strong>, we can organize the sequence of our code in a slightly easier-to-maintain way. A Promise is a <a id="_idIndexMarker665"/>special object that connects code that needs to produce a result and the code that needs to use this result in the next step.</p>&#13;
    <p class="normal">When we create a Promise, we give it a function. In the following example, we use a convention that we have seen a lot; we are creating a function on the spot. So, inside the argument list we are defining the function, often done using arrow functions as well. This function needs two parameters, and these parameters are callbacks. We have called them <code class="Code-In-Text--PACKT-">resolve</code> and <code class="Code-In-Text--PACKT-">reject</code> here.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">You can call these parameters anything you want, but <code class="Code-In-Text--PACKT-">resolve</code> or <code class="Code-In-Text--PACKT-">res</code> and <code class="Code-In-Text--PACKT-">reject</code> or <code class="Code-In-Text--PACKT-">rej</code> are most common.</p>&#13;
    </div>&#13;
    <p class="normal">When <code class="Code-In-Text--PACKT-">resolve()</code> is called, the Promise is presumed to be successful and whatever is between the arrows is returned and used as input for the <code class="Code-In-Text--PACKT-">then</code> method on the <code class="Code-In-Text--PACKT-">Promise</code> object. If <code class="Code-In-Text--PACKT-">reject()</code> is called, the <code class="Code-In-Text--PACKT-">Promise</code> failed and the <code class="Code-In-Text--PACKT-">catch()</code> method on the <code class="Code-In-Text--PACKT-">Promise</code> object (if present) is executed with the argument of the <code class="Code-In-Text--PACKT-">reject()</code> function.</p>&#13;
    <p class="normal">This is a lot of information that can be hard to understand at first, so here is an example of a Promise to help you:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">function</span><span class="hljs-function"> (</span><span class="hljs-params">resolve, reject</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-comment">// do something that might take a while</span>&#13;
    <span class="hljs-comment">// let's just set x instead for this example  </span>&#13;
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">20</span>;&#13;
    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">10</span>) {&#13;
        resolve(x); <span class="hljs-comment">// on success</span>&#13;
    } <span class="hljs-keyword">else</span> {&#13;
        reject(<span class="hljs-string">"Too low"</span>);  <span class="hljs-comment">// on error</span>&#13;
    }&#13;
});&#13;
promise.then(&#13;
    <span class="hljs-keyword">function</span><span class="hljs-function"> (</span><span class="hljs-params">value</span><span class="hljs-function">) </span>{&#13;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Success:"</span>, value);&#13;
    },&#13;
    <span class="hljs-keyword">function</span><span class="hljs-function"> (</span><span class="hljs-params">error</span><span class="hljs-function">) </span>{&#13;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Error:"</span>, error);&#13;
    }&#13;
);&#13;
</code></pre>&#13;
    <p class="normal">We first create a Promise. When creating a <code class="Code-In-Text--PACKT-">Promise</code>, we don't know what the value of the Promise is going to be. This value is whatever is sent as an argument to the resolve function. It is a sort of placeholder.</p>&#13;
    <p class="normal">So when we call then on the Promise, we basically say: figure out what the value of the Promise is, and when <a id="_idIndexMarker666"/>you know, execute one function if the Promise was resolved or a different function if it was rejected. When a Promise is neither resolved nor rejected, we say that the Promise is pending.</p>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">then()</code> is a Promise itself, so when it returns we can use the result for the next <code class="Code-In-Text--PACKT-">then()</code> instance. This means we can chain the <code class="Code-In-Text--PACKT-">then()</code> instances, which can look like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve, reject</span><span class="hljs-function">) =&gt;</span> {&#13;
    resolve(<span class="hljs-string">"success!"</span>);&#13;
})&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"we"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"can"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"chain"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"promises"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
    })&#13;
    .catch(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
    })&#13;
</code></pre>&#13;
    <p class="normal">This will log:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">success!&#13;
we&#13;
can&#13;
chain&#13;
promises&#13;
</code></pre>&#13;
    <p class="normal">The resolve functions are implemented with an arrow function. The <code class="Code-In-Text--PACKT-">return</code> statement is the <code class="Code-In-Text--PACKT-">value</code> input for the next function. You can see that the last block is a <code class="Code-In-Text--PACKT-">catch()</code> function. If any of the <a id="_idIndexMarker667"/>functions were to result in a rejection and the Promise were therefore rejected, this <code class="Code-In-Text--PACKT-">catch()</code> block would be executed and print whatever the <code class="Code-In-Text--PACKT-">reject()</code> function sent to the <code class="Code-In-Text--PACKT-">catch()</code> method. For example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve, reject</span><span class="hljs-function">) =&gt;</span> {&#13;
    reject(<span class="hljs-string">"oops... "</span>);&#13;
})&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"we"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"can"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"chain"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"promises"</span>;&#13;
    })&#13;
    .then(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
    })&#13;
    .catch(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">console</span>.log(value);&#13;
    })&#13;
</code></pre>&#13;
    <p class="normal">This will just log <code class="Code-In-Text--PACKT-">oops…</code> because the first Promise was rejected instead of resolved. This is great for creating <a id="_idIndexMarker668"/>asynchronous processes that need to wait till another process is complete. We can try to do a certain set of actions and when something goes wrong, use a <code class="Code-In-Text--PACKT-">catch()</code> method to deal with it.</p>&#13;
    <h2 id="_idParaDest-392" class="title">Practice exercise 13.2</h2>&#13;
    <p class="normal">In this exercise, you will create a counter that will output the values in sequence using Promises.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Set up a Promise that resolves with a value of <code class="Code-In-Text--PACKT-">Start Counting</code>.</li>&#13;
      <li class="numbered">Create a function named <code class="Code-In-Text--PACKT-">counter()</code> that has one argument that gets the value and outputs it into the console.</li>&#13;
      <li class="numbered">Set up the next function in the Promise with four <code class="Code-In-Text--PACKT-">then()</code> instances, which should output a value into the counter function, and return a value which will provide input for the subsequent <code class="Code-In-Text--PACKT-">then()</code> instance. The returned values should be <code class="Code-In-Text--PACKT-">one</code>, then <code class="Code-In-Text--PACKT-">two</code>, then <code class="Code-In-Text--PACKT-">three</code>. The screen output in the console should be the following:&#13;
        <pre class="programlisting con"><code class="hljs-con">Start Counting&#13;
One&#13;
Two&#13;
Three&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-393" class="title">async and await</h1>&#13;
    <p class="normal">We have just seen the <code class="Code-In-Text--PACKT-">Promise</code> syntax. With the <code class="Code-In-Text--PACKT-">async</code> keyword, we can make a function return a Promise. This makes <a id="_idIndexMarker669"/>the Promises nicer to read and look a lot like <a id="_idIndexMarker670"/>synchronous (non-concurrent) code. We can use this Promise just like we learned in the previous section, or we can use the more powerful <code class="Code-In-Text--PACKT-">await</code> keyword to wait until the Promise is done. <code class="Code-In-Text--PACKT-">await</code> only works in an asynchronous function.</p>&#13;
    <p class="normal">In an asynchronous context, we can await other Promises as well, as can be seen in this example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">saySomething</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-params">resolve</span><span class="hljs-function"> =&gt;</span> {&#13;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {&#13;
            resolve(<span class="hljs-string">"something"</span> + x);&#13;
        }, <span class="hljs-number">2000</span>);&#13;
    });&#13;
}&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">talk</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">const</span> words = <span class="hljs-keyword">await</span> saySomething(x);&#13;
    <span class="hljs-built_in">console</span>.log(words);&#13;
}&#13;
talk(<span class="hljs-number">2</span>);&#13;
talk(<span class="hljs-number">4</span>);&#13;
talk(<span class="hljs-number">8</span>);&#13;
</code></pre>&#13;
    <p class="normal">Can you figure out what this code does? We call the asynchronous function <code class="Code-In-Text--PACKT-">talk()</code> three times in a row with no break. Each of these function calls is awaiting the <code class="Code-In-Text--PACKT-">saySomething()</code> function. The <code class="Code-In-Text--PACKT-">saySomething()</code> function contains a new Promise that is being resolved with a <code class="Code-In-Text--PACKT-">setTimeout()</code> function that waits two seconds before resolving with the value of <code class="Code-In-Text--PACKT-">something</code> plus <code class="Code-In-Text--PACKT-">x</code>. So after two seconds, the three functions are done at the same time (or so it seems to the human eye).</p>&#13;
    <p class="normal">If the <code class="Code-In-Text--PACKT-">talk()</code> function were <a id="_idIndexMarker671"/>not asynchronous, it would throw a <code class="Code-In-Text--PACKT-">SyntaxError</code> because <a id="_idIndexMarker672"/>of the <code class="Code-In-Text--PACKT-">await</code> keyword. <code class="Code-In-Text--PACKT-">await</code> is only valid in asynchronous functions, so <code class="Code-In-Text--PACKT-">talk()</code> must be asynchronous. Without the <code class="Code-In-Text--PACKT-">async</code> and the <code class="Code-In-Text--PACKT-">await</code> in this example, it would store the result of the function <code class="Code-In-Text--PACKT-">saySomething()</code>, a pending <code class="Code-In-Text--PACKT-">Promise</code>, in words and log that once for every function call:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Promise { &lt;pending&gt; }&#13;
Promise { &lt;pending&gt; }&#13;
Promise { &lt;pending&gt; }&#13;
</code></pre>&#13;
    <p class="normal">We have now seen the basic building blocks of concurrency. This should prepare you for working with concurrency <a id="_idIndexMarker673"/>in real life. Concurrency really is an advanced topic; debugging <a id="_idIndexMarker674"/>it is troublesome, but it is really worth while in terms of performance when applied at the right moment.</p>&#13;
    <h2 id="_idParaDest-394" class="title">Practice exercise 13.3</h2>&#13;
    <p class="normal">This exercise will demonstrate how to use <code class="Code-In-Text--PACKT-">await</code> to wait on a <code class="Code-In-Text--PACKT-">Promise</code> inside an <code class="Code-In-Text--PACKT-">async</code> function. Using <code class="Code-In-Text--PACKT-">await</code> and <code class="Code-In-Text--PACKT-">async</code>, create a counter with <code class="Code-In-Text--PACKT-">timeout()</code>, and increment a global counter value.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a global value for a counter.</li>&#13;
      <li class="numbered">Create a function that takes one argument. Return the result of a new Promise, setting a <code class="Code-In-Text--PACKT-">setTimeout()</code> function that will contain the resolve instance.</li>&#13;
      <li class="numbered">Increment the counter within <code class="Code-In-Text--PACKT-">setTimeout()</code>, adding one every second. Resolve the Promise with the value of the counter and the value of the variable that was in the function argument.</li>&#13;
      <li class="numbered">Create an asynchronous function that outputs into the console the value of the global counter and the value of the argument of the function.</li>&#13;
      <li class="numbered">Create a variable to capture the returned resolve value from the <code class="Code-In-Text--PACKT-">await</code> function. Output that result into the console.</li>&#13;
      <li class="numbered">Create a loop to iterate 10 times, incrementing the value and invoking the <code class="Code-In-Text--PACKT-">async</code> function, passing the value of the increment variable as the parameter in the function.</li>&#13;
    </ol>&#13;
    <p class="normal">The results should look like the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">ready 1 counter:0&#13;
ready 2 counter:0&#13;
ready 3 counter:0&#13;
x value 1 counter:1&#13;
x value 2 counter:2&#13;
x value 3 counter:3&#13;
</code></pre>&#13;
    <h1 id="_idParaDest-395" class="title">Event loop</h1>&#13;
    <p class="normal">We would like to end this chapter by explaining how JavaScript handles asynchrony and concurrency <a id="_idIndexMarker675"/>under the hood. JavaScript is a single-threaded language. A thread in this context means a <em class="italic">path of execution</em>. If there is only a single path, this means that tasks will have to wait for one another and only one thing can happen at a time.</p>&#13;
    <p class="normal">This single executor is the <strong class="keyword">event loop</strong>. It's a process that executes the actual work. You may wonder about this, because you've just learned about concurrency and doing things asynchronously <a id="_idIndexMarker676"/>and at the same time. Well, even though JavaScript is single-threaded, it doesn't mean that it cannot outsource some tasks and wait for them to come back. This is exactly how JavaScript manages to do things in a multithreaded manner.</p>&#13;
    <h2 id="_idParaDest-396" class="title">Call stack and callback queue</h2>&#13;
    <p class="normal">JavaScript works <a id="_idIndexMarker677"/>with a <strong class="keyword">call stack</strong>, and all the actions that it has to execute are <a id="_idIndexMarker678"/>queued up here. The event loop is a process that is constantly monitoring this call stack, and whenever there are tasks to do, the event loop does them one by one. The tasks on top get executed first.</p>&#13;
    <p class="normal">Here's a tiny script:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">console</span>.log("Hi there");&#13;
add(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">return</span> x + y;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Here's a visualization of the call stack and event loop for this script.</p>&#13;
    <figure class="mediaobject"><img src="Images/B16682_13_01.png" alt="Application&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="491"/></figure>&#13;
    <p class="packt_figref">Figure 13.1: Visualization of the event loop and the call stack</p>&#13;
    <p class="normal">No multithreading is going on here. But it is here:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">console</span>.log("Hi there");&#13;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log("Sorry I'm late"), <span class="hljs-number">1000</span>);&#13;
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>));&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">return</span> x + y;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">setTimeout()</code> task gets outsourced to the browser's web API (more on APIs in <em class="chapterRef">Chapter 15</em>, <em class="italic">Next Steps</em>). When it's done, this appears in a special place: the <strong class="keyword">callback queue</strong>. When the call <a id="_idIndexMarker679"/>stack is empty (and only then!), the event loop will check the callback queue <a id="_idIndexMarker680"/>for work to do. If there are any callbacks waiting, they'll be executed, one by one. After every action, the event loop will check the call stack for work first.</p>&#13;
    <p class="normal">Here's a visualization of the situation with the outsourcing of <code class="Code-In-Text--PACKT-">setTimeout()</code>:</p>&#13;
    <figure class="mediaobject"><img src="Images/B16682_13_02.png" alt="Shape, square&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="477"/></figure>&#13;
    <p class="packt_figref">Figure 13.2: Visualization of the setTimeout being outsourced</p>&#13;
    <p class="normal">When <code class="Code-In-Text--PACKT-">setTimeout()</code> expires, the <a id="_idIndexMarker681"/>event loop will have done whatever was on the <strong class="keyword">call stack</strong> already, and <a id="_idIndexMarker682"/>will check the callback queue and execute any tasks on there:</p>&#13;
    <figure class="mediaobject"><img src="Images/B16682_13_03.png" alt="Shape, square&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="622"/></figure>&#13;
    <p class="packt_figref">Figure 13.3: Visualization of the task on the callback queue</p>&#13;
    <p class="normal">And this is what it will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hi there&#13;
9&#13;
Sorry I'm late&#13;
</code></pre>&#13;
    <p class="normal">Let's see if you read the above text well. What do you think will happen when we set the timer to <code class="Code-In-Text--PACKT-">0</code>, like here?</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi there"</span>);&#13;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Sorry I'm late"</span>), <span class="hljs-number">0</span>);&#13;
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">add</span><span class="hljs-function">(</span><span class="hljs-params">x, y</span><span class="hljs-function">) </span>{&#13;
    <span class="hljs-keyword">return</span> x + y;&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">This will output the <a id="_idIndexMarker683"/>exact same thing. <code class="Code-In-Text--PACKT-">setTimeout()</code> will also be outsourced when <a id="_idIndexMarker684"/>the timer is at <code class="Code-In-Text--PACKT-">0</code>. The callback is placed in the callback queue right away, but the event loop won't even check the callback queue until the callstack is empty. So it will still print <code class="Code-In-Text--PACKT-">Sorry I'm late</code> after <code class="Code-In-Text--PACKT-">9</code>, even though the timer is at <code class="Code-In-Text--PACKT-">0</code>.</p>&#13;
    <h1 id="_idParaDest-397" class="title">Chapter project</h1>&#13;
    <h2 id="_idParaDest-398" class="title">Password checker</h2>&#13;
    <p class="normal">Using an array of allowed passwords, this exercise will create an application to check if one of these password string <a id="_idIndexMarker685"/>values exists in an array that lists all the accepted passwords. Set a Promise to check if the password is valid, and upon the result either resolve with the status of true or reject with the status of false. Return the check results.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create an array of allowed passwords.</li>&#13;
      <li class="numbered">Create a login function that will check if the argument is a value that is included in the passwords array. You can use <code class="Code-In-Text--PACKT-">indexof()</code> or the <code class="Code-In-Text--PACKT-">includes()</code> method to check the array for a value and return a Boolean value of the result.<div class="note">&#13;
          <p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">includes()</code> method is an array method that can check whether a certain value is included <a id="_idIndexMarker686"/>among the items in the array. It will return a Boolean value depending on the result.</p>&#13;
        </div>&#13;
      </li>&#13;
      <li class="numbered">Add a function that <a id="_idIndexMarker687"/>returns a Promise. Using <code class="Code-In-Text--PACKT-">resolve</code> and <code class="Code-In-Text--PACKT-">reject</code>, return a JavaScript object with the Boolean of <code class="Code-In-Text--PACKT-">true</code> or <code class="Code-In-Text--PACKT-">false</code> to indicate the password validity status. </li>&#13;
      <li class="numbered">Create a function that checks the password, sending it to the login function, and using <code class="Code-In-Text--PACKT-">then()</code> and <code class="Code-In-Text--PACKT-">catch()</code>, outputs the result of either the rejected password or the resolved password.</li>&#13;
      <li class="numbered">Send several passwords, some within the array, others not, to the checker function.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-399" class="title">Self-check quiz</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Fix the error in the following code to use the <code class="Code-In-Text--PACKT-">callback</code> function:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">addOne</span><span class="hljs-function">(</span><span class="hljs-params">val</span><span class="hljs-function">)</span>{&#13;
  <span class="hljs-keyword">return</span> val + <span class="hljs-number">1</span>;&#13;
}&#13;
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">total</span><span class="hljs-function">(</span><span class="hljs-params">a, b, callback</span><span class="hljs-function">)</span>{&#13;
  <span class="hljs-keyword">const</span> sum = a + b;&#13;
  <span class="hljs-keyword">return</span> callback(sum);&#13;
}&#13;
<span class="hljs-built_in">console</span>.log(total(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, addOne()));&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Write down the result of the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">checker</span><span class="hljs-function">(</span><span class="hljs-params">val</span><span class="hljs-function">) </span>{&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve, reject</span><span class="hljs-function">) =&gt;</span> {&#13;
    <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">5</span>) {&#13;
      resolve(<span class="hljs-string">"Ready"</span>);&#13;
    } <span class="hljs-keyword">else</span> {&#13;
      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Oh no"</span>));&#13;
    }&#13;
  });&#13;
}&#13;
checker(<span class="hljs-number">5</span>)&#13;
  .then(<span class="hljs-function">(</span><span class="hljs-params">data</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-built_in">console</span>.log(data); })&#13;
  .catch(<span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-built_in">console</span>.error(err); });&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">What line(s) of code need to be added to the preceding function so that there is always a result after the function runs that ensures the word <code class="Code-In-Text--PACKT-">done</code> is output into the console?</li>&#13;
      <li class="numbered">Update the below code to make the function return a Promise:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">myFun</span><span class="hljs-function">() </span>{&#13;
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span>;&#13;
}&#13;
myFun().then(&#13;
  <span class="hljs-keyword">function</span><span class="hljs-function">(</span><span class="hljs-params">val</span><span class="hljs-function">) </span>{ <span class="hljs-built_in">console</span>.log(val); },&#13;
  <span class="hljs-keyword">function</span><span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) </span>{ conole.log(err); }&#13;
);&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-400" class="title">Summary</h1>&#13;
    <p class="normal">In this chapter, we've discussed concurrency. Concurrency enables our code to do multiple things at the same time and we can determine the order of things using callbacks, Promises, and the <code class="Code-In-Text--PACKT-">async</code> and <code class="Code-In-Text--PACKT-">await</code> keywords. Implementing these in your applications and pages will improve the user experience a lot! Users are quite demanding nowadays; if a website isn't loading fast enough, they bounce (go back to, for example, Google). Concurrency helps to deliver results faster.</p>&#13;
    <p class="normal">The next two chapters are about using JavaScript for modern web development and will be dealing with HTML5 and JavaScript and modern JavaScript frameworks that are real game-changers.</p>&#13;
  </div>&#13;
</div></body></html>