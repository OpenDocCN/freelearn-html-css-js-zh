- en: Chapter 6. Data Binding, and Why You Should Embrace It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The View layer of a single page application goes far beyond statically displaying
    HTML and data through JavaScript templating engines or other means. A modern JavaScript
    application must handle real-time updates and be imbued with reactivity. Some
    of the protocols described in [Chapter 4](ch04.html "Chapter 4. REST is Best –
    Interacting with the Server Side of Your App"), *REST is Best - Interacting with
    the Server Side of Your App* such as WebSockets, MQPP, and DDP can be used to
    actively retrieve updates to data for an application, but the ability to bind
    those changes to the DOM and display them in the View must be handled on the frontend
    of the application. This is where data binding comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What data binding is?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between one-way and two-way data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AngularJS implementation of data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other popular implementations of data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement data binding with native JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What some use cases of data binding are?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is data binding?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, data binding is a software design pattern specifying the ability
    to directly tie changes to your underlying application data, or Model, to the
    View by visually reflecting those changes automatically. This can be done by any
    number of means using JavaScript, and it is really dependent upon what version
    of JavaScript you are using and its abilities and limitations. In the case of
    a web application, those abilities and limitations are governed by the user's
    browser, of course, and this is why there are so many implementations of data
    binding in the JavaScript community.
  prefs: []
  type: TYPE_NORMAL
- en: If you have worked with any popular JavaScript frameworks, or at least have
    read about any of them, you have probably heard of data binding. You also have
    probably never attempted to implement it on your own, considering the number of
    libraries and frameworks out there that provide this capability. The advantage
    that some of these implementations give you is cross-browser compatibility by
    using multiple methods and feature detection in the browser for the delegation
    of those methods. Other frameworks, such as Ember.js and Knockout.js, use their
    own proprietary implementation of data binding that works across most browsers,
    but requires loading a potentially large library when all you want is the data
    binding feature.
  prefs: []
  type: TYPE_NORMAL
- en: Using a library or framework for complex data observation is often more desirable
    than writing custom JavaScript to do it yourself, which speaks to the popularity
    of frameworks such as AngularJS - often touted for its data binding features.
    Leveraging these features is one thing, but understanding how they work and what
    is going on under the hood of a framework is quite another. First, let's break
    down the concept of data binding a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: One-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One-way, or unidirectional, data binding is when a change to an application''s
    data model is updated and subsequently reflected in the View. The initial change
    to the data model can come from anywhere, be it the submission of a form from
    the current user, the edit of a post of a different user on another computer,
    or a change in current data pushed directly from the application''s host server.
    When the change in that data is automatically merged with a dynamic template and
    updated in the View without intervention from the user, it is known as one-way
    data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![One-way data binding](img/B05228_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One-way data binding is visualized in a View from the merging of a ViewModel
    with a Template.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see a simple representation of the one-way data binding design
    pattern. The manner in which the update to the View ultimately takes place relies
    entirely on how the application's frontend JavaScript is written, and can be done
    in any number of ways, but the conceptual pattern itself remains unvarying.
  prefs: []
  type: TYPE_NORMAL
- en: Using a JavaScript templating engine, like the ones discussed in *[Chapter 5](ch05.html
    "Chapter 5. Its All About the View")*, *Its All About the View* provides one-way
    data binding at the template level when expressions in the compiled templates
    are bound to dynamic data. Updating the view to reflect real-time changes to that
    data, however, must be handled with additional code that observes for model changes
    and triggers updates to the view accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two-way, or bidirectional, data binding includes the one-way data binding pattern
    but additionally allows changes to the representation of data in the View by the
    user to be reflected in the underlying Model itself. With this pattern in place,
    the data displayed in the View is always a representation of the current state
    of the Model, even when the user makes changes to that data in the View without
    explicitly submitting it via forms or other means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way data binding](img/B05228_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two-way data binding is visualized in a View from changes to the ViewModel merged
    with a template, and changes by the user to the representations of the data in
    the View are merged back into the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows the two-way data binding design pattern. In order for this
    pattern to work, there must be some type of observer in place that is continuously
    watching for changes to the data and syncing it in both directions. This naturally
    requires a more complex frontend architecture, and popular frameworks such as
    AngularJS can be leveraged to take the reins.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding with modern JavaScript frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the complexity that comes with data binding design patterns, there are
    some standalone JavaScript libraries, such as Rivets.js and Knockout.js, that
    can provide it for you. Many full-fledged JavaScript frameworks also include their
    own implementations of data binding as a core feature.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding with AngularJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS, which is maintained by Google, is one of the most popular modern
    JavaScript frameworks. As discussed in [*Chapter 2*](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    it is a self-avowed MVW framework. In addition to its MVW architectural pattern
    implementation, it includes a powerful data binding design pattern, which is often
    its most touted feature.
  prefs: []
  type: TYPE_NORMAL
- en: One-way data binding with AngularJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One-way data binding with AngularJS is achieved when an expression in the View
    is populated by a value from the Model associated with the Controller for that
    View. Consider the following Controller and Model data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The user Model that is defined on the scope for this Controller can be represented
    in the View with the following template markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with many other JavaScript templating engines, the double curly brace
    syntax is used to represent expressions to be evaluated in an AngularJS template.
    Additionally, AngularJS allows for the use of the ng-bind attribute on empty HTML
    elements to be used in place of the double curly brace syntax for expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This syntax is more verbose, but may be preferable to some. In either case,
    changes to the Model properties will be automatically updated in the View where
    those properties are bound by their respective template expressions. In this way,
    AngularJS provides the underlying DOM manipulation layer that wires Model changes
    to be updated in the View without any further code being necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding with AngularJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two-way data binding with AngularJS is achieved when an editable value in the
    View, such as a text input, is assigned to a property on the Model for the current
    Controller scope. When the value for that property is changed by the user, the
    Model will be updated automatically, and that change will be propagated back to
    the View for any expression that is bound to that Model property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Controller and Model from the previous example, consider the following
    template markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The text inputs are given the ng-model attribute to assign a Model property
    as the value when the View is initially loaded. When the user changes the value
    for either of these inputs, the $scope.user Model will be updated, and the change
    will then be reflected in the paragraph block above the inputs where the same
    properties are bound to the DOM by their respective expressions. This round-trip
    from a change in the View to the Model and back to the View again is a simple
    example of two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Dirty checking with AngularJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AngularJS uses a method of polling for changes to find differences between
    the Model and the View, and this method is referred to as dirty checking. This
    checking is done on a defined interval, which is referred to as the digest cycle**.**
    For each digest cycle, special methods called watches are registered with listeners
    by the scope to watch for changes to bound expressions that are passed to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As explained in [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    the *scope* is a JavaScript object that defines the Model context for variable
    expressions in the View. The watches compare bound Model expressions with their
    previous values and if any of them are found to be *dirty*, or different, the
    listener callbacks are executed and the changes are then synced to the View.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS allows dirty checking to be performed at multiple levels of depth
    for an object, depending on your needs. There are three types of watch provided
    for this, with three respective depths. These levels provide for flexible data
    binding features, but with more depth comes more performance concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Dirty checking by reference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The standard method of dirty checking in AngularJS watches for the entire value
    of a bound expression to change to a new value. This is referred to as dirty checking
    by reference. If the expression represents an object or an array, and only changes
    to its properties or members are made, the change will not be detected. This is
    the lowest depth of dirty checking, and thereby the most performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider a user object with multiple properties is applied to
    the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now a watch expression can be bound by reference to one of the object''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since user.firstName has changed, this will be picked up in the subsequent
    digest cycle and the listener function will be triggered. Now consider instead
    that we watch the user object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, nothing is picked up by the watch after user.lastName is changed.
    This is because the watch is looking for the user object itself to change - not
    one of its individual properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you were to instead replace the entire user object itself, the watch would
    find the value to be *dirty* and would then invoke the listener during the next
    digest cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Dirty checking by collection contents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you need to watch for shallow changes to an object or an array, AngularJS
    provides another method for watching called `$watchCollection`. In this context,
    *shallow* means that the watch will only respond to changes at the first level
    of the object or array `**- deep**` property changes, or those of nested objects
    or arrays, will not be detected. AngularJS calls this dirty checking by collection
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, changing a property of the user object from the previous example
    would be picked up by the watch and trigger the `listener`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Dirty checking by collection contents is not as performant as checking by reference
    because a copy of the watched object or array must be kept in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Dirty checking by value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'AngularJS also allows you to watch for changes on any nested data within an
    object or array. This is referred to as dirty checking by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can implement this method of watching using the `$watch` method, just as
    you would with checking by reference, but with an added third parameter set to
    true. This parameter tells the watch whether you want to check for object equality
    or not, and it defaults to false. When the watch checks for equality by reference,
    it performs a simple `!==` conditional. When the third parameter of $watch is
    set to true, however, it uses the internal angular.equals method for a deep comparison.
  prefs: []
  type: TYPE_NORMAL
- en: The `angular.equals` method can be used to compare any two values, and it supports
    value types, regular expressions, objects, and arrays. If a property being compared
    is a function or its name begins with `$`, it will be ignored. The reason for
    ignoring functions is obvious, and as for the `$` prefix, it is likely done to
    avoid AngularJS internal functionality from being overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Dirty checking by value is the most comprehensive form of data binding in AngularJS,
    but it is also the least performant. This is because a full copy of any complex
    object or array being compared must be held in memory, as is the case with dirty
    checking by collection contents, but additionally, a deep traversal of the entire
    object or array must be performed on each digest cycle. To maintain memory efficiency
    in your application, care should be taken when using this type of data binding
    with AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: When to use dirty checking for data binding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The dirty checking approach to data binding has its pros and cons. AngularJS
    assures us that memory is not a concern as long as you are not doing several thousand
    bindings in a single view. A downside is, however, that changes to the Model will
    not always show up in real time due to the latency of the digest cycle. If you
    are designing an application in which you would like to display true real-time,
    two-way data binding, then AngularJS may not be the solution for you.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding with Ember.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember.js is a popular open source JavaScript framework for building web applications.
    It is similar to AngularJS in its provided features, but it takes quite a different
    approach to data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Ember.js runs an internal loop, similar to the digest cycle in AngularJS, called
    the `**run loop**`. It does not use dirty checking on bound Model data, but it
    maintains the run loop for other internal functionality, such as scheduling work
    queues to be performed in a particular order. The main reason behind scheduling
    operations within the run loop is to provide memory management and optimize the
    efficiency of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Ember.js uses property accessors to provide data binding, which means it uses
    direct object properties to get and set bound Model values. With this mechanism
    in place, it can forgo dirty checking to employ data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ember.js uses computed properties via object property accessors internally
    for setting and getting values. This means that properties are defined as functions
    that perform some type of manipulation to produce the final values that are returned.
    To do this, the native JavaScript object type is extended with the internal `Ember.Object.extend`
    method, and computed properties are returned using the `Ember.computed` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For this extended `User` object, the `firstName` and `lastName` properties are
    static, but the `fullName` property is computed with the `'firstName'` and `'lastName'`
    strings passed to it as parameters. This tells the computed method that those
    properties of the extended object are to be used in computing the returned value
    for `fullName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to access the value that is returned by `fullName`, a new User object
    must first be created with the static `firstName` and `lastName` properties defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a `currentUser` object is created with a given `firstName` and `lastName`
    value, the `fullName` property can be computed and returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This convention of extending objects is a bit verbose, but it allows Ember.js
    to handle the computed properties internally and track bound objects while also
    normalizing JavaScript inconsistencies across various user agents, or browsers.
  prefs: []
  type: TYPE_NORMAL
- en: One-way data binding with Ember.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ember.js uses computed properties in its data binding implementation, which
    means that direct property accessors can be used and no dirty checking is necessary.
    For one-way bindings, you can get the property for an object, but you cannot set
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `Ember.computed.oneWay` method is used to apply a one-way
    binding for the `nickName` property as an *alias* of the `firstName` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new User object is created, the `nickName` property for it can then
    be accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is only a one-way binding, however, the `nickName` property cannot
    be used to set the aliased `firstName` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Often, you may only need to return bound values in an application and not implicitly
    set them from the View. Wither Ember.js, the `Ember.computed.oneWay` method can
    be used for this purpose and will save you additional performance concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding with Ember.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two-way data binding is also available with Ember.js via computed properties.
    This uses an alias paradigm as well; however, a computed two-way alias allows
    for both getting and setting an aliased property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, we are using the Ember.computed.alias method to employ two-way
    data binding for the aliased `firstName` property via the computed `nickName`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new User object is created now, the `nickName` property can be accessed
    to both set and get the aliased `firstName` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, with two-way data binding, View synchronization comes into play. One thing
    to note about Ember.js in this scenario is that, although it does not use dirty
    checking, it will not immediately update values bound to the Model after they
    are changed. Property accessors are indeed used to aggregate changes to bound
    data, but they are not synchronized until the next run loop, just as with AngularJS
    and its digest cycle. In this respect, you could surmise that data binding with
    AngularJS versus Ember.js is really no different, and neither framework provides
    any benefit over the other in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the internal looping mechanisms implemented in these frameworks
    are designed around performance optimization. The difference in this case is that
    AngularJS uses its digest cycle to check for changes to bound values, in addition
    to its other internal operations, while Ember.js is always aware of changes to
    its bound values and only uses its run loop to synchronize them.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that each of these frameworks provides certain advantages over
    the other, depending upon what type of application you are building. When choosing
    a framework to build an application, it is always important to understand these
    internal mechanisms so that you can consider how they may affect performance in
    your particular use case.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding with Rivets.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is desirable to build an SPA with smaller, more modular libraries
    that provide you with specific functionality, rather than using a full-fledged
    frontend framework such as AngularJS or Ember.js. This could be because you are
    building a simple application that does not necessitate the complexity of an MVW
    architectural pattern, or you may just not want to be constrained by the conventions
    of a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Rivets.js is a lightweight library that is primarily designed around data binding,
    and although it does provide some additional features, it makes very few assumptions
    about your application architecture. In this respect, it is a good choice if you
    are only looking to add a data binding layer to a modularized application.
  prefs: []
  type: TYPE_NORMAL
- en: One-way data binding with Rivets.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rivets.js uses an internal construct called a *binder* to define how the DOM
    should be updated in response to a change in a bound property's value. The library
    comes with a variety of built-in binders, but also allows you to define your own
    custom binders.
  prefs: []
  type: TYPE_NORMAL
- en: One-way binders in Rivets.js update the DOM when a property on a bound Model
    changes. As you would expect in a one-way scenario, updating the View will not
    update the Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the binder syntax of Rivets.js, these properties can be bound to the
    View as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Rivets.js uses the `rv-` custom attribute prefix on HTML elements to define
    behaviors for different types of binders. The `rv-`text attribute is a built-in
    binder that inserts a bound value directly into the DOM, just as any JavaScript
    templating engine might do. To that point, there is also an expression interpolation
    syntax that uses single curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With either of these examples, the View would render the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing any properties on the bound Model would also update the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered HTML in the View would then reflect these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Defining your own one-way binder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If none of the many predefined binders in Rivets.js fits your needs, you can
    always define your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have created a binder called size, which can be used to
    dynamically change the CSS font-size property for an element based on a Model
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom binder can then be used in the View as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This would render the View with the `dog.favoriteThing` value displayed at twice
    the font-size of the body text, as defined in the bound dog Model.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding with Rivets.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two-way binders in Rivets.js behave just as one-way binders do when a Model
    is updated by synchronizing the bound values in the View, but they will also update
    the Model when bound values in the View are changed by the user. This behavior
    could be triggered by form input or some other type of event, such as clicking
    a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some predefined two-way binders included with Rivets.js. As you might
    expect, it provides for the most common use case `- a` text input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using the `rv-value` attribute to bind a Model property to an input element
    will prepopulate the value for that input with the bound Model value, and it will
    also update the Model value when the user changes the value of the input.
  prefs: []
  type: TYPE_NORMAL
- en: Defining your own two-way binder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To define a custom two-way binder in Rivets.js, a much more explicit approach
    must be taken, in contrast to one-way binders. This is because you must define
    how to bind and unbind to an element, as well as the data binding routine to run
    when the bound value changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using the special property definitions shown in this example, we are telling
    Rivets.js to bind to an input `onfocus` and to unbind from the input `onblur`.
    Additionally, we define a routine to run when the value changes in which a `className`
    of invalid is added to the input when the value is empty, and removed when it
    is populated.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing data binding with native JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing your own implementation of data binding can be done fairly easily using
    native JavaScript. If you don''t feel the need to use a comprehensive framework
    or library for your application and simply want the benefit of the data binding
    design pattern baked in, using native JavaScript to implement it is a logical
    course to take. This will provide you with several benefits, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You will understand how the data binding actually works under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have a less bloated frontend that doesn't include extraneous library
    code that you may not even use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You won't be pigeonholed into an architecture defined by a particular framework
    when all you want is the added benefit of data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object getters and setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Object` type in JavaScript has native `get` and `set` properties that can
    be used as `getters` and `setters` for any property name on a particular object.
    A `getter` is a method that returns a dynamically computed value from an object,
    and a `setter` is a method that is used to pass a value to a given property on
    an object as if you were assigning it that value. When a setter is defined and
    passed a value, the property name for that setter cannot actually hold a value
    itself; however, it can be used to *set* the value on a completely different variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `get` and `set` properties default to `undefined`, just like any unassigned
    property on an object, so they can easily be defined as functions for any user-defined
    object without affecting JavaScript's native `Object` prototype. This can be a
    powerful tool when used in an appropriate manner within an intuitive design pattern
    such as data binding.
  prefs: []
  type: TYPE_NORMAL
- en: The object initializer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Getters` and `setters` can be defined for an object using an object initializer,
    which is most commonly performed by defining an object in literal notation. For
    example, suppose we want to create a `getter` and a `setter` for the `firstName`
    property on an object named user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, we can use the `user.firstName` property to `get` and `set`
    the value for the `firstName` variable by simply using standard object literal
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, setting `user.firstName = 'Jarmond'` does not actually change
    the value of the `user.firstName` property; rather, it calls the property's defined
    setter method and instead sets the value for the standalone `firstName` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Object.defineProperty() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may often be the case that you would like to modify an existing object to
    provide data binding for that object in your application. To do this, the `Object.defineProperty()`
    method can be used to add the getter and setter for a particular property on a
    predefined object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the object you want to define a property for as the first
    argument, the property name you are defining as the second argument, and a `descriptor`
    object as the third argument. The descriptor object allows you to define the `getter`
    and `setter` for the property using the `get` and `set` key names, and it additionally
    allows some other keys to further describe the property.
  prefs: []
  type: TYPE_NORMAL
- en: The `configurable` key, if `true`, allows the property's configuration to be
    changed and the property itself to be deleted. It defaults to `false`. The `enumerable`
    key, if `true`, allows the property to be visible when iterating over the parent
    object. It also defaults to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Object.defineProperty()` is a more concise way to declare the `getter`
    and `setter` for an object's property because you can explicitly configure the
    behavior for that property, in addition to being able to add the property to a
    predefined object.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a getter and setter data binding pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can take this example further by creating a two-way binding between
    a DOM element and the `user` object for which we have defined a `getter` and `setter`.
    Let''s consider a text input element that is prepopulated with the `firstName`
    value initially when the page loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define our `getter` and `setter` based on the value of this input
    so that there is a reactive binding between the Model and the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you create a page with the input element and run the code above, you can
    then use the developer console in your browser to set the value of `user.firstName`
    and see it automatically update in the DOM for the value of the input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, if you change the value in the text input and then check the value
    of the `user.firstName` property in the developer console, you will see that it
    reflects the changed value of the input. With this simple use of a `getter` and
    `setter`, you have architecturally implemented two-way data binding with native
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing data in the View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To further extend this example so that representations of the Model in the
    View always remain synchronized and work much like the Rivets.js data binding
    pattern, we can simply add an oninput event callback to our input to update the
    DOM in the desired fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we want other places in the DOM where this data is represented to be
    updated upon changing the value of this input, all we need to do is add the desired
    behavior to the setter for the property. Let's use a custom HTML attribute called
    `data-bind` to convey the property's representation in the DOM outside of the
    text input itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a static file with the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below the HTML and just before the closing `</body>` tag of your document,
    add the following JavaScript within `<script>` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now load the page in your browser and observe that the `<strong data-bind="firstName">`
    element will be populated with the name `Udis` from the value of the input. This
    is achieved by calling the setter for the `user.firstName` property and assigning
    it to its corresponding `getter` as `user.firstName = user.firstName`. This may
    seem redundant, but what is actually occurring here is the code defined in the
    setter method is being executed with the given value from the text input, which
    is obtained from the `getter`. The setter looks for any element on the page with
    the `data-bind` property set to `firstName` and updates that element's content
    with the `firstName` value from the input, which is represented in the model as
    `user.firstName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, place your cursor in the text input and change the value. Notice that
    the name represented within the `<strong>` element changes as you type, and each
    representation is in sync with the model. Finally, use your developer console
    to update the value of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the representations both in the text input and the `<strong>` element
    are automatically updated and in sync. You have successfully created a two-way
    data binding and View synchronization design pattern using a small amount of native
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting the design pattern to a reusable method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can further abstract your data binding design pattern by creating a method
    that can be used to apply this behavior to a property for any predefined object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a method called `dataBind`, which takes an object and
    a property as its arguments. The property name is used as an identifier for elements
    in the DOM that are to be bound to the Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, simply define an object and call the `dataBind` method on it, additionally
    passing in the property name you want to bind to the DOM. This method also allows
    you to set the initial value for the property in the Model, and it will be reflected
    in the View upon binding if it is set. Otherwise, it will display the value set
    on the input itself, if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you modify the code in the page you just created to use the abstracted `dataBind`
    method, you will see that it works exactly as before, but it can now be reused
    to bind multiple object properties with multiple corresponding elements in the
    DOM. This pattern can certainly be further abstracted and combined with a modeling
    pattern in which it could be used as a powerful data binding layer within a JavaScript
    SPA. The open source library inbound.js is a good example of this pattern taken
    to the next level. You can learn more about it at [inboundjs.com](http://inboundjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: Accounting for DOM mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One downfall of the previous example, when it comes to View synchronization,
    is that only user input will trigger the setting of the Model from the View. If
    you want comprehensive, two-way data binding in which any changes to bound values
    in the View sync to their respective Model properties, then you must be able to
    observe DOM mutations, or changes, by any means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the previous example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you edit the value of the text input, the `firstName` property on the
    Model will update, and the `<strong data-bind="firstName">` element''s contents
    will be updated as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s instead use the developer console and change the `<strong data-bind="firstName">`
    element''s `innerHTML`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, you will notice that the value of the input has not updated,
    and neither has the Model data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The DOM mutation you created by using the console has now broken your two-way
    data binding and View synchronization. Fortunately, there is a native JavaScript
    constructor that can be used to avoid this pitfall.
  prefs: []
  type: TYPE_NORMAL
- en: MutationObserver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MutationObserver` constructor provides the ability to observe changes to
    the DOM no matter where they are triggered from. In most cases, user input is
    likely sufficient for triggering Model updates, but if you are building an application
    that may have DOM mutations triggered from other sources, such as data being pushed
    via Websockets, you may want to sync those changes back to your Model.
  prefs: []
  type: TYPE_NORMAL
- en: MutationObserver works much like the native addEventListener by providing a
    special type of listener that triggers a callback upon DOM mutation. This event
    type is unique in that it is not often triggered by direct user interaction, unless
    the developer console is being used to manipulate the DOM. Instead, application
    code is typically what will be updating the DOM, and this event is triggered directly
    by those mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `MutationObserver` can be instantiated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a configuration must be defined to pass to the observe method of the
    new observer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This object is called `MutationObserverInit`. It defines special properties
    that are used by the `MutationObserver` implementation to specify how closely
    an element is to be observed. At least one of `attributes`, `childList`, or `characterData`
    must be set to true, or an error will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attributes`: Tells the observer whether mutations to the element''s attributes
    should be observed or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`childList`: Tells the observer whether the addition and removal of the element''s
    child nodes should be observed or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`characterData`: Tells the observer whether mutations to the element''s data
    should be observed or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also four additional, but optional, `MutationObserverInit` properties
    that can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subtree`: If true, tells the observer to watch for mutations to the element''s
    descendants, in addition to the element itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributeOldValue`: If true in conjunction with attributes set to true, tells
    the observer to save the element attributes'' old values before mutation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`characterDataOldValue`: If true in conjunction with `characterData` set to
    true, tells the observer to save the element''s old data values before mutation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributeFilter`: An array specifying attribute names that should not be observed
    in conjunction with attributes set to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the configuration defined, an observer can now be called on a DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With this code in place, any mutations to the element with the attribute `data-bind="firstName"`
    will trigger the callback defined in the observer object's instantiation of the
    `MutationObserver` constructor, and it will log the mutation object passed to
    the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Extending dataBind with MutationObserver
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let''s further extend our `dataBind` method with the `MutationObserver`
    constructor by using it to trigger callbacks when elements with the data-bind
    attribute are mutated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MutationObserver` constructor takes a callback function as its only parameter.
    This callback is passed a mutations object, which can be iterated over to define
    callbacks for each mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the `MutationObserver` instantiation callback, we perform an inequality
    comparison of the bound Model property to the `mutation.target.innerHTML`, which
    is the content of the DOM element being observed, before we set the Model property.
    This is important because it provides that we only set the bound Model property
    when there is a DOM mutation triggered directly on this particular DOM node, and
    not as a result of a setter. If we did not perform this check, all setters would
    trigger the callback, which calls the setter again, and infinite recursion would
    ensue. This is, of course, not desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the new version of the `dataBind` method, test the HTML page in a browser
    again and update the input value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the developer console to change the bound Model property and you
    will see it update in the DOM for both the input and the `<strong data-bind="firstName">`
    element, as originally expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the developer console to change the innerHTML of the `<strong
    data-bind="firstName">` element and trigger a mutation event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, you will see the value of the input element update as well. This
    is because the mutation event was triggered and detected by the observer object,
    which then fired the callback function. Within that callback function, the `obj[prop]
    !== val` comparison was made and found to be true, so the setter was called on
    the new value, subsequently updating the input value and the value returned from
    the `user.firstName` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You have now implemented two-way data binding and comprehensive view synchronization
    using native `getters` and setters and the `MutationObserver` constructor. Keep
    in mind that the examples given here are experimental and have not been used in
    a real-world application. Care should be taken when employing these techniques
    in your own application, and testing should be paramount.
  prefs: []
  type: TYPE_NORMAL
- en: Why use data binding?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data binding provides a layer of abstraction that can eliminate the need for
    a lot of additional application wiring, custom event publishing and subscribing,
    and Model evaluation against the View. These things are usually handled with custom
    application code that is specific to the application itself, when a framework
    or some type of data binding is not being used. Without careful planning and the
    use of defined architectural patterns, this can lead to a lot of adjunct code,
    and subsequently a code base that is not extensible, does not scale well, and
    is difficult for new developers to take on and learn.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel that data binding is a component you'd like to include in your application,
    then consider your options, some of which we have laid out here, and choose accordingly.
    You may see the need to build your application with a full-fledged JavaScript
    framework such as AngularJS, or you may only want the added abstraction layer
    of data binding in combination with your own custom architecture. Also, consider
    the performance implications of your choices, and whether you need two-way data
    binding, which is more memory-intensive, or only one-way data binding, which will
    help to keep your application more performant.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for one-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common form of data binding in modern single page applications is one-way
    data binding. At its most basic, one-way data binding need only consist of binding
    dynamic Model values to their respective expressions in a template at render time.
    If the model changes after a template has already been rendered, the synchronization
    of that data to the View is an added benefit of some frameworks such as AngularJS,
    Ember.js, and Rivets.js.
  prefs: []
  type: TYPE_NORMAL
- en: If you are building an application in which you want to display real-time, frequently
    changing data to a user, and that data does not need to be manipulated by the
    user, this is a good use case for one-way data binding with View synchronization.
    A more specific example of this is an application for tracking stock quotes and
    displaying the prices as they change in real time. The Model data in this case
    is meant entirely for viewing by the user, but no changes to the Model from the
    View are necessary since the stock quotes cannot be changed by the user. In a
    scenario like this, two-way data binding listeners would not be useful and would
    only generate additional and unnecessary overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for two-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two-way data binding is not as commonly used as one-way data binding in single
    page applications, but it does have its place. It is important to fully understand
    the needs of your application before you decide to attach two-way data binding
    behaviors to the DOM and use additional memory.
  prefs: []
  type: TYPE_NORMAL
- en: A live chat, or live messaging, application is one of the most common examples
    of two-way data binding. Whether the application provides one-to-one messaging
    or multiuser messaging, two-way data binding can be used to synchronize the View
    in both directions for each user. As a user is viewing the application, new messages
    from other users are added to the Model and displayed in the View. Likewise, the
    user viewing the application enters new messages in the View and they are added
    to the Model, downloaded to the server, and then displayed to the other users
    in their own Views.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now learned what data binding is, the differences between one-way and
    two-way data binding, how data binding is implemented in some modern JavaScript
    frameworks and libraries, and what some use cases for data binding are in the
    real world. You have also learned about the architectural differences between
    one-way and two-way data binding implementations, and how to write your own data
    binding implementation using modern native JavaScript with getters and setters.
    Additionally, you have learned about the `MutationObserver` constructor and how
    it can be used to trigger behaviors in the DOM based on mutation events.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take everything that we have learned so far about different architectural
    components, including MongoDB, Express, AngularJS, and Node.js, and learn how
    to begin putting them all together to leverage the full MEAN stack.
  prefs: []
  type: TYPE_NORMAL
