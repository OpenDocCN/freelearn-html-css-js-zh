<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Building a Skeleton Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Building a Skeleton Architecture</h1></div></div></div><p>The best way to think in Flux is to write code in Flux. This is why we want to start building a <span class="strong"><strong>skeleton architecture</strong></span> as early as possible. We call this phase of building our application the skeleton architecture because it isn't yet the full architecture. It's missing a lot of key application components, and this is on purpose. The aim of the skeleton is to keep the moving parts to a minimum, allowing us to focus on the information our stores will generate for our views.</p><p>We'll get off the ground with a <a id="id77" class="indexterm"/>minimalist structure that, while small, doesn't require a lot of work to turn our skeleton architecture into our code base. Then, we'll move on to some of the information design goals of the skeleton architecture. Next, we'll dive into implementing some aspects of our stores.</p><p>As we start building, we'll begin to get a sense of how these stores map to domains—the features our users will interact with. After this, we'll create some really simple views, which can help us ensure that our data flows are in fact reaching their final destination. Finally, we'll end the chapter by running through a checklist for each of the Flux architectural layers, to make sure that we've validated our skeleton before moving on to other development activities.</p><div class="section" title="General organization"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>General organization</h1></div></div></div><p>As a first step in <a id="id78" class="indexterm"/>building a skeleton Flux architecture, we'll spend a few minutes getting organized. In this section, we'll establish a basic directory structure, figure out how we'll manage our dependencies, and choose our build tools. None of this is set in stone—the idea is to get going quickly, but at the same time, establish some norms so that transforming our skeleton architecture into application code is as seamless as possible.</p><div class="section" title="Directory structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Directory structure</h2></div></div></div><p>The directory structure <a id="id79" class="indexterm"/>used to start building our skeleton doesn't need to be fancy. It's a skeleton architecture, not the complete architecture, so the initial directory structure should follow suit. Having said that, we also don't want to use a directory structure that's difficult to evolve into what's actually used in the product. Let's take a look at the items that we'll find in the root of our project directory:</p><div class="mediaobject"><img src="graphics/B05419_03_01.jpg" alt="Directory structure"/></div><p>Pretty simple right? Let's walk through what each of these items represent:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">main.js</code>: This is the main entry point into the application. This JavaScript module will bootstrap the initial actions of the system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dispatcher.js</code>: This is our dispatcher module. This is where the Flux dispatcher instance is created.</li><li class="listitem" style="list-style-type: disc"><code class="literal">actions</code>: This directory contains all our action creator functions and action constants.</li><li class="listitem" style="list-style-type: disc"><code class="literal">stores</code>: This directory contains our store modules.</li><li class="listitem" style="list-style-type: disc"><code class="literal">views</code>: This directory contains our view modules.</li></ul></div><p>This may not seem like much, and this is by design. The directory layout is reflective of the architectural layers of Flux. Obviously there will be more to the actual application once we move past the skeleton architecture phase, but not a whole lot. We should refrain from adding any <a id="id80" class="indexterm"/>extraneous components at this point though, because the skeleton architecture is all about information design.</p></div><div class="section" title="Dependency management"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Dependency management</h2></div></div></div><p>As a starting point, we're going to require the basic Facebook Flux dispatcher as a dependency of our <a id="id81" class="indexterm"/>skeleton architecture—even if we don't end up using this dispatcher in our final product. We need to start designing our stores, as this is the most crucial and the most time-consuming aspect of the skeleton architecture; worrying about things like the dispatcher at this juncture simply doesn't pay off.</p><p>We need to start somewhere and the Facebook dispatcher implementation is good enough. The question is, will we need any other packages? In <a class="link" href="ch01.html" title="Chapter 1. What is Flux?">Chapter 1</a>, <span class="emphasis"><em>What is Flux?</em></span> we walked through the setup of the Facebook Flux NPM package and used Webpack to build our code. Can this work as our eventual production build system?</p><p>Not having a package manager or a module bundler puts us at a disadvantage, right from the onset of the project. This is why we need to think about dependency management as a first step of the skeleton architecture, even though we don't have many dependencies at the moment. If this is the first time we're building an application that has a Flux architecture behind it, the way we handle dependencies will serve as a future blueprint for subsequent Flux projects.</p><p>Is it a bad idea to add more module dependencies during the development of our skeleton architecture? Not at all. In fact, it's better that we use a tool that's well suited for the job. As we're implementing the skeleton, we'll start to see places in our stores where a library would be helpful. For example, if we're doing a lot of sorting and filtering on data collections and we're building higher-order functions, using something like lodash for this is perfect.</p><p>On the other hand, pulling in something like ReactJS or jQuery at this stage doesn't make a whole lot of sense because we're still thinking about the information and not how to present it in the DOM. So that's the approach we're going to use in this book—NPM as our package manager and Webpack as our bundler. This is the basic infrastructure we need, without much overhead to distract us.</p></div></div></div>
<div class="section" title="Information design"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Information design</h1></div></div></div><p>We know that the <a id="id82" class="indexterm"/>skeleton architecture we're trying to build is specifically focused on getting the right information into the hands of our users. This <a id="id83" class="indexterm"/>means that we're not paying much attention to user interactivity or formatting the information in a user-friendly way. It might help if we set some rough goals for ourselves—how do we know we're actually getting anywhere with our information design?</p><p>In this section, we'll talk about the negative influence API data models can have on our user interface design. Then, we'll look at mapping data to what the user sees and how these mappings should be encouraged throughout our stores. Finally, we'll think about the environment we find ourselves working in.</p><div class="section" title="Users don't understand models"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Users don't understand models</h2></div></div></div><p>Our job as user interface programmers is to get the right information to the user at the right time. How do we do <a id="id84" class="indexterm"/>this? Conventional wisdom revolves around taking some data that we got from the API and then rendering it as HTML. Apart from semantic markup and some styles, nothing much has changed with the data since it arrived from the API. We're saying <span class="emphasis"><em>here's the data we have, let's make it look nice for the user</em></span>. Here's an illustration of this idea:</p><div class="mediaobject"><img src="graphics/B05419_03_02.jpg" alt="Users don't understand models"/></div><p>There's no data transformation taking place here, which is fine, so long as the user is getting what they need. The problem this picture paints is that the data model of the API has taken the UI feature development hostage. We must heed everything that's sent down to us from the backend. The reason this is a problem is because we're limited in what we can actually do for the user. Something we can do is have our own models enhance the data that's sent back from the API. This means that if we're working on a feature that would require information that isn't exactly as the API intended it, we can fabricate it as a frontend model, as shown here:</p><div class="mediaobject"><img src="graphics/B05419_03_03.jpg" alt="Users don't understand models"/></div><p>This gets us slightly closer to our goal in the sense that we can create a model of the feature we're trying to implement and put it in front of the user. So while the API might not deliver exactly what we want to display on the screen, we can use our transformation functions to generate a model of the information we need.</p><p>During the skeleton architecture phase of our design process, we should think about stores independent of API's as much as possible. Not completely independently; we don't want to go way out into left field, jeopardizing the product. But the idea of producing a Flux skeleton architecture <a id="id85" class="indexterm"/>is to ensure that we're producing the right information, first and foremost. If there's no way the API can support what we're trying to do, then we can take the necessary steps, before spending a lot of time implementing full-fledged features.</p></div><div class="section" title="Stores map to what the user sees"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Stores map to what the user sees</h2></div></div></div><p>State isn't <a id="id86" class="indexterm"/>the only thing that's encapsulated by the stores found in our Flux architecture. There's also the data transformations that map old state to new state. We should spend more time thinking about what the user needs to see and less time thinking about the API data, which means that the store transformation functions are essential.</p><p>We need to embrace data transformations in Flux stores, because they're the ultimate determinant of how things change in front of the user's eyes. Without these transformations, the user would only be able to view static information. Of course, we could aim to design an architecture that only uses the data that's passed into the system "as-is", without transforming it. This never works out as we intend, for the simple reason that we're going to uncover dependencies with other UI components.</p><p>What should our early goals be with stores and how we transform their state? Well, the skeleton architecture is all about experimentation, and if we start writing transformation functionality upfront, we're likely to discover dependencies sooner. Dependencies aren't necessarily a bad thing, except when we find a lot of them late in the project, well after we've completed the skeleton architecture phase. Of course, new features are going to add new dependencies. If we can use state transformations early on to identify potential dependencies, then we can avoid future headaches.</p></div><div class="section" title="What do we have to work with?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>What do we have to work with?</h2></div></div></div><p>The last thing <a id="id87" class="indexterm"/>we'll need to consider before we roll up our sleeves and start implementing this skeleton Flux architecture is what's already in place. For example, does this application already have an established API and we're re-architecting the frontend? Do we need to retain the user experience of an existing UI? Is the project completely greenfield with no API or user experience input?</p><p>The following diagram illustrates how these external factors influence the way we treat the implementation of our skeleton architecture:</p><div class="mediaobject"><img src="graphics/B05419_03_04.jpg" alt="What do we have to work with?"/></div><p>There's nothing wrong with having these two factors shape our Flux architecture. In the case of existing APIs, we'll have a starting point from which we can start writing our state transformation functions, to get the user the information that they need. In the case of keeping an existing user experience, we already know what the shape of our target information looks <a id="id88" class="indexterm"/>like, and we can work the transformation functions from a different angle.</p><p>When the Flux architecture is completely greenfield, we can let it inform both the user experience and the APIs that need to be implemented. It's highly unlikely that any of the scenarios in which we find ourselves building a skeleton architecture will be cut-and-dried. These are just the starting points that we may find ourselves in. Having said that, it's time to start implementing some skeleton stores.</p></div></div>
<div class="section" title="Putting stores into action"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Putting stores into action</h1></div></div></div><p>In this section, we're <a id="id89" class="indexterm"/>going to implement some stores in our skeleton architecture. They won't be complete stores capable of supporting end-to-end work-flows. However, we'll be able to see where the stores fit within the context of our application.</p><p>We'll start with the most <a id="id90" class="indexterm"/>basic of all store actions, which are populating them with some data; this is usually done by fetching it via some API. Then, we'll discuss changing the state of remote API data. Finally, we'll look at actions that change the state of a store locally, without the use of an API.</p><div class="section" title="Fetching API data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Fetching API data</h2></div></div></div><p>Regardless of whether <a id="id91" class="indexterm"/>or not there's an API with application data ready to consume, we know that eventually this is how we'll populate our store data. So it makes sense that we think about this as the first design activity of implementing skeleton stores.</p><p>Let's create a basic store for the homepage of our application. The obvious information that the user is going to want to see here is the currently logged-in user, a navigation menu, and perhaps a summarized list of recent events that are relevant to the user. This means that fetching this data is one of the first things our application will have to do. Here's our first <a id="id92" class="indexterm"/>implementation of the store:</p><div class="informalexample"><pre class="programlisting">// Import the dispatcher, so that the store can
// listen to dispatch events.
import dispatcher from '../dispatcher';

// Our "Home" store.
class HomeStore {
  constructor() {

    // Sets a default state for the store. This is
    // never a bad idea, in case other stores want to
    // iterate over array values - this will break if
    // they're undefined.
    this.state = {
      user: '',
      events: [],
      navigation: []
    };

    // When a "HOME_LOAD" event is dispatched, we
    // can assign "payload" to "state".
    dispatcher.register((e) =&gt; {
      switch (e.type) {
        case 'HOME_LOAD':
          Object.assign(this.state, e.payload);
          break;
      }
    });
  }
}

export default new HomeStore();</pre></div><p>This is fairly easy to follow, so lets point out the important pieces. First, we need to import the dispatcher so that we can register our store. When the store is created, the default state is stored in the <code class="literal">state</code> property. When the <code class="literal">HOME_LOAD</code> action is dispatched, we change the state of the store. Lastly, we export the store instance as the default module member.</p><p>As the action name implies, <code class="literal">HOME_LOAD</code> is dispatched when data for the store has loaded. Presumably, we're going to pull this data for the home store from some API endpoints. Let's go ahead and put <a id="id93" class="indexterm"/>this store to use in our <code class="literal">main.js</code> module—our application entry point:</p><div class="informalexample"><pre class="programlisting">// Imports the "dispatcher", and the "homeStore".
import dispatcher from './dispatcher';
import homeStore from './stores/home';

// Logs the default state of the store, before
// any actions are triggered against it.
console.log(`user: "${homeStore.state.user}"`);
// → user: ""

console.log('events:', homeStore.state.events);
// → events: []

console.log('navigation:', homeStore.state.navigation);
// → navigation: []

// Dispatches a "HOME_LOAD" event, when populates the
// "homeStore" with data in the "payload" of the event.
dispatcher.dispatch({
  type: 'HOME_LOAD',
  payload: {
    user: 'Flux',
    events: [
      'Completed chapter 1',
      'Completed chapter 2'
    ],
    navigation: [
      'Home',
      'Settings',
      'Logout'
    ]
  }
});

// Logs the new state of "homeStore", after it's
// been populated with data.
console.log(`user: "${homeStore.state.user}"`);
// → user: "Flux"

console.log('events:', homeStore.state.events);
// → events: ["Completed chapter 1", "Completed chapter 2"]

console.log('navigation:', homeStore.state.navigation);
// → navigation: ["Home", "Settings", "Logout"]</pre></div><p>This is some fairly straightforward usage of our home store. We're logging the default state of the store, dispatching the <code class="literal">HOME_LOAD</code> action with some new payload data, and logging the state again to make sure that the state of the store did in fact change. So the question is, what does this code have to do with the API?</p><p>This is a good starting point for our skeleton architecture because there's a number of things to think about before we even get to implementing API calls. We haven't even started implementing actions yet, because if we did, they'd just be another distraction. And besides, actions and real API calls are easy to implement once we flesh out our stores.</p><p>The first question that comes to mind about the <code class="literal">main.js</code> module is the location of the <code class="literal">dispatch()</code> call to <code class="literal">HOME_LOAD</code>. Here, we're bootstrapping data into the store. Is this the right place to do this? When the <code class="literal">main.js</code> module runs will we always require that this store be populated? Is this the place where we'll want to bootstrap data into all of our stores? We don't need immediate answers to these questions, because that would likely result in us dwelling on one aspect of the architecture for far too long, and there are many other issues to think about.</p><p>For example, does the coupling of our store make sense? The home store we just implemented has a <a id="id94" class="indexterm"/>
<code class="literal">navigation</code> array. These are just simple strings right now, but they'll likely turn into objects. The bigger issue is that the navigation data might not even belong in this store—several other stores are probably going to require navigation state data too. Another example is the way we're setting the new state of the store using the dispatch payload. Using <code class="literal">Object.assign()</code> is advantageous, because we can dispatch the <code class="literal">HOME_LOAD</code> event with a payload with only one state property and everything will continue to function the same. Implementing this store took us very little time at all, but we've asked some very important questions and learned a powerful technique for assigning new store state.</p><p>This is the skeleton architecture, and so we're not concerned with the mechanics of actually fetching the API data. We're more concerned about the actions that get dispatched as a result of API data arriving in the browser; in this case, it's <code class="literal">HOME_LOAD</code>. It's the mechanics of information flowing through stores that matters in the context of a skeleton Flux architecture. And on that note, let's expand the capabilities of our store slightly:</p><div class="informalexample"><pre class="programlisting">// We need the "dispatcher" to register our store,
// and the "EventEmitter" class so that our store
// can emit "change" events when the state of the
// store changes.
import dispatcher from '../dispatcher';
import { EventEmitter } from 'events';

// Our "Home" store which is an "EventEmitter"
class HomeStore extends EventEmitter {
  constructor() {

    // We always need to call this when extending a class.
    super();

    // Sets a default state for the store. This is
    // never a bad idea, in case other stores want to
    // iterate over array values - this will break if
    // they're undefined.
    this.state = {
      user: '',
      events: [],
      navigation: []
    };

    // When a "HOME_LOAD" event is dispatched, we
    // can assign "payload" to "state", then we can
    // emit a "change" event.
    dispatcher.register((e) =&gt; {
      switch (e.type) {
        case 'HOME_LOAD':
          Object.assign(this.state, e.payload);
          this.emit('change', this.state);
          break;
      }
    });
  }
}

export default new HomeStore();</pre></div><p>The store still does everything it did before, only now the store class inherits from <code class="literal">EventEmitter</code>, and <a id="id95" class="indexterm"/>when the <code class="literal">HOME_LOAD</code> action is dispatched, it emits a <code class="literal">change</code> event using the store state as the event data. This gets us one step closer to having a full work-flow, as views can now listen to the <code class="literal">change</code> event to get the new state of the store. Let's update our main module code to see how this is done:</p><div class="informalexample"><pre class="programlisting">// Imports the "dispatcher", and the "homeStore".
import dispatcher from './dispatcher';
import homeStore from './stores/home';

// Logs the default state of the store, before
// any actions are triggered against it.
console.log(`user: "${homeStore.state.user}"`);
// → user: ""

console.log('events:', homeStore.state.events);
// → events: []

console.log('navigation:', homeStore.state.navigation);
// → navigation: []

// The "change" event is emitted whenever the state of The
// store changes.
homeStore.on('change', (state) =&gt; {
  console.log(`user: "${state.user}"`);
  // → user: "Flux"

  console.log('events:', state.events);
  // → events: ["Completed chapter 1", "Completed chapter 2"]

  console.log('navigation:', state.navigation);
  // → navigation: ["Home", "Settings", "Logout"]
});

// Dispatches a "HOME_LOAD" event, when populates the
// "homeStore" with data in the "payload" of the event.
dispatcher.dispatch({
  type: 'HOME_LOAD',
  payload: {
    user: 'Flux',
    events: [
      'Completed chapter 1',
      'Completed chapter 2'
    ],
    navigation: [
      'Home',
      'Settings',
      'Logout'
    ]
  }
});</pre></div><p>This enhancement to the store in our skeleton architecture brings about yet more questions, namely, about setting up event listeners on our stores. As you can see, we have to make sure that the handler is actually listening to the store before any actions are dispatched. All of these <a id="id96" class="indexterm"/>concerns we need to address, and we've only just begun to design our architecture. Let's move on to changing the state of backend resources.</p></div><div class="section" title="Changing API resource state"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Changing API resource state</h2></div></div></div><p>After we've <a id="id97" class="indexterm"/>set the initial store state by asking the API for some data, we'll likely end up needing to change the state of that backend resource. This happens in response to user activity. In fact, the common pattern looks like the following diagram:</p><div class="mediaobject"><img src="graphics/B05419_03_05.jpg" alt="Changing API resource state"/></div><p>Let's think about this pattern in the context of a Flux store. We've already seen how to load data into a store. In the skeleton architecture we're building, we're not actually making these API calls, even if they exist—we're focused solely on the information that's produced by the frontend right now. When we dispatch an action that changes the state of a store, we'll probably need to update the state of this store in response to successful completion of the API call. The real question is, what does this entail exactly?</p><p>For example, does the call we make to change the state of the backend resource actually respond with the updated resource, or does it respond with a mere success indication? These types of API patterns have a dramatic impact on the design of our stores because it means the difference between having to always make a secondary call or having the data in the response.</p><p>Let's <a id="id98" class="indexterm"/>look at some code now. First, we have a user store as follows:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';
import { EventEmitter } from 'events';

// Our "User" store which is an "EventEmitter"
class UserStore extends EventEmitter {
  constructor() {
    super();
    this.state = {
      first: '',
      last: ''
    };

    dispatcher.register((e) =&gt; {
      switch (e.type) {
        // When the "USER_LOAD" action is dispatched, we
        // can assign the payload to this store's state.
        case 'USER_LOAD':
          Object.assign(this.state, e.payload);
          this.emit('change', this.state);
          break;

        // When the "USER_REMOVE" action is dispatched,
        // we need to check if this is the user that was
        // removed. If so, then reset the state.
        case 'USER_REMOVE':
          if (this.state.id === e.payload) {
            Object.assign(this.state, {
              id: null,
              first: '',
              last: ''
            });

            this.emit('change', this.state);
          }

          break;
      }
    });
  }
}

export default new UserStore();</pre></div><p>We'll assume that this singular user store is for a page in our application where only a single user is displayed. Now, let's implement a store that's useful for tracking the state of several users:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';
import { EventEmitter } from 'events';

// Our "UserList" store which is an "EventEmitter"
class UserListStore extends EventEmitter {
  constructor() {
    super();

    // There's no users in this list by default.
    this.state = []

    dispatcher.register((e) =&gt; {
      switch (e.type) {

        // The "USER_ADD" action adds the "payload" to
        // the array state.
        case 'USER_ADD':
          this.state.push(e.payload);
          this.emit('change', this.state);
          break;

        // The "USER_REMOVE" action has a user id as
        // the "payload" - this is used to locate the
        // user in the array and remove it.
        case 'USER_REMOVE':
          let user = this.state.find(
            x =&gt; x.id === e.payload);

          if (user) {
            this.state.splice(this.state.indexOf(user), 1);
            this.emit('change', this.state);
          }

          break;
      }
    });
  }
}

export default new UserListStore();</pre></div><p>Let's now create the <code class="literal">main.js</code> module that will work with these stores. In particular, we want to see how interacting with the API to change the state of a backend resource will influence the <a id="id99" class="indexterm"/>design of our stores:</p><div class="informalexample"><pre class="programlisting">import dispatcher from './dispatcher';
import userStore from './stores/user';
import userListStore from './stores/user-list';

// Intended to simulate a back-end API that changes 
// state of something. In this case, it's creating
// a new resource. The returned promise will resolve
// with the new resource data.
function createUser() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve({
        id: 1,
        first: 'New',
        last: 'User'
      });
    }, 500);
  });
}

// Show the user when the "userStore" changes.
userStore.on('change', (state) =&gt; {
  console.log('changed', `"${state.first} ${state.last}"`);
});

// Show how many users there are when the "userListStore"
// changes.
userListStore.on('change', (state) =&gt; {
  console.log('users', state.length);
});

// Creates the back-end resource, then dispatches actions
// once the promise has resolved.
createUser().then((user) =&gt; {

  // The user has loaded, the "payload" is the resolved data.
  dispatcher.dispatch({
    type: 'USER_LOAD',
    payload: user
  });
  // Adds a user to the "userListStore", using the resolved
  // data.
  dispatcher.dispatch({
    type: 'USER_ADD',
    payload: user
  });

  // We can also remove the user. This impacts both stores.
  dispatcher.dispatch({
    type: 'USER_REMOVE',
    payload: 1
  });
});</pre></div><p>Here, we can see that the <code class="literal">createUser()</code> function serves as a proxy for the actual API implementation. Remember, this is a skeleton architecture where the chief concern is the information <a id="id100" class="indexterm"/>constructed by our stores. Implementing a function that returns a promise is perfectly acceptable here because this is very easy to change later on once we start talking to the real API.</p><p>We're on the lookout for interesting aspects of our stores—their state, how that state changes, and the dependencies between our stores. In this case, when we create the new user, the API returns the new object. Then, this is dispatched as a <code class="literal">USER_LOAD</code> action. Our <code class="literal">userStore</code> is now populated. We're also dispatching a <code class="literal">USER_ADD</code> action so that the new user data can be added to this list. Presumably, these two stores service different parts of our application, and yet the same API call that changes the state of something in the backend is relevant.</p><p>What can we learn about our architecture from all of this? For starters, we can see that the promise callback is going to have to dispatch multiple actions for multiple stores. This means that we can probably expect more of the same with similar API calls that create resources. What about calls that modify users, would the code look similar?</p><p>Something that we're missing here is an action to update the state of a user object within the array of users in <code class="literal">userListStore</code>. Alternatively, we could have this store also handle the <code class="literal">USER_LOAD</code> action. Any approach is fine, it's the exercise of building the skeleton architecture that's supposed to help us find the approach that best fits our application. For example, we're dispatching a single <code class="literal">USER_REMOVE</code> action here too, and this is handled easily by both our stores. Maybe this is the approach we're looking for?</p></div><div class="section" title="Local actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Local actions</h2></div></div></div><p>We'll close the <a id="id101" class="indexterm"/>section on store actions with a look at local actions. These are actions that have nothing to do with the API. Local actions are generally in response to user interactions, and dispatching them will have a visible effect on the UI. For example, the user wants the toggle the visibility of some component on the page.</p><p>The typical application would just execute a jQuery one-liner to locate the element in the DOM and make the appropriate CSS changes. This type of thing doesn't fly in Flux architectures, and it's the type of thing we should start thinking about during the skeleton architecture phase of our application. Let's implement a simple store that handles local actions:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';
import { EventEmitter } from 'events';

// Our "Panel" store which is an "EventEmitter"
class PanelStore extends EventEmitter {
  constructor() {

    // We always need to call this when extending a class.
    super();

    // The initial state of the store.
    this.state = {
      visible: true,
      items: [
        { name: 'First', selected: false },
        { name: 'Second', selected: false }
      ]
    };

    dispatcher.register((e) =&gt; {
      switch (e.type) {

        // Toggles the visibility of the panel, which is
        // visible by default.
        case 'PANEL_TOGGLE':
          this.state.visible = !this.state.visible;
          this.emit('change', this.state);
          break;

        // Selects an object from "items", but only
        // if the panel is visible.
        case 'ITEM_SELECT':
          let item = this.state.items[e.payload];

          if (this.state.visible &amp;&amp; item) {
            item.selected = true;
            this.emit('change', this.state);
          }

          break;
      }
    });
  }
}

export default new PanelStore();</pre></div><p>The <code class="literal">PANEL_TOGGLE</code> action and the <code class="literal">ITEM_SELECT</code> action are two local actions handled by this store. They're local <a id="id102" class="indexterm"/>because they're likely triggered by the user clicking a button or selecting a checkbox. Let's dispatch these actions so we can see how our store handles them:</p><div class="informalexample"><pre class="programlisting">import dispatcher from './dispatcher';
import panelStore from './stores/panel';

// Logs the state of the "panelStore" when it changes.
panelStore.on('change', (state) =&gt; {
  console.log('visible', state.visible);
  console.log('selected', state.items.filter(
    x =&gt; x.selected));
});

// This will select the first item.
dispatcher.dispatch({
  type: 'ITEM_SELECT',
  payload: 0
});
// → visible true
// → selected [ { name: First, selected: true } ]

// This disables the panel by toggling the "visible"
// property value.
dispatcher.dispatch({ type: 'PANEL_TOGGLE' });
// → visible false
// → selected [ { name: First, selected: true } ]

// Nothing the second item isn't actually selected,
// because the panel is disabled. No "change" event
// is emitted here either, because the "visible"
// property is false.
dispatcher.dispatch({
  type: 'ITEM_SELECT',
  payload: 1
});</pre></div><p>This example serves as an illustration as to why we should consider all things state-related during the skeleton architecture implementation phase. Just because we're not implementing actual UI components right now, doesn't mean we can't guess at some of the potential states of common building blocks. In this code, we've discovered that the <code class="literal">ITEM_SELECT</code> action is actually dependent on the <code class="literal">PANEL_TOGGLE</code> action. This is because we don't actually want to select an item and update the view when the panel is disabled.</p><p>Building on this idea, should other components be able to dispatch this action in the first place? We've just found a <a id="id103" class="indexterm"/>potential store dependency, where the dependent store would query the state of <code class="literal">panelStore</code> before actually enabling UI elements. All of this from local actions that don't even talk to APIs, and without actual user interface elements. We're probably going to find many more items like this throughout the course of our skeleton architecture, but don't get hung up on finding everything. The idea is to learn what we can, while we have an opportunity to, because once we start implementing real features, things become more complicated.</p></div></div>
<div class="section" title="Stores and feature domains"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Stores and feature domains</h1></div></div></div><p>With more traditional <a id="id104" class="indexterm"/>frontend architectures, models that map directly to what's returned from the API provide a clear and concise data model for our JavaScript components to work with. Flux, as we now know, leans more in the direction of the user, and focuses on the information that they need to see and interact with. This doesn't need to be a gigantic headache for us, especially if we're able to decompose our user interface into domains. Think of a domain as a really big feature.</p><p>In this section, we'll talk about identifying the top-level features that form the core of our UI. Then, we'll work on shedding irrelevant API data from the equation. We'll finish the section with a look at the structure of our store data, and the role it plays in the design of our skeleton architecture.</p><div class="section" title="Identifying top-level features"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Identifying top-level features</h2></div></div></div><p>During the <a id="id105" class="indexterm"/>skeleton architecture phase of our Flux project, we should jump in and start writing store code, just as we've done in this chapter. We've been thinking about the information the user is going to need and how we can best get this information to the user. Something we didn't spend a lot of time on upfront was trying to identify the top level features of the application. This is fine, because the exercises we've performed so far in this chapter are often a prerequisite for figuring out how to organize our user interface.</p><p>However, once we've identified how we're going to implement some of the low-level store mechanisms that get us the information we're after, we need to start thinking about these top-level features. And there's a good reason for this—the stores we ultimately maintain will map to these features. When we say top-level, it's tempting to use the navigation as the point of reference. There's actually nothing wrong with using the page navigation as a guide; if it's big enough for the main navigation, it's probably a top-level feature that's worthy of its own Flux store.</p><p>In addition to being a top-level feature, we need to think about the role of the store—why does it exist? What value does this add for the user? The reason these questions are important is because we could end up having six pages that all could have used the same store. So it's a balance between consolidating value into one store and making sure that the store isn't to large and general-purpose.</p><p>Applications are complex, with lots of moving parts that drive lots of features. Our user interface probably has 50 awesome features. But this is unlikely to require 50 awesome top-level navigation links and 50 Flux stores. Our stores will have to represent the complex intricacies of these features in their data, at some point. This comes later though, for now we just need to get a handle on approximately how many stores we're working with, and how many dependencies we have between them.</p></div><div class="section" title="Irrelevant API data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Irrelevant API data</h2></div></div></div><p>Use it or lose it—the mantra of Flux store data. The challenge with API data is that it's a representation of a <a id="id106" class="indexterm"/>backend resource—it's not going to return data that's specifically required for our UI. An API exists so that more than one UI can be built on it. However, this means that we often end up with irrelevant data in our stores. For example, if we only need a few properties from an API resource, we don't want to store 36 properties. Especially when some of these can themselves be collections. This is wasteful in terms of memory consumption, and confusing in terms of their existence. It's actually the latter point that's more concerning because we can easily mislead other programmers working on this project.</p><p>One potential solution is to exclude these unused values from the API response. Many APIs today support this, by letting us opt-in to the properties we want returned. And this is probably a good idea if it means drastically reduced network bandwidth. However, this approach can also be error-prone because we have to perform this filtering at the ajax call level, instead of at <a id="id107" class="indexterm"/>the store level. Let's look at an example that takes a different approach, by specifying a store record:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';
import { EventEmitter } from 'events';

class PlayerStore extends EventEmitter {
  constructor() {
    super();

    // The property keys in the default state are
    // used to determine the allowable properties
    // used to set the state.
    this.state = {
      id: null,
      name: ''
    };

    dispatcher.register((e) =&gt; {
      switch (e.type) {
        case 'PLAYER_LOAD':

          // Make sure that we only take payload data
          // that's already a state property.
          for (let key in this.state) {
            this.state[key] = e.payload[key];
          }

          this.emit('change', this.state);
          break;
      }
    });
  }
}

export default new PlayerStore();</pre></div><p>In this example, the default <code class="literal">state</code> object plays an important role, other than providing default state values. It also provides the store record. In other words, the property keys used by the default state determine the allowable values when the <code class="literal">PLAYER_LOAD</code> <a id="id108" class="indexterm"/>action is dispatched. Let's see if this works as expected:</p><div class="informalexample"><pre class="programlisting">import dispatcher from './dispatcher';
import playerStore from './stores/player';

// Logs the state of the player store when it changes.
playerStore.on('change', (state) =&gt; {
  console.log('state', state);
});

// Dispatch a "PLAYER_LOAD" action with more payload
// data than is actually used by the store.
dispatcher.dispatch({
  type: 'PLAYER_LOAD',
  payload: {
    id: 1,
    name: 'Mario',
    score: 527,
    rank: 12
  }
});
// → state {id: 1, name: "Mario"}</pre></div></div><div class="section" title="Structuring store data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Structuring store data</h2></div></div></div><p>All of the examples <a id="id109" class="indexterm"/>shown so far in this chapter have relatively simple state objects within stores. Once we build the skeleton architecture up, these simple objects will turn into something more complicated. Remember, the state of a store reflects the state of the information that the user is looking at. This includes the state of some of the elements on the page.</p><p>This is something we need to keep an eye on. Just because we're through performing the skeleton architecture exercise doesn't mean an idea will hold up as we start to implement more elaborate features. In other words, if a store state becomes too large—too nested and deep—then it's time to consider moving our stores around a little bit.</p><p>The idea is that we don't want too many stores driving our views, because they're more like models from an MVC architecture at this point. We want the stores to represent a specific feature of the application. This doesn't always work out, because we could end up having some complex and convoluted state in the store for the feature. In this case, our top-level feature needs to be split somehow.</p><p>This will no doubt happen at some point during our time with Flux, and there's no rule in place that says when it's time to refactor stores. Instead, if the state data stays at a size where it feels <a id="id110" class="indexterm"/>comfortable to work with, you're probably fine with the store as it is.</p></div></div>
<div class="section" title="Bare bone views"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Bare bone views</h1></div></div></div><p>We've made some <a id="id111" class="indexterm"/>progress with our skeleton stores to the point where we're ready to start looking at skeleton views. These are simple classes, much in the same spirit as stores are, except we're not actually rendering anything to the DOM. The idea with these bare bone views is to affirm the sound infrastructure of our architecture, and that these view components are in fact getting the information they expect. This is crucial because the views are the final item in the Flux data-flow, so if they're not getting what they need, when they need it, we need to go back and fix our stores.</p><p>In this section, we'll discuss how our bare-boned views can help us more quickly identify when stores are missing a particular piece of information. Then, we'll look at how these views can help us identify potential actions in our Flux application.</p><div class="section" title="Finding missing data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Finding missing data</h2></div></div></div><p>The first <a id="id112" class="indexterm"/>activity we'll perform with our bare bone views is figuring out whether or not the stores are passing along all the essential information required by the view. By essential, we're talking about things that would be problematic for the user were they not there. For example, we're looking at a settings page, and there's a whole section missing. Or, there's a list of options to select from, but we don't actually have the string labels to show because they're part of some other API.</p><p>Once we figure out that these critical pieces of information are missing from the store, the next step is to determine if they're a possibility, because if they're not, we've just avoided spending an inordinate amount of time implementing a full-fledged view. However, these are the rare cases. Usually, it isn't a big deal to go back to the store in question and add the missing transformation that will compute and set the missing state we're looking for.</p><p>How much time do we need to spend on these bare bone views? Think of it this way—as we start implementing the actual views that render to the DOM for us, we'll discover more missing state from the store. These, however, are superficial and easy to fix. With the bare bone views, we're more concerned with teasing out the critical parts that are missing. What can we do with these views when we're done with them? Are they garbage? Not necessarily, depending on how we want to implement our production views, we could either adjust them to become ReactJS components or we could embed the actual view <a id="id113" class="indexterm"/>inside the bare-bone view, making it more of a container.</p></div><div class="section" title="Identifying actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Identifying actions</h2></div></div></div><p>As we saw <a id="id114" class="indexterm"/>earlier in the chapter, the first set of actions to be dispatched by a given Flux architecture are going to be related to fetching data from the backend API. Ultimately, these are the start of the data-flows that end with the views. Sometimes, these are merely <span class="emphasis"><em>load</em></span> type actions, where we're explicitly saying to go fetch the resource and populate our store. Other times, we might have more abstract actions that describe the action taken by the user, resulting in several stores being populated from many different API endpoints.</p><p>This gets the user to a point where we can start thinking about how they're going to want to interact with this information. The only way they do so is by dispatching more actions. Let's create a view with some action methods. Essentially, the goal is to have access our views from the browser JavaScript console. This lets us view the state information associated with the view at any given point, as well as call the method to dispatch the given action.</p><p>To do this, we need to adjust our Webpack configuration slightly:</p><div class="informalexample"><pre class="programlisting">output: {
  …
  library: 'views'
}</pre></div><p>This one line will export a global <code class="literal">views</code> variable in the browser window, and its value will be whatever our <code class="literal">main.js</code> module exports. Let's have a look at this now:</p><div class="informalexample"><pre class="programlisting">import settingsView from './views/settings';
export { settingsView as settings };</pre></div><p>Well, this looks interesting. We're simply exporting our view as <code class="literal">settings</code>. So, as we're creating our bare bone views in the skeleton architecture, we simply follow this pattern in <code class="literal">main.js</code> to keep adding views to the browser console to experiment with. Let's now take a look at the settings view itself:</p><div class="informalexample"><pre class="programlisting">import dispatcher from '../dispatcher';
import settingsStore from '../stores/settings';

// This is a "bare bones" view because it's
// not rendering anything to the DOM. We're just
// using it to validate our Flux data-flows and
// to think about potential actions dispatched
// from this view.
class SettingsView {
  constructor() {

    // Logs the state of "settingsStore" when it
    // changes.
    settingsStore.on('change', (state) =&gt; {
      console.log('settings', state);
    });

    // The initial state of the store is logged.
    console.log('settings', settingsStore.state);
  }

  // This sets an email value by dispatching
  // a "SET_EMAIL" action.
  setEmail(email) {
    dispatcher.dispatch({
      type: 'SET_EMAIL',
      payload: 'foo@bar.com'
    });
  }

  // Do all the things!
  doTheThings() {
    dispatcher.dispatch({
      type: 'DO_THE_THINGS',
      payload: true
    })
  }
}

// We don't need more than one of these
// views, so export a new instance.
export default new SettingsView();</pre></div><p>The only thing left <a id="id115" class="indexterm"/>to do now is to see what's available in the browser console when we load this page. We should have a global <code class="literal">views</code> variable, and this should have each of our view instances as properties. Now, we get to play around with actions dispatched by views as though we're users clicking around in the DOM. Let's see how this looks:</p><div class="informalexample"><pre class="programlisting">views.settings.setEmail()
// → settings {email: "foo@bar.com", allTheThings: false}

views.settings.doTheThings()
// → settings {email: "foo@bar.com", allTheThings: true}</pre></div></div></div>
<div class="section" title="End-to-end scenarios"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>End-to-end scenarios</h1></div></div></div><p>At some point, we're <a id="id116" class="indexterm"/>going to have to wrap up the skeleton architecture phase of the project and start implementing real features. We don't want the skeleton phase to drag on for too long because then we'll start making too many assumptions about the reality of our implementation. At the same time, we'll probably want to walk through a few end-to-end scenarios before we move on.</p><p>The aim of this section is to provide you with a few high-level points to be on the lookout for in each architectural layer. These aren't strict criteria, but they can certainly help us formulate our own measurements that determine whether or not we've adequately answered our questions about the information architecture by building a skeleton. If we're feeling confident, it's time to go full steam and flesh out the application detail—the subsequent chapters in this book dive into the nitty-gritty of implementing Flux.</p><div class="section" title="Action checklist"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Action checklist</h2></div></div></div><p>The following <a id="id117" class="indexterm"/>items are worth thinking about when we're implementing actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Do our features have actions that bootstrap store data by fetching it from the API?</li><li class="listitem" style="list-style-type: disc">Do we have actions that change the state of backend resources? How are these changes reflected in our frontend Flux stores?</li><li class="listitem" style="list-style-type: disc">Does a given feature have any local actions, and are they distinct from actions that issue API requests?</li></ul></div></div><div class="section" title="Store checklist"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Store checklist</h2></div></div></div><p>The following <a id="id118" class="indexterm"/>items are worth thinking about when implementing stores:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does the store map to a top-level feature in our application?</li><li class="listitem" style="list-style-type: disc">How well does the data structure of the store meet the needs of the views that use it? Is the structure too complex? If so, can we refactor the store into two stores?</li><li class="listitem" style="list-style-type: disc">Do the stores discard API data that isn't used?</li><li class="listitem" style="list-style-type: disc">Do the stores map API data to relevant information that the user needs?</li><li class="listitem" style="list-style-type: disc">Is our store structure amenable to change once we start adding more elaborate view functionality?</li><li class="listitem" style="list-style-type: disc">Do we have too many stores? If so, do we need to rethink the way we've structured the <a id="id119" class="indexterm"/>top-level application features?</li></ul></div></div><div class="section" title="View checklist"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>View checklist</h2></div></div></div><p>The <a id="id120" class="indexterm"/>following items are worth thinking about when implementing views:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does the view get the information it needs out of the store?</li><li class="listitem" style="list-style-type: disc">Which actions result in the view rendering?</li><li class="listitem" style="list-style-type: disc">Which actions does the view dispatch, in response to user interaction?</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary</h1></div></div></div><p>This chapter was about getting started with a Flux architecture by building some skeleton components. The goal being to think about the information architecture, without the distraction of other implementation issues. We could find ourselves in a situation where the API is already defined for us, or where the user experience is already in place. Either of these factors will influence the design of our stores, and ultimately the information we present to our users.</p><p>The stores we implemented were basic, loading data when the application starts and updating their state in response to an API call. We did, however, learn to ask the pertinent questions about our stores, such as the approach taken with parsing the new data to set as the store's state, and how this new state will affect other stores.</p><p>Then, we thought about the top-level features that form the core of our application. These features give a good indication of the stores that our architecture will need. Toward the end of the skeleton architecture phase, we want to walk through a few end-to-end scenarios to sanity-check our chosen information design. We looked at a few high-level checklist items to help ensure we didn't leave anything important out. In the following chapter, we'll take a deeper look at actions and how they're dispatched.</p></div></body></html>