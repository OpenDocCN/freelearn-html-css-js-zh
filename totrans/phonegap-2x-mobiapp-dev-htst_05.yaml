- en: Chapter 5. Talking to Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The media capabilities of our mobile devices are frankly amazing, especially
    when you consider where we were five, ten, fifteen years ago. The first mass-produced
    MP3 player was the *SaeHan/Eiger MPMan* ([http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan](http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan))
    introduced in 1997\. The device had 32 MB of storage, enough for roughly 6 to
    7 songs (assuming 1 MB/minute, 5m per song). While it may seem paltry by today's
    standards, it was a revolution and spawned a new way to listen to music.
  prefs: []
  type: TYPE_NORMAL
- en: Today's devices are now so much more, portable entertainment devices that can
    play games, video, and all sorts of audio. Being able to play sounds in your app
    is critical, and there are few apps that could make the case for having no sound
    whatsoever. Although a bit on the extreme side, perhaps, *TweetBot* is a classic
    example of an app that is enhanced by the sound it produces via the user's interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Today's devices can also record audio for a variety of reasons, whether it be
    for a reminder later, recording a speech or meeting, and more. There are a lot
    of apps that wouldn't require this functionality, but for a certain segment, it's
    important that you know how to record.
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a fairly simple app with one purpose: to store and play back
    the end user''s recordings, whatever they may be. They could be a short memo or
    a meeting. We''ll be using a lot of our existing framework, and there''s not a
    lot visually, but there is a lot going on underneath to support audio playback
    and recording.'
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you will be able to play and record audio. We'll be recording
    to the `WAV` format for iOS and the `AMR` format for Android. Other platforms
    support other formats, so if you are targeting a platform other than Android or
    iOS, be sure to double-check what formats are supported.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also be able to play audio; we'll support both `MP3` and `WAV` on Android
    and `WAV` on iOS (the primary reason we exclude MP3 for iOS here is a bug that
    causes `MP3` `format audios` to render with horrible quality and extremely loud
    volume).
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s another reason why this project is so great: we''re introducing gesture
    support. That''s right: *swipe-to-delete* and *long-press* will feature in this
    app as well.'
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be following the same task list as our previous projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface and the look and feel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing gesture support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the main view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do I need to get started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, go ahead and create your project following the same steps we've used
    in previous projects. You might also want to refer to the PhoneGap Media API documentation,
    as we'll be using it extensively. (refer to [http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media](http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media))
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface and the look and feel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This app will be *visually* simpler than any of our previous apps. We only need
    one view, and the look of that view has already largely been defined by our Android
    interfaces for the last two projects. That's right; the view is essentially a
    list of items, nothing fancy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some things we will change in our list of items. Essentially we will
    clean up the list by hiding the action icons (delete, share, and so on) and showing
    them only when we receive a gesture. We will also include *Play* and *Pause* buttons
    in the list item instead of any particular document image. After all, we don't
    have album art for recordings the user creates themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the mockup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this mockup is pretty similar to the Android file listings we've
    had in our previous projects. It is substantially different than the document-based
    list on iOS, but the preceding view is common enough that users will know how
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The icons in the list will not be document icons. Instead we'll use play and
    pause icons to show the state of the document. If it is currently being played,
    we'll show the pause icon, and if it is not being played, we'll show the play
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: The **Delete** button on the right is shown by using the horizontal swipe gesture;
    these buttons are otherwise invisible.
  prefs: []
  type: TYPE_NORMAL
- en: Where are the rest of our document actions, like rename or copy, you ask? That's
    a great question. They're still available, but only when a user holds their finger
    on the item for more than a second. At that point, the long-press swipe is recognized,
    and a small menu will pop up asking the user what they would like to do.
  prefs: []
  type: TYPE_NORMAL
- en: The **Record** button is intended to start a recording session. It will ask
    for the filename, and once entered, it will display another pop up indicating
    that it is recording. The user can stop recording by pressing the *stop* button
    on the pop up. We'll also display a microphone icon on this pop up to indicate
    to the user that the app is recording.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the mockup finished, let''s work on our graphical design in
    our graphics editor. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following are also some icons that we created as part of our mockup. You
    can find their images in the code files available for this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A microphone is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A play button can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And a pause button will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the background canvas and the navigation bar is the same as our
    previous project. All we really need for this task are the icons for the play
    state, the pause state, and the microphone. Everything else can be handled with
    CSS and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we've designed the user interface and defined the feel of the
    app. We've also designed the icons we'll be needing.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data model isn't terribly complex, but it is definitely a bit different
    from our previous projects. The document collection is fundamentally the same,
    so we won't cover that model, but the document itself is different. It must load
    and manage audio resources instead of regular files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our model is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| VoiceRecDocument |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| - fileEntry | Object |'
  prefs: []
  type: TYPE_TB
- en: '| - filename | String |'
  prefs: []
  type: TYPE_TB
- en: '| - fileType | String |'
  prefs: []
  type: TYPE_TB
- en: '| - completion | Function |'
  prefs: []
  type: TYPE_TB
- en: '| - failure | Function |'
  prefs: []
  type: TYPE_TB
- en: '| - state | String |'
  prefs: []
  type: TYPE_TB
- en: '| - title | String |'
  prefs: []
  type: TYPE_TB
- en: '| - media | Object |'
  prefs: []
  type: TYPE_TB
- en: '| - position | Number |'
  prefs: []
  type: TYPE_TB
- en: '| - duration | Number |'
  prefs: []
  type: TYPE_TB
- en: '| - playing | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| - recording | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| - paused | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| - positionTimer | Timer ID |'
  prefs: []
  type: TYPE_TB
- en: '| - durationTimer | Timer ID |'
  prefs: []
  type: TYPE_TB
- en: '| - getFileName() |   |'
  prefs: []
  type: TYPE_TB
- en: '| - setFileName() |'
  prefs: []
  type: TYPE_TB
- en: '| - initializeMediaObject() |'
  prefs: []
  type: TYPE_TB
- en: '| - isPlaying() |'
  prefs: []
  type: TYPE_TB
- en: '| - isRecording() |'
  prefs: []
  type: TYPE_TB
- en: '| - updatePosition() |'
  prefs: []
  type: TYPE_TB
- en: '| - updateDuration() |'
  prefs: []
  type: TYPE_TB
- en: '| - getPlaybackPosition() |'
  prefs: []
  type: TYPE_TB
- en: '| - setPlaybackPosition() |'
  prefs: []
  type: TYPE_TB
- en: '| - getDuration() |'
  prefs: []
  type: TYPE_TB
- en: '| - startPlayback() |'
  prefs: []
  type: TYPE_TB
- en: '| - pausePlayback() |'
  prefs: []
  type: TYPE_TB
- en: '| - releaseResources() |'
  prefs: []
  type: TYPE_TB
- en: '| - stopPlayback() |'
  prefs: []
  type: TYPE_TB
- en: '| - startRecording() |'
  prefs: []
  type: TYPE_TB
- en: '| - stopRecording() |'
  prefs: []
  type: TYPE_TB
- en: '| - dispatchFailure() |'
  prefs: []
  type: TYPE_TB
- en: '| - dispatchSuccess() |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s go over what each of these properties and methods should do:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fileEntry` property stores the file entry obtained from the File API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fileName` property stores the full path to the audio file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fileType` property stores the extension of the audio file (WAV, MP3, and
    so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `completion` and `failure` methods point to the `completion` and `failure`
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `title` property stores the name of the file (minus the path and extension).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `media` property will store the `Media` object from the `Media` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `position` property will indicate the current playback position in seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `duration` property will indicate the current recording duration or length
    of the file for playback (in seconds).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playing`, `recording`, `paused` are internal state methods used to track what
    is happening inside the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`positionTimer` and `durationTimer` are timer IDs used to update the position
    and duration properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get`/`setFileName` methods gets/sets the `fileName` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isPlaying`/`isRecording` methods return the respective property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updatePosition`/`updateDuration` are internal methods used to update the `position`
    and `duration` property during playback and recording.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`/`setPlaybackPosition` will get or set the current playback position.
    If setting, this will use the `seekTo()` method of the `Media` API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`/`pause`/`stopPlayback` will start, pause, or stop playback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`releaseResources` will allow the memory consumed by the media file to be released
    back to the device so that we don''t run out of memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`/`stopRecording` will start or stop recording.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatchFailure`/`Success` will call the `failure` or `completion` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we defined the model for `VoiceRecDocument` as well as the various
    interactions that go on internally.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've designed the model, let's go ahead and implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like in our previous projects, we''ll have two data models: the first one to
    deal with the collection of playable files, and the second one to deal with handling
    a specific playable file. The first, `VoiceRecDocumentCollection.js` is quite
    similar to our previous projects, and so we won''t go over it in this task. But
    the `VoiceRecDocument.js` file is very different, so go ahead and open it up (it''s
    in the `www/models` directory), so you can follow along.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As in our prior projects, the incoming parameters include a file entry obtained
    from the `File` API. We'll use this to determine the name of the audio file to
    play as well as its type. We're using some new functions, introduced in this version
    of the framework, to do work with the various portions that make up a file, namely,
    the path, the filename, and the file extension. Earlier, we use `PKUTIL.FILE.getFileExtensionPart()`
    to obtain the type of the file, whether it is an MP3, WAV, or something else.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define several properties that we will use to keep track of the various
    states and timers we need to use to properly manage our audio:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This property gives the title of the file, essentially the filename
    minus the path and extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media`: This property gives the `Media` object provided by PhoneGap. This
    property will be set whenever the program needs to play a sound or record something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`position`: This property gives the approximate position in the sound file
    for playback. It''s approximate because it is updated every few milliseconds with
    the position. We''ll discuss why in a bit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration`: This property gives the duration of the sound file (if playing),
    or the approximate duration of the recording (while, or after, recording).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playing`, `recording`, `paused`: These are simply Boolean variables intended
    to make it easy to determine what we''re doing. Are we playing the file, recording
    a file, and, if we''re playing, are we paused?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`durationTimer`, `positionTimer`: Timer IDs are used to track the intervals
    that get created whenever we load a media file or prepare one for recording. The
    `durationTimer` property updates the `duration` property, and the `positionTimer`
    property updates the position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code snippet handles getting and setting the filename. If we set
    a filename, we have to update the filename, type, and title.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is a very important method; we''ll be calling it at the top of
    most of our methods that work with playback or recording. This is to ensure that
    the `media` property is properly initialized. But it is also to ensure a few other
    details are correctly set up, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, we do these steps if and only if we don't already have a `media` object
    at hand. If we do, there's no need to initialize it again.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we check if we're running on Android. If we are, the `file://` prefix
    that comes out of the `File` API will confuse the `Media` APIs, and so we remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize the `media` property with a new `Media` object. This object
    requires the filename of the audio file, and two functions: one for when various
    audio functions complete successfully (generally only when playback or recording
    has stopped), and another for when something goes wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we also set up our two timers to update every quarter of a second.
    These times could be made faster or slower depending upon the granularity of updates
    you like, but `250` milliseconds seems to be enough.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Of course, like any good model, we need to provide methods to indicate our state.
    Hence, `isPlaying` and `isRecording` are used in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you recall, this function is called continuously during playback and recording.
    If playing, we ask the `Media` API what the current position is, but we have to
    supply a callback method in order to actually find out what the position is. This
    should usually be called nearly instantly, but we can't guarantee it, so this
    is why we have encapsulated obtaining the position somewhat. We'll define a `getPosition()`
    method later that just looks at the `position` property instead of having to do
    the callback every time we want to know where we are in the audio file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining the duration is even harder than obtaining the current position, mainly
    because it is quite possible that the `Media` API is streaming a file from the
    Internet rather than playing a local file. Therefore, the duration may take some
    time to obtain.
  prefs: []
  type: TYPE_NORMAL
- en: For as long as the duration timer is running, we'll ask the `Media` API if it
    has a duration for the file yet. If it doesn't, it'll return `-1`. If it does
    return a value greater than `-1`, we can stop the timer, since once we get a duration,
    it isn't likely to change.
  prefs: []
  type: TYPE_NORMAL
- en: There's no need to keep asking for the duration forever, especially if we can't
    determine the duration, so we use the negative numbers `-1` to `-20` of our `duration`
    property as a kind of timeout. We subtract one each time we fail to obtain a valid
    duration, and if we go below `-20`, we give up by stopping the timer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Getting the playback position is now simple, we just return our own `position`
    property. But sometimes we need to change the current playback position. To do
    this, we use the `seekTo()` method of the `Media` API to adjust the position.
    For whatever reason, the position used in the `seekTo()` method is in milliseconds,
    while the position we obtain constantly with our timer is in seconds, hence the
    multiplication by `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting playback is actually very simple: once we initialize the object, we
    just call the `play()` method on it. Playback will start as soon as possible.
    We also set our state properties to indicate that we are playing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once playing, we can also pause easily: we just have to call the `pause()`
    method. We update our state to reflect that we are paused as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since media files can consume a lot of memory, whenever they aren't in use,
    they should be released from memory. When we release the file, we also need to
    stop the timers, if running).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Stopping playback is quite simple: just call the `stop()` method instead of
    the `pause() method`. The difference between the two is that pausing playback
    allows a subsequent call to the `play() method` to resume immediately where we
    paused. Calling the `stop()` method will reset our position to zero, so the next
    `play()` method will start from the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Recording is similarly easy: we just call `startRecord()` or `stopRecord()`.
    There is no functionality for providing support for pausing in the middle of recording.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our `failure` method is pretty simple. If an error occurs, we'll log it, and
    then call the `failure` method given when creating this object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `success` function is even simpler: we just call the `completion()` method
    passed in when creating the object.'
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we created the data model for a specific audio file as well as
    the methods for initiating, pausing, and stopping playback, and those for initiating
    and stopping recording.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `completion` method is generally called at the end of playback, though it
    can be called for other reasons as well. In general, one would use this to clean
    up the media object, but if it is called when not expected, the result would be
    an abrupt stop of playback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important issue is that each platform supports only certain media
    files for playback and even different ones for recording. Here''s a short list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform | Plays | Records |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| iOS | WAV | WAV |'
  prefs: []
  type: TYPE_TB
- en: '| Android | MP3,WAV, 3GR | 3GR |'
  prefs: []
  type: TYPE_TB
- en: Implementing gesture support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gestures are a critical component of most mobile platforms these days, and users
    expect the apps they use to support them. A gesture can be fairly elaborate (say,
    drawing a shape, or using multiple fingers) or simple (just pressing an item for
    a certain time), but it is necessary that you get used to the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on the device using native code, gesture recognition is typically
    provided to us nearly for free. That is, the framework provided by the OS does
    the hard work of recognizing a gesture.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, with PhoneGap, we lose that for free part and have to implement
    our gestures on our own. That's where `ui-gestures.js` in the `www/framework`
    directory comes in. Go ahead and open it up so that we can walk through some of
    what it does.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code, starting at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is define a new namespace called `GESTURES`. Then we create
    a `SimpleGesture` class within it. `SimpleGesture` will be the basis for all single-finger
    gestures that we support, which includes a long press gesture, a horizontal swipe
    gesture, and a vertical swipe gesture.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot of properties that go into detecting gestures. Essentially, we
    have to keep track of where a touch first started, and then where that touch ended
    (`touchStartX`, `touchStartY`, `touchX`, `touchY`). We also need to know how far
    away that final touch was from when it started (`deltaX`, `deltaY`, `distance`).
    In order to prevent gestures from being recognized when someone holds their finger
    on the screen for a long time to slowly scroll through a list, we also track the
    duration of the touch. If it goes for too long, we refuse to detect a gesture
    and possibly interrupt the user performing some other operation.
  prefs: []
  type: TYPE_NORMAL
- en: We also keep track of whether or not the gesture has been recognized or cancelled.
    This is done with the `_cleared` property. If `_cleared` is `true`, the gesture
    has been recognized or cancelled and must not be recognized again (until the user
    lifts their finger from the screen).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first step, however, is to attach all our event listeners to a particular
    element. We attach six, namely, `touchstart`, `touchmove`, `touchend`, `mousedown`,
    `mousemove`, and `mouseup`. The first three are for WebKit browsers; the last
    three are for Windows Phone browsers. (Since gesture support is part of the YASMF
    framework, it needs to support more than just iOS and Android, hence the support
    here for WP7.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Part of what makes the `SimpleGesture` class so flexible is that it allows the
    `recognizeGesture()` method in the prior code snippet to be overridden using `attachGestureRecognizer()`
    . This also means that as part of the default implementation, we don't recognize
    any gesture at all yet. It's just a placeholder for the recognition engines later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When a suspected gesture is in progress, we call the `updateGesture()` method
    every `100` milliseconds. It will then helpfully calculate the distance from the
    initial touch and call the `recognizeGesture()` method, assuming that a gesture
    hasn't already been recognized yet.
  prefs: []
  type: TYPE_NORMAL
- en: Try to work out how we obtain the distance; you should recognize it from your
    geometry lessons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we recognize a gesture or determine that there is no gesture at all, there's
    really no reason to continue tracking the fingers and such, so the preceding method
    cancels out all the timers. However, it only prevents the default actions that
    would otherwise occur (such as clicks) if the gesture itself is physically recognized
    (not just cancelled). This is because as part of the recognition process, we can
    call this method once (cancelled) or twice (recognized). The second time through
    we'll cancel all the default actions. This means that attaching gestures to elements
    won't prevent the click events from firing as long as gesture isn't recognized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`eventStart()` is a fairly generic function. All it does is clear out some
    of our properties and then set others to the first touch point. It also starts
    the timer that calls the `updateGesture` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You may wonder why we have such similar handlers for `touchstart` and `mousedown`.
    This is because this part of the framework can technically live outside of the
    framework. That means it could recognize mouse events on a desktop computer as
    well. The other thing, however, to remember is that WP7 thinks touches are mouse
    events, not touch events, which is why we have to keep track of the difference.
    Note that we call the `eventStart()` method to do the stuff that is common to
    each methodology.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When the touch moves, `eventMove` will eventually be called by `touchMove()`
    or `mouseMove()`. Their code is pretty similar to `touchStart`/`mouseStart()`
    so we won't cover their code here. The main point is that as the touch moves around,
    the deltas are continually updated so that when `updateGesture()` is called, it
    can accurately determine the distance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the finger is lifted from the screen, `eventEnd()` will be called from
    either `touchEnd()` or `mouseUp()`. We call `clearEvent()` to reset all the tracking
    and timers involved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, at the end of the object creation process, we attach the events to
    the incoming element. At that point, any gesture applied to the element will be
    tracked, but not yet recognized. That''s what is covered in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Detecting a long press is probably the easiest kind of gesture. Essentially
    a long press is a touch that stays within a certain spot for a certain amount
    of time. Since humans aren't perfect, we have to allow some tolerance to how much
    a finger can wiggle during this time. Thus, we can't cancel the gesture the instant
    we detect some finger movement. That said, we should cancel the gesture if the
    finger movement goes outside of a specific radius (here we'll use 25 px), because
    the user may be doing a different gesture altogether (or none at all).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new `SimpleGesture` object. Then we're going to extend it
    using a poor man's inheritance. (It isn't really object-oriented inheritance,
    but it is good enough for what we need.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We then attach the `whatToDo`, `delayToRecognition`, and `delayToCancel` parameters
    to the new object. If the latter two aren't supplied, we give defaults of `3000`
    milliseconds and we'll ignore the gesture, and `1000` milliseconds to the recognition
    of a long press.
  prefs: []
  type: TYPE_NORMAL
- en: '`whatToDo` must be a function; we''ll call it if the gesture is recognized.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here's where we override the `SimpleGesture` object's *do-nothing* recognizer
    and attach our own. If the distance between the first position and current position
    of the touch is less than 25 px, we'll consider looking at the gesture. Then the
    duration of the gesture must be longer than the `delayToRecognition` (1000 milliseconds
    default) parameter, but not longer than the `delayToCancel` (3000 milliseconds
    default) parameter. If we fall in between, we'll clear the event and call `whatToDo()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, if the distance is more than 25 px, the person isn't doing
    a long press. They're doing something else, so we cancel the gesture entirely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Horizontal swipes are a little more complicated, but not by too much. First,
    we need to have a definition of horizontal. Again, the human finger is likely
    to wobble and wiggle a bit when making the gesture. We also need a minimum length;
    a movement horizontally of a couple pixels shouldn't be enough to trigger the
    gesture. Here we define a horizontal swipe as any swipe longer than 50 px and
    one that doesn't vary along the vertical axis by more than 25 px in either direction
    (50 px total).
  prefs: []
  type: TYPE_NORMAL
- en: We also do away with the `delayToRecognition` we used for long presses – that's
    where the length of the swipe comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Just like for our long press, we'll create the new gesture from a `SimpleGesture`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Then we attach the various parameters. The `radiusToRecognition` parameter is
    really the length of the swipe. Anything inside that radius won't be considered
    at all, but anything outside the radius is long enough to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The recognizer itself is pretty easy; the distance between the first and current
    point must be greater than the `radiusToRecognition` parameter, the duration must
    not be longer than the `delayToCancel` (3000 milliseconds by default) parameter,
    and the finger must not have gone up or down more than `25` px from that first
    touch. If all these conditions are met, we've had a horizontal swipe, and we clear
    the event and call `whatToDo()`.
  prefs: []
  type: TYPE_NORMAL
- en: The vertical swipe is essentially identical except that instead of using `deltaY`
    in the earlier code, it uses `deltaX`. A vertical swipe is only valid if the finger
    doesn't vary on the horizontal axis by more than `25` px on either side. Since
    they are so similar, we won't go over the code.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we've looked at how to recognize three simple gestures, namely,
    the long press gesture, the horizontal swipe gesture, and the vertical swipe gesture.
    In the next task, we'll implement the gesture recognizers in order to provide
    the various actions we can perform on a document, such as copying, renaming, or
    deleting them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the main view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our main view is pretty simple visually, but it is definitely complex underneath.
    Let''s take a look at how the final result will appear. First, this is how it
    looks when recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, this is how it looks after the recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we swipe on the newly recorded item, we get the **Delete** button as shown
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we long press on the recorded item, the following screen will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and open the `documentsView.js` file in `www/views` so that you can
    follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first go over the HTML for our view. The first portion (with class `viewBackground`)
    is like all the previous projects, so we''ll skip that portion and go straight
    to the template that shows each list item on the screen, seen in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This template is similar to, though not exactly like, the template we used in
    prior projects. What we've done is to change the `documentImage` class of the
    `div` element into the state of the document. If it shows a *play* icon, this
    particular item can be tapped to start playback. If it shows *pause*, it can be
    tapped to pause playback.
  prefs: []
  type: TYPE_NORMAL
- en: The **Delete** button is contained within the `documentActions` class of the
    `div` element (which is hidden by default). When tapped, it'll call `deleteDocument()`
    with the index of the item tapped.
  prefs: []
  type: TYPE_NORMAL
- en: All the other elements, such as the `title`, call `documentContainerTapped()`.
    This allows tapping on everything except the **Delete** button when visible to
    *start* or *pause* playback. If we didn't have these `onclick` handlers everywhere,
    some elements would not respond to touch like we would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go over how the view works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So far, pretty much the same as previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, however, we begin to diverge. We need to store both the current item that
    is playing and an index to that item. If we didn't, and we tapped two or more
    items, we'd end up with all of those items playing at once. Instead, we need to
    stop the previous item and start the tapped item so that only one audio file is
    playing at one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll skip over initializing the view, since it''s like all the other projects.
    Instead, we''ll look at the `documentContainterTapped()` method in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First, we check to see if the index (`idx`) is the same as the currently playing
    file. If it is, we need to pause (or resume) it. We don't want to release any
    resources or stop the file – otherwise when the item is tapped again, playback
    will start all over. We also set the image of the particular item to either the
    *play* or *pause* icon as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If the index (`idx`) is different, we first check to see if anything's currently
    playing (or paused). If it is, we release those resources so that we aren't keeping
    on to them when we're going to start playing a different item.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next we create a new `VoiceRecDocument` function and start the playback.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `mediaSuccess()` method, which is passed when creating the `VoiceRecDocument`
    function earlier, is generally called whenever the audio file is forcibly stopped
    (not paused) or stops on its own. Since we don't provide our own *stop* method
    visually, we can safely assume that the file has stopped playing on its own. When
    that is the case, we release the resources so that the file isn't taking up any
    memory when it isn't being played.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to skip to the `documentIterator()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This first portion is fairly self-explanatory. We assign the title of the item
    to the file name (minus the path and extension), we assign the indexes, and then
    also fill in the word `delete` whenever we come across it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Next, we delay for a short time to make sure the DOM has had time to process
    all the new items before we go on to working with them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element we created needs to have two gestures applied: a long press gesture
    and a horizontal swipe gesture. So first we look up the element using the preceding
    code snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create the long press gesture and attach it to the element. When the
    gesture is recognized, we'll call `longpressReceived()` with `o.data`. This data
    is what we set in the next line; it'll be the index of the item that has been
    long pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Assigning a horizontal swipe gesture is much the same, except we call `horizontalSwipeReceived`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When a long press is received, we''ll call the preceding method. We''ll create
    a confirmation pop up with three possible actions: `Copy`, `Rename`, and `Cancel`.
    We''ve modified the framework a little to support more than two buttons on a pop
    up, so don''t worry that they''ll be crowding anything out.'
  prefs: []
  type: TYPE_NORMAL
- en: If the user taps **Copy**, we'll call the `copyDocument()` method, and if they
    tap **Rename**, we'll call `renameDocument()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When a horizontal swipe is received, however, we do something different: we
    want to either display or hide the **Delete** button for that item. We can see
    if it is visible by checking the `style.display` property. We''ve taken the route
    of setting the `opacity` and `display` to show or hide it. This may not exactly
    match the native methodology (iOS slides this button in, for example), but it
    works well enough.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Recording is probably the most complicated and difficult thing to get right.
    After all, each platform has different recording types that they support, but
    they also have their own quirks (such as whether or not the file must already
    exist or not).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: First, we create the new document with the desired filename; we ask the user
    this in the `createDocument()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Next, we display a simple alert that has the microphone image in it and a **Stop**
    button. (That `_` at the end tells the alert to let the button fill the entire
    alert's width so that it is easier to tap.) When the user taps the **Stop** button,
    we'll stop recording and release all the resources. We also have to reload the
    documents so that the user can tap on it to play it back if they want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here we take advantage of one important fact of our pop-up system—they don't
    block our script execution. That means, we can be showing the alert and then continue
    to do other work, in this case, recording.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That was the easy part; getting ready to record is the hard part. We do this
    in `createNewDocument()`, which is called when the **REC** button is tapped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Like always, we ask the user to give us a new name for the document. Here we
    use `Memo` and the date.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we figure out what type of file we can record to based on the platform,
    and then pass that to `createDocument()`. Then, we define what should happen when
    `createDocument()` succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If we have an existing audio file playing, we stop it. We wouldn't want it to
    interfere with recording, after all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Then, for iOS, we create a new file with some junk text. For some reason, the
    `Media` API requires the file to exist prior to the recording, or it will fail
    to record. The other platforms don't have this restriction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: That said, the file gets created anyway, and can confuse Android. So we delete
    the file entirely before recording.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we only had to worry about one type of file in the list. But when
    renaming a file, or copying a file, we need to be sensitive to the type of file
    we are working with, because we need to duplicate the file extension on the new
    name. We do this by first getting the file extension in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Then, if we're renaming (or deleting) a file (we don't do this for a copy),
    we stop any playback of the file we're renaming (or deleting) prior to actually
    doing the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Next we construct the new filename with the same extension as the old file.
    From here on out, the code is identical to the prior projects, so we won't go
    over the rest of it. The important thing here is that you must preserve the file
    extension of any file when renaming or copying it.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a view that can list the available audio files, manage their playback,
    and also record new files. We also created a long press gesture and a horizontal
    swipe gesture for each item to implement the various file management operations
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've created a simple media recorder and playback app. It can manage all the
    files it creates (and even play a few it didn't). It also supports, for the first
    time, simple gestures, which are key to simplifying the complexity of the user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Can you take the HEAT? The Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are, of course, many ways you could enhance this project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pop up a simple media player view over the document view while the item is playing.
    Give the user a way to go backward and forward in the audio file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a separate view while recording that displays the duration of the recording
    in a prominent fashion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to get really creative, add this project to the `Filer` project.
    Allow a recording to be created as a document is written on the device, and then
    when that document is later viewed, play the recording so that the user can follow
    along.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
