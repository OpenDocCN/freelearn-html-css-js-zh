- en: Chapter 5. Talking to Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The media capabilities of our mobile devices are frankly amazing, especially
    when you consider where we were five, ten, fifteen years ago. The first mass-produced
    MP3 player was the *SaeHan/Eiger MPMan* ([http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan](http://en.wikipedia.org/wiki/Portable_media_player#SaeHan.2FEiger_MPMan))
    introduced in 1997\. The device had 32 MB of storage, enough for roughly 6 to
    7 songs (assuming 1 MB/minute, 5m per song). While it may seem paltry by today's
    standards, it was a revolution and spawned a new way to listen to music.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Today's devices are now so much more, portable entertainment devices that can
    play games, video, and all sorts of audio. Being able to play sounds in your app
    is critical, and there are few apps that could make the case for having no sound
    whatsoever. Although a bit on the extreme side, perhaps, *TweetBot* is a classic
    example of an app that is enhanced by the sound it produces via the user's interactions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Today's devices can also record audio for a variety of reasons, whether it be
    for a reminder later, recording a speech or meeting, and more. There are a lot
    of apps that wouldn't require this functionality, but for a certain segment, it's
    important that you know how to record.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a fairly simple app with one purpose: to store and play back
    the end user''s recordings, whatever they may be. They could be a short memo or
    a meeting. We''ll be using a lot of our existing framework, and there''s not a
    lot visually, but there is a lot going on underneath to support audio playback
    and recording.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you will be able to play and record audio. We'll be recording
    to the `WAV` format for iOS and the `AMR` format for Android. Other platforms
    support other formats, so if you are targeting a platform other than Android or
    iOS, be sure to double-check what formats are supported.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: You'll also be able to play audio; we'll support both `MP3` and `WAV` on Android
    and `WAV` on iOS (the primary reason we exclude MP3 for iOS here is a bug that
    causes `MP3` `format audios` to render with horrible quality and extremely loud
    volume).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s another reason why this project is so great: we''re introducing gesture
    support. That''s right: *swipe-to-delete* and *long-press* will feature in this
    app as well.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be following the same task list as our previous projects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface and the look and feel
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the data model
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the data model
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing gesture support
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the main view
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do I need to get started?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, go ahead and create your project following the same steps we've used
    in previous projects. You might also want to refer to the PhoneGap Media API documentation,
    as we'll be using it extensively. (refer to [http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media](http://docs.phonegap.com/en/edge/cordova_media_media.md.html#Media))
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface and the look and feel
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This app will be *visually* simpler than any of our previous apps. We only need
    one view, and the look of that view has already largely been defined by our Android
    interfaces for the last two projects. That's right; the view is essentially a
    list of items, nothing fancy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some things we will change in our list of items. Essentially we will
    clean up the list by hiding the action icons (delete, share, and so on) and showing
    them only when we receive a gesture. We will also include *Play* and *Pause* buttons
    in the list item instead of any particular document image. After all, we don't
    have album art for recordings the user creates themselves.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the mockup:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: As you can see, this mockup is pretty similar to the Android file listings we've
    had in our previous projects. It is substantially different than the document-based
    list on iOS, but the preceding view is common enough that users will know how
    to use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The icons in the list will not be document icons. Instead we'll use play and
    pause icons to show the state of the document. If it is currently being played,
    we'll show the pause icon, and if it is not being played, we'll show the play
    icon.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The **Delete** button on the right is shown by using the horizontal swipe gesture;
    these buttons are otherwise invisible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Where are the rest of our document actions, like rename or copy, you ask? That's
    a great question. They're still available, but only when a user holds their finger
    on the item for more than a second. At that point, the long-press swipe is recognized,
    and a small menu will pop up asking the user what they would like to do.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The **Record** button is intended to start a recording session. It will ask
    for the filename, and once entered, it will display another pop up indicating
    that it is recording. The user can stop recording by pressing the *stop* button
    on the pop up. We'll also display a microphone icon on this pop up to indicate
    to the user that the app is recording.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the mockup finished, let''s work on our graphical design in
    our graphics editor. The result will be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: The following are also some icons that we created as part of our mockup. You
    can find their images in the code files available for this project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'A microphone is shown as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'A play button can be seen as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'And a pause button will be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_05_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Notice that the background canvas and the navigation bar is the same as our
    previous project. All we really need for this task are the icons for the play
    state, the pause state, and the microphone. Everything else can be handled with
    CSS and HTML.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we've designed the user interface and defined the feel of the
    app. We've also designed the icons we'll be needing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Designing the data model
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data model isn't terribly complex, but it is definitely a bit different
    from our previous projects. The document collection is fundamentally the same,
    so we won't cover that model, but the document itself is different. It must load
    and manage audio resources instead of regular files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our model is defined as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '| VoiceRecDocument |   |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| - fileEntry | Object |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| - filename | String |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| - fileType | String |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| - completion | Function |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| - failure | Function |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| - state | String |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| - title | String |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| - media | Object |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| - position | Number |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| - duration | Number |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| - playing | Boolean |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| - recording | Boolean |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| - paused | Boolean |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| - positionTimer | Timer ID |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| - durationTimer | Timer ID |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| - getFileName() |   |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| - setFileName() |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| - initializeMediaObject() |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| - isPlaying() |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| - isRecording() |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| - updatePosition() |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| - updateDuration() |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| - getPlaybackPosition() |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| - setPlaybackPosition() |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| - getDuration() |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| - startPlayback() |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| - pausePlayback() |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| - releaseResources() |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| - stopPlayback() |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| - startRecording() |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| - stopRecording() |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| - dispatchFailure() |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| - dispatchSuccess() |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: 'Let''s go over what each of these properties and methods should do:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The `fileEntry` property stores the file entry obtained from the File API.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fileName` property stores the full path to the audio file.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fileType` property stores the extension of the audio file (WAV, MP3, and
    so on).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `completion` and `failure` methods point to the `completion` and `failure`
    functions.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `title` property stores the name of the file (minus the path and extension).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `media` property will store the `Media` object from the `Media` API.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `position` property will indicate the current playback position in seconds.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `duration` property will indicate the current recording duration or length
    of the file for playback (in seconds).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playing`, `recording`, `paused` are internal state methods used to track what
    is happening inside the object.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`positionTimer` and `durationTimer` are timer IDs used to update the position
    and duration properties.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get`/`setFileName` methods gets/sets the `fileName` property.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isPlaying`/`isRecording` methods return the respective property.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updatePosition`/`updateDuration` are internal methods used to update the `position`
    and `duration` property during playback and recording.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`/`setPlaybackPosition` will get or set the current playback position.
    If setting, this will use the `seekTo()` method of the `Media` API.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`/`pause`/`stopPlayback` will start, pause, or stop playback.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`releaseResources` will allow the memory consumed by the media file to be released
    back to the device so that we don''t run out of memory.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`/`stopRecording` will start or stop recording.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatchFailure`/`Success` will call the `failure` or `completion` method.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What did we do?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we defined the model for `VoiceRecDocument` as well as the various
    interactions that go on internally.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the data model
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've designed the model, let's go ahead and implement it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like in our previous projects, we''ll have two data models: the first one to
    deal with the collection of playable files, and the second one to deal with handling
    a specific playable file. The first, `VoiceRecDocumentCollection.js` is quite
    similar to our previous projects, and so we won''t go over it in this task. But
    the `VoiceRecDocument.js` file is very different, so go ahead and open it up (it''s
    in the `www/models` directory), so you can follow along.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start using the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As in our prior projects, the incoming parameters include a file entry obtained
    from the `File` API. We'll use this to determine the name of the audio file to
    play as well as its type. We're using some new functions, introduced in this version
    of the framework, to do work with the various portions that make up a file, namely,
    the path, the filename, and the file extension. Earlier, we use `PKUTIL.FILE.getFileExtensionPart()`
    to obtain the type of the file, whether it is an MP3, WAV, or something else.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here we define several properties that we will use to keep track of the various
    states and timers we need to use to properly manage our audio:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This property gives the title of the file, essentially the filename
    minus the path and extension.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media`: This property gives the `Media` object provided by PhoneGap. This
    property will be set whenever the program needs to play a sound or record something.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`position`: This property gives the approximate position in the sound file
    for playback. It''s approximate because it is updated every few milliseconds with
    the position. We''ll discuss why in a bit.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration`: This property gives the duration of the sound file (if playing),
    or the approximate duration of the recording (while, or after, recording).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playing`, `recording`, `paused`: These are simply Boolean variables intended
    to make it easy to determine what we''re doing. Are we playing the file, recording
    a file, and, if we''re playing, are we paused?'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`durationTimer`, `positionTimer`: Timer IDs are used to track the intervals
    that get created whenever we load a media file or prepare one for recording. The
    `durationTimer` property updates the `duration` property, and the `positionTimer`
    property updates the position.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippet handles getting and setting the filename. If we set
    a filename, we have to update the filename, type, and title.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method is a very important method; we''ll be calling it at the top of
    most of our methods that work with playback or recording. This is to ensure that
    the `media` property is properly initialized. But it is also to ensure a few other
    details are correctly set up, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we do these steps if and only if we don't already have a `media` object
    at hand. If we do, there's no need to initialize it again.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we check if we're running on Android. If we are, the `file://` prefix
    that comes out of the `File` API will confuse the `Media` APIs, and so we remove
    it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we initialize the `media` property with a new `Media` object. This object
    requires the filename of the audio file, and two functions: one for when various
    audio functions complete successfully (generally only when playback or recording
    has stopped), and another for when something goes wrong.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, we also set up our two timers to update every quarter of a second.
    These times could be made faster or slower depending upon the granularity of updates
    you like, but `250` milliseconds seems to be enough.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, like any good model, we need to provide methods to indicate our state.
    Hence, `isPlaying` and `isRecording` are used in the preceding code snippet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you recall, this function is called continuously during playback and recording.
    If playing, we ask the `Media` API what the current position is, but we have to
    supply a callback method in order to actually find out what the position is. This
    should usually be called nearly instantly, but we can't guarantee it, so this
    is why we have encapsulated obtaining the position somewhat. We'll define a `getPosition()`
    method later that just looks at the `position` property instead of having to do
    the callback every time we want to know where we are in the audio file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obtaining the duration is even harder than obtaining the current position, mainly
    because it is quite possible that the `Media` API is streaming a file from the
    Internet rather than playing a local file. Therefore, the duration may take some
    time to obtain.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: For as long as the duration timer is running, we'll ask the `Media` API if it
    has a duration for the file yet. If it doesn't, it'll return `-1`. If it does
    return a value greater than `-1`, we can stop the timer, since once we get a duration,
    it isn't likely to change.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: There's no need to keep asking for the duration forever, especially if we can't
    determine the duration, so we use the negative numbers `-1` to `-20` of our `duration`
    property as a kind of timeout. We subtract one each time we fail to obtain a valid
    duration, and if we go below `-20`, we give up by stopping the timer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Getting the playback position is now simple, we just return our own `position`
    property. But sometimes we need to change the current playback position. To do
    this, we use the `seekTo()` method of the `Media` API to adjust the position.
    For whatever reason, the position used in the `seekTo()` method is in milliseconds,
    while the position we obtain constantly with our timer is in seconds, hence the
    multiplication by `1000`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Starting playback is actually very simple: once we initialize the object, we
    just call the `play()` method on it. Playback will start as soon as possible.
    We also set our state properties to indicate that we are playing.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Once playing, we can also pause easily: we just have to call the `pause()`
    method. We update our state to reflect that we are paused as well.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since media files can consume a lot of memory, whenever they aren't in use,
    they should be released from memory. When we release the file, we also need to
    stop the timers, if running).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Stopping playback is quite simple: just call the `stop()` method instead of
    the `pause() method`. The difference between the two is that pausing playback
    allows a subsequent call to the `play() method` to resume immediately where we
    paused. Calling the `stop()` method will reset our position to zero, so the next
    `play()` method will start from the beginning.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Recording is similarly easy: we just call `startRecord()` or `stopRecord()`.
    There is no functionality for providing support for pausing in the middle of recording.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `failure` method is pretty simple. If an error occurs, we'll log it, and
    then call the `failure` method given when creating this object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `success` function is even simpler: we just call the `completion()` method
    passed in when creating the object.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we created the data model for a specific audio file as well as
    the methods for initiating, pausing, and stopping playback, and those for initiating
    and stopping recording.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `completion` method is generally called at the end of playback, though it
    can be called for other reasons as well. In general, one would use this to clean
    up the media object, but if it is called when not expected, the result would be
    an abrupt stop of playback.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important issue is that each platform supports only certain media
    files for playback and even different ones for recording. Here''s a short list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform | Plays | Records |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| iOS | WAV | WAV |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| Android | MP3,WAV, 3GR | 3GR |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: Implementing gesture support
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gestures are a critical component of most mobile platforms these days, and users
    expect the apps they use to support them. A gesture can be fairly elaborate (say,
    drawing a shape, or using multiple fingers) or simple (just pressing an item for
    a certain time), but it is necessary that you get used to the idea.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on the device using native code, gesture recognition is typically
    provided to us nearly for free. That is, the framework provided by the OS does
    the hard work of recognizing a gesture.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, with PhoneGap, we lose that for free part and have to implement
    our gestures on our own. That's where `ui-gestures.js` in the `www/framework`
    directory comes in. Go ahead and open it up so that we can walk through some of
    what it does.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code, starting at the top:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first thing we do is define a new namespace called `GESTURES`. Then we create
    a `SimpleGesture` class within it. `SimpleGesture` will be the basis for all single-finger
    gestures that we support, which includes a long press gesture, a horizontal swipe
    gesture, and a vertical swipe gesture.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's a lot of properties that go into detecting gestures. Essentially, we
    have to keep track of where a touch first started, and then where that touch ended
    (`touchStartX`, `touchStartY`, `touchX`, `touchY`). We also need to know how far
    away that final touch was from when it started (`deltaX`, `deltaY`, `distance`).
    In order to prevent gestures from being recognized when someone holds their finger
    on the screen for a long time to slowly scroll through a list, we also track the
    duration of the touch. If it goes for too long, we refuse to detect a gesture
    and possibly interrupt the user performing some other operation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We also keep track of whether or not the gesture has been recognized or cancelled.
    This is done with the `_cleared` property. If `_cleared` is `true`, the gesture
    has been recognized or cancelled and must not be recognized again (until the user
    lifts their finger from the screen).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first step, however, is to attach all our event listeners to a particular
    element. We attach six, namely, `touchstart`, `touchmove`, `touchend`, `mousedown`,
    `mousemove`, and `mouseup`. The first three are for WebKit browsers; the last
    three are for Windows Phone browsers. (Since gesture support is part of the YASMF
    framework, it needs to support more than just iOS and Android, hence the support
    here for WP7.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Part of what makes the `SimpleGesture` class so flexible is that it allows the
    `recognizeGesture()` method in the prior code snippet to be overridden using `attachGestureRecognizer()`
    . This also means that as part of the default implementation, we don't recognize
    any gesture at all yet. It's just a placeholder for the recognition engines later
    on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When a suspected gesture is in progress, we call the `updateGesture()` method
    every `100` milliseconds. It will then helpfully calculate the distance from the
    initial touch and call the `recognizeGesture()` method, assuming that a gesture
    hasn't already been recognized yet.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Try to work out how we obtain the distance; you should recognize it from your
    geometry lessons.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we recognize a gesture or determine that there is no gesture at all, there's
    really no reason to continue tracking the fingers and such, so the preceding method
    cancels out all the timers. However, it only prevents the default actions that
    would otherwise occur (such as clicks) if the gesture itself is physically recognized
    (not just cancelled). This is because as part of the recognition process, we can
    call this method once (cancelled) or twice (recognized). The second time through
    we'll cancel all the default actions. This means that attaching gestures to elements
    won't prevent the click events from firing as long as gesture isn't recognized.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`eventStart()` is a fairly generic function. All it does is clear out some
    of our properties and then set others to the first touch point. It also starts
    the timer that calls the `updateGesture` method.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You may wonder why we have such similar handlers for `touchstart` and `mousedown`.
    This is because this part of the framework can technically live outside of the
    framework. That means it could recognize mouse events on a desktop computer as
    well. The other thing, however, to remember is that WP7 thinks touches are mouse
    events, not touch events, which is why we have to keep track of the difference.
    Note that we call the `eventStart()` method to do the stuff that is common to
    each methodology.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the touch moves, `eventMove` will eventually be called by `touchMove()`
    or `mouseMove()`. Their code is pretty similar to `touchStart`/`mouseStart()`
    so we won't cover their code here. The main point is that as the touch moves around,
    the deltas are continually updated so that when `updateGesture()` is called, it
    can accurately determine the distance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the finger is lifted from the screen, `eventEnd()` will be called from
    either `touchEnd()` or `mouseUp()`. We call `clearEvent()` to reset all the tracking
    and timers involved.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, at the end of the object creation process, we attach the events to
    the incoming element. At that point, any gesture applied to the element will be
    tracked, but not yet recognized. That''s what is covered in the next snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Detecting a long press is probably the easiest kind of gesture. Essentially
    a long press is a touch that stays within a certain spot for a certain amount
    of time. Since humans aren't perfect, we have to allow some tolerance to how much
    a finger can wiggle during this time. Thus, we can't cancel the gesture the instant
    we detect some finger movement. That said, we should cancel the gesture if the
    finger movement goes outside of a specific radius (here we'll use 25 px), because
    the user may be doing a different gesture altogether (or none at all).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we create a new `SimpleGesture` object. Then we're going to extend it
    using a poor man's inheritance. (It isn't really object-oriented inheritance,
    but it is good enough for what we need.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We then attach the `whatToDo`, `delayToRecognition`, and `delayToCancel` parameters
    to the new object. If the latter two aren't supplied, we give defaults of `3000`
    milliseconds and we'll ignore the gesture, and `1000` milliseconds to the recognition
    of a long press.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`whatToDo` must be a function; we''ll call it if the gesture is recognized.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here's where we override the `SimpleGesture` object's *do-nothing* recognizer
    and attach our own. If the distance between the first position and current position
    of the touch is less than 25 px, we'll consider looking at the gesture. Then the
    duration of the gesture must be longer than the `delayToRecognition` (1000 milliseconds
    default) parameter, but not longer than the `delayToCancel` (3000 milliseconds
    default) parameter. If we fall in between, we'll clear the event and call `whatToDo()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: On the other hand, if the distance is more than 25 px, the person isn't doing
    a long press. They're doing something else, so we cancel the gesture entirely.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Horizontal swipes are a little more complicated, but not by too much. First,
    we need to have a definition of horizontal. Again, the human finger is likely
    to wobble and wiggle a bit when making the gesture. We also need a minimum length;
    a movement horizontally of a couple pixels shouldn't be enough to trigger the
    gesture. Here we define a horizontal swipe as any swipe longer than 50 px and
    one that doesn't vary along the vertical axis by more than 25 px in either direction
    (50 px total).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We also do away with the `delayToRecognition` we used for long presses – that's
    where the length of the swipe comes into play.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just like for our long press, we'll create the new gesture from a `SimpleGesture`
    object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then we attach the various parameters. The `radiusToRecognition` parameter is
    really the length of the swipe. Anything inside that radius won't be considered
    at all, but anything outside the radius is long enough to be considered.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The recognizer itself is pretty easy; the distance between the first and current
    point must be greater than the `radiusToRecognition` parameter, the duration must
    not be longer than the `delayToCancel` (3000 milliseconds by default) parameter,
    and the finger must not have gone up or down more than `25` px from that first
    touch. If all these conditions are met, we've had a horizontal swipe, and we clear
    the event and call `whatToDo()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The vertical swipe is essentially identical except that instead of using `deltaY`
    in the earlier code, it uses `deltaX`. A vertical swipe is only valid if the finger
    doesn't vary on the horizontal axis by more than `25` px on either side. Since
    they are so similar, we won't go over the code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we've looked at how to recognize three simple gestures, namely,
    the long press gesture, the horizontal swipe gesture, and the vertical swipe gesture.
    In the next task, we'll implement the gesture recognizers in order to provide
    the various actions we can perform on a document, such as copying, renaming, or
    deleting them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the main view
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our main view is pretty simple visually, but it is definitely complex underneath.
    Let''s take a look at how the final result will appear. First, this is how it
    looks when recording:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_06.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: 'Next, this is how it looks after the recording:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_07.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'If we swipe on the newly recorded item, we get the **Delete** button as shown
    in the next screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_08.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'If we long press on the recorded item, the following screen will appear:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the main view](img/9403_05_09.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and open the `documentsView.js` file in `www/views` so that you can
    follow along.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first go over the HTML for our view. The first portion (with class `viewBackground`)
    is like all the previous projects, so we''ll skip that portion and go straight
    to the template that shows each list item on the screen, seen in the following
    code block:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This template is similar to, though not exactly like, the template we used in
    prior projects. What we've done is to change the `documentImage` class of the
    `div` element into the state of the document. If it shows a *play* icon, this
    particular item can be tapped to start playback. If it shows *pause*, it can be
    tapped to pause playback.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The **Delete** button is contained within the `documentActions` class of the
    `div` element (which is hidden by default). When tapped, it'll call `deleteDocument()`
    with the index of the item tapped.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: All the other elements, such as the `title`, call `documentContainerTapped()`.
    This allows tapping on everything except the **Delete** button when visible to
    *start* or *pause* playback. If we didn't have these `onclick` handlers everywhere,
    some elements would not respond to touch like we would expect.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go over how the view works:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So far, pretty much the same as previous projects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, however, we begin to diverge. We need to store both the current item that
    is playing and an index to that item. If we didn't, and we tapped two or more
    items, we'd end up with all of those items playing at once. Instead, we need to
    stop the previous item and start the tapped item so that only one audio file is
    playing at one time.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll skip over initializing the view, since it''s like all the other projects.
    Instead, we''ll look at the `documentContainterTapped()` method in the following
    code snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, we check to see if the index (`idx`) is the same as the currently playing
    file. If it is, we need to pause (or resume) it. We don't want to release any
    resources or stop the file – otherwise when the item is tapped again, playback
    will start all over. We also set the image of the particular item to either the
    *play* or *pause* icon as appropriate.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the index (`idx`) is different, we first check to see if anything's currently
    playing (or paused). If it is, we release those resources so that we aren't keeping
    on to them when we're going to start playing a different item.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next we create a new `VoiceRecDocument` function and start the playback.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `mediaSuccess()` method, which is passed when creating the `VoiceRecDocument`
    function earlier, is generally called whenever the audio file is forcibly stopped
    (not paused) or stops on its own. Since we don't provide our own *stop* method
    visually, we can safely assume that the file has stopped playing on its own. When
    that is the case, we release the resources so that the file isn't taking up any
    memory when it isn't being played.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to skip to the `documentIterator()` method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This first portion is fairly self-explanatory. We assign the title of the item
    to the file name (minus the path and extension), we assign the indexes, and then
    also fill in the word `delete` whenever we come across it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, we delay for a short time to make sure the DOM has had time to process
    all the new items before we go on to working with them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each element we created needs to have two gestures applied: a long press gesture
    and a horizontal swipe gesture. So first we look up the element using the preceding
    code snippet.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we create the long press gesture and attach it to the element. When the
    gesture is recognized, we'll call `longpressReceived()` with `o.data`. This data
    is what we set in the next line; it'll be the index of the item that has been
    long pressed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Assigning a horizontal swipe gesture is much the same, except we call `horizontalSwipeReceived`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When a long press is received, we''ll call the preceding method. We''ll create
    a confirmation pop up with three possible actions: `Copy`, `Rename`, and `Cancel`.
    We''ve modified the framework a little to support more than two buttons on a pop
    up, so don''t worry that they''ll be crowding anything out.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: If the user taps **Copy**, we'll call the `copyDocument()` method, and if they
    tap **Rename**, we'll call `renameDocument()`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When a horizontal swipe is received, however, we do something different: we
    want to either display or hide the **Delete** button for that item. We can see
    if it is visible by checking the `style.display` property. We''ve taken the route
    of setting the `opacity` and `display` to show or hide it. This may not exactly
    match the native methodology (iOS slides this button in, for example), but it
    works well enough.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Recording is probably the most complicated and difficult thing to get right.
    After all, each platform has different recording types that they support, but
    they also have their own quirks (such as whether or not the file must already
    exist or not).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, we create the new document with the desired filename; we ask the user
    this in the `createDocument()` method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, we display a simple alert that has the microphone image in it and a **Stop**
    button. (That `_` at the end tells the alert to let the button fill the entire
    alert's width so that it is easier to tap.) When the user taps the **Stop** button,
    we'll stop recording and release all the resources. We also have to reload the
    documents so that the user can tap on it to play it back if they want.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here we take advantage of one important fact of our pop-up system—they don't
    block our script execution. That means, we can be showing the alert and then continue
    to do other work, in this case, recording.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That was the easy part; getting ready to record is the hard part. We do this
    in `createNewDocument()`, which is called when the **REC** button is tapped.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Like always, we ask the user to give us a new name for the document. Here we
    use `Memo` and the date.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First, we figure out what type of file we can record to based on the platform,
    and then pass that to `createDocument()`. Then, we define what should happen when
    `createDocument()` succeeds:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If we have an existing audio file playing, we stop it. We wouldn't want it to
    interfere with recording, after all.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then, for iOS, we create a new file with some junk text. For some reason, the
    `Media` API requires the file to exist prior to the recording, or it will fail
    to record. The other platforms don't have this restriction.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That said, the file gets created anyway, and can confuse Android. So we delete
    the file entirely before recording.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Previously, we only had to worry about one type of file in the list. But when
    renaming a file, or copying a file, we need to be sensitive to the type of file
    we are working with, because we need to duplicate the file extension on the new
    name. We do this by first getting the file extension in the preceding code snippet.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Then, if we're renaming (or deleting) a file (we don't do this for a copy),
    we stop any playback of the file we're renaming (or deleting) prior to actually
    doing the operation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Next we construct the new filename with the same extension as the old file.
    From here on out, the code is identical to the prior projects, so we won't go
    over the rest of it. The important thing here is that you must preserve the file
    extension of any file when renaming or copying it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a view that can list the available audio files, manage their playback,
    and also record new files. We also created a long press gesture and a horizontal
    swipe gesture for each item to implement the various file management operations
    necessary.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've created a simple media recorder and playback app. It can manage all the
    files it creates (and even play a few it didn't). It also supports, for the first
    time, simple gestures, which are key to simplifying the complexity of the user
    interface.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的媒体录制和回放应用程序。它可以管理它创建的所有文件（甚至播放它没有创建的一些文件）。它还首次支持简单的手势，这对于简化用户界面的复杂性至关重要。
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受热度吗？热手挑战
- en: 'There are, of course, many ways you could enhance this project, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以以许多方式增强这个项目，如下所示：
- en: Pop up a simple media player view over the document view while the item is playing.
    Give the user a way to go backward and forward in the audio file.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在播放项目时，在文档视图上弹出简单的媒体播放器视图。为用户提供一种在音频文件中向前和向后跳转的方法。
- en: Create a separate view while recording that displays the duration of the recording
    in a prominent fashion.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在录制时创建一个单独的视图，以突出显示的方式显示录制时长。
- en: If you want to get really creative, add this project to the `Filer` project.
    Allow a recording to be created as a document is written on the device, and then
    when that document is later viewed, play the recording so that the user can follow
    along.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想真正发挥创意，将这个项目添加到`Filer`项目中。允许在设备上编写文档时创建录音，然后在稍后查看该文档时播放录音，以便用户可以跟随。
