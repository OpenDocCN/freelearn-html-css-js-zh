- en: Chapter 3. Model Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keeping models in sync with other objects such as views can be challenging,
    and if it is not done correctly, it can lead to messy code. In this chapter, we
    will explore how to deal with data synchronization to make data binding easier.
    But, what is data binding? Wikipedia defines data binding as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Data binding is the process that establishes a connection between the application
    UI (User Interface) and business logic. If the settings and notifications are
    correctly set, the data reflects changes when made. It can also mean that when
    the UI is changed, the underlying data will reflect that change.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A common issue with model binding is how to deal with complex model structures
    that include other embedded objects or lists; in this chapter, we will define
    a strategy to deal with these scenarios. A missing feature in Backbone is two-way
    binding; in the next sections, we will see how to implement this without a headache.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the chapter describing how to bind model data with views manually
    to see how Backbone works; after that, we can use Backbone.Stickit to make it
    much easier. After learning how to sync model data and views, we will explore
    how to perform validations on the models and how to display error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Manual binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make it simple, imagine that we have a form with a simple layout: name,
    phone, and an email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the snippet, we have two views that will be rendered at the same time. When
    the user clicks on the **Save** button in the form, the preview template will
    be updated with the model data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will render the contents of the `contact` model in the form and in
    the preview. When the **Save now** button is clicked, nothing happens because
    it hasn''t yet been programmed, so let''s save the changes in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what's happening here. In `FormView`, we're updating the model with
    the data in the form inputs; this action syncs the form data with the model, triggering
    a `'change'` event on the Model. Because `ContactPreview` is listening for the
    change, the event will update itself with the data in the model.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone is not built with *automagic* view-model bindings, so it's the developer's
    responsibility to implement it. Fortunately, there are some Backbone plugins that
    can help us to make it less painful; one of these is `Backbone.Stickit`, developed
    by the *New York Times*.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Angular.js` has been popularized as two-way data binding in the frontend;
    the idea behind two-way data binding is to keep views and models in sync. When
    you make a change in an input field the view the model should be updated immediately,
    and if you change a property in the model the view should show the current value
    immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way binding](img/B01962_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 Two-way data binding with Backbone
  prefs: []
  type: TYPE_NORMAL
- en: Backbone does not provide a mechanism to achieve this easily; however, we can
    do it using the event system that Backbone models provide. Figure 3.1 shows how
    you can make an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '`Backbone.View` listens for `keyup` and `change` events on input controls at
    the DOM; when a change is triggered from the DOM, `Backbone.View` can extract
    the new value from the input and set the Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call the `set()` method on `Backbone.View`, at least two events are
    triggered: `change` and `change:<fieldname>`.We can use these events to update
    the necessary views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the output of the preceding snippet in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way binding](img/B01962_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 Output of change events
  prefs: []
  type: TYPE_NORMAL
- en: We can use these events to update the view when necessary. Indeed, the code
    we already have is enough to keep the `ContactForm` and `ContactPreview` views
    in sync.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`ContactPreview` is listening for every change in the model and re-rendering
    the view when something changes. However, re-rendering the whole view each time
    is a heavy process; it would be better if we made the changes only when necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to identify each field with an identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the change event handler will update only the contents of the identified
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Despite the result of the two-way data binding it should be used with caution;
    some people don't think that two-way data binding is a good idea and consider
    it as an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following URLs for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why you should not use AngularJS: [http://bit.ly/1Mue1kC](http://bit.ly/1Mue1kC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AngularJS Antipatterns and Pitfalls: [http://bit.ly/1kTHKqS](http://bit.ly/1kTHKqS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s wrong with Angular 1: [http://bit.ly/1N9wHok](http://bit.ly/1N9wHok)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding with plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see in the previous section, Backbone does not provide an easy mechanism
    to sync your models and the views that use them. Some plugins for Backbone have
    been developed to minimize this issue; one of them is `Backbone.Stickit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want an easy and yet powerful way to bind DOM nodes and Backbone models,
    `Backbone.Stickit` will do a great job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code example shows how it looks; please consult the project documentation
    to learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Binding embedded data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common issues with Backbone is how to deal with complex model
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It could be easy to render a read-only view for this model data; however, the
    real challenge is how to bind form actions with embedded arrays. In Backbone,
    it is difficult to use the event system on array objects; if you push a new item
    in the list, no event will be triggered. This makes it difficult to keep model
    data in sync with the a view that edits its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Binding an embedded list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that our Contacts App will now allow us to add more than one phone
    and email. We will need to change the edit form view to add support for adding,
    removing, and modifying items on the array of phones and emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding an embedded list](img/B01962_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3\. Contact form layout with phone and email lists
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 shows the result of adding a **New** button to allow the user to
    dynamically add the number of phones and emails he/she wants. Each item in the
    list should include a **Delete** button too to allow the user to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the phone and email lists and sync the forms with the model, we will
    follow a different strategy; Figure 3.4 illustrates how our strategy will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding an embedded list](img/B01962_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 Embedded array rendering strategy
  prefs: []
  type: TYPE_NORMAL
- en: We will create two new Backbone collections, one for phones and another for
    emails. With the data in the `Contact` model we can initialize these collections
    and render them as regular `CollectionView`.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, `CollectionView` objects take care of the
    changes in the collection that it renders, so that we can modify the collection
    object and the view will behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on the **Save** button, we can serialize the content of
    these collections and update the model before we call the `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each item for phones and emails will have a very similar template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This template will be used as a `ModelView` for a `CollectionView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The contact form now should include two regions for `PhoneListView` and `EmailListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`ContactForm` should be changed to support regions; we will extend from `Layout`
    instead of `ModelView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need two new models: `Phone` and `Email`. Because both models are very
    similar, I will only show `Phone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And collection that uses the `Phone` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the necessary objects to render the form, let''s put them
    all together in the controller. First, we need to create the collection instances
    from the model data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the collections in place, we can build `CollectionView`s properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `phonesView` and `emailsView` can be rendered in the regions exposed in
    the `contactForm` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks on the **New** button, a new item in a proper list should
    be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContactForm` knows nothing about the collections that we are using in
    the controller, so they can''t add an item in the collection directly; the controller
    should listen for events in the `contactForm` and update the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks on the **delete** link in an item of the list, the item
    should be removed from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did with `add`, the controller will take care of managing the collection
    data by attaching an event listener in the list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippets, adding items to the list (and removing
    them) is pretty simple; we just need to update the underlying collection and the
    views will be updated automatically. We did a great job with `CollectionViews`
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save the phone and email attributes in the model, we need to extract the
    data stored in the collections and replace the existing data in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the collections are not in sync with the forms and you will end up
    with empty emails and phones. To fix this, we need to bind the models with the
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you click the **Save** button, the data about the phones and emails
    will be stored as expected.
  prefs: []
  type: TYPE_NORMAL
- en: This way of binding embedded arrays in views through intermediate collections
    simplifies the way you work with lists and will make your code a lot simpler and
    more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Validating model data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, on frontend applications, the inputs are validated with UI plugins
    such as jQuery Validation, which focuses on the user interface. In other words,
    the data is validated directly on the DOM. However, on bigger applications that
    would not be the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: Validations in Backbone can be done manually or through plugins. Of course,
    the best approach is to use a plugin because it saves time and effort, but before
    we learn how to use the `backbone.validation` plugin, I want to show you how native
    validation works.
  prefs: []
  type: TYPE_NORMAL
- en: Manual validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backbone models have three properties to help us validate the model data: `validate()`,
    `validationError()`, and `isValid()`. The `validate()`method should return nothing
    if the model data is correct, or a value otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Backbone leaves open what should be returned by the `validate()` method, so
    you can return just a plain string message or a complex object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the `isValid()` method to ensure that your model has a valid state;
    internally, Backbone will call the `validate()` method and will return a Boolean
    value depending on the returned value: `true` if `validate()` returns nothing,
    `false` if it returns something.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `validationError`, you can get the latest validation error in the model—for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validate()` method is called by Backbone when you want to save the model,
    and will trigger an `''invalid''` event if the model is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the contacts editor, we are not validating anything. It''s time to start
    with some validations; let''s validate the name of the contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the `validate()` method can return anything. Backbone will assume
    that the model is valid only if `validate()` does not return something. In this
    case, an object is returned. Objects are more useful that plain string, because
    return more information that can be used for a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an error occurs an `''invalid''` event will be triggered. The editor form
    should display the error, so that the form will be listening for the `''invalid''`
    event in the model, and managing the DOM to display error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `showError()` method appends a `span` message below the input box, so the
    user can see what's wrong. With the `attr` property in the error object, we can
    put the error message in the right box; that's why using an error object is better
    than plain-text messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are creating a DOM element in the `showError()` method. I'm creating
    the element dynamically to simplify the code in the view. Of course, you can create
    a `span` element directly in the template too and show/hide it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Validating with the Backbone.Validation plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Backbone.Validation` simplifies the validation process, allowing us to write
    validation rules in a declarative way instead of programmatically. Also, it comes
    with built-in validation rules that you can use out-of-the-box. When using `Backbone.Validation`,
    the way you validate models is simplified, as we will show next.'
  prefs: []
  type: TYPE_NORMAL
- en: To start with `Backbone.Validation`, install the plugin after including Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the plugin; `Backbone.Validation` uses a validation property
    in the models to specify validation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `validate()` method, you can write the validation rules
    in a configuration object, where the keys of the object are the name of the fields
    in the model; in this case, we are validating the `name` field. The `required`
    and `minLength` validation rules are applied to the `name` field by `Backbone.Validation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `Contact` model has the validation configuration, we need to override
    the default `validate()` method in the Backbone model to activate the `Backbone.Validation`
    plugin. To do it, we need to call the `Backbone.Validation.bind()` method in the
    `onRender()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showError()` and `clearErrors()`are now unnecessary because we override
    the `validate()` method on the model. The `Backbone.Validation` plugin provides
    hooks to tell you when a model is valid; we will use these hooks as a shortcut.
    For now, the `save:contact` handler should change to invoke the `isValid()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note the `true` argument in the `isValid()` method; this argument should be
    used to validate all the model attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `Backbone.Validation` detects that a field is invalid, it will try to
    show an error message in the form; however, the default behavior is based on the
    `name` attribute in the form inputs. You can change the default behavior to show
    errors properly in our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `invalid()` method will be called when invalid data is found; the callback
    is called with an instance of the view, the field name that has the invalid data,
    and a message. With that information, we can create a `span` error message and
    add the `has-error` class to the `control-group` that contains the input.
  prefs: []
  type: TYPE_NORMAL
- en: Please consult the `Backbone.Validation` documentation to learn more about its
    advantages and usage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to keep models and views in sync. In general,
    syncing model and views is easy but things can turn difficult if the model has
    embedded arrays. You can use a plugin to simplify the data binding; `Backbone.Stickit`
    is a good option because it allows you to make your bindings in a declarative
    way.
  prefs: []
  type: TYPE_NORMAL
- en: I showed you how you can make two-way data binding with a vanilla Backbone,
    taking advantage of the event system; it's not always a good idea to use intensive
    two-way data binding in your applications but in some cases it can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to validate models with Backbone and how to use the
    validation API to show error messages in views. The `Backbone.Validation` plugin
    can help you to validate Backbone models easily with minimal effort, once validation
    callbacks are set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to modularize our contacts application
    to make it more maintainable and more effectively manage dependencies. Then we
    will bundle the whole application in a single script to load it faster.
  prefs: []
  type: TYPE_NORMAL
