- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Basic CRUD Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本CRUD微服务
- en: Our previous chapters are proof that microservices development is not just about
    implementation. You need to at least have a clear understanding of the pros and
    cons of using microservices compared with other approaches we looked at in the
    previous chapters – monolith and service-oriented – and you need to have an essential
    understanding of the technologies you want to apply when building microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前面的章节证明了微服务开发不仅仅是关于实现。你需要至少清楚地了解与其他方法相比（如我们在前几章中看到的单体和面向服务的），使用微服务的优缺点，并且你需要对你构建微服务时想要应用的技术有一个基本的理解。
- en: Applying all theoretical knowledge you have in practice is also not an easy
    task. This chapter will help us to apply microservices in practice and is one
    step forward to real-world microservices implementation. In this chapter, we plan
    to provide a solid foundation for further practical chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将你所有的理论知识应用到实践中也不是一件容易的事情。本章将帮助我们应用微服务到实践中，并且是迈向现实世界微服务实施的一步。在本章中，我们计划为后续的实践章节提供一个坚实的基础。
- en: Implementing a microservice approach in your project means that you mostly have
    a complex business domain and the conceptual boundary of your microservice requires
    you to implement a part of this complex logic. It indicates that microservice
    development is more than **Create**, **Retrieve/Read**, **Update**, **Delete**
    (**CRUD**) but to have a basic understanding of the microservice application structure,
    this chapter is a good starting point.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中实施微服务方法意味着你大部分时间都在处理一个复杂的企业领域，你的微服务的概念边界要求你实现这部分复杂逻辑的一部分。这表明微服务开发不仅仅是**创建**、**检索/读取**、**更新**、**删除**（**CRUD**），而且需要对微服务应用程序结构有一个基本的了解，本章是一个良好的起点。
- en: 'We’re going to explore the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下主题：
- en: Understanding business requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解业务需求
- en: Tools to develop a basic microservice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基本微服务的工具
- en: Preparing our first project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备我们的第一个项目
- en: Defining the internal architecture of our microservice
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们微服务的内部架构
- en: Hands-on account microservice development
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践账户微服务开发
- en: Running and testing our first microservice
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和测试我们的第一个微服务
- en: Let’s get into it!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: 'To develop and test our first microservice, we’ll need the following tools:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发和测试我们的第一个微服务，我们需要以下工具：
- en: An IDE of your choice (we prefer Visual Studio Code)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你喜欢的IDE（我们更喜欢Visual Studio Code）
- en: Postman
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman
- en: MongoDB
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: A browser of your choice
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你喜欢的浏览器
- en: It’s recommended that you download this book’s GitHub repository from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)
    folder to easily follow our code snippets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您从[https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)文件夹下载本书的GitHub仓库，以便轻松跟随我们的代码片段。
- en: Understanding business requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解业务需求
- en: Before you jump into building microservices with JavaScript, it’s important
    to clearly understand what your services need to do. Then, based on what your
    project requires, you can pick the right tools to help you create those microservices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在你用JavaScript构建微服务之前，清楚地了解你的服务需要做什么非常重要。然后，根据你的项目需求，你可以选择合适的工具来帮助你创建这些微服务。
- en: The team doesn’t consist of only developers. The business domain people are
    also an integral part of the team when it comes to building business valuable
    applications. In software development, the final and main artifact is code and
    it should reflect the real business. Applying domain language that everyone speaks
    will make your code a valuable source of truth and it is only possible if you
    have zero translation between business and developers. The most popular approach
    to developing such types of microservices with a single language that everyone
    speaks is **Domain-driven Design** (**DDD**). Everyone in a team should use the
    same language that describes the business in a given boundary. This is called
    **Ubiquitous Language** (**UL**). Using UL, everyone in a team will speak the
    same language and the language will be reflected in your code. It means business
    helps your design and developers help businesses to have more clearer understanding.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 团队不仅仅由开发者组成。在构建具有商业价值的应用程序时，业务领域的人也是团队不可或缺的一部分。在软件开发中，最终和主要的产品是代码，它应该反映真实的业务。应用大家都能使用的领域语言将使你的代码成为宝贵的真相来源，而这只有在业务和开发者之间没有翻译的情况下才可能实现。开发这种类型微服务最流行的方法是用大家都能说的同一种语言，这种方法被称为**领域驱动设计**（**DDD**）。团队中的每个人都应该使用描述给定边界的业务的语言。这被称为**通用语言**（**UL**）。使用UL，团队中的每个人都会说同一种语言，这种语言将反映在你的代码中。这意味着业务帮助你设计，开发者帮助业务有更清晰的理解。
- en: 'Throughout our learning process, we’ll mention some ideas from DDD, despite
    this not being a DDD book. Please refer to *Implementing Domain-Driven Design*,
    by Vaugh Vernon, and *Domain-Driven Design: Tackling Complexity in the Heart of
    Software*, by Eric Evans, to learn more.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的学习过程中，我们会提到一些来自领域驱动设计（DDD）的想法，尽管这不是一本DDD书籍。请参考Vaugh Vernon的《实现领域驱动设计》（Implementing
    Domain-Driven Design）和Eric Evans的《领域驱动设计：软件核心的复杂性处理》（Domain-Driven Design: Tackling
    Complexity in the Heart of Software）以了解更多信息。'
- en: This book is not about analyzing and gathering the business requirements. There
    are really good sources out there that focus exactly on this topic. To make things
    simple and less theoretical, we’ll start with distilled requirements with clear
    boundaries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不是关于分析和收集业务需求的。外面确实有很好的资源专注于这个话题。为了使事情简单化并减少理论性，我们将从提炼出的具有明确边界的业务需求开始。
- en: 'We will build an account building microservice that requires the following
    *core functionalities*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个需要以下*核心功能*的账户构建微服务：
- en: Create account
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建账户
- en: Update account
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新账户
- en: Get all account information
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有账户信息
- en: Get an account for the given ID
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据给定的ID获取账户
- en: Delete unused account
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除未使用的账户
- en: 'Then, we have the following *non-functional* requirements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还有以下以下*非功能性*要求：
- en: '**Scalability**: The microservice should be able to handle more and more requests
    as it gets used by more people.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：随着越来越多的人使用，微服务应该能够处理越来越多的请求。'
- en: '**Performance**: The microservice should respond to requests quickly to keep
    users happy.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：微服务应该快速响应用户请求，以保持用户满意。'
- en: '**Resilience**: The microservice should be able to bounce back from problems
    and keep working properly.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：微服务应该能够从问题中恢复过来，并保持正常工作。'
- en: '**Easy testing**: The microservice should be simple to test to make sure it’s
    working correctly.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于测试**：微服务应该简单易测试，以确保其正确工作。'
- en: '**Stateless**: The microservice shouldn’t rely on remembering past interactions
    with users, and should instead store any important information in a database.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：微服务不应该依赖于记住与用户的过去交互，而应该将任何重要信息存储在数据库中。'
- en: '**Easy updates**: The microservice should be straightforward to put to use
    and update whenever needed. Of course, usually, you’ll have more non-functional
    requirements than these. However, for getting started, these should be more than
    enough.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于更新**：微服务应该简单易用，并在需要时进行更新。当然，通常你会有比这些更多的非功能性要求。然而，为了入门，这些应该已经足够了。'
- en: Tools to develop a basic microservice
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基本微服务所需的工具
- en: 'Developing an application is not just a coding process. In this chapter, to
    develop our microservice, we also need to select the Node.js framework and store
    information in our database:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用程序不仅仅是编码过程。在本章中，为了开发我们的微服务，我们还需要选择Node.js框架并在我们的数据库中存储信息：
- en: '**Database**: We need to store information somewhere. It’s better to keep the
    service itself simple and store the information in a separate database:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：我们需要将信息存储在某个地方。最好是保持服务本身简单，并将信息存储在单独的数据库中：'
- en: For this service, we’ll be using *MongoDB*, a popular database that works differently
    than traditional SQL databases. MongoDB is a popular choice for building web services
    with Node.js technology.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这项服务，我们将使用 *MongoDB*，这是一个与传统SQL数据库工作方式不同的流行数据库。MongoDB是使用Node.js技术构建Web服务的流行选择。
- en: It’s designed to handle situations where users mostly read information, and
    it can store a lot of data efficiently. MongoDB can be easily expanded by adding
    more servers as needed.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它旨在处理用户主要读取信息的情况，并且可以高效地存储大量数据。MongoDB可以通过添加更多服务器轻松扩展。
- en: '**Node.js framework**: You can build a fully functional microservice using
    just Node.js but it takes some time and a lot of lines of code. Nowadays, most
    developers use the Node.js frameworks to build services fast with a minimal amount
    of code lines. Node.js on its own is a low-level environment. Frameworks provide
    a predefined structure and organization for your code, making it easier to manage
    and maintain as your project grows. They often come with common functionalities
    such as *routing* (handling different URL requests), *templating* (generating
    web page content), and database interaction already built-in. This saves you time
    from writing those parts yourself.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js框架**：您可以使用Node.js构建一个功能齐全的微服务，但这需要一些时间和大量的代码行。如今，大多数开发者使用Node.js框架来快速构建服务，同时代码行数最少。Node.js本身是一个低级环境。框架为您提供了预定义的结构和组织，使得随着项目的发展，代码更容易管理和维护。它们通常内置了常见的功能，如
    *路由*（处理不同的URL请求）、*模板*（生成网页内容）和数据库交互。这可以节省您自己编写这些部分的时间。'
- en: Popular Node.js frameworks have large communities of developers. This means
    you have access to a wealth of resources, tutorials, and solutions online if you
    encounter problems. There’s also a bigger pool of developers familiar with the
    framework for potential collaboration.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 流行的Node.js框架拥有庞大的开发者社区。这意味着如果您遇到问题，可以在线访问丰富的资源、教程和解决方案。还有更多熟悉该框架的开发者，可以用于潜在的协作。
- en: Frameworks can help mitigate security vulnerabilities by providing established
    coding practices and features to prevent common attacks.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 框架可以通过提供既定的编码实践和功能来防止常见攻击，从而帮助减轻安全漏洞。
- en: For this chapter, we’re going to use *Express.js*, one of the most popular Node.js
    frameworks for building microservices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用 *Express.js*，这是构建微服务中最受欢迎的Node.js框架之一。
- en: Preparing our first project
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备我们的第一个项目
- en: Our focus in this chapter is to create a microservice that provides really simple
    CRUD operations. So, it’s going to be mostly domain-centric. That’s why we start
    our application from the database.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是创建一个提供真正简单CRUD操作的微服务。因此，它将主要关注领域。这就是为什么我们从数据库开始构建应用程序。
- en: To follow our examples, open the `Ch05` folder in this book’s GitHub repository
    and open it using your favorite text editor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随我们的示例，请打开本书GitHub仓库中的`Ch05`文件夹，并使用您喜欢的文本编辑器打开它。
- en: '*There’s a difference between knowing the path and walking* *the path.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*知道路径和走过路径是不同的*。'
- en: We prefer that you don’t just download and explore the repository and that you
    also try to write some code with us. This will help you gain valuable practice.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您不仅下载并探索仓库，还尝试与我们一起编写一些代码。这将帮助您获得宝贵的实践经验。
- en: Understanding the concept of packages
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解包的概念
- en: Building software doesn’t mean that you should implement everything from scratch
    and this fact doesn’t depend on programming languages. It is also applicable for
    Node.js development. Our main focus should always be solving business problems
    and making this process fast, easy, secure, and reliable. Almost every popular
    programming language provides a collection of libraries. In Node.js, these are
    called **packages**. Node.js development mostly starts with package configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件并不意味着您应该从头开始实现一切，这一事实并不取决于编程语言。它也适用于Node.js开发。我们始终应该关注解决业务问题，并使这个过程快速、简单、安全、可靠。几乎每种流行的编程语言都提供了一组库。在Node.js中，这些被称为
    **包**。Node.js开发通常从包配置开始。
- en: When you install Node.js, you automatically install the `npm` a great and reliable
    source for development. For example, if you need validation for your application,
    you shouldn’t build everything from scratch. Why not use popular practices that
    have already been implemented in popular libraries? We mostly build only business-specific
    functionalities by ourselves. Other relevant functionalities, such as connecting
    to the database, validation, security, logging, and more, can be installed as
    packages and reused.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Node.js 时，你将自动安装 `npm`，这是一个优秀且可靠的开发资源。例如，如果你需要为你的应用程序进行验证，你不需要从头开始构建一切。为什么不使用已经在流行库中实现过的流行实践呢？我们通常只自己构建业务特定的功能。其他相关功能，如连接数据库、验证、安全、日志记录等，可以作为包安装并重用。
- en: 'Here’s how you can interact with `npm` and configure it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何与 `npm` 交互并配置它的方法：
- en: Open your favorite text editor (we’re using Visual Studio Code).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你喜欢的文本编辑器（我们使用 Visual Studio Code）。
- en: Create a folder (in our case, `Ch05`).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件夹（在我们的例子中，是 `Ch05`）。
- en: Navigate to that folder using your terminal (Use `cd folder_name` command to
    navigate to your empty folder – that is, use `cd Ch05`).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的终端导航到该文件夹（使用 `cd folder_name` 命令导航到你的空文件夹——即使用 `cd Ch05`）。
- en: 'Type `npm init` and follow the instructions provided (*Figure 5**.1*):'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `npm init` 并遵循提供的说明（*图 5.1*）：
- en: '![Figure 5.1: Creating a package.json file](img/B09148_05_001.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：创建 package.json 文件](img/B09148_05_001.jpg)'
- en: 'Figure 5.1: Creating a package.json file'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：创建 package.json 文件
- en: Hit *Enter* to generate **package** **configuration** (*package.json*).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Enter* 生成 **配置** **包** (*package.json*)。
- en: 'At this point, we have a special file called `package.json` in our project
    with the following JSON content:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们在项目中有一个特殊的文件叫做 `package.json`，包含以下 JSON 内容：
- en: '[PRE0]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For learning purposes, it is also OK to use the `npm init -y` command instead
    of `npm init` as it will generate a minimal `package.json` file for you to get
    started with (*Figure 5**.2*). After generation, you can manually update any line
    you want:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于学习目的，也可以使用 `npm init -y` 命令代替 `npm init`，因为它会为你生成一个最小的 `package.json` 文件以便你开始使用（*图
    5.2*）。生成后，你可以手动更新任何你想要的行：
- en: '![Figure 5.2: Generated package.json file](img/B09148_05_002.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：生成的 package.json 文件](img/B09148_05_002.jpg)'
- en: 'Figure 5.2: Generated package.json file'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：生成的 package.json 文件
- en: Let’s learn more about the `package.json` file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 `package.json` 文件。
- en: Understanding the package.json file
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 package.json 文件
- en: The `package.json` file is a vital component in Node.js projects. It acts like
    a project manifest, storing crucial information about your project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件是 Node.js 项目中的一个重要组成部分。它就像一个项目清单，存储有关你的项目的关键信息。'
- en: 'Let’s summarize the role of the `package.json` file in our Node.js projects:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下 `package.json` 文件在我们 Node.js 项目中的作用：
- en: It lists all the external modules (dependencies) your project relies on to function.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它列出了你的项目为了运行所依赖的所有外部模块（依赖项）。
- en: Along with the names, it specifies the required versions using semantic versioning
    for compatibility. This ensures that everyone working on the project uses the
    same compatible versions of dependencies.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了名称外，它还使用语义版本控制来指定所需的版本，以确保所有参与项目的人都使用兼容的依赖项版本。
- en: It serves as a central location for project metadata, such as the project’s
    name, version, description, license, and author information (see *Figure 5**.2*).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为项目元数据（如项目的名称、版本、描述、许可证和作者信息）的中心位置（见 *图 5.2*）。
- en: You can define custom scripts in the `package.json` file to automate repetitive
    tasks within your project. These scripts can do anything from starting the development
    server to running tests or building the project for deployment.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 `package.json` 文件中定义自定义脚本来自动化项目中的重复性任务。这些脚本可以从启动开发服务器到运行测试或构建项目以部署做任何事情。
- en: If you plan to publish your project as a reusable package for others to use,
    `package.json` becomes even more important. It provides essential information
    for the package manager (such as `npm`) to understand how to install and use your
    project effectively.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你计划将你的项目作为可重用的包发布供他人使用，`package.json` 就变得更加重要。它为包管理器（如 `npm`）提供了理解如何有效安装和使用你的项目所必需的信息。
- en: Long story short, `package.json` keeps your project organized, ensures consistent
    dependencies, and simplifies collaboration among developers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`package.json` 使你的项目井然有序，确保依赖项的一致性，并简化了开发者之间的协作。
- en: Understanding index.js files
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 index.js 文件
- en: Throughout this chapter, you’ll encounter files named `index.js`. These files
    play a couple of important roles.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将遇到名为 `index.js` 的文件。这些文件扮演着几个重要的角色。
- en: By convention, `index.js` acts as the entry point for our Node.js application.
    When we run our application using node, the `index.js` file is the starting point
    where the application’s execution begins.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`index.js` 作为我们的 Node.js 应用的入口点。当我们使用 node 运行应用时，`index.js` 文件是应用执行开始的起点。
- en: Inside `index.js`, you can typically find code that imports necessary modules
    and libraries using the required statements to configure your application (for
    example, setting up a web server and connecting to databases) and defines the
    main logic or event listeners for your application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 中，你可以通常找到使用所需语句导入必要模块和库的代码，以配置你的应用（例如，设置 Web 服务器和连接到数据库）并定义应用的主逻辑或事件监听器。
- en: These files can also serve for namespacing and organization within your project.
    Consider a folder containing multiple JavaScript files with related functionalities.
    An `index.js` file inside that folder can act as a central point for importing
    those related files and re-exporting specific functions or classes from those
    files, making them accessible outside the folder using a single import statement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件也可以用于在项目中进行命名空间和组织。考虑一个包含多个具有相关功能的 JavaScript 文件的文件夹。该文件夹中的 `index.js` 文件可以作为导入这些相关文件和从这些文件中重新导出特定函数或类的中心点，使得它们可以通过单个导入语句在文件夹外部访问。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that `index.js` is a convention, not a strict requirement.
    You can name your entry point file differently (for example, `app.js` or `main.js`).
    So long as you specify the correct filename when you’re running your application
    with node, it will work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`index.js` 只是一种惯例，并非严格的要求。你可以将入口点文件命名为不同的名称（例如，`app.js` 或 `main.js`）。只要你在使用
    node 运行应用时指定了正确的文件名，它就会正常工作。
- en: In summary, `index.js` files serve as a common entry point and a way to organize
    code within folders in your Node.js projects. They provide a clean and consistent
    approach to structuring your application’s starting point and managing related
    functionalities.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`index.js` 文件在 Node.js 项目中充当一个常见的入口点，以及一种在文件夹内组织代码的方式。它们提供了一种干净且一致的方法来构建应用起点和管理相关功能。
- en: Installing the required packages
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装所需的包
- en: 'By itself, `package.json` doesn’t contain any required package that we plan
    to use by default. It is just boilerplate for getting started. Here’s a list of
    packages that we’ll be using in this chapter, along with their installation commands:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，`package.json` 不包含我们计划默认使用的任何必需包。它只是启动时的模板。以下是本章我们将使用的包及其安装命令列表：
- en: Express ( `npm` `install express`)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express (`npm install express`)
- en: Joi ( `npm` `install joi`)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joi (`npm install joi`)
- en: mongoose ( `npm` `install mongoose`)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mongoose (`npm install mongoose`)
- en: dotenv ( `npm install` `dotenv –save`)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dotenv (`npm install dotenv –save`)
- en: 'Here’s what the `package.json` file’s dependencies and `devDependencies` look
    like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `package.json` 文件中的依赖项和 `devDependencies` 的样子：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You’ve probably already realized that, when installing our first package, the
    node automatically generates another file called `package-lock.json`. Let’s summarize
    its roles:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，当我们安装第一个包时，node 会自动生成另一个名为 `package-lock.json` 的文件。让我们总结一下它的作用：
- en: It acts as a lock file, specifying the exact versions of packages and their
    dependencies that were installed. This guarantees that regardless of who installs
    the project or on what machine, the same set of versions will be used, leading
    to consistent behavior.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为一个锁文件，指定了安装的包及其依赖的确切版本。这保证了无论谁安装项目或在哪里安装，都将使用相同的版本集，从而确保行为的一致性。
- en: By locking down versions, `package-lock.json` enables developers to reproduce
    the project’s environment exactly. This is essential for maintaining stability
    and avoiding unexpected issues during deployments or across different development
    machines.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过锁定版本，`package-lock.json` 允许开发者精确地重现项目环境。这对于维护稳定性和避免在部署期间或不同开发机器上出现意外问题至关重要。
- en: When shared within a team or used in `package-lock.json` ensures everyone involved
    is working with the same dependencies. This streamlines collaboration and automates
    reliable builds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当在团队中共享或在 `package-lock.json` 中使用时，确保所有相关人员都在使用相同的依赖项。这简化了协作并自动化了可靠的构建。
- en: It works in conjunction with `package.json`. While `package.json` specifies
    the desired dependencies and their version ranges, `package-lock.json` pins down
    the exact versions that are used during installation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `package.json` 一起工作。虽然 `package.json` 指定了所需的依赖项及其版本范围，但 `package-lock.json`
    确定了安装过程中使用的确切版本。
- en: Overall, `package-lock.json` is important for maintaining consistent and reproducible
    Node.js project environments across installations and team workflows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`package-lock.json` 对于在安装和团队工作流程中维护一致的、可重复的 Node.js 项目环境非常重要。
- en: 'You may have noticed that we have one more folder: `node_modules`. In Node.js
    projects, the `node_modules` folder is a special directory that stores all the
    third-party libraries and dependencies your project relies on. These libraries
    provide pre-written code for functionalities you don’t need to build from scratch,
    saving you time and effort.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们还有一个额外的文件夹：`node_modules`。在 Node.js 项目中，`node_modules` 文件夹是一个特殊的目录，用于存储项目依赖的所有第三方库。这些库提供了预先编写的代码，用于实现你不需要从头开始构建的功能，从而节省时间和精力。
- en: Node.js projects often depend on external code from various sources. The `node_modules`
    folder keeps all these dependencies organized in one place. Each project can have
    its own set of dependencies specific to its needs. This way, different projects
    can use different versions of the same library without conflicts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 项目通常依赖于来自各种来源的外部代码。`node_modules` 文件夹将所有这些依赖项组织在一个地方。每个项目都可以有自己的依赖项集合，以满足其特定需求。这样，不同的项目可以使用同一库的不同版本，而不会发生冲突。
- en: At this point, we have an initial skeleton for our application. So, it’s time
    to start the actual development process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的应用程序构建了一个初始框架。因此，现在是时候开始实际开发过程了。
- en: Defining the internal architecture of our microservice
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们微服务的内部架构
- en: Imagine that after carefully analyzing, we decided to have a special microservice
    that’s responsible for working with account information and we called it the *account
    microservice*. Our account consists of an *ID*, *account name*, *account type*,
    *account status*, and *account number*. To track changes, we’re going to add `createdAt`
    and `updatedAt` fields.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，经过仔细分析后，我们决定有一个专门负责处理账户信息的特殊微服务，我们称之为 *账户微服务*。我们的账户包括一个 *ID*、*账户名称*、*账户类型*、*账户状态*
    和 *账户号码*。为了跟踪更改，我们将添加 `createdAt` 和 `updatedAt` 字段。
- en: The microservice approach has been applied to our whole project and now we have
    multiple services. However, the internal design of our concrete microservice depends
    on the requirements and it’s up to the team regarding which architectural pattern
    to apply. One of the most popular and classical architectural patterns in software
    development is **Model-View-Controller** (**MVC**). To make things simple and
    understandable, we will apply it to our microservice design.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法已应用于我们的整个项目，现在我们拥有多个服务。然而，我们具体微服务的内部设计取决于需求，并且由团队决定应用哪种架构模式。软件开发中最受欢迎和经典的架构模式之一是
    **模型-视图-控制器**（**MVC**）。为了使事情简单易懂，我们将将其应用于我们的微服务设计。
- en: MVC architectural pattern
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC 架构模式
- en: The MVC architectural pattern is a popular choice for structuring Node.js APIs
    due to its emphasis on separation of concerns.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 架构模式由于其强调关注点的分离，是结构化 Node.js API 的流行选择。
- en: 'It has the following main components:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下主要组件：
- en: '**Model**:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：'
- en: Represents the data layer of your API.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示 API 的数据层。
- en: Encapsulates data access logic and interacts with databases (for example, MongoDB,
    MySQL, and so on).
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装数据访问逻辑并与数据库（例如 MongoDB、MySQL 等）交互。
- en: Handles data persistence and retrieval.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据持久性和检索。
- en: '**View** (not directly used in Node.js APIs):'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**（在 Node.js API 中不直接使用）：'
- en: Traditionally deals with UI presentation in web applications.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统上处理 Web 应用程序中的 UI 呈现。
- en: Not directly applicable in Node.js APIs as they are data-centric.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不直接适用于 Node.js API，因为它们以数据为中心。
- en: Note that the concept of *view* can be extended to represent the response format
    (JSON, XML) for the API.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，*视图* 的概念可以扩展到表示 API 的响应格式（JSON、XML）。
- en: '`GET`, `POST`, `PUT`, and `DELETE`).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT` 和 `DELETE`）。'
- en: Interacts with the model to fetch or manipulate data based on the request.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模型交互以根据请求获取或操作数据。
- en: Prepares the response data in the desired format (JSON, XML).
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备以所需格式（JSON、XML）的数据响应。
- en: Returns the response to the client.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户端返回响应。
- en: But why it is beneficial to use MVC for Node.js APIs?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么使用 MVC 对 Node.js API 有益？
- en: '**Separation of concerns**: Makes code more organized and maintainable by dividing
    functionalities.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：通过划分功能使代码更有组织和易于维护。'
- en: '**Improved testability**: Each layer (model, view, and controller) can be tested
    independently.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可测试性**：每个层（模型、视图和控制器）都可以独立测试。'
- en: '**Flexibility**: Easier to modify or update specific parts of the API without
    affecting others.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：更容易修改或更新API的特定部分，而不会影响其他部分。'
- en: '**Scalability**: Easier to scale the application by adding more controllers
    or models.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：通过添加更多控制器或模型更容易扩展应用程序。'
- en: Now that we have enough theoretical knowledge about MVC, it’s time to apply
    it in practice.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对MVC有了足够的理论知识，是时候将其应用于实践了。
- en: Integrating MVC into our Node.js project
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MVC集成到我们的Node.js项目中
- en: While Node.js doesn’t have a built-in MVC framework, popular web frameworks
    such as *Express.js* can be used to implement the pattern. Express.js handles
    routing (mapping URLs to controllers) and simplifies request-response handling.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Node.js没有内置的MVC框架，但像*Express.js*这样的流行Web框架可以用来实现该模式。Express.js处理路由（将URL映射到控制器）并简化请求-响应处理。
- en: You’ll typically structure your project with separate folders for models and
    controllers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会使用为模型和控制器分别创建的单独文件夹来结构化项目。
- en: We’ll use the *N-Layered Architecture* to structure our code. This architecture
    is popular because it promotes the separation of concerns, making the application
    more modular, maintainable, and scalable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*N层架构*来结构化我们的代码。这种架构之所以受欢迎，是因为它促进了关注点的分离，使应用程序更加模块化、易于维护和可扩展。
- en: 'Since we don’t have complex requirements, getting started with it is a good
    initial point. Using both MVC and the N-layered architecture in your Node.js Express
    project can lead to a well-structured and maintainable API. The following are
    some common layers you’ll encounter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有复杂的需求，因此从它开始是一个很好的起点。在您的Node.js Express项目中同时使用MVC和N层架构可以导致一个结构良好且易于维护的API。以下是一些您可能会遇到的一些常见层：
- en: Presentation Layer (UI or API)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层（UI或API）
- en: Business Logic Layer (core application logic)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑层（核心应用程序逻辑）
- en: Data Access Layer (interaction with databases)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问层（与数据库的交互）
- en: The model, representing data and its logic, aligns with the data access layer’s
    responsibilities. Scripts in the `services` folder will store our business logic.
    The controller, which handles requests and manipulates data, shouldn’t contain
    any business logic. Instead, it should act as a bridge that forwards the user’s
    request to the business logic layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模型，代表数据和其逻辑，与数据访问层的责任相一致。`services`文件夹中的脚本将存储我们的业务逻辑。控制器，它处理请求并操作数据，不应包含任何业务逻辑。相反，它应该作为一个桥梁，将用户的请求转发到业务逻辑层。
- en: Now that we’ve defined a general architecture for our application, we’re ready
    to focus on the implementation details. Starting from the next section, we’ll
    implement the functional behaviors of our first microservice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的应用程序定义了一个通用的架构，我们准备专注于实现细节。从下一节开始，我们将实现第一个微服务的功能行为。
- en: Hands-on account microservice development
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践开发账户微服务
- en: To start from scratch, let’s create a folder called `src`. We plan to organize
    our main application structure under this folder. This is going to be a data-centric
    application, so it’s better to start development from the database segment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头开始，让我们创建一个名为`src`的文件夹。我们计划在这个文件夹下组织我们的主要应用程序结构。这将是一个以数据为中心的应用程序，因此最好从数据库部分开始开发。
- en: 'In the end, we plan to build the following project structure for our application:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计划为我们的应用程序构建以下项目结构：
- en: '![Figure 5.3: The final project structure](img/B09148_05_003.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：最终项目结构](img/B09148_05_003.jpg)'
- en: 'Figure 5.3: The final project structure'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：最终项目结构
- en: To follow along with ease, don’t forget to download the source code from our
    repository.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松跟随，别忘了从我们的仓库下载源代码。
- en: Implementing our data-access functionalities
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的数据访问功能
- en: We always store data somewhere. The most used storage for data is a database.
    The data access that we plan to implement relies on MongoDB and isolates us from
    the difficulties of querying a database using SQL. It’s like using arrays or lists
    but under the hood, it interacts with a database.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是将数据存储在某个地方。最常用的数据存储是数据库。我们计划实现的数据访问依赖于MongoDB，并使我们免于使用SQL查询数据库的困难。它就像使用数组或列表，但在底层，它与数据库交互。
- en: 'To start creating our account microservice, do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建我们的账户微服务，请执行以下操作：
- en: Create a `db` folder under `src`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 下创建一个 `db` 文件夹。
- en: Add the `index.js` file to the `db` folder.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `index.js` 文件添加到 `db` 文件夹中。
- en: 'First, we need to handle the database communication process. That’s why our
    current file (`index.js`) will serve connection and disconnection functionalities:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要处理数据库通信过程。这就是为什么我们的当前文件 (`index.js`) 将提供连接和断开连接的功能：
- en: '[PRE2]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ve already mentioned the `mongoose` package. To use packages like this, we
    have the `required` command. Node.js automatically handles packages from the `node_modules`
    folder without specifying any relative or full path.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经提到了 `mongoose` 包。为了使用这样的包，我们有 `required` 命令。Node.js 会自动处理 `node_modules`
    文件夹中的包，无需指定任何相对或完整路径。
- en: 'Here, we’ve implemented two main functionalities. They mostly act as wrappers
    over existing functionalities:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们实现了两个主要功能。它们主要作为现有功能的包装器：
- en: The `connect` function tries to connect to the given database. In case of errors,
    we have one more attempt to try to connect to the database after `8` seconds.
    It is up to you to configure this but having a connection attempt after an unsuccessful
    operation makes sense.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect` 函数尝试连接到指定的数据库。如果出现错误，我们将在 `8` 秒后再次尝试连接到数据库。这取决于你如何配置，但在不成功操作后进行连接尝试是有意义的。'
- en: The `disconnect` function handles the disconnection case. Here, we’re removing
    all listeners of our database via `db.disconnect()` manually.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnect` 函数处理断开连接的情况。在这里，我们通过 `db.disconnect()` 手动移除我们数据库的所有监听器。'
- en: Node.js has a file-based module approach. This means that every file, by itself,
    can be treated as a module and other modules can use it to build more complex
    modules. One of the ways you can make some functionalities of your module accessible
    to others is by using `exports`. You should only provide the required functions
    with the following proper encapsulation. If some of your functions are used by
    other functions in the same module and they are not part of your module’s contract,
    it’s better not to specify them in the `exports` list. In our case, we have two
    functions – `connect` and `disconnect` – that we’re providing outside to be consumed
    by other modules.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Node.js 有一个基于文件的模块方法。这意味着每个文件本身都可以被视为一个模块，其他模块可以使用它来构建更复杂的模块。你可以通过使用 `exports`
    来使模块的一些功能对其他人可用。你应该只提供以下适当封装的所需函数。如果你的某些函数被同一模块中的其他函数使用，并且它们不是模块合同的一部分，那么最好不要在
    `exports` 列表中指定它们。在我们的例子中，我们有两个函数 – `connect` 和 `disconnect` – 我们提供外部使用，以便其他模块使用。
- en: Implementing the M in MVC
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现MVC中的M
- en: 'In our project, the responsibility of models is to act as a data access layer.
    This layer covers the main operations, such as `INSERT`, `UPDATE`, `SELECT`, and
    `DELETE`. We have `account.js` under the `src/models` folder; this is where all
    the database-related functionalities live. Here’s what it looks like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，模型的责任是充当数据访问层。这一层涵盖了主要操作，如 `INSERT`、`UPDATE`、`SELECT` 和 `DELETE`。我们在
    `src/models` 文件夹下有 `account.js`；这就是所有数据库相关功能所在的地方。下面是这个文件的样子：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s walk through this code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码：
- en: '`const mongoose = require(''mongoose'');`: This line imports the Mongoose library,
    which is used for interacting with MongoDB databases in Node.js.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const mongoose = require(''mongoose'');`: 这一行导入了 Mongoose 库，该库用于在 Node.js
    中与 MongoDB 数据库交互。'
- en: '`const { Schema } = mongoose;`: This line uses destructuring to extract the
    `Schema` class from the `mongoose` object. This makes the code more concise and
    easier to read.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const { Schema } = mongoose;`: 这一行使用解构从 `mongoose` 对象中提取 `Schema` 类。这使得代码更加简洁，更容易阅读。'
- en: '`new Schema({ ... })`: This line creates a new Mongoose schema object. The
    object that’s passed as an argument defines the structure of the documents that
    will be stored in the account collection within your MongoDB database. Within
    the curly braces, `{}`, you define the properties (fields) of each document in
    the collection. Here’s a breakdown of each property:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Schema({ ... })`: 这一行创建了一个新的 Mongoose 架构对象。作为参数传递的对象定义了将在 MongoDB 数据库的账户集合中存储的文档的结构。在大括号
    `{}` 内，你定义了集合中每个文档的属性（字段）。以下是每个属性的分解：'
- en: '`name`:'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`:'
- en: '`type: String`: This specifies that the `name` property should be a string.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: String`: 这指定了 `name` 属性应该是一个字符串。'
- en: '`required: true`: This makes the `name` property mandatory. A document cannot
    be saved without a value for the name.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required: true`: 这使得 `name` 属性是必需的。没有名称值的文档无法保存。'
- en: '`number`: Similar to `name`, but also required.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`: 与 `name` 类似，但也是必需的。'
- en: '`type`:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`:'
- en: '`type: String:` The `status` property is a string.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: String:` `status`属性是一个字符串。'
- en: '`enum: [''new'', ''active'', ''inactive'', ''blocked'']`: Similar to `type`,
    this defines a list of allowed values for the status: `''new''`, `''active''`,
    `''inactive''`, or `''blocked''`.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum: [''new'', ''active'', ''inactive'', ''blocked'']`：类似于`type`，这定义了状态允许值的列表：`''new''`、`''active''`、`''inactive''`或`''blocked''`。'
- en: '`default: ''new''`: If no status is specified, it will default to `''new''`.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default: ''new''`：如果没有指定状态，它将默认为`''new''`。'
- en: '`createdAt`:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createdAt`：'
- en: '`type: Date`: This property stores the date and time the document was created
    using the current time (`Date.now`).'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: Date`: 此属性存储文档创建的日期和时间，使用当前时间（`Date.now`）。'
- en: '`updatedAt`:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatedAt`：'
- en: '`type: Date:` This property is intended to store the date and time the document
    was last updated. However, it’s not explicitly set to a default value here. You’ll
    likely need to update this field manually in your application logic.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: Date:` 此属性旨在存储文档最后更新的日期和时间。然而，它在此处并未显式设置默认值。你很可能需要在应用程序逻辑中手动更新此字段。'
- en: '`{ optimisticConcurrency: true }`: This option is used for optimistic concurrency
    control, which is a mechanism that helps prevent data inconsistencies during updates
    ([https://mongoosejs.com/docs/guide.html#optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency)).'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ optimisticConcurrency: true }`：此选项用于乐观并发控制，这是一种帮助防止更新期间数据不一致的机制（[https://mongoosejs.com/docs/guide.html#optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency)）。'
- en: '`module.exports = mongoose.model(''account'', AccountSchema);`: This line creates
    a Mongoose model named `account` based on your defined `AccountSchema`. The model
    acts as a blueprint for interacting with `account` documents in your MongoDB database.
    By exporting the model, you make it available for use in other parts of your Node.js
    application.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.exports = mongoose.model(''account'', AccountSchema);`：这一行创建了一个基于你定义的`AccountSchema`的Mongoose模型，名为`account`。该模型作为与MongoDB数据库中的`account`文档交互的蓝图。通过导出模型，你使它在Node.js应用程序的其他部分可用。'
- en: Long story short, this code sets up a Mongoose schema for storing account information
    in a MongoDB collection. It defines properties such as `name`, `number`, `type`,
    `status`, `creation time`, and `last update time`, with validation rules and defaults.
    The code then exports a model that allows you to create, read, update, and delete
    account documents in your database.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这段代码为在MongoDB集合中存储账户信息设置了一个Mongoose模式。它定义了诸如`name`、`number`、`type`、`status`、`创建时间`和`最后更新时间`等属性，并具有验证规则和默认值。然后，代码导出一个模型，允许你在数据库中创建、读取、更新和删除账户文档。
- en: Storing configuration
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储配置
- en: We need to store application-based configuration somewhere. For the current
    situation, we need MongoDB URL and port information. It isn’t a good idea to hard-code
    this information directly into your code because of maintainability, reusability,
    and extensibility. Instead, we prefer to store it in a separate file. That’s why
    we’ve installed the `dotenv` package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将应用程序相关的配置存储在某个地方。对于当前情况，我们需要MongoDB的URL和端口信息。直接将此信息硬编码到代码中并不是一个好主意，因为这会影响可维护性、可重用性和可扩展性。相反，我们更倾向于将其存储在一个单独的文件中。这就是为什么我们安装了`dotenv`包。
- en: The `dotenv` package in Node.js helps you manage environment variables for your
    project. It offers a way to store configuration settings, such as API keys or
    database credentials, outside of your code in a `.env` file. This improves security
    by keeping sensitive data out of your codebase.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的`dotenv`包帮助你管理项目中的环境变量。它提供了一种将配置设置（如API密钥或数据库凭据）存储在代码之外，在`.env`文件中的方法。这通过将敏感数据从代码库中排除来提高安全性。
- en: Why use `dotenv`?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`dotenv`？
- en: '**Security**: It keeps sensitive data out of your code base, reducing the risk
    of accidental exposure'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：它将敏感数据从代码库中排除，降低了意外暴露的风险'
- en: '**Separation of concerns**: It separates configuration from code, making your
    code cleaner and easier to manage'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：它将配置与代码分离，使你的代码更干净且易于管理'
- en: '`.env` files for different environments (development, staging, and production)
    with specific configurations for each'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同环境（开发、测试和生产）创建具有特定配置的`.env`文件
- en: The `.env` file itself shouldn’t be included in version control systems such
    as Git to avoid committing sensitive information. We can create a `.env.example`
    file with placeholder values to guide developers on how to set up their environment
    variables. However, for this book, we will include the .`env` file in our Git
    repository as is, to facilitate the learning process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`.env` 文件本身不应包含在版本控制系统（如 Git）中，以避免提交敏感信息。我们可以创建一个包含占位符值的 `.env.example` 文件，以指导开发者如何设置他们的环境变量。然而，对于这本书，我们将以原样将
    `.env` 文件包含在我们的 Git 仓库中，以方便学习过程。'
- en: 'We have the `configs` folder under the `Ch05` folder. It is a root-level folder
    and contains a `.env` file without a name. Here’s its content:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Ch05` 文件夹下有一个 `configs` 文件夹。它是一个根级文件夹，包含一个无名的 `.env` 文件。以下是其内容：
- en: '[PRE4]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to validate and create a configuration object based on the configuration
    we’ve looked at. That’s why we need one more folder called `config` under the
    `src` folder. So, let’s create `config.js` with the following content:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要根据我们查看的配置进行验证和创建配置对象。这就是为什么我们需要在 `src` 文件夹下创建一个名为 `config` 的额外文件夹。所以，让我们创建
    `config.js` 并包含以下内容：
- en: '[PRE5]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the `createConfig` function, we’re able to read and build config objects.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `createConfig` 函数，我们能够读取和构建配置对象。
- en: There are a lot of packages out there that can be used for data validation.
    We prefer to use Joi because it’s popular and easy to use. Joi is a popular open
    source package that provides a declarative way to define data schemas and perform
    validation against those schemas.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多包可以用于数据验证。我们更喜欢使用 Joi，因为它受欢迎且易于使用。Joi 是一个流行的开源包，它提供了一种声明式的方式来定义数据模式并对这些模式进行验证。
- en: it allows you to create JavaScript objects that represent the expected structure
    and data types for your application’s inputs (request body, query parameters,
    and so on).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你创建代表应用程序输入（请求体、查询参数等）预期结构和数据类型的 JavaScript 对象。
- en: It offers a wide range of validation rules for common data types such as strings,
    numbers, arrays, and objects. You can define rules for presence, format, length,
    and more.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它为常见的字符串、数字、数组和对象等数据类型提供了一系列验证规则。你可以定义存在性、格式、长度等规则。
- en: It integrates seamlessly with Express.js middleware, allowing you to validate
    data directly within your route handlers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 Express.js 中间件无缝集成，允许你在路由处理程序中直接验证数据。
- en: By separating validation logic from your route handlers, your code becomes cleaner
    and easier to understand.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将验证逻辑从你的路由处理程序中分离出来，你的代码变得更干净、更容易理解。
- en: Overall, Joi is a valuable tool for building robust and secure Node.js applications.
    By incorporating data validation with Joi, you can ensure that your application
    receives clean, reliable data, leading to a more stable and secure development
    experience.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Joi 是构建健壮和安全的 Node.js 应用程序的有价值工具。通过结合 Joi 进行数据验证，你可以确保你的应用程序接收干净、可靠的数据，从而带来更稳定和安全的开发体验。
- en: We’ll be using it in our application entry point (`src/index.js`).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序入口点 (`src/index.js`) 中使用它。
- en: Implementing the business layer
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现业务层
- en: The business layer is the heart of an N-layered architecture. It’s responsible
    for the core functionality of the application and implements the specific business
    rules that govern how the application operates. It translates user requests into
    actions and decisions based on the business rules. It also determines how data
    should be processed, validated, and manipulated to fulfill those requests. Furthermore,
    it acts as an intermediary between the presentation layer (user interface) and
    the data access layer (database). It receives data requests from the presentation
    layer, retrieves the necessary data from the data access layer, and then applies
    business logic before returning the processed data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层是 N 层架构的核心。它负责应用程序的核心功能，并实现了管理应用程序操作的具体业务规则。它将用户请求转换为基于业务规则的动作和决策。它还确定如何处理、验证和操作数据以满足这些请求。此外，它作为表示层（用户界面）和数据访问层（数据库）之间的中介。它从表示层接收数据请求，从数据访问层检索必要的数据，然后在返回处理后的数据之前应用业务逻辑。
- en: By separating business logic from the presentation and data access layers, the
    business layer promotes loose coupling and reusability. This makes the application
    easier to maintain, test, and modify as business needs evolve.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将业务逻辑与表示层和数据访问层分离，业务层促进了松散耦合和可重用性。这使得应用程序更容易维护、测试和修改，因为业务需求不断变化。
- en: 'We have a `services` folder under `src` to physically locate service functionalities.
    We mostly have five functions in `account.js` to cover the main operations related
    to CRUD: `getAccountById`, `getAllAccounts`, `createAccount`, `deleteAccountById`,
    and `updateAccountById`. Let’s look at the first four here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`src`下有一个`services`文件夹，用于物理定位服务功能。在`account.js`中，我们主要拥有五个函数来覆盖与CRUD相关的主要操作：`getAccountById`、`getAllAccounts`、`createAccount`、`deleteAccountById`和`updateAccountById`。让我们看看前四个：
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first four functions are easy to understand. Using `require`, we import
    our account from models. Then, we wrap our data access operations with business
    functions. The biggest function in this module is `updateAccountById`. Let’s take
    a closer look:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个函数很容易理解。使用`require`，我们从模型中导入我们的账户。然后，我们用业务函数包装我们的数据访问操作。这个模块中最大的函数是`updateAccountById`。让我们仔细看看：
- en: '[PRE7]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the end, we need to export the required code blocks so that they can be
    used by other services:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要导出所需的代码块，以便其他服务可以使用：
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have the following checks before updating our account information:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新我们的账户信息之前，我们有以下检查：
- en: Only allow an update to occur if one of the fields is provided.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当提供一个字段时才允许更新发生。
- en: Return an error if an invalid status code is provided.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了无效的状态代码，则返回错误。
- en: Return an error if an invalid type is provided.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了无效的类型，则返回错误。
- en: If the account for the given ID doesn’t exist, we need to return the error.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定ID的账户不存在，我们需要返回错误。
- en: 'We have some rules to update the status. First, `availableAccountStatusesForUpdate`
    describes the rules: if the status is `new`, then it can be updated to `active`
    or `blocked`. For `active`, it is possible to update to `inactive` and `blocked`.
    If the status is `inactive`, then only `active` is allowed. The `blocked` status
    can only be transitioned to `active`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些规则来更新状态。首先，`availableAccountStatusesForUpdate`描述了规则：如果状态是`new`，则可以更新为`active`或`blocked`。对于`active`，可以更新为`inactive`和`blocked`。如果状态是`inactive`，则只允许更新为`active`。`blocked`状态只能过渡到`active`。
- en: These are not all the possible validations you can implement, but they show
    how you can apply check logic to update functionality. In the end, we expose functions
    with error codes outside to be used by the preceding layer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是你可以实现的所有可能的验证，但它们展示了你可以如何应用检查逻辑来更新功能。最终，我们公开带有错误代码的函数供上层使用。
- en: Implementing the controller
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现控制器
- en: In a Node.js project using the MVC pattern, the controller acts as the central
    nervous system, handling user requests and coordinating the application’s response.
    It is the first point of contact for incoming requests from the user. It interprets
    the URL, HTTP method (`GET`, `POST`, and so on), and any parameters included in
    the request. The controller, by its nature, doesn’t implement the business logic
    itself; instead, it directs the flow of the application based on the request.
    It might interact with the model to retrieve or manipulate data, or it could perform
    some basic validation or processing before moving on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MVC模式的Node.js项目中，控制器充当中枢神经系统，处理用户请求并协调应用程序的响应。它是用户请求的第一个接触点。它解释URL、HTTP方法（`GET`、`POST`等）以及请求中包含的任何参数。控制器本质上不实现业务逻辑；相反，它根据请求指导应用程序的流程。它可能需要与模型交互以检索或操作数据，或者它可能在继续之前执行一些基本的验证或处理。
- en: The controller interacts with the model to get the data needed to fulfill the
    user’s request. This could involve fetching data from a database, performing calculations,
    or any other operations defined in the model layer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器与模型交互以获取满足用户请求所需的数据。这可能涉及从数据库中获取数据、执行计算或模型层中定义的任何其他操作。
- en: Once the controller has the data or has processed the request, it selects the
    appropriate view to render the response for the classical UI application. It might
    also prepare the data so that it can be consumed by the view, such as formatting
    it into a specific template. In our case, we don’t have a complete UI, and our
    JSON representation of data acts as a UI for us.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制器有了数据或处理了请求，它就会选择适当的视图来渲染经典UI应用程序的响应。它也可能准备数据，以便它可以被视图消费，例如将其格式化为特定的模板。在我们的情况下，我们没有完整的UI，我们的数据JSON表示充当我们的UI。
- en: Finally, the controller generates the response that gets sent back to the user.
    This could be an HTML page, JSON data for an API, or any other format suitable
    for the request.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，控制器生成响应并发送给用户。这可能是一个HTML页面，API的JSON数据，或任何适合请求的格式。
- en: In essence, the controller acts as a middleman, managing the communication flow
    between the user (through the view) and the data layer (through the model). It
    keeps the view and model separate, promoting cleaner code and easier maintenance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，控制器充当中间人，管理用户（通过视图）和数据层（通过模型）之间的通信流程。它保持视图和模型分离，促进更干净的代码和更易于维护。
- en: 'To implement a controller mechanism in our project, we need to create a folder
    called `controllers` under the `src` folder and add a new JavaScript file called
    `account.js`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的项目中实现控制器机制，我们需要在 `src` 文件夹下创建一个名为 `controllers` 的文件夹，并添加一个名为 `account.js`
    的新JavaScript文件：
- en: '[PRE9]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Things are straightforward when it comes to implementing retrieve (get), create,
    and delete accounts. However, we should consider some additional factors when
    we update our account information:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实现检索（get）、创建和删除账户时事情很简单。然而，当我们更新账户信息时，我们应该考虑一些额外的因素：
- en: First, `getAccounts` calls the `getallAcccounts` service function and returns
    `200` responses.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`getAccounts` 调用 `getallAcccounts` 服务函数并返回 `200` 响应。
- en: Then, `createAccount` calls the same named function from the service and returns
    `201`, which means the resource has been created.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`createAccount` 调用服务中同名函数并返回 `201`，这意味着资源已被创建。
- en: Finally, `deleteAccountById` calls the same named function from the service
    and returns `204`, which means success with no content. If the delete operation
    fails, it will return a `400` status code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`deleteAccountById` 调用服务中同名函数并返回 `204`，这意味着无内容的成功。如果删除操作失败，它将返回 `400` 状态码。
- en: 'Next, let’s take a look at the update implementation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看更新实现：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `updateAccountById` has a few more lines of code. Based on exported error
    codes, it prepares different HTTP status codes. If the provided data is valid,
    it returns a `200` success code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`updateAccountById` 有几行额外的代码。根据导出的错误代码，它准备不同的HTTP状态码。如果提供的数据有效，它将返回 `200`
    成功代码。
- en: 'We also have a simple function called `mapToResponse`. In Node.js, `mapToResponse`
    serves as a utility function to transform or map an account object to a specific
    format or structure that’s suitable for sending as a response, typically in an
    API. Here’s what it looks like:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为 `mapToResponse` 的简单函数。在Node.js中，`mapToResponse` 作为工具函数，用于将账户对象转换或映射到特定的格式或结构，这适合作为响应发送，通常在API中。下面是这个函数的样子：
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The only additional `private` function that we haven’t exported is `mapToResponse`.
    As you know, the user may not need to retrieve the whole account data structure.
    Using this function, we only return the required fields to the user as a response.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一未导出的 `private` 函数是 `mapToResponse`。正如您所知，用户可能不需要检索整个账户数据结构。使用此函数，我们只将所需的字段作为响应返回给用户。
- en: 'The final piece of code is retrieving the account by ID (`getAccountById`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分代码是通过ID检索账户 (`getAccountById`)：
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `getAccountById` redirects the query to the appropriate service and, based
    on the service’s response, returns a success or not found message.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`getAccountById` 将查询重定向到适当的服务，并根据服务的响应返回成功或未找到的消息。
- en: In the end, to use the main controller functions in the routing process, we
    must export them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在路由过程中使用主控制器函数，我们必须导出它们。
- en: Simple data validation for your API
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的API进行简单的数据验证
- en: Unvalidated data can lead to unexpected behavior, errors, and security vulnerabilities.
    Validation helps ensure that data received from users or external sources conforms
    to your application’s expectations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 未经验证的数据可能导致意外行为、错误和安全漏洞。验证有助于确保从用户或外部来源接收到的数据符合您的应用程序的期望。
- en: Malicious users might try to inject invalid or unexpected data into your application.
    Validation helps prevent these attacks by rejecting data that doesn’t adhere to
    the defined rules.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意用户可能会尝试将无效或意外的数据注入到您的应用程序中。验证通过拒绝不符合定义规则的数据来帮助防止这些攻击。
- en: By defining validation rules upfront, you can catch errors early in the development
    process, reducing debugging time and improving code maintainability.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提前定义验证规则，您可以在开发早期阶段捕获错误，减少调试时间并提高代码的可维护性。
- en: 'Let’s create a validation folder under `src` with the `account.js` file that
    contains the following lines of code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src` 下创建一个名为 `account.js` 的验证文件夹，其中包含以下代码行：
- en: '[PRE13]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s take a closer look at the code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看代码：
- en: After installing the `Joi` package, it is enough to specify it in the `require`
    command.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装完 `Joi` 包后，只需在 `require` 命令中指定它即可。
- en: The regular expression defines a rule to validate the ID. We’ll use this ID
    for `GET`, `PUT`, and `DELETE` operations.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式定义了一个验证ID的规则。我们将使用此ID进行`GET`、`PUT`和`DELETE`操作。
- en: '`const createAccount = { ... }`: This line declares a constant variable named
    `createAccount` and assigns an object literal to it. This object will hold the
    validation schema for creating an account.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const createAccount = { ... }`: 这行代码声明了一个名为`createAccount`的常量变量，并将其赋值为一个对象字面量。此对象将包含创建账户的验证模式。'
- en: '`body`: This property name specifies that the validation schema applies to
    the request body (typically, data sent in the body of a `POST` request).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`: 此属性名指定验证模式适用于请求体（通常，在`POST`请求的体中发送的数据）。'
- en: '`Joi.object()`: This creates a Joi object schema that validates the structure
    (presence of specific properties) of the request body.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Joi.object()`: 这将创建一个Joi对象模式，用于验证请求体的结构（特定属性的必要性）。'
- en: '`.keys({ ... })`: This defines the set of properties to be expected in the
    request body and their corresponding validation rules.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.keys({ ... })`: 这定义了请求体中预期存在的属性集及其相应的验证规则。'
- en: '`name: Joi.string().required()`: This validates the presence of a property
    named `name` and ensures it’s a string value. The `.required()` part makes it
    mandatory.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name: Joi.string().required()`: 这验证了名为`name`的属性的必要性，并确保它是一个字符串值。`.required()`部分使其成为必填项。'
- en: '`number: Joi.string().required()`: Similar to `name`, this validates a required
    string property named `number`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number: Joi.string().required()`: 与`name`类似，这验证了一个名为`number`的必需字符串属性。'
- en: '`status: Joi.string().valid(''new'', ''active'', ''completed'', ''cancelled'').optional()`:
    This validates an optional string property named `status`. The `.valid()` method
    restricts the allowed values to `''new''`, `''active''`, `''completed''`, and
    `''cancelled''`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status: Joi.string().valid(''new'', ''active'', ''completed'', ''cancelled'').optional()`:
    这验证了一个名为`status`的可选字符串属性。`.valid()`方法限制了允许的值为`''new''`、`''active''`、`''completed''`和`''cancelled''`。'
- en: '`type: Joi.string().valid(''root'', ''sub'').optional()`: Similar to `status`,
    this validates an optional string property named `type` with allowed values of
    `''root''` and `''sub''`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type: Joi.string().valid(''root'', ''sub'').optional()`: 与`status`类似，这验证了一个名为`type`的可选字符串属性，其允许的值为`''root''`和`''sub''`。'
- en: 'In general, the preceding code ensures that a request to create an account
    must include the following properties:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，前面的代码确保创建账户的请求必须包含以下属性：
- en: '`name`: Required string value'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 必需的字符串值'
- en: '`number`: Required string value'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`: 必需的字符串值'
- en: '`status`: An optional string value that is either `''new''`, `''active''`,
    `''completed''`, or `''cancelled''`'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 可选的字符串值，可以是`''new''`、`''active''`、`''completed''`或`''cancelled''`'
- en: '`type`: An optional string value that is either `''root''` or `''sub''`'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 可选的字符串值，可以是`''root''`或`''sub''`'
- en: 'By using this schema, you can guarantee that the data that’s received for creating
    an account adheres to the expected format and prevents unexpected or invalid data
    from entering your application:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用此模式，您可以确保接收到的创建账户数据符合预期的格式，并防止意外或无效的数据进入您的应用程序：
- en: '[PRE14]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `updateAccountById` object specifies that the parameters must include an
    `id` parameter, which is required and must be a valid object ID. The `body` part
    of the request must contain `name` and `number` fields, both of which are required
    strings, and optionally a `status` field that can only be one of the specified
    values `('new'`, `'active'`, `'completed'`, or `'cancelled'`) and a `type` field
    that can be either `'root'` or `'sub'`. This validation ensures that incoming
    requests to update an account adhere to the expected format and data types. In
    the end, to use these rules, we need to export them using `module.exports`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateAccountById`对象指定参数必须包括一个`id`参数，该参数是必需的，并且必须是一个有效的对象ID。请求的`body`部分必须包含`name`和`number`字段，这两个字段都是必需的字符串，并且可选的`status`字段只能为指定的值之一（`''new''`、`''active''`、`''completed''`或`''cancelled''`），以及一个`type`字段，可以是`''root''`或`''sub''`。此验证确保传入的更新账户请求符合预期的格式和数据类型。最后，为了使用这些规则，我们需要使用`module.exports`导出它们。'
- en: 'We have another module related to data validation that’s placed in the `middleware`
    folder under the `src` folder. `validate.js` file with the following content:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个与数据验证相关的模块，位于`src`文件夹下的`middleware`文件夹中。`validate.js`文件包含以下内容：
- en: '[PRE15]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If an error exists, the middleware extracts individual error messages using
    `error.details.map(...)` and joins them into a comma-separated string (`errorMessage`).
    A `400 Bad Request` response is sent with the error message in JSON format.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在错误，中间件使用 `error.details.map(...)` 提取单个错误消息，并将它们合并成一个以逗号分隔的字符串（`errorMessage`）。然后发送一个包含错误消息的
    JSON 格式的 `400 Bad Request` 响应。
- en: If validation passes (`!error`), the validated data (value) obtained from Joi
    is attached to the `req` object using `Object.assign`. This makes the validated
    data readily available in subsequent route handlers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证通过（`!error`），则使用 `Object.assign` 将从 Joi 获得的验证数据（值）附加到 `req` 对象上。这使得验证数据在后续的路由处理器中易于访问。
- en: This middleware acts as a gatekeeper for your routes, ensuring that incoming
    requests adhere to the provided validation schema.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件充当你的路由守门人，确保传入的请求符合提供的验证模式。
- en: Implementing routing
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现路由
- en: '**Routing** is a fundamental aspect of building web applications with Node.js
    and Express. It essentially directs incoming HTTP requests to the appropriate
    handlers within your application.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由** 是使用 Node.js 和 Express 构建网络应用程序的基本方面。它本质上将传入的 HTTP 请求定向到应用程序中的适当处理器。'
- en: Routing allows you to define a clear separation between URLs (endpoints) and
    the code that handles them. This promotes modularity and makes your code base
    more readable and manageable.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 路由允许你定义 URL（端点）和处理它们的代码之间的清晰分离。这促进了模块化，并使你的代码库更易于阅读和管理。
- en: It also enables you to define handlers specific to each HTTP method for a particular
    URL. This allows you to handle requests for retrieving data (`GET`), submitting
    data (`POST`), updating data (`PUT`), or deleting data (`DELETE`) appropriately.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许你为特定 URL 定义针对每个 HTTP 方法的特定处理器。这允许你适当地处理获取数据（`GET`）、提交数据（`POST`）、更新数据（`PUT`）或删除数据（`DELETE`）的请求。
- en: By defining routes that map to resources and corresponding HTTP methods, you
    can establish a well-structured and predictable API that other applications can
    interact with.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义映射到资源和相应 HTTP 方法的路由，你可以建立一个结构良好且可预测的 API，其他应用程序可以与之交互。
- en: As your application evolves, routing helps you easily add new features and functionalities.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序的发展，路由可以帮助你轻松地添加新功能和功能。
- en: You can create separate route handlers for new features, keeping your code base
    organized and scalable.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为新功能创建单独的路由处理器，保持你的代码库有组织且可扩展。
- en: Routing also allows you to group related routes, promoting the reusability of
    code across different parts of your application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 路由还允许你将相关的路由分组，促进代码在应用程序不同部分的复用。
- en: In simpler terms, routing acts like a traffic controller for your application,
    directing incoming requests to the designated destinations (handlers) based on
    their URLs and HTTP methods. This keeps your code organized and maintainable and
    enables you to build robust and scalable web applications and APIs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，路由就像是你应用程序的交通控制器，根据它们的 URL 和 HTTP 方法将传入的请求定向到指定的目的地（处理器）。这保持了你的代码的组织性和可维护性，并使你能够构建健壮且可扩展的
    Web 应用程序和 API。
- en: We have a `routes` folder under the `src` folder where we define all the routing
    rules for our application. Currently, it is our first version, so the `v1` folder
    indicates the first version of our API. **Versioning** allows you to introduce
    changes while maintaining compatibility with existing clients.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `src` 文件夹下有一个 `routes` 文件夹，其中定义了我们应用程序的所有路由规则。目前，这是我们的第一个版本，所以 `v1` 文件夹表示我们
    API 的第一个版本。**版本控制**允许你在保持与现有客户端兼容性的同时引入更改。
- en: Let’s add the `accounts` folder and the `index.js` file to our `v1` folder and
    define our routing rules.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `accounts` 文件夹和 `index.js` 文件添加到我们的 `v1` 文件夹中，并定义我们的路由规则。
- en: 'The full path to the file will be `src/routers/v1/accounts/index.js`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的完整路径将是 `src/routers/v1/accounts/index.js`：
- en: '[PRE16]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Express.js provides routing functionality. Using it, we’ve defined the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 提供了路由功能。使用它，我们定义了以下内容：
- en: Users can *get* an account by ID using `/accounts/:id`
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以使用 `/accounts/:id` 通过 ID *获取* 一个账户
- en: Users can *create* a new account by sending a `POST` request to `/accounts`
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过向 `/accounts` 发送 `POST` 请求来 *创建* 一个新账户
- en: Users can *update* an account by ID sending a `PUT` request to `/accounts/:id`
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过向 `/accounts/:id` 发送 `PUT` 请求来 *更新* 一个账户
- en: Users can *delete* an account by ID sending a `DELETE` request to `/accounts/:id`
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过向 `/accounts/:id` 发送 `DELETE` 请求来 *删除* 一个账户
- en: The validation middleware ensures that requests adhere to the expected format
    before reaching the controller functions, which handle the actual account management
    logic.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 验证中间件确保请求在到达处理实际账户管理逻辑的控制函数之前符合预期的格式。
- en: As you might have guessed, we don’t have any indicator for our route to be used
    with the `/``accounts` prefix.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，我们没有任何指示符来表示我们的路由需要使用 `/accounts` 前缀。
- en: 'We need one more JavaScript file to handle this. Let’s create `index.js` under
    the `routes/v1` folder with the following implementation:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个 JavaScript 文件来处理这个问题。让我们在 `routes/v1` 文件夹下创建一个名为 `index.js` 的文件，并使用以下实现：
- en: '[PRE17]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we’ll be able to navigate to our resource using the `/``accounts` prefix.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够使用 `/accounts` 前缀导航到我们的资源。
- en: Constructing our web application
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的 Web 应用程序
- en: Now, it’s time to define our basic structure for a Node.js application using
    the Express.js framework.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用 Express.js 框架为 Node.js 应用程序定义基本结构了。
- en: 'Let’s create an `app.js` file under the `src` folder with the following code
    structure:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src` 文件夹下创建一个名为 `app.js` 的文件，并使用以下代码结构：
- en: '[PRE18]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code snippet defines a basic structure for building our web application:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段定义了构建我们 Web 应用程序的基本结构：
- en: '`const express = require(''express'');`: This line imports the Express.js framework,
    providing functionalities for building web servers and handling HTTP requests
    and responses.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const express = require(''express'');`：这一行导入 Express.js 框架，提供了构建 Web 服务器和处理
    HTTP 请求和响应的功能。'
- en: '`const v1 = require(''./routes/v1'');`: This line imports a module named `v1.js`
    located in a folder named `routes/v1`. This module defines routes (URL paths)
    for version 1 of your application’s API.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const v1 = require(''./routes/v1'');`：这一行导入一个名为 `v1.js` 的模块，该模块位于名为 `routes/v1`
    的文件夹中。该模块定义了应用程序 API 第 1 版的路由（URL 路径）。'
- en: '`const app = express();`: This line creates an instance of the Express application
    using the `express()` function. This `app` object will be used to define routes
    and middleware, as well as handle application logic.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const app = express();`：这一行使用 `express()` 函数创建 Express 应用程序的实例。这个 `app` 对象将用于定义路由和中间件，以及处理应用程序逻辑。'
- en: '`.use(express.json())`: This line registers a middleware function with the
    Express application. The `express.json()` middleware parses incoming JSON data
    in request bodies, making it accessible in your route handlers.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.use(express.json())`：这一行将一个中间件函数注册到 Express 应用程序中。`express.json()` 中间件解析请求体中的
    JSON 数据，使其在路由处理程序中可用。'
- en: '`.use(''/v1'', v1);`: This line is crucial for routing. It mounts the routes
    defined in the imported `v1` module onto the `/v1` path of your application. Any
    requests to URLs starting with `/v1` will be handled by the functions in the `v1`
    module.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.use(''/v1'', v1);`：这一行对于路由至关重要。它将导入的 `v1` 模块中定义的路由挂载到应用程序的 `/v1` 路径上。任何以
    `/v1` 开头的 URL 请求都将由 `v1` 模块中的函数处理。'
- en: '`module.exports = app;`: This line exports the `app` object, which is the core
    of your Express application. This allows other modules in your project to import
    and use this application instance.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.exports = app;`：这一行导出 `app` 对象，这是你的 Express 应用程序的核心。这允许项目中的其他模块导入和使用这个应用程序实例。'
- en: In essence, this code creates an Express application, configures middleware
    for JSON handling, mounts routes from a separate module for version 1 of your
    API, and makes the application instance available for import by other parts of
    your project.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这段代码创建了一个 Express 应用程序，配置了用于处理 JSON 的中间件，挂载了用于 API 第 1 版的单独模块中的路由，并使应用程序实例可供项目其他部分导入和使用。
- en: Combining all the elements
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合所有元素
- en: The final step in our application is to construct everything together, like
    using Lego. This Lego is going to be a main runnable application that will help
    us to communicate between elements of our application.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的最终步骤是将所有内容组合在一起，就像使用乐高积木一样。这个乐高积木将是一个可运行的主体应用程序，它将帮助我们实现应用程序元素之间的通信。
- en: 'Let’s create an `index.js` file under the `src` folder that contains the following
    code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src` 文件夹下创建一个包含以下代码的 `index.js` 文件：
- en: '[PRE19]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This Node.js code defines an asynchronous function named `execute` that serves
    as the entry point for your application. Here’s a breakdown of its functionality:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Node.js 代码定义了一个名为 `execute` 的异步函数，它作为应用程序的入口点。以下是其功能分解：
- en: '`const path = require(''path'');`: Imports the `path` module for manipulating
    file paths'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const path = require(''path'');`：导入 `path` 模块以操作文件路径。'
- en: '`const db = require(''./db'');`: Imports the `db` module, likely containing
    functions for connecting and interacting with your database'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const db = require(''./db'');`: 导入`db`模块，可能包含连接和与数据库交互的函数'
- en: '`const app = require(''./app'');`: Imports the main application module, likely
    containing the Express application instance and your application logic'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const app = require(''./app'');`: 导入主应用程序模块，可能包含Express应用程序实例和应用程序逻辑'
- en: '`const { createConfig } = require(''./config/config'');`: Imports the `createConfig`
    function from the `config/config.js` module, likely responsible for creating your
    application configuration'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const { createConfig } = require(''./config/config'');`: 从`config/config.js`模块导入`createConfig`函数，可能负责创建应用程序配置'
- en: '`async function execute() { ... }`: Defines an asynchronous function named
    `execute` that will be executed when the script starts*   `const configPath =
    path.join(__dirname, ''../configs/.env'');`: Uses the `path` module to construct
    the absolute path to your configuration file (likely a `.env` file) two directories
    above the current script’s location*   `const appConfig = createConfig(configPath);`:
    Calls the imported `createConfig` function with the configuration file path, presumably
    to read and parse the configuration settings*   `await db.connect(appConfig);`:
    Attempts to connect to the database using the `db` module and the loaded configuration
    (`appConfig`) object. This line is asynchronous, so the function waits for the
    connection to be established before proceeding.*   `const server = app.listen(appConfig.port,
    ...);`: Calls a method (likely `listen`) on the imported `app` object, which is
    probably an Express application. This starts the server listening on the port
    specified in the configuration (`appConfig.port`). The callback function logs
    a message when the server starts successfully.*   `const closeServer = () => {
    ... }`: Defines an arrow function named `closeServer` that gracefully shuts down
    the server. It checks whether the server object exists and then calls its `close`
    method. The callback function for `close` logs a message when the server is closed
    and exits the process with an exit code of `1`.*   `const unexpectedError = (error)
    => { ... }`: Defines an arrow function named `unexpectedErrorHandler` that handles
    uncaught errors or unhandled promise rejections. It logs the error message. It
    calls the `closeServer` function to gracefully shut down the server*   `process.on(''uncaughtException'',
    unexpectedError);`: Attaches the `unexpectedErrorHandler` function to the `uncaughtException`
    event of the `process` object. This ensures that any errors thrown outside of
    an `async` function or promise chain are caught and handled.*   `process.on(''unhandledRejection'',
    unexpectedError);`: Attaches the `unexpectedErrorHandler` function to the `unhandledRejection`
    event of the `process` object. This ensures that any unhandled rejections from
    promises are caught and handled.*   `execute();`: Calls the `execute` function
    to start the application. Since `execute` is asynchronous, the entire application
    startup process becomes asynchronous, ensuring the database connection and server
    startup are completed before the application continues.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async function execute() { ... }`: 定义一个名为`execute`的异步函数，当脚本启动时执行*   `const
    configPath = path.join(__dirname, ''../configs/.env'');`: 使用`path`模块构建到配置文件（可能是一个`.env`文件）的绝对路径，该文件位于当前脚本位置的上两个目录中*   `const
    appConfig = createConfig(configPath);`: 使用配置文件路径调用导入的`createConfig`函数，可能用于读取和解析配置设置*   `await
    db.connect(appConfig);`: 尝试使用`db`模块和加载的配置（`appConfig`）对象连接到数据库。此行是异步的，因此函数在继续之前等待连接建立*   `const
    server = app.listen(appConfig.port, ...);`: 调用导入的`app`对象上的方法（可能是`listen`），该对象可能是Express应用程序。这将在配置中指定的端口上启动服务器（`appConfig.port`）。当服务器成功启动时，回调函数记录一条消息*   `const
    closeServer = () => { ... }`: 定义一个名为`closeServer`的箭头函数，用于优雅地关闭服务器。它检查服务器对象是否存在，然后调用其`close`方法。`close`的回调函数在服务器关闭时记录一条消息并退出进程，退出代码为`1`.*   `const
    unexpectedError = (error) => { ... }`: 定义一个名为`unexpectedErrorHandler`的箭头函数，用于处理未捕获的错误或未处理的承诺拒绝。它记录错误消息。它调用`closeServer`函数以优雅地关闭服务器*   `process.on(''uncaughtException'',
    unexpectedError);`: 将`unexpectedErrorHandler`函数附加到`process`对象的`uncaughtException`事件。这确保了任何在`async`函数或承诺链之外抛出的错误都被捕获和处理*   `process.on(''unhandledRejection'',
    unexpectedError);`: 将`unexpectedErrorHandler`函数附加到`process`对象的`unhandledRejection`事件。这确保了任何来自承诺的未处理拒绝都被捕获和处理*   `execute();`:
    调用`execute`函数以启动应用程序。由于`execute`是异步的，整个应用程序启动过程变为异步，确保在应用程序继续之前数据库连接和服务器启动已完成。'
- en: In summary, this code sets up the application configuration, connects to the
    database, starts the server, and implements error handling for a robust and graceful
    startup and shutdown process.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，此代码设置了应用程序配置，连接到数据库，启动服务器，并实现了健壮且优雅的启动和关闭过程。
- en: Running and testing our first microservice
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和测试我们的第一个微服务
- en: 'We’re not going to write any unit or integrate tests in this chapter. In [*Chapter
    11*](B09148_11.xhtml#_idTextAnchor174), where we’ll dive into the details of those
    topics. For this chapter, we’ll do manual testing via Postman. To run our application,
    follow these steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中不会编写任何单元或集成测试。在[*第11章*](B09148_11.xhtml#_idTextAnchor174)中，我们将深入了解这些主题的细节。对于本章，我们将通过Postman进行手动测试。要运行我们的应用程序，请按照以下步骤操作：
- en: Download `Ch05` from our GitHub repository.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的GitHub仓库下载`Ch05`。
- en: Open the project (`Ch05`) via Visual Studio Code.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Visual Studio Code打开项目（`Ch05`）。
- en: Go to **Terminal** | **New Terminal**.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**终端** | **新建终端**。
- en: Run the `npm install` command from the `Ch05` folder to load the required packages.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Ch05`文件夹运行`npm install`命令以加载所需的包。
- en: Change directories to `src` (using the `cd` `src` command).
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`src`目录（使用`cd src`命令）。
- en: Run the `node index.js` command. Mongo should be installed before you run this
    command. Check out [*Chapter 4*](B09148_04.xhtml#_idTextAnchor056) for more information
    about the installation process for Mongo.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`node index.js`命令。在运行此命令之前，Mongo应该已经安装。查看[*第4章*](B09148_04.xhtml#_idTextAnchor056)以获取有关Mongo安装过程的更多信息。
- en: Open Postman.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Postman。
- en: In the next few subsections, we’ll test our endpoints one by one.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将逐一测试我们的端点。
- en: Creating a new account
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新账户
- en: 'To create a new account, follow these steps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新账户，请按照以下步骤操作：
- en: Create a new tab in Postman.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中创建一个新标签页。
- en: Select `POST` from **HTTP verbs**.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HTTP动词**中选择`POST`。
- en: Type `localhost:3001/v1/accounts` in the **URL** section.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**URL**部分输入`localhost:3001/v1/accounts`。
- en: 'Go to the `raw` and change `Text` to `JSON`. Add the following JSON to the
    text area:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`raw`并将`Text`更改为`JSON`。将以下JSON添加到文本区域：
- en: '[PRE20]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮以发送请求。您将从端点获得以下响应：
- en: '[PRE21]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let’s get the account by ID.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过ID获取账户。
- en: Getting an account by ID
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ID获取账户
- en: 'To get an account with the given ID, follow these steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取具有给定ID的账户，请按照以下步骤操作：
- en: Create a new tab in Postman.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中创建一个新标签页。
- en: Select `GET` from **HTTP verbs**.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HTTP动词**中选择`GET`。
- en: Type `localhost:3001/v1/accounts/{accountID}` in the `662c081370bd2ba6b5f04e94`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`662c081370bd2ba6b5f04e94`中输入`localhost:3001/v1/accounts/`。
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮以发送请求。您将从端点获得以下响应：
- en: '[PRE22]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let’s learn how to update our existing account.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何更新我们现有的账户。
- en: Updating an account by ID
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ID更新账户
- en: 'To update your given account, follow these steps:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新指定的账户，请按照以下步骤操作：
- en: Create a new tab in Postman.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中创建一个新标签页。
- en: Select `PUT` from **HTTP verbs**.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HTTP动词**中选择`PUT`。
- en: Type `localhost:3001/v1/accounts/{accountID}` in the URL section.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在URL部分输入`localhost:3001/v1/accounts/{accountID}`。
- en: 'Go to the `raw` and change `Text` to `JSON`. Add the following JSON to the
    text area:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`raw`并将`Text`更改为`JSON`。将以下JSON添加到文本区域：
- en: '[PRE23]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮以发送请求。您将从端点获得以下响应：
- en: '[PRE24]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For most of the APIs, we usually want to retrieve all data. Next, we’ll learn
    how to get all account information.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数API，我们通常希望检索所有数据。接下来，我们将学习如何获取所有账户信息。
- en: Gettings all accounts
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取所有账户
- en: 'To retrieve all accounts, follow these steps:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索所有账户，请按照以下步骤操作：
- en: Create a new tab in Postman.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中创建一个新标签页。
- en: Select `GET` from **HTTP verbs**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HTTP动词**中选择`GET`。
- en: Type `localhost:3001/v1/accounts` in the **URL** section.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**URL**部分输入`localhost:3001/v1/accounts`。
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**按钮以发送请求。您将从端点获得以下响应：
- en: '[PRE25]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The final endpoint involves deleting the account. Let’s check it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最终端点涉及删除账户。让我们检查一下。
- en: Deleting account by ID
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ID删除账户
- en: 'Finally, to delete your already existing account by its ID, follow these steps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要按其ID删除已存在的账户，请按照以下步骤操作：
- en: Create a new tab in Postman.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中创建一个新标签页。
- en: Select `DELETE` from **HTTP verbs**.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HTTP动词**中选择`DELETE`。
- en: Type `localhost:3001/v1/accounts/{accountID}` in the **URL** section. Provide
    the valid **accountID** value to delete the record.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**URL**部分输入`localhost:3001/v1/accounts/{accountID}`。提供有效的**accountID**值以删除记录。
- en: Click the `204 no-content` response from the endpoint.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击端点返回的`204 no-content`响应。
- en: With that, we have fully functional CRUD endpoints for accounts. We may not
    have a complex business case, but the purpose of this chapter was to show you
    how to implement endpoints for your microservices.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就为账户有了完全功能的CRUD端点。我们可能没有复杂的企业案例，但本章的目的是向您展示如何为您的微服务实现端点。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created our first microservice. This was our first practical
    chapter about creating microservices. For this, having a clear understanding of
    your requirements is important. We provided simple requirements to make our first
    microservice more understandable and easy to follow. There, we learned how to
    set up our project. We talked about the tools we need to develop our first microservice;
    before every microservice development process can be undertaken, we need to define
    which tools and technologies we plan to use. We also created our internal structure
    using MVC and N-layered architecture. These are the most popular choices, so using
    them for your first development project is a great chance for you to learn popular
    techniques. The practical aspect of this chapter covered creating models, business
    logic, and controllers. There, we learned about the basics of validation using
    the JOI package. The application requires a separate file to store configuration,
    hence why we used the `dotenv` package. We also learn about routing, which is
    important if we wish to access our functionalities. Then, we integrated routing
    using Express.js.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了我们的第一个微服务。这是我们关于创建微服务的第一个实践章节。为此，对您的需求有清晰的理解很重要。我们提供了简单的需求，以便我们的第一个微服务更容易理解和跟随。在那里，我们学习了如何设置我们的项目。我们讨论了开发我们的第一个微服务所需的工具；在开始每个微服务开发过程之前，我们需要定义我们计划使用的工具和技术。我们还使用MVC和N层架构创建了我们的内部结构。这些是最受欢迎的选择，因此，在您的第一个开发项目中使用它们是您学习流行技术的绝佳机会。本章的实践方面涵盖了创建模型、业务逻辑和控制器。在那里，我们学习了使用JOI包进行验证的基本知识。应用程序需要一个单独的文件来存储配置，因此我们使用了`dotenv`包。我们还学习了路由，这对于我们希望访问我们的功能来说很重要。然后，我们使用Express.js集成了路由。
- en: In the end, we learned how to check our functionalities using Postman. In the
    upcoming chapters, we will delve into the development of a second microservice,
    focusing on establishing synchronous communication between microservices. We will
    introduce a new stack for the transaction microservice, using tools like NestJS,
    Prisma, and Axios, to demonstrate the versatility of JavaScript in microservice
    development.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用Postman检查我们的功能。在接下来的章节中，我们将深入探讨第二个微服务的开发，重点关注微服务之间的同步通信。我们将为事务微服务引入一个新的堆栈，使用NestJS、Prisma和Axios等工具，以展示JavaScript在微服务开发中的多功能性。
