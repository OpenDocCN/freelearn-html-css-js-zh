- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic CRUD Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our previous chapters are proof that microservices development is not just about
    implementation. You need to at least have a clear understanding of the pros and
    cons of using microservices compared with other approaches we looked at in the
    previous chapters – monolith and service-oriented – and you need to have an essential
    understanding of the technologies you want to apply when building microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Applying all theoretical knowledge you have in practice is also not an easy
    task. This chapter will help us to apply microservices in practice and is one
    step forward to real-world microservices implementation. In this chapter, we plan
    to provide a solid foundation for further practical chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a microservice approach in your project means that you mostly have
    a complex business domain and the conceptual boundary of your microservice requires
    you to implement a part of this complex logic. It indicates that microservice
    development is more than **Create**, **Retrieve/Read**, **Update**, **Delete**
    (**CRUD**) but to have a basic understanding of the microservice application structure,
    this chapter is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding business requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools to develop a basic microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing our first project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the internal architecture of our microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on account microservice development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and testing our first microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get into it!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop and test our first microservice, we’ll need the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: An IDE of your choice (we prefer Visual Studio Code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A browser of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s recommended that you download this book’s GitHub repository from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)
    folder to easily follow our code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding business requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you jump into building microservices with JavaScript, it’s important
    to clearly understand what your services need to do. Then, based on what your
    project requires, you can pick the right tools to help you create those microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The team doesn’t consist of only developers. The business domain people are
    also an integral part of the team when it comes to building business valuable
    applications. In software development, the final and main artifact is code and
    it should reflect the real business. Applying domain language that everyone speaks
    will make your code a valuable source of truth and it is only possible if you
    have zero translation between business and developers. The most popular approach
    to developing such types of microservices with a single language that everyone
    speaks is **Domain-driven Design** (**DDD**). Everyone in a team should use the
    same language that describes the business in a given boundary. This is called
    **Ubiquitous Language** (**UL**). Using UL, everyone in a team will speak the
    same language and the language will be reflected in your code. It means business
    helps your design and developers help businesses to have more clearer understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout our learning process, we’ll mention some ideas from DDD, despite
    this not being a DDD book. Please refer to *Implementing Domain-Driven Design*,
    by Vaugh Vernon, and *Domain-Driven Design: Tackling Complexity in the Heart of
    Software*, by Eric Evans, to learn more.'
  prefs: []
  type: TYPE_NORMAL
- en: This book is not about analyzing and gathering the business requirements. There
    are really good sources out there that focus exactly on this topic. To make things
    simple and less theoretical, we’ll start with distilled requirements with clear
    boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build an account building microservice that requires the following
    *core functionalities*:'
  prefs: []
  type: TYPE_NORMAL
- en: Create account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all account information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get an account for the given ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete unused account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we have the following *non-functional* requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: The microservice should be able to handle more and more requests
    as it gets used by more people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: The microservice should respond to requests quickly to keep
    users happy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: The microservice should be able to bounce back from problems
    and keep working properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy testing**: The microservice should be simple to test to make sure it’s
    working correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: The microservice shouldn’t rely on remembering past interactions
    with users, and should instead store any important information in a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy updates**: The microservice should be straightforward to put to use
    and update whenever needed. Of course, usually, you’ll have more non-functional
    requirements than these. However, for getting started, these should be more than
    enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools to develop a basic microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developing an application is not just a coding process. In this chapter, to
    develop our microservice, we also need to select the Node.js framework and store
    information in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database**: We need to store information somewhere. It’s better to keep the
    service itself simple and store the information in a separate database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this service, we’ll be using *MongoDB*, a popular database that works differently
    than traditional SQL databases. MongoDB is a popular choice for building web services
    with Node.js technology.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s designed to handle situations where users mostly read information, and
    it can store a lot of data efficiently. MongoDB can be easily expanded by adding
    more servers as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Node.js framework**: You can build a fully functional microservice using
    just Node.js but it takes some time and a lot of lines of code. Nowadays, most
    developers use the Node.js frameworks to build services fast with a minimal amount
    of code lines. Node.js on its own is a low-level environment. Frameworks provide
    a predefined structure and organization for your code, making it easier to manage
    and maintain as your project grows. They often come with common functionalities
    such as *routing* (handling different URL requests), *templating* (generating
    web page content), and database interaction already built-in. This saves you time
    from writing those parts yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular Node.js frameworks have large communities of developers. This means
    you have access to a wealth of resources, tutorials, and solutions online if you
    encounter problems. There’s also a bigger pool of developers familiar with the
    framework for potential collaboration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Frameworks can help mitigate security vulnerabilities by providing established
    coding practices and features to prevent common attacks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this chapter, we’re going to use *Express.js*, one of the most popular Node.js
    frameworks for building microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our first project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our focus in this chapter is to create a microservice that provides really simple
    CRUD operations. So, it’s going to be mostly domain-centric. That’s why we start
    our application from the database.
  prefs: []
  type: TYPE_NORMAL
- en: To follow our examples, open the `Ch05` folder in this book’s GitHub repository
    and open it using your favorite text editor.
  prefs: []
  type: TYPE_NORMAL
- en: '*There’s a difference between knowing the path and walking* *the path.*'
  prefs: []
  type: TYPE_NORMAL
- en: We prefer that you don’t just download and explore the repository and that you
    also try to write some code with us. This will help you gain valuable practice.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concept of packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building software doesn’t mean that you should implement everything from scratch
    and this fact doesn’t depend on programming languages. It is also applicable for
    Node.js development. Our main focus should always be solving business problems
    and making this process fast, easy, secure, and reliable. Almost every popular
    programming language provides a collection of libraries. In Node.js, these are
    called **packages**. Node.js development mostly starts with package configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When you install Node.js, you automatically install the `npm` a great and reliable
    source for development. For example, if you need validation for your application,
    you shouldn’t build everything from scratch. Why not use popular practices that
    have already been implemented in popular libraries? We mostly build only business-specific
    functionalities by ourselves. Other relevant functionalities, such as connecting
    to the database, validation, security, logging, and more, can be installed as
    packages and reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can interact with `npm` and configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite text editor (we’re using Visual Studio Code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder (in our case, `Ch05`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to that folder using your terminal (Use `cd folder_name` command to
    navigate to your empty folder – that is, use `cd Ch05`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `npm init` and follow the instructions provided (*Figure 5**.1*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1: Creating a package.json file](img/B09148_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Creating a package.json file'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Enter* to generate **package** **configuration** (*package.json*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we have a special file called `package.json` in our project
    with the following JSON content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For learning purposes, it is also OK to use the `npm init -y` command instead
    of `npm init` as it will generate a minimal `package.json` file for you to get
    started with (*Figure 5**.2*). After generation, you can manually update any line
    you want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2: Generated package.json file](img/B09148_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Generated package.json file'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn more about the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the package.json file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `package.json` file is a vital component in Node.js projects. It acts like
    a project manifest, storing crucial information about your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize the role of the `package.json` file in our Node.js projects:'
  prefs: []
  type: TYPE_NORMAL
- en: It lists all the external modules (dependencies) your project relies on to function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with the names, it specifies the required versions using semantic versioning
    for compatibility. This ensures that everyone working on the project uses the
    same compatible versions of dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It serves as a central location for project metadata, such as the project’s
    name, version, description, license, and author information (see *Figure 5**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define custom scripts in the `package.json` file to automate repetitive
    tasks within your project. These scripts can do anything from starting the development
    server to running tests or building the project for deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you plan to publish your project as a reusable package for others to use,
    `package.json` becomes even more important. It provides essential information
    for the package manager (such as `npm`) to understand how to install and use your
    project effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long story short, `package.json` keeps your project organized, ensures consistent
    dependencies, and simplifies collaboration among developers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding index.js files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ll encounter files named `index.js`. These files
    play a couple of important roles.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, `index.js` acts as the entry point for our Node.js application.
    When we run our application using node, the `index.js` file is the starting point
    where the application’s execution begins.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `index.js`, you can typically find code that imports necessary modules
    and libraries using the required statements to configure your application (for
    example, setting up a web server and connecting to databases) and defines the
    main logic or event listeners for your application.
  prefs: []
  type: TYPE_NORMAL
- en: These files can also serve for namespacing and organization within your project.
    Consider a folder containing multiple JavaScript files with related functionalities.
    An `index.js` file inside that folder can act as a central point for importing
    those related files and re-exporting specific functions or classes from those
    files, making them accessible outside the folder using a single import statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that `index.js` is a convention, not a strict requirement.
    You can name your entry point file differently (for example, `app.js` or `main.js`).
    So long as you specify the correct filename when you’re running your application
    with node, it will work.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `index.js` files serve as a common entry point and a way to organize
    code within folders in your Node.js projects. They provide a clean and consistent
    approach to structuring your application’s starting point and managing related
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By itself, `package.json` doesn’t contain any required package that we plan
    to use by default. It is just boilerplate for getting started. Here’s a list of
    packages that we’ll be using in this chapter, along with their installation commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Express ( `npm` `install express`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joi ( `npm` `install joi`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mongoose ( `npm` `install mongoose`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dotenv ( `npm install` `dotenv –save`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s what the `package.json` file’s dependencies and `devDependencies` look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve probably already realized that, when installing our first package, the
    node automatically generates another file called `package-lock.json`. Let’s summarize
    its roles:'
  prefs: []
  type: TYPE_NORMAL
- en: It acts as a lock file, specifying the exact versions of packages and their
    dependencies that were installed. This guarantees that regardless of who installs
    the project or on what machine, the same set of versions will be used, leading
    to consistent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: By locking down versions, `package-lock.json` enables developers to reproduce
    the project’s environment exactly. This is essential for maintaining stability
    and avoiding unexpected issues during deployments or across different development
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: When shared within a team or used in `package-lock.json` ensures everyone involved
    is working with the same dependencies. This streamlines collaboration and automates
    reliable builds.
  prefs: []
  type: TYPE_NORMAL
- en: It works in conjunction with `package.json`. While `package.json` specifies
    the desired dependencies and their version ranges, `package-lock.json` pins down
    the exact versions that are used during installation.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, `package-lock.json` is important for maintaining consistent and reproducible
    Node.js project environments across installations and team workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we have one more folder: `node_modules`. In Node.js
    projects, the `node_modules` folder is a special directory that stores all the
    third-party libraries and dependencies your project relies on. These libraries
    provide pre-written code for functionalities you don’t need to build from scratch,
    saving you time and effort.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js projects often depend on external code from various sources. The `node_modules`
    folder keeps all these dependencies organized in one place. Each project can have
    its own set of dependencies specific to its needs. This way, different projects
    can use different versions of the same library without conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have an initial skeleton for our application. So, it’s time
    to start the actual development process.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the internal architecture of our microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that after carefully analyzing, we decided to have a special microservice
    that’s responsible for working with account information and we called it the *account
    microservice*. Our account consists of an *ID*, *account name*, *account type*,
    *account status*, and *account number*. To track changes, we’re going to add `createdAt`
    and `updatedAt` fields.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice approach has been applied to our whole project and now we have
    multiple services. However, the internal design of our concrete microservice depends
    on the requirements and it’s up to the team regarding which architectural pattern
    to apply. One of the most popular and classical architectural patterns in software
    development is **Model-View-Controller** (**MVC**). To make things simple and
    understandable, we will apply it to our microservice design.
  prefs: []
  type: TYPE_NORMAL
- en: MVC architectural pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVC architectural pattern is a popular choice for structuring Node.js APIs
    due to its emphasis on separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Represents the data layer of your API.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulates data access logic and interacts with databases (for example, MongoDB,
    MySQL, and so on).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles data persistence and retrieval.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View** (not directly used in Node.js APIs):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditionally deals with UI presentation in web applications.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Not directly applicable in Node.js APIs as they are data-centric.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the concept of *view* can be extended to represent the response format
    (JSON, XML) for the API.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, and `DELETE`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacts with the model to fetch or manipulate data based on the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepares the response data in the desired format (JSON, XML).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the response to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But why it is beneficial to use MVC for Node.js APIs?
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Makes code more organized and maintainable by dividing
    functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved testability**: Each layer (model, view, and controller) can be tested
    independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Easier to modify or update specific parts of the API without
    affecting others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Easier to scale the application by adding more controllers
    or models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have enough theoretical knowledge about MVC, it’s time to apply
    it in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating MVC into our Node.js project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Node.js doesn’t have a built-in MVC framework, popular web frameworks
    such as *Express.js* can be used to implement the pattern. Express.js handles
    routing (mapping URLs to controllers) and simplifies request-response handling.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll typically structure your project with separate folders for models and
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the *N-Layered Architecture* to structure our code. This architecture
    is popular because it promotes the separation of concerns, making the application
    more modular, maintainable, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we don’t have complex requirements, getting started with it is a good
    initial point. Using both MVC and the N-layered architecture in your Node.js Express
    project can lead to a well-structured and maintainable API. The following are
    some common layers you’ll encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation Layer (UI or API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business Logic Layer (core application logic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data Access Layer (interaction with databases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model, representing data and its logic, aligns with the data access layer’s
    responsibilities. Scripts in the `services` folder will store our business logic.
    The controller, which handles requests and manipulates data, shouldn’t contain
    any business logic. Instead, it should act as a bridge that forwards the user’s
    request to the business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined a general architecture for our application, we’re ready
    to focus on the implementation details. Starting from the next section, we’ll
    implement the functional behaviors of our first microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on account microservice development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start from scratch, let’s create a folder called `src`. We plan to organize
    our main application structure under this folder. This is going to be a data-centric
    application, so it’s better to start development from the database segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we plan to build the following project structure for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: The final project structure](img/B09148_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The final project structure'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with ease, don’t forget to download the source code from our
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our data-access functionalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We always store data somewhere. The most used storage for data is a database.
    The data access that we plan to implement relies on MongoDB and isolates us from
    the difficulties of querying a database using SQL. It’s like using arrays or lists
    but under the hood, it interacts with a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start creating our account microservice, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `db` folder under `src`.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `index.js` file to the `db` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to handle the database communication process. That’s why our
    current file (`index.js`) will serve connection and disconnection functionalities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve already mentioned the `mongoose` package. To use packages like this, we
    have the `required` command. Node.js automatically handles packages from the `node_modules`
    folder without specifying any relative or full path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we’ve implemented two main functionalities. They mostly act as wrappers
    over existing functionalities:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `connect` function tries to connect to the given database. In case of errors,
    we have one more attempt to try to connect to the database after `8` seconds.
    It is up to you to configure this but having a connection attempt after an unsuccessful
    operation makes sense.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `disconnect` function handles the disconnection case. Here, we’re removing
    all listeners of our database via `db.disconnect()` manually.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js has a file-based module approach. This means that every file, by itself,
    can be treated as a module and other modules can use it to build more complex
    modules. One of the ways you can make some functionalities of your module accessible
    to others is by using `exports`. You should only provide the required functions
    with the following proper encapsulation. If some of your functions are used by
    other functions in the same module and they are not part of your module’s contract,
    it’s better not to specify them in the `exports` list. In our case, we have two
    functions – `connect` and `disconnect` – that we’re providing outside to be consumed
    by other modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the M in MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our project, the responsibility of models is to act as a data access layer.
    This layer covers the main operations, such as `INSERT`, `UPDATE`, `SELECT`, and
    `DELETE`. We have `account.js` under the `src/models` folder; this is where all
    the database-related functionalities live. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s walk through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const mongoose = require(''mongoose'');`: This line imports the Mongoose library,
    which is used for interacting with MongoDB databases in Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const { Schema } = mongoose;`: This line uses destructuring to extract the
    `Schema` class from the `mongoose` object. This makes the code more concise and
    easier to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Schema({ ... })`: This line creates a new Mongoose schema object. The
    object that’s passed as an argument defines the structure of the documents that
    will be stored in the account collection within your MongoDB database. Within
    the curly braces, `{}`, you define the properties (fields) of each document in
    the collection. Here’s a breakdown of each property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: String`: This specifies that the `name` property should be a string.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required: true`: This makes the `name` property mandatory. A document cannot
    be saved without a value for the name.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: Similar to `name`, but also required.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: String:` The `status` property is a string.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum: [''new'', ''active'', ''inactive'', ''blocked'']`: Similar to `type`,
    this defines a list of allowed values for the status: `''new''`, `''active''`,
    `''inactive''`, or `''blocked''`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default: ''new''`: If no status is specified, it will default to `''new''`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createdAt`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: Date`: This property stores the date and time the document was created
    using the current time (`Date.now`).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updatedAt`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: Date:` This property is intended to store the date and time the document
    was last updated. However, it’s not explicitly set to a default value here. You’ll
    likely need to update this field manually in your application logic.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ optimisticConcurrency: true }`: This option is used for optimistic concurrency
    control, which is a mechanism that helps prevent data inconsistencies during updates
    ([https://mongoosejs.com/docs/guide.html#optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency)).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module.exports = mongoose.model(''account'', AccountSchema);`: This line creates
    a Mongoose model named `account` based on your defined `AccountSchema`. The model
    acts as a blueprint for interacting with `account` documents in your MongoDB database.
    By exporting the model, you make it available for use in other parts of your Node.js
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long story short, this code sets up a Mongoose schema for storing account information
    in a MongoDB collection. It defines properties such as `name`, `number`, `type`,
    `status`, `creation time`, and `last update time`, with validation rules and defaults.
    The code then exports a model that allows you to create, read, update, and delete
    account documents in your database.
  prefs: []
  type: TYPE_NORMAL
- en: Storing configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to store application-based configuration somewhere. For the current
    situation, we need MongoDB URL and port information. It isn’t a good idea to hard-code
    this information directly into your code because of maintainability, reusability,
    and extensibility. Instead, we prefer to store it in a separate file. That’s why
    we’ve installed the `dotenv` package.
  prefs: []
  type: TYPE_NORMAL
- en: The `dotenv` package in Node.js helps you manage environment variables for your
    project. It offers a way to store configuration settings, such as API keys or
    database credentials, outside of your code in a `.env` file. This improves security
    by keeping sensitive data out of your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Why use `dotenv`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: It keeps sensitive data out of your code base, reducing the risk
    of accidental exposure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns**: It separates configuration from code, making your
    code cleaner and easier to manage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.env` files for different environments (development, staging, and production)
    with specific configurations for each'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.env` file itself shouldn’t be included in version control systems such
    as Git to avoid committing sensitive information. We can create a `.env.example`
    file with placeholder values to guide developers on how to set up their environment
    variables. However, for this book, we will include the .`env` file in our Git
    repository as is, to facilitate the learning process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the `configs` folder under the `Ch05` folder. It is a root-level folder
    and contains a `.env` file without a name. Here’s its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to validate and create a configuration object based on the configuration
    we’ve looked at. That’s why we need one more folder called `config` under the
    `src` folder. So, let’s create `config.js` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the `createConfig` function, we’re able to read and build config objects.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of packages out there that can be used for data validation.
    We prefer to use Joi because it’s popular and easy to use. Joi is a popular open
    source package that provides a declarative way to define data schemas and perform
    validation against those schemas.
  prefs: []
  type: TYPE_NORMAL
- en: it allows you to create JavaScript objects that represent the expected structure
    and data types for your application’s inputs (request body, query parameters,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: It offers a wide range of validation rules for common data types such as strings,
    numbers, arrays, and objects. You can define rules for presence, format, length,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: It integrates seamlessly with Express.js middleware, allowing you to validate
    data directly within your route handlers.
  prefs: []
  type: TYPE_NORMAL
- en: By separating validation logic from your route handlers, your code becomes cleaner
    and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Joi is a valuable tool for building robust and secure Node.js applications.
    By incorporating data validation with Joi, you can ensure that your application
    receives clean, reliable data, leading to a more stable and secure development
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using it in our application entry point (`src/index.js`).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the business layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The business layer is the heart of an N-layered architecture. It’s responsible
    for the core functionality of the application and implements the specific business
    rules that govern how the application operates. It translates user requests into
    actions and decisions based on the business rules. It also determines how data
    should be processed, validated, and manipulated to fulfill those requests. Furthermore,
    it acts as an intermediary between the presentation layer (user interface) and
    the data access layer (database). It receives data requests from the presentation
    layer, retrieves the necessary data from the data access layer, and then applies
    business logic before returning the processed data.
  prefs: []
  type: TYPE_NORMAL
- en: By separating business logic from the presentation and data access layers, the
    business layer promotes loose coupling and reusability. This makes the application
    easier to maintain, test, and modify as business needs evolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a `services` folder under `src` to physically locate service functionalities.
    We mostly have five functions in `account.js` to cover the main operations related
    to CRUD: `getAccountById`, `getAllAccounts`, `createAccount`, `deleteAccountById`,
    and `updateAccountById`. Let’s look at the first four here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four functions are easy to understand. Using `require`, we import
    our account from models. Then, we wrap our data access operations with business
    functions. The biggest function in this module is `updateAccountById`. Let’s take
    a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we need to export the required code blocks so that they can be
    used by other services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following checks before updating our account information:'
  prefs: []
  type: TYPE_NORMAL
- en: Only allow an update to occur if one of the fields is provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return an error if an invalid status code is provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return an error if an invalid type is provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the account for the given ID doesn’t exist, we need to return the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have some rules to update the status. First, `availableAccountStatusesForUpdate`
    describes the rules: if the status is `new`, then it can be updated to `active`
    or `blocked`. For `active`, it is possible to update to `inactive` and `blocked`.
    If the status is `inactive`, then only `active` is allowed. The `blocked` status
    can only be transitioned to `active`.'
  prefs: []
  type: TYPE_NORMAL
- en: These are not all the possible validations you can implement, but they show
    how you can apply check logic to update functionality. In the end, we expose functions
    with error codes outside to be used by the preceding layer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Node.js project using the MVC pattern, the controller acts as the central
    nervous system, handling user requests and coordinating the application’s response.
    It is the first point of contact for incoming requests from the user. It interprets
    the URL, HTTP method (`GET`, `POST`, and so on), and any parameters included in
    the request. The controller, by its nature, doesn’t implement the business logic
    itself; instead, it directs the flow of the application based on the request.
    It might interact with the model to retrieve or manipulate data, or it could perform
    some basic validation or processing before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: The controller interacts with the model to get the data needed to fulfill the
    user’s request. This could involve fetching data from a database, performing calculations,
    or any other operations defined in the model layer.
  prefs: []
  type: TYPE_NORMAL
- en: Once the controller has the data or has processed the request, it selects the
    appropriate view to render the response for the classical UI application. It might
    also prepare the data so that it can be consumed by the view, such as formatting
    it into a specific template. In our case, we don’t have a complete UI, and our
    JSON representation of data acts as a UI for us.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the controller generates the response that gets sent back to the user.
    This could be an HTML page, JSON data for an API, or any other format suitable
    for the request.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the controller acts as a middleman, managing the communication flow
    between the user (through the view) and the data layer (through the model). It
    keeps the view and model separate, promoting cleaner code and easier maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a controller mechanism in our project, we need to create a folder
    called `controllers` under the `src` folder and add a new JavaScript file called
    `account.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Things are straightforward when it comes to implementing retrieve (get), create,
    and delete accounts. However, we should consider some additional factors when
    we update our account information:'
  prefs: []
  type: TYPE_NORMAL
- en: First, `getAccounts` calls the `getallAcccounts` service function and returns
    `200` responses.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `createAccount` calls the same named function from the service and returns
    `201`, which means the resource has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `deleteAccountById` calls the same named function from the service
    and returns `204`, which means success with no content. If the delete operation
    fails, it will return a `400` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at the update implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `updateAccountById` has a few more lines of code. Based on exported error
    codes, it prepares different HTTP status codes. If the provided data is valid,
    it returns a `200` success code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a simple function called `mapToResponse`. In Node.js, `mapToResponse`
    serves as a utility function to transform or map an account object to a specific
    format or structure that’s suitable for sending as a response, typically in an
    API. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The only additional `private` function that we haven’t exported is `mapToResponse`.
    As you know, the user may not need to retrieve the whole account data structure.
    Using this function, we only return the required fields to the user as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of code is retrieving the account by ID (`getAccountById`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `getAccountById` redirects the query to the appropriate service and, based
    on the service’s response, returns a success or not found message.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, to use the main controller functions in the routing process, we
    must export them.
  prefs: []
  type: TYPE_NORMAL
- en: Simple data validation for your API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unvalidated data can lead to unexpected behavior, errors, and security vulnerabilities.
    Validation helps ensure that data received from users or external sources conforms
    to your application’s expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious users might try to inject invalid or unexpected data into your application.
    Validation helps prevent these attacks by rejecting data that doesn’t adhere to
    the defined rules.
  prefs: []
  type: TYPE_NORMAL
- en: By defining validation rules upfront, you can catch errors early in the development
    process, reducing debugging time and improving code maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a validation folder under `src` with the `account.js` file that
    contains the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: After installing the `Joi` package, it is enough to specify it in the `require`
    command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regular expression defines a rule to validate the ID. We’ll use this ID
    for `GET`, `PUT`, and `DELETE` operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const createAccount = { ... }`: This line declares a constant variable named
    `createAccount` and assigns an object literal to it. This object will hold the
    validation schema for creating an account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: This property name specifies that the validation schema applies to
    the request body (typically, data sent in the body of a `POST` request).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Joi.object()`: This creates a Joi object schema that validates the structure
    (presence of specific properties) of the request body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.keys({ ... })`: This defines the set of properties to be expected in the
    request body and their corresponding validation rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name: Joi.string().required()`: This validates the presence of a property
    named `name` and ensures it’s a string value. The `.required()` part makes it
    mandatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number: Joi.string().required()`: Similar to `name`, this validates a required
    string property named `number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status: Joi.string().valid(''new'', ''active'', ''completed'', ''cancelled'').optional()`:
    This validates an optional string property named `status`. The `.valid()` method
    restricts the allowed values to `''new''`, `''active''`, `''completed''`, and
    `''cancelled''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: Joi.string().valid(''root'', ''sub'').optional()`: Similar to `status`,
    this validates an optional string property named `type` with allowed values of
    `''root''` and `''sub''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, the preceding code ensures that a request to create an account
    must include the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: Required string value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: Required string value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: An optional string value that is either `''new''`, `''active''`,
    `''completed''`, or `''cancelled''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: An optional string value that is either `''root''` or `''sub''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using this schema, you can guarantee that the data that’s received for creating
    an account adheres to the expected format and prevents unexpected or invalid data
    from entering your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `updateAccountById` object specifies that the parameters must include an
    `id` parameter, which is required and must be a valid object ID. The `body` part
    of the request must contain `name` and `number` fields, both of which are required
    strings, and optionally a `status` field that can only be one of the specified
    values `('new'`, `'active'`, `'completed'`, or `'cancelled'`) and a `type` field
    that can be either `'root'` or `'sub'`. This validation ensures that incoming
    requests to update an account adhere to the expected format and data types. In
    the end, to use these rules, we need to export them using `module.exports`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have another module related to data validation that’s placed in the `middleware`
    folder under the `src` folder. `validate.js` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If an error exists, the middleware extracts individual error messages using
    `error.details.map(...)` and joins them into a comma-separated string (`errorMessage`).
    A `400 Bad Request` response is sent with the error message in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: If validation passes (`!error`), the validated data (value) obtained from Joi
    is attached to the `req` object using `Object.assign`. This makes the validated
    data readily available in subsequent route handlers.
  prefs: []
  type: TYPE_NORMAL
- en: This middleware acts as a gatekeeper for your routes, ensuring that incoming
    requests adhere to the provided validation schema.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Routing** is a fundamental aspect of building web applications with Node.js
    and Express. It essentially directs incoming HTTP requests to the appropriate
    handlers within your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Routing allows you to define a clear separation between URLs (endpoints) and
    the code that handles them. This promotes modularity and makes your code base
    more readable and manageable.
  prefs: []
  type: TYPE_NORMAL
- en: It also enables you to define handlers specific to each HTTP method for a particular
    URL. This allows you to handle requests for retrieving data (`GET`), submitting
    data (`POST`), updating data (`PUT`), or deleting data (`DELETE`) appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: By defining routes that map to resources and corresponding HTTP methods, you
    can establish a well-structured and predictable API that other applications can
    interact with.
  prefs: []
  type: TYPE_NORMAL
- en: As your application evolves, routing helps you easily add new features and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: You can create separate route handlers for new features, keeping your code base
    organized and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Routing also allows you to group related routes, promoting the reusability of
    code across different parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, routing acts like a traffic controller for your application,
    directing incoming requests to the designated destinations (handlers) based on
    their URLs and HTTP methods. This keeps your code organized and maintainable and
    enables you to build robust and scalable web applications and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We have a `routes` folder under the `src` folder where we define all the routing
    rules for our application. Currently, it is our first version, so the `v1` folder
    indicates the first version of our API. **Versioning** allows you to introduce
    changes while maintaining compatibility with existing clients.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the `accounts` folder and the `index.js` file to our `v1` folder and
    define our routing rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full path to the file will be `src/routers/v1/accounts/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Express.js provides routing functionality. Using it, we’ve defined the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Users can *get* an account by ID using `/accounts/:id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can *create* a new account by sending a `POST` request to `/accounts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can *update* an account by ID sending a `PUT` request to `/accounts/:id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can *delete* an account by ID sending a `DELETE` request to `/accounts/:id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The validation middleware ensures that requests adhere to the expected format
    before reaching the controller functions, which handle the actual account management
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed, we don’t have any indicator for our route to be used
    with the `/``accounts` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more JavaScript file to handle this. Let’s create `index.js` under
    the `routes/v1` folder with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll be able to navigate to our resource using the `/``accounts` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing our web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it’s time to define our basic structure for a Node.js application using
    the Express.js framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an `app.js` file under the `src` folder with the following code
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet defines a basic structure for building our web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const express = require(''express'');`: This line imports the Express.js framework,
    providing functionalities for building web servers and handling HTTP requests
    and responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const v1 = require(''./routes/v1'');`: This line imports a module named `v1.js`
    located in a folder named `routes/v1`. This module defines routes (URL paths)
    for version 1 of your application’s API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const app = express();`: This line creates an instance of the Express application
    using the `express()` function. This `app` object will be used to define routes
    and middleware, as well as handle application logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.use(express.json())`: This line registers a middleware function with the
    Express application. The `express.json()` middleware parses incoming JSON data
    in request bodies, making it accessible in your route handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.use(''/v1'', v1);`: This line is crucial for routing. It mounts the routes
    defined in the imported `v1` module onto the `/v1` path of your application. Any
    requests to URLs starting with `/v1` will be handled by the functions in the `v1`
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module.exports = app;`: This line exports the `app` object, which is the core
    of your Express application. This allows other modules in your project to import
    and use this application instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, this code creates an Express application, configures middleware
    for JSON handling, mounts routes from a separate module for version 1 of your
    API, and makes the application instance available for import by other parts of
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Combining all the elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final step in our application is to construct everything together, like
    using Lego. This Lego is going to be a main runnable application that will help
    us to communicate between elements of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an `index.js` file under the `src` folder that contains the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This Node.js code defines an asynchronous function named `execute` that serves
    as the entry point for your application. Here’s a breakdown of its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const path = require(''path'');`: Imports the `path` module for manipulating
    file paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const db = require(''./db'');`: Imports the `db` module, likely containing
    functions for connecting and interacting with your database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const app = require(''./app'');`: Imports the main application module, likely
    containing the Express application instance and your application logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const { createConfig } = require(''./config/config'');`: Imports the `createConfig`
    function from the `config/config.js` module, likely responsible for creating your
    application configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async function execute() { ... }`: Defines an asynchronous function named
    `execute` that will be executed when the script starts*   `const configPath =
    path.join(__dirname, ''../configs/.env'');`: Uses the `path` module to construct
    the absolute path to your configuration file (likely a `.env` file) two directories
    above the current script’s location*   `const appConfig = createConfig(configPath);`:
    Calls the imported `createConfig` function with the configuration file path, presumably
    to read and parse the configuration settings*   `await db.connect(appConfig);`:
    Attempts to connect to the database using the `db` module and the loaded configuration
    (`appConfig`) object. This line is asynchronous, so the function waits for the
    connection to be established before proceeding.*   `const server = app.listen(appConfig.port,
    ...);`: Calls a method (likely `listen`) on the imported `app` object, which is
    probably an Express application. This starts the server listening on the port
    specified in the configuration (`appConfig.port`). The callback function logs
    a message when the server starts successfully.*   `const closeServer = () => {
    ... }`: Defines an arrow function named `closeServer` that gracefully shuts down
    the server. It checks whether the server object exists and then calls its `close`
    method. The callback function for `close` logs a message when the server is closed
    and exits the process with an exit code of `1`.*   `const unexpectedError = (error)
    => { ... }`: Defines an arrow function named `unexpectedErrorHandler` that handles
    uncaught errors or unhandled promise rejections. It logs the error message. It
    calls the `closeServer` function to gracefully shut down the server*   `process.on(''uncaughtException'',
    unexpectedError);`: Attaches the `unexpectedErrorHandler` function to the `uncaughtException`
    event of the `process` object. This ensures that any errors thrown outside of
    an `async` function or promise chain are caught and handled.*   `process.on(''unhandledRejection'',
    unexpectedError);`: Attaches the `unexpectedErrorHandler` function to the `unhandledRejection`
    event of the `process` object. This ensures that any unhandled rejections from
    promises are caught and handled.*   `execute();`: Calls the `execute` function
    to start the application. Since `execute` is asynchronous, the entire application
    startup process becomes asynchronous, ensuring the database connection and server
    startup are completed before the application continues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, this code sets up the application configuration, connects to the
    database, starts the server, and implements error handling for a robust and graceful
    startup and shutdown process.
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing our first microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re not going to write any unit or integrate tests in this chapter. In [*Chapter
    11*](B09148_11.xhtml#_idTextAnchor174), where we’ll dive into the details of those
    topics. For this chapter, we’ll do manual testing via Postman. To run our application,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download `Ch05` from our GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the project (`Ch05`) via Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Terminal** | **New Terminal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `npm install` command from the `Ch05` folder to load the required packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change directories to `src` (using the `cd` `src` command).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `node index.js` command. Mongo should be installed before you run this
    command. Check out [*Chapter 4*](B09148_04.xhtml#_idTextAnchor056) for more information
    about the installation process for Mongo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next few subsections, we’ll test our endpoints one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new account, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new tab in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `POST` from **HTTP verbs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `localhost:3001/v1/accounts` in the **URL** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `raw` and change `Text` to `JSON`. Add the following JSON to the
    text area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s get the account by ID.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an account by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get an account with the given ID, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new tab in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `GET` from **HTTP verbs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `localhost:3001/v1/accounts/{accountID}` in the `662c081370bd2ba6b5f04e94`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s learn how to update our existing account.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an account by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update your given account, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new tab in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `PUT` from **HTTP verbs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `localhost:3001/v1/accounts/{accountID}` in the URL section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `raw` and change `Text` to `JSON`. Add the following JSON to the
    text area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For most of the APIs, we usually want to retrieve all data. Next, we’ll learn
    how to get all account information.
  prefs: []
  type: TYPE_NORMAL
- en: Gettings all accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve all accounts, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new tab in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `GET` from **HTTP verbs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `localhost:3001/v1/accounts` in the **URL** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Send** button to send the request. You’ll get the following response
    from the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final endpoint involves deleting the account. Let’s check it.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting account by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, to delete your already existing account by its ID, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new tab in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `DELETE` from **HTTP verbs**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `localhost:3001/v1/accounts/{accountID}` in the **URL** section. Provide
    the valid **accountID** value to delete the record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `204 no-content` response from the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we have fully functional CRUD endpoints for accounts. We may not
    have a complex business case, but the purpose of this chapter was to show you
    how to implement endpoints for your microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our first microservice. This was our first practical
    chapter about creating microservices. For this, having a clear understanding of
    your requirements is important. We provided simple requirements to make our first
    microservice more understandable and easy to follow. There, we learned how to
    set up our project. We talked about the tools we need to develop our first microservice;
    before every microservice development process can be undertaken, we need to define
    which tools and technologies we plan to use. We also created our internal structure
    using MVC and N-layered architecture. These are the most popular choices, so using
    them for your first development project is a great chance for you to learn popular
    techniques. The practical aspect of this chapter covered creating models, business
    logic, and controllers. There, we learned about the basics of validation using
    the JOI package. The application requires a separate file to store configuration,
    hence why we used the `dotenv` package. We also learn about routing, which is
    important if we wish to access our functionalities. Then, we integrated routing
    using Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we learned how to check our functionalities using Postman. In the
    upcoming chapters, we will delve into the development of a second microservice,
    focusing on establishing synchronous communication between microservices. We will
    introduce a new stack for the transaction microservice, using tools like NestJS,
    Prisma, and Axios, to demonstrate the versatility of JavaScript in microservice
    development.
  prefs: []
  type: TYPE_NORMAL
