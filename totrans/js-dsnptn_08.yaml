- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Micro Frontends, Zones, and Islands Architectures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端、区域和岛屿架构
- en: The micro frontend architecture, and specifically the “zones” and “islands”
    patterns, mirror the microservices architecture for backend systems. Given the
    right tooling, they allow multiple teams to maintain high-velocity development
    on a single product. The techniques covered in this chapter look at system-level
    interaction and integration patterns. Each system can leverage creational, structural,
    behavioral, and reactive view library patterns, as covered in *Chapters* *1*,
    *2*, *3*, and *4* respectively. Micro frontend architectures help link systems
    together as opposed to structuring the code within each of them better.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构，特别是“区域”和“岛屿”模式，与后端系统的微服务架构相呼应。有了合适的工具，它们允许多个团队在单一产品上进行高速开发。本章介绍的技术探讨了系统级交互和集成模式。每个系统都可以利用创建、结构、行为和反应视图库模式，分别如第1章、第2章、第3章和第4章所述。微前端架构有助于将系统连接起来，而不是在它们内部更好地组织代码。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The problem space that micro frontends address, including some common approaches
    and their drawbacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端解决的问题空间，包括一些常见方法和它们的缺点
- en: Leveraging Next.js features to build a “zones” micro frontend setup
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Next.js功能构建“区域”微前端设置
- en: Using the **is-land** package to deliver an “islands” micro frontend setup with
    islands in Preact and Vue.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**is-land**包在Preact和Vue.js中实现“岛屿”微前端设置
- en: By the end of this chapter, you’ll be able to discuss the trade-offs and deliver
    modern micro frontend approaches in JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够讨论权衡并交付现代JavaScript微前端方法。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件：[https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
- en: An overview of micro frontends
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端概述
- en: A micro frontend setup is one where multiple frontend applications or components
    are composed. This is akin to microservices, where a micro frontend would encapsulate
    a subset of functionality, or “bounded context.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端设置是指多个前端应用程序或组件的组合。这类似于微服务，其中微前端将封装功能子集，或“边界上下文”。
- en: For example, in an e-commerce setting, we might have a “search” micro frontend
    and a “cart” or “checkout” micro frontend.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在电子商务环境中，我们可能会有“搜索”微前端和“购物车”或“结账”微前端。
- en: '![Figure 6.1: A simplified micro frontends diagram](img/B19109_06_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：简化的微前端图](img/B19109_06_1.jpg)'
- en: 'Figure 6.1: A simplified micro frontends diagram'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：简化的微前端图
- en: We’ve now introduced the micro frontends architecture; next, we’ll see at the
    key benefits micro frontends deliver.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了微前端架构；接下来，我们将看到微前端提供的关键优势。
- en: Key benefits
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键优势
- en: The benefits of the micro frontend patterns are similar to microservice benefits.
    They usually come in the sociotechnical aspect of development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端模式的好处与微服务的好处相似。它们通常出现在开发的社会技术方面。
- en: Each micro frontend can use a different set of technologies, which means the
    right tool for the job can be selected. A very page-load performance-sensitive
    page might use a different stack than an admin interface or a high-volume SVG
    visualization page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微前端可以使用不同的技术集，这意味着可以选择适合工作的正确工具。一个非常关注页面加载性能的页面可能使用与管理员界面或高流量SVG可视化页面不同的堆栈。
- en: Incremental upgrades are available, and changes can be tested in one component
    before being rolled out to all components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可提供增量升级，并且可以在将更改部署到所有组件之前在一个组件中进行测试。
- en: The releases of different micro frontends are not locked together. This can
    help when scaling, where each team might work on one or more of the micro frontends.
    They can be released independently of other teams, meaning the cadence can increase;
    this is related to the last benefit we’ll discuss.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不同微前端的发布不是锁定在一起的。这有助于在扩展时，每个团队可能都在一个或多个微前端上工作。它们可以独立于其他团队发布，这意味着节奏可以加快；这与我们将讨论的最后一个优势相关。
- en: Each micro frontend can have its own code base, and “bounded contexts” can be
    strictly enforced.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微前端都可以有自己的代码库，并且可以严格实施“边界上下文”。
- en: “Classic” micro frontend patterns
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “经典”微前端模式
- en: We’ll cover five different “classic” approaches to creating a micro frontend
    setup.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖创建微前端设置的五种不同的“经典”方法。
- en: The first is the “container application” using server-side includes. This leverages
    a server that will fetch from the different micro frontends and stitch them together.
    This is illustrated in the following diagram, where the container application
    loads a “cart” HTML section and a “search” HTML section and injects them into
    its own template, before returning to the client.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用服务器端包含的“容器应用”。这利用了一个服务器，它会从不同的微前端获取内容并将它们拼接在一起。以下图示说明了这一点，其中容器应用加载了一个“购物车”HTML部分和一个“搜索”HTML部分，并将它们注入到自己的模板中，然后再返回给客户端。
- en: '![Figure 6.2: The “container application” sequence](img/B19109_06_2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：“容器应用”序列](img/B19109_06_2.jpg)'
- en: 'Figure 6.2: The “container application” sequence'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：“容器应用”序列
- en: The benefits of server-side include, or the “container application,” is that
    deployments of each micro frontend are decoupled (e.g., we can deploy changes
    to the cart without deploying changes to the search section or the container);
    in addition, it’s completely technology-agnostic, as micro frontends don’t even
    need to use JavaScript.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端包含或“容器应用”的好处是，每个微前端的部署是解耦的（例如，我们可以部署购物车的更改，而不必部署搜索部分或容器的更改）；此外，它完全不受技术限制，因为微前端甚至不需要使用JavaScript。
- en: The next “classic” approach we’ll see is different, using “build-time composition,”
    where each micro frontend is a package, usually a npm package (part of the Node.js/JavaScript
    toolchain). Each package is then imported where necessary and composed at “build-time”
    (when each application is packaged for deployment).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到的是另一种“经典”方法，它使用“构建时”组合，其中每个微前端都是一个包，通常是npm包（Node.js/JavaScript工具链的一部分）。然后，每个包在需要的地方导入，并在“构建时”进行组合（即每个应用程序打包用于部署时）。
- en: The key drawback of “build-time” composition is that releases now require deployment
    cascades. For all the applications to receive updates to the “cart”, we need to
    update the version and release all the applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “构建时”组合的关键缺点是，现在发布需要部署级联。为了使所有应用程序都能接收到“购物车”的更新，我们需要更新版本并发布所有应用程序。
- en: The three final “classic” approaches are similar conceptually although use different
    technologies. They’re all “runtime integrations”; the technologies are iframes,
    JavaScript, and web components. Runtime integrations mean that the micro frontend
    requests the micro frontend resource from the browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三种“经典”方法在概念上相似，尽管使用了不同的技术。它们都是“运行时集成”；技术包括iframe、JavaScript和Web组件。运行时集成意味着微前端从浏览器请求微前端资源。
- en: In the case of iframes, this involves using the iframe `src` attribute. The
    main downside of this is that each micro frontend needs to be secured against
    all public network exploits. What’s more, allowing the iframing of an application’s
    content can lead to click-jacking vulnerabilities if not done carefully, so there
    are security implications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在iframe的情况下，这涉及到使用iframe的`src`属性。这种做法的主要缺点是，每个微前端都需要防范所有公开网络攻击。更重要的是，如果操作不当，允许应用内容的iframe可能导致点击劫持漏洞，因此存在安全影响。
- en: '![Figure 6.3: Runtime integration with iframes](img/B19109_06_3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：使用iframe的运行时集成](img/B19109_06_3.jpg)'
- en: 'Figure 6.3: Runtime integration with iframes'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：使用iframe的运行时集成
- en: In the case of JavaScript or Web Component “runtime” integration, the composition
    is managed by loading JavaScript files. This is more ideal than using iframes,
    since serving JavaScript to the browser has fewer security implications than allowing
    the framing of your content. In the Web Components case, you would have both the
    web component referenced in the body of the HTML and a reference to the scripts
    required to run the Web Component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript或Web组件“运行时”集成的情况下，组合是通过加载JavaScript文件来管理的。这比使用iframe更理想，因为将JavaScript提供给浏览器比允许内容被框架化有更少的潜在安全影响。在Web组件的情况下，你会在HTML的主体中引用Web组件，并且还需要引用运行Web组件所需的脚本。
- en: '![Figure 6.4: Runtime integration with JavaScript or web components](img/B19109_06_4.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：使用JavaScript或Web组件的运行时集成](img/B19109_06_4.jpg)'
- en: 'Figure 6.4: Runtime integration with JavaScript or web components'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：使用JavaScript或Web组件的运行时集成
- en: Runtime integrations have a performance impact on the user experience, as shown
    by the difference in diagrams between our “server-side includes” and “runtime
    integration” diagrams. In the “server-side includes” case, the server composes
    a full application before returning it to the customer. In the “runtime integration”,
    the server returns what are essentially resource references to the browser, which
    then has to load these resources.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时集成对用户体验有性能影响，如图表之间“服务器端包含”和“运行时集成”的差异所示。在“服务器端包含”的情况下，服务器在返回给客户之前会组合一个完整的应用程序。在“运行时集成”中，服务器返回给浏览器的是本质上是对资源的引用，然后浏览器必须加载这些资源。
- en: As we explore the “zones” and “islands” modern implementations of micro frontends,
    we’ll encounter several instances of these techniques used together.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索微前端的“区域”和“岛屿”现代实现时，我们将遇到这些技术共同使用的几个实例。
- en: Other concerns in a micro frontend world
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微前端世界中的其他关注点
- en: Similar to a microservice setup, micro frontends that allow different teams
    to build in their own way can be a benefit and a drawback.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于微服务架构，允许不同团队以自己的方式构建的微前端可以是一种优势，也可能是一种劣势。
- en: At the end of the day, most frontend systems will need to communicate with a
    backend service. How to do this remains something to be decided – should each
    team deploy its own **backend for frontend** (**BFF**), should a single gateway
    be deployed that exposes relevant service endpoints, or should it be a gateway
    that wraps services in a different query system such as GraphQL?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，大多数前端系统最终都需要与后端服务进行通信。如何做这仍然是一个待定的问题——每个团队是否应该部署自己的**前端后端**（**BFF**），是否应该部署一个单一的网关来暴露相关的服务端点，或者它应该是一个将服务封装在不同查询系统（如GraphQL）中的网关？
- en: Micro frontends also cause challenges for testing. How do we reliably test at
    the “user journey” level, which might go through multiple micro frontends, when
    each of the micro frontends also has its own test suite?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端也给测试带来了挑战。当每个微前端都有自己的测试套件时，我们如何可靠地在“用户旅程”级别进行测试，这可能涉及多个微前端？
- en: Similar to the questions about which backend integrations to use, there’s a
    challenge related to shared styles and potentially component libraries. Teams
    doing micro frontends might standardize on a set technology (React, Vue, etc)
    in order to gain the benefits of a component library. Component libraries are
    more difficult to maintain in multiple technologies, but companies sometimes opt
    for this to support their engineers in picking the right tool for the job.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与关于使用哪种后端集成的问题类似，还有一个与共享样式和潜在组件库相关的挑战。进行微前端开发的团队可能会在某个技术（如React、Vue等）上实现标准化，以获得组件库的好处。在多种技术中维护组件库更为困难，但公司有时会选择这种方式来支持工程师选择合适的工具。
- en: One big challenge of micro frontends is how to keep them performant. Even in
    a case where all teams use the same technologies, it’s likely that the same dependency
    is duplicated across micro frontends, which has a performance impact. When technologies
    and build and deploy processes diverge (which is possible with micro frontends),
    this problem is exacerbated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端的一个大挑战是如何保持它们的性能。即使在所有团队都使用相同技术的案例中，同一依赖项也可能在微前端之间重复，这会影响性能。当技术和构建和部署流程出现分歧（微前端是可能的）时，这个问题会加剧。
- en: The other performance issue that occurs with, for example, “server-side includes”
    is that the page will only load as fast as the slowest component on the page.
    This is less of an issue with runtime integrations, but the idea that each micro
    frontend might affect a whole page’s performance is a relevant one with regard
    to the challenges of building a system using micro frontends.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与“服务器端包含”相关的另一个性能问题是，页面将只以页面中最慢的组件的速度加载。在运行时集成中，这不太成问题，但每个微前端可能会影响整个页面的性能，这在使用微前端构建系统时是一个相关的问题。
- en: Finally, as we’ve alluded to with regard to testing micro frontends, it causes
    operational and governance complexities. For example, environment mismatch issues
    are harder to detect. Running or deploying a full environment for development
    or testing with multiple micro frontends is more complex than with a monolithic
    application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我们关于测试微前端所暗示的，它会导致操作和治理复杂性。例如，环境不匹配问题更难检测。在多个微前端的情况下，运行或部署用于开发或测试的完整环境比单体应用程序更复杂。
- en: Now that we’ve defined and contrasted the benefits and drawbacks of micro frontends
    in general and specific micro frontend approaches, we can look at modern implementations
    of micro frontends. In the following section, we’ll look at leveraging Next.js
    and “zones” in order to build flexible micro frontends.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义并对比了微前端的一般优势和劣势以及特定的微前端方法，我们可以看看微前端在现代的实现。在下一节中，我们将探讨利用Next.js和“zones”来构建灵活的微前端。
- en: Composing applications with Next.js “zones”
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Next.js“zones”组合应用程序
- en: Next.js “zones” are a URL “base path”-driven approach to composing Next.js applications.
    This allows us to build a micro frontend setup with Next.js.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js “zones”是一种基于URL“基本路径”的方法，用于组合Next.js应用程序。这允许我们使用Next.js构建一个微前端设置。
- en: What this means, as shown in the figure that follows, is that an e-commerce
    use case, where the user might request four sets of URLs (`GET /, GET /careers,
    GET /search, and GET /cart/{id}), "{id}"`), denotes that the cart has a dynamic
    segment, which is the cart ID that is requested. For `GET /` and `GET /careers`,
    the request first goes to the `root` frontend, which handles rendering directly.
    For `GET /search`, the request goes to the root frontend, which forwards the request
    to the search frontend. Similarly, for `GET /cart/{id}` requests, the request
    initially is sent to the root frontend, which proxies the request to the checkout
    frontend.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，这意味着一个电子商务用例，其中用户可能请求四组URL（`GET /, GET /careers, GET /search, 和 GET /cart/{id}`），`{id}`表示购物车有一个动态段，即请求的购物车ID。对于`GET
    /`和`GET /careers`请求，请求首先发送到`root`前端，它直接处理渲染。对于`GET /search`请求，请求发送到`root`前端，它将请求转发到搜索前端。同样，对于`GET
    /cart/{id}`请求，请求最初发送到`root`前端，它将请求代理到结账前端。
- en: "![Figure 6.5: An overview flowchart of a three-app Next.js\uFEFF zone setup](img/B19109_06_5.jpg)"
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：三个应用Next.js区域设置的概述流程图](img/B19109_06_5.jpg)'
- en: 'Figure 6.5: An overview flowchart of a three-app Next.js zone setup'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：三个应用Next.js区域设置的概述流程图
- en: We’ve now introduced Next.js “zones” and an overview of our implementation,
    next we’ll implement the “root app”.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了Next.js“zones”和我们的实现概述，接下来我们将实现“root app”。
- en: Root app
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根应用程序
- en: The root app contains two pages, `/` (`pages/index.js`) and `/careers` (`pages/careers.js`).
    Both of these pages are statically rendered, `index.js` via automatic static generation
    (since it doesn’t have `getServerSideProps` or `getInitialProps`) and `careers.js`
    via static site generation (since it has `getStaticProps`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根应用程序包含两个页面，`/`（`pages/index.js`）和`/careers`（`pages/careers.js`）。这两个页面都是静态渲染的，`index.js`通过自动静态生成（因为它没有`getServerSideProps`或`getInitialProps`），而`careers.js`通过静态站点生成（因为它有`getStaticProps`）。
- en: '`index.js` contains a heading as well as `Head` content.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js`包含一个标题以及`Head`内容。'
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we load the `GET` `/` path, our root app renders the `h1` element we placed
    within it, with `'Root'` as its content.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载`GET` `/`路径时，我们的根应用程序渲染我们放置其中的`h1`元素，内容为`'Root'`。
- en: '![Figure 6.6: The Root page rendered](img/B19109_06_6.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6：根页面的渲染效果](img/B19109_06_6.jpg)'
- en: 'Figure 6.6: The Root page rendered'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：根页面的渲染效果
- en: The `/careers` page loads roles from an API using `getStaticProps` and displays
    them in a list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`/careers`页面使用`getStaticProps`从API加载角色，并以列表形式显示它们。'
- en: 'We can start with a `getStaticProps` function in `pages/careers.js`. This function
    loads from a “fake jobs” API and returns a `roles` prop, which includes the returned
    data from the API:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`pages/careers.js`中的`getStaticProps`函数开始。这个函数从一个“虚假工作”API加载数据，并返回一个`roles`属性，它包括API返回的数据：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we’ll add a `CareersPages` component. It includes the page scaffolding
    with `title` and `h1`. It also loops through the `roles` prop to render it as
    a list, using `ul` and `li`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个`CareersPages`组件。它包括带有`title`和`h1`的页面框架。它还会遍历`roles`属性，将其渲染为列表，使用`ul`和`li`：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It displays as follows.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示如下。
- en: '![Figure 6.7: The Careers page in the root zone](img/B19109_06_7.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7：根区域中的职业页面](img/B19109_06_7.jpg)'
- en: 'Figure 6.7: The Careers page in the root zone'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：根区域中的职业页面
- en: 'The `next build` output shows that `index.js` is indeed statically rendered,
    while `/``careers` uses static site generation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`next build`输出显示`index.js`确实被静态渲染，而`/careers`使用静态站点生成：'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ve now started implementing the root app, we’ll move on to our second zone,
    the “search” zone.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经开始了根应用程序的实现，接下来我们将转向我们的第二个区域，“搜索”区域。
- en: Adding a /search app
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加/search应用程序
- en: Next, we’ll build and mount a `/``search` page.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建和挂载一个`/search`页面。
- en: '`search/pages/index.js` displays an input and makes a call to the `/search/api/search`
    route on change:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`search/pages/index.js` 显示一个输入并在更改时调用 `/search/api/search` 路由：'
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To implement the `search/pages/api/search` API route, we create `pages/api/search`,
    which loads products from `fakestoreapi` and finds a match between the title,
    description and category:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `search/pages/api/search` API 路由，我们创建 `pages/api/search`，它从 `fakestoreapi`
    加载产品，并在标题、描述和类别之间找到匹配项：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order for `search-app/` to be mounted under `search-app/search`, we’ll use
    `basePath` in `next.config.js` in the search app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `search-app/` 在 `search-app/search` 下挂载，我们将在搜索应用程序的 `next.config.js` 中使用
    `basePath`：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’ll expose `search` via the root app’s `next.config.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过根应用程序的 `next.config.js` 暴露 `search`：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then load the **Search** page, which displays as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以加载 **搜索** 页面，其显示如下：
- en: '![Figure 6.8: The Search page on load](img/B19109_06_8.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：加载时的搜索页面](img/B19109_06_8.jpg)'
- en: 'Figure 6.8: The Search page on load'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：加载时的搜索页面
- en: The search works – for example, with the `jacket` search term.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索功能正常工作——例如，使用 `jacket` 搜索词。
- en: '![Figure 6.9: The Search page with the jacket search term](img/B19109_06_9.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9：包含夹克搜索词的搜索页面](img/B19109_06_9.jpg)'
- en: 'Figure 6.9: The Search page with the jacket search term'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9：包含夹克搜索词的搜索页面
- en: '`/search` is statically rendered via automatic static rendering:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`/search` 通过自动静态渲染进行静态渲染：'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve now implemented the search “zone”, next we’ll implement the checkout “zone”.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了搜索“区域”，接下来我们将实现结账“区域”。
- en: Adding /checkout app
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 /checkout 应用
- en: We’ll add a “view cart” page in a new checkout Next.js app under `pages/cart/[id].js`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在新的 Next.js 应用程序 `pages/cart/[id].js` 下添加一个“查看购物车”页面。
- en: The cart page loads a cart and its contained products from `fakestoreapi`, displaying
    them via a `CartContents` component.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车页面从 `fakestoreapi` 加载购物车及其包含的产品，并通过 `CartContents` 组件显示它们。
- en: First, we’ll define a `CartContents` component that takes `cart` and `productsById`
    props. It then maps through `cart.products`, extracting the product’s title and
    the quantity requested in the cart, before computing and formatting the price
    in euros using `.toLocaleString`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个 `CartContents` 组件，该组件接受 `cart` 和 `productsById` 属性。然后它遍历 `cart.products`，提取购物车中的产品标题和请求的数量，然后使用
    `.toLocaleString` 计算并格式化欧元价格。
- en: The reason we need `cart` and `productsById` is that the cart comes back in
    a normalized data format, meaning it contains only cart-specific information and
    none of the related product’s information, except the product ID. Therefore, we
    need to do a lookup based on the product ID.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `cart` 和 `productsById` 的原因是购物车以规范化的数据格式返回，这意味着它只包含购物车特定的信息，不包含任何相关产品的信息，除了产品
    ID。因此，我们需要根据产品 ID 进行查找。
- en: 'Our rendering logic uses an unordered list container (the `ul` HTML element)
    and list item elements (`li` HTML elements). We render the title in an `h3` heading
    and the rest of the information using `span` elements:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的渲染逻辑是一个无序列表容器（`ul` HTML 元素）和列表项元素（`li` HTML 元素）。我们将标题渲染为 `h3` 标题，其余信息使用
    `span` 元素：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we’re rendering the contents of the cart, the additional functionality
    we’ll add to `CartContents` is a display of the cart’s total price.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在渲染购物车的内容，我们将添加到 `CartContents` 的附加功能是显示购物车的总价。
- en: This is done by adding another `li`, which displays “Total:” and computes the
    total price, using `reduce` over `cart.products`. Remember from the previous code
    block that `cart.products` is normalized, meaning that it doesn’t contain any
    information about the product (e.g., its price), apart from the product’s ID.
    This means that our reduce handler does a lookup on `productsById[product.productId]`
    in order to access the product’s price.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过添加另一个 `li` 实现的，它显示“总计:”并计算总价，使用 `reduce` 对 `cart.products` 进行操作。记住，从之前的代码块中，`cart.products`
    是规范化的，这意味着它不包含任何关于产品（例如，其价格）的信息，除了产品的 ID。这意味着我们的 reduce 处理器在 `productsById[product.productId]`
    上进行查找，以便访问产品的价格。
- en: Once we have the quantity of a given product in the cart and the price of the
    product, we simply multiply them together and sum the quantity times the price
    result to the accumulator, which we initialized as 0.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了购物车中给定产品的数量和产品的价格，我们只需将它们相乘，然后将数量乘以价格的结果加到累加器上，我们将其初始化为 0。
- en: 'Similar to the cart items, we use `toLocaleString` to format the total price
    in euros as an en localized string:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与购物车项类似，我们使用 `toLocaleString` 将总价格式化为欧元作为 en 本地化的字符串：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll leverage `getServerSideProps` to load the cart, and then the relevant
    products from `fakestoreapi`. As mentioned in the previous code blocks, `fakestoreapi`’s
    cart response is normalized and, therefore, doesn’t include all the product data
    we need, which is why we load the products by ID.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 `getServerSideProps` 来加载购物车，然后从 `fakestoreapi` 加载相关产品。如前述代码块中所述，`fakestoreapi`
    的购物车响应是规范化的，因此不包含我们需要的所有产品数据，这就是为什么我们通过 ID 加载产品的原因。
- en: 'Once we have a cart response and all relevant product responses, we process
    the products to allow them to be looked up by ID. Finally, `getServerSideProps`
    returns `id` (the cart ID from the Next.js context), `productsById`, and `cart`
    in a `props` property of an object so that Next.js can pass them to our page component:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了购物车响应和所有相关的产品响应，我们将处理产品以允许通过 ID 查找它们。最后，`getServerSideProps` 在一个对象的 `props`
    属性中返回 `id`（Next.js 上下文中的购物车 ID）、`productsById` 和 `cart`，以便 Next.js 可以将它们传递给我们的页面组件：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we’ll add our `GetCartPage` component, which will take props as passed
    by Next.js (based on the output of `getServerSideProps`), and we’ll use them to
    render `CartContents`, as well as a heading and title:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加我们的 `GetCartPage` 组件，该组件将接受 Next.js 传递的属性（基于 `getServerSideProps` 的输出），并使用它们来渲染
    `CartContents`，以及一个标题和标题：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the checkout app to mount under the right path, we set `basePath` in its
    `next.config.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让结账应用在正确的路径下挂载，我们在其 `next.config.js` 中设置 `basePath`：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We again need to modify the root app’s `next.config.js` so that relevant requests
    are proxied to the checkout app:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改根应用的 `next.config.js`，以便相关请求被代理到结账应用：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can load `/checkout/cart/2`, and the following will display:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以加载 `/checkout/cart/2`，以下内容将显示：
- en: '![Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded](img/B19109_06_10.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10：结账区域中加载了购物车 2 的购物车/[id] 页面](img/B19109_06_10.jpg)'
- en: 'Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：结账区域中加载了购物车 2 的购物车/[id] 页面
- en: 'In the build output, we can see that `/cart/[id]` is server-side rendered,
    since it uses `getServerSideProps`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建输出中，我们可以看到 `/cart/[id]` 是服务器端渲染的，因为它使用了 `getServerSideProps`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ve now seen how to add a checkout “zone” to our micro frontend setup, next
    we’ll cover the benefits of a micro frontend “zones” architecture specifically
    with regards to working in growing teams.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何将结账“区域”添加到我们的微前端设置中，接下来我们将介绍微前端“区域”架构的益处，特别是关于在增长团队中工作的益处。
- en: The benefits/supporting team scaling
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势/支持团队扩展
- en: Using “zones” with `basePath` means that Next.js features work out of the box.
    For example, client-side transitions and `getServerSideProps` re-fetches work
    (where Next.js loads `{basePath}/_next/...`) as well as the API routes that we
    used in the search example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 `basePath` 的“区域”意味着 Next.js 的功能可以无缝工作。例如，客户端过渡和 `getServerSideProps` 重新获取功能正常工作（Next.js
    加载 `{basePath}/_next/...`），以及我们在搜索示例中使用的 API 路由。
- en: Adding new pages also “just works”; a new page at `/cart/[id]/checkout` wouldn’t
    require any changes to the root app to be available to users.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新页面也“只需如此”；在 `/cart/[id]/checkout` 的新页面不需要对根应用进行任何更改即可对用户可用。
- en: The only time we would change the root application config is to add a whole
    new app (top-level path) – for example, if we wanted an admin app, we would need
    to create that and configure the root `next.config.js`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有在需要添加一个全新的应用（顶级路径）时才会更改根应用配置——例如，如果我们想要一个管理应用，我们就需要创建它并配置根 `next.config.js`。
- en: In the case where there’s a lot of traffic to applications and we want to be
    more efficient with our resource, we don’t need to use the `root` app to forward
    all requests to the other micro frontends; we could leverage any reverse proxy
    (web servers such as NGINX and Caddy) or even the infrastructure provider’s CDN
    (e.g., Fastly, Akamai, Cloudflare and AWS) can be configured to forward all requests
    from `domain.tld/{path}/*` (all requests to `domain.tld` starting with `{path}`)
    to a specific origin.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在流量很大且我们想要更有效地使用资源的情况下，我们不需要使用 `root` 应用将所有请求转发到其他微前端；我们可以利用任何反向代理（如 NGINX 和
    Caddy）或甚至基础设施提供商的 CDN（例如 Fastly、Akamai、Cloudflare 和 AWS）来配置，以便将所有来自 `domain.tld/{path}/*`（以
    `{path}` 开头的 `domain.tld` 的所有请求）转发到特定的源。
- en: By having a suite of applications that all use Next.js, pages can be built in
    the root app experimentally and then spun off to a full Next.js application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有一系列都使用 Next.js 的应用，可以在根应用中进行实验性页面构建，然后将其扩展为完整的 Next.js 应用。
- en: For debugging and communication purposes, having the app name in the URL can
    help when discussing apps and pages with technical and non-technical team members.
    For example, even non-technical team members will understand that “this first
    section of the URL is the application name.”
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试和沟通目的，在URL中包含应用程序名称可以帮助在与技术团队和非技术团队成员讨论应用程序和页面时。例如，即使是非技术团队成员也会理解“URL的这个第一部分是应用程序名称。”
- en: One other benefit of using zones is that that request is not rewritten during
    a reverse-proxy pass. For example, in some setups, the reverse proxy would receive
    `/search` but load `/` on the search app. This means that there’s a subtle mismatch
    when running the search app locally versus when proxied.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用区域的一个其他好处是，在反向代理传递期间请求不会被重写。例如，在某些配置中，反向代理会接收到`/search`，但在搜索应用程序中加载`/`。这意味着在本地运行搜索应用程序与代理时存在细微的不匹配。
- en: Next.js was used for all systems here but is not required; most tools can be
    configured to serve out of a “sub-path,” or `basePath` as Next.js calls it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用了Next.js的所有系统，但并非必需；大多数工具都可以配置为从“子路径”或Next.js所说的`basePath`提供服务。
- en: The drawbacks of Next.js zones
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js区域的缺点
- en: In the setup we’ve demonstrated, the key drawback is that the “framework” bundle
    is not shared across apps. That means that as a user goes from one zone to another,
    they load a different version of Next.js, React, and React DOM. This is suboptimal
    but probably acceptable for a lot of use cases. When it’s not acceptable, a technique
    such as module federation or its predecessor, vendor bundles, can be deployed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示的设置中，主要缺点是“框架”包在应用程序之间没有共享。这意味着当用户从一个区域移动到另一个区域时，他们会加载不同版本的Next.js、React和React
    DOM。这不太理想，但可能适用于许多用例。当这不适用时，可以部署模块联邦或其前身，供应商包。
- en: Another drawback is that when developing locally, using `next dev`, and using
    the root app to proxy requests, we lose features such as fast refresh/live reload.
    This can be worked around by going directly to the micro frontend during local
    development.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，在本地开发时，使用`next dev`并使用根应用程序代理请求，我们会失去诸如快速刷新/实时重新加载等特性。这可以通过在本地开发期间直接访问微前端来解决这个问题。
- en: Now that we understand how we can use Next.js path-based routing, proxying,
    and base URL functionality to deliver a “zones” implementation, where the micro
    frontends each serve different subsets of the URLs, we’ll now look at how to deliver
    a micro frontend application where all the micro frontends are visible on one
    page, using the “islands” architecture with the `is-land` package. The micro frontends
    will be built using Preact and Vue.js.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用Next.js基于路径的路由、代理和基本URL功能来提供“区域”实现，其中微前端各自服务于URL的不同子集，我们现在将探讨如何使用`is-land`包中的“岛屿”架构来提供微前端应用程序，使得所有微前端都显示在单个页面上。微前端将使用Preact和Vue.js构建。
- en: Scaling performance-sensitive pages with the “islands” architecture
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“岛屿”架构扩展性能敏感页面的规模
- en: 'According to the is-land library documentation ([https://github.com/11ty/is-land](https://github.com/11ty/is-land)),
    is-land is *“A new performance-focused way to add interactive client-side components
    to your web site. Or, more technically: a framework independent partial hydration
    islands* *architecture implementation.”*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 根据is-land库文档([https://github.com/11ty/is-land](https://github.com/11ty/is-land))，is-land是*“一种新的以性能为导向的方法，用于向您的网站添加交互式客户端组件。或者，更技术性地：一个框架无关的局部水合岛屿架构实现。”*
- en: Let’s start by looking at what a “islands architecture” is. The islands architecture
    is a paradigm where a page is mainly server-rendered, and interactivity is added
    specifically where necessary. This reduces the page load time, as well as the
    amount of JavaScript being delivered (JavaScript is only delivered for specific
    client-side interactions). This is in contrast to situations where a JavaScript
    application “takes over” the full page – for example, in a Next.js app, where
    the client-side JavaScript will remount what’s been server-rendered, meaning the
    minimum amount of JavaScript running client-side by default is Next.js client
    code + React + React DOM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看“岛屿架构”是什么。岛屿架构是一种模式，其中页面主要是由服务器渲染的，并且只在必要时添加交互性。这减少了页面加载时间，以及传递的JavaScript数量（JavaScript仅用于特定的客户端交互）。这与JavaScript应用程序“接管”整个页面的情况形成对比——例如，在Next.js应用程序中，客户端JavaScript将重新挂载已由服务器渲染的内容，这意味着默认情况下在客户端运行的JavaScript的最小量是Next.js客户端代码
    + React + React DOM。
- en: The following diagram shows how the islands architecture can be leveraged to
    deliver a micro frontend experience.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了如何利用岛屿架构来提供微前端体验。
- en: Each island is responsible for its own data fetching from the server.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个岛屿都负责从服务器获取自己的数据。
- en: '![Figure 6.11: An app page composed of islands](img/B19109_06_11.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：由岛屿组成的app页面](img/B19109_06_11.jpg)'
- en: 'Figure 6.11: An app page composed of islands'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：由岛屿组成的app页面
- en: One additional element in the islands architecture is loading JavaScript on
    user interaction – for example, on a click, hover, or scroll into view of an element.
    The `is-land` package provides primitives to create islands with these types of
    hydration strategies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 岛屿架构中的一个额外元素是在用户交互时加载JavaScript – 例如，在点击、悬停或元素滚动到视图中时。`is-land`包提供了创建具有这些类型的水合策略的岛屿的原始方法。
- en: Islands setup with is-land
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用is-land设置的岛屿
- en: We’ll look at how to implement the three-islands page with a product island
    that is immediately initialized, a cart island that is initialized on interaction,
    and a related products island that is initialized when scrolled into view.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何实现包含立即初始化的产品岛屿、交互时初始化的购物车岛屿以及滚动到视图中时初始化的相关产品岛屿的三岛屿页面。
- en: Our example will demonstrate the usage of all the tools without a bundler in
    the first instance. We’ll use Preact with *htm* (since we don’t have a JSX compilation
    pipeline) and Vue with DOM templates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将演示在没有打包器的情况下使用所有工具的用法。我们将使用Preact与*htm*（因为我们没有JSX编译管道）以及Vue与DOM模板。
- en: 'In order to enable simple imports in our scripts, we’ll leverage an import
    map, loading from the [unpkg.com](http://unpkg.com) CDN:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的脚本中启用简单的导入，我们将利用导入映射，从[unpkg.com](http://unpkg.com) CDN加载：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to initialize the islands, we’ll include the `is-land` package at
    the end of the page:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化岛屿，我们将在页面末尾包含`is-land`包：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve now introduced the page we’ll be building and configured `is-land` to
    initialize on page load, next we’ll implement the product island.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了将要构建的页面，并配置了`is-land`在页面加载时初始化，接下来我们将实现产品岛屿。
- en: Product island
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品岛屿
- en: We’ll use Vue to build our product island.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Vue构建我们的产品岛屿。
- en: The first step is to create an `<is-land>` element and script.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个`<is-land>`元素和脚本。
- en: We set `on:visible` so that the contents of the island are initialized by `is-land`
    when the element is within the viewport; since our HTML contains only the product
    island, this will occur on page load.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置`on:visible`，以便当元素在视口中时，岛屿的内容由`is-land`初始化；由于我们的HTML中只包含产品岛屿，这将发生在页面加载时。
- en: We’ll create a Vue app that, on `mount`, makes an API call to `fakestoreapi.com`
    to fetch a product based on the query parameters. Around the API call using `fetch`,
    we’ll set `this.loading = true` (before the API call starts) and `this.loading
    = false` (when the API call completes).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Vue应用，在`mount`时向`fakestoreapi.com`发起API调用以根据查询参数获取产品。在`fetch` API调用周围，我们将设置`this.loading
    = true`（在API调用开始之前）和`this.loading = false`（当API调用完成时）。
- en: 'The `data` method of the Vue app will read `productId` from the URL query string,
    set loading to `true`, and set `product` to an empty object literal (`{}`):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Vue应用的数据方法将从URL查询字符串中读取`productId`，将加载设置为`true`，并将`product`设置为空对象字面量（`{}`）：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that the data is loaded, we can focus on the template; we’ll render the
    title, description, and other product information:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已加载，我们可以专注于模板；我们将渲染标题、描述和其他产品信息：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we load this page with `productId=1` or no `productId` (since it’s defaulted),
    we see the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`productId=1`或没有`productId`（因为它已默认）加载此页面时，我们看到以下输出：
- en: "![Figure 6.12: The product with\uFEFF ID 1 displaying in the product island](img/B19109_06_12.jpg)"
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：在产品岛屿中显示ID为1的产品](img/B19109_06_12.jpg)'
- en: 'Figure 6.12: The product with ID 1 displaying in the product island'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：在产品岛屿中显示ID为1的产品
- en: We’ve now seen how to implement a product island using `is-land` and Vue. Next,
    we’ll build the cart island.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用`is-land`和Vue实现产品岛屿。接下来，我们将构建购物车岛屿。
- en: Cart island
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车岛屿
- en: 'Again, we’ll start with an `is-land` element, this time with `on:interaction`,
    which means the island will initialize only when the user clicks on it (we’ll
    show a button for them to do so):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从一个`is-land`元素开始，这次是`on:interaction`，这意味着岛屿只有在用户点击它时才会初始化（我们将显示一个按钮供他们点击）：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we’ll build a `CartContainer` component that will be mounted using Preact.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个`CartContainer`组件，它将使用Preact挂载。
- en: '`CartContainer` loads cart and product information from `fakestoreapi.com`
    and stores it in state for a `CartContents` component to render:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`CartContainer` 从 `fakestoreapi.com` 加载购物车和产品信息，并将其存储在状态中，以便 `CartContents`
    组件进行渲染：'
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we’ll implement `CartContents`, in which we loop through the cart
    and render pricing information:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现 `CartContents`，在其中遍历购物车并渲染定价信息：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we load our page with `cartId 1` and `productId 1` and open the cart contents,
    we can see that it renders the cart with ID 1, including the three line items,
    their amount, the subtotal per item, and the cart total.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `cartId 1` 和 `productId 1` 加载我们的页面并打开购物车内容时，我们可以看到它渲染了 ID 为 1 的购物车，包括三个项目，它们的数量，每个项目的小计，以及购物车总额。
- en: "![Figure 6\uFEFF.13: Cart 1 rendering in the cart island](img/B19109_06_13.jpg)"
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13：购物车岛上的购物车 1 渲染](img/B19109_06_13.jpg)'
- en: 'Figure 6.13: Cart 1 rendering in the cart island'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13：购物车岛上的购物车 1 渲染
- en: We’ve now implemented the cart island with Preact, next we’ll implement a related
    products island which initializes only when it’s visible.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用 Preact 实现了购物车岛，接下来我们将实现一个相关产品岛，它仅在可见时初始化。
- en: A related products island
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个相关产品岛
- en: Finally, we’ll build our related products island. The island itself is quite
    straightforward, but communicating which product is being displayed and its category
    is trickier.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将构建我们的相关产品岛。岛屿本身相当直接，但传达展示的产品及其类别则更为复杂。
- en: We’ll build an island that waits to be visible to initialize itself, again using
    `on:visible` but also `on:idle`. This means the island will load either when it’s
    visible or when other processing has completed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个岛屿，等待可见性来初始化自己，再次使用 `on:visible` 但也使用 `on:idle`。这意味着岛屿将在可见或其他处理完成时加载。
- en: The island will mount if it receives a `product-category-load` custom event.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果岛屿接收到 `product-category-load` 自定义事件，它将挂载。
- en: 'We’ll start by building the `RelatedProducts` component, which will receive
    three props – `selectedProductId`, `category`, and `from`. The `from` value will
    be displayed in an `h3` element we render to illustrate how the island received
    its data:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建 `RelatedProducts` 组件，该组件将接收三个属性——`selectedProductId`、`category` 和 `from`。`from`
    值将在我们渲染的 `h3` 元素中显示，以说明岛屿如何接收其数据：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, based on the category, we want to load all possible products from `fakestoreapi.com`.
    We’ll store the value using the `useState()` hook, and loading the related products
    will be done on component mount, using the `useEffect()` hook.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据类别，我们希望从 `fakestoreapi.com` 加载所有可能的产品。我们将使用 `useState()` 钩子存储值，并且加载相关产品将在组件挂载时完成，使用
    `useEffect()` 钩子。
- en: 'The data fetching logic is as follows. We’ll make an API call to `fakestoreapi.com`
    using the provided category. To fulfill the “related” requirement of the “related
    products,” we’ll exclude the product that’s currently being displayed – that is,
    remove the product with an ID equal to `selectedProductId` from the products list.
    Finally, we sort the related products by rating and persist the first three items
    to state, using `setRelatedProducts`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取逻辑如下。我们将使用提供的类别调用 `fakestoreapi.com` 的 API。为了满足“相关产品”的“相关”要求，我们将排除当前显示的产品——即从产品列表中移除
    ID 等于 `selectedProductId` 的产品。最后，我们按评分对相关产品进行排序，并使用 `setRelatedProducts` 将前三个项目持久化到状态中：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the data persisted to `relatedProducts`, we can now render them using
    the `.map` function which returns a list. For each product, we want to show a
    title that’s also a link to view the product, its price, an image, and the rating
    information:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据持久化到 `relatedProducts` 后，我们可以现在使用 `.map` 函数渲染它们，该函数返回一个列表。对于每个产品，我们希望显示一个标题，该标题也是一个查看产品的链接，其价格，一张图片，以及评分信息：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we’ll add logic to mount `RelatedProducts`, based on an event listener
    for the `product-category-load` custom event:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加逻辑来挂载 `RelatedProducts`，基于对 `product-category-load` 自定义事件的监听器：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to ensure that `product-category-load` is dispatched from the
    product island. We need to make the following change to the “mounted” life cycle
    hook of the Vue.js product island script:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保从产品岛发出 `product-category-load` 事件。我们需要对 Vue.js 产品岛脚本的“mounted”生命周期钩子进行以下更改：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There’s also a condition whereby the `product-category-load` is emitted before
    the related products island is initialized; in order to work around this, we’ll
    store the information in the `#related-products-island-wrapper` element’s `dataset`
    property:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个条件，即在初始化相关产品岛之前会发出 `product-category-load` 事件；为了解决这个问题，我们将在 `#related-products-island-wrapper`
    元素的 `dataset` 属性中存储信息：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can then use that information as a mounting condition as well:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将此信息用作挂载条件：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We render `from` to illustrate that both the `dataset`-based approach and the
    event-based approach both function in different scenarios.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `from` 来说明基于 `dataset` 的方法和基于事件的方法都在不同的场景下工作。
- en: 'If we load the page and scroll down to the related products (which are initially
    below outside the viewport), we’ll see the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载页面并向下滚动到相关产品（最初位于视口外），我们会看到以下内容：
- en: '![Figure 6.14: The related products island with category information from data
    attributes](img/B19109_06_14.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14：带有来自数据属性的类别信息的相关产品岛屿](img/B19109_06_14.jpg)'
- en: 'Figure 6.14: The related products island with category information from data
    attributes'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：带有来自数据属性的类别信息的相关产品岛屿
- en: If we then reload the page, the scroll position will be such that the related
    products island is in view and initializes immediately, meaning the data comes
    from the custom event directly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新加载页面，滚动位置将使得相关产品岛屿可见并立即初始化，这意味着数据直接来自自定义事件。
- en: "![Figure 6.15: The related products island w\uFEFFith category information\
    \ from the custom event](img/B19109_06_15.jpg)"
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15：带有来自自定义事件的类别信息的相关产品岛屿](img/B19109_06_15.jpg)'
- en: 'Figure 6.15: The related products island with category information from the
    custom event'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：带有来自自定义事件的类别信息的相关产品岛屿
- en: We’ve now implemented the related products island with Preact and two approaches
    to reading the product category. Next, we’ll see how to use bundling in conjunction
    with the islands architecture.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了使用 Preact 的相关产品岛屿，并采用了两种读取产品类别的方案。接下来，我们将看到如何结合岛屿架构使用捆绑。
- en: Scaling with a team – bundling islands
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与团队一起扩展 - 捆绑岛屿
- en: 'We can move the bulk of the code for a particular island to an external file
    and then use a tool such as `esbuild` to bundle it together. The following uses
    `.jsx` files for Preact, but a copy and paste of the existing files using `htm`
    would also work:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将特定岛屿的大部分代码移动到外部文件，然后使用 `esbuild` 等工具将其捆绑在一起。以下使用 `.jsx` 文件为 Preact，但使用
    `htm` 复制粘贴现有文件也会有效：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The outputted files can then be used as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的文件可以按以下方式使用：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Each team can own one or more islands by providing a JavaScript bundle for them
    and/or a template (the template needs to be a server-side include).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队可以通过提供 JavaScript 包和/或模板（模板需要是服务器端包含）来拥有一个或多个岛屿。
- en: Drawbacks
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: In the bundled use case, our two Preact islands don’t share a Preact version,
    which means that this dependency will be loaded twice in the browser. This can
    be fixed with vendor bundles or module federation, as mentioned in the previous
    section. Also, note that it’s not an issue for the initial version of the code
    where the scripts for the islands were in the page itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑用例中，我们的两个 Preact 岛屿不共享 Preact 版本，这意味着这个依赖将在浏览器中加载两次。这可以通过供应商捆绑或模块联邦来解决，如前所述。此外，请注意，对于岛屿脚本位于页面本身的初始代码版本，这不是一个问题。
- en: Challenges in an islands architecture mainly relate to component communication
    (as we’ve illustrated with the related products island) and the mechanism used
    to compose the templates and scripts in a unified page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 岛屿架构中的挑战主要与组件通信（正如我们通过相关产品岛屿所展示的）以及用于在统一页面上组合模板和脚本的机制有关。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve covered micro frontends, common approaches, and how the
    zones and islands architectures with Next.js and `is-land` allow us to build high-development
    velocity systems without compromising the user experience.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了微前端、常见方法以及如何使用 Next.js 和 `is-land` 构建高开发速度的系统，同时不损害用户体验。
- en: Micro frontends allow teams to have strong governance over different parts of
    a frontend ecosystem without compromising the user experience. Micro frontends
    allow more teams and their skills to be brought to bear effectively, which increases
    delivery velocity across the board. Common approaches include a container application
    with “server-side includes,” build-time integration via shared packages, and runtime
    integrations (e.g., iframes, JavaScript, and Web Components).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端允许团队在没有损害用户体验的情况下对前端生态系统的不同部分进行强有力的治理。微前端允许更多团队及其技能有效地发挥作用，从而提高整体交付速度。常见的方法包括具有“服务器端包含”的容器应用程序、通过共享包在构建时集成以及运行时集成（例如iframe、JavaScript
    和 Web 组件）。
- en: The recommended Next.js “zones” approach allows different micro frontends to
    be mounted on different “base paths.” The zones approach is a more flexible type
    of server-side includes; apps are “included” via a reverse-proxy and URLs. On
    a conceptual level, domain-specific applications that can deliver multiple pages
    and API routes are a great tool to leverage for larger teams.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的 Next.js “zones” 方法允许不同的微前端在不同的“基础路径”上挂载。zones 方法是一种更灵活的服务端包含类型；应用通过反向代理和
    URL 被包含。从概念上讲，能够提供多个页面和 API 路由的特定领域应用是大型团队可以利用的强大工具。
- en: Finally, we discussed the “islands” architecture implemented via the `is-land`
    package, which demonstrated a lightweight micro frontend approach with multiple
    JavaScript based libraries for different components. `is-land`’s ability to do
    partial hydration is a clear benefit to end users. Cross-island communication,
    a common challenge of the islands architecture, was addressed with an approach
    that includes `CustomEvent`’s and HTML data attributes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了通过 `is-land` 包实现的“islands”架构，它展示了使用多个基于 JavaScript 的库为不同组件提供轻量级微前端方法。`is-land`
    进行部分激活的能力对最终用户来说是一个明显的优势。岛屿间的通信，岛屿架构的常见挑战，通过包括 `CustomEvent` 和 HTML 数据属性的方法得到了解决。
- en: Now that we’ve covered modern micro frontend approaches and the “zones” and
    “islands” architectures, we will look at patterns for performant asynchronous
    programming in JavaScript in the next chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了现代微前端方法和“zones”以及“islands”架构，我们将在下一章中探讨在 JavaScript 中进行高效异步编程的模式。
