- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Micro Frontends, Zones, and Islands Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The micro frontend architecture, and specifically the “zones” and “islands”
    patterns, mirror the microservices architecture for backend systems. Given the
    right tooling, they allow multiple teams to maintain high-velocity development
    on a single product. The techniques covered in this chapter look at system-level
    interaction and integration patterns. Each system can leverage creational, structural,
    behavioral, and reactive view library patterns, as covered in *Chapters* *1*,
    *2*, *3*, and *4* respectively. Micro frontend architectures help link systems
    together as opposed to structuring the code within each of them better.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The problem space that micro frontends address, including some common approaches
    and their drawbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Next.js features to build a “zones” micro frontend setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **is-land** package to deliver an “islands” micro frontend setup with
    islands in Preact and Vue.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to discuss the trade-offs and deliver
    modern micro frontend approaches in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  prefs: []
  type: TYPE_NORMAL
- en: An overview of micro frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A micro frontend setup is one where multiple frontend applications or components
    are composed. This is akin to microservices, where a micro frontend would encapsulate
    a subset of functionality, or “bounded context.”
  prefs: []
  type: TYPE_NORMAL
- en: For example, in an e-commerce setting, we might have a “search” micro frontend
    and a “cart” or “checkout” micro frontend.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: A simplified micro frontends diagram](img/B19109_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: A simplified micro frontends diagram'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now introduced the micro frontends architecture; next, we’ll see at the
    key benefits micro frontends deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Key benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The benefits of the micro frontend patterns are similar to microservice benefits.
    They usually come in the sociotechnical aspect of development.
  prefs: []
  type: TYPE_NORMAL
- en: Each micro frontend can use a different set of technologies, which means the
    right tool for the job can be selected. A very page-load performance-sensitive
    page might use a different stack than an admin interface or a high-volume SVG
    visualization page.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental upgrades are available, and changes can be tested in one component
    before being rolled out to all components.
  prefs: []
  type: TYPE_NORMAL
- en: The releases of different micro frontends are not locked together. This can
    help when scaling, where each team might work on one or more of the micro frontends.
    They can be released independently of other teams, meaning the cadence can increase;
    this is related to the last benefit we’ll discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Each micro frontend can have its own code base, and “bounded contexts” can be
    strictly enforced.
  prefs: []
  type: TYPE_NORMAL
- en: “Classic” micro frontend patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll cover five different “classic” approaches to creating a micro frontend
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the “container application” using server-side includes. This leverages
    a server that will fetch from the different micro frontends and stitch them together.
    This is illustrated in the following diagram, where the container application
    loads a “cart” HTML section and a “search” HTML section and injects them into
    its own template, before returning to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: The “container application” sequence](img/B19109_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The “container application” sequence'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of server-side include, or the “container application,” is that
    deployments of each micro frontend are decoupled (e.g., we can deploy changes
    to the cart without deploying changes to the search section or the container);
    in addition, it’s completely technology-agnostic, as micro frontends don’t even
    need to use JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The next “classic” approach we’ll see is different, using “build-time composition,”
    where each micro frontend is a package, usually a npm package (part of the Node.js/JavaScript
    toolchain). Each package is then imported where necessary and composed at “build-time”
    (when each application is packaged for deployment).
  prefs: []
  type: TYPE_NORMAL
- en: The key drawback of “build-time” composition is that releases now require deployment
    cascades. For all the applications to receive updates to the “cart”, we need to
    update the version and release all the applications.
  prefs: []
  type: TYPE_NORMAL
- en: The three final “classic” approaches are similar conceptually although use different
    technologies. They’re all “runtime integrations”; the technologies are iframes,
    JavaScript, and web components. Runtime integrations mean that the micro frontend
    requests the micro frontend resource from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of iframes, this involves using the iframe `src` attribute. The
    main downside of this is that each micro frontend needs to be secured against
    all public network exploits. What’s more, allowing the iframing of an application’s
    content can lead to click-jacking vulnerabilities if not done carefully, so there
    are security implications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Runtime integration with iframes](img/B19109_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Runtime integration with iframes'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of JavaScript or Web Component “runtime” integration, the composition
    is managed by loading JavaScript files. This is more ideal than using iframes,
    since serving JavaScript to the browser has fewer security implications than allowing
    the framing of your content. In the Web Components case, you would have both the
    web component referenced in the body of the HTML and a reference to the scripts
    required to run the Web Component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Runtime integration with JavaScript or web components](img/B19109_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Runtime integration with JavaScript or web components'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime integrations have a performance impact on the user experience, as shown
    by the difference in diagrams between our “server-side includes” and “runtime
    integration” diagrams. In the “server-side includes” case, the server composes
    a full application before returning it to the customer. In the “runtime integration”,
    the server returns what are essentially resource references to the browser, which
    then has to load these resources.
  prefs: []
  type: TYPE_NORMAL
- en: As we explore the “zones” and “islands” modern implementations of micro frontends,
    we’ll encounter several instances of these techniques used together.
  prefs: []
  type: TYPE_NORMAL
- en: Other concerns in a micro frontend world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a microservice setup, micro frontends that allow different teams
    to build in their own way can be a benefit and a drawback.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, most frontend systems will need to communicate with a
    backend service. How to do this remains something to be decided – should each
    team deploy its own **backend for frontend** (**BFF**), should a single gateway
    be deployed that exposes relevant service endpoints, or should it be a gateway
    that wraps services in a different query system such as GraphQL?
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontends also cause challenges for testing. How do we reliably test at
    the “user journey” level, which might go through multiple micro frontends, when
    each of the micro frontends also has its own test suite?
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the questions about which backend integrations to use, there’s a
    challenge related to shared styles and potentially component libraries. Teams
    doing micro frontends might standardize on a set technology (React, Vue, etc)
    in order to gain the benefits of a component library. Component libraries are
    more difficult to maintain in multiple technologies, but companies sometimes opt
    for this to support their engineers in picking the right tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: One big challenge of micro frontends is how to keep them performant. Even in
    a case where all teams use the same technologies, it’s likely that the same dependency
    is duplicated across micro frontends, which has a performance impact. When technologies
    and build and deploy processes diverge (which is possible with micro frontends),
    this problem is exacerbated.
  prefs: []
  type: TYPE_NORMAL
- en: The other performance issue that occurs with, for example, “server-side includes”
    is that the page will only load as fast as the slowest component on the page.
    This is less of an issue with runtime integrations, but the idea that each micro
    frontend might affect a whole page’s performance is a relevant one with regard
    to the challenges of building a system using micro frontends.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as we’ve alluded to with regard to testing micro frontends, it causes
    operational and governance complexities. For example, environment mismatch issues
    are harder to detect. Running or deploying a full environment for development
    or testing with multiple micro frontends is more complex than with a monolithic
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined and contrasted the benefits and drawbacks of micro frontends
    in general and specific micro frontend approaches, we can look at modern implementations
    of micro frontends. In the following section, we’ll look at leveraging Next.js
    and “zones” in order to build flexible micro frontends.
  prefs: []
  type: TYPE_NORMAL
- en: Composing applications with Next.js “zones”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next.js “zones” are a URL “base path”-driven approach to composing Next.js applications.
    This allows us to build a micro frontend setup with Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: What this means, as shown in the figure that follows, is that an e-commerce
    use case, where the user might request four sets of URLs (`GET /, GET /careers,
    GET /search, and GET /cart/{id}), "{id}"`), denotes that the cart has a dynamic
    segment, which is the cart ID that is requested. For `GET /` and `GET /careers`,
    the request first goes to the `root` frontend, which handles rendering directly.
    For `GET /search`, the request goes to the root frontend, which forwards the request
    to the search frontend. Similarly, for `GET /cart/{id}` requests, the request
    initially is sent to the root frontend, which proxies the request to the checkout
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.5: An overview flowchart of a three-app Next.js\uFEFF zone setup](img/B19109_06_5.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: An overview flowchart of a three-app Next.js zone setup'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now introduced Next.js “zones” and an overview of our implementation,
    next we’ll implement the “root app”.
  prefs: []
  type: TYPE_NORMAL
- en: Root app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The root app contains two pages, `/` (`pages/index.js`) and `/careers` (`pages/careers.js`).
    Both of these pages are statically rendered, `index.js` via automatic static generation
    (since it doesn’t have `getServerSideProps` or `getInitialProps`) and `careers.js`
    via static site generation (since it has `getStaticProps`).
  prefs: []
  type: TYPE_NORMAL
- en: '`index.js` contains a heading as well as `Head` content.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we load the `GET` `/` path, our root app renders the `h1` element we placed
    within it, with `'Root'` as its content.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: The Root page rendered](img/B19109_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The Root page rendered'
  prefs: []
  type: TYPE_NORMAL
- en: The `/careers` page loads roles from an API using `getStaticProps` and displays
    them in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with a `getStaticProps` function in `pages/careers.js`. This function
    loads from a “fake jobs” API and returns a `roles` prop, which includes the returned
    data from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll add a `CareersPages` component. It includes the page scaffolding
    with `title` and `h1`. It also loops through the `roles` prop to render it as
    a list, using `ul` and `li`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It displays as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: The Careers page in the root zone](img/B19109_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The Careers page in the root zone'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `next build` output shows that `index.js` is indeed statically rendered,
    while `/``careers` uses static site generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now started implementing the root app, we’ll move on to our second zone,
    the “search” zone.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a /search app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll build and mount a `/``search` page.
  prefs: []
  type: TYPE_NORMAL
- en: '`search/pages/index.js` displays an input and makes a call to the `/search/api/search`
    route on change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `search/pages/api/search` API route, we create `pages/api/search`,
    which loads products from `fakestoreapi` and finds a match between the title,
    description and category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for `search-app/` to be mounted under `search-app/search`, we’ll use
    `basePath` in `next.config.js` in the search app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll expose `search` via the root app’s `next.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then load the **Search** page, which displays as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: The Search page on load](img/B19109_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The Search page on load'
  prefs: []
  type: TYPE_NORMAL
- en: The search works – for example, with the `jacket` search term.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: The Search page with the jacket search term](img/B19109_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: The Search page with the jacket search term'
  prefs: []
  type: TYPE_NORMAL
- en: '`/search` is statically rendered via automatic static rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now implemented the search “zone”, next we’ll implement the checkout “zone”.
  prefs: []
  type: TYPE_NORMAL
- en: Adding /checkout app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll add a “view cart” page in a new checkout Next.js app under `pages/cart/[id].js`.
  prefs: []
  type: TYPE_NORMAL
- en: The cart page loads a cart and its contained products from `fakestoreapi`, displaying
    them via a `CartContents` component.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll define a `CartContents` component that takes `cart` and `productsById`
    props. It then maps through `cart.products`, extracting the product’s title and
    the quantity requested in the cart, before computing and formatting the price
    in euros using `.toLocaleString`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need `cart` and `productsById` is that the cart comes back in
    a normalized data format, meaning it contains only cart-specific information and
    none of the related product’s information, except the product ID. Therefore, we
    need to do a lookup based on the product ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our rendering logic uses an unordered list container (the `ul` HTML element)
    and list item elements (`li` HTML elements). We render the title in an `h3` heading
    and the rest of the information using `span` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’re rendering the contents of the cart, the additional functionality
    we’ll add to `CartContents` is a display of the cart’s total price.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by adding another `li`, which displays “Total:” and computes the
    total price, using `reduce` over `cart.products`. Remember from the previous code
    block that `cart.products` is normalized, meaning that it doesn’t contain any
    information about the product (e.g., its price), apart from the product’s ID.
    This means that our reduce handler does a lookup on `productsById[product.productId]`
    in order to access the product’s price.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the quantity of a given product in the cart and the price of the
    product, we simply multiply them together and sum the quantity times the price
    result to the accumulator, which we initialized as 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the cart items, we use `toLocaleString` to format the total price
    in euros as an en localized string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ll leverage `getServerSideProps` to load the cart, and then the relevant
    products from `fakestoreapi`. As mentioned in the previous code blocks, `fakestoreapi`’s
    cart response is normalized and, therefore, doesn’t include all the product data
    we need, which is why we load the products by ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a cart response and all relevant product responses, we process
    the products to allow them to be looked up by ID. Finally, `getServerSideProps`
    returns `id` (the cart ID from the Next.js context), `productsById`, and `cart`
    in a `props` property of an object so that Next.js can pass them to our page component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll add our `GetCartPage` component, which will take props as passed
    by Next.js (based on the output of `getServerSideProps`), and we’ll use them to
    render `CartContents`, as well as a heading and title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For the checkout app to mount under the right path, we set `basePath` in its
    `next.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We again need to modify the root app’s `next.config.js` so that relevant requests
    are proxied to the checkout app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can load `/checkout/cart/2`, and the following will display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded](img/B19109_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: The cart/[id] page in the checkout zone with cart 2 loaded'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the build output, we can see that `/cart/[id]` is server-side rendered,
    since it uses `getServerSideProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how to add a checkout “zone” to our micro frontend setup, next
    we’ll cover the benefits of a micro frontend “zones” architecture specifically
    with regards to working in growing teams.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits/supporting team scaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using “zones” with `basePath` means that Next.js features work out of the box.
    For example, client-side transitions and `getServerSideProps` re-fetches work
    (where Next.js loads `{basePath}/_next/...`) as well as the API routes that we
    used in the search example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new pages also “just works”; a new page at `/cart/[id]/checkout` wouldn’t
    require any changes to the root app to be available to users.
  prefs: []
  type: TYPE_NORMAL
- en: The only time we would change the root application config is to add a whole
    new app (top-level path) – for example, if we wanted an admin app, we would need
    to create that and configure the root `next.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case where there’s a lot of traffic to applications and we want to be
    more efficient with our resource, we don’t need to use the `root` app to forward
    all requests to the other micro frontends; we could leverage any reverse proxy
    (web servers such as NGINX and Caddy) or even the infrastructure provider’s CDN
    (e.g., Fastly, Akamai, Cloudflare and AWS) can be configured to forward all requests
    from `domain.tld/{path}/*` (all requests to `domain.tld` starting with `{path}`)
    to a specific origin.
  prefs: []
  type: TYPE_NORMAL
- en: By having a suite of applications that all use Next.js, pages can be built in
    the root app experimentally and then spun off to a full Next.js application.
  prefs: []
  type: TYPE_NORMAL
- en: For debugging and communication purposes, having the app name in the URL can
    help when discussing apps and pages with technical and non-technical team members.
    For example, even non-technical team members will understand that “this first
    section of the URL is the application name.”
  prefs: []
  type: TYPE_NORMAL
- en: One other benefit of using zones is that that request is not rewritten during
    a reverse-proxy pass. For example, in some setups, the reverse proxy would receive
    `/search` but load `/` on the search app. This means that there’s a subtle mismatch
    when running the search app locally versus when proxied.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js was used for all systems here but is not required; most tools can be
    configured to serve out of a “sub-path,” or `basePath` as Next.js calls it.
  prefs: []
  type: TYPE_NORMAL
- en: The drawbacks of Next.js zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the setup we’ve demonstrated, the key drawback is that the “framework” bundle
    is not shared across apps. That means that as a user goes from one zone to another,
    they load a different version of Next.js, React, and React DOM. This is suboptimal
    but probably acceptable for a lot of use cases. When it’s not acceptable, a technique
    such as module federation or its predecessor, vendor bundles, can be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback is that when developing locally, using `next dev`, and using
    the root app to proxy requests, we lose features such as fast refresh/live reload.
    This can be worked around by going directly to the micro frontend during local
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how we can use Next.js path-based routing, proxying,
    and base URL functionality to deliver a “zones” implementation, where the micro
    frontends each serve different subsets of the URLs, we’ll now look at how to deliver
    a micro frontend application where all the micro frontends are visible on one
    page, using the “islands” architecture with the `is-land` package. The micro frontends
    will be built using Preact and Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling performance-sensitive pages with the “islands” architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the is-land library documentation ([https://github.com/11ty/is-land](https://github.com/11ty/is-land)),
    is-land is *“A new performance-focused way to add interactive client-side components
    to your web site. Or, more technically: a framework independent partial hydration
    islands* *architecture implementation.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at what a “islands architecture” is. The islands architecture
    is a paradigm where a page is mainly server-rendered, and interactivity is added
    specifically where necessary. This reduces the page load time, as well as the
    amount of JavaScript being delivered (JavaScript is only delivered for specific
    client-side interactions). This is in contrast to situations where a JavaScript
    application “takes over” the full page – for example, in a Next.js app, where
    the client-side JavaScript will remount what’s been server-rendered, meaning the
    minimum amount of JavaScript running client-side by default is Next.js client
    code + React + React DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows how the islands architecture can be leveraged to
    deliver a micro frontend experience.
  prefs: []
  type: TYPE_NORMAL
- en: Each island is responsible for its own data fetching from the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: An app page composed of islands](img/B19109_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: An app page composed of islands'
  prefs: []
  type: TYPE_NORMAL
- en: One additional element in the islands architecture is loading JavaScript on
    user interaction – for example, on a click, hover, or scroll into view of an element.
    The `is-land` package provides primitives to create islands with these types of
    hydration strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Islands setup with is-land
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at how to implement the three-islands page with a product island
    that is immediately initialized, a cart island that is initialized on interaction,
    and a related products island that is initialized when scrolled into view.
  prefs: []
  type: TYPE_NORMAL
- en: Our example will demonstrate the usage of all the tools without a bundler in
    the first instance. We’ll use Preact with *htm* (since we don’t have a JSX compilation
    pipeline) and Vue with DOM templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable simple imports in our scripts, we’ll leverage an import
    map, loading from the [unpkg.com](http://unpkg.com) CDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to initialize the islands, we’ll include the `is-land` package at
    the end of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now introduced the page we’ll be building and configured `is-land` to
    initialize on page load, next we’ll implement the product island.
  prefs: []
  type: TYPE_NORMAL
- en: Product island
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll use Vue to build our product island.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create an `<is-land>` element and script.
  prefs: []
  type: TYPE_NORMAL
- en: We set `on:visible` so that the contents of the island are initialized by `is-land`
    when the element is within the viewport; since our HTML contains only the product
    island, this will occur on page load.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a Vue app that, on `mount`, makes an API call to `fakestoreapi.com`
    to fetch a product based on the query parameters. Around the API call using `fetch`,
    we’ll set `this.loading = true` (before the API call starts) and `this.loading
    = false` (when the API call completes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data` method of the Vue app will read `productId` from the URL query string,
    set loading to `true`, and set `product` to an empty object literal (`{}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the data is loaded, we can focus on the template; we’ll render the
    title, description, and other product information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we load this page with `productId=1` or no `productId` (since it’s defaulted),
    we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.12: The product with\uFEFF ID 1 displaying in the product island](img/B19109_06_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: The product with ID 1 displaying in the product island'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to implement a product island using `is-land` and Vue. Next,
    we’ll build the cart island.
  prefs: []
  type: TYPE_NORMAL
- en: Cart island
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, we’ll start with an `is-land` element, this time with `on:interaction`,
    which means the island will initialize only when the user clicks on it (we’ll
    show a button for them to do so):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll build a `CartContainer` component that will be mounted using Preact.
  prefs: []
  type: TYPE_NORMAL
- en: '`CartContainer` loads cart and product information from `fakestoreapi.com`
    and stores it in state for a `CartContents` component to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll implement `CartContents`, in which we loop through the cart
    and render pricing information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we load our page with `cartId 1` and `productId 1` and open the cart contents,
    we can see that it renders the cart with ID 1, including the three line items,
    their amount, the subtotal per item, and the cart total.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6\uFEFF.13: Cart 1 rendering in the cart island](img/B19109_06_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Cart 1 rendering in the cart island'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now implemented the cart island with Preact, next we’ll implement a related
    products island which initializes only when it’s visible.
  prefs: []
  type: TYPE_NORMAL
- en: A related products island
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we’ll build our related products island. The island itself is quite
    straightforward, but communicating which product is being displayed and its category
    is trickier.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build an island that waits to be visible to initialize itself, again using
    `on:visible` but also `on:idle`. This means the island will load either when it’s
    visible or when other processing has completed.
  prefs: []
  type: TYPE_NORMAL
- en: The island will mount if it receives a `product-category-load` custom event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by building the `RelatedProducts` component, which will receive
    three props – `selectedProductId`, `category`, and `from`. The `from` value will
    be displayed in an `h3` element we render to illustrate how the island received
    its data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, based on the category, we want to load all possible products from `fakestoreapi.com`.
    We’ll store the value using the `useState()` hook, and loading the related products
    will be done on component mount, using the `useEffect()` hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data fetching logic is as follows. We’ll make an API call to `fakestoreapi.com`
    using the provided category. To fulfill the “related” requirement of the “related
    products,” we’ll exclude the product that’s currently being displayed – that is,
    remove the product with an ID equal to `selectedProductId` from the products list.
    Finally, we sort the related products by rating and persist the first three items
    to state, using `setRelatedProducts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data persisted to `relatedProducts`, we can now render them using
    the `.map` function which returns a list. For each product, we want to show a
    title that’s also a link to view the product, its price, an image, and the rating
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll add logic to mount `RelatedProducts`, based on an event listener
    for the `product-category-load` custom event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to ensure that `product-category-load` is dispatched from the
    product island. We need to make the following change to the “mounted” life cycle
    hook of the Vue.js product island script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also a condition whereby the `product-category-load` is emitted before
    the related products island is initialized; in order to work around this, we’ll
    store the information in the `#related-products-island-wrapper` element’s `dataset`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use that information as a mounting condition as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We render `from` to illustrate that both the `dataset`-based approach and the
    event-based approach both function in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we load the page and scroll down to the related products (which are initially
    below outside the viewport), we’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: The related products island with category information from data
    attributes](img/B19109_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: The related products island with category information from data
    attributes'
  prefs: []
  type: TYPE_NORMAL
- en: If we then reload the page, the scroll position will be such that the related
    products island is in view and initializes immediately, meaning the data comes
    from the custom event directly.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.15: The related products island w\uFEFFith category information\
    \ from the custom event](img/B19109_06_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: The related products island with category information from the
    custom event'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now implemented the related products island with Preact and two approaches
    to reading the product category. Next, we’ll see how to use bundling in conjunction
    with the islands architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling with a team – bundling islands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can move the bulk of the code for a particular island to an external file
    and then use a tool such as `esbuild` to bundle it together. The following uses
    `.jsx` files for Preact, but a copy and paste of the existing files using `htm`
    would also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputted files can then be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Each team can own one or more islands by providing a JavaScript bundle for them
    and/or a template (the template needs to be a server-side include).
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the bundled use case, our two Preact islands don’t share a Preact version,
    which means that this dependency will be loaded twice in the browser. This can
    be fixed with vendor bundles or module federation, as mentioned in the previous
    section. Also, note that it’s not an issue for the initial version of the code
    where the scripts for the islands were in the page itself.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges in an islands architecture mainly relate to component communication
    (as we’ve illustrated with the related products island) and the mechanism used
    to compose the templates and scripts in a unified page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve covered micro frontends, common approaches, and how the
    zones and islands architectures with Next.js and `is-land` allow us to build high-development
    velocity systems without compromising the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontends allow teams to have strong governance over different parts of
    a frontend ecosystem without compromising the user experience. Micro frontends
    allow more teams and their skills to be brought to bear effectively, which increases
    delivery velocity across the board. Common approaches include a container application
    with “server-side includes,” build-time integration via shared packages, and runtime
    integrations (e.g., iframes, JavaScript, and Web Components).
  prefs: []
  type: TYPE_NORMAL
- en: The recommended Next.js “zones” approach allows different micro frontends to
    be mounted on different “base paths.” The zones approach is a more flexible type
    of server-side includes; apps are “included” via a reverse-proxy and URLs. On
    a conceptual level, domain-specific applications that can deliver multiple pages
    and API routes are a great tool to leverage for larger teams.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed the “islands” architecture implemented via the `is-land`
    package, which demonstrated a lightweight micro frontend approach with multiple
    JavaScript based libraries for different components. `is-land`’s ability to do
    partial hydration is a clear benefit to end users. Cross-island communication,
    a common challenge of the islands architecture, was addressed with an approach
    that includes `CustomEvent`’s and HTML data attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered modern micro frontend approaches and the “zones” and
    “islands” architectures, we will look at patterns for performant asynchronous
    programming in JavaScript in the next chapter.
  prefs: []
  type: TYPE_NORMAL
