<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Base, Sandbox, and Core Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Base, Sandbox, and Core Modules</h1></div></div></div><p>So far in this book, we have mostly looked at different techniques for creating and enhancing modules. However, our focus has been on the smaller pieces of the application.</p><p>In this chapter, we are going to<a id="id291" class="indexterm"/> take a holistic view of our application as a complete functioning body. We will see how its various pieces can be put together to create a robust and flexible ecosystem to deliver our ultimate goal, which is a working <span class="strong"><strong>Single-Page Application </strong></span>(<span class="strong"><strong>SPA</strong></span>).</p><p>As you read through different sections of this chapter, keep in mind that all the pieces of the application are designed to work together in concert, while still adhering to the principles of maintainability and extensibility of a modular design.</p><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Base module and its design</li><li class="listitem" style="list-style-type: disc">Sandbox and the principles behind sandboxing of our components</li><li class="listitem" style="list-style-type: disc">Core and its related modules</li><li class="listitem" style="list-style-type: disc">Components and how they are added to the application</li><li class="listitem" style="list-style-type: disc">Plug-and-play, progressive enhancement, and graceful degradation in our application</li></ul></div><p>Note that we will not get too deep into the coding aspect of things here, since I would really like you to focus on the architecture of the application, as opposed to being distracted with the details of the implementation. As such, there is no project code associated with this chapter of the book.</p><p>I should also mention that the architectural design concepts discussed in this chapter, and the next, are based on the design principles that I was originally introduced to by <span class="emphasis"><em>Nicholas C. Zakas</em></span>, after watching one of his talks on the subject. He is one of my favorite authors and speakers. While our implementation will slightly deviate from his, the essence of our architecture will remain similar to his proposed architectural design.</p><div class="section" title="Application architecture overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Application architecture overview</h1></div></div></div><p>To create a truly modular <a id="id292" class="indexterm"/>design for our application, we need to break it down into smaller functional pieces, in such a way that each piece will specialize in and be responsible for very specific tasks. This enables us to achieve the principle of separation of concerns and responsibilities.</p><p>The following diagram provides a depiction of our overall application design:</p><div class="mediaobject"><img src="graphics/B04910_07_01.jpg" alt="Application architecture overview"/></div><p>As you can see, our application consists of four main pieces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Base</li><li class="listitem" style="list-style-type: disc">Sandbox</li><li class="listitem" style="list-style-type: disc">Core</li><li class="listitem" style="list-style-type: disc">Component</li></ul></div><p>At the same time, each main piece may consist of other smaller pieces which are packaged together to create the main piece.</p><p>Let's start by exploring each main piece of the application and looking at the specific functionality that each piece provides.</p><p>For our purposes in this book, from this point forward, when I talk about <a id="id293" class="indexterm"/>
<span class="strong"><strong>components</strong></span>, I'll be referring to modules that have user interface pieces (views) which the user is able to interact with, such as the header component. However, when I refer to <span class="strong"><strong>modules</strong></span> I will be<a id="id294" class="indexterm"/> referring to functional modules that each main piece may consist of, which do not have any views associated with them directly.</p><p>The definitions will become more clear as we move along but you may decide to refer to such pieces differently in your own projects. This is fine, as long as the architectural concepts behind them remain the same.</p><p>Also, from time to time, I will be <a id="id295" class="indexterm"/>referring to our modular design architecture as a <span class="strong"><strong>framework,</strong></span> which should be interpreted as all the various pieces of the application together as a whole.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>
<span class="strong"><strong>About the term framework</strong></span>
</p><p>While I will be using the term framework at times, our application is not meant to create what is generally known as a framework. At least not in the same capacity that the term is used to refer to<a id="id296" class="indexterm"/> frameworks in the likes of <span class="strong"><strong>AngularJS</strong></span> or <span class="strong"><strong>React</strong></span>.</p><p>Generally speaking, I think sometimes third-party frameworks are overused and while they all provide some pros, there are also cons associated with using any type of third party framework.</p><p>The purpose of this book is to show you how you can create your own architectural design which allows you to easily create, organize, and maintain your application's code base without the need for a third party framework.</p><p>As such, I would like you to<a id="id297" class="indexterm"/> look at our implementation as an architectural design concept as opposed to a framework. But if you insist, you can call what we design and create here an <span class="strong"><strong>ironic framework</strong></span>. I say ironic, because it is really not a framework in the traditional sense, as it does not impose a special syntax or a slew of rules and regulations!</p><p>The best way to describe our implementation is perhaps by using the term <span class="strong"><strong>Client-side Modular Design</strong></span> (<span class="strong"><strong>CMD</strong></span>), since the goal of this architectural approach is to create<a id="id298" class="indexterm"/> a solid foundation and a flexible ecosystem for our applications, as opposed to it being a framework.</p></div></div></div></div>
<div class="section" title="Base module"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Base module</h1></div></div></div><p>We will start our exploration<a id="id299" class="indexterm"/> of the design with the base module. As the name implies, the base module provides the lowest level of functionality for our application.</p><p>This is where we import and leverage the functionality of third party libraries and utilities. These libraries can<a id="id300" class="indexterm"/> consist of jQuery, Dojo, MooTools, and so on.</p><p>The main idea is that we can easily use the functionality provided by such libraries without the need to create a tight dependency between our application and the libraries used.</p><p>For instance, consider how we need to detect browser compatibility to attach events to our elements on the page, as follows:</p><div class="informalexample"><pre class="programlisting">if (elem.addEventListener) {
    elem.addEventListener(event, callbackFunc);
} else if (elem.attachEvent) { // For IE 8 and earlier versions
    elem.attachEvent("on" + event, callbackFunc);
}</pre></div><p>Whereras we could easily let jQuery take care of such intricacies by doing the following:</p><div class="informalexample"><pre class="programlisting">$(elem).on(event,callbackFunc);</pre></div><p>Here, we are letting jQuery take care of the browser compatibility issues and we can focus on other, more important things in our application. Another example is adding animations to our <a id="id301" class="indexterm"/>elements only when jQuery is present. This approach allows us to implement <span class="strong"><strong>progressive enhancement</strong></span> and <span class="strong"><strong>graceful degradation</strong></span> techniques in<a id="id302" class="indexterm"/> our code.</p><p>We can also have both of such implementations in our code. This allows us to have a fallback if jQuery has not been loaded properly.</p><p>Therefore, the preceding code can be written as follows:</p><div class="informalexample"><pre class="programlisting">if($) {
    $(elem).on(event,callbackFunc);

} else {
    if (elem.addEventListener) {
        elem.addEventListener(event, callbackFunc);
    } else  if (elem.attachEvent) {    // For IE 8 and earlier versions
        elem.attachEvent("on" + event, callbackFunc);
    }
}   </pre></div><p>Most of the time, it is <a id="id303" class="indexterm"/>best to leave low-level functionality such as browser compatibility issues to third party libraries and focus on providing customized functionality for our application in our own code.</p><p>Keep in mind that we are talking about third party libraries and utility packages here and not third party frameworks, as one of the goals of our architecture is to eliminate, or at least minimize, the need for third party frameworks.</p><div class="section" title="Adding general-purpose libraries to the base module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>Adding general-purpose libraries to the base module</h2></div></div></div><p>As mentioned, our base<a id="id304" class="indexterm"/> module loads and provides general-purpose libraries to the core module of our application. This means that only the core is aware of what base libraries are used in the code, as well as which particular functionality of such libraries is being leveraged.</p><p>Depending on the design of our base module, the libraries are either loaded at  application start-up time or dynamically at a later time. The base module passes a reference for each loaded and initialized library to the core module.</p><p>Since it is only the core module that is aware of what libraries are used in the application and to what extend, if we ever decide to change our third party libraries or how they are used in the application, it is only the core module that is affected and no other pieces.</p><p>This means that all the other pieces and components of our application will continue to work as they did before, regardless of the change in the third party libraries. Implementing our application as such minimizes the impact of replacing or removing the third party libraries on the application as a whole.</p><p>This also holds true when we import and use new libraries in order to add more functionality to our application.</p><p>In the next chapter, we will have a closer look at how the base module is used to add jQuery to our application's core module.</p><p>The following is a <a id="id305" class="indexterm"/>depiction of how third party libraries are provided to the core module by our application's base module:</p><div class="mediaobject"><img src="graphics/B04910_07_02.jpg" alt="Adding general-purpose libraries to the base module"/></div></div></div>
<div class="section" title="Sandbox module"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Sandbox module</h1></div></div></div><p>When we talk about <a id="id306" class="indexterm"/>a sandbox in our daily lives, we usually have a picture of a box full of sand in our minds, where <a id="id307" class="indexterm"/>we allow the kids to play and make all the mess they like - and hopefully only in that box.</p><p>In our modular architecture, we capitalize on the same concept and create spaces for our components to play in and to be isolated from other pieces of the application.</p><p>By sandboxing our modules in such a way, we eliminate tight coupling among our application components and the core module.</p><p>The sandbox is essentially a layer of abstraction as well as a thin interface between our components and the other pieces of our application.</p><p>As the sandbox<a id="id308" class="indexterm"/> module is designed to be an interface and to provide communication among our components and the rest of the application, it is considered a contract and, as such, it should never change. This is so our components can be sure that they can always count on a consistent layer of communication with the application as well as a certain level of functionality provided by the core module.</p><p>That is not to say,<a id="id309" class="indexterm"/> we cannot add new methods or functionality to the sandbox; it is only that we cannot change what is already there and that our components have come to rely on.</p><div class="section" title="Sandbox module functionality"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>Sandbox module functionality</h2></div></div></div><p>When our components<a id="id310" class="indexterm"/> are loaded in the application, either at application start-up time or dynamically any time after, they are all given an instance of the sandbox<a id="id311" class="indexterm"/> module.</p><p>The sandbox module<a id="id312" class="indexterm"/> provides the following for our components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A consistent interface</li><li class="listitem" style="list-style-type: disc">Security</li><li class="listitem" style="list-style-type: disc">Communication</li><li class="listitem" style="list-style-type: disc">Filtering</li></ul></div><p>Each one of the services provided by the sandbox module is crucial to the modular aspect of our implementation.</p><p>Let's explore each aspect in more detail.</p><div class="section" title="Sandbox as a consistent interface"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec22"/>Sandbox as a consistent interface</h3></div></div></div><p>As mentioned, when <a id="id313" class="indexterm"/>every registered component is given an instance of the sandbox module by the core module.</p><p>This instance of the sandbox then acts as an interface to the rest of the application, which provides application-level functionality for the component.</p><p>When a component needs a particular functionality, it does not necessarily need to implement it itself. This is true when the implementation of that functionality is already available in the application.</p><p>For instance, to bind event handlers to elements, each component does not need to provide its <a id="id314" class="indexterm"/>own implementation. Components can simply ask the sandbox module, which in turn, asks the core module to bind a certain event handler to a particular element on the page.</p><p>Of course, the components also do not have to worry about browser compatibility issues related to event binding, as it is the job of the core module to take care of such issues.</p><p>Since the sandbox instance is identical for every registered component, we can be sure that any changes in the sandbox code is provided to all the components at the same time. This means that the addition of new functionality, bug fixes, and modifications in the sandbox module are done once and then propagated to all the components that use the sandbox module, in a uniform and cohesive manner.</p><p>Note that any changes to the sandbox module should still honor the previous contract between this module and the application's components.</p></div><div class="section" title="Sandbox as a security layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec23"/>Sandbox as a security layer</h3></div></div></div><p>The components in our application only know about the sandbox module and are not allowed (or able) to directly communicate with any other pieces of the application.</p><p>This means that the <a id="id315" class="indexterm"/>sandbox makes sure that protected areas of the framework are not accessible by the components through its interface. This enables us to control the type of operations that the components are permitted to perform, within the context of the core and other modules of the application.</p></div><div class="section" title="Sandbox as a communication layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec24"/>Sandbox as a communication layer</h3></div></div></div><p>As the sandbox<a id="id316" class="indexterm"/> module is a thin layer of interface which provides the exposed interface of the core module to the components, it is the only route of communication between the components and the rest of the application.</p><p>It is also through the sandbox module that components can subscribe to and publish custom events in the application.</p><p>Note that it is important for the components to only have one route of communication with the rest of the application so we can preserve the integrity of our modular design. If a component is able to directly communicate with another component or other parts of the application, then it could be tightly coupled to such pieces, and we certainly would like to avoid this type of tight coupling.</p></div><div class="section" title="Sandbox as a filter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec25"/>Sandbox as a filter</h3></div></div></div><p>The design of the sandbox should be done in a way that not only will it provide the functionality of the <a id="id317" class="indexterm"/>core module that we want to expose to the components, but it can also do simple error checking for the calls made by the components to the core.</p><p>For instance, consider the following:</p><div class="informalexample"><pre class="programlisting">getElement : function(elementID){
            
    if(elementID &amp;&amp; typeof elementID === "string"){
        return core.getElement(elementID);
    }else{
        core.log(3,"incorrect parameters passed in; from SandBox.getElement");
    }
}</pre></div><p>The preceding method has been provided to our components through the sandbox module. This method does a simple parameter check to make sure that the parameter, as well as the correct type of the parameter, has been passed to it by the component before the sandbox module asks the core to do the work.</p><p>While the core module might have its own error checking, it is always a good idea to do some error checking at the sandbox level before getting the core module involved.</p></div></div><div class="section" title="Implementing multiple instances of the sandbox module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>Implementing multiple instances of the sandbox module</h2></div></div></div><p>You may be<a id="id318" class="indexterm"/> wondering at this point, why is it a better idea to<a id="id319" class="indexterm"/> use multiple instances of the sandbox module (one for each component) as opposed to having all the components use the same sandbox object as a singleton?</p><p>The short answer is: better isolation and performance. We need to explore that answer a little further in the upcoming sections.</p><div class="section" title="Advantages of multiple instances of the sandbox"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Advantages of multiple instances of the sandbox</h3></div></div></div><p>Usually, a module <a id="id320" class="indexterm"/>provides its exposed functionality to the outside world through a single common interface.</p><p>However, our implementation <a id="id321" class="indexterm"/>of the sandbox module is different. As mentioned previously, we create multiple instances of the sandbox module and, to be more precise, one instance per component.</p><p>The following summarizes the goals behind this design:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Isolating sandbox instances from each other</li><li class="listitem" style="list-style-type: disc">Creating a code <a id="id322" class="indexterm"/>execution context for each component</li><li class="listitem" style="list-style-type: disc">Performance improvements</li></ul></div><div class="section" title="Isolating the sandbox instances from each other"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec09"/>Isolating the sandbox instances from each other</h4></div></div></div><p>In our analogy of a kid <a id="id323" class="indexterm"/>playing in a sandbox, I mentioned that this type of isolation contains the possible mess created in the box. In just the same way, we would like any possible damage to a sandbox module instance to be contained and isolated.</p><p>This would mean that, if one of our components does something undesirable which could cause issues in its sandbox instance, such a mess would be contained within that sandbox module instance. The adverse effects will only impact the functionality of that component but no other sandbox instances, or any other components for that matter.</p><p>It is very important for us to design our architecture in such a way which minimizes the chances of complete application failure caused by an issue in one of the components.</p><p>This allows for at least partial functionality of our application, which is probably a much more acceptable outcome than a complete application failure.</p><p>For instance, the footer component in our application may stop working but the user can still view the catalog of our images and add them to the favorites list.</p></div><div class="section" title="Creating a code execution context"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec10"/>Creating a code execution context</h4></div></div></div><p>When a sandbox <a id="id324" class="indexterm"/>module is created, it sets a context object for its component. Components can use this context object to easily refer to the correct execution context when needed. This is probably better understood if we look at an example.</p><p>Consider the following code snippet from our application:</p><div class="informalexample"><pre class="programlisting">handleMainContainerClicked: function (e) {

    if (e.target != e.currentTarget) {

        e.preventDefault();
        e.stopPropagation();

        if (e.target.tagName.toUpperCase() === 'IMG') {
            sandBox.contextObj.handleImageClick(e.target);

        } else if (e.target.tagName.toUpperCase() === 'A') {
            sandBox.contextObj.handelFavLinkClick(e.target);
        }

    }
}</pre></div><p>The function above is<a id="id325" class="indexterm"/> implemented in the content component of our application. Inside this function, which is the click event handler for some of the elements on the page, we need to call other related functions in the content component.</p><p>We can easily do that by using the execution context that we set on the sandbox instance for this component when we first initialize the component.</p><p>This is done as follows:</p><div class="informalexample"><pre class="programlisting">sandBox.contextObj = this;</pre></div><p>In the code snippet, <code class="literal">this</code> refers to the content component of our application. Thus, when we need to execute any functions in the context of our content component, we can just refer to the correct context, as follows:</p><div class="informalexample"><pre class="programlisting">sandBox.contextObj.handelFavLinkClick(e.target);</pre></div><p>If this does not make a lot of sense to you right now, do not be alarmed. I will explain this further in the next chapter where we'll have a chance to look at it's full implementation in the code.</p><p>For now, the only thing that you need to keep in mind is that we can use each instance of the sandbox module to preserve a reference to the component that the sandbox instance belongs to. This allows us to easily access the execution context of that component.</p></div><div class="section" title="Performance improvements"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec11"/>Performance improvements</h4></div></div></div><p>When we create an<a id="id326" class="indexterm"/> instance of the sandbox for each component, we also assign a reference on the sandbox instance to the DOM element in which the component's view resides. This allows us to make our DOM manipulation within that container a lot more efficiently, since we do not need to traverse the whole DOM tree to find the DOM element of interest within the container of the component's view.</p><p>Have a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">getElementInContext : function(elementID){
        
    if(elementID &amp;&amp; typeof elementID === "string"){
        return core.getChildOfParentByID(containerElemContext,elementID);

    }else{

        core.log(3,"incorrect parameters passed in; from SandBox.getElementInContext");
    }  

}</pre></div><p>In this snippet, we are trying to find a child element of the container element where the component's view has been rendered.</p><p>When the component <a id="id327" class="indexterm"/>was registered with the core, the core created an instance of the sandbox and returned a reference to the component's container element with the sandbox instance.</p><p>For instance, after the header component of our application is created, all the header-related DOM elements reside inside a main div element container that hosts them. The header component's sandbox instance holds a reference to this div container.</p><p>When the header component needs access to any DOM elements related to its view, it will only need to look for the desired element inside of its container div element as opposed to traversing the whole DOM tree to find the element.</p><p>This makes finding the desired element much quicker as we don't need to search the entire DOM looking for it.</p><p>If you are not completely clear on how this works, we will cover it again in the next chapter when we examine the code in more depth.</p><p>For now, just be mindful of the fact that the sandbox instance allows us to have quick and direct access to the DOM element that the component renders in, which in turn allows for much more optimized DOM manipulation tasks related to the component.</p></div></div></div></div>
<div class="section" title="Core module"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Core module</h1></div></div></div><p>The core module is<a id="id328" class="indexterm"/> really the brain of our application. It is <a id="id329" class="indexterm"/>where the application's heavy lifting is done and the real magic happens.</p><p>The core module is responsible for implementing application-level business logic as well as providing bridges among components when there is a need for components to communicate with each other. Of course, while still preserving the loose coupling nature of the application.</p><p>The core module also<a id="id330" class="indexterm"/> leverages the functionality provided by the third party libraries, which are loaded by the base module, to create a cohesive functional application.</p><p>If you are familiar with the<a id="id331" class="indexterm"/> architectural design pattern known as <span class="strong"><strong>Module-View-Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>), the core module is the controller piece of this design pattern in our application.</p><p>We can summarize the role of<a id="id332" class="indexterm"/> core module as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Acting as the controller for the application</li><li class="listitem" style="list-style-type: disc">Providing communication bridges among modularized components</li><li class="listitem" style="list-style-type: disc">Initializing and destroying components</li><li class="listitem" style="list-style-type: disc">Implementing plug-and-play capability for the components</li><li class="listitem" style="list-style-type: disc">Providing a centralized method of handling errors</li><li class="listitem" style="list-style-type: disc">Providing application-level extensibility</li><li class="listitem" style="list-style-type: disc">Leveraging third party libraries' functionality</li></ul></div><p>We will examine all these aspects very shortly but before doing so, let's talk about how the core is constructed in our application.</p><div class="section" title="Core module construction approach"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>Core module construction approach</h2></div></div></div><p>There are different approaches to building the core module, but one of the best approaches is to build it in a modularized fashion.</p><p>We can start the implementation by building a main core module and then augment it using techniques such as loose <a id="id333" class="indexterm"/>and tight augmentation, which we have already covered in this book. However, adding most of the functionality to the core module using sub-modules allows for a better separation of the logic in the code.</p><p>In the implementation of our main application for this book, we will be using all the above techniques to build our core module. </p><p>The next chapter will examine the implementation of the core in depth, but for now, we'll look at a couple of things related to its implementation.</p><p>Consider the following:</p><div class="informalexample"><pre class="programlisting">var ImagesInc_Core = (function(Core){
    
    var $ = Core.jQuery;
    var insertHTMLTxt = function(containerID,newStructure){
        var containerElem;
        if(typeof containerID === 'string'){
        
            containerElem = Core.getElement(containerID);
        }else if(typeof containerID === 'object'){
            
            containerElem = containerID;        
        }    
        Core.setInnerHTML(containerElem,newStructure);
    };
...

return Core;
    
})(ImagesInc_Core); // using tight augmentation</pre></div><p>In the preceding code, we<a id="id334" class="indexterm"/> are using tight augmentation to add DOM-related functionality to the core module. We can also add functionality to the core by attaching a sub-module to it, as shown here:</p><div class="informalexample"><pre class="programlisting">// using simple sub-module augmentation
ImagesInc_Core.LoggingHandler = (function(){

    var self = {}, messageParam, colorParam;
    
    self.logMessage = function(severity, message,color) {    
        // if no severity number was possed in, then give the message and warn the user
        if(typeof severity === 'string'){
            message = severity;
            severity = 2;
        }

...

return {
        logMessage: self.logMessage,
        initialize: self.initialize
    };
    
})();</pre></div><p>As you can see, we are augmenting the core module by attaching a self-contained sub-module, which is added as a new property to the core module object.</p><p>Augmenting the core module using sub-modules, is similar to building a play house using Lego blocks as separate pieces are attached together to create the whole structure.</p><p>This would mean that not only the application main pieces (such as components and sandbox) are built as modules, but also the core module itself is built based on smaller modules.</p><p>This allows us to easily extend our core module while providing us with the ability to remove or replace each sub-module without affecting the other pieces of the core module.</p><p>We will examine this modular implementation of the core module quite a bit further, when we'll have a look under the hood in the next chapter. Have a look at the following image to see all the pieces of the core module in our final application. This image depicts how the core module consists of separate self-contained sub-modules:</p><div class="mediaobject"><img src="graphics/B04910_07_03.jpg" alt="Core module construction approach"/></div><p>Of course, at the time of deployment, we can combine and minify all of these files (sub-modules) into one file but during development, this separation of sub-modules provides a good visual representation of all the pieces of the core module.</p><p>Now that we have had a good overview of how the core module is built, let's examine the functionality that this module provides for us.</p><div class="section" title="Core module functionality"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec27"/>Core module functionality</h3></div></div></div><p>Core module plays different vital roles in our application, and provides essential services for all the other modules. It is important to note that while the core module consists of many pieces itself, it acts as a uniform and cohesive  piece while providing the following functionality for the application.</p></div></div><div class="section" title="Acting as the controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Acting as the controller</h2></div></div></div><p>The core module provides application-level functionality for all the components in the application. For instance, event binding and unbinding happen in the core module and the components only need to ask the core to take care of this task for them.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">if(elem.addEventListener) {
    elem.addEventListener(event, callbackFunc);
    } else if(elem.attachEvent) {                  
        // For IE 8 and earlier versions
            elem.attachEvent("on" + event, callbackFunc);
    }
}</pre></div><p>This code is implemented in the core module and all the components in the application call this method (through their instance of the sandbox module) to bind an event handler to an element.</p><p>Another example can be when a component<a id="id335" class="indexterm"/> would need to make an <span class="strong"><strong>AJAX</strong></span> call to the server. It is the core module that would make the call instead to the server and would return the result to the component and/or would take an action based on the result returned, such as logging an error when the AJAX call fails.</p><p>We can also mention <a id="id336" class="indexterm"/>
<span class="strong"><strong>cookie</strong></span> and <span class="strong"><strong>local storage</strong></span>-related functionality in the application as some of the<a id="id337" class="indexterm"/> other application-level functionality the core provides to all the registered components.</p><p>Keep in mind that the implementation should be designed in a way that component-specific functionality that only the component cares about should happen at the component level and that the application-level functionality should take place at the core module.</p><p>Each component, in a sense, implements its own MVC or MV* design at the component level, which is separate from the application-level implementation. This point will become more clear to you when we look at implementation code in the next chapter.</p></div><div class="section" title="Providing communication bridges"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Providing communication bridges</h2></div></div></div><p>As you may recall, one of the main goals of our modular architecture was to provide loose coupling among our<a id="id338" class="indexterm"/> components. This means that none of the components in our application knows about any other component, nor are they dependent on any other component.</p><p>However, there are times when components need to communicate with each other, or an event or action in one component should cause a change in another component, while the components have no knowledge of each other.</p><p>To provide such functionality the core implements a variation to the observer pattern called the <span class="strong"><strong>mediator pattern</strong></span>.</p><p>Using the mediator pattern, our application's components can register for and publish events. However, this is done through an abstraction layer.</p><p>The following is a depiction of how the mediator pattern is implemented:</p><div class="mediaobject"><img src="graphics/B04910_07_08.jpg" alt="Providing communication bridges"/></div><p>The core module in our application acts as the mediator, which enables the components (modules) for subscribe to and publish events without knowing about each other, thus still adhering to the principle of loose coupling among our components and modules.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">sandBox.publishCustomEvent({
      type: 'support-Clicked',
      data: "support"
});</pre></div><p>Here, the footer component in our application is publishing a custom event, <code class="literal">support-Clicked,</code> through its<a id="id339" class="indexterm"/> instance of the sandbox module. Beyond that, it has no idea what other pieces of the application could be listening for this event and what actions they would take based on this event.</p><p>On the other hand, the following snippet shows that our <code class="literal">NotificationHandler</code> module is listening to this event and will take action when this event is published, as follows:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.registerForCustomEvents("Notification",{
        'support-Clicked':this.handleSupportClick
}</pre></div><p>The core module is responsible for notifying all the registered components and modules that a certain event has taken place if they have registered for that particular event.</p></div><div class="section" title="Initializing and destroying components"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Initializing and destroying components</h2></div></div></div><p>In our architectural design, we can load and unload components (modules) both at the start-up phase of the <a id="id340" class="indexterm"/>application as well as any time after.</p><p>This is pretty robust, since it allows us to load what we need when we need it, which helps to keep the consumption of the resources on the device to a minimum, as well as keeping the application very light and responsive. This could be particularly important for mobile devices.</p><p>When a component is loaded (either at application start-up or any other time), it first registers itself with the core module and then the core module calls the <code class="literal">init</code> method of the component when it needs to be initialized.</p><p>Consider the following code snippet and see how this is done:</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.registerComponent("footerContainer", "footer", function(sandBox){

    return {
        
        init: function(){
            try{
                sandBox.updateElement("footerContainer", ImagesInc_GlobalData.getFooterHTMLTxt());
                this.registerForEvents();
                sandBox.contextObj = this;
                sandBox.logMessage(1,'Footer component has been initialized...', 'blue');
            
            }catch(e){
                sandBox.logMessage(3,'Footer component has NOT been initialized correctly --&gt; ' + e.message);
            }
 }, </pre></div><p>As you can see in the<a id="id341" class="indexterm"/> preceding code, each component upon loading calls the <code class="literal">registerComponent</code> method of the core module. Note that the core module is known as <code class="literal">ImagesInc_Core</code> to other application pieces.</p><p>The component sends the ID of its container (<code class="literal">footerContainer</code> for instance) as well as its own ID (shown as <code class="literal">footer</code> in the preceding code) as parameters to the <code class="literal">registerComponent</code> method of the core module.</p><p>It also sends a reference to the function that the core module needs to call to create an instance of the component. This <a id="id342" class="indexterm"/>function is then called by the core module with an instance of the sandbox module, which is an interface for the component to use for interacting with the application from this point forward.</p><p>Here is how registration of the component is done in the core module:</p><div class="informalexample"><pre class="programlisting">mainCore.registerComponent = function(containerID, componentID, createFunc){
...
if(createFunc &amp;&amp; typeof createFunc === 'function'){
    <span class="strong"><strong>componentObj = createFunc(new</strong></span> <span class="strong"><strong>SandBox(this,containerElem, componentID));</strong></span>
    if (componentObj.init &amp;&amp; typeof componentObj.init === 'function' &amp;&amp; componentObj.destroy &amp;&amp; typeof componentObj.destroy === 'function') {

        componentObj.id = componentID;
        registeredComponents.push(componentObj); 
    }
...
};</pre></div><p>As you can see, the core module first checks to see if the component has the required methods, <code class="literal">init</code> and <code class="literal">destroy</code>, and if so, the creator function (<code class="literal">createFunc</code>) on the component is called to create an instance of the component.</p><p>You can think of this phase as the hand-shake phase between the component and the core module specifically, as well as the hand-shake of the component with the application as a whole.</p><p>As mentioned, the <a id="id343" class="indexterm"/>component is also required to have a destroy method, which <a id="id344" class="indexterm"/>allows the core module to either disable the component for event handling and/or to completely remove the component from the application.</p><p>At the start-up phase of application, the core module goes through all the registered components and calls the <code class="literal">init</code> method on all of them, as shown:</p><div class="informalexample"><pre class="programlisting">for(var i=0; i &lt; registeredComponents.length; i++){
          
  registeredComponents[i].init();
}</pre></div><p>We use a similar approach to destroy (remove) all the registered components from the application, as shown:</p><div class="informalexample"><pre class="programlisting">for(var i=lastIndex; i &gt;= 0 ; i--){
          
     registeredComponents[i].destroy(removeFromDom);
}</pre></div><p>We will look at the details of these operations in the next chapter and will examine the code more closely then. The takeaway here is that the core module handles the initialization and destruction of all the components in the application, either as a collection or on individual basis.</p></div><div class="section" title="Providing plug-and-play capability"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec52"/>Providing plug-and-play capability</h2></div></div></div><p>As we mentioned <a id="id345" class="indexterm"/>previously, components can be loaded and added to the application at any time while the application is loaded in the browser.</p><p>Let's have a look at how a component is loaded dynamically and how it becomes part of the application.</p><p>Dynamic loading of the components is done by leveraging a mechanism which first checks to see if the component is already loaded in the cache, and if not, finding its object definition in either the local storage or in the <code class="literal">PageDefinitions.js</code> file and then subsequently loading it.</p><p>The <code class="literal">PageDefinitions.js</code> is the file that holds object definitions (as JavaScript objects) for all the components that can be loaded dynamically in the application, at any time other than the start-up phase.</p><p>We can also keep<a id="id346" class="indexterm"/> resource (asset) information related to any component in this file if we desire to do so. Generally speaking, this file is mostly used to find the location of our dynamic assets.</p><p>For instance, in our application, we will be keeping information related to the <code class="literal">Favorites</code> page and the location of its <code class="literal">CSS</code> file in <code class="literal">PageDefinitions.js</code>. This information will be consumed by the content component when the user navigates to this page.</p><p>Have a look at the following diagram to see an overview of the dynamic component-loading mechanism in our application:</p><div class="mediaobject"><img src="graphics/B04910_07_04.jpg" alt="Providing plug-and-play capability"/></div><p>As the flow diagram <a id="id347" class="indexterm"/>shows, when there is a need for a component to be rendered dynamically in the application, the core module checks to see if the component object is already present in the cache.</p><p>If the component object is already present in the cache, then there is no need to do anything else but to render its view.</p><p>On the other hand, if the component object is not present, the core module looks for the component's object definition in the local storage first. This object definition has a property that holds the location (path) of the component's JavaScript file on the server.</p><p>Note that we are using the<a id="id348" class="indexterm"/> local storage as the primary storage facility for such object definitions as opposed to keeping them in the cache. This is purely to keep the footprint of the application as small as possible in the browser. Usage of the local storage is especially important if we have quite a few object definitions for the components, since such, definitions could get quite large and consume a considerable amount of memory.</p><p>Admittedly, in our application there is no real need to use local storage, since we have only one dynamically loading component. But I'm using the local storage to show you how it can be leveraged if you decide to use this mechanism in your future applications.</p><p>The important point is that when the core finds the location of the component's file, it will make a request to the server for the <code class="literal">.js</code> (and possibly <code class="literal">.css</code>) file(s) of the component.</p><p>Once the required <code class="literal">.js</code> file for the component is loaded and parsed, then the component registers itself with the core and, as with any other component in the application, it is given an instance of the sandbox module.</p><p>As you can imagine, this approach provides us with a very robust way to dynamically load and activate our application's components, which essentially encompasses the plug-and-play capabilities of the application.</p><p>The mechanism is a bit more involved than what is explained here, but this brief description should provide a good overview of how things work behind the scenes. In the next chapter, we will have a closer look at the implementation of this mechanism and I'm sure all the details will become more clear to you in that chapter.</p></div><div class="section" title="Providing a centralized approach to handling errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec53"/>Providing a centralized approach to handling errors</h2></div></div></div><p>The core module implements a <a id="id349" class="indexterm"/>centralized approach to logging all types of messages. This frees the application modules and components from implementing such functionality themselves. It also provides enhanced capabilities for the logging mechanism that all components can leverage in a uniform way.</p><p>Note that any future enhancements that we may make to our logging mechanism will be done in one place and will be available to all the modules at the same time.</p><p>For instance, imagine that we would like all the error messages in the application to be logged on the server. This could mean that for each error, an AJAX call needs to be made from the client to the server with the related information.</p><p>If each module wanted to do that task itself, we would have to implement such functionality for each module separately. Of course, it makes more sense to implement this functionality once and then provide it to all of the application modules in a cohesive manner.</p><p>Have a look at <a id="id350" class="indexterm"/>the following screenshot, which displays our application messages being logged in the Chrome debugger tool when the application is in the debug mode:</p><div class="mediaobject"><img src="graphics/B04910_07_05.jpg" alt="Providing a centralized approach to handling errors"/></div><p>As you can see, when the application is loaded, all the modules as well as all the components in the application are initialized and the related messages are displayed.</p><p>All that the components need to do is call the sandbox module with the message, and the sandbox module in turn will send the message to the core module. In the case of other core modules, they can directly use the core module's logging mechanism.</p><p>Here is a code snippet which shows how the footer component logs its initialization message using the core module's logging mechanism:</p><div class="informalexample"><pre class="programlisting">sandBox.logMessage(1,'Footer component has been initialized...', 'blue');</pre></div><p>To log an error message, the footer component only needs to do the following:</p><div class="informalexample"><pre class="programlisting">sandBox.logMessage(3,'Footer component has NOT been initialized correctly --&gt; ' + e.message);</pre></div><p>This is a much simpler and better approach than the footer component implementing its own error-handling mechanism.</p><p>If we decide to send all the error messages to the server, the module, will still make the same call to the sandbox module and in turn to the core module. It will be the core module that will be responsible for sending the error message to the server.</p><p>The following <a id="id351" class="indexterm"/>code snippet shows how one of the core sub-modules sends its initialization message to the core module. This is similar to how the components log their message but with one difference.</p><div class="informalexample"><pre class="programlisting">ImagesInc_Core.log(1,"Utilities Module has been initialized...", "blue");</pre></div><p>The difference is that the sub-module directly sends its message to the core module and not through a sandbox module instance. This is, of course, because the sub-module is part of the core module and does not have an instance of the sandbox module.</p><p>Also, the sandbox module itself uses the same logging facility provided by the core module to log its errors, as shown:</p><div class="informalexample"><pre class="programlisting">Core.log(3,"incorrect parameters passed in; from SandBox.getElement ");</pre></div><p>The following image shows how the error message is displayed in the debugger:</p><div class="mediaobject"><img src="graphics/B04910_07_06.jpg" alt="Providing a centralized approach to handling errors"/></div><p>We will have a more in-depth look at how the logging mechanism has been implemented in our application, and how it is designed to be a sub-module of the core module, in the next chapter.</p></div><div class="section" title="Providing application-level extensibility"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Providing application-level extensibility</h2></div></div></div><p>From the beginning, we <a id="id352" class="indexterm"/>designed our application based on modular architecture. One of the advantages that our modular architecture provides is the ability to easily extend our application's functionality and capabilities when needed.</p><p>As you saw, the functionality of our application was enhanced using various techniques, such as loose augmentation, tight augmentation, and sub-modules.</p><p>While our application might provide quite a bit of functionality, it is a reasonable to assume that more features and capabilities will be needed in the future.</p><p>For instance, imagine that one or more of our future components need to do form field validation. This functionality can be easily added to our application by extending the core module and then providing the functionality to our components.</p><p>The core module can provide form field validation by either importing a validation library through the base module or by implementing the functionality itself. This new functionality will then be provided to all the registered components through the sandbox module and all the components can use it as needed.</p><p>In fact, our components would not even know who has provided this new functionality and how it works <a id="id353" class="indexterm"/>behind the scenes. All they need to know is that the functionality is available to them and they can use it to accomplish their validation tasks.</p><p>Being able to provide application-level extensibility is one of the key features of our modular design and one of the most important tasks that the core module is responsible for.</p></div><div class="section" title="Leveraging third party libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Leveraging third party libraries</h2></div></div></div><p>We briefly talked about this responsibility of the core module before. As mentioned, the core module is designed to ask for third party libraries from the base module. These libraries are used by the core module to provide application-level functionality for other pieces of the application.</p><p>The import of such libraries<a id="id354" class="indexterm"/> usually happens at the application start-up time, but it does not have to.</p><p>As you saw previously in this chapter, our application does have the capability to load files dynamically from the server. It is quite possible that while the application is running, based on certain application needs or certain user interactions with the application, we need to load a third party library dynamically.</p><p>Most of the time, we would use the dynamic loading of a third party library when the library is not needed for most of the functionality of our application. This allows us to keep the foot print of our application small, which is an important consideration on mobile devices.</p><p>In the application for this book, we do not use such dynamic loading of third party libraries. However, if at any point in the future you decide to leverage this capability, all the hooks are available for it in the code.</p><p>Let's have a look at how the core module uses the base module to import the jQuery library into our application.</p><p>Consider the following:</p><div class="informalexample"><pre class="programlisting">(function Core_initialize(){
        
        mainCore.debug = true;
        
        try{
            // get jQuery from the base module loader
            mainCore.jQuery = $ = ImagesInc_Base.getBaseModule();
            
        }catch(e){
            
            if(mainCore.debug){
                console.error('Base Module has not been defined!!!' );    
            };
        };
        
        if(mainCore.debug){
            console.log("%c Core Module has been initialized...", "color:blue");
        };
        
})();</pre></div><p>In the preceding code <a id="id355" class="indexterm"/>snippet, during the start-up phase of the application, our core module (<code class="literal">MainCore</code> module of the core module) asks the base module for jQuery. </p><p>This is done as shown here:</p><div class="informalexample"><pre class="programlisting">mainCore.jQuery = $ = ImagesInc_Base.getBaseModule();</pre></div><p>Notice that we have wrapped this call in a try/catch statement to capture any errors that could happen during this operation.</p><p>Let's also have a look at how the base module provides a reference for jQuery to the core module.</p><div class="informalexample"><pre class="programlisting">if(typeof jQuery !== 'undefined'){
    return jQuery;
}else{
    return null;
}</pre></div><p>As you can see, since jQuery loads as a global object in the application, the base module simply returns a reference to this global object to the core module. From that point forward, jQuery is used by the core module as a sub-module to deliver application-level functionality.</p><p>The following code <a id="id356" class="indexterm"/>snippet shows an example of how jQuery is used in the application to provide the required functionality:</p><div class="informalexample"><pre class="programlisting">var ImagesInc_Core = (function(Core){
    var $ = Core.jQuery;
    Core.makeAjaxCall = function(url, theQuery, method, handler){
        
        if($ &amp;&amp; Core.jQueryAjaxEngine &amp;&amp; Core.jQueryAjaxEngine.makeAjaxCall){
            Core.jQueryAjaxEngine.makeAjaxCall(url, theQuery, method, handler);
        
        }else{        
            Core.log(3, "Cannot make Ajax call!; from makeAjaxCall")
        }
    };
…
})(ImagesInc_Core); // using tight augmentation</pre></div><p>Just in the same way, other third party libraries can be loaded into the application at the start-up phase to enhance our application's functionality.</p><p>Note that none of the other modules or components are aware of the third party libraries or how they are leveraged. It is only the core module that is aware of such libraries, and it is the only module to provide the third party library functionality to other application modules and components.</p><p>The following image shows how third party libraries can be placed in our application's folder structure:</p><div class="mediaobject"><img src="graphics/B04910_07_07.jpg" alt="Leveraging third party libraries"/></div></div></div>
<div class="section" title="Components"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Components</h1></div></div></div><p>The last main piece <a id="id357" class="indexterm"/>of our application design is related to components. In this section, we will cover how components are built and plugged into our application.</p><p>Remember that we <a id="id358" class="indexterm"/>considered components as pieces of the application that have views. By views, I am referring to the pieces that have HTML elements associated with them which are rendered in the browser and the users can interact with them directly.</p><p>Components can be as simple as a layover box. Such simple components can be rendered as part of another component or as a stand-alone component on their own.</p><p>Most of the time, our components are independent modules with their own MVC or MV* architecture, which are attached to the application and use the facilities and functionality that the rest of the application provides for them.</p><p>In our design, we have created three main components and a widget named <code class="literal">NotificationWidget</code>. This widget is also a component but it is loaded and viewed based on the user's interaction with another component. In our application, <code class="literal">NotificationWidget</code> is launched when the user clicks on the <span class="strong"><strong>Support</strong></span> link in the footer component. Since this widget can potentially be launched by other components too, I am tagging it as a widget but for all practical intents and purposes, it is also a component with its own MV* implementation.</p><p>Components can have very sophisticated business logic implemented in their controller, or have a very simple controller with very little functionality.</p><p>In our application, the content component is an example of a component with a fairly involved controller logic, and the footer stands as a component with a relatively simple controller.</p><p>Also remember that the only bridge or point of connection between a component and the rest of the application is via an instance of the sandbox which was passed to it when the component registered itself with the core.</p><p>We previously<a id="id359" class="indexterm"/> talked about how, in our architecture, components can be loaded either at the start-up phase of the application or dynamically at any time after that. In our implementation, header, footer, and the content components are loaded at the start-up phase and <code class="literal">NotificationWidget</code> is loaded dynamically, when required.</p><p>Let's have a look at one of our simpler components, the footer, and see how it is implemented.</p><div class="section" title="Components required methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec56"/>Components required methods</h2></div></div></div><p>In our design, there are two<a id="id360" class="indexterm"/> required methods that every component needs to implement in order to register and connect with the core module and the rest of the application.</p><p>These two required methods are called <code class="literal">init</code> and the <code class="literal">destroy</code> methods. The <code class="literal">init</code> method is called by the core module to start the initialization of the component. On the other hand, the <code class="literal">destroy</code> method is called by the core module to either disable or completely remove the component from the application.</p><p>Consider the implementation below:</p><div class="informalexample"><pre class="programlisting">init: function(){
            try{
                sandBox.updateElement("footerContainer", ImagesInc_GlobalData.getFooterHTMLTxt());
                this.registerForEvents();
                sandBox.contextObj = this;
                sandBox.logMessage(1,'Footer component has been initialized...', 'blue');
            
            }catch(e){
                sandBox.logMessage(3,'Footer component has NOT been initialized correctly --&gt; ' + e.message);
            }
}, 
        
        destroy: function(removeComponent){

            sandBox.contextObj.unregisterFromEvents();
            sandBox.unregisterAllCustomEvents();
            
            if(removeComponent){
                sandBox.removeComponent("footerContainer");
            }
            sandBox.logMessage(1,'Footer component has been destroyed...', "blue");
        }</pre></div><p>As you can see, in the <code class="literal">init</code> method of the footer component, the required HTML string for the view is fetched from the <code class="literal">GlobalData</code> object. This object is an application-level object (the application model) which holds application-level data. The HTML string is then passed to the core<a id="id361" class="indexterm"/> module via the sandbox module instance.</p><p>Note that the core module is responsible for rendering HTML elements, in this case the footer's view, on the page.</p><p>This is done in the following lines of code in the <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">sandBox.updateElement("footerContainer", ImagesInc_GlobalData.getFooterHTMLTxt());</pre></div><p>For this particular component, we call for the rendering of the view in this method. However, the rendering does not always have to be done in the <code class="literal">init</code> method of a component. For instance, for <code class="literal">NotificationWidget</code> component, the rendering is done in a different method which is called at some later time by the application. Consequently, the <code class="literal">init</code> method of <code class="literal">NotificationWidget</code> is kept very simple, as follows:</p><div class="informalexample"><pre class="programlisting">init: function(){
            try{                               
                sandBox.contextObj = this;
                sandBox.logMessage(1,'Notification Widget component has been initialized...', 'blue');
            
            }catch(e){
                sandBox.logMessage(3,'Notification Widget has NOT been initialized correctly --&gt; ' + e.message);
            }
 }</pre></div></div><div class="section" title="Binding events to the components elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec57"/>Binding events to the components elements</h2></div></div></div><p>In <code class="literal">init</code> method of<a id="id362" class="indexterm"/> the footer component, we also register the HTML elements related to its view for handling events. This is done by calling <code class="literal">registerForEvents</code> method of the component. In <code class="literal">registerForEvents</code> method, the related event handler is bound to the <code class="literal">support</code> link, as follows:</p><div class="informalexample"><pre class="programlisting">registerForEvents : function(){
            …...................
            sandBox.addEventHandlerToElement("support","click", this.handleSupportClick);    
        
}</pre></div><p>As you can see, the actual binding for the event is done in the core module.</p><p>I previously mentioned that our components are loosely coupled with the other pieces of the application by custom events using the mediator pattern. Let's have a quick look at that.</p><p>Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">handleSupportClick : function(e){
            
            sandBox.publishCustomEvent({
                type: 'support-Clicked',
                data: "support"
            });
            
            e.preventDefault();
            e.stopPropagation();
}</pre></div><p>As you can see, the footer component publishes a custom event when the <span class="strong"><strong>Support</strong></span> link is clicked. Then, all the other pieces of the application that have registered for this custom event will be notified by the core module that this event has occurred. We will talk about this mechanism more in the next chapter.</p></div><div class="section" title="Component design considerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Component design considerations</h2></div></div></div><p>In this chapter, we did not<a id="id363" class="indexterm"/> examine the implementation details of the components too closely, as we will have a more in-depth look at them in the next chapter. However, I would like you to consider a few conceptual aspects of the components.</p><p>First of all, all the components are loosely coupled with the application. The only connection between them and the rest of the application is through an instance of the Sandbox, which was passed to them during the registration phase.</p><p>Second, all the components are responsible for implementing their own controllers. The other application pieces do not get involved with the functionality, which is specific to an individual component.</p><p>The job of the application <a id="id364" class="indexterm"/>as a whole, and the core module in particular, is to create a robust ecosystem in which the components can leverage the application-level functionality that has been implemented. Therefore, the components do not need to implement such functionality themselves. This approach allows us to create a cohesive and loosely coupled application that can be easily maintained and extended as the need arises.</p><p>Note that each Component is a self-contained piece of the application and the core or any other pieces of the application are not aware of nor are dependent on the internal implementation of the Component. This means that components are free to decide on their own implementation.</p><p>In this manner, we can create a good level of separation of concerns and responsibilities throughout all the application pieces.</p><p>When a component needs to modify the DOM, it should do so by leveraging the functionality that the core module provides. Therefore the component does not have to implement this functionality itself. Also, by using the core module, we are able to prevent other pieces of the application from accidentally causing any conflicts at the same DOM element level, thus preventing collisions and application-level issues.</p><p>The proper approach in most cases is that components only modify the DOM elements (through the core module) in their own container and not beyond that.</p></div></div>
<div class="section" title="Application architectural considerations"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Application architectural considerations</h1></div></div></div><p>Let's review the important <a id="id365" class="indexterm"/>points that we have discussed about our modular architecture in this chapter and see how they relate to various pieces of our <a id="id366" class="indexterm"/>application, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All third party libraries are imported into the application through the base module</li><li class="listitem" style="list-style-type: disc">The core module and the base module are the only pieces of the application that know about the loaded third party libraries</li><li class="listitem" style="list-style-type: disc">All browser compatibility issues are dealt with in the core module by leveraging the functionality of the third party libraries</li><li class="listitem" style="list-style-type: disc">Every component in<a id="id367" class="indexterm"/> the application gets an instance of the sandbox module</li><li class="listitem" style="list-style-type: disc">The sandbox only knows about the core and no other pieces of the application</li><li class="listitem" style="list-style-type: disc">No pieces of the application know about the internal implementation of other pieces</li><li class="listitem" style="list-style-type: disc">Components can be added, modified, or removed from the application without affecting the application as a whole</li><li class="listitem" style="list-style-type: disc">Components can only call their own methods and the methods provided to them through their instance of the sandbox module</li><li class="listitem" style="list-style-type: disc">Components cannot access DOM elements outside of their own container</li><li class="listitem" style="list-style-type: disc">Components should not create global objects</li><li class="listitem" style="list-style-type: disc">Each module and component only does limited tasks and only things which are directly related to its own functionality</li><li class="listitem" style="list-style-type: disc">All the components in the application are loosely coupled with the rest of the application</li><li class="listitem" style="list-style-type: disc">Components can only communicate with other components and other pieces of the application using a publish-subscribe model (the mediator pattern) and their sandbox instance, thus preserving the loose coupling architecture</li><li class="listitem" style="list-style-type: disc">Each component has a very limited understanding of the application, and that is through the instance of the sandbox module which was assigned to it during the registration phase of the component with the application</li></ul></div><p>The following can be considered as the advantages that modular architecture provides for us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Once the modular architecture ecosystem has been developed, it can be used for many applications; therefore, we can code once and use many times</li><li class="listitem" style="list-style-type: disc">Each piece of the application can be tested separately</li><li class="listitem" style="list-style-type: disc">Each piece of the application can be implemented by different people in a modularized fashion</li><li class="listitem" style="list-style-type: disc">Third party external dependencies can be controlled and managed by the core module</li><li class="listitem" style="list-style-type: disc">Modules and components can be replaced, modified, or removed without affecting the application as a whole</li><li class="listitem" style="list-style-type: disc">Components and modules can be loaded dynamically and as needed after the application start-up phase</li></ul></div><p>I hope you view the points above as important takeaways from this chapter and will keep them in mind as we move forward to a more in-depth look at the application's implementation in the<a id="id368" class="indexterm"/> next chapter.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Summary</h1></div></div></div><p>As was noted in the beginning of this chapter, we had a good overview of the architectural concepts related to the modular implementation of our application.</p><p>We discussed the main pieces of the application and saw how they come together to create a cohesive ecosystem.</p><p>We also examined the specific roles that the pieces play in the overall application design and looked at how we can create a good separation of responsibilities and concerns among our modules and components.</p><p>One of the important aspects that we focused on was to loosely couple our various application pieces together, which allows for ease of maintainability as well as future extensibility.</p><p>While some application code was shown in the chapter, we did not get deeply involved in analyzing the code and the application implementation. This is exactly what we will cover in the next chapter, where we will have a closer look at how things are done under the hood.</p></div></body></html>