<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Highcharts and Ext JS</h1></div></div></div><p>This chapter starts with an introduction of Sencha's Ext JS. Since the Ext JS framework covers a broad range of features, it comprises a large collection of classes. Therefore, a quick guide on a small set will be given, especially for the user interface components likely to be used with Highcharts. Then, we will learn which Highcharts extension we have for Ext JS and how to create a Highcharts graph within Ext JS. We will also learn about a small set of APIs provided by the extension. After that, we will use network data to build a simple application to demonstrate how the Ext JS components can interact with Highcharts. Finally, we will have a brief look at a commercial Ext JS application working together with Highcharts. In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing and giving a quick tutorial on Sencha Ext JS classes</li><li class="listitem" style="list-style-type: disc">Introducing the Highcharts extension for Ext JS</li><li class="listitem" style="list-style-type: disc">Demonstrating how to convert a working Highcharts configuration for the extension</li><li class="listitem" style="list-style-type: disc">Preparing the Ext JS JsonStore object for the extension</li><li class="listitem" style="list-style-type: disc">Describing APIs provided by the extension module</li><li class="listitem" style="list-style-type: disc">Illustrating how to create an Ext JS application with the Highcharts extension</li></ul></div><div><div><div><div><h1 class="title"><a id="ch13lvl1sec84"/>A short introduction to Sencha Ext JS</h1></div></div></div><p>Sencha's Ext JS<a id="id897" class="indexterm"/> is one of the most comprehensive <strong>Rich Internet Application</strong> (<strong>RIA</strong>)<a id="id898" class="indexterm"/> frameworks on the market. An RIA framework can produce a web frontend that behaves like a desktop application. Ext JS supports many features such as proxy storage, charting, managing SVG, tabs, toolbars, a myriad of different form inputs, and many, many others. There are other popular RIA frameworks, such as the Java-based <strong>Google Web Toolkit</strong> (<strong>GWT</strong>)<a id="id899" class="indexterm"/> and Python-based Dojo. Both frameworks can be integrated with Highcharts via third-party contributed software.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>See <a class="ulink" href="http://www.highcharts.com/download">http://www.highcharts.com/download</a> under the section <em>Third Party Implementation</em> for the full<a id="id900" class="indexterm"/> list of software contributed by other developers.</p></div></div><p>The <a id="id901" class="indexterm"/>Highcharts extension was originally written by Daniel Kloosterman for Ext JS 2+ as an adapter, as it didn't support any charts. In Ext JS 3, it started adopting the YUI charting library as the charting solution. However, the charts lacked features and style, and the main drawback was that they required Flash to run. Since Ext JS 3.1, I have been maintaining the Highcharts extension and added features, such as support for donut charts and enhancements for some of the APIs.</p><p>Although Ext JS 4<a id="id902" class="indexterm"/> comes with its own chart library, some users still prefer Highcharts over Ext JS 4 charts for style and flexibility. Moreover, Ext JS 4 can run alongside version 3 codes, so it is desirable to enhance the extension to natively support Ext JS 4, which I have done. The extension implementation has always been to follow the original approach, which is to preserve the use of Highcharts configurations as much as possible.</p><p>At the time of writing, Ext JS 5<a id="id903" class="indexterm"/> has just been released and the changes from Ext JS 4 to Ext JS 5 are not as drastic as from Ext JS 3<a id="id904" class="indexterm"/> to Ext JS 4. The Highcharts extension has been updated to be fully compatible with both Ext JS 4 and 5. In this chapter, we will focus on working with Ext JS 5. All the examples are simply from the previous edition, which is based on Ext JS 4, and they are updated to work with Ext JS 5.</p><p>There are demos <a id="id905" class="indexterm"/>online at <a class="ulink" href="http://joekuan.org/demos/Highcharts_Sencha/desktop.extjs5/">http://joekuan.org/demos/Highcharts_Sencha/desktop.extjs5/</a> and the extension can be downloaded from <a class="ulink" href="http://github.com/JoeKuan/Highcharts_Sencha/">http://github.com/JoeKuan/Highcharts_Sencha/</a>.</p><p>Unlike jQuery UI, an Ext JS application is programmed in pure JavaScript, without the need to collaborate with HTML markup or fiddle with particular CSS classes (strictly speaking, there are times when it is necessary to interface with HTML and CSS, but it is not common and is only in small doses). This empowers programmers to focus on developing the entire web application in a single language and to concentrate on application logic. That also pushes the server-side development to reside in data operations only, unlike some approaches that use server-side language with HTML and CSS to serve client pages.</p><p>Technically, JavaScript does not have classes: function itself is an object. The Ext JS framework provides access to its components through the class approach, organized in a hierarchical manner. In this chapter, we will use the word "class" to refer to Ext JS classes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec85"/>A quick tour of Ext JS components</h1></div></div></div><p>There are a myriad of <a id="id906" class="indexterm"/>classes in Ext JS, and it is beyond the scope of this book to introduce them. Sencha provides three types of online documentation in terms of both quality and quantity: a reference manual, tutorials (written and video), and working demos. You are strongly advised to spend ample time reviewing these materials. In this section, a very brief introduction is given about some components, especially those that are likely to interface with Highcharts. This chapter is by no means enough to get you started with programming in Ext JS, but should be enough to give you an idea.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec92"/>Implementing and loading Ext JS code</h2></div></div></div><p>An Ext JS<a id="id907" class="indexterm"/> application can always be divided into multiple<a id="id908" class="indexterm"/> JavaScript files, but they should always start from one HTML file. The following code snippet demonstrates how to start up Ext JS from an HTML file:</p><div><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv="Content-Type" 
          content="text/html; charset=UTF-8"&gt;
    &lt;title&gt;Highcharts for Ext JS 5&lt;/title&gt;
    // At the time of writing, there is no CDN for ExtJs 5
    // Download http://www.sencha.com/products/extjs/download/ext-js-5.0.0/3164
    &lt;link rel="stylesheet" type="text/css" 
          href="/extjs5/packages/ext-theme-classic/build/resources/ext-theme-classic-all.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
  &lt;script type="text/javascript" src="img/ext-all.js"&gt;&lt;/script&gt;
  &lt;script type='text/javascript'&gt;
          Ext.require('Ext.window.Window');
          Ext.onReady(function() {
               // application startup code goes here
               ....
          });
  &lt;/script&gt;
&lt;/html&gt;</pre></div><p>Ext JS 5 is packaged with various themes. The preceding example demonstrates how to load one of the available themes. We will apply different themes in the examples to show the look and feel of Ext JS 5. The script file, <code class="literal">ext-all.js</code>, contains all the Ext JS classes in a compressed format.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>Ext JS has the facility to build a custom class file to cut down loading for production deployments. We are leaving that for you to explore.</p></div></div><p><code class="literal">Ext.require</code> is to <a id="id909" class="indexterm"/>load specific classes used in the application. <code class="literal">Ext.onReady</code> is the <a id="id910" class="indexterm"/>DOM-ready method, the same as the <code class="literal">$.ready</code> jQuery method that the application startup code starts running inside this function.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec93"/>Creating and accessing Ext JS components</h2></div></div></div><p>Out of all the <a id="id911" class="indexterm"/>classes in Ext JS, we should start by discussing <code class="literal">Ext.Component</code>, which is the base class for Ext JS user interface components. Depending on the <a id="id912" class="indexterm"/>characteristics of the component, some of them such as <code class="literal">Panel</code>, <code class="literal">Window</code>, <code class="literal">FieldSet</code>, and <code class="literal">RadioGroup</code> can contain multiple components, because they are inherited through another class: <code class="literal">Container</code>. We will look at <code class="literal">Container</code> in more detail later.</p><p>To create an Ext JS object, we use the <code class="literal">Ext.create</code> method, which takes two parameters. The first parameter is the string presentation of a class path, for example <code class="literal">'Ext.window.Window'</code>, or an alias name such as <code class="literal">'widget.window'</code>. The second parameter is the object specifier, containing the initial values to instantiate a class:</p><div><pre class="programlisting">var win = Ext.create('Ext.window.Window', {
       title: 'Ext JS Window',
       layout: 'fit',
       items: [{
            xtype: 'textarea',
            id: 'textbox',
            value: 'Lorem ipsum dolor sit amet, ... '
       }]
});

win.show();</pre></div><p>The preceding code snippet is used to create a window widget and its content is defined through the <code class="literal">items</code> option. <code class="literal">Window</code> is a class derived from the <code class="literal">Container</code> class, which inherits the <code class="literal">items</code> option for containing other components. When the window is finally created and ready to render, it goes through each object specifier in the items array and creates each component.</p><p>The <code class="literal">xtype</code> option is the Ext-specific type, which has a short unique name to symbolize the component's class path. In Ext JS, all interface components have their own <code class="literal">xtype</code> names (this refers to the <code class="literal">Ext.Component</code> manual). The <code class="literal">xtype</code> option is commonly used for convenience to create components within the container, as opposed to <code class="literal">Ext.create</code> with a full pathname.</p><p>The <code class="literal">id</code> field is <a id="id913" class="indexterm"/>to give a unique ID name to a component. The <a id="id914" class="indexterm"/>purpose is to gain direct access to a component at any point inside a program. To retrieve the component with an ID value, we can execute the following line of code:</p><div><pre class="programlisting">var tb = Ext.getCmp('textbox');</pre></div><p>Alternatively, we can use the <code class="literal">itemId</code> option to assign a unique name. The difference is that the ID has to be globally unique to the application, whereas <code class="literal">itemId</code> only has to be unique within the parent container, to avoid name conflict elsewhere in the application. To access a component with the <code class="literal">itemId</code> value, we need to call <code class="literal">getComponent</code> from the immediate parent container, as follows:</p><div><pre class="programlisting">var tb = win.getComponent('textbox');</pre></div><p>Moreover, we can chain the call all the way from the top level to the desired component, as follows:</p><div><pre class="programlisting">var val =   
win.getComponent('panel').getComponent('textbox').getValue();</pre></div><p>The <code class="literal">'textbox'</code> (with <code class="literal">itemId</code> defined) component is constructed inside the parent container, <code class="literal">'panel'</code>, which resides inside the window object. Although the <code class="literal">getCmp</code> method provides direct, easy access to a component, it should generally be avoided as part of best practices, due to slower performance and undesired effects if a duplicate ID is accidentally used.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>For the sake of avoiding long sample code, we use the <code class="literal">getCmp</code> call in some of the demos.</p></div></div><p>Note that Sencha also provides convenient component navigation, <code class="literal">up</code> and <code class="literal">down</code> methods which search for target component with CSS style selector. Here is an example:</p><div><pre class="programlisting">var val = win.down('#textbox').getValue(); </pre></div><p>As we can see the preceding expression is much more simplified and direct. The <code class="literal">down</code> method basically traverses down to its children components and so on until come across the first component with the matching criteria. In this case, the matching expression <code class="literal">'#textbox'</code> means a component with <code class="literal">itemId</code> specified as a textbox. Many different search expression can be used, another example is <code class="literal">down('textarea')</code> which means searching for the first child component with <code class="literal">xtype</code> value of textarea.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec94"/>Using layout and viewport</h2></div></div></div><p>As we mentioned earlier, some <a id="id915" class="indexterm"/>types of components have the ability to <a id="id916" class="indexterm"/>contain other components, because they are extended from the <code class="literal">Container</code> class. Another feature of the <code class="literal">Container</code> class is to arrange the layout between the contained components; the layout policy is specified via the <code class="literal">layout</code> option. There are about a dozen layout policies: among them <code class="literal">'anchor'</code>, <code class="literal">'border'</code>, and <code class="literal">'fit'</code> are most commonly used (the <code class="literal">card</code> layout is also used often, but through the tab panel). The <code class="literal">border</code> layout is widely used in GUI programming. The layout is finely divided into the <code class="literal">'north'</code>, <code class="literal">'east'</code>, <code class="literal">'south'</code>, <code class="literal">'west'</code>, and <code class="literal">'center'</code> regions.</p><p>When developing an application that requires utilizing the whole browser space, we generally use a <code class="literal">Viewport</code> class coupled with a <code class="literal">border</code> layout. <code class="literal">Viewport</code> is a special type of container whose size automatically binds to the browser. The following is a simple example of using a viewport:</p><div><pre class="programlisting">    var viewport = Ext.create('Ext.container.Viewport', {
      layout: 'border',
      defaults: {
         frame: true
      },
      items: [{
          region: 'north',
          html: '&lt;h1&gt;North&lt;/h1&gt;'
      }, {
          region: 'east',
          html: '&lt;h1&gt;East&lt;/h1&gt;',
          width: '15%'
      }, {
          region: 'south',
          html: '&lt;h1&gt;South&lt;/h1&gt;'
      }, {
          region: 'west',
          html: '&lt;h1&gt;West&lt;/h1&gt;',
          width: '20%'
      }, {
          region: 'center',
          html: '&lt;h1&gt;Center&lt;/h1&gt;'
      }]
    });</pre></div><p>The following<a id="id917" class="indexterm"/> screenshot shows the <code class="literal">border</code> layout in a gray <a id="id918" class="indexterm"/>theme:</p><div><img src="img/7451OS_13_01.jpg" alt="Using layout and viewport"/></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec95"/>Panel</h2></div></div></div><p><code class="literal">Panel</code> is a basic <a id="id919" class="indexterm"/>container <a id="id920" class="indexterm"/>component, and is generally used as a building block with the layout format and then combined with more panels or components. Another general use is to extend the <code class="literal">Panel</code> class to a special purpose type of panel, for example <code class="literal">PortalPanel</code> in the online portal demo. The most widely used panel types are <code class="literal">GridPanel</code>, <code class="literal">FormPanel</code>, and <code class="literal">TabPanel</code>.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec35"/>GridPanel</h3></div></div></div><p><code class="literal">GridPanel</code> <a id="id921" class="indexterm"/>is used for displaying data in table format and it comes with lots of useful <a id="id922" class="indexterm"/>features, such as drag-and-drop column ordering, column sorting, flexible data rendering, enable or disable column display functions, and many others. <code class="literal">GridPanel</code> can also be used with different plugins such as row editor, allowing a user to edit field values on the fly. The class comes with a large set of events settings that can establish smooth coordination with other components. Nonetheless, the most tightly coupled component is the store object, which we will demonstrate in a later section.</p></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec36"/>FormPanel</h3></div></div></div><p><code class="literal">FormPanel</code> is a panel<a id="id923" class="indexterm"/> for accommodating field input components in <a id="id924" class="indexterm"/>form style, that is, labels on the left-hand side, inputs on the right-hand side, and the buttons array. Ext JS provides a great selection of form inputs, such as date time fields, comboboxes, number fields, sliders, and many others. Underneath the <code class="literal">FormPanel</code> layer, there is a <code class="literal">BasicForm</code> component, which contributes to field validations, form submission, and loading services with the store's <code class="literal">Record</code> class for adding and editing entries.</p><p>The following is a screenshot of <code class="literal">FormPanel</code> with various inputs:</p><div><img src="img/7451OS_13_02.jpg" alt="FormPanel"/></div></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec37"/>TabPanel</h3></div></div></div><p><code class="literal">TabPanel</code>, as its <a id="id925" class="indexterm"/>name implies, is a panel associated with tabs. It supports creating and removing <a id="id926" class="indexterm"/>tabs on the fly and scrolling between tabs. The following code snippet shows how to create a tab panel:</p><div><pre class="programlisting">items:[{
      xtype: 'tabpanel',
      items: [{
           title: 'Tab 1',
           xtype: 'form',
           items: [{
                .....
           }]
      }, {
          title: 'Tab 2',
          ....
      }]
}]</pre></div><p>The following is a screenshot of tabs within the tab panel, with a scrolling feature:</p><div><img src="img/7451OS_13_03.jpg" alt="TabPanel"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec96"/>Window</h2></div></div></div><p><code class="literal">Window</code> is a<a id="id927" class="indexterm"/> special type of <a id="id928" class="indexterm"/>panel that is not bound to any parent container and is free-floating within the application. It offers many features found in normal desktop windows, such as resize and maximize/minimize, and also comes with options for adding a toolbar, footer bar, and buttons. Later, we will see the <code class="literal">Window</code> panel in action in an example.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec97"/>Ajax</h2></div></div></div><p>The Ext JS framework provides its <a id="id929" class="indexterm"/>own method, <code class="literal">Ajax.request</code>, for issuing Ajax queries. This is used <a id="id930" class="indexterm"/>when the returned JSON data is not required to be converted into table rows and field columns. The method is generally coupled with <code class="literal">Ext.decode</code> to convert the returned JSON format string into a JavaScript object and directly access individual fields inside the object.</p><p>The following code snippet shows a<a id="id931" class="indexterm"/> sample of issuing <a id="id932" class="indexterm"/>an Ajax query:</p><div><pre class="programlisting">Ext.Ajax.request({
     url: 'getData.php ',
     params: { id: 1 },
     success: function(response) {
          // Decode JSON response from the server
          var result = Ext.decode(response.responseText);
          if (result &amp;&amp; result.success) {
              .... 
          } else {
              ....
          }
     }
});</pre></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec98"/>Store and JsonStore</h2></div></div></div><p><code class="literal">Store</code> is a <a id="id933" class="indexterm"/>general purpose<a id="id934" class="indexterm"/> storage class for modeled data. There are several classes derived from <code class="literal">Store,</code> but the most important one for Highcharts is <code class="literal">JsonStore</code>. It is a proxy-cached storage class responsible for issuing an Ajax query and unpacks the returned JSON data into modeled data. The <code class="literal">JsonStore</code> class is often used for accessing database data that resides on the server side. A store object can bind with more than one component, for <a id="id935" class="indexterm"/>example a<a id="id936" class="indexterm"/> <code class="literal">JsonStore</code> object can bind to a grid panel and a column chart. Clicking on a column order direction in the grid panel can change the row sequence in <code class="literal">JsonStore</code>, affecting the order of the columns displayed in the chart. In other words, the <code class="literal">Store</code> class acts as a skeleton to hold several components working together effortlessly and systematically.</p><p>It is important to note that the load method in the <code class="literal">Store</code> class is asynchronous. An event handler should be assigned to the load event if we want to tie an action after the data is loaded. The action can be specified through <code class="literal">listeners.click</code> via either the object specifier or <code class="literal">store.on</code> method.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec38"/>Example of using JsonStore and GridPanel</h3></div></div></div><p>So far, a number of <a id="id937" class="indexterm"/>Ext JS components<a id="id938" class="indexterm"/> have been introduced; we should see how they work together. Let's build a simple window application that contains a table (<code class="literal">GridPanel</code>) showing a list of hosts with their download usage that are returned from the server. Let's assume that we have rows of data returned in JSON format from the server:</p><div><pre class="programlisting">{ "data": [
       { "host" : "192.168.200.145", "download" : 126633683 },  
       { "host" : "192.168.200.99" , "download" : 55840235 },
       { "host" : "192.168.200.148", "download" : 54382673 },
        ...
] }</pre></div><p>First we define the data model to correspond with the JSON data. For the sake of simplicity, we can put all our demo code inside <code class="literal">Ext.onReady</code> rather than in a separate JavaScript file:</p><div><pre class="programlisting">Ext.onReady(function() {
    Ext.define('NetworkData', {
        extend: 'Ext.data.Model',
        fields: [
            {name: 'host',  type: 'string'},
            {name: 'download', type: 'int'}        
        ]
    });
});</pre></div><div><div><h3 class="title"><a id="note26"/>Note</h3><p>It is not mandatory to accept field names returned by the server. <code class="literal">Ext.data.Model</code> offers the <code class="literal">mapping</code> option to map an alternative field name to use on the client side.</p></div></div><p>The next step <a id="id939" class="indexterm"/>is to define a <code class="literal">JsonStore</code> object with the URL, connection type, and the<a id="id940" class="indexterm"/> data format type. We will bind the <code class="literal">JsonStore</code> object with the <code class="literal">NetworkData</code> data model defined in the preceding code snippet:</p><div><pre class="programlisting">var netStore = Ext.create('Ext.data.JsonStore', {
      autoLoad: true,
      model: 'NetworkData',
      proxy: {
        type: 'ajax',
        url: './getNetTraffic.php',
        reader: {
            type: 'json',
            idProperty: 'host',
            rootProperty: 'data'
        }
    }
});</pre></div><p><code class="literal">idProperty</code> is used to define which field is regarded as an ID if the default <code class="literal">'id'</code> fieldname is not provided, so that methods such as <code class="literal">Store.getById</code> can function properly. The <code class="literal">root</code> option tells the reader (<code class="literal">JsonReader</code>) which property name holds the array of row data in the JSON response from the server. The next task is to build a <code class="literal">Window</code> panel with a <code class="literal">GridPanel</code> class, as follows:</p><div><pre class="programlisting">var win = Ext.create('Ext.window.Window', {
      title: 'Network Traffic',
      layout: 'fit',
      items: [{
             xtype: 'grid',
             height: 170,
             width: 270,
             store: netStore,
             columns: [{
                 header: 'IP Address',
                 dataIndex: 'host',
                 width: 150
             }, {
                 header: 'Download',
                 dataIndex: 'download'
             }]
      }]
}).show();</pre></div><p>We instruct the grid panel to <a id="id941" class="indexterm"/>bind with the <code class="literal">netStore</code> object and define a list of columns to<a id="id942" class="indexterm"/> display. We then match each column to the store's data field through the <code class="literal">dataIndex</code> option. The following is a screenshot showing part of a window (crisp theme) with a grid panel inside it:</p><div><img src="img/7451OS_13_04.jpg" alt="Example of using JsonStore and GridPanel"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec86"/>The Highcharts extension</h1></div></div></div><p>In this section, we <a id="id943" class="indexterm"/>will examine how simple it is to create a Highcharts component in Ext JS. We do this by importing from an existing Highcharts configuration. Let's continue from the previous JsonStore example and incorporate it within the extension.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec99"/>Step 1 – removing some of the Highcharts options</h2></div></div></div><p>Let's assume that we already have a working <a id="id944" class="indexterm"/>independent Highcharts configuration, as follows:</p><div><pre class="programlisting">var myConfig = {
      chart: {
            renderTo: 'container',
            width: 350,
            height: 300,
            ....
      },
      series: [{
          type: 'column',
          data: [ 126633683, 55840235, .... ]
      }],
      xAxis: { 
          categories: [ "192.168.200.145", 
                        "192.168.200.99", ... ],
          ....
      },
      yAxis: { .... },
      title: { .... },
      ....
};</pre></div><p>The first step is to remove all the fields that the extension will handle internally and pass them to Highcharts. For this reason, we need to remove <code class="literal">chart.renderTo</code> and the dimension options. We also need to remove the <code class="literal">chart.series</code> array, because eventually <code class="literal">JsonStore</code> will be the source of graph data. We also want to remove <code class="literal">chart.xAxis.categories</code> as it contains graph data.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec100"/>Step 2 – converting to a Highcharts extension configuration</h2></div></div></div><p>The next step is to construct a<a id="id945" class="indexterm"/> new configuration for the extension derived from the old Highcharts configuration. Let's start a new configuration object, <code class="literal">myNewConfig</code>, with the size properties:</p><div><pre class="programlisting">var myNewConfig = {
        width: 350,
        height: 300
};</pre></div><p>The next step is to create a new <a id="id946" class="indexterm"/>option, <code class="literal">chartConfig</code>, which is required by the extension. We put the rest of the properties left in the <code class="literal">myConfig</code> object towards <code class="literal">chartConfig</code>. The following code snippet shows what the new config should look like:</p><div><pre class="programlisting">// ExtJS component config for Highcharts extension
var myNewConfig = {
        width: 450,
        height: 350,
        chartConfig: {
              // Trimmed Highcharts configuration here
              chart: { .... },
              xAxis: { .... },
              yAxis: { .... },
              title: { .... },
              ....
        }
};</pre></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec101"/>Step 3 – constructing a series option by mapping the JsonStore data model</h2></div></div></div><p>Recalling the data model of <a id="id947" class="indexterm"/>the store object, we <a id="id948" class="indexterm"/>have the following code snippet:</p><div><pre class="programlisting">        fields: [
            { name: 'host', type: 'string' },
            { name: 'download', type: 'int' }        
        ]</pre></div><p>The next task is to build a series array with options matching the data model of <code class="literal">JsonStore</code>. The new series array has a similar structure to the one in Highcharts options. We also need to link the store object inside the object configuration. Eventually, the options object should become like the following code snippet:</p><div><pre class="programlisting">var myNewConfig = {
        width: 450,
        height: 350,
        store: netStore,
        series: [{
              name: 'Network Traffic',
              type: 'column',
              // construct the series data out of the
              // 'download' field from the return Json data
              dataIndex: 'download'
        }],
        // construct the x-axis categories data from
        // 'host' field from the return Json data
        xField: 'host',
        chartConfig: {
             .... 
        }
};</pre></div><p>The <code class="literal">dataIndex</code> option is<a id="id949" class="indexterm"/> used for mapping <a id="id950" class="indexterm"/>the <em>y</em> value from <code class="literal">JsonStore</code> into the series data array. As the <code class="literal">'host'</code> field is string-type data, it is used as categories. Therefore, we specify the <code class="literal">xField</code> option outside the series array shared by the series.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec102"/>Step 4 – creating the Highcharts extension</h2></div></div></div><p>The final step is to put<a id="id951" class="indexterm"/> everything together to display a chart in Ext JS. We can create a Highcharts component first and put it inside an Ext JS container object, as follows:</p><div><pre class="programlisting">var hcChart = Ext.create('Chart.ux.Highcharts', myNewConfig);
var win = Ext.create('widget.window', {
      title: 'Network Traffic',
      layout: 'fit',
      items: [ hcChart ]
}).show();</pre></div><p>Or alternatively, we can create the whole thing through one configuration using <code class="literal">xtype</code>, as follows:</p><div><pre class="programlisting">var win = Ext.create('widget.window', {
      title: 'Network Traffic',
      layout: 'fit',
      items: [{
             xtype: 'highchart',
             itemId: 'highchart',
             height: 350,
             width: 450,
             store: netStore,
             series: [{ .... }],
             xField: 'host',
             chartConfig: {
                 chart: { .... },
                 xAxis: { .... },
                 yAxis: { .... },
                 ....
      }]
}).show();</pre></div><p>The following<a id="id952" class="indexterm"/> screenshot shows a Highcharts graph inside an Ext JS window (classic theme):</p><div><img src="img/7451OS_13_05.jpg" alt="Step 4 – creating the Highcharts extension"/></div><div><div><h3 class="title"><a id="note27"/>Note</h3><p>In order to display data at startup, the JsonStore must be instantiated by setting the <code class="literal">autoLoad</code> option to <code class="literal">true</code> or calling the <code class="literal">Store.load</code> method manually at the start of the program.</p></div></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec39"/>Passing series-specific options in the Highcharts extension</h3></div></div></div><p>If we need to <a id="id953" class="indexterm"/>pass series-specific options, for example <a id="id954" class="indexterm"/>color, data point decorations, and so on, then we simply put them into the series configuration in the same way we normally do in Highcharts:</p><div><pre class="programlisting">       .....
       store: netStore,
            series: [{
                  name: 'Network Traffic',
                  type: 'column',
                  dataIndex: 'download',
                  color: '#A47D7C'
            }],</pre></div><p>The extension will copy these options across at the same time as creating the series.</p></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec103"/>Converting a data model into a Highcharts series</h2></div></div></div><p>In the previous example, we learned how to <a id="id955" class="indexterm"/>map a simple data model from the Ext JS store into Highcharts. However, there are several ways to declare the data mapping, and each way has different implications depending on the scenarios, especially in multiple series.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec40"/>X-axis category data and y-axis numerical values</h3></div></div></div><p>This is the simplest<a id="id956" class="indexterm"/> and probably the most<a id="id957" class="indexterm"/> common scenario. Each series has numerical values along the <em>y</em> axis and shares data between the categories. For historical reasons, the <code class="literal">dataIndex</code> option can also be replaced with another option name, <code class="literal">yField</code>, which has a higher priority, and both behave in exactly the same way:</p><div><pre class="programlisting">            series: [{
                  name: 'Upload',
                  type: 'column',
                  yField: 'upload'
            }, {
                  name: 'Download',
                  type: 'column',
                  yField: 'download'
           }],
           // 'Monday', 'Tuesday', 'Wednesday' ....  
           xField: 'day'</pre></div></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec41"/>Numerical values for both x and y axes</h3></div></div></div><p>Another scenario is where <a id="id958" class="indexterm"/>both the <em>x</em> and <em>y</em> axes are made up of numerical values. There are two different ways to specify the data mapping. First, each series holds the <em>y</em> axis values and shares common <em>x</em> axis values. In this case, the series are specified in the same way as the previous example:</p><div><pre class="programlisting">           series: [{
                  name: 'Upload',
                  type: 'line',
                  yField: 'upload'
            }, {
                  name: 'Download',
                  type: 'line',
                  yField: 'download'
           }], 
           // Time in UTC
           xField: 'time'</pre></div><p>Another situation is that each series holds its own pairs of <em>x</em> and <em>y</em> values, as follows:</p><div><pre class="programlisting">           series: [{
                  name: 'Upload',
                  type: 'line',
                  yField: 'upload',
                  xField: 'upload_time'
            }, {
                  name: 'Download',
                  type: 'line',
                  yField: 'download',
                  xField: 'download_time'
           }]</pre></div><p>The difference<a id="id959" class="indexterm"/> between the two settings is that the first configuration ends up with two line series in the graph with data points aligning along the <em>x</em> axis, whereas the latter one doesn't, and the store data model is different as well.</p></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec42"/>Performing preprocessing from store data</h3></div></div></div><p>Suppose that we need to perform a<a id="id960" class="indexterm"/> preprocessing task on the server data before we can plot the chart. We can do this by overriding a template method in the series configuration.</p><p>Inside the extension code, each series is actually instantiated from a <code class="literal">Serie</code> class. This class has a standard method defined, <code class="literal">getData</code>, which is for retrieving data from the store. Let's visit the original implementation of <code class="literal">getData</code>:</p><div><pre class="programlisting">  getData : function(record, index) {
     var yField = this.yField || this.dataIndex, 
         xField = this.xField, 
         point = {
             data : record.data,
             y : record.data[yField]
         };
     if (xField)
         point.x = record.data[xField];
     return point;
  },</pre></div><div><div><h3 class="title"><a id="note28"/>Note</h3><p>The classes and methods in this extension are named that way with the word "<code class="literal">Serie</code>" by the original author.</p></div></div><p>Basically, <code class="literal">getData</code> is called for every row returned from <code class="literal">JsonStore</code>. The method is passed with two parameters. The first one is an Ext JS <code class="literal">Record</code> object, which is an object representation of a row of data. The second parameter is the index value of the record inside the store. Inside the <code class="literal">Record</code> object, the <code class="literal">data</code> option holds the values according to the model definition when the store object is created.</p><p>As we can see, the simple<a id="id961" class="indexterm"/> implementation of <code class="literal">getData</code> is to access <code class="literal">record.data</code> based on the values of <code class="literal">xField</code>, <code class="literal">yField</code>, and <code class="literal">dataIndex</code> and format it into a Highcharts <code class="literal">Point</code> configuration. We can override this method as we declare a series to suit our need for data conversion. Let's continue the example: suppose the server is returning the data in a JSON string:</p><div><pre class="programlisting">{"data":[
      {"host":"192.168.200.145","download":126633683,
       "upload":104069233},
      {"host":"192.168.200.99","download":55840235,
       "upload":104069233},
      {"host":"192.168.200.148","download":54382673,
       "upload":19565468},
       ....</pre></div><p><code class="literal">JsonStore</code> interprets the preceding data as rows with the following model definition:</p><div><pre class="programlisting">    fields: [
        {name: 'host',  type: 'string'},
        {name: 'download', type: 'int'}, 
        {name: 'upload', type: 'int'}        
    ]</pre></div><p>We need to plot a column chart with each bar as the total of the upload and download fields, so we define the <code class="literal">getData</code> method for the series as shown next. Note that we don't need to declare <code class="literal">yField</code> or <code class="literal">dataIndex</code> anymore, because the <code class="literal">getData</code> method for this particular series has already taken care of the field mappings:</p><div><pre class="programlisting">   series: [{
       name: 'Total Usage',
       type: 'column',
       getData: function(record, index) {
           return {
               data: record.data,
               y: record.data.upload + 
                  record.data.download
           };
       } 
   }],
   xField: 'host',
   ....</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec104"/>Plotting pie charts</h2></div></div></div><p>Plotting <a id="id962" class="indexterm"/>pie charts is slightly different to line, column, and scatter charts. A pie series is composed of data values where each value is from a category. Therefore, the module has two specific option names, <code class="literal">categorieField</code> and <code class="literal">dataField</code>, for category and data, respectively. To plot a pie chart, the series is needed to specify the following:</p><div><pre class="programlisting">    series: [{
        type: 'pie',
        categorieField: 'host',
        dataField: 'upload'
    }]</pre></div><p>The <code class="literal">getData</code> method of the <code class="literal">PieSeries</code> class subsequently converts the mapped data from the store into the <code class="literal">Point</code> object, with values assigned to the <code class="literal">name</code> and <code class="literal">y</code> fields.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec43"/>Plotting donut charts</h3></div></div></div><p>Let's remind <a id="id963" class="indexterm"/>ourselves that a donut chart is actually a two-series pie chart in which the data in the inner pie is a subcategory of the outer pie. In other words, each slice in the inner series is always the total of its outer portions. Therefore, the data returned from <code class="literal">JsonStore</code> has to be designed in such a way that these can be grouped into subcategories by field name. In this case, the JSON data should be returned, as follows:</p><div><pre class="programlisting">{ "data": [
       { "host" : "192.168.200.145", "bytes" : 126633683,
         "direction" : "download"},  
       { "host" : "192.168.200.145", "bytes" : 104069233,
         "direction" : "upload"},  
       { "host" : "192.168.200.99", "bytes" : 55840235,
         "direction" : "download"},  
       { "host" : "192.168.200.99", "bytes" : 104069233, 
         "direction" : "upload"},  
       ....
] }</pre></div><p>Then, we use an extra Boolean option, <code class="literal">totalDataField</code>, for the inner pie series to indicate that we want to use <code class="literal">dataField</code> to scan for the total value for each <code class="literal">"host"</code> category. As for the outer series, we just define it as a normal pie series, but with <code class="literal">"direction"</code> and <code class="literal">"bytes"</code> as <code class="literal">categorieField</code> and <code class="literal">dataField</code>, respectively. The following is the series definition for the donut chart:</p><div><pre class="programlisting">             series: [{
                   // Inner pie
                   type: 'pie',
                   categorieField: 'host',
                   dataField: 'bytes',
                   totalDataField: true,
                   size: '60%',
                   ....
             }, {
                   // Outer pie
                   type: 'pie',
                   categorieField: 'direction',
                   dataField: 'bytes',
                   innerSize: '60%',
                   ....
             }]</pre></div><p>The following screenshot shows what a donut chart looks like in Ext JS (aria theme):</p><div><img src="img/7451OS_13_06.jpg" alt="Plotting donut charts"/></div><p>Inside the <a id="id964" class="indexterm"/>extension, the implementation of the <code class="literal">getData</code> method for the <code class="literal">PieSeries</code> class is significantly different from other series types, in order to handle both pie and donut series data. Therefore, it is not advisable to overwrite this method. Later on, we will see how pie and donut charts are plotted with this module.</p></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec105"/>Module APIs</h2></div></div></div><p>The Highcharts<a id="id965" class="indexterm"/> extension comes with a small set of APIs. Most of them are helper functions to modify series in the Ext JS layer. As for the Highcharts native APIs, they can be invoked through the <code class="literal">chart</code> property inside the extension component, for example:</p><div><pre class="programlisting">win.down('#highchart').chart.getSVG({ ... });</pre></div><p>In the preceding line of code, <code class="literal">'highchart'</code> is the <code class="literal">itemId</code> value when the chart component is created. The <code class="literal">down</code> method is Ext JS's convenient way of using the CSS selection style to navigate through the hierarchical components.</p><p>As<a id="id966" class="indexterm"/> mentioned earlier, the <code class="literal">chartConfig</code> option contains all the Highcharts configurations. Once the chart component is created, it saves <code class="literal">chartConfig</code> inside the component. Hence, the <code class="literal">chartConfig</code> property possesses all the initial configurations that have created the chart. Later, we will see how this <code class="literal">chartConfig</code> property plays a role with regards to API calls.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec44"/>addSeries</h3></div></div></div><p>The <code class="literal">addSeries</code> method<a id="id967" class="indexterm"/> adds one or more series into the chart. The added series is/are also stored inside the <code class="literal">chartConfig.series</code> array, as follows:</p><div><pre class="programlisting">addSeries : function(Array series, [Boolean append]) </pre></div><p>The series <a id="id968" class="indexterm"/>parameter is an array of series configuration objects. <code class="literal">addSeries</code> not only allows series configuration with the <code class="literal">xField</code>, <code class="literal">yField</code>, and <code class="literal">dataIndex</code> options, but also supports series configuration with the data array, so it won't go via the store object to extract the data. The following are examples of using <code class="literal">addSeries</code> in different ways:</p><div><pre class="programlisting">Ext.getComponent('highchart').addSeries([{
       name: 'Upload',
       yField: 'upload'
}], true);

Ext.getComponent('highchart').addSeries([{
       name: 'Random',
       type: 'column',
       data: [ 524524435, 434324423, 43436454, 47376432 ]
}], true);</pre></div><p>The optional <code class="literal">append</code> parameter sets the series parameter to either replace the currently displayed series or append the series to the chart. The default is <code class="literal">false</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec45"/>removeSerie and removeAllSeries</h3></div></div></div><p>The<a id="id969" class="indexterm"/> <code class="literal">removeSerie</code> method<a id="id970" class="indexterm"/> removes a single series in the chart and the <code class="literal">removeAllSeries</code> method<a id="id971" class="indexterm"/> removes<a id="id972" class="indexterm"/> all the series defined for the chart. Both methods also remove the series configuration in <code class="literal">chartConfig.series</code>, as follows:</p><div><pre class="programlisting">removeSerie : function(Number idx, [Boolean redraw])
removeAllSeries : function()</pre></div><p>The <code class="literal">idx</code> parameter is the index value in the series array. The optional <code class="literal">redraw</code> parameter sets whether to redraw the chart after the series is removed. The default is <code class="literal">true</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec46"/>setTitle and setSubTitle</h3></div></div></div><p>Both <code class="literal">setTitle</code> and <code class="literal">setSubTitle</code> change<a id="id973" class="indexterm"/> the<a id="id974" class="indexterm"/> current chart title <a id="id975" class="indexterm"/>as well as the title <a id="id976" class="indexterm"/>settings in <code class="literal">chartConfig</code>, as follows:</p><div><pre class="programlisting">setSubTitle : function(String title)
setTitle: function(String title)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch13lvl3sec47"/>draw</h3></div></div></div><p>So far, we have <a id="id977" class="indexterm"/>mentioned <code class="literal">chartConfig</code> but haven't really explained what it does<a id="id978" class="indexterm"/> in the module. The <code class="literal">draw</code> method actually destroys the internal Highcharts object and recreates the chart based on the settings inside the current <code class="literal">chartConfig</code>. Suppose we have already created a chart component but we want to change some of the display properties. We modify properties inside <code class="literal">chartConfig</code> (Highcharts configurations) and call this method to recreate the internal Highcharts object:</p><div><pre class="programlisting">draw: function()</pre></div><p>Although we can call Highcharts' native APIs via the internal <code class="literal">chart</code> option without destroying and recreating the chart, not all Highcharts elements can be changed with API calls, for example series color, legend layout, the column stacking option, invert chart axes, and so on.</p><p>As a result, this method enables the extension component to refresh the internal chart with any configuration change, without the need to recreate the component itself. Hence, this empowers the Ext JS application by not removing it from the parent container and reinserting a new one. Also, the layout in the parent container is not disrupted.</p></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec106"/>Event handling and export modules</h2></div></div></div><p>Specifying chart event <a id="id979" class="indexterm"/>handlers<a id="id980" class="indexterm"/> for the extension is exactly the same as how we normally declare event handlers in Highcharts. Since this is now under both the Ext JS and jQuery environments, the implementation can use both Ext JS and jQuery methods.</p><p>The Highcharts exporting chart module is unaffected by the extension. The export settings simply bypass this extension and work straightaway.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec107"/>Extending the example with Highcharts</h2></div></div></div><p>In this section, we <a id="id981" class="indexterm"/>will build a larger example that includes other types of panels and charts. The application is built with a viewport showing two regions—the <code class="literal">'center'</code> region is a tab panel containing three tabs for each different type of network data graph, and the <code class="literal">'west'</code> region shows the table data of the current graph on display. The graph in the first tab is <strong>Bandwidth Utilisation</strong>, which indicates the data rate passing through the network.</p><p>The following screenshot shows the front screen of the application (neptune theme):</p><div><img src="img/7451OS_13_07.jpg" alt="Extending the example with Highcharts"/></div><p><strong>Plot Yesterday</strong> in the toolbar is a toggle button that triggers an additional series, <strong>Yesterday</strong>, to be plotted on the same chart. An extra column of data called <strong>Yesterday</strong> is also displayed in the left-hand side table, as shown in the following screenshot:</p><div><img src="img/7451OS_13_08.jpg" alt="Extending the example with Highcharts"/></div><p>The <a id="id982" class="indexterm"/>
<strong>Plot Yesterday</strong> button handler uses the <code class="literal">addSeries</code> and <code class="literal">removeSeries</code> methods internally to toggle the <strong>Yesterday</strong> series. The following is the implementation:</p><div><pre class="programlisting">    toggleHandler: function(item, pressed) {
        // Retrieve the chart extension component
        var chart = Ext.getCmp('chart1').chart;
        if (pressed &amp;&amp; chart.series.length == 1) {
            Ext.getCmp('chart1').addSeries([{
                name: 'Yesterday',
                yField: 'yesterday'
            }], true);
            // Display yesterday column in the grid panel
            .... 
        } else if (!pressed &amp;&amp; chart.series.length == 2) {
            Ext.getCmp('chart1').removeSerie(1);
            // Hide yesterday column in the grid panel
            ....
        }
     }</pre></div><p>Let's move on to the second tab, which is a column chart showing a list of hosts with their network usage in uplink and downlink directions, as follows:</p><div><img src="img/7451OS_13_09.jpg" alt="Extending the example with Highcharts"/></div><p>When we click on the <a id="id983" class="indexterm"/>
<strong>Stacked Columns</strong> button, the bars of both series are stacked together instead of aligned adjacent to each other, as follows:</p><div><img src="img/7451OS_13_10.jpg" alt="Extending the example with Highcharts"/></div><p>This is achieved<a id="id984" class="indexterm"/> by modifying the column <code class="literal">stacking</code> option inside the extension <code class="literal">chartConfig</code> property and recreating the whole chart with the module's <code class="literal">draw</code> method:</p><div><pre class="programlisting">  toggleHandler: function(item, pressed) {
       var chart2 = Ext.getCmp('chart2');    
           chart2.chartConfig.plotOptions.column.stacking = 
              (pressed) ? 'normal' : null;
           chart2.draw();
  }</pre></div><p>Note that we declare the default <code class="literal">stacking</code> option inside <code class="literal">chartConfig</code> when we create the chart, so that we can directly modify the property in the handler code later:</p><div><pre class="programlisting">     chartConfig: {
         .... ,                  
         plotOptions: {
             column: { stacking: null }
         },
         ......</pre></div><p>The final tab is <strong>Last 7 Days Network Usage</strong>, which has a pie chart showing the network usage for each of the last seven days, as shown in the following screenshot:</p><div><img src="img/7451OS_13_11.jpg" alt="Extending the example with Highcharts"/></div><p>Let's see how<a id="id985" class="indexterm"/> this pie chart is implemented in detail. <code class="literal">JsonStore</code> is adjusted to return data in the following format:</p><div><pre class="programlisting">{"data": [
      {"date": "Mon 13/08", "type": "wan", 
       "bytes": 92959786, "color": "#8187ff" },
      {"date": "Mon 13/08", "type": "lan", 
       "bytes": 438238992, "color": "#E066A3" },
      {"date": "Tue 14/08", "type": "wan", 
       "bytes": 241585530, "color": "#8187ff" },
      {"date":"Tue 14/08", "type": "lan", 
       "bytes": 773479723, "color": "#E066A3" },
      .....</pre></div><p>Then, we define the tab panel content, as follows:</p><div><pre class="programlisting">           items:[{              
                 xtype: 'highchart',
                 id: 'chart3',
                 store: summStore,
                 series: [{ 
                     type: 'pie',
                     name: 'Total',
                     categorieField: 'date',
                     dataField: 'bytes', 
                     totalDataField: true,
                     size: '60%',  
                     showInLegend: true,
                     dataLabels: { enabled: true }
                 }],
                 chartConfig: {
                     chart: {...},
                     title: {  text: null },
                     legend: { enabled: false }
                 }
           }]</pre></div><p>The series is set up as an inner series, hence the use of the <code class="literal">totalDataField</code> and <code class="literal">dataField</code> options to get the total bytes of <code class="literal">"lan"</code> and <code class="literal">"wan"</code> as the slice value for each <code class="literal">'host'</code>. If we click on the <strong>Show Traffic Type</strong> button, then the pie chart is changed to a donut chart, as shown in the following screenshot:</p><div><img src="img/7451OS_13_12.jpg" alt="Extending the example with Highcharts"/></div><p>The original <a id="id986" class="indexterm"/>data labels in the first pie chart are replaced with items inside the legend box. An outer series is displayed with a fixed color scheme to show the <strong>LAN</strong> and <strong>WAN</strong> portions of traffic. The following is the <strong>Show Traffic Type</strong> button's button handler code:</p><div><pre class="programlisting">     toggleHandler: function(item, pressed) {
         var config = Ext.getCmp('chart3').chartConfig;
         if (pressed) {
             Ext.getCmp('chart3').addSeries([{
                 type: 'pie',
                 center: [ '50%', '45%' ],
                 categorieField: 'type',
                 dataField: 'bytes',
                 colorField: 'color',
                 innerSize: '50%',
                 dataLabels: {
                     distance: 20,
                     formatter: function() {
                       if (this.point.x &lt;= 1) {
                         return this.point.name.toUpperCase();
                       }
                       return null;
                     }
                 },
                 size: '60%'
             }], true);

             config.legend.enabled = true;
             config.series[0].dataLabels.enabled = false;
             config.series[0].size = '50%';
             config.series[0].center = [ '50%', '45%' ];
         } else {
             Ext.getCmp('chart3').removeSerie(1);
             config.legend.enabled = false;
             config.series[0].dataLabels.enabled = true;
             config.series[0].size = '60%';
             config.series[0].center = [ '50%', '50%' ];
         }
         Ext.getCmp('chart3').draw();
     }</pre></div><p>If the toggle<a id="id987" class="indexterm"/> button is enabled, then we add an outer pie series (with the <code class="literal">innerSize</code> option) via the <code class="literal">addSeries</code> method. Moreover, we align the outer series accordingly with the traffic <code class="literal">'type'</code>, and so <code class="literal">categorieField</code> and <code class="literal">dataField</code> are assigned to <code class="literal">'type'</code> and <code class="literal">'bytes'</code>. Since more information is needed to display the second series, we set the inner series to a smaller size for more space. In order to only show the first two data labels in the outer series, we implement <code class="literal">dataLabels.formatter</code> to print the label when <code class="literal">this.point.x</code> is 0 and 1. After that, we disable the data labels by returning null in the <code class="literal">formatter</code> function. Finally, the <code class="literal">draw</code> method is used to reflect all the changes.</p><div><div><div><div><h3 class="title"><a id="ch13lvl3sec48"/>Displaying a context menu by clicking on a data point</h3></div></div></div><p>For interactive applications, it <a id="id988" class="indexterm"/>would be handy to allow users to launch specific actions by clicking on a data point. To do that, we need to handle Highcharts' click events. Here, we create a simple menu for showing the difference between the selected point and the average value of the series. The following is the sample code:</p><div><pre class="programlisting">point: {
  events: {
    click: function(evt) {
      var menu = 
        Ext.create('Ext.menu.Menu', {
          items: [{
            text: 'Compare to Average Usage',
            scope: this,
            handler: function() {
              var series = this.series, 
                  yVal = this, avg = 0, msg = '';

              Ext.each(this.series.data, function(point) {
                avg += point.y;
              });
              avg /= this.series.data.length;

              if (yVal &gt; avg) {
                msg = 
                  Highcharts.numberFormat(yVal - avg) + 
                  " above average (" +               
                  Highcharts.numberFormat(avg) + ")";
              } else {
                msg = 
                  Highcharts.numberFormat(avg - yVal) + 
                  " below average (" +  
                  Highcharts.numberFormat(avg) + ")";
              }
                                                   
              Ext.Msg.alert('Info', msg);
            }
          }]  // items:
        });
                                        
        menu.showAt(evt.point.pageX, evt.point.pageY);
      }
    }
  }</pre></div><p>First we create a simple Ext JS <code class="literal">Menu</code> object with the menu item <strong>Compare to Average Usage</strong>. The <code class="literal">click</code> handler is called with the mouse event parameter, <code class="literal">evt</code>, and then we obtain the mouse pointer location, <code class="literal">pageX</code> and <code class="literal">pageY</code>, and pass it to the menu object. As a result, the Ext JS menu appears next to the pointer after clicking on a data point.</p><p>The <code class="literal">'this'</code> keyword in<a id="id989" class="indexterm"/> the <code class="literal">click</code> event handler refers to the selected point object. We then use the <code class="literal">scope</code> option to pass the Highcharts point object to the menu handler layer. Inside the handler, the <code class="literal">'this'</code> keyword becomes the data point object instead of the Ext JS menu item. We extract the series data to calculate the average and compute the difference with the selected point value. Then, we display the message with the value. The following is the screenshot of the menu:</p><div><img src="img/7451OS_13_13.jpg" alt="Displaying a context menu by clicking on a data point"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec87"/>A commercial RIA with Highcharts – Profiler</h1></div></div></div><p>So far, we<a id="id990" class="indexterm"/> have demonstrated how Highcharts can be applied within the Ext JS framework. However, the demo itself seems rather shrink-wrapped for an RIA product. In this section, we will have a quick glance at a commercial application, <strong>Profiler,</strong> a tool<a id="id991" class="indexterm"/> for profiling companies network scenario developed by iTrinegy. Due to the nature of its business, a stack of diagnostic graphs is required for this type of application. The whole application is designed as a collection of portals for monitoring network traffic from multiple sites. Users can drill down from utilization graph to top downlink usage by IP address graph, modify filter properties to display relative data in multiple series, and so on.</p><p>In order to fine-tune the profiling parameters and provide a portal interface, a framework offering dynamic and calibrated user interfaces is needed. For this reason, Ext JS is a suitable candidate, as it offers a rich set of professional looking widget components, and its cross-browser support makes building complicated RIA software manageable. The following is the interface for launching a bandwidth utilization report graph with specific parameters:</p><div><img src="img/7451OS_13_14.jpg" alt="A commercial RIA with Highcharts – Profiler"/></div><p>The <a id="id992" class="indexterm"/>Highcharts events are easily bound with Ext JS components so that a fully interactive navigation style becomes possible. For instance, if a peak appears on the <strong>Utilisation</strong> graph, the users can either click on the peak data point or highlight a region for a specific time range, then a context menu with a selection of network graphs pops up. This action means that we can append the selected time region to be part of the accumulated filters and navigate towards a specific graph. The following is a screenshot of the context menu, which shows up in one of the graphs:</p><div><img src="img/7451OS_13_15.jpg" alt="A commercial RIA with Highcharts – Profiler"/></div><p>If we <a id="id993" class="indexterm"/>proceed by selecting the same graph again, <strong>Utilisation</strong>, it means we want to zoom into greater detail within the selected time region. This doesn't use the Highcharts default zoom action, which just stretches the graph series and redraws the axes. In fact, it launches another Ajax query with the selected time and returns graph data in finer granularity, so the peak in the graph can be diagnosed further. In other words, the application enables the user to visually filter through a sequence of different graphs. At the same time, the user gradually refines the filters in different dimensions. This process dissects the problem into the root cause in a prompt, intuitive, and effective fashion.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec88"/>Summary</h1></div></div></div><p>In this chapter, we learned the very basics of Ext JS, which is a framework for building <strong>Rich Internet Applications</strong> (<strong>RIAs</strong>). We looked at a quick introduction of a dozen Ext JS components that are likely to be used with the Highcharts extension for Ext JS. Then, we explored how to create a Highcharts component from an existing Highcharts configuration in a step-by-step approach. We looked into the small set of APIs that are provided by the extension module and built a simple application with network usage data. Finally, we took a brief look at Highcharts and Ext JS applied to a commercial network profiling application.</p><p>In the next chapter, we will explore how to run Highcharts on the server side.</p></div></body></html>