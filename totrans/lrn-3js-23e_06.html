<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Advanced Geometries and Binary Operations</h1></div></div></div><p>In the previous chapter, we showed you all the basic geometries provided by Three.js. Besides these basic geometries, Three.js also offers a set of more advanced and specialized objects. In this chapter, we'll show you these advanced geometries and cover the following subjects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to use advanced geometries such as <code class="literal">THREE.ConvexGeometry</code>, <code class="literal">THREE.LatheGeometry</code>, and <code class="literal">THREE.TubeGeometry</code>.</li><li class="listitem" style="list-style-type: disc">How to create 3D shapes from 2D shapes using <code class="literal">THREE.ExtrudeGeometry</code>. We'll do this based on a 2D shape drawn using functionality provided by Three.js, and we'll show an example where we create a 3D shape based on an externally loaded SVG image.</li><li class="listitem" style="list-style-type: disc">If you want to create custom shapes yourself, you can easily amend the ones we've discussed in the previous chapters. Three.js, however, also offers a <code class="literal">THREE.ParamtericGeometry</code> object. With this object, you can create a geometry based on a set of equations.</li><li class="listitem" style="list-style-type: disc">Finally, we'll look at how you can create 3D text effects using <code class="literal">THREE.TextGeometry</code>.</li><li class="listitem" style="list-style-type: disc">Additionally, we'll also show you how you can create new geometries from existing ones using binary operations provided by the Three.js extension, ThreeBSP.</li></ul></div><p>We'll start with the first one from this list, <code class="literal">THREE.ConvexGeometry</code>.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>THREE.ConvexGeometry</h1></div></div></div><p>With <code class="literal">THREE.ConvexGeometry</code>, we<a id="id566" class="indexterm"/> can create a convex hull around a set of points. A convex hull is the minimal shape that encompasses all these points. The easiest way to understand this is by looking at an example. If you open up the <code class="literal">01-advanced-3d-geometries-convex.html</code> example, you'll see the convex <a id="id567" class="indexterm"/>hull for a random set of points. The following screenshot shows this geometry:</p><div><img src="img/2215OS_06_01.jpg" alt="THREE.ConvexGeometry"/></div><p>In this <a id="id568" class="indexterm"/>example, we generate a random set of points and based on these points we create <code class="literal">THREE.ConvexGeometry</code>. In the example, you can click on <strong>redraw</strong>, which will generate 20 new points and draw the convex hull. We also add each of these points as a small <code class="literal">THREE.SphereGeometry</code> object to clearly show how a convex hull works. <code class="literal">THREE.ConvexGeometry</code> isn't included in the standard Three.js distribution, so you have to include an additional JavaScript file to use this geometry. At the top of your HTML page, add the following:</p><div><pre class="programlisting">&lt;script src="img/ConvexGeometry.js"&gt;&lt;/script&gt;</pre></div><p>The following piece of code shows how these points were created and added to the scene:</p><div><pre class="programlisting">function generatePoints() {
  // add 10 random spheres
  var points = [];
  for (var i = 0; i &lt; 20; i++) {
    var randomX = -15 + Math.round(Math.random() * 30);
    var randomY = -15 + Math.round(Math.random() * 30);
    var randomZ = -15 + Math.round(Math.random() * 30);
    points.push(new THREE.Vector3(randomX, randomY, randomZ));
  }

  var group = new THREE.Object3D();
  var material = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: false});
  points.forEach(function (point) {
    var geom = new THREE.SphereGeometry(0.2);
    var mesh = new THREE.Mesh(geom, material);
    mesh.position.clone(point);
    group.add(mesh);
  });

  // add the points as a group to the scene
  scene.add(group);
}</pre></div><p>As you can <a id="id569" class="indexterm"/>see in this snippet of code, we create 20 random points (<code class="literal">THREE.Vector3</code>), which we push into an array. Next, we iterate this array and create <code class="literal">THREE.SphereGeometry</code>, whose position we set to one of these points (<code class="literal">position.clone(point)</code>). All the points are added to a group (more on this in <a class="link" href="ch07.html" title="Chapter 7. Particles, Sprites, and the Point Cloud">Chapter 7</a>, <em>Particles, Sprites, and the Point Cloud</em>), so we can rotate them easily by just rotating the group.</p><p>Once you have this set of points, creating <code class="literal">THREE.ConvexGeometry</code> is very easy, as shown in the following code snippet:</p><div><pre class="programlisting">// use the same points to create a convexgeometry
var convexGeometry = new THREE.ConvexGeometry(points);
convexMesh = createMesh(convexGeometry);
scene.add(convexMesh);</pre></div><p>An array containing vertices (of the <code class="literal">THREE.Vector3</code> type) is the only argument <code class="literal">THREE.ConvexGeometry</code> takes. Here's one final note on the <code class="literal">createMesh()</code> function (which is a function we created ourselves in <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>) we call here. In the previous chapter, we used this method to create a mesh using <code class="literal">THREE.MeshNormalMaterial</code>. For this example, we changed this to a translucent green <code class="literal">THREE.MeshBasicMaterial</code> to better show the convex hull we created and the individual points that make up this geometry.</p><p>The next complex geometry is <code class="literal">THREE.LatheGeometry</code>, which can be used to create vase-like shapes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>THREE.LatheGeometry</h1></div></div></div><p>
<code class="literal">THREE.LatheGeometry</code> <a id="id570" class="indexterm"/>allows you to create shapes from a smooth curve. This curve is defined by a number of points (also called knots) and is most often called a spline. This spline is rotated around the central <em>z</em> axis of the object and results in vase-like and bell-like shapes. Once again, the easiest way to understand what <code class="literal">THREE.LatheGeometry</code> looks like is by looking at an example. This geometry is shown in <code class="literal">02-advanced-3d-geometries-lathe.html</code>. The following screenshot taken from the example shows this geometry:</p><div><img src="img/2215OS_06_02.jpg" alt="THREE.LatheGeometry"/></div><p>In the preceding screenshot, you can see the spline as the set of small red spheres. The positions of these spheres are passed in to <code class="literal">THREE.LatheGeometry</code>, together with a couple of other arguments. In this example, we rotate this spline for half a circle, and based on this spline, we extract the shape you can see. Before we look at all the arguments, let's look at the code used to create the spline and how <code class="literal">THREE.LatheGeometry</code> uses this spline:</p><div><pre class="programlisting">function generatePoints(segments, phiStart, phiLength) {
  // add 10 random spheres
  var points = [];
  var height = 5;
  var count = 30;
  for (var i = 0; i &lt; count; i++) {
    points.push(new THREE.Vector3((Math.sin(i * 0.2) + Math.cos(i * 0.3)) * height + 12, 0, ( i - count ) + count / 2));
  }

  ...

  // use the same points to create a LatheGeometry
  var latheGeometry = new THREE.LatheGeometry (points, segments, phiStart, phiLength);
  latheMesh = createMesh(latheGeometry);
  scene.add(latheMesh);
}</pre></div><p>In this piece<a id="id571" class="indexterm"/> of JavaScript, you can see that we generate 30 points whose <em>x</em> coordinate is based on a combination of sine and cosine functions while the <em>z</em> coordinate is based on the <code class="literal">i</code> and <code class="literal">count</code> variables. This creates the spline visualized by the red dots in the preceding screenshot.</p><p>Based on these points, we can create <code class="literal">THREE.LatheGeometry</code>. Besides the array of vertices, <code class="literal">THREE.LatheGeometry</code> takes a couple of other arguments. The following table lists all the arguments:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Mandatory</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">points</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>These <a id="id572" class="indexterm"/>are the points that make up the spline used to generate the bell/vase shape.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">segments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>These <a id="id573" class="indexterm"/>are the number of segments used when creating the shape. The higher this number, the more <em>round</em> the resulting shape will be. The default value for this is <code class="literal">12</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">phiStart</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id574" class="indexterm"/> determines where to start on a circle when generating the shape. This can range from <code class="literal">0</code> to <code class="literal">2*PI</code>. The default value is <code class="literal">0</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">phiLength</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id575" class="indexterm"/>defines how fully generated the shape is. For instance, a quarter shape will be <code class="literal">0.5*PI</code>. The default value is the full <code class="literal">360</code> degrees or <code class="literal">2*PI</code>.</p>
</td></tr></tbody></table></div><p>In the next section, we'll look at an alternative way of creating geometries by extracting a 3D geometry from a 2D shape.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Creating a geometry by extruding</h2></div></div></div><p>Three.js <a id="id576" class="indexterm"/>provides a couple of ways in which we can extrude a 2D shape to a 3D shape. By extruding, we mean stretching out a 2D shape along its <em>z</em> axis to convert it to 3D. For instance, if we extrude <code class="literal">THREE.CircleGeometry</code>, we get a shape that looks like a cylinder, and if we extrude <code class="literal">THREE.PlaneGeometry</code>, we get a cube-like shape.</p><p>The most versatile way of extruding a shape is using the <code class="literal">THREE.ExtrudeGeometry</code> object.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec16"/>THREE.ExtrudeGeometry</h3></div></div></div><p>With<a id="id577" class="indexterm"/> <code class="literal">THREE.ExtrudeGeometry</code>, you <a id="id578" class="indexterm"/>can create a 3D object from a 2D shape. Before we dive into the details of this geometry, let's first look at an example: <code class="literal">03-extrude-geometry.html</code>. The following screenshot taken from the example shows this geometry:</p><div><img src="img/2215OS_06_03.jpg" alt="THREE.ExtrudeGeometry"/></div><p>In this example, we took the 2D shape we created in the previous chapter and used <code class="literal">THREE.ExtrudeGeometry</code> to<a id="id579" class="indexterm"/> convert it to 3D. As you can see in this screenshot, the shape is extruded along the <em>z</em> axis, which results in a 3D shape. The code to create <code class="literal">THREE.ExtrudeGeometry</code> is very easy:</p><div><pre class="programlisting">var options = {
  amount: 10,
  bevelThickness: 2,
  bevelSize: 1,
  bevelSegments: 3,
  bevelEnabled: true,
  curveSegments: 12,
  steps: 1
};

shape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options));</pre></div><p>In this <a id="id580" class="indexterm"/>code, we created the shape with the <code class="literal">drawShape()</code> function just as we did in the previous chapter. This shape is passed on to the <code class="literal">THREE.ExtrudeGeometry</code> constructor together with an <code class="literal">options</code> object. With the <code class="literal">options</code> object, you can define exactly how the shape should be extruded. The following table explains the options you can pass in to <code class="literal">THREE.ExtrudeGeometry</code>.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Mandatory</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">shapes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>One<a id="id581" class="indexterm"/> or more shapes (<code class="literal">THREE.Shape</code> objects) are required to extrude the geometry from. See the preceding chapter on how to create such a shape.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">amount</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id582" class="indexterm"/>determines how far (the depth) the shape should be extruded. The default value is <code class="literal">100</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelThickness</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id583" class="indexterm"/> determines the depth of the bevel. The bevel is the rounded corner between the front and back faces and the extrusion. This value defines how deep into the shape the bevel goes. The default value is <code class="literal">6</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelSize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id584" class="indexterm"/>determines the height of the bevel. This is added to the normal height of the shape. The default value is <code class="literal">bevelThickness - 2</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelSegments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id585" class="indexterm"/> defines the number of segments that will be used by the bevel. The more the number of segments used, the smoother the bevel will look. The default value is <code class="literal">3</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelEnabled</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>If<a id="id586" class="indexterm"/> this is set to <code class="literal">true</code>, a bevel is added. The default value is <code class="literal">true</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">curveSegments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id587" class="indexterm"/> determines how many segments will be used when extruding the curves of shapes. The more the number of segments used, the smoother the curves will look. The default value is <code class="literal">12</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">steps</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id588" class="indexterm"/>defines the number of segments into the extrusion will be divided along its depth. The default value is <code class="literal">1</code>. A higher value will result in more individual faces.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">extrudePath</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id589" class="indexterm"/> the path (<code class="literal">THREE.CurvePath</code>) along which the shape should be extruded. If this isn't specified, the shape is extruded along the <em>z</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">material</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id590" class="indexterm"/> is the index of the material to use for the front and the back faces. Use the <code class="literal">THREE.SceneUtils.createMultiMaterialObject</code> function to create the mesh if you want separate materials for the front and back faces.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">extrudeMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id591" class="indexterm"/> is the index of the materials to use for the bevel and the extrusion. Use the <code class="literal">THREE.SceneUtils.createMultiMaterialObject</code> function to create the mesh if you want separate materials for the front and back faces.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uvGenerator</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>When <a id="id592" class="indexterm"/>you use a texture with your material, the UV mapping determines what part of a texture is used for a specific face. With the <code class="literal">uvGenerator</code> property, you can pass in your own object that will create the UV settings for the faces that are created for the shapes that are passed in. More information on UV settings can be found in <a class="link" href="ch10.html" title="Chapter 10. Loading and Working with Textures">Chapter 10</a>, <em>Loading and Working with Textures</em>. If none are specified, <code class="literal">THREE.ExtrudeGeometry.WorldUVGenerator</code> is used.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">frames</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>A <a id="id593" class="indexterm"/>frenet frame is used to calculate the tangents, normal, and binormals of a spline. This is used when extruding along <code class="literal">extrudePath</code>. You don't need to specify this since Three.js provides its own implementation, <code class="literal">THREE.TubeGeometry.FrenetFrames</code>, which is also used as default. More information on frenet frames can be found at <a class="ulink" href="http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame">http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame</a>.</p>
</td></tr></tbody></table></div><p>You can experiment with these options using the menu from the <code class="literal">03-extrude-geometry.html</code> example.</p><p>In this example, we extruded the shape along its <em>z</em> axis. As you would have seen in the options, you can also extrude a shape along a path with the <code class="literal">extrudePath</code> option. In the following geometry, <code class="literal">THREE.TubeGeometry</code>, we'll do just that.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec17"/>THREE.TubeGeometry</h3></div></div></div><p>
<code class="literal">THREE.TubeGeometry</code> <a id="id594" class="indexterm"/>creates a tube that <a id="id595" class="indexterm"/>extrudes along a 3D spline. You specify the path using a number of vertices, and <code class="literal">THREE.TubeGeometry</code> will create the tube. An example which you can experiment with can be found in the sources for this chapter (<code class="literal">04-extrude-tube.html</code>). The following screenshot shows this example:</p><div><img src="img/2215OS_06_04.jpg" alt="THREE.TubeGeometry"/></div><p>As you can <a id="id596" class="indexterm"/>see in this example, we generate a number of random points and use those points to draw the tube. With the controls in the upper-right corner, we can define how the tube looks or generate a new tube by clicking on the <strong>newPoints</strong> button. The code needed to create a tube is very simple, as follows:</p><div><pre class="programlisting">var points = [];
for (var i = 0 ; i &lt; controls.numberOfPoints ; i++) {
  var randomX = -20 + Math.round(Math.random() * 50);
  var randomY = -15 + Math.round(Math.random() * 40);
  var randomZ = -20 + Math.round(Math.random() * 40);

  points.push(new THREE.Vector3(randomX, randomY, randomZ));
}

var tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), segments, radius, radiusSegments, closed);

var tubeMesh = createMesh(tubeGeometry);
scene.add(tubeMesh);</pre></div><p>What we<a id="id597" class="indexterm"/> need to do first is get a set of vertices of the <code class="literal">THREE.Vector3</code> type just like we did for <code class="literal">THREE.ConvexGeometry</code> and <code class="literal">THREE.LatheGeometry</code>. Before we can use these points, however, to create the<a id="id598" class="indexterm"/> tube, we first need to convert these points to <code class="literal">THREE.SplineCurve3</code>. In other words, we need to define a smooth curve through the points we defined. We can do this simply by passing in the array of vertices to the constructor of <code class="literal">THREE.SplineCurve3</code>. With this spline and the other arguments (which we'll explain in a bit), we can create the tube and add it to the scene.</p><p>
<code class="literal">THREE.TubeGeometry</code> takes some other arguments besides <code class="literal">THREE.SplineCurve3</code>. The following table lists all the arguments for <code class="literal">THREE.TubeGeometry</code>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Mandatory</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">path</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id599" class="indexterm"/> is <code class="literal">THREE.SplineCurve3</code> that describes the path this tube should follow.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">segments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>These<a id="id600" class="indexterm"/> are the segments used to build up the tube. The default value is <code class="literal">64</code>. The longer the path, the more segments you should specify.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">radius</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id601" class="indexterm"/> is the radius of the tube. The default value is <code class="literal">1</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">radiusSegments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id602" class="indexterm"/> is the number of segments to be used along the length of the tube. The default value is <code class="literal">8</code>. The more you use, the more <em>round</em> the tube will look.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">closed</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>If this<a id="id603" class="indexterm"/> is set to <code class="literal">true</code>, the start of the tube and the end will be connected together. The default value is <code class="literal">false</code>.</p>
</td></tr></tbody></table></div><p>The last extrude example we'll show in this chapter isn't really a different geometry. In the next section, we'll show you how you can use <code class="literal">THREE.ExtrudeGeometry</code> to create extrusions from existing SVG paths.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec18"/>Extrude from SVG</h3></div></div></div><p>When we<a id="id604" class="indexterm"/> discussed <code class="literal">THREE.ShapeGeometry</code>, we mentioned that SVG follows pretty much the <a id="id605" class="indexterm"/>same approach of drawing shapes. SVG<a id="id606" class="indexterm"/> has a very close match with how Three.js handles shapes. In this section, we'll look at how you can use a small library from <a class="ulink" href="https://github.com/asutherland/d3-threeD">https://github.com/asutherland/d3-threeD</a> to convert SVG paths to a Three.js shape.</p><p>For the <code class="literal">05-extrude-svg.html</code> example, I've taken an SVG drawing of the Batman logo and used <code class="literal">ExtrudeGeometry</code> to convert it to 3D, as shown in the following screenshot:</p><div><img src="img/2215OS_06_05.jpg" alt="Extrude from SVG"/></div><p>First, let's<a id="id607" class="indexterm"/> look at<a id="id608" class="indexterm"/> what the original SVG code looks like (you can also see this for yourself when looking at the source code for this example):</p><div><pre class="programlisting">&lt;svg version="1.0"   x="0px" y="0px" width="1152px" height="1152px" xml:space="preserve"&gt;
  &lt;g&gt;
  &lt;path  id="batman-path" style="fill:rgb(0,0,0);" d="M 261.135 114.535 C 254.906 116.662 247.491 118.825 244.659 119.344 C 229.433 122.131 177.907 142.565 151.973 156.101 C 111.417 177.269 78.9808 203.399 49.2992 238.815 C 41.0479 248.66 26.5057 277.248 21.0148 294.418 C 14.873 313.624 15.3588 357.341 21.9304 376.806 C 29.244 398.469 39.6107 416.935 52.0865 430.524 C 58.2431 437.23 63.3085 443.321 63.3431 444.06 ... 261.135 114.535 "/&gt;
  &lt;/g&gt;
&lt;/svg&gt;</pre></div><p>Unless you're an SVG guru, this will probably mean nothing to you. Basically though, what you see here are a set of drawing instructions. For instance, <code class="literal">C 277.987 119.348 279.673 116.786 279.673 115.867</code> tells the browser to draw a cubic Bezier curve, and <code class="literal">L 489.242 111.787</code> tells us that we should draw a line to that specific position. Luckily though, we won't <a id="id609" class="indexterm"/>have to write the code to interpret this <a id="id610" class="indexterm"/>ourselves. With the d3-threeD library, we can convert this automatically. This library was originally created to be used together with the excellent <a id="id611" class="indexterm"/>
<strong>D3.js</strong> library, but with some small adaptions, we can also use this specific functionality standalone.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>
<strong>SVG</strong> stands for <strong>Scalable Vector Graphics</strong>. This is an XML-based standard that can be used to create vector-based 2D images for the Web. This is an open standard that is supported by all of the modern browsers. Directly working with SVG and manipulating it from JavaScript, however, isn't very straightforward. Luckily, there are a couple of open source JavaScript libraries <a id="id612" class="indexterm"/>that<a id="id613" class="indexterm"/> make working with SVG a lot easier. <strong>Paper.js</strong>, <strong>Snap.js</strong>, <strong>D3.js</strong>, and <a id="id614" class="indexterm"/>
<strong>Raphael.js</strong> are some of the best.</p></div></div><p>The following code fragment shows how we can load in the SVG you saw earlier, convert it to <code class="literal">THREE.ExtrudeGeometry</code>, and show it on screen:</p><div><pre class="programlisting">function drawShape() {
  var svgString = document.querySelector("#batman-path").getAttribute("d");
  var shape = transformSVGPathExposed(svgString);
  return shape;
}

var options = {
  amount: 10,
  bevelThickness: 2,
  bevelSize: 1,
  bevelSegments: 3,
  bevelEnabled: true,
  curveSegments: 12,
  steps: 1
};

shape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options));</pre></div><p>In this code fragment, you'll see a call to the <code class="literal">transformSVGPathExposed</code> function. This function is provided by the d3-threeD library and takes an SVG string as an argument. We get this SVG string directly from the SVG element with the following expression: <code class="literal">document.querySelector("#batman-path").getAttribute("d")</code>. In SVG, the <code class="literal">d</code> attribute contains the path statements used to draw a shape. Add a nice-looking shiny material and a <a id="id615" class="indexterm"/>spotlight and you've recreated this example.</p><p>The last <a id="id616" class="indexterm"/>geometry we'll discuss in this section is <code class="literal">THREE.ParametricGeometry</code>. With this geometry, you can specify a couple of functions that are used to programmatically create geometries.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec19"/>THREE.ParametricGeometry</h3></div></div></div><p>With <a id="id617" class="indexterm"/>
<code class="literal">THREE.ParametricGeometry</code>, you<a id="id618" class="indexterm"/> can create a geometry based on an equation. Before we dive into our own example, a good thing to start with is to look at the examples already provided by Three.js. When you download the Three.js distribution, you get the <code class="literal">examples/js/ParametricGeometries.js</code> file. In this file, you can find a couple of examples of equations you can use together with <code class="literal">THREE.ParametricGeometry</code>. The most basic example is the function to create a plane:</p><div><pre class="programlisting">function plane(u, v) {	
  var x = u * width;
  var y = 0;
  var z = v * depth;
  return new THREE.Vector3(x, y, z);
}</pre></div><p>This function is called by <code class="literal">THREE.ParametricGeometry</code>. The <code class="literal">u</code> and <code class="literal">v</code> values will range from <code class="literal">0</code> to <code class="literal">1</code> and will be called a large number of times for all the values from <code class="literal">0</code> to <code class="literal">1</code>. In this example, the <code class="literal">u</code> value is used to determine the <em>x</em> coordinate of the vector and the <code class="literal">v</code> value is used to determine the <em>z</em> coordinate. When this is run, you'll have a basic plane with a width of <code class="literal">width</code> and a depth of <code class="literal">depth</code>.</p><p>In our example, we do something similar. However, instead of creating a flat plane, we create a wave-like pattern, as you can see in the <code class="literal">06-parametric-geometries.html</code> example. The following screenshot shows this example:</p><div><img src="img/2215OS_06_06.jpg" alt="THREE.ParametricGeometry"/></div><p>To create <a id="id619" class="indexterm"/>this shape, we passed in the following function to <code class="literal">THREE.ParametricGeometry</code>:</p><div><pre class="programlisting">radialWave = function (u, v) {
  var r = 50;

  var x = Math.sin(u) * r;
  var z = Math.sin(v / 2) * 2 * r;
  var y = (Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 * Math.PI)) * 2.8;

  return new THREE.Vector3(x, y, z);
}

var mesh = createMesh(new THREE.ParametricGeometry(radialWave, 120, 120, false));</pre></div><p>As you can see in this example, with a few lines of code, we can create really interesting geometries. In this example, you can also see the arguments we can pass in to <code class="literal">THREE.ParametricGeometry</code>. These are explained in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Mandatory</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">function</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>This is the<a id="id620" class="indexterm"/> function that defines the position of each vertex based on the <code class="literal">u</code> and <code class="literal">v</code> values provided</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">slices</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>This defines <a id="id621" class="indexterm"/>the number of parts the <code class="literal">u</code> value should be divided into</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">stacks</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id622" class="indexterm"/>defines the number of parts the <code class="literal">v</code> value should be divided into</p>
</td></tr></tbody></table></div><p>I'd like to make a final note on how to use the <code class="literal">slices</code> and <code class="literal">stacks</code> properties before moving on to the final part of this chapter. We mentioned that the <code class="literal">u</code> and <code class="literal">v</code> properties are passed in to the <code class="literal">function</code> argument provided, and that the values of these two properties range from <code class="literal">0</code> to <code class="literal">1</code>. With the <code class="literal">slices</code> and <code class="literal">stacks</code> properties, we can define how often the passed-in function is called. If, for instance, we set <code class="literal">slices</code> to <code class="literal">5</code> and <code class="literal">stacks</code> to <code class="literal">4</code>, the function will be called with the following values:</p><div><pre class="programlisting">u:0/5, v:0/4
u:1/5, v:0/4
u:2/5, v:0/4
u:3/5, v:0/4
u:4/5, v:0/4
u:5/5, v:0/4
u:0/5, v:1/4
u:1/5, v:1/4
...
u:5/5, v:3/4
u:5/5, v:4/4</pre></div><p>So, the higher this value, the more vertices you get to specify and the smoother your created geometry will be. You can use the menu in the top-right corner of the <code class="literal">06-parametric-geometries.html</code> example to see this effect.</p><p>For more examples, you can look at the <code class="literal">examples/js/ParametricGeometries.js</code> file in the Three.js distribution. This file contains functions to create the following geometries:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Klein bottle</li><li class="listitem" style="list-style-type: disc">Plane</li><li class="listitem" style="list-style-type: disc">Flat mobius strip</li><li class="listitem" style="list-style-type: disc">3d mobius strip</li><li class="listitem" style="list-style-type: disc">Tube</li><li class="listitem" style="list-style-type: disc">Torus knot</li><li class="listitem" style="list-style-type: disc">Sphere</li></ul></div><p>The last part of this chapter deals with creating 3D text objects.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Creating 3D text</h1></div></div></div><p>In the <a id="id623" class="indexterm"/>last part of this chapter, we'll have a quick look at how you can create 3D text effects. First, we'll look at how to render text using the fonts provided by Three.js, and after that, we'll have a quick look at how you can use your own fonts for this.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Rendering text</h2></div></div></div><p>Rendering text <a id="id624" class="indexterm"/>in Three.js is very easy. All you have to do is define the font you want to use and the basic extrude properties we saw when we discussed <code class="literal">THREE.ExtrudeGeometry</code>. The following screenshot shows the <code class="literal">07-text-geometry.html</code> example on how to render text in Three.js:</p><div><img src="img/2215OS_06_07.jpg" alt="Rendering text"/></div><p>The code required<a id="id625" class="indexterm"/> to create this 3D text is as follows:</p><div><pre class="programlisting">var options = {
  size: 90,
  height: 90,
  weight: 'normal',
  font: 'helvetiker',
  style: 'normal',
  bevelThickness: 2,
  bevelSize: 4,
  bevelSegments: 3,
  bevelEnabled: true,
  curveSegments: 12,
  steps: 1
};

// the createMesh is the same function we saw earlier
text1 = createMesh(new THREE.TextGeometry("Learning", options));
text1.position.z = -100;
text1.position.y = 100;
scene.add(text1);

text2 = createMesh(new THREE.TextGeometry("Three.js", options));
scene.add(text2);
};</pre></div><p>Let's look at all the options we can specify for <code class="literal">THREE.TextGeometry</code>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Mandatory</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id626" class="indexterm"/>is the size of the text. The default value is <code class="literal">100</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">height</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id627" class="indexterm"/>the length (depth) of the extrusion. The default value is <code class="literal">50</code>. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">weight</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This is the<a id="id628" class="indexterm"/> weight of the font. The possible values are <code class="literal">normal</code> and <code class="literal">bold</code>. The default value is <code class="literal">normal</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">font</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id629" class="indexterm"/> is the name of the font to be used. The default value is <code class="literal">helvetiker</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">style</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id630" class="indexterm"/> is the weight of the font. The possible values are <code class="literal">normal</code> and <code class="literal">italic</code>. The default value is <code class="literal">normal</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelThickness</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id631" class="indexterm"/> is the depth of the bevel. The bevel is the rounded corner between the front and back faces and the extrusion. The default value is <code class="literal">10</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelSize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id632" class="indexterm"/> is the height of the bevel. The default value is <code class="literal">8</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelSegments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id633" class="indexterm"/>defines the number of segments that will be used by the bevel. The more segments there are, the smoother the bevel will look. The default value is <code class="literal">3</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bevelEnabled</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>If <a id="id634" class="indexterm"/>this is set to <code class="literal">true</code>, a bevel is added. The default value is <code class="literal">false</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">curveSegments</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id635" class="indexterm"/>defines the number segments used when extruding the curves of shapes. The more segments there are, the smoother the curves will look. The default value is <code class="literal">4</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">steps</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id636" class="indexterm"/>defines the number of segments the extrusion will be divided into. The default value is <code class="literal">1</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">extrudePath</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id637" class="indexterm"/> is the path along which the shape should be extruded. If this isn't specified, the shape is extruded along the <em>z</em> axis. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">material</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id638" class="indexterm"/> is the index of the material to be used for the front and back faces. Use the <code class="literal">THREE.SceneUtils.createMultiMaterialObject</code> function to create the mesh.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">extrudeMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id639" class="indexterm"/> is the index of the material to be used for the bevel and the extrusion. Use the <code class="literal">THREE.SceneUtils.createMultiMaterialObject</code> function to create the mesh.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uvGenerator</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>When <a id="id640" class="indexterm"/>you use a texture with your material, the UV mapping determines what part of a texture is used for a specific face. With the <code class="literal">UVGenerator</code> property, you can pass in your own object that will create the UV settings for the faces that are created for the passed-in shapes. More information on UV settings can be found in <a class="link" href="ch10.html" title="Chapter 10. Loading and Working with Textures">Chapter 10</a>, <em>Loading and Working with Textures</em>. If none are specified, <code class="literal">THREE.ExtrudeGeometry.WorldUVGenerator</code> is used.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">frames</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>A<a id="id641" class="indexterm"/> frenet frame is used to calculate the tangents, normal, and binormals of a spline. This is used when extruding along <code class="literal">extrudePath</code>. You don't need to specify this because Three.js provides its own implementation, <code class="literal">THREE.TubeGeometry.FrenetFrames</code>, which is also used as default. More information on frenet frames can be found at <a class="ulink" href="http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame">http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame</a>.</p>
</td></tr></tbody></table></div><p>The fonts that are included in Three.js are also added to the sources for this book. You can find them in the <code class="literal">assets/fonts</code> folder.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>If you want to render fonts in 2D, for instance, to use them as a texture for a material, you shouldn't use <code class="literal">THREE.TextGeometry</code>. <code class="literal">THREE.TextGeometry</code>, which internally uses <code class="literal">THREE.ExtrudeGeometry</code> to build the 3D text, and the JavaScript fonts introduce a lot of overhead. Rendering a simple 2D font is better than just using the HTML5 canvas. With <code class="literal">context.font</code>, you can set the font to be used, and with <code class="literal">context.fillText</code>, you can output text to the canvas. You can then use this canvas as input for your texture. We will show you how to do this in <a class="link" href="ch10.html" title="Chapter 10. Loading and Working with Textures">Chapter 10</a>, <em>Loading and Working with Textures</em>.</p></div></div><p>It's also possible to<a id="id642" class="indexterm"/> use other fonts with this geometry, but you first need to convert them to JavaScript. How to do this is shown in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Adding custom fonts</h2></div></div></div><p>There are a <a id="id643" class="indexterm"/>couple of fonts provided by Three.js that you can use in your scenes. These fonts are based<a id="id644" class="indexterm"/> on the fonts provided by <strong>typeface.js</strong> (<a class="ulink" href="http://typeface.neocracy.org:81/">http://typeface.neocracy.org:81/</a>). Typeface.js <a id="id645" class="indexterm"/>is a library that can convert TrueType and OpenType fonts to JavaScript. The resulting JavaScript file can be included in your page, and the font can then be used in Three.js.</p><p>To convert an existing OpenType or TrueType font, you can use the web page at <a class="ulink" href="http://typeface.neocracy.org:81/fonts.html">http://typeface.neocracy.org:81/fonts.html</a>. On this page, you can upload a font, and it will be converted to JavaScript for you. Note that this doesn't work for all types of fonts. The simpler the font (more straight lines), the better the chance is that it will be rendered correctly when used in Three.js.</p><p>To include that font, just add the following line at the top of your HTML page:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/bitstream_vera_sans_mono_roman.typeface.js"&gt;
&lt;/script&gt;</pre></div><p>This will load the font and make it available to Three.js. If you want to know the name of the font (to use with the <code class="literal">font</code> property), you can print out the font cache to the console using the following line of JavaScript:</p><div><pre class="programlisting">console.log(THREE.FontUtils.faces);</pre></div><p>This will print out something like the following:</p><div><img src="img/2215OS_06_08.jpg" alt="Adding custom fonts"/></div><p>Here, you <a id="id646" class="indexterm"/>can see that we can use the <code class="literal">helvetiker</code> font with <code class="literal">weight</code> as<code class="literal"> either bold</code> or <code class="literal">normal</code>, and the <code class="literal">bitstream vera sans mono</code> font with <code class="literal">weight</code> as <code class="literal">normal</code>. Note that each font weight comes in its separate JavaScript file and needs to be loaded separately. An alternative way of determining the font name is by looking at the JavaScript source file for the font. At the end of the file, you'll find a property with the name <code class="literal">familyName</code> as shown in the following code. This property also contains the name of the font:</p><div><pre class="programlisting">"familyName":"Bitstream Vera Sans Mono"</pre></div><p>In the next part of this chapter, we'll introduce the ThreeBSP library to create very interesting-looking geometries using the binary operations: <code class="literal">intersect</code>, <code class="literal">subtract</code>, and <code class="literal">union</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Using binary operations to combine meshes</h1></div></div></div><p>In this section, we'll look at a <a id="id647" class="indexterm"/>different way of creating geometries. In this chapter, so far, and in the previous chapter, we used the <a id="id648" class="indexterm"/>default geometries provided by Three.js to create interesting-looking geometries. With the default set of properties, you can create beautiful models, but you are limited to what Three.js provides. In this section, we'll show you how you can combine these standard geometries to create new ones—a technique known as<a id="id649" class="indexterm"/> <strong>Constructive Solid Geometry</strong> (<strong>CSG</strong>) To do this, we use the Three.js extension <a id="id650" class="indexterm"/>ThreeBSP, which you can find online at <a class="ulink" href="https://github.com/skalnik/ThreeBSP">https://github.com/skalnik/ThreeBSP</a>. This <a id="id651" class="indexterm"/>additional library provides the following three functions:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">intersect</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id652" class="indexterm"/>function allows you to create a <a id="id653" class="indexterm"/>new geometry based on the intersection of two existing geometries. The area where both geometries overlap will define the shape of this new geometry.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">union</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<a id="id654" class="indexterm"/> union function<a id="id655" class="indexterm"/> can be used to combine two geometries and create a new one. You can compare this with the <code class="literal">mergeGeometry</code> functionality we'll look at in <a class="link" href="ch08.html" title="Chapter 8. Creating and Loading Advanced Meshes and Geometries">Chapter 8</a>, <em>Creating and Loading Advanced Meshes and Geometries</em>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">subtract</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id656" class="indexterm"/>subtract function is the opposite<a id="id657" class="indexterm"/> of the union function. You can create a new geometry by removing the overlapping area from the first geometry. </p>
</td></tr></tbody></table></div><p>In the following sections, we'll look at each of these functions in more detail. The following screenshot shows an example of what you can create by just using the <code class="literal">union</code> and <code class="literal">subtract</code> functionalities one after the other.</p><div><img src="img/2215OS_06_09.jpg" alt="Using binary operations to combine meshes"/></div><p>To use this library, we need to include it in our page. This library is written in CoffeeScript, a more user-friendly variant of JavaScript. To get this working, we have two options. We can add the CoffeeScript file and compile it on the fly, or we can precompile it to JavaScript and include it directly. For the first approach, we need to do the following:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/coffee-script.js"&gt;&lt;/script&gt;
&lt;script type="text/coffeescript" src="img/ThreeBSP.coffee"&gt;&lt;/script&gt;</pre></div><p>The <code class="literal">ThreeBSP.coffee</code> file contains the functionality we need for this example, and <code class="literal">coffee-script.js</code> can interpret the Coffee language used for ThreeBSP. A final step we need to take is make sure the <code class="literal">ThreeBSP.coffee</code> file has been parsed completely before we start using the ThreeBSP functionality. For this, we add the following to the bottom of the file:</p><div><pre class="programlisting">&lt;script type="text/coffeescript"&gt;
  onReady();
&lt;/script&gt;</pre></div><p>We rename our initial <code class="literal">onload</code> function to <code class="literal">onReady</code> like this:</p><div><pre class="programlisting">function onReady() {
  // Three.js code
}</pre></div><p>If we precompile CoffeeScript to JavaScript using the CoffeeScript command-line tool, we can include the resulting JavaScript file directly. Before we can do this, though, we need to install CoffeeScript. You can follow the installation instructions on the CoffeeScript <a id="id658" class="indexterm"/>website at <a class="ulink" href="http://coffeescript.org/">http://coffeescript.org/</a>. Once you've installed CoffeeScript, you can use the following command line to convert the CoffeeScript ThreeBSP file to JavaScript:</p><div><pre class="programlisting">coffee --compile ThreeBSP.coffee</pre></div><p>This command creates a <code class="literal">ThreeBSP.js</code> file that we can include in our example just as we do with the other JavaScript file. In our examples, we use this second approach because it'll load quicker than compiling the CoffeeScript each time we load the page. For this, all we need to do is add the following to the top of our HTML page:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/ThreeBSP.js"&gt;&lt;/script&gt;</pre></div><p>Now that the ThreeBSP library is loaded, we can use the functions it provides.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec46"/>The subtract function</h2></div></div></div><p>Before<a id="id659" class="indexterm"/> we <a id="id660" class="indexterm"/>start with the <code class="literal">subtract</code> function, there is one important step you need to keep in mind. These three functions use the absolute position of the mesh for calculations. So, if you group meshes <a id="id661" class="indexterm"/>together or use multiple materials before applying these functions, you'll probably get strange results. For the best and most predictable result, make sure you're working with ungrouped meshes.</p><p>Let's start by demonstrating the <code class="literal">subtract</code> functionality. For this, we've provided an example, <code class="literal">08-binary-operations.html</code>. With this example, you can experiment with the three operations. When you first open the example on binary operations, you'll see something like the following start screen:</p><div><img src="img/2215OS_06_10.jpg" alt="The subtract function"/></div><p>There are three wireframes: a cube and two spheres. <strong>Sphere1</strong>, the center sphere, is the object on which all operations are executed, <strong>Sphere2</strong> is on the right-hand side, and <strong>Cube</strong> is on the left-hand side. On <strong>Sphere2</strong> and <strong>Cube</strong>, you can define one of four actions: <strong>subtract</strong>, <strong>union</strong>, <strong>intersect</strong>, and <strong>none</strong>. These actions are applied from the point of view of <strong>Sphere1</strong>. When we set <strong>Sphere2</strong> to subtract and select <strong>showResult</strong> (and hide the wireframes), the result will show <strong>Sphere1</strong> minus the area where <strong>Sphere1</strong> and <strong>Sphere2</strong> overlap. Note that a few of these operations might take a couple of seconds to complete after you've pushed the <strong>showResult</strong> button, so be patient while the <em>busy</em> indicator is visible.</p><p>The following screenshot shows the result action of a sphere after subtracting another sphere:</p><div><img src="img/2215OS_06_11.jpg" alt="The subtract function"/></div><p>In this <a id="id662" class="indexterm"/>example, first the action defined for <strong>Sphere2</strong> is executed, and next, the action for <strong>Cube</strong> is executed. So, if we subtract both <strong>Sphere2</strong> and <strong>Cube</strong> (which we scale a bit along the <em>x</em> axis), we get the following result:</p><div><img src="img/2215OS_06_12.jpg" alt="The subtract function"/></div><p>The best way to understand the <code class="literal">subtract</code> functionality is to just play around with the example. The ThreeBSP code to accomplish this is very simple and, in this example, is implemented <a id="id663" class="indexterm"/>in the <code class="literal">redrawResult</code> function, which we call whenever the <strong>showResult</strong> button from the example is clicked on:</p><div><pre class="programlisting">function redrawResult() {
  scene.remove(result);
  var sphere1BSP = new ThreeBSP(sphere1);
  var sphere2BSP = new ThreeBSP(sphere2);
  var cube2BSP = new ThreeBSP(cube);

  var resultBSP;

  // first do the sphere
  switch (controls.actionSphere) {
    case "subtract":
      resultBSP = sphere1BSP.subtract(sphere2BSP);
    break;
    case "intersect":
      resultBSP = sphere1BSP.intersect(sphere2BSP);
    break;
    case "union":
      resultBSP = sphere1BSP.union(sphere2BSP);
    break;
    case "none": // noop;
  }

  // next do the cube
  if (!resultBSP) resultBSP = sphere1BSP;
  switch (controls.actionCube) {
    case "subtract":
      resultBSP = resultBSP.subtract(cube2BSP);
    break;
    case "intersect":
      resultBSP = resultBSP.intersect(cube2BSP);
    break;
    case "union":
      resultBSP = resultBSP.union(cube2BSP);
    break;
    case "none": // noop;
  }


  if (controls.actionCube === "none" &amp;&amp; controls.actionSphere === "none") {
  // do nothing
  } else {
    result = resultBSP.toMesh();
    result.geometry.computeFaceNormals();
    result.geometry.computeVertexNormals();
    scene.add(result);
  }
}</pre></div><p>The first thing we <a id="id664" class="indexterm"/>do in this code is wrap our meshes (the wireframes you can see) in a <code class="literal">ThreeBSP</code> object. This allows us to apply the <code class="literal">subtract</code>, <code class="literal">intersect</code>, and <code class="literal">union</code> functions on these objects. Now, we can just call the specific function we want on the <code class="literal">ThreeBSP</code> object wrapped around the center sphere (<code class="literal">sphere1BSP</code>), and the result from this function will contain all the information we need to create a new mesh. To create this mesh, we just call the <code class="literal">toMesh()</code> function on the <code class="literal">sphere1BSP</code> object. On the resulting object, we have to make sure that all the normals are computed correctly by first calling <code class="literal">computeFaceNormals</code> and then calling <code class="literal">computeVertexNormals()</code>. These compute functions need to be called since by running one of the binary operations, the vertices and faces of the geometry are changed and this affects the normals of the faces. Explicitly recalculating them will make sure your new object is shaded smoothly (when shading on the material has been set to <code class="literal">THREE.SmoothShading</code>) and rendered correctly. Finally, we add the result to the scene.</p><p>For <code class="literal">intersect</code> and <code class="literal">union</code>, we use exactly the same approach.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec47"/>The intersect function</h2></div></div></div><p>With <a id="id665" class="indexterm"/>everything we explained <a id="id666" class="indexterm"/>in the previous section, there isn't much left to explain for the <code class="literal">intersect</code> function. With this function, only the part of the meshes that overlap is left. The following screenshot is an example where both the sphere and the cube are set to intersect:</p><div><img src="img/2215OS_06_13.jpg" alt="The intersect function"/></div><p>If you look <a id="id667" class="indexterm"/>at the example and play around with the settings, you'll<a id="id668" class="indexterm"/> see that it's very easy to create these kinds of objects. And remember, this can be applied to every mesh you can create, even the complex ones we saw in this chapter, such as <code class="literal">THREE.ParametricGeometry</code> and <code class="literal">THREE.TextGeometry</code>.</p><p>The <code class="literal">subtract</code> and <code class="literal">intersect</code> functions work great together. The example we showed at the beginning of this section was created by first subtracting a smaller sphere to create a hollow sphere. After that, we used the cube to intersect with this hollow sphere to get the following result (a hollow cube with rounded corners):</p><div><img src="img/2215OS_06_14.jpg" alt="The intersect function"/></div><p>The last function <a id="id669" class="indexterm"/>provided by ThreeBSP is the <code class="literal">union</code> function.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec48"/>The union function</h2></div></div></div><p>The <a id="id670" class="indexterm"/>final function is the least interesting one of those offered by ThreeBSP. With <a id="id671" class="indexterm"/>this function, we can combine two meshes together to create a new one. So, when we apply this to the two spheres and the cube, we'll get a single object—a result of the union function:</p><div><img src="img/2215OS_06_15.jpg" alt="The union function"/></div><p>This is not <a id="id672" class="indexterm"/>really that useful because this functionality is also provided <a id="id673" class="indexterm"/>by Three.js (see <a class="link" href="ch08.html" title="Chapter 8. Creating and Loading Advanced Meshes and Geometries">Chapter 8</a>, <em>Creating and Loading Advanced Meshes and Geometries</em>, where we explain how to use <code class="literal">THREE.Geometry.merge</code>), which also offers slightly better performance. If you enable rotation, you can see that this union is applied from the perspective of the center sphere since it is rotating around the center of that sphere. The same applies to the other two operations.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Summary</h1></div></div></div><p>We saw a lot in this chapter. We introduced a couple of advanced geometries and even showed you how you can create interesting-looking geometries using a couple of simple binary operations. We showed you how you can create really beautiful shapes using advanced geometries such as <code class="literal">THREE.ConvexGeometry</code>, <code class="literal">THREE.TubeGeometry</code>, and <code class="literal">THREE.LatheGeometry</code> and experiment with these geometries to get the results you're looking for. A very nice feature is that we can also convert existing SVG paths to Three.js. Remember, though, that you still might need to fine-tune the paths using tools such as GIMP, Adobe Illustrator, or Inkscape.</p><p>If you want to create 3D text, you need to specify the font to use. Three.js comes with a couple of fonts you can use, but you can also create your own fonts. However, remember that complex fonts often won't convert correctly. And finally, with ThreeBSP, you have access to three binary operations you can apply to your mesh: union, subtract, and intersect. With union, you combine two meshes together; with subtract, you remove the overlapping part of the meshes from the source mesh; and with intersect, only the overlapping part is kept.</p><p>Until now, we looked at solid (or wireframe) geometries, where vertices are connected to each other to form faces. In the following chapter, we'll look at an alternative way of visualizing geometries using something called particles. With particles, we don't render complete geometries—we just render the vertices as points in space. This allows you to create great-looking 3D effects that perform well.</p></div></body></html>