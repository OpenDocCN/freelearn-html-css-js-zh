- en: 'Chapter 9. Workbook: Using the Camera'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By far, the most common feature of mobile devices today is the camera. It is
    difficult to imagine a mobile device without one. A quality application needs
    to be able to take advantage of this feature and in this chapter, we will show
    you how it's done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will build a basic workbook application where you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Create notebooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add notes to each notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an image to each note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also use a tiled layout data view to spice up the appearance of the
    application, and talk about ways to send an image to another application such
    as WordPress or the Sencha.io storage system.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the basic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this application we will have "books" that contain "notes", which means
    we will only see a note when the user clicks on a specific book. In this case,
    a tabbed interface probably doesn't make much sense, so we will use a navigation
    view to move between our list of books and the list of notes for a particular
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to move beyond the traditional list and use a tiled view with
    some icons. This will give us something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the basic application](img/8901OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the user taps on one of the books, they will get a similar screen with
    the notes for that particular book. We will have an **Add** button for new books
    and an **Add** button for new notes. Since the navigation view uses the same title
    bar for both views, we will need to swap between the two **Add** buttons based
    on which view we are looking at.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need forms for our books and notes. The notes form will also need
    a button that allows us to either take a picture with the device camera, or select
    a photo from the device's photo library.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of data, we need a title and an ID for our books. Our notes will also
    have a title and an ID, and we will need fields for our notes, an image, and a
    book ID to tell us which book the note belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have a good idea of what data we need, let's start by setting up our
    models and stores.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models and stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our book is by far the simpler of the two pieces we need to deal with, so let''s
    start there. Our book model looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `bookstore.js` file is equally simple and uses a local storage proxy for
    storing our data. Since the list of books is the first thing the user will see,
    we also want this store to automatically load. So, in that case we will use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our notes need to be related to our books, so they will have an associated
    `bookID` as well as their own unique ID property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We also have fields for our title, `dateModified`, `notes`, and `image`. We
    will set `dateModified` to the current date when a new note is created and when
    an existing note is updated and saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `noteStore.js` file looks much the same as our book store, except we don''t
    want this one to load automatically so we set `autoLoad` to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know what kind of data we are dealing with, we need to think about
    how things will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our application views, we will need a list and edit views for our books.
    When the user clicks on a book, they will get the list of notes. We will also
    need a form for editing notes and a details view for the notes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the book views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the book views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first book view is our list of books. Rather than going with the simple
    list, we will use a DataView and icons to give our list a bit more visual appeal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the book views](img/8901OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This layout will be created using the xTemplate (`tpl`) and CSS styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We start our `booklist.js` file by extending the standard `Ext.dataview.DataView`
    and adding our configuration options. We set a title and allow for styled HTML
    content in the panel. We also set up scrolling and give it providing `directionLock`
    so it only scrolls in one direction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add some empty text that instructs the user how to add a book and finish
    up with our `itemTpl` and an `itemCls`. `itemTpl` and `itemCls` will be used to
    position each of our books within the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when the DataView is rendered as HTML, each item in our DataView
    is wrapped in a `div` tag with a CSS class of `.x-dataview-item`. It looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Potentially, we could just set styles on `.x-dataview-item`, but this would
    change the style for every DataView we use. By setting `itemCls`, the `div` tag
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we can now style the `bookItem` class without affecting the rest
    of our data views. We style the `bookItem` class by placing the following into
    our CSS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This style data determines our width for each item and tiles them across the
    screen from left to right. It also sets our margins and centers the text and our
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a view for adding our books using a `form` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This form has a container for instructions, a text field for the user to enter
    a name for the book, and a `hiddenfield` component where we will add the book's
    `id` value when we are editing an existing book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also going to add two buttons to the form; a **Save** button and a **Cancel**
    button. In this example, we will set handlers for each button inside the view
    itself. This code could also be moved into the controller if you prefer, and we
    will show you how to do it that way a bit later. For now, let''s add the **Save**
    button first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The basic setup for the `button` element should be pretty familiar to you now.
    The `handler` component will automatically fire when the button is tapped.
  prefs: []
  type: TYPE_NORMAL
- en: This function grabs our `store` and `form`, values, and the value from the `values`
    variable. We then check to see if the `id` value is a number greater than zero.
    The only way this will occur is if we have loaded an existing book record into
    our form for editing.
  prefs: []
  type: TYPE_NORMAL
- en: If the `id` value is greater than zero (we have an existing book), we grab the
    current `record` value from the store and replace its values with the new values
    from our form.
  prefs: []
  type: TYPE_NORMAL
- en: If the `id` value is null (it's a new book), we create a new record using our
    book model, insert the form's `values` variable and add the record to the store.
  prefs: []
  type: TYPE_NORMAL
- en: We then sync the store to save our changes and pop the book form off of our
    main `navigationview`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we add a **Cancel** button after our **Save** button. This one just
    needs to pop the form off of our `navigationview`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the views for adding and displaying books in our application,
    we need to create our `main.js` view that will launch when the application is
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the book list to the main view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our main view needs to display the list of books and it needs a button to show
    our add book form. As we noted previously, we will be using `navigationview` for
    this main component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This view is defined in `app.js` as the one that will be added to the viewport
    when the application launches. You will notice that we have required the `TitleBar`
    and `DataView` components in our `Main` component. This is to prevent compiling
    errors later on when we build our native application. The main `navigationview`
    component also includes our booklist component and an add button to show our form.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Code in the controller versus the view**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike our previous book's `form` view, we will place the function code for
    our "Add Book" button inside the controller. Placing the functionality of a view
    in the controller is generally considered a "best practice", but it is important
    to understand that this can be done in a number of different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our main view created, let's jump over to the `Book.js` controller
    and set things up to test what we have so far.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the book controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The book controller will start with our views, models, and stores that we have
    created. It will also set up our references, our initial controls, and two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our `book.js` controller file needs to push our `bookEdit` form onto the `Main`
    navigation view. We do this by creating a reference (`refs`) for the `addBookButton`
    component using its `id` property. We then assign a function to the button's `tap`
    event in our `controls` section.
  prefs: []
  type: TYPE_NORMAL
- en: The `onAddBookButtonTap` function creates a new instance of our `bookEdit` form
    and pushes it onto our `Main` navigation view. This will make the form appear
    and add a back button at the top of the page.
  prefs: []
  type: TYPE_NORMAL
- en: We also added `refs` and `controls` for the `bookList` form, including an `onBookSelect`
    function. However, we don't have any of our other views so we can't display a
    list of notes for the book. Instead, we have added a console log that will show
    the DataView, record, and options that are passed when a book in the list is tapped.
    Once we add a book, we should be able to tap on it and see the information displayed
    in the Safari Error console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `console.log()` function is a great way to test your application in the
    early stages of development. It can help you detect problems early on and deal
    with them before you build up the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the project now, you should get the initial empty book screen and
    be able to add new books:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the book controller](img/8901OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you add a book and then tap it in the book list, you should see something
    like the following screenshot in the Safari Error console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the book controller](img/8901OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From left to right, these objects are the DataView (our book list), the record
    (which book was tapped), and the options (the object that was passed to the listener—serious
    nerd stuff).
  prefs: []
  type: TYPE_NORMAL
- en: We will use the information in the record object later on to tell us which notes
    to display. Now we need to create the views for our notes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the note views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need three different views for our notes: a list view, an edit view, and
    a details view. We will start with our list view since it is similar to the one
    we use for books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We override the DataView, set up our IDs and our scrolling, just as we did with
    our book list. In the `itemTpl` configuration, we added the date the note was
    modified, using the `date()` function to change it to a shorter format than the
    default. We also set our empty text and a default title. Our book controller will
    update the title and display the book name for the current note.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the same basic styles as our book container to make the note
    list tile across the screen like our book list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the note views](img/8901OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user taps a note in the list, we need to display the note details
    with the text and the image for the note. Our `noteDetails.js` view is a simple
    panel with an xTemplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much about the `data:image/png;base64` section of this code.
    We will cover the base64 image format in the *Getting started with images* section
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The edit view for our note will have fields for a title and note text. There
    will also be hidden fields such as `bookID`, `image`, and the note's `id` field
    (the value of these will be set by our controller).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will also have a button for selecting an image and a container for displaying
    the selected image. When the button is tapped, we will select an image from the
    device that will be returned to us as a base64 string. This string will be set
    as the value for our hidden `image` field.
  prefs: []
  type: TYPE_NORMAL
- en: We will also have two buttons just like our book edit form, one for for the
    purpose of saving and one for canceling. The **Cancel** button is exactly the
    same as the previous one for the book edit and it just pops the form off of the
    navigation view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Save** button is a little different in that it needs to set a value for
    date modified whenever a note is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Other than that, the button is mostly the same as our book save button. We grab
    the store and the form values, we check to see if we are dealing with a new note
    or an existing note, and we save the note accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: With these basic views set up, it's time to get back into our controller and
    hook everything together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do in our controller is update our `config` section
    to add the new views, stores, and models for our application. We also need to
    add some new references and controls for these new components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `refs` section will set up our shortcuts for the new note components we
    created and the controls will add new functions for the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Tapping a note in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tapping the button to add an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a book in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a note in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking the back button from anywhere in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have `refs` and `control` in place, let's start creating the functions
    we will need for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onBookSelect` function is linked to the `select` event for the book list
    (in the `controls` section). The `select` event will automatically pass along
    the record that was selected as part of its arguments. We will use the book title
    from that record to set the `title` property of our new note list view. We will
    also use the `id` property from this record to limit the note''s `store` to just
    the notes for that book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we pass the `title` value as a configuration option when we create
    the new instance of the note list. This is often a handy way to set additional
    parameters when creating a new object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we push our new `noteList` object onto the `Main` navigation view, and
    swap our `AddBook` button with the `AddNote` button using `show`/`hide` functions.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `bookID` value to filter the store, limiting the notes to just
    the ones for our current book and load the store.
  prefs: []
  type: TYPE_NORMAL
- en: We also add `bookID` as a configuration option on `noteList`. This will let
    us easily grab `bookID` when we add new notes.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need to take care of is the **Back** button. This button is
    created automatically by the navigation view and it will automatically pop the
    current view off of the navigation view stack, returning us to the previous page.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are three problems with this:'
  prefs: []
  type: TYPE_NORMAL
- en: When we switch back to the previous view, we need to hide the **Add Note** button
    and show our **Add Book** button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we switch back to the book list, we still have a filter on the notes store.
    This will mess things up if we select a different book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we switch back to the book list, the book we originally selected will still
    be selected. This means that if you click on the same book again, the `select`
    event will not fire. This is also true for our notes list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means we need to tie into the back event on our navigation view and fix
    these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we have to determine is which item is active after the `back`
    event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: If it is the book list, we hide the `AddNote` button, show the `AddBook` button,
    deselect all in `bookList`, and clear the filter on the store.
  prefs: []
  type: TYPE_NORMAL
- en: If `noteList` is active then the user is coming back from the note details.
    We still need to deselect all in `noteList` and show the correct buttons, but
    we keep the filters on the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function will be used to create a `noteEdit` form and add some initial
    values to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `onAddNoteButtonTap` function we create a new instance of the `noteEdit`
    form and push it onto the `Main` navigation view. We also create a new record
    based on our `Note` model and set the `bookID` value. Lastly, we load the record
    into the form using `setRecord()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a short function to push the details panel for a note onto our
    main navigation. This is accomplished by our `onNoteSelect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are done with the basic functions, we can finally move on to getting
    images into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of important things to note about using images in an application.
    The first is that the application must be a compiled application in order for
    this feature to work. You will also need to add `Ext.device.Camera` to your `requires`
    section in `app.js`. Since this functionality is only used in compiled applications,
    the file is not included by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we have covered compiling applications in [Chapter 3](ch03.html "Chapter 3. Going
    Command Line"), *Going Command Line*, for our TimeCop application, we will not
    cover it again here.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, JavaScript has no access to the filesystem on a mobile
    device. Only by compiling the application can we bypass this limitation and use
    the camera or access existing photos on the device. This means that actual testing
    of the application can be somewhat limited before you compile it.
  prefs: []
  type: TYPE_NORMAL
- en: When you are testing in a web browser, Sencha Touch will return a placeholder
    image link for the purposes of testing. However, there are two different formats
    an image can be returned in.
  prefs: []
  type: TYPE_NORMAL
- en: The first is a `file` or URI format. This is basically a link to the existing
    file and the implementation can vary across devices. The second format is `data`,
    which is a base64-encoded string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `file` format can typically be used in an image link as `src`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the base64 `data` needs a slightly different format, which you might
    recall from our `noteDetails.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This base64 `data` format allows us to control the image format on the fly and
    store the value as a string in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Base64 data is a format that allows you to transmit files as a string of text.
    This lets us include things such as images as part of our JSON data. It also lets
    us store the string as part of the data in our database.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the file URI and the user deletes the image from the device, the URI
    will also disappear from our application. While this may be the desired behavior
    in some instances, more often it is not.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to consider where the source image is coming from. Is it coming
    from the camera itself, the stored photos, or a particular photo album?
  prefs: []
  type: TYPE_NORMAL
- en: All of these options and more are handled within the `capture` function.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing an image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how the image `capture()` function works in our `onImageSelectButtonTap`
    function works in our `Book.js` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We start out by grabbing our `imageView` variable (where we will place a copy
    of the image after it is selected) and our `imageField` variable (the hidden field
    that will store the data for our image for saving). You can see our completed
    form in the following screenshot. This shows our button, our selected image, and
    the two form fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing an image](img/8901OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Ext.device.Camera.capture` function has an internal `success` function
    to which the image is passed. The format of the image is set in the `destination`
    config and can be either `data` (base64) or `file` (URI) format.
  prefs: []
  type: TYPE_NORMAL
- en: The `success` function is where we process the image information we receive.
    In this case we set the HTML of our `imageView` container to the image, scaled
    to 200 by 200 pixels. This provides the user with a preview of their selection
    before saving.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the value of our hidden `imageField` component to the base64-encoded
    string so that it will save with our other form values.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we save there are a number of options we can set on the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quality`: This specifies the image quality to be anything from 1 – 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: Where should the image come from? The options are `camera`, `library`,
    or `album`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding`: The available encodings are `png` and `jpg`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This specifies the height of the image in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: This specifies the width of the image in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of these options can be set within the capture function, but it is good
    to keep in mind that `quality`, `height`, and `width` will be applied to the image
    before it can potentially be stored. Limiting these values can subsequently limit
    the usefulness of the image later on. It's always easier to make a big image smaller
    than it is to make a small image bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `onImageSelectButtonTap` function, we set the value of our hidden field
    to the base64-encoded `data` string. If we had chosen `destination: file` instead
    of `destination: data`, we could still do much the same thing. The image is saved
    as part of our save button handler in `noteEdit.js` we built earlier in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the `file` option would only store a reference to the image file. As
    we noted previously, if the user deletes the image from their device using their
    photo manager, it disappears from our application as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` option gives us the actual data for the image itself. This means
    if the user deletes the image from their device using their photo manager, it
    doesn't affect the image stored in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have the stored image, you can use it in your xTemplates as we described
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `file` format can typically be used in an image link as `src` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The base64 `data` format is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we also noted, when you are testing in a web browser, Sencha Touch will return
    a test image link ([http://www.sencha.com/img/sencha-large.png](http://www.sencha.com/img/sencha-large.png)).
  prefs: []
  type: TYPE_NORMAL
- en: While the test image returned when testing in the browser will work fine, if
    you are using the `file destination` format, it will display a missing image if
    you are using the `data destination` format. In the compiled application, the
    image will display correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to keep in mind with these images is that you can use the standard
    `img height` and `width` tags to shrink the image to a particular screen size.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will give you a great deal of flexibility if you store the full size image
    and use it in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Sending images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your application needs to transmit images, either to another user or an external
    API, you will need to use the data destination format. As noted previously, the
    file destination format is just a reference and it is relative to the device the
    application is running on.
  prefs: []
  type: TYPE_NORMAL
- en: Since the data format is base64, it can be transmitted just like any other string
    data. Unfortunately, there is currently no way to natively upload a file to a
    remote server without building your own custom API to accept the base64 data string
    and convert it to an image file.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you compile your application using the PhoneGap compiler instead
    of the native Sencha Touch compiler, you can use their `fileTransfer` object to
    send files as a standard HTTP POST. You can find more information on PhoneGap
    and the `fileTransfer` object at [http://docs.phonegap.com/en/1.0.0/phonegap_file_file.md.html#FileTransfer](http://docs.phonegap.com/en/1.0.0/phonegap_file_file.md.html#FileTransfer).
  prefs: []
  type: TYPE_NORMAL
- en: PhoneGap provides an online compiling service that can create native applications
    from the Sencha Touch code much like the Sencha Touch Command tools we covered
    in a previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: More information on PhoneGap can be found at [http://www.phonegap.com/](http://www.phonegap.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we talked about setting up your application to take advantage
    of the camera on your mobile device. With this we covered the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use DataViews to create a different looking UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the `data` and `file` image formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Sencha Touch to interact with the device's camera and local photo storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will use DataViews to an even greater extent to create
    the board for a multiplayer game.
  prefs: []
  type: TYPE_NORMAL
