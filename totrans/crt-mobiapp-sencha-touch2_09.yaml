- en: 'Chapter 9. Workbook: Using the Camera'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章。工作簿：使用摄像头
- en: By far, the most common feature of mobile devices today is the camera. It is
    difficult to imagine a mobile device without one. A quality application needs
    to be able to take advantage of this feature and in this chapter, we will show
    you how it's done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，移动设备最常见的特点是摄像头。很难想象一个没有摄像头的移动设备。一个高质量的应用程序需要能够利用这个功能，在本章中，我们将向您展示如何实现。
- en: 'In this chapter we will build a basic workbook application where you can:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个基本的工作簿应用程序，您可以在其中：
- en: Create notebooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建笔记本
- en: Add notes to each notebook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个笔记本添加笔记
- en: Add an image to each note
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个笔记添加图片
- en: We will also use a tiled layout data view to spice up the appearance of the
    application, and talk about ways to send an image to another application such
    as WordPress or the Sencha.io storage system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用拼贴布局数据视图来增强应用程序的外观，并讨论将图片发送到其他应用程序（如WordPress或Sencha.io存储系统）的方法。
- en: Designing the basic application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计基本应用程序
- en: For this application we will have "books" that contain "notes", which means
    we will only see a note when the user clicks on a specific book. In this case,
    a tabbed interface probably doesn't make much sense, so we will use a navigation
    view to move between our list of books and the list of notes for a particular
    book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将有“书籍”包含“笔记”，这意味着我们只有在用户点击特定书籍时才会看到笔记。在这种情况下，标签页界面可能没有太多意义，所以我们将使用导航视图在书籍列表和特定书籍的笔记列表之间切换。
- en: 'We also want to move beyond the traditional list and use a tiled view with
    some icons. This will give us something like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望超越传统的列表，使用带有一些图标的拼贴视图。这将给我们带来类似这样的效果：
- en: '![Designing the basic application](img/8901OS_09_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![设计基本应用程序](img/8901OS_09_01.jpg)'
- en: When the user taps on one of the books, they will get a similar screen with
    the notes for that particular book. We will have an **Add** button for new books
    and an **Add** button for new notes. Since the navigation view uses the same title
    bar for both views, we will need to swap between the two **Add** buttons based
    on which view we are looking at.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击其中一本书时，他们将看到一个类似的屏幕，显示该特定书籍的笔记。我们将有一个**添加**按钮用于新书籍和一个**添加**按钮用于新笔记。由于导航视图使用相同的标题栏来显示两个视图，我们需要根据我们正在查看的视图在两个**添加**按钮之间切换。
- en: We will also need forms for our books and notes. The notes form will also need
    a button that allows us to either take a picture with the device camera, or select
    a photo from the device's photo library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的书籍和笔记创建表单。笔记表单还需要一个按钮，允许我们使用设备摄像头拍照，或者从设备的照片库中选择照片。
- en: In terms of data, we need a title and an ID for our books. Our notes will also
    have a title and an ID, and we will need fields for our notes, an image, and a
    book ID to tell us which book the note belongs to.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据方面，我们需要为我们的书籍设置一个标题和一个ID。我们的笔记也将有一个标题和一个ID，我们还需要为笔记设置字段，一个图片字段，以及一个书籍ID来告诉我们笔记属于哪本书。
- en: Since we have a good idea of what data we need, let's start by setting up our
    models and stores.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经清楚我们需要哪些数据，让我们先设置我们的模型和存储。
- en: Creating the models and stores
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型和存储
- en: 'Our book is by far the simpler of the two pieces we need to deal with, so let''s
    start there. Our book model looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的两个组件中，书籍要简单得多，所以让我们从这里开始。我们的书籍模型看起来像这样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `bookstore.js` file is equally simple and uses a local storage proxy for
    storing our data. Since the list of books is the first thing the user will see,
    we also want this store to automatically load. So, in that case we will use the
    following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`bookstore.js`文件同样简单，并使用本地存储代理来存储我们的数据。由于书籍列表是用户首先看到的东西，我们也希望这个存储自动加载。因此，在这种情况下，我们将使用以下代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our notes need to be related to our books, so they will have an associated
    `bookID` as well as their own unique ID property:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的笔记需要与我们的书籍相关联，所以它们将有一个关联的`bookID`以及它们自己的唯一ID属性：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We also have fields for our title, `dateModified`, `notes`, and `image`. We
    will set `dateModified` to the current date when a new note is created and when
    an existing note is updated and saved.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有标题、`dateModified`、`notes`和`image`字段。当创建新笔记或更新并保存现有笔记时，我们将`dateModified`设置为当前日期。
- en: 'Our `noteStore.js` file looks much the same as our book store, except we don''t
    want this one to load automatically so we set `autoLoad` to `false`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`noteStore.js`文件看起来和我们的书店文件很相似，但我们不希望这个文件自动加载，所以我们设置`autoLoad`为`false`：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know what kind of data we are dealing with, we need to think about
    how things will be displayed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们正在处理什么类型的数据，我们需要考虑如何显示这些数据。
- en: The views
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: For our application views, we will need a list and edit views for our books.
    When the user clicks on a book, they will get the list of notes. We will also
    need a form for editing notes and a details view for the notes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序视图，我们需要为书籍创建一个列表视图和编辑视图。当用户点击一本书时，他们会看到笔记列表。我们还需要一个用于编辑笔记的表单和一个用于查看笔记的详细视图。
- en: Let's start with the book views.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从书籍视图开始。
- en: Creating the book views
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建书籍视图
- en: 'The first book view is our list of books. Rather than going with the simple
    list, we will use a DataView and icons to give our list a bit more visual appeal:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一本书的视图是我们的书籍列表。我们不会简单地使用列表，而是会使用一个DataView和图标来给我们的列表增添一些视觉吸引力：
- en: '![Creating the book views](img/8901OS_09_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![创建书籍视图](img/8901OS_09_02.jpg)'
- en: 'This layout will be created using the xTemplate (`tpl`) and CSS styles:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局将使用xTemplate（`tpl`）和CSS样式来创建：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We start our `booklist.js` file by extending the standard `Ext.dataview.DataView`
    and adding our configuration options. We set a title and allow for styled HTML
    content in the panel. We also set up scrolling and give it providing `directionLock`
    so it only scrolls in one direction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`booklist.js`文件开始，扩展标准的`Ext.dataview.DataView`并添加我们的配置选项。我们设置了一个标题，并允许在面板中使用样式化的HTML内容。我们还设置了滚动，并提供了`directionLock`，使其只能在一个方向上滚动。
- en: Next, we add some empty text that instructs the user how to add a book and finish
    up with our `itemTpl` and an `itemCls`. `itemTpl` and `itemCls` will be used to
    position each of our books within the view.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一些指示用户如何添加书籍的空文本，并完成我们的`itemTpl`和`itemCls`。`itemTpl`和`itemCls`将用于在视图中定位我们的每本书。
- en: 'By default, when the DataView is rendered as HTML, each item in our DataView
    is wrapped in a `div` tag with a CSS class of `.x-dataview-item`. It looks something
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当DataView以HTML渲染时，我们DataView中的每个项目都被一个带有`.x-dataview-item` CSS类的`div`标签包裹。它看起来像这样：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Potentially, we could just set styles on `.x-dataview-item`, but this would
    change the style for every DataView we use. By setting `itemCls`, the `div` tag
    now looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的话，我们只需在`.x-dataview-item`上设置样式，但这将改变我们使用的每个DataView的样式。通过设置`itemCls`，`div`标签现在看起来是这样的：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This means we can now style the `bookItem` class without affecting the rest
    of our data views. We style the `bookItem` class by placing the following into
    our CSS file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以样式化`bookItem`类，而不会影响我们的其他数据视图。我们通过在我们的CSS文件中放置以下内容来样式化`bookItem`类：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This style data determines our width for each item and tiles them across the
    screen from left to right. It also sets our margins and centers the text and our
    icon.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种样式数据决定了每个项目的宽度，并将它们从左到右平铺在屏幕上。它还设置了我们的边距，并使文本和图标居中。
- en: 'Next, we need to create a view for adding our books using a `form` component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个用于添加书籍的视图，使用一个`form`组件：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This form has a container for instructions, a text field for the user to enter
    a name for the book, and a `hiddenfield` component where we will add the book's
    `id` value when we are editing an existing book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单有一个用于说明的容器，一个用于用户输入书籍名称的文本字段，以及一个`hiddenfield`组件，当我们编辑现有的书籍时，我们将添加书籍的`id`值。
- en: 'We are also going to add two buttons to the form; a **Save** button and a **Cancel**
    button. In this example, we will set handlers for each button inside the view
    itself. This code could also be moved into the controller if you prefer, and we
    will show you how to do it that way a bit later. For now, let''s add the **Save**
    button first:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在表单中添加两个按钮；一个**保存**按钮和一个**取消**按钮。在这个例子中，我们将在视图内部为每个按钮设置处理程序。如果你更喜欢将此代码移动到控制器中，我们稍后会展示如何这样做。现在，让我们首先添加**保存**按钮：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The basic setup for the `button` element should be pretty familiar to you now.
    The `handler` component will automatically fire when the button is tapped.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`button`元素的基本设置现在应该对你来说很熟悉了。当按钮被点击时，`handler`组件会自动触发。
- en: This function grabs our `store` and `form`, values, and the value from the `values`
    variable. We then check to see if the `id` value is a number greater than zero.
    The only way this will occur is if we have loaded an existing book record into
    our form for editing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数获取我们的`store`和`form`，值，以及`values`变量的值。然后我们检查`id`值是否是一个大于零的数字。这种情况只会发生在我们将现有的书籍记录加载到表单中进行编辑时。
- en: If the `id` value is greater than zero (we have an existing book), we grab the
    current `record` value from the store and replace its values with the new values
    from our form.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `id` 值大于零（我们有一个现有的书籍），我们从商店中获取当前的 `record` 值，并用我们表单的新值替换它。
- en: If the `id` value is null (it's a new book), we create a new record using our
    book model, insert the form's `values` variable and add the record to the store.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `id` 值为 null（它是一本书），我们使用我们的书籍模型创建一个新的记录，插入表单的 `values` 变量，并将记录添加到商店中。
- en: We then sync the store to save our changes and pop the book form off of our
    main `navigationview`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后同步商店以保存我们的更改，并从主 `navigationview` 中移除书籍表单。
- en: 'Lastly, we add a **Cancel** button after our **Save** button. This one just
    needs to pop the form off of our `navigationview`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在“保存”按钮之后添加了一个 **取消** 按钮。这个按钮只需要从我们的 `navigationview` 中移除表单：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have the views for adding and displaying books in our application,
    we need to create our `main.js` view that will launch when the application is
    started.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的应用程序中创建了添加和显示书籍的视图，我们需要创建我们的 `main.js` 视图，该视图将在应用程序启动时启动。
- en: Adding the book list to the main view
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将书籍列表添加到主视图
- en: 'Our main view needs to display the list of books and it needs a button to show
    our add book form. As we noted previously, we will be using `navigationview` for
    this main component:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主视图需要显示书籍列表，并且需要一个按钮来显示我们的添加书籍表单。正如我们之前所提到的，我们将使用 `navigationview` 来实现这个主要组件：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This view is defined in `app.js` as the one that will be added to the viewport
    when the application launches. You will notice that we have required the `TitleBar`
    and `DataView` components in our `Main` component. This is to prevent compiling
    errors later on when we build our native application. The main `navigationview`
    component also includes our booklist component and an add button to show our form.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图在 `app.js` 中定义，作为应用程序启动时将被添加到视口中的视图。您会注意到，我们在 `Main` 组件中已引入了 `TitleBar` 和
    `DataView` 组件，这是为了防止在构建我们的原生应用程序时出现编译错误。主要的 `navigationview` 组件还包括我们的书籍列表组件和添加按钮，以显示我们的表单。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Code in the controller versus the view**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器中的代码与视图中的代码**'
- en: Unlike our previous book's `form` view, we will place the function code for
    our "Add Book" button inside the controller. Placing the functionality of a view
    in the controller is generally considered a "best practice", but it is important
    to understand that this can be done in a number of different ways.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前书籍的 `form` 视图不同，我们将“添加书籍”按钮的功能代码放在控制器中。将视图的功能放在控制器中通常被认为是“最佳实践”，但重要的是要理解这可以通过多种不同的方式来完成。
- en: Now that we have our main view created, let's jump over to the `Book.js` controller
    and set things up to test what we have so far.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了主视图，让我们跳转到 `Book.js` 控制器，并设置好以测试到目前为止我们所做的工作。
- en: Starting the book controller
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动书籍控制器
- en: 'The book controller will start with our views, models, and stores that we have
    created. It will also set up our references, our initial controls, and two functions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍控制器将从我们创建的视图、模型和商店开始。它还将设置我们的引用、初始控件和两个函数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our `book.js` controller file needs to push our `bookEdit` form onto the `Main`
    navigation view. We do this by creating a reference (`refs`) for the `addBookButton`
    component using its `id` property. We then assign a function to the button's `tap`
    event in our `controls` section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `book.js` 控制器文件需要将我们的 `bookEdit` 表单推送到 `Main` 导航视图中。我们通过创建一个引用 (`refs`)
    为 `addBookButton` 组件使用其 `id` 属性。然后我们在 `controls` 部分为按钮的 `tap` 事件分配一个函数。
- en: The `onAddBookButtonTap` function creates a new instance of our `bookEdit` form
    and pushes it onto our `Main` navigation view. This will make the form appear
    and add a back button at the top of the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAddBookButtonTap` 函数创建我们 `bookEdit` 表单的新实例，并将其推送到我们的 `Main` 导航视图中。这将使表单出现，并在页面顶部添加一个返回按钮。'
- en: We also added `refs` and `controls` for the `bookList` form, including an `onBookSelect`
    function. However, we don't have any of our other views so we can't display a
    list of notes for the book. Instead, we have added a console log that will show
    the DataView, record, and options that are passed when a book in the list is tapped.
    Once we add a book, we should be able to tap on it and see the information displayed
    in the Safari Error console.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为 `bookList` 表单添加了 `refs` 和 `controls`，包括一个 `onBookSelect` 函数。然而，我们没有其他视图，因此无法显示书籍的笔记列表。相反，我们添加了一个控制台日志，它将显示当列表中的书籍被点击时传递的
    DataView、记录和选项。一旦我们添加了一本书，我们应该能够点击它，并在 Safari 错误控制台中看到显示的信息。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The `console.log()` function is a great way to test your application in the
    early stages of development. It can help you detect problems early on and deal
    with them before you build up the entire project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log()`函数是测试开发早期阶段应用程序的绝佳方式。它可以帮助你及早发现问题并处理它们，在你构建整个项目之前。'
- en: 'If you test the project now, you should get the initial empty book screen and
    be able to add new books:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试项目，你应该会得到初始的空书屏幕，并且能够添加新的书籍：
- en: '![Starting the book controller](img/8901OS_09_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![启动书控制器](img/8901OS_09_03.jpg)'
- en: 'If you add a book and then tap it in the book list, you should see something
    like the following screenshot in the Safari Error console:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了一本书并在书列表中轻触它，你应该在Safari错误控制台中看到以下截图类似的内容：
- en: '![Starting the book controller](img/8901OS_09_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![启动书控制器](img/8901OS_09_04.jpg)'
- en: From left to right, these objects are the DataView (our book list), the record
    (which book was tapped), and the options (the object that was passed to the listener—serious
    nerd stuff).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，这些对象是`DataView`（我们的书列表）、记录（被轻触的书）和选项（传递给监听器的对象——真正的技术宅内容）。
- en: We will use the information in the record object later on to tell us which notes
    to display. Now we need to create the views for our notes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后使用记录对象中的信息来告诉我们显示哪些笔记。现在我们需要为我们的笔记创建视图。
- en: Creating the note views
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建笔记视图
- en: 'We need three different views for our notes: a list view, an edit view, and
    a details view. We will start with our list view since it is similar to the one
    we use for books:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的笔记创建三个不同的视图：列表视图、编辑视图和详情视图。我们将从列表视图开始，因为它与我们的书列表类似：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We override the DataView, set up our IDs and our scrolling, just as we did with
    our book list. In the `itemTpl` configuration, we added the date the note was
    modified, using the `date()` function to change it to a shorter format than the
    default. We also set our empty text and a default title. Our book controller will
    update the title and display the book name for the current note.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖了`DataView`，设置了我们的ID和滚动，就像我们在书列表中做的那样。在`itemTpl`配置中，我们添加了笔记修改的日期，使用`date()`函数将其转换为比默认格式更短的格式。我们还设置了我们的空文本和默认标题。我们的书控制器将更新标题并显示当前笔记的书名。
- en: We will be using the same basic styles as our book container to make the note
    list tile across the screen like our book list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与我们的书容器相同的基本样式，使笔记列表像书列表一样横跨屏幕。
- en: '![Creating the note views](img/8901OS_09_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![创建笔记视图](img/8901OS_09_05.jpg)'
- en: 'When the user taps a note in the list, we need to display the note details
    with the text and the image for the note. Our `noteDetails.js` view is a simple
    panel with an xTemplate:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在列表中轻触笔记时，我们需要显示笔记的详细信息，包括文本和笔记的图片。我们的`noteDetails.js`视图是一个简单的面板，使用xTemplate：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don't worry too much about the `data:image/png;base64` section of this code.
    We will cover the base64 image format in the *Getting started with images* section
    of the chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过分担心此代码中的`data:image/png;base64`部分。我们将在本章的*图像入门*部分介绍base64图像格式。
- en: The edit view for our note will have fields for a title and note text. There
    will also be hidden fields such as `bookID`, `image`, and the note's `id` field
    (the value of these will be set by our controller).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们笔记的编辑视图将包含标题和笔记文本字段。同时，还将有隐藏字段，如`bookID`、`image`和笔记的`id`字段（这些字段的值将由我们的控制器设置）。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will also have a button for selecting an image and a container for displaying
    the selected image. When the button is tapped, we will select an image from the
    device that will be returned to us as a base64 string. This string will be set
    as the value for our hidden `image` field.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个用于选择图片的按钮和一个用于显示所选图片的容器。当按钮被轻触时，我们将从设备中选择一个图片，该图片将作为base64字符串返回给我们。这个字符串将被设置为我们的隐藏`image`字段的值。
- en: We will also have two buttons just like our book edit form, one for for the
    purpose of saving and one for canceling. The **Cancel** button is exactly the
    same as the previous one for the book edit and it just pops the form off of the
    navigation view.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有两个按钮，就像我们的书编辑表单一样，一个用于保存，一个用于取消。**取消**按钮与之前的书编辑按钮完全相同，它只是从导航视图中弹出表单。
- en: 'The **Save** button is a little different in that it needs to set a value for
    date modified whenever a note is saved:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**保存**按钮有一点不同，因为它需要在每次保存笔记时设置日期修改的值：'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Other than that, the button is mostly the same as our book save button. We grab
    the store and the form values, we check to see if we are dealing with a new note
    or an existing note, and we save the note accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，按钮基本上与我们的书籍保存按钮相同。我们获取存储和表单值，检查我们是否正在处理新的笔记或现有的笔记，并相应地保存笔记。
- en: With these basic views set up, it's time to get back into our controller and
    hook everything together.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些基本视图后，是时候回到我们的控制器，将所有东西连接在一起了。
- en: Creating the controller
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器
- en: The first thing we need to do in our controller is update our `config` section
    to add the new views, stores, and models for our application. We also need to
    add some new references and controls for these new components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制器中，我们首先需要更新 `config` 部分，为我们的应用程序添加新的视图、存储和模型。我们还需要为这些新组件添加一些新的引用和控制。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `refs` section will set up our shortcuts for the new note components we
    created and the controls will add new functions for the following actions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`refs` 部分将设置我们为创建的新笔记组件设置快捷键，而控制部分将为以下操作添加新功能：'
- en: Tapping a note in the list
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击列表中的笔记
- en: Tapping the button to add an image
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击按钮添加图片
- en: Selecting a book in the list
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中选择书籍
- en: Selecting a note in the list
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中选择笔记
- en: Clicking the back button from anywhere in the application
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序的任何地方点击返回按钮
- en: Now that we have `refs` and `control` in place, let's start creating the functions
    we will need for the application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了 `refs` 和 `control`，让我们开始创建应用程序所需的函数。
- en: 'The `onBookSelect` function is linked to the `select` event for the book list
    (in the `controls` section). The `select` event will automatically pass along
    the record that was selected as part of its arguments. We will use the book title
    from that record to set the `title` property of our new note list view. We will
    also use the `id` property from this record to limit the note''s `store` to just
    the notes for that book:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBookSelect` 函数与书单的 `select` 事件（在 `controls` 部分中）相关联。`select` 事件将自动将其参数中选中的记录传递过来。我们将使用该记录中的书名来设置我们新的笔记列表视图的
    `title` 属性。我们还将使用此记录的 `id` 属性来限制笔记的 `store` 只包含该书的笔记：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that we pass the `title` value as a configuration option when we create
    the new instance of the note list. This is often a handy way to set additional
    parameters when creating a new object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在创建笔记列表的新实例时，将 `title` 值作为配置选项传递。这通常是在创建新对象时设置额外参数的一种便捷方式。
- en: Next, we push our new `noteList` object onto the `Main` navigation view, and
    swap our `AddBook` button with the `AddNote` button using `show`/`hide` functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将新的 `noteList` 对象推送到 `Main` 导航视图，并使用 `show`/`hide` 函数将 `AddBook` 按钮与 `AddNote`
    按钮进行交换。
- en: We then use the `bookID` value to filter the store, limiting the notes to just
    the ones for our current book and load the store.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `bookID` 值来过滤存储，仅限制当前书籍的笔记，并加载存储。
- en: We also add `bookID` as a configuration option on `noteList`. This will let
    us easily grab `bookID` when we add new notes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `noteList` 上添加了 `bookID` 作为配置选项。这将使我们能够轻松地在我们添加新笔记时获取 `bookID`。
- en: The next thing we need to take care of is the **Back** button. This button is
    created automatically by the navigation view and it will automatically pop the
    current view off of the navigation view stack, returning us to the previous page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要处理的是 **返回** 按钮。此按钮由导航视图自动创建，并且它将自动从导航视图堆栈中弹出当前视图，返回到上一页。
- en: 'However, there are three problems with this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有三个问题：
- en: When we switch back to the previous view, we need to hide the **Add Note** button
    and show our **Add Book** button.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们切换回上一视图时，我们需要隐藏 **添加笔记** 按钮并显示我们的 **添加书籍** 按钮。
- en: When we switch back to the book list, we still have a filter on the notes store.
    This will mess things up if we select a different book.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们切换回书单时，我们仍然在笔记存储上有过滤器。如果我们选择不同的书籍，这将会搞乱事情。
- en: When we switch back to the book list, the book we originally selected will still
    be selected. This means that if you click on the same book again, the `select`
    event will not fire. This is also true for our notes list.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们切换回书单时，最初选择的书籍仍然被选中。这意味着如果你再次点击同一本书，`select` 事件将不会触发。这同样适用于我们的笔记列表。
- en: 'This means we need to tie into the back event on our navigation view and fix
    these issues:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要连接到我们的导航视图上的后退事件并修复这些问题：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first thing we have to determine is which item is active after the `back`
    event is fired.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确定在 `back` 事件触发后哪个项目是激活的。
- en: If it is the book list, we hide the `AddNote` button, show the `AddBook` button,
    deselect all in `bookList`, and clear the filter on the store.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是书单，我们将隐藏`AddNote`按钮，显示`AddBook`按钮，取消选择`bookList`中的所有项，并清除存储上的过滤器。
- en: If `noteList` is active then the user is coming back from the note details.
    We still need to deselect all in `noteList` and show the correct buttons, but
    we keep the filters on the store.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`noteList`是活动的，则用户是从笔记详情返回的。我们仍然需要取消选择`noteList`中的所有项并显示正确的按钮，但我们需要保持存储上的过滤器。 '
- en: 'The next function will be used to create a `noteEdit` form and add some initial
    values to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数将用于创建一个`noteEdit`表单并向其中添加一些初始值：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `onAddNoteButtonTap` function we create a new instance of the `noteEdit`
    form and push it onto the `Main` navigation view. We also create a new record
    based on our `Note` model and set the `bookID` value. Lastly, we load the record
    into the form using `setRecord()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onAddNoteButtonTap`函数中，我们创建一个`noteEdit`表单的新实例并将其推送到`Main`导航视图。我们还基于我们的`Note`模型创建一个新记录并设置`bookID`值。最后，我们使用`setRecord()`将记录加载到表单中。
- en: 'Next, we need a short function to push the details panel for a note onto our
    main navigation. This is accomplished by our `onNoteSelect` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个简短的函数来将笔记的详细信息面板推送到我们的主导航。这是通过我们的`onNoteSelect`函数实现的：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we are done with the basic functions, we can finally move on to getting
    images into our application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了基本函数，我们最终可以开始将图像添加到我们的应用程序中。
- en: Getting started with images
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用图像
- en: There are a couple of important things to note about using images in an application.
    The first is that the application must be a compiled application in order for
    this feature to work. You will also need to add `Ext.device.Camera` to your `requires`
    section in `app.js`. Since this functionality is only used in compiled applications,
    the file is not included by default.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中使用图像有几个重要事项需要注意。首先，应用程序必须是一个编译后的应用程序，以便此功能能够工作。你还需要在`app.js`中的`requires`部分添加`Ext.device.Camera`。由于此功能仅在编译后的应用程序中使用，因此默认情况下不包括该文件。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since we have covered compiling applications in [Chapter 3](ch03.html "Chapter 3. Going
    Command Line"), *Going Command Line*, for our TimeCop application, we will not
    cover it again here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在[第3章](ch03.html "第3章。命令行操作")中已经介绍了编译应用程序，即“命令行操作”，对于我们的TimeCop应用程序，我们在此不再重复介绍。
- en: For security reasons, JavaScript has no access to the filesystem on a mobile
    device. Only by compiling the application can we bypass this limitation and use
    the camera or access existing photos on the device. This means that actual testing
    of the application can be somewhat limited before you compile it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，JavaScript无法访问移动设备上的文件系统。只有通过编译应用程序，我们才能绕过这一限制并使用相机或访问设备上的现有照片。这意味着在实际编译应用程序之前，对应用程序的实际测试可能有些受限。
- en: When you are testing in a web browser, Sencha Touch will return a placeholder
    image link for the purposes of testing. However, there are two different formats
    an image can be returned in.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网页浏览器中进行测试时，Sencha Touch会返回一个占位符图像链接以供测试。然而，图像可以以两种不同的格式返回。
- en: The first is a `file` or URI format. This is basically a link to the existing
    file and the implementation can vary across devices. The second format is `data`,
    which is a base64-encoded string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种格式是`file`或URI。这基本上是现有文件的链接，其实施可以在不同设备上有所不同。第二种格式是`data`，它是一个base64编码的字符串。
- en: 'The `file` format can typically be used in an image link as `src`. For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`格式通常可以用作图像链接中的`src`。例如：'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, the base64 `data` needs a slightly different format, which you might
    recall from our `noteDetails.js` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，base64 `data`需要稍有不同的格式，你可能还记得我们的`noteDetails.js`文件：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This base64 `data` format allows us to control the image format on the fly and
    store the value as a string in the database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种base64 `data`格式允许我们动态控制图像格式并将值作为字符串存储在数据库中。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Base64 data is a format that allows you to transmit files as a string of text.
    This lets us include things such as images as part of our JSON data. It also lets
    us store the string as part of the data in our database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Base64数据是一种允许你将文件作为文本字符串传输的格式。这使得我们可以将图像等东西作为我们JSON数据的一部分。它还允许我们将字符串作为数据库中的数据部分存储。
- en: If we use the file URI and the user deletes the image from the device, the URI
    will also disappear from our application. While this may be the desired behavior
    in some instances, more often it is not.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用文件URI，并且用户从设备中删除了图像，URI也将从我们的应用程序中消失。虽然在某些情况下这可能是一种期望的行为，但更常见的情况并非如此。
- en: We also need to consider where the source image is coming from. Is it coming
    from the camera itself, the stored photos, or a particular photo album?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑源图片是从哪里来的。它是从相机本身来的，还是从存储的照片，或者是从特定的相册来的？
- en: All of these options and more are handled within the `capture` function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项以及更多都是在`capture`函数中处理的。
- en: Capturing an image
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获图片
- en: 'Let''s take a look at how the image `capture()` function works in our `onImageSelectButtonTap`
    function works in our `Book.js` controller:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图片`capture()`函数是如何在我们的`Book.js`控制器中的`onImageSelectButtonTap`函数中工作的：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We start out by grabbing our `imageView` variable (where we will place a copy
    of the image after it is selected) and our `imageField` variable (the hidden field
    that will store the data for our image for saving). You can see our completed
    form in the following screenshot. This shows our button, our selected image, and
    the two form fields:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取我们的`imageView`变量（在图片被选中后我们将放置图片副本的地方）和我们的`imageField`变量（将存储我们图片数据的隐藏字段）。您可以在下面的屏幕截图中看到我们的完整表单。这显示了我们的按钮、选中的图片和两个表单字段：
- en: '![Capturing an image](img/8901OS_09_06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![捕获图片](img/8901OS_09_06.jpg)'
- en: The `Ext.device.Camera.capture` function has an internal `success` function
    to which the image is passed. The format of the image is set in the `destination`
    config and can be either `data` (base64) or `file` (URI) format.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.device.Camera.capture`函数有一个内部的`success`函数，将图片传递给它。图片的格式由`destination`配置设置，可以是`data`（base64）或`file`（URI）格式。'
- en: The `success` function is where we process the image information we receive.
    In this case we set the HTML of our `imageView` container to the image, scaled
    to 200 by 200 pixels. This provides the user with a preview of their selection
    before saving.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`success`函数是我们处理接收到的图片信息的地方。在这种情况下，我们将我们的`imageView`容器（在图片被选中后我们将放置图片副本的地方）的HTML设置为200x200像素的图片。这为用户提供了一个在保存之前的预览。'
- en: We also set the value of our hidden `imageField` component to the base64-encoded
    string so that it will save with our other form values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将我们的隐藏`imageField`组件的值设置为base64编码的字符串，以便它将与我们的其他表单值一起保存。
- en: 'However, before we save there are a number of options we can set on the image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们保存之前，我们可以在图片上设置一系列选项：
- en: '`quality`: This specifies the image quality to be anything from 1 – 100.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quality`: 这指定了图片质量，范围从1到100。'
- en: '`source`: Where should the image come from? The options are `camera`, `library`,
    or `album`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`: 图片应该从哪里来？选项有`camera`、`library`或`album`。'
- en: '`encoding`: The available encodings are `png` and `jpg`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`: 可用的编码格式有`png`和`jpg`。'
- en: '`height`: This specifies the height of the image in pixels.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`: 这指定了图片的高度（以像素为单位）。'
- en: '`width`: This specifies the width of the image in pixels.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 这指定了图片的宽度（以像素为单位）。'
- en: Any of these options can be set within the capture function, but it is good
    to keep in mind that `quality`, `height`, and `width` will be applied to the image
    before it can potentially be stored. Limiting these values can subsequently limit
    the usefulness of the image later on. It's always easier to make a big image smaller
    than it is to make a small image bigger.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的任何一个都可以在捕获函数中设置，但最好记住，`quality`、`height`和`width`将在图片可能被存储之前应用于图片。限制这些值可能会随后限制图片在之后的可用性。将大图片变小总是比将小图片变大容易。
- en: Storing the image
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储图片
- en: 'In our `onImageSelectButtonTap` function, we set the value of our hidden field
    to the base64-encoded `data` string. If we had chosen `destination: file` instead
    of `destination: data`, we could still do much the same thing. The image is saved
    as part of our save button handler in `noteEdit.js` we built earlier in the chapter.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的`onImageSelectButtonTap`函数中，我们将隐藏字段的值设置为base64编码的`data`字符串。如果我们选择了`destination:
    file`而不是`destination: data`，我们仍然可以做很多相同的事情。图片作为我们之前在章节中构建的`noteEdit.js`中的保存按钮处理程序的一部分被保存。'
- en: However, the `file` option would only store a reference to the image file. As
    we noted previously, if the user deletes the image from their device using their
    photo manager, it disappears from our application as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`file`选项只会存储图片文件的引用。正如我们之前提到的，如果用户使用他们的照片管理器从设备中删除图片，它也会从我们的应用程序中消失。
- en: The `data` option gives us the actual data for the image itself. This means
    if the user deletes the image from their device using their photo manager, it
    doesn't affect the image stored in our application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`选项为我们提供了图片本身的实际数据。这意味着如果用户使用他们的照片管理器从设备中删除图片，它不会影响我们应用程序中存储的图片。'
- en: Displaying the image
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示图片
- en: Once you have the stored image, you can use it in your xTemplates as we described
    previously.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了存储的图像，您就可以像我们之前描述的那样在您的xTemplates中使用它。
- en: 'The `file` format can typically be used in an image link as `src` like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`文件`格式通常可以用作图像链接中的`src`，如下所示：'
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The base64 `data` format is used like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: base64 `数据`格式的使用方式如下：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we also noted, when you are testing in a web browser, Sencha Touch will return
    a test image link ([http://www.sencha.com/img/sencha-large.png](http://www.sencha.com/img/sencha-large.png)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们也提到的，当您在网页浏览器中测试时，Sencha Touch将返回一个测试图像链接([http://www.sencha.com/img/sencha-large.png](http://www.sencha.com/img/sencha-large.png))。
- en: While the test image returned when testing in the browser will work fine, if
    you are using the `file destination` format, it will display a missing image if
    you are using the `data destination` format. In the compiled application, the
    image will display correctly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器中测试时返回的测试图像将正常工作，但如果您使用的是`文件目标`格式，并且使用的是`数据目标`格式，则会显示一个缺失的图像。在编译的应用程序中，图像将正确显示。
- en: 'Another thing to keep in mind with these images is that you can use the standard
    `img height` and `width` tags to shrink the image to a particular screen size.
    For example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些图像中还需要注意的另一件事是，您可以使用标准的`img height`和`width`标签将图像缩小到特定的屏幕大小。例如：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will give you a great deal of flexibility if you store the full size image
    and use it in different ways.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您存储全尺寸图像并以不同的方式使用它，这将为您带来极大的灵活性。
- en: Sending images
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送图像
- en: If your application needs to transmit images, either to another user or an external
    API, you will need to use the data destination format. As noted previously, the
    file destination format is just a reference and it is relative to the device the
    application is running on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要传输图像，无论是发送给其他用户还是外部API，您将需要使用数据目标格式。如前所述，文件目标格式只是一个参考，它与应用程序运行的设备相关。
- en: Since the data format is base64, it can be transmitted just like any other string
    data. Unfortunately, there is currently no way to natively upload a file to a
    remote server without building your own custom API to accept the base64 data string
    and convert it to an image file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据格式是base64，它可以像任何其他字符串数据一样传输。不幸的是，目前还没有办法在不构建自己的自定义API来接受base64数据字符串并将其转换为图像文件的情况下，在本地上传文件到远程服务器。
- en: However, if you compile your application using the PhoneGap compiler instead
    of the native Sencha Touch compiler, you can use their `fileTransfer` object to
    send files as a standard HTTP POST. You can find more information on PhoneGap
    and the `fileTransfer` object at [http://docs.phonegap.com/en/1.0.0/phonegap_file_file.md.html#FileTransfer](http://docs.phonegap.com/en/1.0.0/phonegap_file_file.md.html#FileTransfer).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您使用PhoneGap编译器而不是本地的Sencha Touch编译器来编译您的应用程序，您可以使用他们的`fileTransfer`对象将文件作为标准的HTTP
    POST发送。您可以在[http://docs.phonegap.com/en/1.0.0/phonegap_file_file.md.html#FileTransfer](http://docs.phonegap.com/en/1.0.0/phonegap_file_file.md.html#FileTransfer)找到更多关于PhoneGap和`fileTransfer`对象的信息。
- en: PhoneGap provides an online compiling service that can create native applications
    from the Sencha Touch code much like the Sencha Touch Command tools we covered
    in a previous chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap提供了一个在线编译服务，可以从Sencha Touch代码创建原生应用程序，就像我们在前一章中介绍的Sencha Touch命令工具一样。
- en: More information on PhoneGap can be found at [http://www.phonegap.com/](http://www.phonegap.com/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于PhoneGap的信息可以在[http://www.phonegap.com/](http://www.phonegap.com/)找到。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we talked about setting up your application to take advantage
    of the camera on your mobile device. With this we covered the following points:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何设置您的应用程序以利用您的移动设备上的相机。通过这种方式，我们涵盖了以下要点：
- en: How to use DataViews to create a different looking UI
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用DataViews创建不同外观的UI
- en: The difference between the `data` and `file` image formats
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据`和`文件`图像格式之间的区别'
- en: Using Sencha Touch to interact with the device's camera and local photo storage
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sencha Touch与设备的相机和本地照片存储进行交互
- en: In the next chapter we will use DataViews to an even greater extent to create
    the board for a multiplayer game.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更广泛地使用DataViews来创建多人游戏的游戏板。
