<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-106"><a id="_idTextAnchor106"/>8</h1>
<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Builds and Adapters</h1>
<p>In the previous four chapters, we’ve spent a significant amount of time discussing various routing techniques. From simple routing to pages that can be rendered as static HTML and speed up our application, to more complex tactics where we ensure the data is of an expected type through the use of regular expressions. While these techniques represent core features of SvelteKit, they are not all there is to it. Another useful quality found in SvelteKit is its ability to run in nearly any environment through the use of adapters. Before we dive into various adapters and their configurations, we’ll analyze the process involved when creating a production build of a SvelteKit application.</p>
<p>Firstly, we’ll need to address how to build our application for a production environment. Vite makes this step simple, so we’ll then pivot to how we can use different adapters to adjust builds for various environments. While each adapter has its own requirements, it would quickly become repetitive to discuss them all. Instead, we’ll focus on three different adapters that are each suited to unique environments.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating a Build</li>
<li>Adapting the App</li>
</ul>
<p>Once complete, you’ll be able to build and deploy your very own applications to a multitude of platform types, including static hosts, Node.js, and a plethora of serverless environments.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter08">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter08</a>.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Creating a Build</h1>
<p>In other books about web development<a id="_idIndexMarker172"/> frameworks, a section related to creating a production build of the application usually doesn’t come until the very end. But because SvelteKit and Vite make it so simple, there’s really no reason to wait. I’m sure you’re eager to get your application available as soon as possible, so let’s get straight to it.</p>
<p>So far, we’ve only worked with our application in the development environment. In essence, Vite started a development server on the local machine when we ran the <code>npm run dev</code> command. To shut down the development server, we use <em class="italic">Ctrl</em> + <em class="italic">C</em>. To prepare a production build of our application, we can use the provided <code>npm</code> script:</p>
<pre class="source-code">
npm run build</pre>
<p>If you open the project’s <code>package.json</code>, you’ll notice this particular script runs the <code>vite build</code> command. It does exactly what it sounds like by kicking off Vite’s build process, which involves the bundling process from Rollup, packaging static assets, and running the configured adapter. Upon completion of the command, you’ll notice the output in your terminal lists various files as well as their size. If there are any errors in the build, they will be shown here.</p>
<p>By default, the fully built application will be output to <code>.svelte-kit/</code>. To change this directory, we can open <code>svelte.config.js</code> and pass in the preferred directory name to the <code>config.kit.outDir</code> option. When opening the <code>build</code> folder, you’ll notice that the built application has a different structure compared to our source code. This is, of course, by design and varies based on the adapter we’re using. To confirm that our production build works, we can preview it using the following command:</p>
<pre class="source-code">
npm run preview</pre>
<p>Once run, Vite will alert us to the new URL and port that our application can be accessed from. We can view and use the application there just as we can when running our development server. What differs is that file changes will not be automatically updated, as the files being used to run this version of the application need to be regenerated on each build – that is, unless <code>build.watch</code> has been set in the <code>vite.config.js</code> project.</p>
<p>Having run the first official build of our application, there are a few things to make note of before we begin discussing adapters. Firstly, think back to <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a> when we covered <code>ssr</code> in the root <code>+layout.js</code> file. Just keep in mind that prerendering takes place during the build of the application. As such, any <code>fetch()</code> requests that happen on prerendered pages will happen at build time. We can confirm this with a simple change to our <code>fetch</code> example. Where we previously set <code>ssr = false</code>, change it now to <code>prerender = </code><code>true;</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(site)/fetch/+page.js</p>
<pre class="source-code">
const key = 'DEMO_KEY'; // your API key here
export const prerender = true; // change this line
export function load() {
  const pic = fetch(`https://api.nasa.gov/planetary/apod?api_key=${key}`)
    .then(response =&gt; {
      console.log('got response');
      return response.json();
    });
  return {pic};
}</pre>
<p>Once we’ve enabled prerendering<a id="_idIndexMarker174"/> on this particular route, we can go ahead and rebuild the application. Now, when we open our <code>build</code> folder, we should see the file at the <code>.svelte-kit/output/prerendered/pages/fetch.html</code> path. Upon opening this file, we’ll see the image element as well as all of the other data pulled from the NASA API shown as static HTML. This confirms to us that prerendering happens during the build process. It is very much something developers need to be cognizant of when preparing their applications for production environments.</p>
<p>There are a few other idiosyncrasies<a id="_idIndexMarker175"/> to take note of when building your application:</p>
<ul>
<li>Disabling <code>csr</code> and <code>ssr</code> will result in an empty page being rendered.</li>
<li>It is not possible to prerender pages that rely on form actions as the page relies on HTTP <code>POST</code> requests.</li>
<li>It is also not possible to prerender pages that make use of <code>url.searchParams.</code></li>
<li>It is possible to prerender pages that load data based on dynamic parameters in the route; however, SvelteKit will need to observe links to those endpoints to do so.</li>
</ul>
<p>As demonstrated, preparing an application for production is quite simple. Vite bundles dependencies quickly and even provides a means to preview the application. That being said, there are a few things to keep in mind before packaging the application. In the next section, we’ll look at a few commonly used adapters and how they each produce builds specific to the intended environment.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Adapting the app</h1>
<p>Now that we know how to build <a id="_idIndexMarker176"/>our application, we can explore some of the adapters that transform it for specified environments. For the entire time we’ve worked on our project, we’ve been using the <code>@sveltejs/adapter-auto</code> package. So far, we haven’t run into any issues, but if we want to build and deploy our application to a real production environment, we’ll need to get more specific. While <code>adapter-auto</code> is great, it doesn’t accept any configuration options and only works with Cloudflare Pages, Vercel, Netlify, and Azure Static Web Apps. If we wanted to host our application on a Node.js server or elsewhere, we would need to use a different adapter. Let’s explore a few of the different options available in the following section. The adapters<a id="_idIndexMarker177"/> we’ll look at are as follows:</p>
<ul>
<li><code>adapter-node</code></li>
<li><code>adapter-cloudflare</code></li>
<li><code>adapter-static</code></li>
</ul>
<p>This list is not comprehensive, as the SvelteKit project supports many more environments. Meanwhile, the SvelteKit community continues creating and releasing adapters for a variety of platforms. Be sure to check the Svelte community resources before building your own adapter.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>adapter-node</h2>
<p>To begin, we’ll start with <code>adapter-node</code>, as most web developers<a id="_idIndexMarker178"/> have at least some familiarity with Node.js environments. This adapter can be installed by running the following command:</p>
<pre class="source-code">
npm install -D @sveltejs/adapter-node</pre>
<p>Once installed, we can add it to our project by importing it into our <code>svelte.config.js</code> and specifying the adapter accordingly:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">svelte.config.js</p>
<pre class="source-code">
import adapter from '@sveltejs/adapter-node';
const config = {
    kit: {
        adapter: adapter(),
        alias: {
            db: '/src/db.js',
            img: '/src/lib/images'
        }
    },
};
export default config;</pre>
<p>As before, this configuration only differs in that it imports <code>adapter-node</code> instead of <code>adapter-auto</code>.</p>
<p>Once the adapters have been switched out, we can build the application for a Node.js environment by running <code>npm run build</code> in the terminal. By default, this adapter will output the built application to the <code>build/</code> directory.</p>
<p>So far in this project, we’ve only<a id="_idIndexMarker179"/> included one dependency, and that was <code>bcrypt</code>. If we hadn’t included that dependency, we wouldn’t even need to do this next step. But because it seems rare to find a project that’s not using other dependencies, we’d better cover it. To ensure our Node.js production environment has access to all the required dependencies, we’ll need to install them. We do this by copying <code>package.json</code> and <code>package-lock.json</code> to the <code>build/</code> directory. To ensure our build works successfully, we’ll simulate an automated deployment. We can do this by copying the entire <code>build/</code> directory (which now also includes <code>package.json</code> and <code>package-lock.json</code>) to another location on our machine. Once done, we can use npm’s clean install command in the same directory to download the required production dependencies. This is the recommended installation method for automated deployments and continuous integration environments. We don’t need development dependencies, as SvelteKit is now bundled into pure JS so the command looks like this:</p>
<pre class="source-code">
npm ci --omit dev</pre>
<p>Running this command in the same directory as our build will download the dependencies required.</p>
<p>We can then launch the application with the following command:</p>
<pre class="source-code">
ORIGIN=http://0.0.0.0:3000 node build</pre>
<p>In this instance, <code>build</code> is the name of the directory we would like Node.js to target. We’ve also specified the <code>ORIGIN</code> environment variable so that <code>adapter-node</code> can correctly determine the URL of the application. Without<a id="_idIndexMarker180"/> this, SvelteKit would block any <code>POST</code> requests as a means of protection against <code>0.0.0.0:3000</code>. To change the IP address or listening port, we can set those environment variables before running <code>node build</code>. For instance, launching the application at <code>127.0.0.1:8000</code> would look like <code>HOST=127.0.0.1 PORT=8000 ORIGIN=http://127.0.0.1:8000 </code><code>node build</code>.</p>
<p>To further customize your builds, this adapter provides the following options:</p>
<ul>
<li><code>out</code> – A string specifying the directory the build should be output to. It defaults to <code>build</code> and should not have a <code>/</code> character at the end.</li>
<li><code>precompress</code> – A Boolean value that defaults to <code>false</code> and controls whether or not assets and prerendered pages should be compressed using <code>gzip</code> and <code>brotli</code>.</li>
<li><code>envPrefix</code> – A string value specifying a prefix applied to environment variables, which proves quite useful when your hosting provider doesn’t provide you with access to the standard environment variables such as <code>HOST</code> or <code>PORT</code>. Setting this will allow you to create your own environment variables.</li>
<li><code>polyfill</code> – A Boolean value defaulting to <code>true</code> that allows you to specify whether or not your build should include polyfills that add functionality not available in older Node.js releases.</li>
</ul>
<p>After everything we’ve just covered, you should be able to deploy your own SvelteKit application to just about any Node.js environment. And if the destination environment limits your control, you should be able to customize the build using various options. Because Node.js environments<a id="_idIndexMarker181"/> are so prevalent, it would have been a huge mistake to not explain some of the functionality behind <code>adapter-node</code> and how it can streamline your deployment process.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>adapter-cloudflare</h2>
<p>While <code>adapter-node</code> is great for when<a id="_idIndexMarker182"/> we’re running Node.js applications, there are adapters that allow us to deploy without needing to manage, configure, or maintain a server. Platforms such as Vercel, Netlify, and Cloudflare all provide these services and empower developers to ship their code faster than ever before. For demonstration purposes, let’s look at how easy it is to deploy to Cloudflare Pages.</p>
<p>To begin, we’ll install the adapter just like we have done with other packages:</p>
<pre class="source-code">
npm i -D @sveltejs/adapter-cloudflare</pre>
<p>Once done, we can change our <code>svelte.config.js</code> to reflect the new adapter. Again, we simply need to import the new adapter:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">svelte.config.js</p>
<pre class="source-code">
import adapter from '@sveltejs/adapter-cloudflare';
const config = {
    kit: {
        adapter: adapter(),
    }
};
export default config;</pre>
<p>Before delving too deep, it’s important to note that the application we have built thus far <code>bcrypt</code> package earlier, our application will fail to build as <code>bcrypt</code> makes extensive use of Node.js APIs. To successfully build and deploy the application, we will need to make a couple of changes.</p>
<p>If you’d prefer not to make these<a id="_idIndexMarker183"/> changes in your application, you can create a fork of this book’s code repository found under the <em class="italic">Technical requirements</em> section listed at the beginning of each chapter. In that repository, there is a branch labeled <code>cloudflare</code> that has all of the necessary changes. When forking the repository, be sure to <code>cloudflare</code> branch. As for the necessary changes, let’s take a brief detour and examine them now:</p>
<ol>
<li>Uninstall <code>bcrypt</code> with the <code>npm uninstall </code><code>bcrypt</code> command.</li>
<li>Remove references to <code>bcrypt</code> in <code>src/routes/(app)/login/+page.server.js</code>, as shown in the following code snippet.</li>
<li>Change <code>src/lib/users.json</code> passwords to plaintext values:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/(app)/login/+page.server.js</p>
<pre class="source-code">
import users from '$lib/users.json';
export const actions = {
  login: async ({request, cookies}) =&gt; {
    const form = await request.formData();
    const exists = users.filter(user =&gt; user.username === form.get('username'));
    const auth = exists.filter(user =&gt; user.password === form.get('password'));
    if(!exists.length || !auth.length) {
      return {msg: 'Invalid login!'};
    }
    cookies.set('identity', auth[0].identity, {path: '/'});
    return {msg: 'success!'}
  }
}</pre>
<p>This new version of <code>+page.server.js</code> simply removes references to the <code>bcrypt</code> package and instead compares the text supplied in the <code>password</code> field to the plain text values in the <code>src/lib/users.json</code> file. <strong class="bold">It cannot be stressed how terrible this is from a security standpoint and I am trusting you to never do this outside of this </strong><strong class="bold">particular demonstration</strong>.</p>
<p>Now that we have removed all dependencies<a id="_idIndexMarker184"/> that require Node.js, we can proceed with our deployment to Cloudflare. Firstly, we should log in to a Cloudflare account, navigate to <code>cloudflare</code> here. Typically, this would be the <code>main</code> branch.</p>
<p>From there, we can set up a few<a id="_idIndexMarker185"/> options. Cloudflare makes this next step a breeze by asking whether we’re using a framework, which we are. Selecting <strong class="bold">SvelteKit</strong> from the <strong class="bold">Framework preset</strong> dropdown will auto-populate the <strong class="bold">Build command</strong> and <strong class="bold">Build output directory</strong> fields with the appropriate values. See <em class="italic">Figure 8</em><em class="italic">.1</em> for more information:</p>
<div><div><img alt="Figure 8.1 – Cloudflare Pages project settings" src="img/B19024_08_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Cloudflare Pages project settings</p>
<p>Because the source code for the project we’re attempting to deploy from is in a subdirectory of the Git repository, we’ll have to specify that directory in the <code>NODE_VERSION</code> in the <strong class="bold">Environment variables</strong> section. Though SvelteKit only requires Node.js 16.14 or higher, we’ve specified version 18 as that is the current latest Long-Term<a id="_idIndexMarker186"/> Support version of SvelteKit as well as the version used throughout the development of this book. Once everything has been filled out appropriately, you can save and deploy the project!</p>
<p>Cloudflare will then check out your code and attempt to build it. If everything is successful, you’ll be provided with a URL pointing to your application. For reference, a version of the application we’ve created thus far is live at <a href="https://sveltekit-up-and-running.pages.dev/">https://sveltekit-up-and-running.pages.dev/</a>. Deploying an update to an application is as simple as pushing code to the appropriate branch in the project repository.</p>
<p>As you can see, deploying a SvelteKit application can be almost effortless once set up on serverless platforms such as Cloudflare Pages. The Vercel and Netlify adapters have similar processes, which you are encouraged<a id="_idIndexMarker187"/> to explore at your leisure. While our particular project ran into a slight issue with an included dependency requiring Node.js, this example hopefully demonstrated how using the right adapter can simplify deployments.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>adapter-static</h2>
<p>While we only ran into<a id="_idIndexMarker188"/> one minor problem with our previous adapter, we’ll most certainly run into problems with <code>adapter-static</code>. The reason for that is that this adapter is intended to only be used on platforms that can host static content – that is, platforms where no server backend logic exists. If you have a host that can serve static HTML, CSS, and JS, you can host an entire SvelteKit application there using this adapter. A common example is GitHub pages, but Cloudflare and many others also support this method. Hosting static applications has the added benefit of increased speed since no server backend exists to communicate with.</p>
<p>Since we won’t be able to get <code>adapter-static</code> working with our project, we won’t attempt to install it on our existing project. But it is still an adapter worth discussing. Just like other adapters, it is easily installed via this command:</p>
<pre class="source-code">
npm install -D @sveltejs/adapter-static</pre>
<p>And again, it can then be imported in <code>svelte.config.js</code>. This adapter varies from the others in that it prerenders the entire application. It is able to do this because we will insert <code>export let prerender = true;</code> at the lowest level layout of our application. In each case, this will be <code>src/routes/+layout.js</code>.</p>
<p>To customize the builds produced with this adapter, we’re provided with a few options. These options are passed to the adapter in <code>svelte.config.js</code>:</p>
<ul>
<li><code>pages</code> – A string value defaulting to <code>build</code> that determines where prerendered pages will be output to.</li>
<li><code>assets</code> – A string value defaulting to the value provided to <code>pages</code> that determines where static assets should be output to.</li>
<li><code>fallback</code> – A string value specifying<a id="_idIndexMarker189"/> a fallback file to use when SSR has been disabled sitewide. Disabling SSR application-wide enables <code>index.html</code>, <code>200.html</code>, or <code>404.html</code>.</li>
<li><code>precompress</code> – A Boolean value that determines whether files should be compressed using <code>brotli</code> and <code>gzip</code> compression algorithms.</li>
<li><code>strict</code> – A Boolean value that prevents the application from building if certain endpoints will not exist when prerendered. It can be useful to disable if your application makes use of pages that exist only in specific circumstances.</li>
</ul>
<p>If you’re interested in trying <code>adapter-static</code> for yourself, consider creating a new SvelteKit application using the <code>skeleton</code> template. You can try with the <em class="italic">Demo App</em>, but will run into issues<a id="_idIndexMarker190"/> with server routes unable to be prerendered. These can be removed to get it working, but if your goal is to simply see how the static adapter works, it will likely be easier to deploy from the <code>skeleton</code> template. Again, the steps for building a static application are fairly straightforward:</p>
<ol>
<li>Install the adapter with <code>npm install -</code><code>D @sveltejs/adapter-static</code>.</li>
<li>Import the adapter in <code>svelte.config.js</code>.</li>
<li>Ensure the application is entirely prerenderable by adding <code>export let prerender = true;</code> in <code>src/routes/+layout.js</code>.</li>
<li>Run the <code>npm run </code><code>build</code> command!</li>
</ol>
<p>Once your application has been built, you can simply copy it to anywhere that can serve static files. Of course, certain hosts may have their own requirements so be sure to read their documentation as well.</p>
<p>A great way to learn about SvelteKit is by working with it. If you don’t already have a personal website, consider creating one using the SvelteKit static adapter. Not only does it not require a database or backend but it can also be deployed to almost any hosting provider. If you’re wondering where to start, Josh Collinsworth created a fantastic project using the static adapter. It enables users to add blog posts using Markdown while still existing as a static site. This means that hosting can be done for free on platforms such as GitHub Pages. You can find a link to Josh’s project in the <em class="italic">Resources</em> section at the end of this chapter. While our project and many others cannot make use of <code>adapter-static</code> as they are not prerenderable, the value<a id="_idIndexMarker191"/> that this particular adapter provides for generating static sites is clear.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/>Summary</h1>
<p>Having covered how the SvelteKit build process works, we then observed how we can preview our builds locally. We also looked at how page options can affect our builds. We took what we learned about the build process and saw how we can tailor our application to various platforms by selecting the right adapter. The application we’ve built so far is best suited to Node.js environments but we’ve also seen how simple it is to deploy to Cloudflare Pages and platforms such as Netlify or Vercel. By using the correct adapter and development strategies, we can even turn our application into a static website. Now that you’ve seen how to prepare your application for different production environments, you can go forth and release your SvelteKit applications into the wild.</p>
<p>In the next chapter, we’ll learn how we can manipulate requests across our entire application through the use of hooks. We’ll also address how we can utilize these hooks to assist in managing errors. Because no application is perfect, we’ll address how SvelteKit lets us customize the user experience when issues do arise.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Resources</h1>
<ul>
<li><em class="italic">Svelte Society</em> – A central resource that provides many community-maintained Svelte-related projects including adapters: <a href="https://sveltesociety.dev/">https://sveltesociety.dev/</a></li>
<li><em class="italic">How Cloudflare Workers </em><em class="italic">Work</em>: <a href="https://developers.cloudflare.com/workers/learning/how-workers-works">https://developers.cloudflare.com/workers/learning/how-workers-works</a></li>
<li><em class="italic">SvelteKit Blog Starter</em> by Josh Collinsworth: <a href="https://github.com/josh-collinsworth/sveltekit-blog-starter">https://github.com/josh-collinsworth/sveltekit-blog-starter</a></li>
</ul>
</div>
</body></html>