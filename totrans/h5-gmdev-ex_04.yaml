- en: Chapter 4. Building the Untangle Game with Canvas and the Drawing API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*One new highlighted feature in HTML5 is the `canvas` element. We can treat
    it as a dynamic area where we can draw graphics and shapes with scripts.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Images in websites have been static for years. There are animated GIFs, but
    they cannot interact with visitors. Canvas is dynamic. We draw and modify the
    context in the Canvas, dynamically through the JavaScript drawing API. We can
    also add interaction to the Canvas and thus make games.*'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous two chapters, we discussed DOM-based game development with CSS3
    and a few HTML5 features. In the coming two chapters, we will focus on using new
    HTML5 features to create games. In this chapter, we will take a look at a core
    feature, Canvas, and some basic drawing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the HTML5 `canvas` element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a circle in Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines in the `canvas` element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with drawn objects in Canvas with mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting a line intersection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting the drag-n-drop feature in touch devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Untangle puzzle game is a game where players are given circles with some
    lines connecting them. The lines may intersect the others and the players need
    to drag the circles so that no line intersects anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot previews the game that we are going to achieve through
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Untangle Game with Canvas and the Drawing API](img/B04290_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also try the game at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://makzan.net/html5-games/untangle-wip-dragging/](http://makzan.net/html5-games/untangle-wip-dragging/)'
  prefs: []
  type: TYPE_NORMAL
- en: So let's start making our Canvas game from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the HTML5 canvas element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'W3C community states that the `canvas` element and the drawing functions are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A resolution-dependent bitmap canvas, which can be used for rendering graphs,
    game graphics, or other visual images on the fly.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `canvas` element contains context for drawing and the actual graphics and
    shapes are drawn by the JavaScript drawing API. There is one key difference between
    using `canvas` and the usual HTML DOM elements. Canvas is an immediate mode while
    DOM is a retained mode. We describe the DOM tree with elements and attributes,
    and the browser renders and tracks the objects for us. In Canvas, we have to manage
    all the attributes and rendering ourselves. The browser doesn't keep the information
    of what we draw. It only keeps the drawn pixel data.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a circle in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start our drawing in the Canvas from the basic shape—circle.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – drawing color circles in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s set up the new environment for the example. That is, an HTML
    file that will contain the `canvas` element, a jQuery library to help us in JavaScript,
    a JavaScript file containing the actual drawing logic, and a style sheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put the following HTML code into the `index.html` file. It is a basic HTML
    document containing the `canvas` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use CSS to set the background color of the Canvas inside `untangle.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `untangle.js` JavaScript file, we put a jQuery `document` `ready` function
    and draw a color circle inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `index.html` file in a web browser and we will get the following screenshot:![Time
    for action – drawing color circles in the Canvas](img/B04290_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have just created a simple **Canvas context** with circles on it. There
    are not many settings for the `canvas` element itself. We set the width and height
    of the Canvas, the same as we have fixed the dimensions of real drawing paper.
    Also, we assign an ID attribute to the Canvas for an easier reference in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Putting in fallback content when the web browser does not support the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not every web browser supports the `canvas` element. The `canvas` element provides
    an easy way to provide **fallback content** if the `canvas` element is not supported.
    The content also provides meaningful information for any screen reader too. Anything
    inside the open and close tags of the `canvas` element is the fallback content.
    This content is hidden if the web browser supports the element. Browsers that
    don't support `canvas` will instead display that fallback content. It is good
    practice to provide useful information in the fallback content. For instance,
    if the `canvas` tag's purpose is a dynamic picture, we may consider placing an
    `<img>` alternative there. Or we may also provide some links to modern web browsers
    for the visitor to upgrade their browser easily.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we draw in the Canvas, we actually call the drawing API of the **canvas
    rendering context**. You can think of the relationship of the Canvas and context
    as Canvas being the frame and context the real drawing surface. Currently, we
    have `2d`, `webgl`, and `webgl2` as the context options. In our example, we'll
    use the 2D drawing API by calling `getContext("2d")`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Drawing circles and shapes with the Canvas arc function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no circle function to draw a circle. The Canvas drawing API provides
    a function to draw different arcs, including the circle. The `arc` function accepts
    the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Arguments | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | The center point of the arc in the *x* axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | The center point of the arc in the *y* axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `radius` | The radius is the distance between the center point and the arc''s
    perimeter. When drawing a circle, a larger radius means a larger circle. |'
  prefs: []
  type: TYPE_TB
- en: '| `startAngle` | The starting point is an angle in radians. It defines where
    to start drawing the arc on the perimeter. |'
  prefs: []
  type: TYPE_TB
- en: '| `endAngle` | The ending point is an angle in radians. The arc is drawn from
    the position of the starting angle, to this end angle. |'
  prefs: []
  type: TYPE_TB
- en: '| `counter-clockwise` | This is a Boolean indicating the arc from `startingAngle`
    to `endingAngle` drawn in a clockwise or counter-clockwise direction.This is an
    optional argument with the default value `false`. |'
  prefs: []
  type: TYPE_TB
- en: Converting degrees to radians
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The angle arguments used in the `arc` function are in **radians** instead of
    **degrees**. If you are familiar with the degrees angle, you may need to convert
    the degrees into radians before putting the value into the arc function. We can
    convert the angle unit using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Executing the path drawing in the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are calling the `arc` function or other path drawing functions, we are
    not drawing the path immediately in the Canvas. Instead, we are adding it into
    a list of the paths. These paths will not be drawn until we execute the drawing
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two drawing executing commands: one command to fill the paths and
    the other to draw the stroke.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We fill the paths by calling the `fill` function and draw the stroke of the
    paths by calling the `stroke` function, which we will use later when drawing lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Beginning a path for each style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fill` and `stroke` functions fill and draw the paths in the Canvas but
    do not clear the list of paths. Take the following code snippet as an example.
    After filling our circle with the color red, we add other circles and fill them
    with green. What happens to the code is both the circles are filled with green,
    instead of only the new circle being filled by green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is because, when calling the second `fill` command, the list of paths in
    the Canvas contains both circles. Therefore, the `fill` command fills both circles
    with green and overrides the red color circle.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix this issue, we want to ensure we call `beginPath` before drawing
    a new shape every time.
  prefs: []
  type: TYPE_NORMAL
- en: The `beginPath` function empties the list of paths, so the next time we call
    the `fill` and `stroke` commands, they will only apply to all paths after the
    last `beginPath`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have just discussed a code snippet where we intended to draw two circles:
    one in red and the other in green. The code ends up drawing both circles in green.
    How can we add a `beginPath` command to the code so that it draws one red circle
    and one green circle correctly?'
  prefs: []
  type: TYPE_NORMAL
- en: Closing a path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `closePath` function will draw a straight line from the last point of the
    latest path to the first point of the path. This is called closing the path. If
    we are only going to fill the path and are not going to draw the stroke outline,
    the `closePath` function does not affect the result. The following screenshot
    compares the results on a half circle with one calling `closePath` and the other
    not calling `closePath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Closing a path](img/B04290_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Do we need to use the `closePath` function on the shape we are drawing
    if we just want to fill the color and not draw the outline stroke?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we need to use the `closePath` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it does not matter whether we use the `closePath` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping the circle drawing in a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing a circle is a common function that we will use a lot. It is better to
    create a function to draw a circle now instead of entering several code lines.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – putting the circle drawing code into a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make a function to draw the circle and then draw some circles in the
    Canvas. We are going to put code in different files to make the code simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `untangle.drawing.js` file in our code editor and put in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.data.js` file and put the following code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then open the `untangle.js` file. Replace the original code in the JavaScript
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the HTML file in the web browser to see the result:![Time for action –
    putting the circle drawing code into a function](img/B04290_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code of drawing circles is executed after the page is loaded and ready.
    We used a loop to draw several circles in random places in the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing code into files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are putting the code into different files. Currently, there are the `untangle.js`,
    `untangle.drawing.js`, and `untangle.data.js` files. The `untangle.js` is the
    entry point of the game. Then we put logic that is related to the context drawing
    into `untangle.drawing.js` and logic that's related to data manipulation into
    the `untangle.data.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `untangleGame` object as the global object that''s being accessed
    across all the files. At the beginning of each JavaScript file, we have the following
    code to create this object if it does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Generating random numbers in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In game development, we often use `random` functions. We may want to randomly
    summon a monster for the player to fight, we may want to randomly drop a reward
    when the player makes progress, and we may want a random number to be the result
    of rolling a dice. In this code, we place the circles randomly in the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a random number in JavaScript, we use the `Math.random()` function.
    There is no argument in the `random` function. It always returns a floating number
    between 0 and 1\. The number is equal or bigger than 0 and smaller than 1\. There
    are two common ways to use the `random` function. One way is to generate random
    numbers within a given range. The other way is generating a true or false value.
  prefs: []
  type: TYPE_NORMAL
- en: '| Usage | Code | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Getting a random integer between A and B | `Math.floor(Math.random()*B)+A`
    | `Math.floor()` function cuts the decimal point of the given number.Take `Math.floor(Math.random()*10)+5`
    as an example.`Math.random()` returns a decimal number between 0 to 0.9999….`Math.random()*10`
    is a decimal number between 0 to 9.9999….`Math.floor(Math.random()*10)` is an
    integer between 0 to 9.Finally, `Math.floor(Math.random()*10)` `+` `5` is an integer
    between 5 to 14. |'
  prefs: []
  type: TYPE_TB
- en: '| Getting a random Boolean | `(Math.random() > 0.495)` | `(Math.random()` `>`
    `0.495)` means 50 percent `false` and 50 percent `true`.We can further adjust
    the true/false ratio. `(Math.random()` `>` `0.7)` means almost 70 percent `false`
    and 30 percent `true`. |'
  prefs: []
  type: TYPE_TB
- en: Saving the circle position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are developing a DOM-based game, such as the games we built in previous
    chapters, we often put the game objects into DIV elements and accessed them later
    in code logic. It is a different story in the Canvas-based game development.
  prefs: []
  type: TYPE_NORMAL
- en: In order to access our game objects after they are drawn in the Canvas, we need
    to remember their states ourselves. Let's say now we want to know how many circles
    are drawn and where they are, and we will need an array to store their position.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – saving the circle position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `untangle.data.js` file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `circle` object definition code in the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need an array to store the circles'' positions. Add a new array to the
    `untangleGame` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While drawing every circle in the Canvas, we save the position of the circle
    in the `circles` array. Add the following line before calling the `drawCircle`
    function, inside the `createRandomCircles` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the steps, we should have the following code in the `untangle.data.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can test the code in the web browser. There is no visual difference between
    this code and the last example when drawing random circles in the Canvas. This
    is because we are saving the circles but have not changed any code that affects
    the appearance. We just make sure it looks the same and there are no new errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saved the position and radius of each circle. This is because Canvas drawing
    is an immediate mode. We cannot directly access the object drawn in the Canvas
    because there is no such information. All lines and shapes are drawn on the Canvas
    as pixels and we cannot access the lines or shapes as individual objects. Imagine
    that we are drawing on a real canvas. We cannot just move a house in an oil painting,
    and in the same way we cannot directly manipulate any drawn items in the `canvas`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a basic class definition in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use **object-oriented programming** in JavaScript. We can define some
    object structures for our use. The `Circle` object provides a data structure for
    us to easily store a collection of *x* and *y* positions and the radii.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the `Circle` object, we can create a new `Circle` instance with
    an *x*, *y*, and radius value using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more detailed usage on object-oriented programming in JavaScript, please
    check out the Mozilla Developer Center at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript)'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have drawn several circles randomly on the Canvas. They are in the same style
    and of the same size. How about we randomly draw the size of the circles? And
    fill the circles with different colors? Try modifying the code and then play with
    the drawing API.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have several circles here, so how about connecting them with lines? Let's
    draw a straight line between each circle.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – drawing straight lines between each circle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `index.html` file we just used in the circle-drawing example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the wording in h1 from **drawing circles in Canvas** to **drawing lines
    in Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `untangle.data.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define a `Line` class to store the information that we need for each line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and switch to the `untangle.drawing.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need two more variables. Add the following lines into the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add the following `drawLine` function into our code, after the existing `drawCircle`
    function in the `untangle.drawing.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we define a new function that iterates the circle list and draws a line
    between each pair of circles. Append the following code in the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we open the `untangle.js` file, and add the following code before
    the end of the jQuery document `ready` function, after we have called the `untangleGame.createRandomCircles`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test the code in the web browser. We should see there are lines connected to
    each randomly placed circle:![Time for action – drawing straight lines between
    each circle](img/B04290_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have enhanced our code with lines connecting each generated circle. You
    may find a working example at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://makzan.net/html5-games/untangle-wip-connect-lines/](http://makzan.net/html5-games/untangle-wip-connect-lines/)'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the way we saved the circle position, we have an array to save every
    line segment we draw. We declare a line class definition to store some essential
    information of a line segment. That is, we save the start and end point and the
    thickness of the line.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the line drawing API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some drawing APIs for us to draw and style the line stroke:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Line drawing functions | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `moveTo` | The `moveTo` function is like holding a pen in our hand and moving
    it on top of the paper without touching it with the pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `lineTo` | This function is like putting the pen down on the paper and drawing
    a straight line to the destination point. |'
  prefs: []
  type: TYPE_TB
- en: '| `lineWidth` | The `lineWidth` function sets the thickness of the strokes
    we draw afterwards. |'
  prefs: []
  type: TYPE_TB
- en: '| `stroke` | The `stroke` function is used to execute the drawing. We set up
    a collection of `moveTo`, `lineTo`, or styling functions and finally call the
    `stroke` function to execute it on the Canvas. |'
  prefs: []
  type: TYPE_TB
- en: We usually draw lines by using the `moveTo` and `lineTo` pairs. Just like in
    the real world, we move our pen on top of the paper to the starting point of a
    line and put down the pen to draw a line. Then, keep on drawing another line or
    move to the other position before drawing. This is exactly the flow in which we
    draw lines on the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We just demonstrated how to draw a simple line. We can set different line styles
    to lines in the Canvas. For more details on line styling, please read the styling
    guide in W3C at [http://www.w3.org/TR/2dcontext/#line-styles](http://www.w3.org/TR/2dcontext/#line-styles)
    and the Mozilla Developer Center at [https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors).
  prefs: []
  type: TYPE_NORMAL
- en: Using mouse events to interact with objects drawn in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have shown that we can draw shapes in the Canvas dynamically based
    on our logic. There is one part missing in the game development, that is, the
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we can drag the circles around on the Canvas, and the connected
    lines will follow the circles. In this section, we will add mouse events to the
    canvas to make our circles **draggable**.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – dragging the circles in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with our previous code. Open the `html5games.untangle.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need a function to clear all the drawings in the Canvas. Add the following
    function to the end of the `untangle.drawing.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need two more functions that draw all known circles and lines. Append
    the following code to the `untangle.drawing.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are done with the `untangle.drawing.js` file. Let''s switch to the `untangle.js`
    file. Inside the jQuery document-ready function, before the ending of the function,
    we add the following code, which creates a game loop to keep drawing the circles
    and lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before moving on to the input handling code implementation, let''s add the
    following code to the jQuery document ready function in the `untangle.js` file,
    which calls the `handleInput` function that we will define:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s time to implement our input handling logic. Switch to the `untangle.input.js`
    file and add the following code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser. There should be five circles with lines
    connecting them. Try dragging the circles. The dragged circle will follow the
    mouse cursor and the connected lines will follow too.![Time for action – dragging
    the circles in the Canvas](img/B04290_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have set up three mouse event listeners. They are the mouse down, move,
    and up events. We also created the game loop, which updates the Canvas drawing
    based on the new position of the circles. You can view the example''s current
    progress at: [http://makzan.net/html5-games/untangle-wip-dragging-basic/](http://makzan.net/html5-games/untangle-wip-dragging-basic/).'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting mouse events in circles in the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After discussing the difference between DOM-based development and Canvas-based
    development, we cannot directly listen to the mouse events of any shapes drawn
    in the Canvas. There is no such thing. We cannot monitor the event in any shapes
    drawn in the Canvas. We can only get the mouse event of the `canvas` element and
    calculate the relative position of the Canvas. Then we change the states of the
    game objects according to the mouse's position and finally redraw it on the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '*How do we know we are clicking on a circle?* We can use the **point-in-circle**
    formula. This is to check the distance between the center point of the circle
    and the mouse position. The mouse clicks on the circle when the distance is less
    than the circle''s radius. We use this formula to get the distance between two
    points: *Distance = (x2-x1)2 + (y2-y1)2*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph shows that when the distance between the center point and
    the mouse cursor is smaller than the radius, the cursor is in the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting mouse events in circles in the Canvas](img/B04290_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code we used explains how we can apply distance checking to know
    whether the mouse cursor is inside the circle in the mouse down event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that `Math.pow` is an expensive function that may hurt performance
    in some scenarios. If performance is a concern, we may use the bounding box collision
    checking, which we covered in [Chapter 2](ch02.html "Chapter 2. Getting Started
    with DOM-based Game Development"), *Getting Started with DOM-based Game Development*.
  prefs: []
  type: TYPE_NORMAL
- en: When we know that the mouse cursor is pressing the circle in the Canvas, we
    mark it as the targeted circle to be dragged on the mouse move event. During the
    mouse move event handler, we update the target dragged circle's position to the
    latest cursor position. When the mouse is up, we clear the target circle's reference.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Can we directly access an already drawn shape in the Canvas?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which method can we use to check whether a point is inside a circle?
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate of the point is smaller than the coordinate of the center of
    the circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The distance between the point and the center of the circle is smaller than
    the circle's radius.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *x* coordinate of the point is smaller than the circle's radius.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The distance between the point and the center of the circle is bigger than the
    circle's radius.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Game loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Getting Started with DOM-based Game Development"),
    *Getting Started with DOM-based Game Development*, we discussed the **game loop**
    approach. In the Ping Pong game, the game loop manipulates the keyboard input
    and updates the position of the DOM-based game objects.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the game loop is used to redraw the Canvas to present the later game states.
    If we do not redraw the Canvas after changing the states, say the position of
    the circles, we will not see it.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we drag the circle, we redraw the Canvas. The problem is the already drawn
    shapes on the Canvas won''t disappear automatically. We will keep adding new paths
    to the Canvas and finally mess up everything in the Canvas. The following screenshot
    is what will happen if we keep dragging the circles without clearing the Canvas
    on every redraw:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clearing the Canvas](img/B04290_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have saved all game statuses in JavaScript, we can safely clear the
    entire Canvas and draw the updated lines and circles with the latest game status.
    To clear the Canvas, we use the `clearRect` function provided by Canvas drawing
    API. The `clearRect` function clears a rectangle area by providing a rectangle
    clipping region. It accepts the following arguments as the clipping region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | The top left point of the rectangular clipping region, on the *x* axis.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `y` | The top left point of the rectangular clipping region, on the *y* axis.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `width` | The width of the rectangular region. |'
  prefs: []
  type: TYPE_TB
- en: '| `height` | The height of the rectangular region. |'
  prefs: []
  type: TYPE_TB
- en: 'The `x` and `y` values set the top left position of the region to be cleared.
    The `width` and `height` values define how much area is to be cleared. To clear
    the entire Canvas, we can provide (0,0) as the top left position and the width
    and height of the Canvas to the `clearRect` function. The following code clears
    all things drawn on the entire Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Can we clear a portion of the Canvas by using the clearRect function?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Does the following code clear things on the drawn Canvas?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detecting line intersection in the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have draggable circles and connected lines in the Canvas. Some lines intersect
    others and some do not. Now imagine we want to distinguish the intersected lines.
    We need some mathematics formula to check them and then thicken those intersected
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – distinguishing the intersected lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's increase the thickness of those intersected lines so we can distinguish
    them in the Canvas
  prefs: []
  type: TYPE_NORMAL
- en: Open the `untangle.drawing.js` file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the `thinLineThickness` variable as the default line thickness. We
    add the following code to define a thickness for bold lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.data.js` file. We create a function to check whether the
    given two lines intersect. Add the following functions to the end of the JavaScript
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s continue on with the `untangle.data.js` file. We define the following
    function to check whether our lines intersect and mark that line in bold. Append
    the following new function to the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we update the line intersection by adding the following function call
    in two places. Open the `untangle.js` file. Add the following line of code inside
    the jQuery document-ready function, probably before the game-loop function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`untangleGame.updateLineIntersection();`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, open the `untangle.input.js` file and add the same code inside the mouse
    move event handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is time to test the intersection in the web browser. When viewing the circles
    and lines in Canvas, the lines with an intersection should be thicker than those
    without an intersection. Try dragging the circles to change the intersection relationship
    and the lines will become thin or thick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have just added some code checking for line intersections to our existing
    circle-dragging example. The line intersection code involves some mathematical
    formula to get the **intersection point** of two lines and checks whether the
    point is inside the line segment we provide. You can view the example''s current
    progress at: [http://makzan.net/html5-games/untangle-wip-intersected-lines/](http://makzan.net/html5-games/untangle-wip-intersected-lines/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the mathematics element and see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether two line segments intersect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the intersection equation we learned from geometry, with two given
    lines in a general form, we can get the intersection point.
  prefs: []
  type: TYPE_NORMAL
- en: What is a **general form**? In our code, we have the starting point and ending
    point of a line in *x* and *y* coordinates. This is a **line segment** because
    it is just a segment part of the line in mathematics. A general form of a line
    is represented by `Ax` `+` `By` `=` `C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph explains the line segment on a line in a general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining whether two line segments intersect](img/B04290_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can transform the line segment with point 1 in **x1**, **y1** and point
    2 in **x2**, **y2** into general form by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a line equation `AX+BY` `=` `C` where `A`, `B`, `C` are known and
    `X` and `Y` are unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are checking two lines intersecting. We can transform both lines into a
    general form and get two line equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By putting the two general form equations together, `X` and `Y` are two variables
    that are unknown. We can then solve these two equations and get the intersection
    point of *x* and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `A1` `*` `B2` `-` `A2` `*` `B1` is zero, then two lines are parallel and
    there is no intersection point. Otherwise we get the interception point by using
    the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The intersection point of these general forms only provides that the two lines
    are not parallel to each other and will intersect each other at some point. It
    does not guarantee that the intersection point is on both line segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graphs show two possible results of the intersection point and
    the given line segments. The intersection point is not in between both line segments
    in the left graph; in this case, the two line segments are not intersecting with
    each other. In the right-hand side graph, the point is in between both line segments
    so these two line segments intersect with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining whether two line segments intersect](img/B04290_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we need another function named `isInBetween` to determine whether
    a provided value is in between the beginning and ending value. Then we use this
    function to check whether the intersection point from the equation is in between
    both line segments that we are checking.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the result of the lines intersection, we draw the thick line to
    indicate those intersected lines.
  prefs: []
  type: TYPE_NORMAL
- en: Adding touch support for tablets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drag-and-drop is a common gesture in touch devices in tablets and mobile devices.
    Currently, our game doesn't support these touch devices. We want to add touch
    support for our game in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the touch input support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s allow our tablet users to drag-n-drop our circles with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there is a selection highlighted in the `canvas` element in iOS
    devices. We want to get rid of this highlighted part to make the dragging interaction
    smooth. Add the following CSS rules to the `canvas` CSS. Please note that we use
    the `webkit` vendor prefix here because this rule is specific for `webkit` at
    the time of writing this book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `untangle.input.js file`. We bind the mouse events on the Canvas in
    the previous step. Now we add the support for touch events. We used `MouseEvent.pageX`
    and `pageY` to calculate the mouse position. With touch devices, there can be
    multiple touches. We modify our code to add the touch support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We modify the `mousemove` event similarly. We bind both the `mousemove` and
    `touchmove` events and calculate the touch position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the original `mouseup` event handler, we add the `touchend` handling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just added touch support to our untangle game. You may find the code and
    example at: [http://makzan.net/html5-games/untangle-wip-dragging/](http://makzan.net/html5-games/untangle-wip-dragging/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the CSS, we disable the default tap highlight by setting the `-webkit-tap-highlight-color`
    to transparent. We need the vendor prefix `-webkit-` because this is a WebKit-only
    rule especially designed for their touch devices.
  prefs: []
  type: TYPE_NORMAL
- en: Handling touches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We get the `touch` event object by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The touches array holds all the current touches on the screen. Since we are
    handling the touch events in jQuery, we need to access the `originalEvent` to
    access the touches because these are browser native events, instead of a jQuery
    event.
  prefs: []
  type: TYPE_NORMAL
- en: We only care about one touch in this game, that's why we only check the `touches[0]`
    parameter. We also confirm that `originalEvent.touches` exists before using the
    array notation, otherwise, the browser throws errors on non-touch devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we access the `pageX` property of either the `touch` object or the mouse
    event object. If the `touch` object presents, JavaScript uses the `touch.pageX`.
    Otherwise, JavaScript uses the mouse event''s `pageX` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Mouse move and Touch move
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We reuse the same logic for our `mousedown`/`touchstart`, `mousemove`/`touchmove`,
    and `mouseup`/`touchend` event. Often `mousedown` and `touchstart` share very
    similar logic for dragging starts. The `mouseup` and `touchend` events also share
    similar logic for dragging ends. The `mousemove` and `touchmove` events, however,
    have a subtle difference. In desktop devices with mouse input, the `mousemove`
    event is always firing whenever the mouse moves, regardless of the pressing of
    mouse button. That was why we needed to use a variable `targetCircleIndex` to
    determine whether the button was pressed and then selected a certain circle when
    the mouse moves. The `touchmove` event, on the other hand, happens only when a
    finger is actually down on the screen and dragging. This difference may sometimes
    affect the different ways we handle the logic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about drawing shapes and creating interaction
    with the new HTML5 `canvas` element and the drawing API.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you learned to draw circles and lines in the Canvas. We added
    mouse events and touch dragging interaction with the paths drawn in the Canvas.
    We determined line intersection with the help of mathematics formulas. We separated
    a complex code logic into different files to make the code maintainable. We divided
    the logic into data, drawing, and inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about basic drawing functions in the Canvas and the
    drawing API, you're ready to learn some advanced drawing techniques in Canvas.
    In the next chapter, we will create a puzzle solving game by continuing the code
    example. You will also learn more Canvas drawing techniques, such as drawing text,
    drawing images, and creating multiple drawing layers.
  prefs: []
  type: TYPE_NORMAL
