- en: Chapter 4. Building the Untangle Game with Canvas and the Drawing API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用Canvas和绘图API构建Untangle游戏
- en: '*One new highlighted feature in HTML5 is the `canvas` element. We can treat
    it as a dynamic area where we can draw graphics and shapes with scripts.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTML5中的一个新亮点特性是`canvas`元素。我们可以将其视为一个动态区域，在其中我们可以使用脚本绘制图形和形状。*'
- en: '*Images in websites have been static for years. There are animated GIFs, but
    they cannot interact with visitors. Canvas is dynamic. We draw and modify the
    context in the Canvas, dynamically through the JavaScript drawing API. We can
    also add interaction to the Canvas and thus make games.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*网站上的图像已经静态了好几年。有动画GIF，但它们不能与访客交互。Canvas是动态的。我们在Canvas中绘制和修改上下文，通过JavaScript绘图API动态地绘制。我们还可以向Canvas添加交互，从而制作游戏。*'
- en: In the previous two chapters, we discussed DOM-based game development with CSS3
    and a few HTML5 features. In the coming two chapters, we will focus on using new
    HTML5 features to create games. In this chapter, we will take a look at a core
    feature, Canvas, and some basic drawing techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们讨论了基于DOM的游戏开发，使用了CSS3和一些HTML5特性。在接下来的两章中，我们将专注于使用新的HTML5特性来创建游戏。在本章中，我们将探讨一个核心特性，Canvas，以及一些基本的绘图技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the HTML5 `canvas` element
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍HTML5 `canvas`元素
- en: Drawing a circle in Canvas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Canvas中绘制圆形
- en: Drawing lines in the `canvas` element
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`canvas`元素中绘制线条
- en: Interacting with drawn objects in Canvas with mouse events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标事件与Canvas中绘制的对象交互
- en: Detecting a line intersection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测线段交点
- en: Supporting the drag-n-drop feature in touch devices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在触摸设备上支持拖放功能
- en: The Untangle puzzle game is a game where players are given circles with some
    lines connecting them. The lines may intersect the others and the players need
    to drag the circles so that no line intersects anymore.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Untangle谜题游戏是一款玩家被给予一些线条连接的圆形的游戏。这些线条可能相交，玩家需要拖动圆形，以便没有线条再相交。
- en: 'The following screenshot previews the game that we are going to achieve through
    this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图预览了我们将通过本章实现的那个游戏：
- en: '![Building the Untangle Game with Canvas and the Drawing API](img/B04290_04_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![使用Canvas和绘图API构建Untangle游戏](img/B04290_04_01.jpg)'
- en: 'You can also try the game at the following URL:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在以下URL尝试游戏：
- en: '[http://makzan.net/html5-games/untangle-wip-dragging/](http://makzan.net/html5-games/untangle-wip-dragging/)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://makzan.net/html5-games/untangle-wip-dragging/](http://makzan.net/html5-games/untangle-wip-dragging/)'
- en: So let's start making our Canvas game from scratch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从头开始制作我们的Canvas游戏。
- en: Introducing the HTML5 canvas element
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍HTML5 `canvas`元素
- en: 'W3C community states that the `canvas` element and the drawing functions are
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: W3C社区表示，`canvas`元素和绘图函数如下：
- en: '*A resolution-dependent bitmap canvas, which can be used for rendering graphs,
    game graphics, or other visual images on the fly.*'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一个分辨率相关的位图Canvas，可以用于实时渲染图表、游戏图形或其他视觉图像。*'
- en: The `canvas` element contains context for drawing and the actual graphics and
    shapes are drawn by the JavaScript drawing API. There is one key difference between
    using `canvas` and the usual HTML DOM elements. Canvas is an immediate mode while
    DOM is a retained mode. We describe the DOM tree with elements and attributes,
    and the browser renders and tracks the objects for us. In Canvas, we have to manage
    all the attributes and rendering ourselves. The browser doesn't keep the information
    of what we draw. It only keeps the drawn pixel data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas`元素包含绘图上下文，实际的图形和形状是通过JavaScript绘图API绘制的。使用`canvas`与常规HTML DOM元素之间有一个关键区别。Canvas是即时模式，而DOM是保留模式。我们使用元素和属性描述DOM树，浏览器为我们渲染和跟踪对象。在Canvas中，我们必须自己管理所有属性和渲染。浏览器不会保留我们绘制的相关信息。它只保留绘制的像素数据。'
- en: Drawing a circle in the Canvas
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Canvas中绘制圆形
- en: Let's start our drawing in the Canvas from the basic shape—circle.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Canvas的基本形状——圆形开始我们的绘图。
- en: Time for action – drawing color circles in the Canvas
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——在Canvas中绘制彩色圆形
- en: 'First, let''s set up the new environment for the example. That is, an HTML
    file that will contain the `canvas` element, a jQuery library to help us in JavaScript,
    a JavaScript file containing the actual drawing logic, and a style sheet:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为示例设置新的环境。即一个包含`canvas`元素、一个jQuery库以帮助我们进行JavaScript编程、一个包含实际绘图逻辑的JavaScript文件以及一个样式表的HTML文件：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Put the following HTML code into the `index.html` file. It is a basic HTML
    document containing the `canvas` element:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下HTML代码放入`index.html`文件中。这是一个包含`canvas`元素的基本HTML文档：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use CSS to set the background color of the Canvas inside `untangle.css`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CSS在`untangle.css`中设置Canvas的背景颜色：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `untangle.js` JavaScript file, we put a jQuery `document` `ready` function
    and draw a color circle inside it:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`untangle.js` JavaScript文件中，我们放置了一个jQuery `document` `ready`函数并在其中绘制了一个颜色圆圈：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open the `index.html` file in a web browser and we will get the following screenshot:![Time
    for action – drawing color circles in the Canvas](img/B04290_04_02.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络浏览器中打开`index.html`文件，我们将得到以下截图：![动手实践 – 在Canvas中绘制颜色圆圈](img/B04290_04_02.jpg)
- en: '*What just happened?*'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We have just created a simple **Canvas context** with circles on it. There
    are not many settings for the `canvas` element itself. We set the width and height
    of the Canvas, the same as we have fixed the dimensions of real drawing paper.
    Also, we assign an ID attribute to the Canvas for an easier reference in JavaScript:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个简单的**Canvas上下文**，上面有圆圈。对于`canvas`元素本身并没有很多设置。我们设置了Canvas的宽度和高度，就像我们固定了真实绘制纸张的尺寸一样。此外，我们还为Canvas分配了一个ID属性，以便在JavaScript中更容易引用：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Putting in fallback content when the web browser does not support the Canvas
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当网络浏览器不支持Canvas时，添加回退内容
- en: Not every web browser supports the `canvas` element. The `canvas` element provides
    an easy way to provide **fallback content** if the `canvas` element is not supported.
    The content also provides meaningful information for any screen reader too. Anything
    inside the open and close tags of the `canvas` element is the fallback content.
    This content is hidden if the web browser supports the element. Browsers that
    don't support `canvas` will instead display that fallback content. It is good
    practice to provide useful information in the fallback content. For instance,
    if the `canvas` tag's purpose is a dynamic picture, we may consider placing an
    `<img>` alternative there. Or we may also provide some links to modern web browsers
    for the visitor to upgrade their browser easily.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个网络浏览器都支持`canvas`元素。`canvas`元素提供了一个简单的方法来提供**回退内容**，如果浏览器不支持`canvas`元素。该内容同时也为任何屏幕阅读器提供了有意义的信息。`canvas`元素打开和关闭标签内的任何内容都是回退内容。如果浏览器支持该元素，则此内容将被隐藏。在回退内容中提供有用信息是一种良好的做法。例如，如果`canvas`标签的目的是动态图片，我们可能考虑在那里放置一个`<img>`替代元素。或者，我们也可以提供一些链接到现代网络浏览器，以便访客可以轻松升级他们的浏览器。
- en: The Canvas context
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Canvas上下文
- en: When we draw in the Canvas, we actually call the drawing API of the **canvas
    rendering context**. You can think of the relationship of the Canvas and context
    as Canvas being the frame and context the real drawing surface. Currently, we
    have `2d`, `webgl`, and `webgl2` as the context options. In our example, we'll
    use the 2D drawing API by calling `getContext("2d")`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Canvas中绘制时，实际上是在调用**canvas渲染上下文**的绘图API。你可以将Canvas和上下文的关系想象为Canvas是框架，上下文是真正的绘图表面。目前，我们有`2d`、`webgl`和`webgl2`作为上下文选项。在我们的例子中，我们将通过调用`getContext("2d")`使用2D绘图API。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Drawing circles and shapes with the Canvas arc function
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Canvas弧线函数绘制圆和形状
- en: 'There is no circle function to draw a circle. The Canvas drawing API provides
    a function to draw different arcs, including the circle. The `arc` function accepts
    the following arguments:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有绘制圆的函数。Canvas绘图API提供了一个绘制不同弧线（包括圆）的函数。`arc`函数接受以下参数：
- en: '| Arguments | Discussion |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 讨论 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `X` | The center point of the arc in the *x* axis. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 弧在*x*轴上的中心点。 |'
- en: '| `Y` | The center point of the arc in the *y* axis. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `Y` | 弧在*y*轴上的中心点。 |'
- en: '| `radius` | The radius is the distance between the center point and the arc''s
    perimeter. When drawing a circle, a larger radius means a larger circle. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `radius` | 半径是中心点和弧线周界的距离。在绘制圆时，较大的半径意味着较大的圆。 |'
- en: '| `startAngle` | The starting point is an angle in radians. It defines where
    to start drawing the arc on the perimeter. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `startAngle` | 起始点是弧度。它定义了在圆周上开始绘制弧线的位置。 |'
- en: '| `endAngle` | The ending point is an angle in radians. The arc is drawn from
    the position of the starting angle, to this end angle. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `endAngle` | 结束点是弧度。弧线从起始角度的位置绘制到这个结束角度。 |'
- en: '| `counter-clockwise` | This is a Boolean indicating the arc from `startingAngle`
    to `endingAngle` drawn in a clockwise or counter-clockwise direction.This is an
    optional argument with the default value `false`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `counter-clockwise` | 这是一个布尔值，指示从 `startingAngle` 到 `endingAngle` 的弧是按顺时针还是逆时针方向绘制的。这是一个可选参数，默认值为
    `false`。|'
- en: Converting degrees to radians
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将角度转换为弧度
- en: 'The angle arguments used in the `arc` function are in **radians** instead of
    **degrees**. If you are familiar with the degrees angle, you may need to convert
    the degrees into radians before putting the value into the arc function. We can
    convert the angle unit using the following formula:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`arc` 函数中使用的角度参数是以 **弧度** 为单位的，而不是以 **度** 为单位。如果你熟悉度数角度，你可能需要在将值放入弧度函数之前将度数转换为弧度。我们可以使用以下公式来转换角度单位：'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Executing the path drawing in the Canvas
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布中执行路径绘制
- en: When we are calling the `arc` function or other path drawing functions, we are
    not drawing the path immediately in the Canvas. Instead, we are adding it into
    a list of the paths. These paths will not be drawn until we execute the drawing
    command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `arc` 函数或其他路径绘制函数时，我们并不是立即在画布中绘制路径。相反，我们将它添加到路径列表中。这些路径将不会绘制，直到我们执行绘制命令。
- en: 'There are two drawing executing commands: one command to fill the paths and
    the other to draw the stroke.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个绘图执行命令：一个用于填充路径，另一个用于绘制轮廓。
- en: 'We fill the paths by calling the `fill` function and draw the stroke of the
    paths by calling the `stroke` function, which we will use later when drawing lines:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `fill` 函数来填充路径，通过调用 `stroke` 函数来绘制路径的轮廓，我们将在绘制线条时使用它：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Beginning a path for each style
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每种样式开始路径
- en: 'The `fill` and `stroke` functions fill and draw the paths in the Canvas but
    do not clear the list of paths. Take the following code snippet as an example.
    After filling our circle with the color red, we add other circles and fill them
    with green. What happens to the code is both the circles are filled with green,
    instead of only the new circle being filled by green:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill` 和 `stroke` 函数用于填充和绘制画布中的路径，但不会清除路径列表。以下是一个代码片段示例。在用红色填充我们的圆之后，我们添加其他圆并用绿色填充它们。代码的结果是两个圆都被绿色填充，而不是只有新的圆被绿色填充：'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is because, when calling the second `fill` command, the list of paths in
    the Canvas contains both circles. Therefore, the `fill` command fills both circles
    with green and overrides the red color circle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在调用第二个 `fill` 命令时，画布中的路径列表包含两个圆。因此，`fill` 命令用绿色填充了两个圆，并覆盖了红色圆的颜色。
- en: In order to fix this issue, we want to ensure we call `beginPath` before drawing
    a new shape every time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们想要确保每次绘制新形状之前都调用 `beginPath`。
- en: The `beginPath` function empties the list of paths, so the next time we call
    the `fill` and `stroke` commands, they will only apply to all paths after the
    last `beginPath`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`beginPath` 函数清空路径列表，所以下次我们调用 `fill` 和 `stroke` 命令时，它们将只应用于最后一个 `beginPath`
    之后的所有路径。'
- en: Have a go hero
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: 'We have just discussed a code snippet where we intended to draw two circles:
    one in red and the other in green. The code ends up drawing both circles in green.
    How can we add a `beginPath` command to the code so that it draws one red circle
    and one green circle correctly?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了一个代码片段，我们原本打算绘制两个圆：一个红色，一个绿色。代码最终绘制了两个绿色的圆。我们如何向代码中添加一个 `beginPath` 命令，以便正确地绘制一个红色圆和一个绿色圆？
- en: Closing a path
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭合路径
- en: 'The `closePath` function will draw a straight line from the last point of the
    latest path to the first point of the path. This is called closing the path. If
    we are only going to fill the path and are not going to draw the stroke outline,
    the `closePath` function does not affect the result. The following screenshot
    compares the results on a half circle with one calling `closePath` and the other
    not calling `closePath`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`closePath` 函数将从最新路径的最后一个点到路径的第一个点绘制一条直线。这被称为闭合路径。如果我们只是要填充路径而不绘制轮廓线，`closePath`
    函数不会影响结果。以下截图比较了在半圆上调用 `closePath` 和不调用 `closePath` 的结果：'
- en: '![Closing a path](img/B04290_04_03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![闭合路径](img/B04290_04_03.jpg)'
- en: Pop quiz
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. Do we need to use the `closePath` function on the shape we are drawing
    if we just want to fill the color and not draw the outline stroke?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 如果我们只想填充颜色而不绘制轮廓线，我们是否需要在绘制的形状上使用 `closePath` 函数？
- en: Yes, we need to use the `closePath` function.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，我们需要使用 `closePath` 函数。
- en: No, it does not matter whether we use the `closePath` function.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，使用`closePath`函数并不重要。
- en: Wrapping the circle drawing in a function
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将圆形绘制封装在函数中
- en: Drawing a circle is a common function that we will use a lot. It is better to
    create a function to draw a circle now instead of entering several code lines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆形是一个我们将大量使用的常见函数。现在创建一个绘制圆形的函数，而不是输入几行代码会更好。
- en: Time for action – putting the circle drawing code into a function
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将圆形绘制代码放入函数中的行动时间
- en: 'Let''s make a function to draw the circle and then draw some circles in the
    Canvas. We are going to put code in different files to make the code simpler:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来绘制圆形，然后在画布上绘制一些圆形。我们将把代码放在不同的文件中，以使代码更简单：
- en: 'Open the `untangle.drawing.js` file in our code editor and put in the following
    code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码编辑器中打开`untangle.drawing.js`文件，并输入以下代码：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open the `untangle.data.js` file and put the following code into it:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`untangle.data.js`文件，并将以下代码放入其中：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then open the `untangle.js` file. Replace the original code in the JavaScript
    file with the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后打开`untangle.js`文件。用以下代码替换JavaScript文件中的原始代码：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Open the HTML file in the web browser to see the result:![Time for action –
    putting the circle drawing code into a function](img/B04290_04_04.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开HTML文件以查看结果：![将圆形绘制代码放入函数中的行动时间](img/B04290_04_04.jpg)
- en: '*What just happened?*'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The code of drawing circles is executed after the page is loaded and ready.
    We used a loop to draw several circles in random places in the Canvas.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制圆形的代码在页面加载并准备好后执行。我们使用循环在画布的随机位置绘制几个圆形。
- en: Dividing code into files
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码分割成文件
- en: We are putting the code into different files. Currently, there are the `untangle.js`,
    `untangle.drawing.js`, and `untangle.data.js` files. The `untangle.js` is the
    entry point of the game. Then we put logic that is related to the context drawing
    into `untangle.drawing.js` and logic that's related to data manipulation into
    the `untangle.data.js` file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将代码放入不同的文件。目前，有`untangle.js`、`untangle.drawing.js`和`untangle.data.js`文件。`untangle.js`是游戏的入口点。然后我们将与上下文绘制相关的逻辑放入`untangle.drawing.js`，将与数据处理相关的逻辑放入`untangle.data.js`文件。
- en: 'We use the `untangleGame` object as the global object that''s being accessed
    across all the files. At the beginning of each JavaScript file, we have the following
    code to create this object if it does not exist:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`untangleGame`对象作为跨所有文件访问的全局对象。在每个JavaScript文件的开头，我们有以下代码来创建此对象（如果它不存在的话）：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Generating random numbers in JavaScript
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中生成随机数
- en: In game development, we often use `random` functions. We may want to randomly
    summon a monster for the player to fight, we may want to randomly drop a reward
    when the player makes progress, and we may want a random number to be the result
    of rolling a dice. In this code, we place the circles randomly in the Canvas.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，我们经常使用`random`函数。我们可能想要随机召唤一个怪物让玩家战斗，我们可能想要在玩家取得进展时随机掉落奖励，或者我们可能想要一个随机数作为掷骰子的结果。在这段代码中，我们将圆形随机放置在画布上。
- en: To generate a random number in JavaScript, we use the `Math.random()` function.
    There is no argument in the `random` function. It always returns a floating number
    between 0 and 1\. The number is equal or bigger than 0 and smaller than 1\. There
    are two common ways to use the `random` function. One way is to generate random
    numbers within a given range. The other way is generating a true or false value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaScript中生成随机数，我们使用`Math.random()`函数。`random`函数没有参数。它总是返回一个介于0和1之间的浮点数。这个数等于或大于0且小于1。使用`random`函数有两种常见方式。一种是在给定范围内生成随机数。另一种是生成真或假值。
- en: '| Usage | Code | Discussion |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 用法 | 代码 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Getting a random integer between A and B | `Math.floor(Math.random()*B)+A`
    | `Math.floor()` function cuts the decimal point of the given number.Take `Math.floor(Math.random()*10)+5`
    as an example.`Math.random()` returns a decimal number between 0 to 0.9999….`Math.random()*10`
    is a decimal number between 0 to 9.9999….`Math.floor(Math.random()*10)` is an
    integer between 0 to 9.Finally, `Math.floor(Math.random()*10)` `+` `5` is an integer
    between 5 to 14. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 在A和B之间获取一个随机整数 | `Math.floor(Math.random()*B)+A` | `Math.floor()`函数截断给定数字的小数点。以`Math.floor(Math.random()*10)+5`为例。`Math.random()`返回一个介于0到0.9999…之间的十进制数。`Math.random()*10`是一个介于0到9.9999…之间的十进制数。`Math.floor(Math.random()*10)`是一个介于0到9之间的整数。最后，`Math.floor(Math.random()*10)`
    `+` `5`是一个介于5到14之间的整数。|'
- en: '| Getting a random Boolean | `(Math.random() > 0.495)` | `(Math.random()` `>`
    `0.495)` means 50 percent `false` and 50 percent `true`.We can further adjust
    the true/false ratio. `(Math.random()` `>` `0.7)` means almost 70 percent `false`
    and 30 percent `true`. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 获取一个随机的布尔值 | `(Math.random() > 0.495)` | `(Math.random() > 0.495)` 表示50%的`false`和50%的`true`。我们可以进一步调整真假比例。`(Math.random()
    > 0.7)` 表示大约70%的`false`和30%的`true`。|'
- en: Saving the circle position
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存圆的位置
- en: When we are developing a DOM-based game, such as the games we built in previous
    chapters, we often put the game objects into DIV elements and accessed them later
    in code logic. It is a different story in the Canvas-based game development.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发基于DOM的游戏时，例如我们在前几章中构建的游戏，我们通常将游戏对象放入DIV元素中，并在代码逻辑中稍后访问它们。在基于Canvas的游戏开发中则不同。
- en: In order to access our game objects after they are drawn in the Canvas, we need
    to remember their states ourselves. Let's say now we want to know how many circles
    are drawn and where they are, and we will need an array to store their position.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Canvas中绘制游戏对象后访问它们，我们需要自己记住它们的状态。假设现在我们想知道画了多少个圆以及它们的位置，我们需要一个数组来存储它们的位置。
- en: Time for action – saving the circle position
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 保存圆的位置
- en: Open the `untangle.data.js` file in the text editor.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`untangle.data.js`文件。
- en: 'Add the following `circle` object definition code in the JavaScript file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript文件中添加以下`circle`对象定义代码：
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need an array to store the circles'' positions. Add a new array to the
    `untangleGame` object:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个数组来存储圆的位置。向`untangleGame`对象中添加一个新数组：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While drawing every circle in the Canvas, we save the position of the circle
    in the `circles` array. Add the following line before calling the `drawCircle`
    function, inside the `createRandomCircles` function:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在Canvas中绘制每个圆时，我们在`circles`数组中保存圆的位置。在`createRandomCircles`函数中调用`drawCircle`函数之前，添加以下行：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After the steps, we should have the following code in the `untangle.data.js`
    file:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤完成后，我们应该在`untangle.data.js`文件中有以下代码：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we can test the code in the web browser. There is no visual difference between
    this code and the last example when drawing random circles in the Canvas. This
    is because we are saving the circles but have not changed any code that affects
    the appearance. We just make sure it looks the same and there are no new errors.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以测试网页中的代码。在Canvas中绘制随机圆时，此代码与上一个示例之间没有视觉上的差异。这是因为我们保存了圆，但没有更改任何影响外观的代码。我们只是确保它看起来相同，没有新的错误。
- en: '*What just happened?*'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We saved the position and radius of each circle. This is because Canvas drawing
    is an immediate mode. We cannot directly access the object drawn in the Canvas
    because there is no such information. All lines and shapes are drawn on the Canvas
    as pixels and we cannot access the lines or shapes as individual objects. Imagine
    that we are drawing on a real canvas. We cannot just move a house in an oil painting,
    and in the same way we cannot directly manipulate any drawn items in the `canvas`
    element.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存了每个圆的位置和半径。这是因为Canvas绘制是即时模式。我们无法直接访问Canvas中绘制的对象，因为没有这样的信息。所有线条和形状都作为像素绘制在Canvas上，我们无法将线条或形状作为单独的对象访问。想象一下我们在真正的画布上作画。我们无法只是移动油画中的房子，同样，我们也不能直接操作`canvas`元素中绘制的任何项目。
- en: Defining a basic class definition in JavaScript
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中定义基本类定义
- en: We can use **object-oriented programming** in JavaScript. We can define some
    object structures for our use. The `Circle` object provides a data structure for
    us to easily store a collection of *x* and *y* positions and the radii.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在JavaScript中使用**面向对象编程**。我们可以定义一些用于我们的对象结构。`Circle`对象为我们提供了一个数据结构，使我们能够轻松地存储*x*和*y*位置以及半径。
- en: 'After defining the `Circle` object, we can create a new `Circle` instance with
    an *x*, *y*, and radius value using the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`Circle`对象后，我们可以使用以下代码创建一个新的`Circle`实例，并使用*x*、*y*和半径值：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more detailed usage on object-oriented programming in JavaScript, please
    check out the Mozilla Developer Center at the following link:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript中面向对象编程的更详细用法，请查看以下链接的Mozilla开发者中心：
- en: '[https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript)'
- en: Have a go hero
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We have drawn several circles randomly on the Canvas. They are in the same style
    and of the same size. How about we randomly draw the size of the circles? And
    fill the circles with different colors? Try modifying the code and then play with
    the drawing API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Canvas上随机画了几个圆。它们具有相同的样式和大小。我们随机画圆的大小怎么样？用不同的颜色填充圆？尝试修改代码，然后玩玩绘图API。
- en: Drawing lines in the Canvas
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Canvas上画线
- en: Now we have several circles here, so how about connecting them with lines? Let's
    draw a straight line between each circle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们这里有几个圆，那么我们如何用线连接它们？让我们在每个圆之间画一条直线。
- en: Time for action – drawing straight lines between each circle
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 在每个圆之间画直线
- en: Open the `index.html` file we just used in the circle-drawing example.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在圆绘制示例中刚刚使用的`index.html`文件。
- en: Change the wording in h1 from **drawing circles in Canvas** to **drawing lines
    in Canvas**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将h1中的文字从**在Canvas上画圆**改为**在Canvas上画线**。
- en: Open the `untangle.data.js` JavaScript file.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`untangle.data.js` JavaScript文件。
- en: 'We define a `Line` class to store the information that we need for each line:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个`Line`类来存储我们需要的每条线的相关信息：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save the file and switch to the `untangle.drawing.js` file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并切换到`untangle.drawing.js`文件。
- en: 'We need two more variables. Add the following lines into the JavaScript file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个额外的变量。在JavaScript文件中添加以下行：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We add the following `drawLine` function into our code, after the existing `drawCircle`
    function in the `untangle.drawing.js` file.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`untangle.drawing.js`文件中现有的`drawCircle`函数之后添加以下`drawLine`函数。
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we define a new function that iterates the circle list and draws a line
    between each pair of circles. Append the following code in the JavaScript file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个新的函数，它遍历圆列表并在每对圆之间画一条线。在JavaScript文件中添加以下代码：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we open the `untangle.js` file, and add the following code before
    the end of the jQuery document `ready` function, after we have called the `untangleGame.createRandomCircles`
    function:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打开`untangle.js`文件，并在调用`untangleGame.createRandomCircles`函数之后，在jQuery文档`ready`函数的末尾添加以下代码：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Test the code in the web browser. We should see there are lines connected to
    each randomly placed circle:![Time for action – drawing straight lines between
    each circle](img/B04290_04_05.jpg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中测试代码。我们应该看到有线条连接到每个随机放置的圆：![动手时间 - 在每个圆之间画直线](img/B04290_04_05.jpg)
- en: '*What just happened?*'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We have enhanced our code with lines connecting each generated circle. You
    may find a working example at the following URL:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过连接每个生成的圆增强了我们的代码。你可以在以下URL找到一个工作示例：
- en: '[http://makzan.net/html5-games/untangle-wip-connect-lines/](http://makzan.net/html5-games/untangle-wip-connect-lines/)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://makzan.net/html5-games/untangle-wip-connect-lines/](http://makzan.net/html5-games/untangle-wip-connect-lines/)'
- en: Similar to the way we saved the circle position, we have an array to save every
    line segment we draw. We declare a line class definition to store some essential
    information of a line segment. That is, we save the start and end point and the
    thickness of the line.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们保存圆位置的方式类似，我们有一个数组来保存我们绘制的每条线段。我们声明一个线段类定义来存储线段的一些基本信息。也就是说，我们保存起点和终点以及线的粗细。
- en: Introducing the line drawing API
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍线条绘制API
- en: 'There are some drawing APIs for us to draw and style the line stroke:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些绘图API可以用来绘制和样式化线条：
- en: '| Line drawing functions | Discussion |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 线条绘制函数 | 讨论 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `moveTo` | The `moveTo` function is like holding a pen in our hand and moving
    it on top of the paper without touching it with the pen. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `moveTo` | `moveTo`函数就像我们手里拿着笔，在纸上移动它，但不碰触纸面。|'
- en: '| `lineTo` | This function is like putting the pen down on the paper and drawing
    a straight line to the destination point. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `lineTo` | 这个函数就像把笔放在纸上，然后画一条直线到目标点。|'
- en: '| `lineWidth` | The `lineWidth` function sets the thickness of the strokes
    we draw afterwards. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `lineWidth` | `lineWidth`函数设置我们之后绘制的线条的粗细。|'
- en: '| `stroke` | The `stroke` function is used to execute the drawing. We set up
    a collection of `moveTo`, `lineTo`, or styling functions and finally call the
    `stroke` function to execute it on the Canvas. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `stroke` | `stroke`函数用于执行绘图。我们设置一个包含`moveTo`、`lineTo`或样式函数的集合，并最终调用`stroke`函数在Canvas上执行。|'
- en: We usually draw lines by using the `moveTo` and `lineTo` pairs. Just like in
    the real world, we move our pen on top of the paper to the starting point of a
    line and put down the pen to draw a line. Then, keep on drawing another line or
    move to the other position before drawing. This is exactly the flow in which we
    draw lines on the Canvas.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用`moveTo`和`lineTo`对来绘制线条。就像在现实世界中一样，我们在纸上移动我们的笔到线条的起点并放下笔来绘制线条。然后，继续绘制另一条线条或移动到另一个位置再绘制。这正是我们在画布上绘制线条的流程。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We just demonstrated how to draw a simple line. We can set different line styles
    to lines in the Canvas. For more details on line styling, please read the styling
    guide in W3C at [http://www.w3.org/TR/2dcontext/#line-styles](http://www.w3.org/TR/2dcontext/#line-styles)
    and the Mozilla Developer Center at [https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚演示了如何绘制一条简单的线条。我们可以为画布中的线条设置不同的样式。有关线条样式的更多详细信息，请参阅W3C的样式指南[http://www.w3.org/TR/2dcontext/#line-styles](http://www.w3.org/TR/2dcontext/#line-styles)和Mozilla开发者中心的教程[https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors)。
- en: Using mouse events to interact with objects drawn in the Canvas
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用鼠标事件与画布中绘制的对象交互
- en: So far, we have shown that we can draw shapes in the Canvas dynamically based
    on our logic. There is one part missing in the game development, that is, the
    input.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了我们可以根据我们的逻辑动态地在画布中绘制形状。游戏开发中缺少的一部分是输入。
- en: Now, imagine that we can drag the circles around on the Canvas, and the connected
    lines will follow the circles. In this section, we will add mouse events to the
    canvas to make our circles **draggable**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们可以在画布上拖动圆圈，并且连接的线条会跟随圆圈移动。在本节中，我们将向画布添加鼠标事件以使我们的圆圈**可拖动**。
- en: Time for action – dragging the circles in the Canvas
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在画布中拖动圆圈
- en: Let's continue with our previous code. Open the `html5games.untangle.js` file.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用之前的代码。打开`html5games.untangle.js`文件。
- en: 'We need a function to clear all the drawings in the Canvas. Add the following
    function to the end of the `untangle.drawing.js` file:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个函数来清除画布上的所有绘制内容。将以下函数添加到`untangle.drawing.js`文件的末尾：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also need two more functions that draw all known circles and lines. Append
    the following code to the `untangle.drawing.js` file:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要两个额外的函数来绘制所有已知的圆圈和线条。将以下代码添加到`untangle.drawing.js`文件中：
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are done with the `untangle.drawing.js` file. Let''s switch to the `untangle.js`
    file. Inside the jQuery document-ready function, before the ending of the function,
    we add the following code, which creates a game loop to keep drawing the circles
    and lines:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了`untangle.drawing.js`文件。让我们切换到`untangle.js`文件。在jQuery文档就绪函数内部，在函数结束之前，我们添加以下代码，它创建了一个游戏循环以持续绘制圆圈和线条：
- en: '[PRE25]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before moving on to the input handling code implementation, let''s add the
    following code to the jQuery document ready function in the `untangle.js` file,
    which calls the `handleInput` function that we will define:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续实现输入处理代码之前，让我们将以下代码添加到`untangle.js`文件中的jQuery文档就绪函数中，该代码调用我们将定义的`handleInput`函数：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It''s time to implement our input handling logic. Switch to the `untangle.input.js`
    file and add the following code to the file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候实现我们的输入处理逻辑了。切换到`untangle.input.js`文件，并将以下代码添加到文件中：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Open `index.html` in a web browser. There should be five circles with lines
    connecting them. Try dragging the circles. The dragged circle will follow the
    mouse cursor and the connected lines will follow too.![Time for action – dragging
    the circles in the Canvas](img/B04290_04_06.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开`index.html`。应该有五个圆圈，它们通过线条连接。尝试拖动圆圈。被拖动的圆圈将跟随鼠标光标移动，并且连接的线条也会随之移动。![行动时间
    – 在画布中拖动圆圈](img/B04290_04_06.jpg)
- en: '*What just happened?*'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**发生了什么？**'
- en: 'We have set up three mouse event listeners. They are the mouse down, move,
    and up events. We also created the game loop, which updates the Canvas drawing
    based on the new position of the circles. You can view the example''s current
    progress at: [http://makzan.net/html5-games/untangle-wip-dragging-basic/](http://makzan.net/html5-games/untangle-wip-dragging-basic/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了三个鼠标事件监听器。它们是鼠标按下、移动和抬起事件。我们还创建了游戏循环，它根据圆圈的新位置更新画布绘制。您可以在以下位置查看示例的当前进度：[http://makzan.net/html5-games/untangle-wip-dragging-basic/](http://makzan.net/html5-games/untangle-wip-dragging-basic/)。
- en: Detecting mouse events in circles in the Canvas
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布中的圆圈上检测鼠标事件
- en: After discussing the difference between DOM-based development and Canvas-based
    development, we cannot directly listen to the mouse events of any shapes drawn
    in the Canvas. There is no such thing. We cannot monitor the event in any shapes
    drawn in the Canvas. We can only get the mouse event of the `canvas` element and
    calculate the relative position of the Canvas. Then we change the states of the
    game objects according to the mouse's position and finally redraw it on the Canvas.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了基于DOM的开发和基于Canvas的开发之间的区别后，我们无法直接监听在画布中绘制的任何形状的鼠标事件。不存在这样的事情。我们无法监听在画布中绘制的任何形状的事件。我们只能获取
    `canvas` 元素的鼠标事件，并计算Canvas的相对位置。然后根据鼠标的位置更改游戏对象的状态，最后在画布上重新绘制。
- en: '*How do we know we are clicking on a circle?* We can use the **point-in-circle**
    formula. This is to check the distance between the center point of the circle
    and the mouse position. The mouse clicks on the circle when the distance is less
    than the circle''s radius. We use this formula to get the distance between two
    points: *Distance = (x2-x1)2 + (y2-y1)2*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们如何知道我们点击的是圆？* 我们可以使用 **点在圆内** 的公式。这是检查圆的中心点和鼠标位置之间的距离。当距离小于圆的半径时，鼠标点击圆。我们使用这个公式来获取两点之间的距离：*距离
    = (x2-x1)² + (y2-y1)²*。'
- en: 'The following graph shows that when the distance between the center point and
    the mouse cursor is smaller than the radius, the cursor is in the circle:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示，当中心点和鼠标光标之间的距离小于半径时，光标位于圆内：
- en: '![Detecting mouse events in circles in the Canvas](img/B04290_04_07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![在画布中检测圆的鼠标事件](img/B04290_04_07.jpg)'
- en: 'The following code we used explains how we can apply distance checking to know
    whether the mouse cursor is inside the circle in the mouse down event handler:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的以下代码解释了如何在鼠标按下事件处理程序中应用距离检查，以确定鼠标光标是否在圆内：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that `Math.pow` is an expensive function that may hurt performance
    in some scenarios. If performance is a concern, we may use the bounding box collision
    checking, which we covered in [Chapter 2](ch02.html "Chapter 2. Getting Started
    with DOM-based Game Development"), *Getting Started with DOM-based Game Development*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Math.pow` 是一个昂贵的函数，可能在某些场景中损害性能。如果性能是一个关注点，我们可能使用边界框碰撞检测，这在[第2章](ch02.html
    "第2章. 基于DOM的游戏开发入门")中有所介绍，*基于DOM的游戏开发入门*。
- en: When we know that the mouse cursor is pressing the circle in the Canvas, we
    mark it as the targeted circle to be dragged on the mouse move event. During the
    mouse move event handler, we update the target dragged circle's position to the
    latest cursor position. When the mouse is up, we clear the target circle's reference.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道鼠标光标正在按下画布中的圆时，我们将其标记为目标圆，以便在鼠标移动事件中拖动。在鼠标移动事件处理程序中，我们将目标拖动圆的位置更新为最新的光标位置。当鼠标抬起时，我们清除目标圆的引用。
- en: Pop quiz
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Can we directly access an already drawn shape in the Canvas?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 我们能否直接访问在画布中已经绘制的形状？
- en: 'Yes'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的
- en: 'No'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可以
- en: Q2\. Which method can we use to check whether a point is inside a circle?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 我们可以使用哪种方法来检查一个点是否在圆内？
- en: The coordinate of the point is smaller than the coordinate of the center of
    the circle.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点的坐标小于圆心的坐标。
- en: The distance between the point and the center of the circle is smaller than
    the circle's radius.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点和圆心之间的距离小于圆的半径。
- en: The *x* coordinate of the point is smaller than the circle's radius.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点的 *x* 坐标小于圆的半径。
- en: The distance between the point and the center of the circle is bigger than the
    circle's radius.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点和圆心之间的距离大于圆的半径。
- en: Game loop
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏循环
- en: In [Chapter 2](ch02.html "Chapter 2. Getting Started with DOM-based Game Development"),
    *Getting Started with DOM-based Game Development*, we discussed the **game loop**
    approach. In the Ping Pong game, the game loop manipulates the keyboard input
    and updates the position of the DOM-based game objects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 基于DOM的游戏开发入门")，*基于DOM的游戏开发入门*中，我们讨论了 **游戏循环** 方法。在乒乓球游戏中，游戏循环处理键盘输入并更新基于DOM的游戏对象的位置。
- en: Here, the game loop is used to redraw the Canvas to present the later game states.
    If we do not redraw the Canvas after changing the states, say the position of
    the circles, we will not see it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，游戏循环被用来重新绘制画布以展示后续的游戏状态。如果我们改变状态后不重新绘制画布，比如圆的位置，我们就看不到它。
- en: Clearing the Canvas
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除画布
- en: 'When we drag the circle, we redraw the Canvas. The problem is the already drawn
    shapes on the Canvas won''t disappear automatically. We will keep adding new paths
    to the Canvas and finally mess up everything in the Canvas. The following screenshot
    is what will happen if we keep dragging the circles without clearing the Canvas
    on every redraw:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拖动圆时，我们会重新绘制 Canvas。问题是 Canvas 上已经绘制的形状不会自动消失。我们将继续向 Canvas 添加新的路径，最终搞乱 Canvas
    上的所有东西。以下截图是如果我们不断拖动圆而不在每次重新绘制时清除 Canvas 会发生的情况：
- en: '![Clearing the Canvas](img/B04290_04_10.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![清除 Canvas](img/B04290_04_10.jpg)'
- en: 'Since we have saved all game statuses in JavaScript, we can safely clear the
    entire Canvas and draw the updated lines and circles with the latest game status.
    To clear the Canvas, we use the `clearRect` function provided by Canvas drawing
    API. The `clearRect` function clears a rectangle area by providing a rectangle
    clipping region. It accepts the following arguments as the clipping region:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将所有游戏状态保存在 JavaScript 中，我们可以安全地清除整个 Canvas，并使用最新的游戏状态绘制更新的线和圆。要清除 Canvas，我们使用
    Canvas 绘图 API 提供的 `clearRect` 函数。`clearRect` 函数通过提供一个矩形裁剪区域来清除矩形区域。它接受以下参数作为裁剪区域：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| Argument | Definition |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 |'
- en: '| --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x` | The top left point of the rectangular clipping region, on the *x* axis.
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 矩形裁剪区域的左上角点，位于 *x* 轴上。 |'
- en: '| `y` | The top left point of the rectangular clipping region, on the *y* axis.
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `y` | 矩形裁剪区域的左上角点，位于 *y* 轴上。 |'
- en: '| `width` | The width of the rectangular region. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `width` | 矩形区域的宽度。 |'
- en: '| `height` | The height of the rectangular region. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `height` | 矩形区域的宽度。 |'
- en: 'The `x` and `y` values set the top left position of the region to be cleared.
    The `width` and `height` values define how much area is to be cleared. To clear
    the entire Canvas, we can provide (0,0) as the top left position and the width
    and height of the Canvas to the `clearRect` function. The following code clears
    all things drawn on the entire Canvas:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 值设置要清除的区域左上角的位置。`width` 和 `height` 值定义要清除的区域大小。要清除整个 Canvas，我们可以将
    (0,0) 作为左上角位置，并将 Canvas 的宽度和高度提供给 `clearRect` 函数。以下代码清除整个 Canvas 上绘制的所有内容：'
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Pop quiz
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Can we clear a portion of the Canvas by using the clearRect function?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 我们能否使用 `clearRect` 函数清除 Canvas 的一部分？
- en: 'Yes'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'No'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Q2\. Does the following code clear things on the drawn Canvas?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 以下代码是否清除绘制在 Canvas 上的内容？
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Yes'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'No'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Detecting line intersection in the Canvas
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Canvas 中检测线段相交
- en: We have draggable circles and connected lines in the Canvas. Some lines intersect
    others and some do not. Now imagine we want to distinguish the intersected lines.
    We need some mathematics formula to check them and then thicken those intersected
    lines.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Canvas 中，我们有可拖动的圆和连接的线。有些线段相交，有些则不相交。现在想象一下，我们想要区分相交的线段。我们需要一些数学公式来检查它们，然后加粗那些相交的线段。
- en: Time for action – distinguishing the intersected lines
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 区分相交的线段
- en: Let's increase the thickness of those intersected lines so we can distinguish
    them in the Canvas
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加相交线段的粗细，以便在 Canvas 中区分它们
- en: Open the `untangle.drawing.js` file in the text editor.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `untangle.drawing.js` 文件。
- en: 'We have the `thinLineThickness` variable as the default line thickness. We
    add the following code to define a thickness for bold lines:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有 `thinLineThickness` 变量作为默认线粗细。我们添加以下代码来定义粗体线的粗细：
- en: '[PRE32]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open the `untangle.data.js` file. We create a function to check whether the
    given two lines intersect. Add the following functions to the end of the JavaScript
    file:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `untangle.data.js` 文件。我们创建一个函数来检查给定的两条线是否相交。将以下函数添加到 JavaScript 文件的末尾：
- en: '[PRE33]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s continue on with the `untangle.data.js` file. We define the following
    function to check whether our lines intersect and mark that line in bold. Append
    the following new function to the end of the file:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续 `untangle.data.js` 文件。我们定义以下函数来检查我们的线段是否相交，并用粗体标记该线段。将以下新函数追加到文件末尾：
- en: '[PRE34]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we update the line intersection by adding the following function call
    in two places. Open the `untangle.js` file. Add the following line of code inside
    the jQuery document-ready function, probably before the game-loop function:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在两个地方更新线段相交。打开 `untangle.js` 文件。在 jQuery 文档就绪函数中添加以下代码行，可能是在游戏循环函数之前：
- en: '`untangleGame.updateLineIntersection();`'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`untangleGame.updateLineIntersection();`'
- en: Then, open the `untangle.input.js` file and add the same code inside the mouse
    move event handler.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `untangle.input.js` 文件，并在鼠标移动事件处理程序中添加相同的代码。
- en: It is time to test the intersection in the web browser. When viewing the circles
    and lines in Canvas, the lines with an intersection should be thicker than those
    without an intersection. Try dragging the circles to change the intersection relationship
    and the lines will become thin or thick.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候在网页浏览器中测试交点了。当在Canvas中查看圆和线时，有交点的线应该比没有交点的线更粗。尝试拖动圆来改变交点关系，线将变细或变粗。
- en: '*What just happened?*'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We have just added some code checking for line intersections to our existing
    circle-dragging example. The line intersection code involves some mathematical
    formula to get the **intersection point** of two lines and checks whether the
    point is inside the line segment we provide. You can view the example''s current
    progress at: [http://makzan.net/html5-games/untangle-wip-intersected-lines/](http://makzan.net/html5-games/untangle-wip-intersected-lines/).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们现有的圆拖动示例中添加了一些检查线段交点的代码。线段交点代码涉及一些数学公式来获取两条直线的**交点**，并检查该点是否在我们提供的线段内。您可以在以下位置查看示例的当前进度：[http://makzan.net/html5-games/untangle-wip-intersected-lines/](http://makzan.net/html5-games/untangle-wip-intersected-lines/)。
- en: Let's look at the mathematics element and see how it works.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数学元素，看看它是如何工作的。
- en: Determining whether two line segments intersect
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 判断两条线段是否相交
- en: According to the intersection equation we learned from geometry, with two given
    lines in a general form, we can get the intersection point.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们从几何学中学到的交点方程，给定两条通用形式的直线，我们可以得到交点。
- en: What is a **general form**? In our code, we have the starting point and ending
    point of a line in *x* and *y* coordinates. This is a **line segment** because
    it is just a segment part of the line in mathematics. A general form of a line
    is represented by `Ax` `+` `By` `=` `C`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**通用形式**？在我们的代码中，我们有一个线段的起点和终点在 *x* 和 *y* 坐标中。这是一个**线段**，因为它只是数学中线的一部分。直线的通用形式表示为
    `Ax` `+` `By` `=` `C`。
- en: 'The following graph explains the line segment on a line in a general form:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表以通用形式解释了直线上的线段：
- en: '![Determining whether two line segments intersect](img/B04290_04_08.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![判断两条线段是否相交](img/B04290_04_08.jpg)'
- en: 'We can transform the line segment with point 1 in **x1**, **y1** and point
    2 in **x2**, **y2** into general form by the following equation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方程将点1在**x1**、**y1**和点2在**x2**、**y2**的线段转换为通用形式：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we have a line equation `AX+BY` `=` `C` where `A`, `B`, `C` are known and
    `X` and `Y` are unknown.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个直线方程 `AX+BY` `=` `C`，其中 `A`、`B`、`C` 是已知的，而 `X` 和 `Y` 是未知的。
- en: 'We are checking two lines intersecting. We can transform both lines into a
    general form and get two line equations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检查两条直线是否相交。我们可以将两条直线都转换为通用形式，并得到两个直线方程：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By putting the two general form equations together, `X` and `Y` are two variables
    that are unknown. We can then solve these two equations and get the intersection
    point of *x* and *y*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将两个通用形式方程组合起来，`X` 和 `Y` 是两个未知变量。然后我们可以解这两个方程，得到 *x* 和 *y* 的交点。
- en: 'If `A1` `*` `B2` `-` `A2` `*` `B1` is zero, then two lines are parallel and
    there is no intersection point. Otherwise we get the interception point by using
    the following equation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `A1` `*` `B2` `-` `A2` `*` `B1` 为零，则两条直线平行，没有交点。否则，我们可以使用以下方程得到交点：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The intersection point of these general forms only provides that the two lines
    are not parallel to each other and will intersect each other at some point. It
    does not guarantee that the intersection point is on both line segments.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通用形式的交点仅表明两条直线不平行，并且将在某一点相交。这并不保证交点位于两条线段上。
- en: 'The following graphs show two possible results of the intersection point and
    the given line segments. The intersection point is not in between both line segments
    in the left graph; in this case, the two line segments are not intersecting with
    each other. In the right-hand side graph, the point is in between both line segments
    so these two line segments intersect with each other:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了交点和给定线段可能的两种结果。在左图中，交点不在两个线段之间；在这种情况下，两个线段没有相交。在右图中，点位于两个线段之间，因此这两个线段相交：
- en: '![Determining whether two line segments intersect](img/B04290_04_09.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![判断两条线段是否相交](img/B04290_04_09.jpg)'
- en: Therefore, we need another function named `isInBetween` to determine whether
    a provided value is in between the beginning and ending value. Then we use this
    function to check whether the intersection point from the equation is in between
    both line segments that we are checking.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要另一个名为`isInBetween`的函数来确定提供的值是否在起始值和结束值之间。然后我们使用这个函数来检查方程的交点是否在我们检查的两个线段之间。
- en: After getting the result of the lines intersection, we draw the thick line to
    indicate those intersected lines.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在得到线段交点的结果后，我们画一条粗线来指示那些相交的线。
- en: Adding touch support for tablets
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为平板电脑添加触摸支持
- en: Drag-and-drop is a common gesture in touch devices in tablets and mobile devices.
    Currently, our game doesn't support these touch devices. We want to add touch
    support for our game in this section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放是平板电脑和移动设备中触摸设备的常见手势。目前，我们的游戏不支持这些触摸设备。我们想在本文档的这一节中为我们的游戏添加触摸支持。
- en: Time for action – adding the touch input support
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加触摸输入支持
- en: 'Let''s allow our tablet users to drag-n-drop our circles with the following
    steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的平板用户通过以下步骤拖放我们的圆圈：
- en: 'By default, there is a selection highlighted in the `canvas` element in iOS
    devices. We want to get rid of this highlighted part to make the dragging interaction
    smooth. Add the following CSS rules to the `canvas` CSS. Please note that we use
    the `webkit` vendor prefix here because this rule is specific for `webkit` at
    the time of writing this book:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，iOS设备中的`canvas`元素有一个选区高亮显示。我们想要去掉这个高亮部分，以使拖动交互更平滑。请将以下CSS规则添加到`canvas`
    CSS中。请注意，我们在这里使用`webkit`供应商前缀，因为这个规则在撰写本书时是特定于`webkit`的：
- en: '[PRE38]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Open the `untangle.input.js file`. We bind the mouse events on the Canvas in
    the previous step. Now we add the support for touch events. We used `MouseEvent.pageX`
    and `pageY` to calculate the mouse position. With touch devices, there can be
    multiple touches. We modify our code to add the touch support:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`untangle.input.js`文件。我们在上一步中在Canvas上绑定了鼠标事件。现在我们添加了对触摸事件的支持。我们使用了`MouseEvent.pageX`和`pageY`来计算鼠标位置。对于触摸设备，可能会有多个触摸。我们修改了我们的代码来添加触摸支持：
- en: '[PRE39]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We modify the `mousemove` event similarly. We bind both the `mousemove` and
    `touchmove` events and calculate the touch position:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们类似地修改了`mousemove`事件。我们绑定了`mousemove`和`touchmove`事件，并计算触摸位置：
- en: '[PRE40]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the original `mouseup` event handler, we add the `touchend` handling:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于原始的`mouseup`事件处理器，我们添加了`touchend`处理：
- en: '[PRE41]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*What just happened?*'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We just added touch support to our untangle game. You may find the code and
    example at: [http://makzan.net/html5-games/untangle-wip-dragging/](http://makzan.net/html5-games/untangle-wip-dragging/).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为untangle游戏添加了触摸支持。你可以在以下位置找到代码和示例：[http://makzan.net/html5-games/untangle-wip-dragging/](http://makzan.net/html5-games/untangle-wip-dragging/)。
- en: In the CSS, we disable the default tap highlight by setting the `-webkit-tap-highlight-color`
    to transparent. We need the vendor prefix `-webkit-` because this is a WebKit-only
    rule especially designed for their touch devices.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，我们通过将`-webkit-tap-highlight-color`设置为透明来禁用默认的点击高亮。我们需要使用供应商前缀`-webkit-`，因为这个规则仅适用于WebKit，特别是为他们的触摸设备特别设计的。
- en: Handling touches
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理触摸
- en: 'We get the `touch` event object by using the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码获取`touch`事件对象：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The touches array holds all the current touches on the screen. Since we are
    handling the touch events in jQuery, we need to access the `originalEvent` to
    access the touches because these are browser native events, instead of a jQuery
    event.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸数组包含屏幕上所有的当前触摸。由于我们在jQuery中处理触摸事件，我们需要访问`originalEvent`来访问触摸，因为这些是浏览器原生事件，而不是jQuery事件。
- en: We only care about one touch in this game, that's why we only check the `touches[0]`
    parameter. We also confirm that `originalEvent.touches` exists before using the
    array notation, otherwise, the browser throws errors on non-touch devices.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们只关心一个触摸，这就是为什么我们只检查`touches[0]`参数。在使用数组表示法之前，我们也确认了`originalEvent.touches`存在，否则，在非触摸设备上浏览器会抛出错误。
- en: 'Then we access the `pageX` property of either the `touch` object or the mouse
    event object. If the `touch` object presents, JavaScript uses the `touch.pageX`.
    Otherwise, JavaScript uses the mouse event''s `pageX` property:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们访问`touch`对象或鼠标事件对象的`pageX`属性。如果`touch`对象存在，JavaScript使用`touch.pageX`。否则，JavaScript使用鼠标事件的`pageX`属性：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Mouse move and Touch move
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标移动和触摸移动
- en: We reuse the same logic for our `mousedown`/`touchstart`, `mousemove`/`touchmove`,
    and `mouseup`/`touchend` event. Often `mousedown` and `touchstart` share very
    similar logic for dragging starts. The `mouseup` and `touchend` events also share
    similar logic for dragging ends. The `mousemove` and `touchmove` events, however,
    have a subtle difference. In desktop devices with mouse input, the `mousemove`
    event is always firing whenever the mouse moves, regardless of the pressing of
    mouse button. That was why we needed to use a variable `targetCircleIndex` to
    determine whether the button was pressed and then selected a certain circle when
    the mouse moves. The `touchmove` event, on the other hand, happens only when a
    finger is actually down on the screen and dragging. This difference may sometimes
    affect the different ways we handle the logic.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`mousedown`/`touchstart`、`mousemove`/`touchmove`和`mouseup`/`touchend`事件重用了相同的逻辑。通常`mousedown`和`touchstart`在拖拽开始时具有非常相似的逻辑。`mouseup`和`touchend`事件在拖拽结束时也具有相似的逻辑。然而，`mousemove`和`touchmove`事件却有一个细微的差别。在带有鼠标输入的桌面设备上，`mousemove`事件总是在鼠标移动时触发，无论鼠标按钮是否按下。这就是为什么我们需要使用一个变量`targetCircleIndex`来确定按钮是否被按下，然后在鼠标移动时选择一个特定的圆。另一方面，`touchmove`事件仅在手指实际按下屏幕并拖拽时发生。这种差异有时可能会影响我们处理逻辑的不同方式。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about drawing shapes and creating interaction
    with the new HTML5 `canvas` element and the drawing API.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学习了关于使用新的HTML5 `canvas`元素和绘图API绘制形状和创建交互的很多知识。
- en: Specifically, you learned to draw circles and lines in the Canvas. We added
    mouse events and touch dragging interaction with the paths drawn in the Canvas.
    We determined line intersection with the help of mathematics formulas. We separated
    a complex code logic into different files to make the code maintainable. We divided
    the logic into data, drawing, and inputs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你学会了在画布上绘制圆形和线条。我们添加了与画布中绘制的路径相关的鼠标事件和触摸拖拽交互。我们借助数学公式来确定线条的交点。我们将复杂的代码逻辑分离到不同的文件中，以便代码可维护。我们将逻辑分为数据、绘制和输入。
- en: Now that you've learned about basic drawing functions in the Canvas and the
    drawing API, you're ready to learn some advanced drawing techniques in Canvas.
    In the next chapter, we will create a puzzle solving game by continuing the code
    example. You will also learn more Canvas drawing techniques, such as drawing text,
    drawing images, and creating multiple drawing layers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了画布中的基本绘图函数和绘图API，你准备好学习一些Canvas中的高级绘图技术了。在下一章中，我们将通过继续代码示例来创建一个解谜游戏。你还将学习更多Canvas绘图技术，例如绘制文本、绘制图像和创建多个绘图层。
