- en: Chapter 6. Advanced Geometries and Binary Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。高级几何和二进制运算
- en: 'In the previous chapter, we showed you all the basic geometries provided by
    Three.js. Besides these basic geometries, Three.js also offers a set of more advanced
    and specialized objects. In this chapter, we''ll show you these advanced geometries
    and cover the following subjects:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向您展示了 Three.js 提供的所有基本几何形状。除了这些基本几何形状之外，Three.js 还提供了一套更高级和专业的对象。在本章中，我们将向您展示这些高级几何形状，并涵盖以下主题：
- en: How to use advanced geometries such as `THREE.ConvexGeometry`, `THREE.LatheGeometry`,
    and `THREE.TubeGeometry`.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用高级几何形状，如 `THREE.ConvexGeometry`、`THREE.LatheGeometry` 和 `THREE.TubeGeometry`。
- en: How to create 3D shapes from 2D shapes using `THREE.ExtrudeGeometry`. We'll
    do this based on a 2D shape drawn using functionality provided by Three.js, and
    we'll show an example where we create a 3D shape based on an externally loaded
    SVG image.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `THREE.ExtrudeGeometry` 从 2D 形状创建 3D 形状。我们将基于使用 Three.js 提供的功能绘制的 2D 形状来完成此操作，并展示一个基于外部加载的
    SVG 图像创建 3D 形状的示例。
- en: If you want to create custom shapes yourself, you can easily amend the ones
    we've discussed in the previous chapters. Three.js, however, also offers a `THREE.ParamtericGeometry`
    object. With this object, you can create a geometry based on a set of equations.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想自己创建自定义形状，你可以轻松修改前几章中讨论过的形状。然而，Three.js 也提供了一个 `THREE.ParametricGeometry`
    对象。使用此对象，你可以根据一组方程创建一个几何形状。
- en: Finally, we'll look at how you can create 3D text effects using `THREE.TextGeometry`.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何使用 `THREE.TextGeometry` 创建 3D 文本效果。
- en: Additionally, we'll also show you how you can create new geometries from existing
    ones using binary operations provided by the Three.js extension, ThreeBSP.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还将向您展示如何使用 Three.js 扩展 ThreeBSP 提供的二进制运算从现有几何形状创建新几何形状。
- en: We'll start with the first one from this list, `THREE.ConvexGeometry`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列表中的第一个开始，`THREE.ConvexGeometry`。
- en: THREE.ConvexGeometry
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: THREE.ConvexGeometry
- en: 'With `THREE.ConvexGeometry`, we can create a convex hull around a set of points.
    A convex hull is the minimal shape that encompasses all these points. The easiest
    way to understand this is by looking at an example. If you open up the `01-advanced-3d-geometries-convex.html`
    example, you''ll see the convex hull for a random set of points. The following
    screenshot shows this geometry:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.ConvexGeometry`，我们可以围绕一组点创建凸包。凸包是包含所有这些点的最小形状。理解这一点最简单的方法是查看一个示例。如果您打开
    `01-advanced-3d-geometries-convex.html` 示例，您将看到一组随机点的凸包。以下截图显示了此几何形状：
- en: '![THREE.ConvexGeometry](img/2215OS_06_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.ConvexGeometry](img/2215OS_06_01.jpg)'
- en: 'In this example, we generate a random set of points and based on these points
    we create `THREE.ConvexGeometry`. In the example, you can click on **redraw**,
    which will generate 20 new points and draw the convex hull. We also add each of
    these points as a small `THREE.SphereGeometry` object to clearly show how a convex
    hull works. `THREE.ConvexGeometry` isn''t included in the standard Three.js distribution,
    so you have to include an additional JavaScript file to use this geometry. At
    the top of your HTML page, add the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们生成一组随机点，并根据这些点创建 `THREE.ConvexGeometry`。在示例中，您可以点击**重绘**，这将生成 20 个新的点并绘制凸包。我们还添加了每个点作为一个小型的
    `THREE.SphereGeometry` 对象，以清楚地显示凸包的工作原理。`THREE.ConvexGeometry` 不包含在标准的 Three.js
    分发中，因此您必须包含一个额外的 JavaScript 文件才能使用此几何形状。在您的 HTML 页面顶部添加以下内容：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following piece of code shows how these points were created and added to
    the scene:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了这些点是如何创建并添加到场景中的：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in this snippet of code, we create 20 random points (`THREE.Vector3`),
    which we push into an array. Next, we iterate this array and create `THREE.SphereGeometry`,
    whose position we set to one of these points (`position.clone(point)`). All the
    points are added to a group (more on this in [Chapter 7](ch07.html "Chapter 7. Particles,
    Sprites, and the Point Cloud"), *Particles, Sprites, and the Point Cloud*), so
    we can rotate them easily by just rotating the group.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们创建了 20 个随机点（`THREE.Vector3`），并将它们推入一个数组。接下来，我们遍历这个数组，创建 `THREE.SphereGeometry`，并将位置设置为这些点之一（`position.clone(point)`）。所有点都被添加到一个组中（更多内容请参阅[第
    7 章](ch07.html "第 7 章。粒子、精灵和点云")，*粒子、精灵和点云*），因此我们可以通过旋转组来轻松地旋转它们。
- en: 'Once you have this set of points, creating `THREE.ConvexGeometry` is very easy,
    as shown in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这组点，创建 `THREE.ConvexGeometry` 非常简单，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An array containing vertices (of the `THREE.Vector3` type) is the only argument
    `THREE.ConvexGeometry` takes. Here's one final note on the `createMesh()` function
    (which is a function we created ourselves in [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*) we call here. In
    the previous chapter, we used this method to create a mesh using `THREE.MeshNormalMaterial`.
    For this example, we changed this to a translucent green `THREE.MeshBasicMaterial`
    to better show the convex hull we created and the individual points that make
    up this geometry.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.ConvexGeometry`只接受一个包含顶点（`THREE.Vector3`类型）的数组作为参数。这里有一个关于`createMesh()`函数（这是我们自己在[第5章](ch05.html
    "第5章。学习与几何体一起工作")中创建的函数）的最终说明，我们在本章中调用它。在前一章中，我们使用此方法通过`THREE.MeshNormalMaterial`创建网格。对于这个例子，我们将它改为半透明的绿色`THREE.MeshBasicMaterial`，以便更好地显示我们创建的凸包和构成此几何形状的各个点。'
- en: The next complex geometry is `THREE.LatheGeometry`, which can be used to create
    vase-like shapes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个复杂的几何形状是`THREE.LatheGeometry`，它可以用来创建类似花瓶的形状。
- en: THREE.LatheGeometry
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: THREE.LatheGeometry
- en: '`THREE.LatheGeometry` allows you to create shapes from a smooth curve. This
    curve is defined by a number of points (also called knots) and is most often called
    a spline. This spline is rotated around the central *z* axis of the object and
    results in vase-like and bell-like shapes. Once again, the easiest way to understand
    what `THREE.LatheGeometry` looks like is by looking at an example. This geometry
    is shown in `02-advanced-3d-geometries-lathe.html`. The following screenshot taken
    from the example shows this geometry:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.LatheGeometry`允许你从平滑曲线创建形状。这个曲线由一定数量的点（也称为节点）定义，通常称为样条曲线。这个样条曲线围绕对象的中心*z*轴旋转，并产生类似花瓶和钟形形状。再次强调，了解`THREE.LatheGeometry`外观的最简单方法是通过查看示例。这个几何形状在`02-advanced-3d-geometries-lathe.html`中显示。以下是从示例中截取的屏幕截图，显示了此几何形状：'
- en: '![THREE.LatheGeometry](img/2215OS_06_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.LatheGeometry](img/2215OS_06_02.jpg)'
- en: 'In the preceding screenshot, you can see the spline as the set of small red
    spheres. The positions of these spheres are passed in to `THREE.LatheGeometry`,
    together with a couple of other arguments. In this example, we rotate this spline
    for half a circle, and based on this spline, we extract the shape you can see.
    Before we look at all the arguments, let''s look at the code used to create the
    spline and how `THREE.LatheGeometry` uses this spline:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图中，你可以看到样条曲线作为一组小红色球体。这些球体的位置被传递给`THREE.LatheGeometry`，以及一些其他参数。在这个例子中，我们将这个样条曲线旋转半圆，并根据这个样条曲线，我们提取了你可以看到的形状。在我们查看所有参数之前，让我们看看创建样条曲线所使用的代码以及`THREE.LatheGeometry`如何使用这个样条曲线：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this piece of JavaScript, you can see that we generate 30 points whose *x*
    coordinate is based on a combination of sine and cosine functions while the *z*
    coordinate is based on the `i` and `count` variables. This creates the spline
    visualized by the red dots in the preceding screenshot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段JavaScript代码中，你可以看到我们生成了30个点，其中*x*坐标是基于正弦和余弦函数的组合，而*z*坐标是基于`i`和`count`变量。这创建了前一个屏幕截图中所显示的由红色点表示的样条曲线。
- en: 'Based on these points, we can create `THREE.LatheGeometry`. Besides the array
    of vertices, `THREE.LatheGeometry` takes a couple of other arguments. The following
    table lists all the arguments:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些点，我们可以创建`THREE.LatheGeometry`。除了顶点数组之外，`THREE.LatheGeometry`还需要一些其他参数。下表列出了所有参数：
- en: '| Property | Mandatory | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 必需 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `points` | Yes | These are the points that make up the spline used to generate
    the bell/vase shape. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `points` | 是 | 这些是构成用于生成钟形/花瓶形状的样条的点。|'
- en: '| `segments` | No | These are the number of segments used when creating the
    shape. The higher this number, the more *round* the resulting shape will be. The
    default value for this is `12`. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `segments` | 否 | 这些是在创建形状时使用的段数。这个数字越高，生成的形状就越*圆滑*。默认值是`12`。|'
- en: '| `phiStart` | No | This determines where to start on a circle when generating
    the shape. This can range from `0` to `2*PI`. The default value is `0`. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `phiStart` | 否 | 这决定了在生成形状时从圆的哪个位置开始。这可以从`0`到`2*PI`。默认值是`0`。|'
- en: '| `phiLength` | No | This defines how fully generated the shape is. For instance,
    a quarter shape will be `0.5*PI`. The default value is the full `360` degrees
    or `2*PI`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `phiLength` | 否 | 这定义了形状生成的完整程度。例如，四分之一形状将是`0.5*PI`。默认值是完整的`360`度或`2*PI`。|'
- en: In the next section, we'll look at an alternative way of creating geometries
    by extracting a 3D geometry from a 2D shape.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨通过从 2D 形状提取 3D 几何体来创建几何体的另一种方法。
- en: Creating a geometry by extruding
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过拉伸创建几何体
- en: Three.js provides a couple of ways in which we can extrude a 2D shape to a 3D
    shape. By extruding, we mean stretching out a 2D shape along its *z* axis to convert
    it to 3D. For instance, if we extrude `THREE.CircleGeometry`, we get a shape that
    looks like a cylinder, and if we extrude `THREE.PlaneGeometry`, we get a cube-like
    shape.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了几种方法，可以将 2D 形状拉伸成 3D 形状。通过拉伸，我们指的是沿着其 *z* 轴拉伸 2D 形状以将其转换为 3D。例如，如果我们拉伸
    `THREE.CircleGeometry`，我们得到一个看起来像圆柱体的形状，如果我们拉伸 `THREE.PlaneGeometry`，我们得到一个类似立方体的形状。
- en: The most versatile way of extruding a shape is using the `THREE.ExtrudeGeometry`
    object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.ExtrudeGeometry` 对象是拉伸形状最灵活的方法。
- en: THREE.ExtrudeGeometry
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: THREE.ExtrudeGeometry
- en: 'With `THREE.ExtrudeGeometry`, you can create a 3D object from a 2D shape. Before
    we dive into the details of this geometry, let''s first look at an example: `03-extrude-geometry.html`.
    The following screenshot taken from the example shows this geometry:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.ExtrudeGeometry`，你可以从 2D 形状创建一个 3D 对象。在我们深入探讨这个几何体的细节之前，让我们先看看一个例子：`03-extrude-geometry.html`。以下是从例子中截取的屏幕截图，展示了这个几何体：
- en: '![THREE.ExtrudeGeometry](img/2215OS_06_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.ExtrudeGeometry](img/2215OS_06_03.jpg)'
- en: 'In this example, we took the 2D shape we created in the previous chapter and
    used `THREE.ExtrudeGeometry` to convert it to 3D. As you can see in this screenshot,
    the shape is extruded along the *z* axis, which results in a 3D shape. The code
    to create `THREE.ExtrudeGeometry` is very easy:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了上一章中创建的 2D 形状，并使用 `THREE.ExtrudeGeometry` 将其转换为 3D。正如你在下面的屏幕截图中所看到的，形状沿着
    *z* 轴拉伸，从而形成了一个 3D 形状。创建 `THREE.ExtrudeGeometry` 的代码非常简单：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, we created the shape with the `drawShape()` function just as we
    did in the previous chapter. This shape is passed on to the `THREE.ExtrudeGeometry`
    constructor together with an `options` object. With the `options` object, you
    can define exactly how the shape should be extruded. The following table explains
    the options you can pass in to `THREE.ExtrudeGeometry`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用 `drawShape()` 函数创建了形状，就像我们在上一章中所做的那样。这个形状被传递给 `THREE.ExtrudeGeometry`
    构造函数，同时传递一个 `options` 对象。通过 `options` 对象，你可以精确地定义形状应该如何拉伸。以下表格解释了你可以传递给 `THREE.ExtrudeGeometry`
    的选项。
- en: '| Property | Mandatory | Description |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 必需 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `shapes` | Yes | One or more shapes (`THREE.Shape` objects) are required
    to extrude the geometry from. See the preceding chapter on how to create such
    a shape. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `shapes` | 是 | 需要一个或多个形状（`THREE.Shape` 对象）来从其中拉伸几何体。请参阅前面的章节了解如何创建这样的形状。
    |'
- en: '| `amount` | No | This determines how far (the depth) the shape should be extruded.
    The default value is `100`. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `amount` | 否 | 这决定了形状应该拉伸多远（深度）。默认值是 `100`。 |'
- en: '| `bevelThickness` | No | This determines the depth of the bevel. The bevel
    is the rounded corner between the front and back faces and the extrusion. This
    value defines how deep into the shape the bevel goes. The default value is `6`.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `bevelThickness` | 否 | 这决定了斜面的深度。斜面是前后面和拉伸之间的圆角。此值定义斜面进入形状的深度。默认值是 `6`。 |'
- en: '| `bevelSize` | No | This determines the height of the bevel. This is added
    to the normal height of the shape. The default value is `bevelThickness - 2`.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSize` | 否 | 这决定了斜面的高度。这被添加到形状的正常高度上。默认值是 `bevelThickness - 2`。 |'
- en: '| `bevelSegments` | No | This defines the number of segments that will be used
    by the bevel. The more the number of segments used, the smoother the bevel will
    look. The default value is `3`. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSegments` | 否 | 这定义了斜面将使用的段数。使用的段数越多，斜面看起来越平滑。默认值是 `3`。 |'
- en: '| `bevelEnabled` | No | If this is set to `true`, a bevel is added. The default
    value is `true`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `bevelEnabled` | 否 | 如果设置为 `true`，则添加斜面。默认值是 `true`。 |'
- en: '| `curveSegments` | No | This determines how many segments will be used when
    extruding the curves of shapes. The more the number of segments used, the smoother
    the curves will look. The default value is `12`. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `curveSegments` | 否 | 这决定了在拉伸形状的曲线时将使用多少段。使用的段数越多，曲线看起来越平滑。默认值是 `12`。 |'
- en: '| `steps` | No | This defines the number of segments into the extrusion will
    be divided along its depth. The default value is `1`. A higher value will result
    in more individual faces. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `steps` | 否 | 这定义了沿着拉伸的深度将分割成多少段。默认值是 `1`。更高的值将导致更多的单独面。 |'
- en: '| `extrudePath` | No | This is the path (`THREE.CurvePath`) along which the
    shape should be extruded. If this isn''t specified, the shape is extruded along
    the *z* axis. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `extrudePath` | No | 这是形状应该拉伸的路径（`THREE.CurvePath`）。如果没有指定，形状将沿着*z*轴拉伸。 |'
- en: '| `material` | No | This is the index of the material to use for the front
    and the back faces. Use the `THREE.SceneUtils.createMultiMaterialObject` function
    to create the mesh if you want separate materials for the front and back faces.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `material` | No | 这是用于前表面和后表面的材质索引。如果你想为前后表面使用不同的材质，请使用`THREE.SceneUtils.createMultiMaterialObject`函数来创建网格。
    |'
- en: '| `extrudeMaterial` | No | This is the index of the materials to use for the
    bevel and the extrusion. Use the `THREE.SceneUtils.createMultiMaterialObject`
    function to create the mesh if you want separate materials for the front and back
    faces. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `extrudeMaterial` | No | 这是用于斜面和拉伸的材质索引。如果你想为前后表面使用不同的材质，请使用`THREE.SceneUtils.createMultiMaterialObject`函数来创建网格。
    |'
- en: '| `uvGenerator` | No | When you use a texture with your material, the UV mapping
    determines what part of a texture is used for a specific face. With the `uvGenerator`
    property, you can pass in your own object that will create the UV settings for
    the faces that are created for the shapes that are passed in. More information
    on UV settings can be found in [Chapter 10](ch10.html "Chapter 10. Loading and
    Working with Textures"), *Loading and Working with Textures*. If none are specified,
    `THREE.ExtrudeGeometry.WorldUVGenerator` is used. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `uvGenerator` | No | 当你使用材质与纹理结合时，UV贴图决定了纹理的哪一部分用于特定的面。通过`uvGenerator`属性，你可以传入自己的对象，该对象将为传入的形状创建面的UV设置。有关UV设置的更多信息，请参阅[第10章](ch10.html
    "第10章。加载和使用纹理")，*加载和使用纹理*。如果没有指定，将使用`THREE.ExtrudeGeometry.WorldUVGenerator`。
    |'
- en: '| `frames` | No | A frenet frame is used to calculate the tangents, normal,
    and binormals of a spline. This is used when extruding along `extrudePath`. You
    don''t need to specify this since Three.js provides its own implementation, `THREE.TubeGeometry.FrenetFrames`,
    which is also used as default. More information on frenet frames can be found
    at [http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame).
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `frames` | No | Frenet框架用于计算样条的切线、法线和双法线。当沿着`extrudePath`拉伸时使用。无需指定此参数，因为Three.js提供了自己的实现，即`THREE.TubeGeometry.FrenetFrames`，这也是默认值。有关Frenet框架的更多信息，请参阅[http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame)。
    |'
- en: You can experiment with these options using the menu from the `03-extrude-geometry.html`
    example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`03-extrude-geometry.html`示例中的菜单来实验这些选项。
- en: In this example, we extruded the shape along its *z* axis. As you would have
    seen in the options, you can also extrude a shape along a path with the `extrudePath`
    option. In the following geometry, `THREE.TubeGeometry`, we'll do just that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们沿着形状的*z*轴进行拉伸。正如你在选项中看到的，你也可以使用`extrudePath`选项沿着路径拉伸形状。在下面的几何体`THREE.TubeGeometry`中，我们将这样做。
- en: THREE.TubeGeometry
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: THREE.TubeGeometry
- en: '`THREE.TubeGeometry` creates a tube that extrudes along a 3D spline. You specify
    the path using a number of vertices, and `THREE.TubeGeometry` will create the
    tube. An example which you can experiment with can be found in the sources for
    this chapter (`04-extrude-tube.html`). The following screenshot shows this example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.TubeGeometry`创建一个沿着3D样条拉伸的管状体。你通过指定一系列顶点来指定路径，`THREE.TubeGeometry`将创建管状体。你可以在这个章节的源代码中找到一个可以实验的例子（`04-extrude-tube.html`）。以下截图显示了此示例：'
- en: '![THREE.TubeGeometry](img/2215OS_06_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.TubeGeometry](img/2215OS_06_04.jpg)'
- en: 'As you can see in this example, we generate a number of random points and use
    those points to draw the tube. With the controls in the upper-right corner, we
    can define how the tube looks or generate a new tube by clicking on the **newPoints**
    button. The code needed to create a tube is very simple, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们生成了一些随机点，并使用这些点来绘制管状体。通过右上角的控件，我们可以定义管状体的外观或通过点击**newPoints**按钮生成一个新的管状体。创建管状体所需的代码非常简单，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we need to do first is get a set of vertices of the `THREE.Vector3` type
    just like we did for `THREE.ConvexGeometry` and `THREE.LatheGeometry`. Before
    we can use these points, however, to create the tube, we first need to convert
    these points to `THREE.SplineCurve3`. In other words, we need to define a smooth
    curve through the points we defined. We can do this simply by passing in the array
    of vertices to the constructor of `THREE.SplineCurve3`. With this spline and the
    other arguments (which we'll explain in a bit), we can create the tube and add
    it to the scene.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要获取一组与 `THREE.Vector3` 类型的顶点，就像我们为 `THREE.ConvexGeometry` 和 `THREE.LatheGeometry`
    所做的那样。然而，在我们可以使用这些点来创建管状体之前，我们首先需要将这些点转换为 `THREE.SplineCurve3`。换句话说，我们需要定义一条通过我们定义的点的平滑曲线。我们可以通过将顶点数组传递给
    `THREE.SplineCurve3` 的构造函数来实现这一点。有了这条样条曲线和其他参数（我们稍后会解释），我们可以创建管状体并将其添加到场景中。
- en: '`THREE.TubeGeometry` takes some other arguments besides `THREE.SplineCurve3`.
    The following table lists all the arguments for `THREE.TubeGeometry`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.TubeGeometry` 除了 `THREE.SplineCurve3` 之外还接受一些其他参数。以下表格列出了 `THREE.TubeGeometry`
    的所有参数：'
- en: '| Property | Mandatory | Description |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 必需 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `path` | Yes | This is `THREE.SplineCurve3` that describes the path this
    tube should follow. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `path` | 是 | 这是描述此管状体应遵循路径的 `THREE.SplineCurve3`。|'
- en: '| `segments` | No | These are the segments used to build up the tube. The default
    value is `64`. The longer the path, the more segments you should specify. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `segments` | 否 | 这些是用于构建管状体的段。默认值为 `64`。路径越长，您应该指定的段数就越多。|'
- en: '| `radius` | No | This is the radius of the tube. The default value is `1`.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `radius` | 否 | 这是管状体的半径。默认值为 `1`。|'
- en: '| `radiusSegments` | No | This is the number of segments to be used along the
    length of the tube. The default value is `8`. The more you use, the more *round*
    the tube will look. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `radiusSegments` | 否 | 这是沿管状体长度使用的段数。默认值为 `8`。您使用的越多，管状体看起来就越圆。|'
- en: '| `closed` | No | If this is set to `true`, the start of the tube and the end
    will be connected together. The default value is `false`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `closed` | 否 | 如果设置为 `true`，管状体的起始端和末端将连接在一起。默认值为 `false`。|'
- en: The last extrude example we'll show in this chapter isn't really a different
    geometry. In the next section, we'll show you how you can use `THREE.ExtrudeGeometry`
    to create extrusions from existing SVG paths.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将展示的最后一条拉伸示例实际上并不是一个不同的几何形状。在下一节中，我们将向您展示如何使用 `THREE.ExtrudeGeometry` 从现有的
    SVG 路径创建拉伸体。
- en: Extrude from SVG
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 SVG 拉伸
- en: When we discussed `THREE.ShapeGeometry`, we mentioned that SVG follows pretty
    much the same approach of drawing shapes. SVG has a very close match with how
    Three.js handles shapes. In this section, we'll look at how you can use a small
    library from [https://github.com/asutherland/d3-threeD](https://github.com/asutherland/d3-threeD)
    to convert SVG paths to a Three.js shape.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 `THREE.ShapeGeometry` 时，我们提到 SVG 大体上遵循相同的绘图形状的方法。SVG 与 Three.js 处理形状的方式非常相似。在本节中，我们将探讨如何使用来自
    [https://github.com/asutherland/d3-threeD](https://github.com/asutherland/d3-threeD)
    的小型库将 SVG 路径转换为 Three.js 形状。
- en: 'For the `05-extrude-svg.html` example, I''ve taken an SVG drawing of the Batman
    logo and used `ExtrudeGeometry` to convert it to 3D, as shown in the following
    screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `05-extrude-svg.html` 示例，我使用了一个蝙蝠侠标志的 SVG 绘图，并使用 `ExtrudeGeometry` 将其转换为
    3D，如下面的截图所示：
- en: '![Extrude from SVG](img/2215OS_06_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![从 SVG 拉伸](img/2215OS_06_05.jpg)'
- en: 'First, let''s look at what the original SVG code looks like (you can also see
    this for yourself when looking at the source code for this example):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看原始 SVG 代码的样子（您也可以在查看此示例的源代码时自己查看）：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unless you're an SVG guru, this will probably mean nothing to you. Basically
    though, what you see here are a set of drawing instructions. For instance, `C
    277.987 119.348 279.673 116.786 279.673 115.867` tells the browser to draw a cubic
    Bezier curve, and `L 489.242 111.787` tells us that we should draw a line to that
    specific position. Luckily though, we won't have to write the code to interpret
    this ourselves. With the d3-threeD library, we can convert this automatically.
    This library was originally created to be used together with the excellent **D3.js**
    library, but with some small adaptions, we can also use this specific functionality
    standalone.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是SVG专家，否则这可能对你来说毫无意义。基本上，你在这里看到的是一系列绘图指令。例如，`C 277.987 119.348 279.673 116.786
    279.673 115.867`告诉浏览器绘制一个三次贝塞尔曲线，而`L 489.242 111.787`告诉我们应该绘制到那个特定位置。幸运的是，我们不需要自己编写代码来解释这些。使用d3-threeD库，我们可以自动转换这些指令。这个库最初是为了与优秀的**D3.js**库一起使用而创建的，但经过一些小的调整，我们也可以单独使用这个特定的功能。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**SVG** stands for **Scalable Vector Graphics**. This is an XML-based standard
    that can be used to create vector-based 2D images for the Web. This is an open
    standard that is supported by all of the modern browsers. Directly working with
    SVG and manipulating it from JavaScript, however, isn''t very straightforward.
    Luckily, there are a couple of open source JavaScript libraries that make working
    with SVG a lot easier. **Paper.js**, **Snap.js**, **D3.js**, and **Raphael.js**
    are some of the best.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**SVG**代表**可缩放矢量图形**。这是一个基于XML的标准，可以用来创建用于网络的矢量2D图像。这是一个由所有现代浏览器支持的开源标准。然而，直接使用SVG并通过JavaScript操作它并不十分直接。幸运的是，有几个开源JavaScript库使得使用SVG变得更加容易。**Paper.js**、**Snap.js**、**D3.js**和**Raphael.js**是一些最好的库。'
- en: 'The following code fragment shows how we can load in the SVG you saw earlier,
    convert it to `THREE.ExtrudeGeometry`, and show it on screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何加载你之前看到的SVG，将其转换为`THREE.ExtrudeGeometry`，并在屏幕上显示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code fragment, you''ll see a call to the `transformSVGPathExposed`
    function. This function is provided by the d3-threeD library and takes an SVG
    string as an argument. We get this SVG string directly from the SVG element with
    the following expression: `document.querySelector("#batman-path").getAttribute("d")`.
    In SVG, the `d` attribute contains the path statements used to draw a shape. Add
    a nice-looking shiny material and a spotlight and you''ve recreated this example.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你会看到一个对`transformSVGPathExposed`函数的调用。这个函数由d3-threeD库提供，并接受一个SVG字符串作为参数。我们直接从以下表达式获取这个SVG字符串：`document.querySelector("#batman-path").getAttribute("d")`。在SVG中，`d`属性包含了用于绘制形状的路径语句。添加一个看起来很漂亮的闪亮材质和聚光灯，你就重新创建了此示例。
- en: The last geometry we'll discuss in this section is `THREE.ParametricGeometry`.
    With this geometry, you can specify a couple of functions that are used to programmatically
    create geometries.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将讨论的最后一种几何形状是`THREE.ParametricGeometry`。使用这种几何形状，你可以指定一些函数，这些函数用于程序化地创建几何形状。
- en: THREE.ParametricGeometry
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: THREE.ParametricGeometry
- en: 'With `THREE.ParametricGeometry`, you can create a geometry based on an equation.
    Before we dive into our own example, a good thing to start with is to look at
    the examples already provided by Three.js. When you download the Three.js distribution,
    you get the `examples/js/ParametricGeometries.js` file. In this file, you can
    find a couple of examples of equations you can use together with `THREE.ParametricGeometry`.
    The most basic example is the function to create a plane:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.ParametricGeometry`，你可以根据一个方程创建一个几何形状。在我们自己的示例之前，一个好的开始是查看Three.js已经提供的示例。当你下载Three.js发行版时，你会得到`examples/js/ParametricGeometries.js`文件。在这个文件中，你可以找到一些你可以与`THREE.ParametricGeometry`一起使用的方程示例。最基本的例子是创建平面的函数：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function is called by `THREE.ParametricGeometry`. The `u` and `v` values
    will range from `0` to `1` and will be called a large number of times for all
    the values from `0` to `1`. In this example, the `u` value is used to determine
    the *x* coordinate of the vector and the `v` value is used to determine the *z*
    coordinate. When this is run, you'll have a basic plane with a width of `width`
    and a depth of `depth`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是通过`THREE.ParametricGeometry`调用的。`u`和`v`的值将在`0`到`1`之间变化，并且对于`0`到`1`之间的所有值都会被调用很多次。在这个例子中，`u`值用于确定向量的*x*坐标，而`v`值用于确定*z*坐标。当运行这个程序时，你会得到一个宽度为`width`和深度为`depth`的基本平面。
- en: 'In our example, we do something similar. However, instead of creating a flat
    plane, we create a wave-like pattern, as you can see in the `06-parametric-geometries.html`
    example. The following screenshot shows this example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们做了类似的事情。然而，我们不是创建一个平面，而是创建了一个波浪状的模式，正如您在`06-parametric-geometries.html`示例中所见。以下截图显示了此示例：
- en: '![THREE.ParametricGeometry](img/2215OS_06_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.ParametricGeometry](img/2215OS_06_06.jpg)'
- en: 'To create this shape, we passed in the following function to `THREE.ParametricGeometry`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个形状，我们向`THREE.ParametricGeometry`传递了以下函数：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in this example, with a few lines of code, we can create really
    interesting geometries. In this example, you can also see the arguments we can
    pass in to `THREE.ParametricGeometry`. These are explained in the following table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个示例中所见，通过几行代码，我们可以创建非常有趣的几何体。在这个示例中，您还可以看到我们可以传递给`THREE.ParametricGeometry`的参数。这些参数在以下表中解释：
- en: '| Property | Mandatory | Description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 必选 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `function` | Yes | This is the function that defines the position of each
    vertex based on the `u` and `v` values provided |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `function` | 是 | 这是一个函数，它根据提供的`u`和`v`值定义每个顶点的位置 |'
- en: '| `slices` | Yes | This defines the number of parts the `u` value should be
    divided into |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `slices` | 是 | 这定义了`u`值应该被分成多少部分 |'
- en: '| `stacks` | Yes | This defines the number of parts the `v` value should be
    divided into |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `stacks` | 是 | 这定义了`v`值应该被分成多少部分 |'
- en: 'I''d like to make a final note on how to use the `slices` and `stacks` properties
    before moving on to the final part of this chapter. We mentioned that the `u`
    and `v` properties are passed in to the `function` argument provided, and that
    the values of these two properties range from `0` to `1`. With the `slices` and
    `stacks` properties, we can define how often the passed-in function is called.
    If, for instance, we set `slices` to `5` and `stacks` to `4`, the function will
    be called with the following values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章的最后部分之前，我想对如何使用`slices`和`stacks`属性做一个总结。我们提到`u`和`v`属性被传递到提供的`function`参数中，并且这两个属性的值范围从`0`到`1`。通过`slices`和`stacks`属性，我们可以定义传递的函数被调用的频率。例如，如果我们将`slices`设置为`5`，将`stacks`设置为`4`，函数将使用以下值被调用：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, the higher this value, the more vertices you get to specify and the smoother
    your created geometry will be. You can use the menu in the top-right corner of
    the `06-parametric-geometries.html` example to see this effect.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个值越高，您能指定的顶点就越多，创建的几何体就越平滑。您可以使用`06-parametric-geometries.html`示例右上角的菜单来查看此效果。
- en: 'For more examples, you can look at the `examples/js/ParametricGeometries.js`
    file in the Three.js distribution. This file contains functions to create the
    following geometries:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多示例，您可以查看Three.js分布中的`examples/js/ParametricGeometries.js`文件。此文件包含创建以下几何体的函数：
- en: Klein bottle
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克莱因瓶
- en: Plane
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面
- en: Flat mobius strip
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面莫比乌斯带
- en: 3d mobius strip
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D莫比乌斯带
- en: Tube
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Torus knot
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭结
- en: Sphere
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体
- en: The last part of this chapter deals with creating 3D text objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分处理创建3D文本对象。
- en: Creating 3D text
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建3D文本
- en: In the last part of this chapter, we'll have a quick look at how you can create
    3D text effects. First, we'll look at how to render text using the fonts provided
    by Three.js, and after that, we'll have a quick look at how you can use your own
    fonts for this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将快速浏览如何创建3D文本效果。首先，我们将查看如何使用Three.js提供的字体渲染文本，之后，我们将简要了解如何使用自己的字体进行此操作。
- en: Rendering text
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染文本
- en: 'Rendering text in Three.js is very easy. All you have to do is define the font
    you want to use and the basic extrude properties we saw when we discussed `THREE.ExtrudeGeometry`.
    The following screenshot shows the `07-text-geometry.html` example on how to render
    text in Three.js:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中渲染文本非常简单。您只需定义要使用的字体和我们在讨论`THREE.ExtrudeGeometry`时看到的基 ExtrudeGeometry
    础拉伸属性。以下截图显示了如何使用Three.js渲染文本的`07-text-geometry.html`示例：
- en: '![Rendering text](img/2215OS_06_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![渲染文本](img/2215OS_06_07.jpg)'
- en: 'The code required to create this 3D text is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此3D文本所需的代码如下：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s look at all the options we can specify for `THREE.TextGeometry`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以为`THREE.TextGeometry`指定的所有选项：
- en: '| Property | Mandatory | Description |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 必选 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `size` | No | This is the size of the text. The default value is `100`. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 否 | 这是文本的大小。默认值是`100`。 |'
- en: '| `height` | No | This is the length (depth) of the extrusion. The default
    value is `50`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `height` | 否 | 这是拉伸的长度（深度）。默认值是`50`。 |'
- en: '| `weight` | No | This is the weight of the font. The possible values are `normal`
    and `bold`. The default value is `normal`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `weight` | No | 这是字体的粗细。可能的值是 `normal` 和 `bold`。默认值是 `normal`。|'
- en: '| `font` | No | This is the name of the font to be used. The default value
    is `helvetiker`. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `font` | No | 这是将要使用的字体名称。默认值是 `helvetiker`。|'
- en: '| `style` | No | This is the weight of the font. The possible values are `normal`
    and `italic`. The default value is `normal`. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `style` | No | 这是字体的粗细。可能的值是 `normal` 和 `italic`。默认值是 `normal`。|'
- en: '| `bevelThickness` | No | This is the depth of the bevel. The bevel is the
    rounded corner between the front and back faces and the extrusion. The default
    value is `10`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `bevelThickness` | No | 这是斜面的深度。斜面是前后面和挤压之间的圆角。默认值是 `10`。|'
- en: '| `bevelSize` | No | This is the height of the bevel. The default value is
    `8`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSize` | No | 这是斜面的高度。默认值是 `8`。|'
- en: '| `bevelSegments` | No | This defines the number of segments that will be used
    by the bevel. The more segments there are, the smoother the bevel will look. The
    default value is `3`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSegments` | No | 这定义了斜面将使用的段数。段数越多，斜面看起来越平滑。默认值是 `3`。|'
- en: '| `bevelEnabled` | No | If this is set to `true`, a bevel is added. The default
    value is `false`. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `bevelEnabled` | No | 如果设置为 `true`，则添加斜面。默认值是 `false`。|'
- en: '| `curveSegments` | No | This defines the number segments used when extruding
    the curves of shapes. The more segments there are, the smoother the curves will
    look. The default value is `4`. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `curveSegments` | No | 这定义了在挤压形状的曲线时使用的段数。段数越多，曲线看起来越平滑。默认值是 `4`。|'
- en: '| `steps` | No | This defines the number of segments the extrusion will be
    divided into. The default value is `1`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `steps` | No | 这定义了挤压将被分割成多少段。默认值是 `1`。|'
- en: '| `extrudePath` | No | This is the path along which the shape should be extruded.
    If this isn''t specified, the shape is extruded along the *z* axis. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `extrudePath` | No | 这是形状应该挤压的路径。如果没有指定，形状将沿着 *z* 轴挤压。|'
- en: '| `material` | No | This is the index of the material to be used for the front
    and back faces. Use the `THREE.SceneUtils.createMultiMaterialObject` function
    to create the mesh. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `material` | No | 这是用于前后面的材料的索引。使用 `THREE.SceneUtils.createMultiMaterialObject`
    函数来创建网格。|'
- en: '| `extrudeMaterial` | No | This is the index of the material to be used for
    the bevel and the extrusion. Use the `THREE.SceneUtils.createMultiMaterialObject`
    function to create the mesh. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `extrudeMaterial` | No | 这是用于斜面和挤压的材料的索引。使用 `THREE.SceneUtils.createMultiMaterialObject`
    函数来创建网格。|'
- en: '| `uvGenerator` | No | When you use a texture with your material, the UV mapping
    determines what part of a texture is used for a specific face. With the `UVGenerator`
    property, you can pass in your own object that will create the UV settings for
    the faces that are created for the passed-in shapes. More information on UV settings
    can be found in [Chapter 10](ch10.html "Chapter 10. Loading and Working with Textures"),
    *Loading and Working with Textures*. If none are specified, `THREE.ExtrudeGeometry.WorldUVGenerator`
    is used. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `uvGenerator` | No | 当您使用材质与纹理一起使用时，UV 映射确定纹理的哪个部分用于特定的面。通过 `UVGenerator`
    属性，您可以传递自己的对象，该对象将为传入的形状创建面的 UV 设置。有关 UV 设置的更多信息，请参阅第 10 章，*加载和使用纹理*。如果没有指定，则使用
    `THREE.ExtrudeGeometry.WorldUVGenerator`。|'
- en: '| `frames` | No | A frenet frame is used to calculate the tangents, normal,
    and binormals of a spline. This is used when extruding along `extrudePath`. You
    don''t need to specify this because Three.js provides its own implementation,
    `THREE.TubeGeometry.FrenetFrames`, which is also used as default. More information
    on frenet frames can be found at [http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame).
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `frames` | No | Frenet 坐标系用于计算样条的切线、法线和双法线。当沿着 `extrudePath` 挤压时使用。您不需要指定此值，因为
    Three.js 提供了自己的实现，`THREE.TubeGeometry.FrenetFrames`，这也是默认值。有关 Frenet 坐标系的更多信息，请参阅
    [http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame)。|'
- en: The fonts that are included in Three.js are also added to the sources for this
    book. You can find them in the `assets/fonts` folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在 Three.js 中的字体也添加到本书的源代码中。您可以在 `assets/fonts` 文件夹中找到它们。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to render fonts in 2D, for instance, to use them as a texture for
    a material, you shouldn't use `THREE.TextGeometry`. `THREE.TextGeometry`, which
    internally uses `THREE.ExtrudeGeometry` to build the 3D text, and the JavaScript
    fonts introduce a lot of overhead. Rendering a simple 2D font is better than just
    using the HTML5 canvas. With `context.font`, you can set the font to be used,
    and with `context.fillText`, you can output text to the canvas. You can then use
    this canvas as input for your texture. We will show you how to do this in [Chapter
    10](ch10.html "Chapter 10. Loading and Working with Textures"), *Loading and Working
    with Textures*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在2D中渲染字体，例如，将其用作材质的纹理，您不应该使用`THREE.TextGeometry`。`THREE.TextGeometry`内部使用`THREE.ExtrudeGeometry`构建3D文本，而JavaScript字体引入了很多开销。渲染简单的2D字体比仅使用HTML5
    canvas更好。使用`context.font`，您可以设置要使用的字体，使用`context.fillText`，您可以将文本输出到画布上。然后您可以使用这个画布作为纹理的输入。我们将在[第10章](ch10.html
    "第10章。加载和使用纹理")中向您展示如何做到这一点，*加载和使用纹理*。
- en: It's also possible to use other fonts with this geometry, but you first need
    to convert them to JavaScript. How to do this is shown in the next section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用其他字体与该几何体一起使用，但您首先需要将它们转换为JavaScript。如何做到这一点将在下一节中展示。
- en: Adding custom fonts
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义字体
- en: There are a couple of fonts provided by Three.js that you can use in your scenes.
    These fonts are based on the fonts provided by **typeface.js** ([http://typeface.neocracy.org:81/](http://typeface.neocracy.org:81/)).
    Typeface.js is a library that can convert TrueType and OpenType fonts to JavaScript.
    The resulting JavaScript file can be included in your page, and the font can then
    be used in Three.js.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一些字体，您可以在场景中使用这些字体。这些字体基于**typeface.js**提供的字体([http://typeface.neocracy.org:81/](http://typeface.neocracy.org:81/))。Typeface.js是一个库，可以将TrueType和OpenType字体转换为JavaScript。生成的JavaScript文件可以包含在您的页面上，然后该字体就可以在Three.js中使用。
- en: To convert an existing OpenType or TrueType font, you can use the web page at
    [http://typeface.neocracy.org:81/fonts.html](http://typeface.neocracy.org:81/fonts.html).
    On this page, you can upload a font, and it will be converted to JavaScript for
    you. Note that this doesn't work for all types of fonts. The simpler the font
    (more straight lines), the better the chance is that it will be rendered correctly
    when used in Three.js.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换现有的OpenType或TrueType字体，您可以使用[http://typeface.neocracy.org:81/fonts.html](http://typeface.neocracy.org:81/fonts.html)网页。在此页面上，您可以上传字体，它将为您转换为JavaScript。请注意，这并不适用于所有类型的字体。字体越简单（直线越多），在Three.js中使用时正确渲染的机会就越大。
- en: 'To include that font, just add the following line at the top of your HTML page:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含该字体，只需在您的HTML页面顶部添加以下行：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will load the font and make it available to Three.js. If you want to know
    the name of the font (to use with the `font` property), you can print out the
    font cache to the console using the following line of JavaScript:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载字体并使其在Three.js中可用。如果您想了解字体的名称（用于`font`属性），可以使用以下JavaScript代码行将字体缓存打印到控制台：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will print out something like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出如下内容：
- en: '![Adding custom fonts](img/2215OS_06_08.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![添加自定义字体](img/2215OS_06_08.jpg)'
- en: 'Here, you can see that we can use the `helvetiker` font with `weight` as `either
    bold` or `normal`, and the `bitstream vera sans mono` font with `weight` as `normal`.
    Note that each font weight comes in its separate JavaScript file and needs to
    be loaded separately. An alternative way of determining the font name is by looking
    at the JavaScript source file for the font. At the end of the file, you''ll find
    a property with the name `familyName` as shown in the following code. This property
    also contains the name of the font:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们可以使用`helvetiker`字体，其`weight`为`either bold`或`normal`，以及`bitstream
    vera sans mono`字体，其`weight`为`normal`。请注意，每种字体粗细都对应一个单独的JavaScript文件，并且需要单独加载。确定字体名称的另一种方法是查看字体的JavaScript源文件。在文件末尾，您会找到一个名为`familyName`的属性，如下面的代码所示。此属性还包含字体的名称：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next part of this chapter, we''ll introduce the ThreeBSP library to
    create very interesting-looking geometries using the binary operations: `intersect`,
    `subtract`, and `union`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，我们将介绍ThreeBSP库，使用二进制操作：`intersect`、`subtract`和`union`来创建非常有趣的几何体。
- en: Using binary operations to combine meshes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二进制操作组合网格
- en: 'In this section, we''ll look at a different way of creating geometries. In
    this chapter, so far, and in the previous chapter, we used the default geometries
    provided by Three.js to create interesting-looking geometries. With the default
    set of properties, you can create beautiful models, but you are limited to what
    Three.js provides. In this section, we''ll show you how you can combine these
    standard geometries to create new ones—a technique known as **Constructive Solid
    Geometry** (**CSG**) To do this, we use the Three.js extension ThreeBSP, which
    you can find online at [https://github.com/skalnik/ThreeBSP](https://github.com/skalnik/ThreeBSP).
    This additional library provides the following three functions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨创建几何体的另一种方法。到目前为止，在本章以及上一章中，我们使用了Three.js提供的默认几何体来创建看起来有趣的几何体。使用默认的属性集，你可以创建美丽的模型，但你受到Three.js提供的限制。在本节中，我们将向你展示如何将这些标准几何体组合起来创建新的几何体——这是一种称为**构造实体几何**（**CSG**）的技术。为此，我们使用Three.js扩展ThreeBSP，你可以在[https://github.com/skalnik/ThreeBSP](https://github.com/skalnik/ThreeBSP)上找到它。这个额外的库提供了以下三个函数：
- en: '| Name | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `intersect` | This function allows you to create a new geometry based on
    the intersection of two existing geometries. The area where both geometries overlap
    will define the shape of this new geometry. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `intersect` | 此函数允许你根据两个现有几何体的交集创建一个新的几何体。两个几何体重叠的区域将定义这个新几何体的形状。 |'
- en: '| `union` | The union function can be used to combine two geometries and create
    a new one. You can compare this with the `mergeGeometry` functionality we''ll
    look at in [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced Meshes
    and Geometries"), *Creating and Loading Advanced Meshes and Geometries*. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `union` | 联合函数可以用来合并两个几何体并创建一个新的几何体。你可以将此与我们在第8章中将要讨论的`mergeGeometry`功能进行比较，即[第8章](ch08.html
    "第8章. 创建和加载高级网格和几何体")中的*创建和加载高级网格和几何体*。 |'
- en: '| `subtract` | The subtract function is the opposite of the union function.
    You can create a new geometry by removing the overlapping area from the first
    geometry. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `subtract` | 减去函数是联合函数的对立面。你可以通过从第一个几何体中移除重叠区域来创建一个新的几何体。 |'
- en: In the following sections, we'll look at each of these functions in more detail.
    The following screenshot shows an example of what you can create by just using
    the `union` and `subtract` functionalities one after the other.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更详细地探讨这些函数。以下截图显示了仅使用`union`和`subtract`功能依次创建的示例。
- en: '![Using binary operations to combine meshes](img/2215OS_06_09.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用二进制操作合并网格](img/2215OS_06_09.jpg)'
- en: 'To use this library, we need to include it in our page. This library is written
    in CoffeeScript, a more user-friendly variant of JavaScript. To get this working,
    we have two options. We can add the CoffeeScript file and compile it on the fly,
    or we can precompile it to JavaScript and include it directly. For the first approach,
    we need to do the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个库，我们需要将其包含在我们的页面中。这个库是用CoffeeScript编写的，它是JavaScript的一个更易于使用的变体。为了使其工作，我们有两种选择。我们可以添加CoffeeScript文件并在运行时编译它，或者我们可以将其预编译为JavaScript并直接包含它。对于第一种方法，我们需要做以下操作：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ThreeBSP.coffee` file contains the functionality we need for this example,
    and `coffee-script.js` can interpret the Coffee language used for ThreeBSP. A
    final step we need to take is make sure the `ThreeBSP.coffee` file has been parsed
    completely before we start using the ThreeBSP functionality. For this, we add
    the following to the bottom of the file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreeBSP.coffee`文件包含我们在这个例子中需要的功能，而`coffee-script.js`可以解释ThreeBSP使用的Coffee语言。我们需要采取的最后一步是确保在开始使用ThreeBSP功能之前，`ThreeBSP.coffee`文件已经被完全解析。为此，我们在文件的底部添加以下内容：'
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We rename our initial `onload` function to `onReady` like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始的`onload`函数重命名为`onReady`，如下所示：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we precompile CoffeeScript to JavaScript using the CoffeeScript command-line
    tool, we can include the resulting JavaScript file directly. Before we can do
    this, though, we need to install CoffeeScript. You can follow the installation
    instructions on the CoffeeScript website at [http://coffeescript.org/](http://coffeescript.org/).
    Once you''ve installed CoffeeScript, you can use the following command line to
    convert the CoffeeScript ThreeBSP file to JavaScript:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用CoffeeScript命令行工具将CoffeeScript预编译为JavaScript，我们可以直接包含生成的JavaScript文件。不过，在我们这样做之前，我们需要安装CoffeeScript。你可以在CoffeeScript网站上找到安装说明，网址为[http://coffeescript.org/](http://coffeescript.org/)。一旦安装了CoffeeScript，你可以使用以下命令行将CoffeeScript
    ThreeBSP文件转换为JavaScript：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command creates a `ThreeBSP.js` file that we can include in our example
    just as we do with the other JavaScript file. In our examples, we use this second
    approach because it''ll load quicker than compiling the CoffeeScript each time
    we load the page. For this, all we need to do is add the following to the top
    of our HTML page:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个`ThreeBSP.js`文件，我们可以将其包含在我们的示例中，就像我们包含其他JavaScript文件一样。在我们的示例中，我们使用第二种方法，因为它比每次加载页面时编译CoffeeScript要快。为此，我们只需将以下内容添加到我们的HTML页面顶部：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that the ThreeBSP library is loaded, we can use the functions it provides.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在ThreeBSP库已加载，我们可以使用它提供的函数。
- en: The subtract function
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减法函数
- en: Before we start with the `subtract` function, there is one important step you
    need to keep in mind. These three functions use the absolute position of the mesh
    for calculations. So, if you group meshes together or use multiple materials before
    applying these functions, you'll probably get strange results. For the best and
    most predictable result, make sure you're working with ungrouped meshes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用`subtract`函数之前，有一个重要的步骤您需要记住。这三个函数使用网格的绝对位置进行计算。因此，如果您在应用这些函数之前将网格分组或使用多种材质，您可能会得到奇怪的结果。为了获得最佳和最可预测的结果，请确保您正在处理未分组的网格。
- en: 'Let''s start by demonstrating the `subtract` functionality. For this, we''ve
    provided an example, `08-binary-operations.html`. With this example, you can experiment
    with the three operations. When you first open the example on binary operations,
    you''ll see something like the following start screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从演示`subtract`功能开始。为此，我们提供了一个示例，`08-binary-operations.html`。使用此示例，您可以尝试三种操作。当您第一次打开二进制操作示例时，您将看到以下类似的开屏：
- en: '![The subtract function](img/2215OS_06_10.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![减法函数](img/2215OS_06_10.jpg)'
- en: 'There are three wireframes: a cube and two spheres. **Sphere1**, the center
    sphere, is the object on which all operations are executed, **Sphere2** is on
    the right-hand side, and **Cube** is on the left-hand side. On **Sphere2** and
    **Cube**, you can define one of four actions: **subtract**, **union**, **intersect**,
    and **none**. These actions are applied from the point of view of **Sphere1**.
    When we set **Sphere2** to subtract and select **showResult** (and hide the wireframes),
    the result will show **Sphere1** minus the area where **Sphere1** and **Sphere2**
    overlap. Note that a few of these operations might take a couple of seconds to
    complete after you''ve pushed the **showResult** button, so be patient while the
    *busy* indicator is visible.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个线框：一个立方体和两个球体。**Sphere1**，中心球体，是所有操作执行的对象，**Sphere2**位于右侧，**Cube**位于左侧。在**Sphere2**和**Cube**上，您可以定义四种操作之一：**subtract**（减法）、**union**（并集）、**intersect**（交集）和**none**（无）。这些操作是从**Sphere1**的角度应用的。当我们把**Sphere2**设置为减法，并选择**showResult**（并隐藏线框）时，结果将显示**Sphere1**减去**Sphere1**和**Sphere2**重叠的区域。请注意，在您点击**showResult**按钮后，一些操作可能需要几秒钟才能完成，所以当可见的*忙碌*指示器时，请耐心等待。
- en: 'The following screenshot shows the result action of a sphere after subtracting
    another sphere:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在减去另一个球体后球体的结果操作：
- en: '![The subtract function](img/2215OS_06_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![减法函数](img/2215OS_06_11.jpg)'
- en: 'In this example, first the action defined for **Sphere2** is executed, and
    next, the action for **Cube** is executed. So, if we subtract both **Sphere2**
    and **Cube** (which we scale a bit along the *x* axis), we get the following result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，首先执行**Sphere2**定义的操作，然后执行**Cube**的操作。因此，如果我们减去**Sphere2**和**Cube**（我们在*x*轴上稍微缩放），我们将得到以下结果：
- en: '![The subtract function](img/2215OS_06_12.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![减法函数](img/2215OS_06_12.jpg)'
- en: 'The best way to understand the `subtract` functionality is to just play around
    with the example. The ThreeBSP code to accomplish this is very simple and, in
    this example, is implemented in the `redrawResult` function, which we call whenever
    the **showResult** button from the example is clicked on:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`subtract`功能性的最佳方式就是直接在示例中尝试。完成此操作所需的ThreeBSP代码非常简单，在这个示例中，它是在`redrawResult`函数中实现的，每当示例中的**showResult**按钮被点击时，我们都会调用这个函数：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing we do in this code is wrap our meshes (the wireframes you can
    see) in a `ThreeBSP` object. This allows us to apply the `subtract`, `intersect`,
    and `union` functions on these objects. Now, we can just call the specific function
    we want on the `ThreeBSP` object wrapped around the center sphere (`sphere1BSP`),
    and the result from this function will contain all the information we need to
    create a new mesh. To create this mesh, we just call the `toMesh()` function on
    the `sphere1BSP` object. On the resulting object, we have to make sure that all
    the normals are computed correctly by first calling `computeFaceNormals` and then
    calling `computeVertexNormals()`. These compute functions need to be called since
    by running one of the binary operations, the vertices and faces of the geometry
    are changed and this affects the normals of the faces. Explicitly recalculating
    them will make sure your new object is shaded smoothly (when shading on the material
    has been set to `THREE.SmoothShading`) and rendered correctly. Finally, we add
    the result to the scene.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先将我们的网格（你可以看到的线框）包裹在一个`ThreeBSP`对象中。这使得我们可以对这些对象应用`subtract`、`intersect`和`union`函数。现在，我们只需在围绕中心球体（`sphere1BSP`）包裹的`ThreeBSP`对象上调用我们想要的特定函数，这个函数的结果将包含我们创建新网格所需的所有信息。要创建这个网格，我们只需在`sphere1BSP`对象上调用`toMesh()`函数。在生成的对象上，我们必须确保通过首先调用`computeFaceNormals`然后调用`computeVertexNormals()`来正确计算所有法线。由于运行二进制操作之一会改变几何体的顶点和面，这会影响面的法线，因此需要调用这些计算函数。显式地重新计算它们将确保你的新对象在设置材质的着色为`THREE.SmoothShading`时能够平滑着色（正确渲染）。最后，我们将结果添加到场景中。
- en: For `intersect` and `union`, we use exactly the same approach.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`intersect`和`union`，我们使用完全相同的方法。
- en: The intersect function
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相交函数
- en: 'With everything we explained in the previous section, there isn''t much left
    to explain for the `intersect` function. With this function, only the part of
    the meshes that overlap is left. The following screenshot is an example where
    both the sphere and the cube are set to intersect:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中解释了所有内容之后，对于`intersect`函数就没有太多可以解释的了。使用这个函数，只留下网格重叠的部分。以下截图是一个示例，其中球体和立方体都被设置为相交：
- en: '![The intersect function](img/2215OS_06_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![相交函数](img/2215OS_06_13.jpg)'
- en: If you look at the example and play around with the settings, you'll see that
    it's very easy to create these kinds of objects. And remember, this can be applied
    to every mesh you can create, even the complex ones we saw in this chapter, such
    as `THREE.ParametricGeometry` and `THREE.TextGeometry`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个例子并调整设置，你会发现创建这类对象非常容易。而且记住，这可以应用于你创建的任何网格，即使是本章中看到的复杂网格，例如`THREE.ParametricGeometry`和`THREE.TextGeometry`。
- en: 'The `subtract` and `intersect` functions work great together. The example we
    showed at the beginning of this section was created by first subtracting a smaller
    sphere to create a hollow sphere. After that, we used the cube to intersect with
    this hollow sphere to get the following result (a hollow cube with rounded corners):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`subtract`和`intersect`函数配合得很好。本节开头我们展示的例子是通过首先减去一个较小的球体来创建一个空心球体。之后，我们使用立方体与这个空心球体相交以得到以下结果（一个带有圆角的空心立方体）：'
- en: '![The intersect function](img/2215OS_06_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![相交函数](img/2215OS_06_14.jpg)'
- en: The last function provided by ThreeBSP is the `union` function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ThreeBSP提供的最后一个函数是`union`函数。
- en: The union function
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并集函数
- en: 'The final function is the least interesting one of those offered by ThreeBSP.
    With this function, we can combine two meshes together to create a new one. So,
    when we apply this to the two spheres and the cube, we''ll get a single object—a
    result of the union function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数是ThreeBSP提供的函数中最不有趣的一个。使用这个函数，我们可以将两个网格组合在一起以创建一个新的网格。因此，当我们将其应用于两个球体和立方体时，我们将得到一个单一的对象——并集函数的结果：
- en: '![The union function](img/2215OS_06_15.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![并集函数](img/2215OS_06_15.jpg)'
- en: This is not really that useful because this functionality is also provided by
    Three.js (see [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced
    Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*,
    where we explain how to use `THREE.Geometry.merge`), which also offers slightly
    better performance. If you enable rotation, you can see that this union is applied
    from the perspective of the center sphere since it is rotating around the center
    of that sphere. The same applies to the other two operations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不那么有用，因为Three.js也提供了这个功能（参见第8章[Chapter 8](ch08.html "Chapter 8. Creating
    and Loading Advanced Meshes and Geometries")，*创建和加载高级网格和几何形状*，其中我们解释了如何使用`THREE.Geometry.merge`），它还提供略微更好的性能。如果你启用旋转，你可以看到这个合并是从中心球体的视角应用的，因为它围绕该球体的中心旋转。同样的情况也适用于其他两个操作。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw a lot in this chapter. We introduced a couple of advanced geometries
    and even showed you how you can create interesting-looking geometries using a
    couple of simple binary operations. We showed you how you can create really beautiful
    shapes using advanced geometries such as `THREE.ConvexGeometry`, `THREE.TubeGeometry`,
    and `THREE.LatheGeometry` and experiment with these geometries to get the results
    you're looking for. A very nice feature is that we can also convert existing SVG
    paths to Three.js. Remember, though, that you still might need to fine-tune the
    paths using tools such as GIMP, Adobe Illustrator, or Inkscape.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了很多内容。我们介绍了几种高级几何形状，甚至展示了如何使用几个简单的二进制运算来创建看起来有趣的几何形状。我们展示了如何使用像`THREE.ConvexGeometry`、`THREE.TubeGeometry`和`THREE.LatheGeometry`这样的高级几何形状来创建真正美丽的形状，并实验这些几何形状以获得你想要的结果。一个非常不错的功能是，我们还可以将现有的SVG路径转换为Three.js。不过，请记住，你可能仍然需要使用GIMP、Adobe
    Illustrator或Inkscape等工具对路径进行微调。
- en: 'If you want to create 3D text, you need to specify the font to use. Three.js
    comes with a couple of fonts you can use, but you can also create your own fonts.
    However, remember that complex fonts often won''t convert correctly. And finally,
    with ThreeBSP, you have access to three binary operations you can apply to your
    mesh: union, subtract, and intersect. With union, you combine two meshes together;
    with subtract, you remove the overlapping part of the meshes from the source mesh;
    and with intersect, only the overlapping part is kept.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建3D文本，你需要指定要使用的字体。Three.js附带了一些你可以使用的字体，但你也可以创建自己的字体。然而，请记住，复杂的字体通常无法正确转换。最后，使用ThreeBSP，你可以访问可以应用于你的网格的三个二进制运算：合并、减去和相交。使用合并，你可以将两个网格组合在一起；使用减去，你从源网格中移除网格的重叠部分；使用相交，只保留重叠部分。
- en: Until now, we looked at solid (or wireframe) geometries, where vertices are
    connected to each other to form faces. In the following chapter, we'll look at
    an alternative way of visualizing geometries using something called particles.
    With particles, we don't render complete geometries—we just render the vertices
    as points in space. This allows you to create great-looking 3D effects that perform
    well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看的是实体（或线框）几何形状，其中顶点相互连接以形成面。在下一章中，我们将探讨一种使用称为粒子的方法来可视化几何形状的替代方式。使用粒子，我们不渲染完整的几何形状——我们只是将顶点渲染为空间中的点。这允许你创建看起来很棒的3D效果，并且性能良好。
