- en: Chapter 6. Advanced Geometries and Binary Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we showed you all the basic geometries provided by
    Three.js. Besides these basic geometries, Three.js also offers a set of more advanced
    and specialized objects. In this chapter, we''ll show you these advanced geometries
    and cover the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use advanced geometries such as `THREE.ConvexGeometry`, `THREE.LatheGeometry`,
    and `THREE.TubeGeometry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create 3D shapes from 2D shapes using `THREE.ExtrudeGeometry`. We'll
    do this based on a 2D shape drawn using functionality provided by Three.js, and
    we'll show an example where we create a 3D shape based on an externally loaded
    SVG image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to create custom shapes yourself, you can easily amend the ones
    we've discussed in the previous chapters. Three.js, however, also offers a `THREE.ParamtericGeometry`
    object. With this object, you can create a geometry based on a set of equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll look at how you can create 3D text effects using `THREE.TextGeometry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we'll also show you how you can create new geometries from existing
    ones using binary operations provided by the Three.js extension, ThreeBSP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start with the first one from this list, `THREE.ConvexGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.ConvexGeometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `THREE.ConvexGeometry`, we can create a convex hull around a set of points.
    A convex hull is the minimal shape that encompasses all these points. The easiest
    way to understand this is by looking at an example. If you open up the `01-advanced-3d-geometries-convex.html`
    example, you''ll see the convex hull for a random set of points. The following
    screenshot shows this geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.ConvexGeometry](img/2215OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we generate a random set of points and based on these points
    we create `THREE.ConvexGeometry`. In the example, you can click on **redraw**,
    which will generate 20 new points and draw the convex hull. We also add each of
    these points as a small `THREE.SphereGeometry` object to clearly show how a convex
    hull works. `THREE.ConvexGeometry` isn''t included in the standard Three.js distribution,
    so you have to include an additional JavaScript file to use this geometry. At
    the top of your HTML page, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code shows how these points were created and added to
    the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this snippet of code, we create 20 random points (`THREE.Vector3`),
    which we push into an array. Next, we iterate this array and create `THREE.SphereGeometry`,
    whose position we set to one of these points (`position.clone(point)`). All the
    points are added to a group (more on this in [Chapter 7](ch07.html "Chapter 7. Particles,
    Sprites, and the Point Cloud"), *Particles, Sprites, and the Point Cloud*), so
    we can rotate them easily by just rotating the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have this set of points, creating `THREE.ConvexGeometry` is very easy,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: An array containing vertices (of the `THREE.Vector3` type) is the only argument
    `THREE.ConvexGeometry` takes. Here's one final note on the `createMesh()` function
    (which is a function we created ourselves in [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*) we call here. In
    the previous chapter, we used this method to create a mesh using `THREE.MeshNormalMaterial`.
    For this example, we changed this to a translucent green `THREE.MeshBasicMaterial`
    to better show the convex hull we created and the individual points that make
    up this geometry.
  prefs: []
  type: TYPE_NORMAL
- en: The next complex geometry is `THREE.LatheGeometry`, which can be used to create
    vase-like shapes.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.LatheGeometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`THREE.LatheGeometry` allows you to create shapes from a smooth curve. This
    curve is defined by a number of points (also called knots) and is most often called
    a spline. This spline is rotated around the central *z* axis of the object and
    results in vase-like and bell-like shapes. Once again, the easiest way to understand
    what `THREE.LatheGeometry` looks like is by looking at an example. This geometry
    is shown in `02-advanced-3d-geometries-lathe.html`. The following screenshot taken
    from the example shows this geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.LatheGeometry](img/2215OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see the spline as the set of small red
    spheres. The positions of these spheres are passed in to `THREE.LatheGeometry`,
    together with a couple of other arguments. In this example, we rotate this spline
    for half a circle, and based on this spline, we extract the shape you can see.
    Before we look at all the arguments, let''s look at the code used to create the
    spline and how `THREE.LatheGeometry` uses this spline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of JavaScript, you can see that we generate 30 points whose *x*
    coordinate is based on a combination of sine and cosine functions while the *z*
    coordinate is based on the `i` and `count` variables. This creates the spline
    visualized by the red dots in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these points, we can create `THREE.LatheGeometry`. Besides the array
    of vertices, `THREE.LatheGeometry` takes a couple of other arguments. The following
    table lists all the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Mandatory | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `points` | Yes | These are the points that make up the spline used to generate
    the bell/vase shape. |'
  prefs: []
  type: TYPE_TB
- en: '| `segments` | No | These are the number of segments used when creating the
    shape. The higher this number, the more *round* the resulting shape will be. The
    default value for this is `12`. |'
  prefs: []
  type: TYPE_TB
- en: '| `phiStart` | No | This determines where to start on a circle when generating
    the shape. This can range from `0` to `2*PI`. The default value is `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `phiLength` | No | This defines how fully generated the shape is. For instance,
    a quarter shape will be `0.5*PI`. The default value is the full `360` degrees
    or `2*PI`. |'
  prefs: []
  type: TYPE_TB
- en: In the next section, we'll look at an alternative way of creating geometries
    by extracting a 3D geometry from a 2D shape.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a geometry by extruding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Three.js provides a couple of ways in which we can extrude a 2D shape to a 3D
    shape. By extruding, we mean stretching out a 2D shape along its *z* axis to convert
    it to 3D. For instance, if we extrude `THREE.CircleGeometry`, we get a shape that
    looks like a cylinder, and if we extrude `THREE.PlaneGeometry`, we get a cube-like
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: The most versatile way of extruding a shape is using the `THREE.ExtrudeGeometry`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.ExtrudeGeometry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `THREE.ExtrudeGeometry`, you can create a 3D object from a 2D shape. Before
    we dive into the details of this geometry, let''s first look at an example: `03-extrude-geometry.html`.
    The following screenshot taken from the example shows this geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.ExtrudeGeometry](img/2215OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we took the 2D shape we created in the previous chapter and
    used `THREE.ExtrudeGeometry` to convert it to 3D. As you can see in this screenshot,
    the shape is extruded along the *z* axis, which results in a 3D shape. The code
    to create `THREE.ExtrudeGeometry` is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we created the shape with the `drawShape()` function just as we
    did in the previous chapter. This shape is passed on to the `THREE.ExtrudeGeometry`
    constructor together with an `options` object. With the `options` object, you
    can define exactly how the shape should be extruded. The following table explains
    the options you can pass in to `THREE.ExtrudeGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Mandatory | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `shapes` | Yes | One or more shapes (`THREE.Shape` objects) are required
    to extrude the geometry from. See the preceding chapter on how to create such
    a shape. |'
  prefs: []
  type: TYPE_TB
- en: '| `amount` | No | This determines how far (the depth) the shape should be extruded.
    The default value is `100`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelThickness` | No | This determines the depth of the bevel. The bevel
    is the rounded corner between the front and back faces and the extrusion. This
    value defines how deep into the shape the bevel goes. The default value is `6`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelSize` | No | This determines the height of the bevel. This is added
    to the normal height of the shape. The default value is `bevelThickness - 2`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelSegments` | No | This defines the number of segments that will be used
    by the bevel. The more the number of segments used, the smoother the bevel will
    look. The default value is `3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelEnabled` | No | If this is set to `true`, a bevel is added. The default
    value is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `curveSegments` | No | This determines how many segments will be used when
    extruding the curves of shapes. The more the number of segments used, the smoother
    the curves will look. The default value is `12`. |'
  prefs: []
  type: TYPE_TB
- en: '| `steps` | No | This defines the number of segments into the extrusion will
    be divided along its depth. The default value is `1`. A higher value will result
    in more individual faces. |'
  prefs: []
  type: TYPE_TB
- en: '| `extrudePath` | No | This is the path (`THREE.CurvePath`) along which the
    shape should be extruded. If this isn''t specified, the shape is extruded along
    the *z* axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `material` | No | This is the index of the material to use for the front
    and the back faces. Use the `THREE.SceneUtils.createMultiMaterialObject` function
    to create the mesh if you want separate materials for the front and back faces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `extrudeMaterial` | No | This is the index of the materials to use for the
    bevel and the extrusion. Use the `THREE.SceneUtils.createMultiMaterialObject`
    function to create the mesh if you want separate materials for the front and back
    faces. |'
  prefs: []
  type: TYPE_TB
- en: '| `uvGenerator` | No | When you use a texture with your material, the UV mapping
    determines what part of a texture is used for a specific face. With the `uvGenerator`
    property, you can pass in your own object that will create the UV settings for
    the faces that are created for the shapes that are passed in. More information
    on UV settings can be found in [Chapter 10](ch10.html "Chapter 10. Loading and
    Working with Textures"), *Loading and Working with Textures*. If none are specified,
    `THREE.ExtrudeGeometry.WorldUVGenerator` is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `frames` | No | A frenet frame is used to calculate the tangents, normal,
    and binormals of a spline. This is used when extruding along `extrudePath`. You
    don''t need to specify this since Three.js provides its own implementation, `THREE.TubeGeometry.FrenetFrames`,
    which is also used as default. More information on frenet frames can be found
    at [http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame).
    |'
  prefs: []
  type: TYPE_TB
- en: You can experiment with these options using the menu from the `03-extrude-geometry.html`
    example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we extruded the shape along its *z* axis. As you would have
    seen in the options, you can also extrude a shape along a path with the `extrudePath`
    option. In the following geometry, `THREE.TubeGeometry`, we'll do just that.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.TubeGeometry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`THREE.TubeGeometry` creates a tube that extrudes along a 3D spline. You specify
    the path using a number of vertices, and `THREE.TubeGeometry` will create the
    tube. An example which you can experiment with can be found in the sources for
    this chapter (`04-extrude-tube.html`). The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.TubeGeometry](img/2215OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in this example, we generate a number of random points and use
    those points to draw the tube. With the controls in the upper-right corner, we
    can define how the tube looks or generate a new tube by clicking on the **newPoints**
    button. The code needed to create a tube is very simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we need to do first is get a set of vertices of the `THREE.Vector3` type
    just like we did for `THREE.ConvexGeometry` and `THREE.LatheGeometry`. Before
    we can use these points, however, to create the tube, we first need to convert
    these points to `THREE.SplineCurve3`. In other words, we need to define a smooth
    curve through the points we defined. We can do this simply by passing in the array
    of vertices to the constructor of `THREE.SplineCurve3`. With this spline and the
    other arguments (which we'll explain in a bit), we can create the tube and add
    it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.TubeGeometry` takes some other arguments besides `THREE.SplineCurve3`.
    The following table lists all the arguments for `THREE.TubeGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Mandatory | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | Yes | This is `THREE.SplineCurve3` that describes the path this
    tube should follow. |'
  prefs: []
  type: TYPE_TB
- en: '| `segments` | No | These are the segments used to build up the tube. The default
    value is `64`. The longer the path, the more segments you should specify. |'
  prefs: []
  type: TYPE_TB
- en: '| `radius` | No | This is the radius of the tube. The default value is `1`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `radiusSegments` | No | This is the number of segments to be used along the
    length of the tube. The default value is `8`. The more you use, the more *round*
    the tube will look. |'
  prefs: []
  type: TYPE_TB
- en: '| `closed` | No | If this is set to `true`, the start of the tube and the end
    will be connected together. The default value is `false`. |'
  prefs: []
  type: TYPE_TB
- en: The last extrude example we'll show in this chapter isn't really a different
    geometry. In the next section, we'll show you how you can use `THREE.ExtrudeGeometry`
    to create extrusions from existing SVG paths.
  prefs: []
  type: TYPE_NORMAL
- en: Extrude from SVG
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we discussed `THREE.ShapeGeometry`, we mentioned that SVG follows pretty
    much the same approach of drawing shapes. SVG has a very close match with how
    Three.js handles shapes. In this section, we'll look at how you can use a small
    library from [https://github.com/asutherland/d3-threeD](https://github.com/asutherland/d3-threeD)
    to convert SVG paths to a Three.js shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `05-extrude-svg.html` example, I''ve taken an SVG drawing of the Batman
    logo and used `ExtrudeGeometry` to convert it to 3D, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extrude from SVG](img/2215OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, let''s look at what the original SVG code looks like (you can also see
    this for yourself when looking at the source code for this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unless you're an SVG guru, this will probably mean nothing to you. Basically
    though, what you see here are a set of drawing instructions. For instance, `C
    277.987 119.348 279.673 116.786 279.673 115.867` tells the browser to draw a cubic
    Bezier curve, and `L 489.242 111.787` tells us that we should draw a line to that
    specific position. Luckily though, we won't have to write the code to interpret
    this ourselves. With the d3-threeD library, we can convert this automatically.
    This library was originally created to be used together with the excellent **D3.js**
    library, but with some small adaptions, we can also use this specific functionality
    standalone.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**SVG** stands for **Scalable Vector Graphics**. This is an XML-based standard
    that can be used to create vector-based 2D images for the Web. This is an open
    standard that is supported by all of the modern browsers. Directly working with
    SVG and manipulating it from JavaScript, however, isn''t very straightforward.
    Luckily, there are a couple of open source JavaScript libraries that make working
    with SVG a lot easier. **Paper.js**, **Snap.js**, **D3.js**, and **Raphael.js**
    are some of the best.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code fragment shows how we can load in the SVG you saw earlier,
    convert it to `THREE.ExtrudeGeometry`, and show it on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code fragment, you''ll see a call to the `transformSVGPathExposed`
    function. This function is provided by the d3-threeD library and takes an SVG
    string as an argument. We get this SVG string directly from the SVG element with
    the following expression: `document.querySelector("#batman-path").getAttribute("d")`.
    In SVG, the `d` attribute contains the path statements used to draw a shape. Add
    a nice-looking shiny material and a spotlight and you''ve recreated this example.'
  prefs: []
  type: TYPE_NORMAL
- en: The last geometry we'll discuss in this section is `THREE.ParametricGeometry`.
    With this geometry, you can specify a couple of functions that are used to programmatically
    create geometries.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.ParametricGeometry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `THREE.ParametricGeometry`, you can create a geometry based on an equation.
    Before we dive into our own example, a good thing to start with is to look at
    the examples already provided by Three.js. When you download the Three.js distribution,
    you get the `examples/js/ParametricGeometries.js` file. In this file, you can
    find a couple of examples of equations you can use together with `THREE.ParametricGeometry`.
    The most basic example is the function to create a plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function is called by `THREE.ParametricGeometry`. The `u` and `v` values
    will range from `0` to `1` and will be called a large number of times for all
    the values from `0` to `1`. In this example, the `u` value is used to determine
    the *x* coordinate of the vector and the `v` value is used to determine the *z*
    coordinate. When this is run, you'll have a basic plane with a width of `width`
    and a depth of `depth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we do something similar. However, instead of creating a flat
    plane, we create a wave-like pattern, as you can see in the `06-parametric-geometries.html`
    example. The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.ParametricGeometry](img/2215OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create this shape, we passed in the following function to `THREE.ParametricGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this example, with a few lines of code, we can create really
    interesting geometries. In this example, you can also see the arguments we can
    pass in to `THREE.ParametricGeometry`. These are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Mandatory | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `function` | Yes | This is the function that defines the position of each
    vertex based on the `u` and `v` values provided |'
  prefs: []
  type: TYPE_TB
- en: '| `slices` | Yes | This defines the number of parts the `u` value should be
    divided into |'
  prefs: []
  type: TYPE_TB
- en: '| `stacks` | Yes | This defines the number of parts the `v` value should be
    divided into |'
  prefs: []
  type: TYPE_TB
- en: 'I''d like to make a final note on how to use the `slices` and `stacks` properties
    before moving on to the final part of this chapter. We mentioned that the `u`
    and `v` properties are passed in to the `function` argument provided, and that
    the values of these two properties range from `0` to `1`. With the `slices` and
    `stacks` properties, we can define how often the passed-in function is called.
    If, for instance, we set `slices` to `5` and `stacks` to `4`, the function will
    be called with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, the higher this value, the more vertices you get to specify and the smoother
    your created geometry will be. You can use the menu in the top-right corner of
    the `06-parametric-geometries.html` example to see this effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more examples, you can look at the `examples/js/ParametricGeometries.js`
    file in the Three.js distribution. This file contains functions to create the
    following geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: Klein bottle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flat mobius strip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3d mobius strip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Torus knot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last part of this chapter deals with creating 3D text objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating 3D text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part of this chapter, we'll have a quick look at how you can create
    3D text effects. First, we'll look at how to render text using the fonts provided
    by Three.js, and after that, we'll have a quick look at how you can use your own
    fonts for this.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rendering text in Three.js is very easy. All you have to do is define the font
    you want to use and the basic extrude properties we saw when we discussed `THREE.ExtrudeGeometry`.
    The following screenshot shows the `07-text-geometry.html` example on how to render
    text in Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering text](img/2215OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code required to create this 3D text is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at all the options we can specify for `THREE.TextGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Mandatory | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | No | This is the size of the text. The default value is `100`. |'
  prefs: []
  type: TYPE_TB
- en: '| `height` | No | This is the length (depth) of the extrusion. The default
    value is `50`. |'
  prefs: []
  type: TYPE_TB
- en: '| `weight` | No | This is the weight of the font. The possible values are `normal`
    and `bold`. The default value is `normal`. |'
  prefs: []
  type: TYPE_TB
- en: '| `font` | No | This is the name of the font to be used. The default value
    is `helvetiker`. |'
  prefs: []
  type: TYPE_TB
- en: '| `style` | No | This is the weight of the font. The possible values are `normal`
    and `italic`. The default value is `normal`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelThickness` | No | This is the depth of the bevel. The bevel is the
    rounded corner between the front and back faces and the extrusion. The default
    value is `10`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelSize` | No | This is the height of the bevel. The default value is
    `8`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelSegments` | No | This defines the number of segments that will be used
    by the bevel. The more segments there are, the smoother the bevel will look. The
    default value is `3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bevelEnabled` | No | If this is set to `true`, a bevel is added. The default
    value is `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `curveSegments` | No | This defines the number segments used when extruding
    the curves of shapes. The more segments there are, the smoother the curves will
    look. The default value is `4`. |'
  prefs: []
  type: TYPE_TB
- en: '| `steps` | No | This defines the number of segments the extrusion will be
    divided into. The default value is `1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `extrudePath` | No | This is the path along which the shape should be extruded.
    If this isn''t specified, the shape is extruded along the *z* axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `material` | No | This is the index of the material to be used for the front
    and back faces. Use the `THREE.SceneUtils.createMultiMaterialObject` function
    to create the mesh. |'
  prefs: []
  type: TYPE_TB
- en: '| `extrudeMaterial` | No | This is the index of the material to be used for
    the bevel and the extrusion. Use the `THREE.SceneUtils.createMultiMaterialObject`
    function to create the mesh. |'
  prefs: []
  type: TYPE_TB
- en: '| `uvGenerator` | No | When you use a texture with your material, the UV mapping
    determines what part of a texture is used for a specific face. With the `UVGenerator`
    property, you can pass in your own object that will create the UV settings for
    the faces that are created for the passed-in shapes. More information on UV settings
    can be found in [Chapter 10](ch10.html "Chapter 10. Loading and Working with Textures"),
    *Loading and Working with Textures*. If none are specified, `THREE.ExtrudeGeometry.WorldUVGenerator`
    is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `frames` | No | A frenet frame is used to calculate the tangents, normal,
    and binormals of a spline. This is used when extruding along `extrudePath`. You
    don''t need to specify this because Three.js provides its own implementation,
    `THREE.TubeGeometry.FrenetFrames`, which is also used as default. More information
    on frenet frames can be found at [http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame).
    |'
  prefs: []
  type: TYPE_TB
- en: The fonts that are included in Three.js are also added to the sources for this
    book. You can find them in the `assets/fonts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to render fonts in 2D, for instance, to use them as a texture for
    a material, you shouldn't use `THREE.TextGeometry`. `THREE.TextGeometry`, which
    internally uses `THREE.ExtrudeGeometry` to build the 3D text, and the JavaScript
    fonts introduce a lot of overhead. Rendering a simple 2D font is better than just
    using the HTML5 canvas. With `context.font`, you can set the font to be used,
    and with `context.fillText`, you can output text to the canvas. You can then use
    this canvas as input for your texture. We will show you how to do this in [Chapter
    10](ch10.html "Chapter 10. Loading and Working with Textures"), *Loading and Working
    with Textures*.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to use other fonts with this geometry, but you first need
    to convert them to JavaScript. How to do this is shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of fonts provided by Three.js that you can use in your scenes.
    These fonts are based on the fonts provided by **typeface.js** ([http://typeface.neocracy.org:81/](http://typeface.neocracy.org:81/)).
    Typeface.js is a library that can convert TrueType and OpenType fonts to JavaScript.
    The resulting JavaScript file can be included in your page, and the font can then
    be used in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: To convert an existing OpenType or TrueType font, you can use the web page at
    [http://typeface.neocracy.org:81/fonts.html](http://typeface.neocracy.org:81/fonts.html).
    On this page, you can upload a font, and it will be converted to JavaScript for
    you. Note that this doesn't work for all types of fonts. The simpler the font
    (more straight lines), the better the chance is that it will be rendered correctly
    when used in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include that font, just add the following line at the top of your HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will load the font and make it available to Three.js. If you want to know
    the name of the font (to use with the `font` property), you can print out the
    font cache to the console using the following line of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding custom fonts](img/2215OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see that we can use the `helvetiker` font with `weight` as `either
    bold` or `normal`, and the `bitstream vera sans mono` font with `weight` as `normal`.
    Note that each font weight comes in its separate JavaScript file and needs to
    be loaded separately. An alternative way of determining the font name is by looking
    at the JavaScript source file for the font. At the end of the file, you''ll find
    a property with the name `familyName` as shown in the following code. This property
    also contains the name of the font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next part of this chapter, we''ll introduce the ThreeBSP library to
    create very interesting-looking geometries using the binary operations: `intersect`,
    `subtract`, and `union`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using binary operations to combine meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at a different way of creating geometries. In
    this chapter, so far, and in the previous chapter, we used the default geometries
    provided by Three.js to create interesting-looking geometries. With the default
    set of properties, you can create beautiful models, but you are limited to what
    Three.js provides. In this section, we''ll show you how you can combine these
    standard geometries to create new ones—a technique known as **Constructive Solid
    Geometry** (**CSG**) To do this, we use the Three.js extension ThreeBSP, which
    you can find online at [https://github.com/skalnik/ThreeBSP](https://github.com/skalnik/ThreeBSP).
    This additional library provides the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `intersect` | This function allows you to create a new geometry based on
    the intersection of two existing geometries. The area where both geometries overlap
    will define the shape of this new geometry. |'
  prefs: []
  type: TYPE_TB
- en: '| `union` | The union function can be used to combine two geometries and create
    a new one. You can compare this with the `mergeGeometry` functionality we''ll
    look at in [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced Meshes
    and Geometries"), *Creating and Loading Advanced Meshes and Geometries*. |'
  prefs: []
  type: TYPE_TB
- en: '| `subtract` | The subtract function is the opposite of the union function.
    You can create a new geometry by removing the overlapping area from the first
    geometry. |'
  prefs: []
  type: TYPE_TB
- en: In the following sections, we'll look at each of these functions in more detail.
    The following screenshot shows an example of what you can create by just using
    the `union` and `subtract` functionalities one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using binary operations to combine meshes](img/2215OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To use this library, we need to include it in our page. This library is written
    in CoffeeScript, a more user-friendly variant of JavaScript. To get this working,
    we have two options. We can add the CoffeeScript file and compile it on the fly,
    or we can precompile it to JavaScript and include it directly. For the first approach,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ThreeBSP.coffee` file contains the functionality we need for this example,
    and `coffee-script.js` can interpret the Coffee language used for ThreeBSP. A
    final step we need to take is make sure the `ThreeBSP.coffee` file has been parsed
    completely before we start using the ThreeBSP functionality. For this, we add
    the following to the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We rename our initial `onload` function to `onReady` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we precompile CoffeeScript to JavaScript using the CoffeeScript command-line
    tool, we can include the resulting JavaScript file directly. Before we can do
    this, though, we need to install CoffeeScript. You can follow the installation
    instructions on the CoffeeScript website at [http://coffeescript.org/](http://coffeescript.org/).
    Once you''ve installed CoffeeScript, you can use the following command line to
    convert the CoffeeScript ThreeBSP file to JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a `ThreeBSP.js` file that we can include in our example
    just as we do with the other JavaScript file. In our examples, we use this second
    approach because it''ll load quicker than compiling the CoffeeScript each time
    we load the page. For this, all we need to do is add the following to the top
    of our HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that the ThreeBSP library is loaded, we can use the functions it provides.
  prefs: []
  type: TYPE_NORMAL
- en: The subtract function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start with the `subtract` function, there is one important step you
    need to keep in mind. These three functions use the absolute position of the mesh
    for calculations. So, if you group meshes together or use multiple materials before
    applying these functions, you'll probably get strange results. For the best and
    most predictable result, make sure you're working with ungrouped meshes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by demonstrating the `subtract` functionality. For this, we''ve
    provided an example, `08-binary-operations.html`. With this example, you can experiment
    with the three operations. When you first open the example on binary operations,
    you''ll see something like the following start screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The subtract function](img/2215OS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three wireframes: a cube and two spheres. **Sphere1**, the center
    sphere, is the object on which all operations are executed, **Sphere2** is on
    the right-hand side, and **Cube** is on the left-hand side. On **Sphere2** and
    **Cube**, you can define one of four actions: **subtract**, **union**, **intersect**,
    and **none**. These actions are applied from the point of view of **Sphere1**.
    When we set **Sphere2** to subtract and select **showResult** (and hide the wireframes),
    the result will show **Sphere1** minus the area where **Sphere1** and **Sphere2**
    overlap. Note that a few of these operations might take a couple of seconds to
    complete after you''ve pushed the **showResult** button, so be patient while the
    *busy* indicator is visible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result action of a sphere after subtracting
    another sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The subtract function](img/2215OS_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, first the action defined for **Sphere2** is executed, and
    next, the action for **Cube** is executed. So, if we subtract both **Sphere2**
    and **Cube** (which we scale a bit along the *x* axis), we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The subtract function](img/2215OS_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The best way to understand the `subtract` functionality is to just play around
    with the example. The ThreeBSP code to accomplish this is very simple and, in
    this example, is implemented in the `redrawResult` function, which we call whenever
    the **showResult** button from the example is clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do in this code is wrap our meshes (the wireframes you can
    see) in a `ThreeBSP` object. This allows us to apply the `subtract`, `intersect`,
    and `union` functions on these objects. Now, we can just call the specific function
    we want on the `ThreeBSP` object wrapped around the center sphere (`sphere1BSP`),
    and the result from this function will contain all the information we need to
    create a new mesh. To create this mesh, we just call the `toMesh()` function on
    the `sphere1BSP` object. On the resulting object, we have to make sure that all
    the normals are computed correctly by first calling `computeFaceNormals` and then
    calling `computeVertexNormals()`. These compute functions need to be called since
    by running one of the binary operations, the vertices and faces of the geometry
    are changed and this affects the normals of the faces. Explicitly recalculating
    them will make sure your new object is shaded smoothly (when shading on the material
    has been set to `THREE.SmoothShading`) and rendered correctly. Finally, we add
    the result to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: For `intersect` and `union`, we use exactly the same approach.
  prefs: []
  type: TYPE_NORMAL
- en: The intersect function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With everything we explained in the previous section, there isn''t much left
    to explain for the `intersect` function. With this function, only the part of
    the meshes that overlap is left. The following screenshot is an example where
    both the sphere and the cube are set to intersect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The intersect function](img/2215OS_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the example and play around with the settings, you'll see that
    it's very easy to create these kinds of objects. And remember, this can be applied
    to every mesh you can create, even the complex ones we saw in this chapter, such
    as `THREE.ParametricGeometry` and `THREE.TextGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `subtract` and `intersect` functions work great together. The example we
    showed at the beginning of this section was created by first subtracting a smaller
    sphere to create a hollow sphere. After that, we used the cube to intersect with
    this hollow sphere to get the following result (a hollow cube with rounded corners):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The intersect function](img/2215OS_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last function provided by ThreeBSP is the `union` function.
  prefs: []
  type: TYPE_NORMAL
- en: The union function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final function is the least interesting one of those offered by ThreeBSP.
    With this function, we can combine two meshes together to create a new one. So,
    when we apply this to the two spheres and the cube, we''ll get a single object—a
    result of the union function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The union function](img/2215OS_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is not really that useful because this functionality is also provided by
    Three.js (see [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced
    Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*,
    where we explain how to use `THREE.Geometry.merge`), which also offers slightly
    better performance. If you enable rotation, you can see that this union is applied
    from the perspective of the center sphere since it is rotating around the center
    of that sphere. The same applies to the other two operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw a lot in this chapter. We introduced a couple of advanced geometries
    and even showed you how you can create interesting-looking geometries using a
    couple of simple binary operations. We showed you how you can create really beautiful
    shapes using advanced geometries such as `THREE.ConvexGeometry`, `THREE.TubeGeometry`,
    and `THREE.LatheGeometry` and experiment with these geometries to get the results
    you're looking for. A very nice feature is that we can also convert existing SVG
    paths to Three.js. Remember, though, that you still might need to fine-tune the
    paths using tools such as GIMP, Adobe Illustrator, or Inkscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create 3D text, you need to specify the font to use. Three.js
    comes with a couple of fonts you can use, but you can also create your own fonts.
    However, remember that complex fonts often won''t convert correctly. And finally,
    with ThreeBSP, you have access to three binary operations you can apply to your
    mesh: union, subtract, and intersect. With union, you combine two meshes together;
    with subtract, you remove the overlapping part of the meshes from the source mesh;
    and with intersect, only the overlapping part is kept.'
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we looked at solid (or wireframe) geometries, where vertices are
    connected to each other to form faces. In the following chapter, we'll look at
    an alternative way of visualizing geometries using something called particles.
    With particles, we don't render complete geometries—we just render the vertices
    as points in space. This allows you to create great-looking 3D effects that perform
    well.
  prefs: []
  type: TYPE_NORMAL
