<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Getting Skype to Work for You</h1></div></div></div><p>
<strong>Skype</strong> (<a class="ulink" href="http://www.skype.com">
http://www.skype.com
</a>) is an awesome piece of software and a reliable platform that is used by millions of people worldwide in order to make calls, organize meetings, and chat with each other. It is used for both personal communication as well as for business.</p><p>One of the great things about Skype is that it allows you make free peer-to-peer VoIP calls with any other user that also has a Skype account. It also allows you to call phone numbers at very cheap rates and even for free to some locations.</p><p>Besides that, Skype can also allow you to receive incoming calls on a real phone number or divert them to become text messages. It also allows message forwarding, conferencing, group chatting, file transferring, remote desktop presentation, viewing, and many other features.</p><p>So far, it sounds like Skype is a great communication platform, and it is. But what about using Skype as an automated agent that can help to get some work done and could automate some business processes, in order to make our lives easier? Is this even possible?</p><p>The good news is that, indeed, it is possible. Skype is now part of Microsoft (<a class="ulink" href="https://www.microsoft.com/en-in">https://www.microsoft.com/en-in</a>/) and, recently, at the build developer's event, a framework for creating interactive bots with Skype was unveiled. Skype already has a set of cool and extremely useful APIs, which make it relatively easy for developers to interact with the service, and is great for all sorts of voice and chat-related applications. However, it does not have an API that is solely focused on interactive messaging automation and this is where the <strong>Bot Framework</strong> (<a class="ulink" href="https://dev.botframework.com">
https://dev.botframework.com
</a>) comes in to fill the void.</p><p>In this chapter, we'll explore how to use this framework in order to build a Skype bot that acts like a virtual <strong>Human Resources</strong> (<strong>HR</strong>) assistant, which should be able to provide information about vacation days, notice periods, and other HR-related queries.</p><p>Sounds like a lot of fun! Let's get started.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>How a Skype bot works</h1></div></div></div><p>A Skype bot is, in essence, just another Skype contact; the difference is that, instead of talking to another person, it's an automated process that knows how to reply to the input you provide. Bots can do many things, such as fetch the news, check the weather, retrieve photos or information from websites, start a game, or order food or a taxi for you.</p><p>Anything that can be turned into a service can be converted into an automated conversation by using a bot. With Skype, bots can have interactive conversations on nearly every platform, at any time, and from anywhere.</p><p>Users can send a Skype bot request, and your bot can send back meaningful feedback based on the content received. A Skype bot can also be part of a group conversation and send details to all the parties involved in that group.</p><p>The way a Skype bot technically works is that it connects and listens to the bot platform using the Skype bot API directly, or using the C# or Node.js SDK. We'll obviously focus our attention on the Node.js SDK.</p><p>When a user sends a message to your Skype bot, we route this activity to a <strong>Webhook</strong> (<a class="ulink" href="https://en.wikipedia.org/wiki/Webhook">
https://en.wikipedia.org/wiki/Webhook
</a>) that is defined for the bot. The bot then sends replies back to the bot platform, which passes them on to the user. The Webhooks (which are valid public URLs-HTTP Messaging endpoints) will typically run on a cloud service such as <strong>Microsoft </strong>
<strong>Azure</strong> (<a class="ulink" href="https://azure.microsoft.com">
https://azure.microsoft.com
</a>).</p><p>Webhooks are called with JSON-formatted requests. Every JSON object indicates some update and looks like this:</p><pre class="programlisting">[ &#13;
{ &#13;
   "activity" : "message", &#13;
   "from" : "awesomeskypebot", &#13;
   "to" : "28:2c967451-ee01-421f-92aa-1a80f9e163dc", &#13;
   "time" : "2016-03-30T09:50:01.123Z", &#13;
   "id" : "1443805282113", &#13;
   "content" : "Hello from a Bot!" &#13;
} &#13;
] &#13;
</pre><p>In essence, a bot goes through various stages. Initially the bot can be added to a limited number of users for development, which allows the bot details to be edited, and also allows for previewing features such as group chat or calling. In the example we will build in this chapter, we will focus on chatting (text interaction) and not calling, but it is useful to know that this feature is also possible. Here are the stages:</p><div><ul class="itemizedlist"><li class="listitem">Bot creation/editing (initial stage)</li><li class="listitem">Bot review</li><li class="listitem">Bot published</li></ul></div><p>Following the creation or editing stage is the review stage, which is just before publishing your bot. Once in review, you cannot edit the attributes of your bot on the portal (such as its name and other properties). It is important to note that a bot cannot be submitted using preview features such as group chat or calling.</p><p>Once the review of the bot has been accepted, it goes into the published stage. At this point in time, the bot can be added by any number of users via the bot URL link or button.</p><p>Finally, soon after it has been published, the bot is then shown in the Skype bot directory.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec9"/>Wiring up our Skype bot</h2></div></div></div><p>With the theory behind us, let's now dig into the details of how we can start using the Bot Framework with Node.js in order to create our Skype HR bot.</p><p>In the previous chapter, we saw how to get Node.js installed and also how to deploy our Twilio example to Azure website. For our Skype bot, we'll follow a very similar process.</p><p>Let's first start by creating a folder in our local drive from the Command Prompt in order to store our bot:</p><pre class="programlisting">
<strong>mkdir skypebot</strong>
<strong>cd skypebot</strong>
</pre><p>Assuming we have Node.js and npm installed (if not, please refer to the steps in <a class="link" title="Chapter 1. The Rise of Bots – Getting the Message Across" href="part0015.xhtml#aid-E9OE1">
Chapter 1
</a>, <em>The Rise of Bots – Getting the Message Across</em>), let's create and initialize our <code class="literal">package.json</code>, which will store our bot's dependencies and definitions:</p><pre class="programlisting">
<strong>npm init</strong>
</pre><p>When you go through the <code class="literal">npm init</code> options (which are very easy to follow), you'll see something similar to this. In some cases you might get an <code class="literal">index.js</code> file created; however, going forward, we'll instead use the name <code class="literal">app.js</code> as shown in the following screenshot:</p><p>
</p><div><img src="img/image00175.jpeg" alt="Wiring up our Skype bot"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>In your project folder, you'll see the result, which is your <code class="literal">package.json</code> file:</p><p>
</p><div><img src="img/image00176.jpeg" alt="Wiring up our Skype bot"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Just like we did in our previous example, we will use <strong>Express</strong> (<a class="ulink" href="http://expressjs.com">
http://expressjs.com
</a>) as our <strong>REST</strong> Node.js framework. We'll install it and save it to our <code class="literal">package.json</code> file, as follows:</p><pre class="programlisting">
<strong>npm install express --save</strong>
</pre><p> 
Once Express has been installed, you should see something like this:</p><p>
</p><div><img src="img/image00177.jpeg" alt="Wiring up our Skype bot"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>With Express set up, the next thing to do is to install the <code class="literal">BotBuilder</code> package, which corresponds to the Microsoft Bot Framework Node.js library. Let's do that now.</p><p>In order to install it, run this <code class="literal">npm</code> command:</p><pre class="programlisting">
<strong>npm install --save botbuilder</strong>
</pre><p>After <code class="literal">BotBuilder</code> has been installed, you should see in your command line a result similar to the following screenshot:</p><p>
</p><div><img src="img/image00178.jpeg" alt="Wiring up our Skype bot"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Your <code class="literal">package.json</code> should then look similar to mine, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00179.jpeg" alt="Wiring up our Skype bot"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>With our bot all wired up, we can then focus on creating the Express endpoints and core logic.</p><p>Let's create our <code class="literal">app.js</code> file, which will be the entry point to our bot. You can create the <code class="literal">app.js</code> file by using the applicable menu option in the editor of your choice.</p><p>Our Skype skeleton bot <code class="literal">app.js</code> should look like this:</p><pre class="programlisting">var skype = require('botbuilder'); &#13;
var express = require('express'); &#13;
 &#13;
var app = express(); &#13;
 &#13;
var botService = new skype.ChatConnector({ &#13;
    appId: '', &#13;
    appPassword: '' &#13;
}); &#13;
 &#13;
var bot = new skype.UniversalBot(botService); &#13;
 &#13;
app.post('/api/messages', botService.listen()); &#13;
 &#13;
bot.dialog('/', function (session) { &#13;
  if (session.message.text.toLowerCase().indexOf('hi') &gt;= 0){ &#13;
    session.send('Hi ' + session.message.user.name +  &#13;
     ' thank you for your message: ' + session.message.text); &#13;
  } else{ &#13;
    session.send('Sorry I don't understand you...'); &#13;
  } &#13;
}); &#13;
 &#13;
app.get('/', function (req, res) { &#13;
  res.send('SkypeBot listening...'); &#13;
}); &#13;
 &#13;
app.listen(process.env.port, function () { &#13;
  console.log('SkypeBot listening...'); &#13;
}); &#13;
</pre><p>Now let's break this into smaller chunks. The first thing we do is to reference the Bot Framework we previously installed using npm:</p><pre class="programlisting">var skype = require('botbuilder'); &#13;
</pre><p>Once we've indicated this, we need to reference the Express framework, as follows:</p><pre class="programlisting">var express = require('express');&#13;
</pre><p>Once we have our references all set up, we can proceed to create the <code class="literal">botService</code> object and wire it up an <code class="literal">HTTP POST</code> endpoint, hosted on Azure websites, which the Skype bot service will push incoming messages to for our bot to reply to.</p><p>Please note that the <code class="literal">botService</code> object requires <code class="literal">APP_ID</code> and <code class="literal">APP_SECRET</code> variables that we will get from the Bot Framework once we have registered it with on the bot developer portal, for which we will go through the steps shortly.</p><p>The <code class="literal">botService</code> object is created as follows:</p><pre class="programlisting">var APP_ID = ''; &#13;
var APP_SECRET = ''; &#13;
 &#13;
var botService = new skype.ChatConnector({ &#13;
    appId: APP_ID, &#13;
    appPassword: APP_SECRET &#13;
}); &#13;
 &#13;
var bot = new skype.UniversalBot(botService); &#13;
</pre><p>With the <code class="literal">botService</code> object created, it needs to be wired up so that the Skype bot knows where to <code class="literal">POST</code> the incoming message requests, so they can be processed by the bot. This is achieved by adding this to <code class="literal">app.js</code>, as shown in the following:</p><pre class="programlisting">app.post('/api/messages', botService.listen())&#13;
</pre><p>This basically registers the <code class="literal">botService</code> object on the publicly accessible <code class="literal">/api/messages</code> HTTP endpoint exposed through the Azure website where this Node.js will be running.
 Finally, the Node.js app is exposed by listening on the port <code class="literal">process.env.port</code> as follows, by adding this to <code class="literal">app.js</code>:</p><pre class="programlisting">app.listen(process.env.port, function () { &#13;
  console.log('SkypeBot listening...'); &#13;
}); &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Registering our Skype bot app</h2></div></div></div><p>In order to for this to work, we'll need to register our bot within the Bot Framework Developer Portal. In order to do this, sign in with your Microsoft account at <a class="ulink" href="https://dev.botframework.com/">
https://dev.botframework.com/
</a>. You'll be presented with this screen:</p><p>
</p><div><img src="img/image00180.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Click on the <strong>Register a bot</strong> option in order to create and register your Skype bot. Once you've done that, you'll see the following screen:</p><p>
</p><div><img src="img/image00181.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As you can see, there are three basic fields that are mandatory. The first field represents the bot's name, which will be used to identify the bot within the bot directory (if we later decide to make it public). It cannot be longer than 35 characters.</p><p>The second field is the bot's handle, which will be used as part of the bot's public URL. It only allows alphanumeric and underscore characters, and it cannot be changed after registration.</p><p>The third field is the bot's description. The first 46 characters are displayed on the bot's card on the bot directory and the rest of the description is displayed under the bot's details.</p><p>If we scroll down the page, we can see that we are also being asked to enter a Messaging endpoint and an App ID. Let's add some details to our bot. Refer to the following screenshot:</p><p>
</p><div><img src="img/image00182.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>So far, we've added the three initial fields required for our bot. In this case, we'll use the name <code class="literal">NodeJsPacktSkypeBot</code>; however, you can use any other unique name. I recommend using the same name for both the <strong>Name</strong> and <strong>Bot handle</strong> fields.</p><p>So let's scroll down and carry on, in order to add the other required details:</p><p>
</p><div><img src="img/image00183.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Next we need to add the Messaging endpoint and add the App ID for our bot. So let's click on the <strong>Create Microsoft App ID and password</strong> button in order to get the required App ID.</p><p>Once we do this, we get the following result:</p><p>
</p><div><img src="img/image00184.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The next thing we need to do is to click on the <strong>Generate an app password to continue</strong> button. Once you do that, you'll see the following screen:</p><p>
</p><div><img src="img/image00185.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Immediately after, click on the <strong>Ok</strong> button, and this will take you back to the <strong>Generate App ID</strong> and password screen. Once there, click on the <strong>Finish and go back to Bot Framework</strong> button:</p><p>
</p><div><img src="img/image00186.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you have done that, you'll be back at the main registration screen. The only missing details will be the <strong>Messaging endpoint</strong> and the <strong>Owners</strong> e-mail address fields, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00187.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>For now, let's leave this as it is (we'll come back to this screen later) because, first, we need to deploy our bot to Azure.</p><p>Just like we did in the previous chapter, we can deploy our solution to Azure websites and host our messaging endpoint there. So, before we actually fill in the URL for our Messaging endpoint, let's deploy and push our Skype bot code to Azure websites in order to get a publicly accessible URL.</p><p>Assuming you have your Azure account set up and ready (if not please refer to <a class="link" title="Chapter 1. The Rise of Bots – Getting the Message Across" href="part0015.xhtml#aid-E9OE1">
Chapter 1
</a>, <em>The Rise of Bots – Getting the Message Across</em>, for details on how to do this), log in to Azure by executing the following instruction from the Command Prompt:</p><pre class="programlisting">
<strong>azure login</strong>
</pre><p>Once that has been done and the credentials provided, you will see a screen similar to the following screenshot:</p><p>
</p><div><img src="img/image00188.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Open your browser and enter the URL mentioned on the console response. Then enter the code you have been provided with. Once you have done that, you will see the following:</p><p>
</p><div><img src="img/image00189.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>This means that you have successfully logged on to Azure using the command line.</p><p>The next thing to do is to actually create the Azure website service that will host the Skype bot code; this can be done by running this command from the prompt:</p><pre class="programlisting">
<strong>azure site create --git nodeskypehrbotsite</strong>
</pre><p>When you execute this command, you will be asked to choose the Azure region to which you wish to deploy the bot, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00190.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Select the region that is closest to where you are located by typing in the appropriate number. After this has been done, you'll see the following information, indicating that the site has been successfully created:</p><p>
</p><div><img src="img/image00191.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Before deploying the bot's code to Azure, first log in to the <strong>Azure Portal</strong> (<a class="ulink" href="http://portal.azure.com">
http://portal.azure.com
</a>) with your account, and specify an <strong>FTP/deployment </strong>username and <strong>password</strong>.</p><p>This can be done by going into <strong>All resources</strong>, selecting the <strong>nodeskypehrbotsite</strong>, then opening the <strong>Deployment credentials</strong> blade, and, finally, entering the <strong>FTP/deployment username</strong> and <strong>Password</strong>, as seen in the following screenshot:</p><p>Once the username and password have been entered, click on the <strong>Save</strong> button at the top of the blade.</p><p>
</p><div><img src="img/image00192.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once this has been done, wait for a couple of minutes. Then we can deploy the code to Azure websites as follows:</p><pre class="programlisting">
<strong>git add .</strong>
<strong>git commit -m "SkypeNodeBot first commit"</strong>
<strong>git push azure master</strong>
</pre><p>Once these commands have been executed, the bot's code will be deployed to the Azure website and you should see some responses similar to the following:</p><p>
</p><div><img src="img/image00193.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>With our site deployed, we can finally get the publicly accessible URL, which in our case will be <code class="literal">https://nodeskypehrbotsite.azurewebsites.net/api/messages</code>, given that in our code we have defined a <code class="literal">POST</code> endpoint that our bot will be listening on.</p><p>This is the URL that we need to specify as the <strong>Messaging endpoint</strong>.</p><p>We can then go back to the bot <strong>Registration</strong> website screen where we recently entered the bot's APP ID and we can now enter the <strong>Messaging endpoint</strong>, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00194.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Make sure to check the option for <strong>Privacy statement</strong>, <strong>Terms of use</strong>, and <strong>Code of conduct</strong>, then click on the <strong>Register</strong> button, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00195.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you have clicked on the <strong>Register</strong> button, you'll receive a popup dialog that will say that the bot has been created, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00196.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Click on the <strong>OK</strong> button in order to continue. Once you have clicked on <strong>OK</strong>, then you'll be redirected to the following web page:</p><p>
</p><div><img src="img/image00197.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>There, you can quickly test the connection to the bot by clicking on the <strong>Test</strong> button.</p><p>As we don't want to make the bot public, there is no need to <strong>Publish</strong> it to the Skype bot directory.</p><p>If you scroll down a bit, you'll find the channels that are enabled by default. One of them is <strong>Skype</strong>, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00198.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Let's go ahead and click on the <strong>Add to Skype</strong> button in order to add the bot to our Skype contact list. Once we do that, a new browser tab or window will open, and we'll be presented with the following screen:</p><p>
</p><div><img src="img/image00199.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>In order to add the bot to Skype, click on the <strong>Add to Contacts</strong> button. This will launch the Skype application and add it to our contacts list.</p><p>If your Skype account is not the same as your Azure account (and if you are logged on with your Azure account), then it will be requested that you sign out and then sign in with your Skype account, in order to add the bot to your contacts list.</p><p>With all the setup behind us, let's modify our code in order to add our bot ID, Application ID, and application secret. The bot ID and the Application ID that we'll need to add to our code are the same, which is the one entered when registering the bot. Once we've done this, we can re-publish it to Azure websites and test it.</p><p>Our Skype bot <code class="literal">app.js</code> should now look like this:</p><pre class="programlisting">var skype = require('botbuilder'); &#13;
var express = require('express'); &#13;
 &#13;
var app = express(); &#13;
 &#13;
var botService = new skype.ChatConnector({ &#13;
    appId: '&lt;&lt; Your Application Id &gt;&gt;', &#13;
    appPassword: '&lt;&lt; Your Application Password &gt;&gt;' &#13;
}); &#13;
 &#13;
var bot = new skype.UniversalBot(botService); &#13;
 &#13;
app.post('/api/messages', botService.listen()); &#13;
 &#13;
bot.dialog('/', function (session) { &#13;
  if (session.message.text.toLowerCase().indexOf('hi') &gt;= 0){ &#13;
    session.send('Hi ' + session.message.user.name +  &#13;
     ' thank you for your message: ' + session.message.text); &#13;
  } else{ &#13;
    session.send('Sorry I don't understand you...'); &#13;
  } &#13;
}); &#13;
 &#13;
app.get('/', function (req, res) { &#13;
  res.send('SkypeBot listening...'); &#13;
}); &#13;
 &#13;
app.listen(process.env.port, function () { &#13;
  console.log('SkypeBot listening...'); &#13;
}); &#13;
</pre><p>If we publish the changes to Azure websites and have added our bot to our Skype contacts list, using the URL indicated by the label <strong>Add to Skype</strong>, we should see the following when we send a message to it.</p><p>The bot, for now, will reply with the same message that we provided as a response wrapped up with a nice thank you appended to the original message.</p><p>
</p><div><img src="img/image00200.jpeg" alt="Registering our Skype bot app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now, let's explore where the magic actually happens. Notice that <strong>8:ef_remote</strong> is the name of the actual Skype user that sent the message to our bot.</p><p>In our code, the part that is responsible for the magic is the <code class="literal">bot.dialog</code> event.</p><p>This event, as its name explicitly implies, gets triggered when Skype sends an <code class="literal">HTTP POST</code> request when the bot receives a message. Take a look at the following code snippet:</p><pre class="programlisting">bot.dialog('/', function (session) { &#13;
  if (session.message.text.toLowerCase().indexOf('hi') &gt;= 0){ &#13;
    session.send('Hi ' + session.message.user.name +  &#13;
     ' thank you for your message: ' + session.message.text); &#13;
  } else{ &#13;
    session.send('Sorry I don't understand you...'); &#13;
  } &#13;
}); &#13;
</pre><p>The <code class="literal">session</code> object contains the information that Skype passes on to the bot app, which describes the session data that has been received and from whom. Notice that the session object contains properties such as <code class="literal">message</code> and <code class="literal">text</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>HR Skype bot agent</h2></div></div></div><p>So far, we've been able to create and deploy to Azure a basic Skype bot that essentially responds to any message sent with the same text it received, with an appended thank you message.</p><p>In the previous chapter, we briefly mentioned that we would add a <code class="literal">BotBrain</code> method that will basically be responsible for giving an answer to a particular message input.</p><p>Let's now expand our Skype bot in order to create a basic <strong>Human Resources</strong> (<strong>HR</strong>) agent that is capable of answering certain requests, such as checking how many holidays a person has left or requesting a sick leave.</p><p>HR is an ample area that covers many topics and, obviously, much more logic could be added to an automated HR agent. However, as the purpose is to illustrate some sort of automated communication, we'll restrict ourselves to simply processing holidays and sick leave requests.</p><p>As we are already using Azure, we'll use <strong>Table </strong>
<strong>Storage</strong> (<a class="ulink" href="https://azure.microsoft.com/en-us/documentation/articles/storage-introduction">
https://azure.microsoft.com/en-us/documentation/articles/storage-introduction
</a>) in order to define some data and some answers that our bot will provide, depending on the type of message submitted and the type of request provided by the user.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Azure table storage as a backend</h1></div></div></div><p>The Table Storage service uses a tabular format to store data. Each record represents an entity, and the columns represent the various properties of that entity (fields within a table).</p><p>Every entity has a pair of keys (a <strong>PartitionKey</strong> and <strong>RowKey</strong>) to uniquely identify it. It also has a timestamp column that the Table Storage service uses to know when the entity was last updated (this happens automatically and the timestamp value cannot be overwritten; it is internally controlled by the service itself).</p><p>Extensive documentation (<a class="ulink" href="https://docs.microsoft.com/en-us/azure/storage/">
https://docs.microsoft.com/en-us/azure/storage/
</a>) about how the Storage and Table Storage services work can be found directly on the Azure website. It is an invaluable resource that is definitely worthwhile checking in order to have a better understanding of both services.</p><p>Nevertheless, we'll quickly explore how we can get up and running quickly with Azure Table Storage.</p><p>In order to get started with a Storage instance on Microsoft Azure, you'll need to sign in to the Azure Portal with a Microsoft account. You can do that by going to <a class="ulink" href="http://portal.azure.com">http://portal.azure.com</a>. Refer to the following screenshot:</p><p>
</p><div><img src="img/image00201.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you've signed in to the Azure Portal, you can browse through the list of Azure services and select <strong>Storage accounts (classic)</strong>, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00202.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you've selected <strong>Storage accounts (classic)</strong>, you'll be presented with the following screen, where you can add a new Storage account:</p><p>
</p><div><img src="img/image00203.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>In order to add a new <strong>Storage accounts (classic)</strong>, click on the <strong>Add</strong> button. This will then present a screen where you may add the account's <strong>Name</strong> and select the Azure <strong>Location</strong> in which the account will be hosted, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00204.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you have chosen a name and selected the location nearest to you, click on the <strong>Create</strong> button. Immediately after, Azure will create the Storage account. Once created, it will look as follows. You'll need your access keys in order to interact with the service from your code or any external tool. The keys can be found by clicking on the <strong>Keys</strong> setting, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00205.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>With the Azure Storage account now ready, you can use an open source and very handy tool called <strong>Azure Storage Explorer</strong> (<a class="ulink" href="https://azurestorageexplorer.codeplex.com">
https://azurestorageexplorer.codeplex.com
</a>), which will allow you to easily connect to your Storage account and create, update, delete, and view any storage tables and data:</p><p>
</p><div><img src="img/image00206.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you've downloaded the ZIP file from CodePlex, after you unzip it, you'll find an executable that you can run in order to install the tool.</p><p>The installation wizard is super easy to follow and self-explanatory, requiring just a few clicks. Please note that the Azure Storage Explorer application only works on Windows. Once installed, you'll see the following files:</p><p>
</p><div><img src="img/image00207.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>In order to run the tool, double-click on the <strong>Azure Storage Explorer</strong> shortcut. Once the application is running, you'll need to connect your Azure Storage account to it. This can be done by clicking on the <strong>Add Account</strong> button:</p><p>
</p><div><img src="img/image00208.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you click on the <strong>Add Account</strong> button, it'll be requested that you add your <strong>Storage account name</strong> and key, as follows:</p><p>
</p><div><img src="img/image00209.jpeg" alt="Azure table storage as a backend"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>After entering the requested details, you should click on the <strong>Test Access</strong> button in order to check if the connection works. If that is successful, you may click on the <strong>Save</strong> button.</p><p>With these details stored, next time you open the Azure Storage Explorer application, you'll be able to access your Storage account from the dropdown next to the <strong>Add Account</strong> button.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>HR agent guidelines</h2></div></div></div><p>Having set up our Azure Table Storage account and seen how to use Storage Explorer in order to connect to it, let's now create a table with some data that our Skype bot will use in order to interpret requests and function as an automated HR agent. Sounds exciting, so let's roll up our sleeves and get started.</p><p>We'll create a table called <code class="literal">HolidaysHRBot</code>, which will contain as its <code class="literal">PartitionKey</code> the name of the Skype user and as its <code class="literal">RowKey</code> the full name of the person in the form of <code class="literal">FirstName-LastName</code>. Both the <code class="literal">PartitionKey</code> and <code class="literal">RowKey</code> fields are strings. It will also have a third field called <code class="literal">DaysLeft</code>, which will be an integer and represent the number of vacation days that a person has left to use.</p><p>Let's assume that <code class="literal">DaysLeft</code> will start with a value of 25 (representing 25 days of vacation available to use). Finally, we can add another field that will indicate the number of sick days used. Let's call this field <code class="literal">DaysSick</code> and define it as an integer, which will be initially set to zero.</p><p>So, let's create the table using Storage Explorer and add some data. Refer to the following screenshot:</p><p>
</p><div><img src="img/image00210.jpeg" alt="HR agent guidelines"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The way the logic of our HR agent will work is that, once a user has been verified, and a holiday or sick request has been placed, the bot will reply back with the option selected.</p><p>So, having defined these basic rules, let's develop the <code class="literal">BotBrain</code> method that can take care of this. Looks like a lot of fun!</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Accessing the Azure table through code</h2></div></div></div><p>So, let's see how we can connect to Azure Table Storage through Node.js, read the information on the database table, and, furthermore, update it.</p><p>In order to get started, the first thing to do is to add Azure Storage to our project as an npm package. This can be done, as follows, from the command line:</p><pre class="programlisting">
<strong>npm install azure-storage --save  </strong>
</pre><p>This will update our <code class="literal">package.json</code> file, adding a reference to the Azure Storage library. Once the package has been installed, let's add a reference to it in our code:</p><pre class="programlisting">var azure = require('azure-storage'); &#13;
</pre><p>With the reference added, we can go ahead and create the <code class="literal">tableSvc</code> object that we will be using to connect to and communicate with our <code class="literal">HolidaysHRBot</code> table. It is necessary to pass the <code class="literal">AZURE_ACCOUNT</code> and <code class="literal">ACCOUNT_KEY</code>, which can be found on the Azure Portal.</p><pre class="programlisting">var tableSvc = azure.createTableService(AZURE_ACCOUNT, AZURE_KEY); &#13;
</pre><p>Because we have manually added data to our table using Storage Explorer, in order to retrieve data based on the <code class="literal">PartitionKey</code> and <code class="literal">RowKey</code> we'll need to use the <code class="literal">retrieveEntity</code> method from the <code class="literal">tableSvc</code> object. Here's how:</p><pre class="programlisting">tableSvc.retrieveEntity('HolidaysHRBot', 'Eduardo Freitas', 'Ed-Freitas',    &#13;
   function(error, result, response){ &#13;
  if(!error){ &#13;
    // result contains the entity &#13;
  } &#13;
}); &#13;
</pre><p>So, now let's create a small user verification method that takes the first message from the user and checks on the Azure table if the user actually exists, and if so, the bot carries out the rest of the interactive messaging process. This will be the entry point for our <code class="literal">BotBrain</code> method. Take a look at the following code snippet:</p><pre class="programlisting">userVerification = function(session) { &#13;
    session.send('Hey, let me verify your user id ' +  &#13;
      userId + ' (' + userName + '), bear with me...'); &#13;
 &#13;
  tableSvc.retrieveEntity(AZURE_TABLE, userId, userName, function  &#13;
  entityQueried(error, entity) { &#13;
    if (!error) { &#13;
      authenticated = true; &#13;
      userEntity = entity; &#13;
 &#13;
      session.send('I have verified your id, how can I help you?' +  &#13;
        ' Type a) for Holidays, b) for Sick Leave.'); &#13;
    } &#13;
    else { &#13;
      session.send('Could not find: ' + userName +  &#13;
      ', please make sure you use proper casing :)'); &#13;
    } &#13;
  }); &#13;
}; &#13;
</pre><p>What we've done here is to basically wrap up the <code class="literal">retrieveEntity</code> function into a method for which, depending on what result is fetched from the <code class="literal">AZURE_TABLE</code>, a given <code class="literal">session.send</code> is sent back to the user.</p><p>If, for the user, there is a matching record for the <code class="literal">userId</code> (PartitionKey) and <code class="literal">userName</code> (RowKey) specified, then the state is set to authenticated and the entity <code class="literal">retrieved</code> (record) is copied to the <code class="literal">userEntity</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>HR agent bot logic</h2></div></div></div><p>Now let's close the loop and tie all this up by outlining the bot's full code, as follows:</p><pre class="programlisting">var skype = require('botbuilder'); &#13;
var express = require('express'); &#13;
var azure = require('azure-storage'); &#13;
 &#13;
var app = express(); &#13;
 &#13;
var APP_ID = '&lt;&lt; Your App ID &gt;&gt;'; &#13;
var APP_SECRET = '&lt;&lt; Your App Password &gt;&gt;'; &#13;
 &#13;
var AZURE_ACCOUNT = '&lt;&lt; Your Azure Account ID &gt;&gt;'; &#13;
var AZURE_KEY = '&lt;&lt; Your Azure Account Key &gt;&gt;'; &#13;
var AZURE_TABLE = 'HolidaysHRBot'; &#13;
 &#13;
var tableSvc = azure.createTableService(AZURE_ACCOUNT, AZURE_KEY); &#13;
 &#13;
var authenticated = false; &#13;
var holidays = false; &#13;
var sick = false; &#13;
var userId = ''; &#13;
var userName = ''; &#13;
var userEntity = undefined; &#13;
 &#13;
var botService = new skype.ChatConnector({ &#13;
    appId: APP_ID, &#13;
    appPassword: APP_SECRET &#13;
}); &#13;
 &#13;
var bot = new skype.UniversalBot(botService); &#13;
 &#13;
app.post('/api/messages', botService.listen()); &#13;
 &#13;
userVerification = function(session) { &#13;
  session.send('Hey, let me verify your user id ' + userId + ' (' +  &#13;
    userName + '), bear with me...'); &#13;
 &#13;
  tableSvc.retrieveEntity(AZURE_TABLE, userId, userName,  &#13;
  function entityQueried(error, entity) { &#13;
    if (!error) { &#13;
      authenticated = true; &#13;
      userEntity = entity; &#13;
 &#13;
      session.send('I have verified your id, how can I help you?' +  &#13;
        ' Type a) for Holidays, b) for Sick Leave.'); &#13;
    } &#13;
    else { &#13;
      session.send('Could not find: ' + userName +  &#13;
        ', please make sure you use proper casing :)'); &#13;
    } &#13;
  }); &#13;
}; &#13;
 &#13;
cleanUserId = function(userId) { &#13;
  var posi = userId.indexOf(':'); &#13;
  return (posi &gt; 0) ? userId.substring(posi + 1) : userId; &#13;
}; &#13;
 &#13;
BotBrain = function(session) { &#13;
  var orig = session.message.text; &#13;
  var content = orig.toLowerCase(); &#13;
  var from = session.message.user.name; &#13;
   &#13;
  if (authenticated) { &#13;
    if (content === 'a)') { &#13;
      holidays = true; &#13;
      session.send('Please indicate how many vacation days' +  &#13;
        ' you will be requesting, i.e.: 3'); &#13;
    } &#13;
    else if (content === 'b)') { &#13;
      sick = true; &#13;
      session.send('Please indicate how many sick days' +  &#13;
        ' you will be requesting, i.e.: 2'); &#13;
    } &#13;
    else if (content !== 'a)' &amp;&amp; content !== 'b)') { &#13;
      if (holidays) { &#13;
        session.send(userName + '(' + userId + ')' +  &#13;
          ', you have chosen to take ' + content +  &#13;
          ' holiday(s). Session ended.'); &#13;
        sick = false; &#13;
        authenticated = false; &#13;
      } &#13;
      else if (sick) { &#13;
        session.send(userName + '(' + userId + ')' +  &#13;
          ', you have chosen to take ' + content +  &#13;
          ' sick day(s). Session ended.'); &#13;
        holidays = false; &#13;
        authenticated = false; &#13;
      } &#13;
      else if (!holidays &amp;&amp; !sick) { &#13;
        session.send('I can only process vacation or sick leave requests.' +     &#13;
          ' Please try again.'); &#13;
      } &#13;
    } &#13;
  } &#13;
  else { &#13;
    authenticated = false, holidays = false, sick = false; &#13;
    userId = '', userName = '', userEntity = undefined; &#13;
 &#13;
    if (content === 'hi') { &#13;
      session.send('Hello ' + cleanUserId(from) +  &#13;
        ', I shall verify your identify...'); &#13;
      session.send('Can you please your provide your FirstName-LastName?' +  &#13;
        ' (please use the - between them)'); &#13;
    } &#13;
    else if (content !== '') { &#13;
      userId = cleanUserId(from); &#13;
      userName = orig; &#13;
 &#13;
      if (userName.indexOf('-') &gt; 1) { &#13;
        userVerification(session); &#13;
      } &#13;
      else { &#13;
        session.send('Hi, please provide your FirstName-LastName' +  &#13;
          ' (please use the - between them) or say hi :)'); &#13;
      } &#13;
    } &#13;
  } &#13;
}; &#13;
 &#13;
bot.dialog('/', function (session) { &#13;
  BotBrain(session); &#13;
}); &#13;
 &#13;
app.get('/', function (req, res) { &#13;
  res.send('SkypeBot listening...'); &#13;
}); &#13;
 &#13;
//app.listen(3979, function () { &#13;
app.listen(process.env.port, function () { &#13;
  console.log('SkypeBot listening...'); &#13;
}); &#13;
</pre><p>Given that we already explained some parts of the code when we went through the process of registering the bot with Skype and we also reviewed how to hook up to the Skype API events that allow the bot to receive incoming messages from users, we won't be covering those parts further. Instead, we will focus on the <code class="literal">BotBrain</code> function and how the actual process flows. Let's analyze this.</p><p>The first thing to notice is that, when the <code class="literal">bot.Dialog</code> event gets triggered, the <code class="literal">BotBrain</code> function is invoked:</p><pre class="programlisting">bot.dialog('/', function (session) { &#13;
  BotBrain(session); &#13;
}); &#13;
</pre><p>Another important part is that somehow we need to keep the state in order to be able to determine what stage of the conversation our bot is at with the user.</p><p>A relatively simple way to do this is by using variables that keep the state of the conversation or apply it to some parts.</p><p>We'll need to know when the user has been authenticated, which basically means that their Skype Id and name have been checked against the data contained within the <code class="literal">AZURE_TABLE</code>. Further to that, we'll also need to keep the <code class="literal">userId</code>, <code class="literal">userName</code>, and <code class="literal">userEntity</code> (representing the record on the table) for the authenticated user.</p><p>It is also important to know if the user has sent a <code class="literal">holidays</code> request or a <code class="literal">sick</code> leave request. With these variables, we can keep the state in a very simple way.</p><p>Ideally, for multiple users requesting interaction with the bot at the same time, the state should be kept individually for each user logged on or authenticated. However, this is far beyond the scope of this example and we shall not cover this. Take a look at the following code snippet:</p><pre class="programlisting">var authenticated = false; &#13;
var holidays = false; &#13;
var sick = false; &#13;
var userId = ''; &#13;
var userName = ''; &#13;
var userEntity = undefined; &#13;
</pre><p>With the problem of managing the state covered, let's now focus on the internals of the <code class="literal">BotBrain</code> function. Let's dissect it into smaller chunks.</p><p>There are basically two main parts that are important. One is whether the user has already been authenticated (the user has been verified to exist on the <code class="literal">AZURE_TABLE</code>) and the other is where the user has yet not been authenticated, which corresponds to the initial stage of the conversation:</p><pre class="programlisting">authenticated = false, holidays = false, sick = false; &#13;
userId = '', userName = '', userEntity = undefined; &#13;
 &#13;
if (content === 'hi') { &#13;
  session.send('Hello ' + cleanUserId(from) +  &#13;
    ', I shall verify your identify...'); &#13;
  session.send('Can you please your provide your FirstName-LastName?' +  &#13;
    ' (please use the - between them)'); &#13;
} &#13;
else if (content !== '') { &#13;
  userId = cleanUserId(from); &#13;
  userName = orig; &#13;
 &#13;
  if (userName.indexOf('-') &gt; 1) { &#13;
    userVerification(session); &#13;
  } &#13;
  else { &#13;
    session.send('Hi, please provide your FirstName-LastName' +  &#13;
      ' (please use the - between them) or say hi :)'); &#13;
  } &#13;
} &#13;
</pre><p>Here we can see that, in order to start the conversation, the user must write a message including the word <code class="literal">hi</code>. Following that, the bot responds and requests that the user enters their name in the form of <code class="literal">FirstName-LastName</code> (proper casing should be used).</p><p>
<code class="literal">FirstName-LastName</code> will be used in order to query the RowKey of the <code class="literal">AZURE_TABLE</code> and verify if the <code class="literal">userId</code> (the user's Skype Id) corresponds to the record that also contains the value specified by <code class="literal">FirstName-LastName</code>. This is done within the <code class="literal">userVerification</code> function.</p><p>Once the user's identity has been verified, then <code class="literal">authenticated</code> is set to <code class="literal">true</code> and therefore the bot can ask what type of action the user wants to carry out. Let's check this:</p><pre class="programlisting">if (content === 'a)') { &#13;
  holidays = true; &#13;
  session.send('Please indicate how many vacation days' +  &#13;
    ' you will be requesting, i.e.: 3'); &#13;
} &#13;
else if (content === 'b)') { &#13;
  sick = true; &#13;
  session.send('Please indicate how many sick days' +  &#13;
    ' you will be requesting, i.e.: 2'); &#13;
} &#13;
else if (content !== 'a)' &amp;&amp; content !== 'b)') { &#13;
  if (holidays) { &#13;
     session.send(userName + '(' + userId + ')' +  &#13;
       ', you have chosen to take ' + content +  &#13;
       ' holiday(s). Session ended.'); &#13;
     sick = false; &#13;
     authenticated = false; &#13;
   } &#13;
   else if (sick) { &#13;
     session.send(userName + '(' + userId + ')' +  &#13;
       ', you have chosen to take ' + content +  &#13;
       ' sick day(s). Session ended.'); &#13;
     holidays = false; &#13;
     authenticated = false; &#13;
  } &#13;
  else if (!holidays &amp;&amp; !sick) { &#13;
     session.send('I can only process vacation or sick leave requests.' +     &#13;
       ' Please try again.'); &#13;
  } &#13;
} &#13;
</pre><p>Once the user has been verified and the bot's state has been authenticated, the bot then requests that the user chooses if he or she wants to request some vacation days or sick leave days. Once the user responds, each state is then stored using Boolean variables called <code class="literal">holidays</code> and <code class="literal">sick</code>, which are then used by the bot to send back a reply asking how many days the user wants to book. Take a look at the following screenshot:</p><p>
</p><div><img src="img/image00211.jpeg" alt="HR agent bot logic"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>When the user provides the number of days, the bot then replies back confirming the request. The output can be seen as follows:</p><p>
</p><div><img src="img/image00212.jpeg" alt="HR agent bot logic"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>It's important to note that there's room to add additional logic and perform more operations, such as actually changing the values on the <code class="literal">AZURE_TABLE</code> once the days request has been entered, so there's plenty of opportunity to keep exploring and expanding the functionality of the bot.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>It's been an interesting journey on how to connect and interact with Skype services, and how to create a bot to leverage some basic but interesting and interactive functionality.</p><p>We've see how to get our bot all set up with Skype, how to install the related npm packages, and implement the basic skeleton and structure for our app.</p><p>Further to this, you've also learned how to create the bot's brains in order to perform certain tasks and send the right response based on the input received.</p><p>If you'd like to expand on this a bit further, something interesting to think about is how to keep the state for multiple users simultaneously and also add more interactive functionality.</p><p>Hopefully, this has given you some inspiration, food for thought, and an eagerness to continue exploring many more possibilities for implementing Skype bots. Thanks so much for reading.</p></div></body></html>