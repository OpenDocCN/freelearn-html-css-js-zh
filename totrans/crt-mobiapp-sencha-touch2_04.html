<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Weight Weight</h1></div></div></div><p>In this chapter we will explore an optional add-on package to the Sencha Touch Framework. The package is called <a id="id321" class="indexterm"/>Sencha Charts and it enables us to create charts using a data store.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building the basic application</li><li class="listitem" style="list-style-type: disc">Defining the data stores</li><li class="listitem" style="list-style-type: disc">Setting up the Sencha Charts package</li><li class="listitem" style="list-style-type: disc">Connecting the stores to Sencha Charts</li><li class="listitem" style="list-style-type: disc">Configuring and displaying the charts</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Sencha Charts overview</h1></div></div></div><p>The basic Sencha Touch <a id="id322" class="indexterm"/>Framework has a number of components for displaying data. However, business and other intensive software products often require something a bit more robust. By using Sencha Touch Charts, we can also display complex graphical data as part of our applications.</p><p>The following screenshot exemplifies an overview of chart and graph types for displaying data:</p><div><img src="img/8901OS_04_01.jpg" alt="Sencha Charts overview"/></div><p>These new components use data <a id="id323" class="indexterm"/>stores to display a wide range of chart and graph types including:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pie</li><li class="listitem" style="list-style-type: disc">Bar</li><li class="listitem" style="list-style-type: disc">Line</li><li class="listitem" style="list-style-type: disc">Scatter</li><li class="listitem" style="list-style-type: disc">Area</li><li class="listitem" style="list-style-type: disc">Candlestick</li><li class="listitem" style="list-style-type: disc">Radar</li><li class="listitem" style="list-style-type: disc">Gauge</li></ul></div><p>We will be using a few of these charts to provide a more user-friendly display for our application.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>As of writing, the Sencha Charts <a id="id324" class="indexterm"/>package is only available as a part of Sencha Complete, or the open source version (GPL) of Sencha Touch 2.1 download. For this chapter, we will be using the open source version, <a id="id325" class="indexterm"/>which can be downloaded for free from the web page at <a class="ulink" href="http://www.sencha.com/products/touch/download/">http://www.sencha.com/products/touch/download/</a>.</p></div></div><p>Later on in the chapter, we will cover the basic setup for using Sencha Charts, but first, we will take a look at setting up the basic application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>The basic application</h1></div></div></div><p>We will use the Sencha Charts package to <a id="id326" class="indexterm"/>create a program for tracking weight, exercise, calories, and water consumption. We will also allow the user to tag entries for adding additional information to the charts.</p><p>The application consists of four basic pieces as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A form for entering data</li><li class="listitem" style="list-style-type: disc">An overview that will provide a group of charts on a single page</li><li class="listitem" style="list-style-type: disc">A details section for viewing a specific chart in greater detail</li><li class="listitem" style="list-style-type: disc">A configuration section that will allow the user to set goals for our four categories, and define the units of measurement for weight and water consumption</li></ul></div><p>We will start by setting up the basic application and building our form.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Setting up the application and building the form</h2></div></div></div><p>We will be using the Sencha <a id="id327" class="indexterm"/>
<a id="id328" class="indexterm"/>Command SDK to create the application as described in the previous chapter. You will <a id="id329" class="indexterm"/>
<a id="id330" class="indexterm"/>need to execute this command from the <code class="literal">Sencha Touch</code> directory. The basic command is as follows:</p><div><pre class="programlisting">
<strong>sencha app create weightweight /Path/To/Your/New/Application</strong>
</pre></div><p>If you prefer, you can create the initial directories and files yourself. Your file and directory structure should look something like this:</p><div><img src="img/8901OS_04_02.jpg" alt="Setting up the application and building the form"/></div><p>The previous screenshot shows the structure that is automatically <a id="id331" class="indexterm"/>generated with the <code class="literal">sencha app create</code> command.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">touch</code> directory <a id="id332" class="indexterm"/>contains a copy of the Sencha Touch Framework including our chart functions.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">resources</code> directory <a id="id333" class="indexterm"/>will contain our images and CSS files.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">app</code> directory will <a id="id334" class="indexterm"/><a id="id335" class="indexterm"/><a id="id336" class="indexterm"/><a id="id337" class="indexterm"/>contain the bulk of our code.</li></ul></div><p>To begin, we need to define our main view. This file will be called <code class="literal">main.js</code> and it belongs to the <code class="literal">views</code> folder. The <a id="id338" class="indexterm"/>
<code class="literal">main.js</code> file is a simple tab panel with four items:</p><div><pre class="programlisting">Ext.define("WeightWeight.view.Main", {
    extend: 'Ext.tab.Panel',
    requires: ['Ext.TitleBar'],
    
    config: {
        tabBar: {
            docked: 'bottom'
        },
        items: [
            { xtype: 'dataentry'},
            { xtype: 'overview'},
            { xtype: 'details'},
            { xtype: 'configform' }
        ]
    }
});</pre></div><p>We also need to make sure that this component is added into our <code class="literal">app.js</code> file in the <code class="literal">views</code> section of our <a id="id339" class="indexterm"/>
<code class="literal">Ext.application</code> function:</p><div><pre class="programlisting">Ext.application({
    name: 'WeightWeight',
    views: ['Main'],
…</pre></div><p>Remember that the name we list under the view is not the file name (<code class="literal">Main.js</code>), it's the last part of the define statement at the top of our code: <code class="literal">WeightWeight.view.Main</code>. Once we have this setup, let's create four placeholder files, one for each panel in our tab view.</p><p>We need to create a placeholder for <code class="literal">dataentry</code>, <code class="literal">overview</code>, <code class="literal">details</code>, and <code class="literal">configform</code> panels. These files will contain starter code for each panel or form in our application. This will let us test our application without getting errors for missing files.</p><p>Let's have a look at how to test our <a id="id340" class="indexterm"/>application by using the starter code for each panel:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">dataentry.js</code> file in the <code class="literal">views</code> directory. This will be a form panel so the starter code should be set as follows:<div><pre class="programlisting">Ext.define("WeightWeight.view.DataEntry", {
    extend:'Ext.form.Panel',
    alias:'widget.dataentry',
    config:{
        title:'Enter Data',
        iconCls:'info',
        html: 'Data Entry'
    }
});</pre></div></li><li class="listitem">Next, we need to create an <code class="literal">overview.js</code> file with a simple panel in the <code class="literal">views</code> directory and set the code as follows:<div><pre class="programlisting">Ext.define("WeightWeight.view.OverviewChart", {
    extend:'Ext.Panel',
    alias:'widget.overview',
    config:{
        title:'Overview',
        iconCls:'star',
        html: 'Overview'

    }
});</pre></div></li><li class="listitem">The <code class="literal">view/details.js</code> file <a id="id341" class="indexterm"/><a id="id342" class="indexterm"/>is also a panel like the previous <code class="literal">overview.js</code> file. The code is as follows:<div><pre class="programlisting">Ext.define("WeightWeight.view.DetailChart", {
    extend:'Ext.Panel',
    alias:'widget.details',
    config:{
        title:'Details',
        iconCls:'locate',
        html: 'Details'

    }
});</pre></div></li><li class="listitem">And finally, the <code class="literal">views/config.js</code> file, <a id="id343" class="indexterm"/>which is also a form panel like the <code class="literal">dataentry.js</code> file. The code is as follows:<div><pre class="programlisting">Ext.define("WeightWeight.view.Config", {
    extend:'Ext.form.Panel',
    alias:'widget.configform',
    config:{
        title:'Config',
        iconCls:'settings',
        html: 'Config'

    }
});</pre></div></li><li class="listitem">Once all the views <a id="id344" class="indexterm"/><a id="id345" class="indexterm"/>are created, we need to remember to add them to the <code class="literal">views</code> section in our <code class="literal">app.js</code> file (where we added <code class="literal">Main</code> previously). In the <code class="literal">app js</code> file, set the <code class="literal">views</code> section as follows:<div><pre class="programlisting">views: ['Main', 'Config', 'AddTag', "OverviewChart", "DetailChart"]</pre></div></li></ol></div><p>We should now be able to load the code and test our panels.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>
<strong>Small steps</strong>
</p><p>Creating code can be a very involved process. It is often helpful to make small changes and then test, rather than changing a few hundred lines of code and then testing. By changing small amounts of code, you should be able to track down problems quicker when they occur. In this case, by creating these starter files, we can test to make sure that Sencha is locating the files correctly and that the application starts without errors. We can then work on one file at a time and limit the places where we need to look when things go boom.</p></div></div><div><img src="img/8901OS_04_03.jpg" alt="Setting up the application and building the form"/></div><p>At this point, our application should simply start and allow us to switch between our views. This confirms that the <a id="id346" class="indexterm"/>application is working and then we can start creating our form.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Creating the data entry form</h2></div></div></div><p>Our data entry form <a id="id347" class="indexterm"/>
<a id="id348" class="indexterm"/>consists of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Three fields: <a id="id349" class="indexterm"/><code class="literal">datepickerfield</code> for setting the date, <code class="literal">numberfield</code> <a id="id350" class="indexterm"/>for each of our four categories (weight, water, calories, and exercise), and <a id="id351" class="indexterm"/><code class="literal">hiddenfield</code> for storing our tag value for the entry.</li><li class="listitem" style="list-style-type: disc">Three buttons: One for adding tags, one for saving, and one for canceling and clearing the form.</li><li class="listitem" style="list-style-type: disc">We will also place the <strong>Cancel</strong> and <strong>Save</strong> buttons inside an Hbox layout container. This will let us display the buttons side by side.</li></ul></div><p>We will replace the line <a id="id352" class="indexterm"/>in <code class="literal">view/DataEntry.js</code> that says <code class="literal">html: 'Data Entry'</code> so that the code looks like this:</p><div><pre class="programlisting">Ext.define("WeightWeight.view.DataEntry", {
    extend:'Ext.form.Panel',
    alias:'widget.dataentry',
    config:{

        title:'Enter Data',
        iconCls:'info',
        items:[
            {
                xtype:'datepickerfield',
                label:'Date',
                placeHolder:'mm/dd/yyyy'
            },
            {
                xtype:'numberfield',
                id:'weightField',
                margin:'10 0',
                label:'Weight'
            },
            {
                xtype:'numberfield',
                id:'waterField',
                margin:'10 0',
                label:'Water'
            },
            {
                xtype:'numberfield',
                id:'calorieField',
                margin:'10 0',
                label:'Calories'
            },
            {
                xtype:'numberfield',
                id:'exerciseField',
                label:'Exercise'
            },
            {
                xtype:'hiddenfield',
                id:'hiddenTagField'
            },
            {
                xtype:'button',
                margin:'25 0 25',
                text:'Add Tag',
                id: 'addTagButton'
            },
            {
                xtype:'container',
                layout:{
                    type:'hbox'
                },
                items:[
                    {
                        xtype:'button',
                        margin:'0 10 0 0',
                        text:'Cancel',
                        flex:1
                    },
                    {
                        xtype:'button',
                        margin:'0 0 0 10',
                        text:'Save',
                        flex:1
                    }
                ]
            }
        ]
    }
});</pre></div><p>We have also provided <a id="id353" class="indexterm"/>margins for each of our items to add spacing <a id="id354" class="indexterm"/>to the form, making it more readable. The end result should look something like this:</p><div><img src="img/8901OS_04_04.jpg" alt="Creating the data entry form"/></div><p>The next view we need <a id="id355" class="indexterm"/>to create is the one for adding our tags. We <a id="id356" class="indexterm"/>will use a sheet to achieve this.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Creating the AddTag view</h2></div></div></div><p>The <code class="literal">AddTag</code> view is <a id="id357" class="indexterm"/>embedded in an <code class="literal">ActionSheet</code> component. <a id="id358" class="indexterm"/>This view will allow us to add new tags or select from the previous ones, and the <code class="literal">ActionSheet</code> component will display the <a id="id359" class="indexterm"/>view as an overlay that slides up from the bottom of the screen. The form contains a single field called <code class="literal">textfield</code>, a <code class="literal">list</code> view, and two buttons. Create the file in the <code class="literal">views</code> directory and call it <code class="literal">AddTag.js</code>:</p><div><pre class="programlisting">Ext.define('WeightWeight.view.AddTag', {
    extend: 'Ext.ActionSheet',
    alias: 'widget.addtag',
    config: {
        id: 'addTagSheet',
        items: [
            {
                xtype: 'textfield',
                label: 'Enter a New Tag',
                placeHolder: 'or choose a tag from the list below.'
            },
            {
                xtype: 'list',
                height: 300,
                itemTpl: [
                    '&lt;div&gt;List Item {string}&lt;/div&gt;'
                ]
            },
            {
                xtype: 'container',
                margin: 10,
                layout: {
                    type: 'hbox'
                },
                items: [
                    {
                        xtype: 'button',
                        margin: '0 10 0 0',
                        text: 'Cancel',
                        flex: 1
                    },
                    {
                        xtype: 'button',
                        margin: '0 0 0 10',
                        text: 'Save',
                        flex: 1
                    }
                ]
            }
        ]
    }
});</pre></div><p>We have used the <code class="literal">alias</code> <a id="id360" class="indexterm"/>configuration to give this component an <code class="literal">xtype</code> property. This will let us quickly <a id="id361" class="indexterm"/>create and remove it within our program. We <a id="id362" class="indexterm"/>have also given the component an <code class="literal">id</code> property so that we can reference it in our controller.</p><p>The end result should look something like this:</p><div><img src="img/8901OS_04_05.jpg" alt="Creating the AddTag view"/></div><p>The <code class="literal">list</code> component <a id="id363" class="indexterm"/>
<a id="id364" class="indexterm"/>is a placeholder for now. We will finish it later once we have our data stores set up.</p><p>The next view we need to set up is the config form. This will be similar to our data entry form with a few different field types.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Creating the config form</h2></div></div></div><p>We will start by <a id="id365" class="indexterm"/>editing the <code class="literal">Config.js</code> placeholder file that we set up <a id="id366" class="indexterm"/>earlier in the chapter. The code for it is as follows:</p><div><pre class="programlisting">Ext.define("WeightWeight.view.Config", {
    extend:'Ext.form.Panel',
    alias: 'widget.configform',
    config:{
        title:'Config',
        iconCls:'settings',
        items:[]
    }
});</pre></div><p>The <code class="literal">alias</code> property <a id="id367" class="indexterm"/>allows us to call the panel by a custom xtype of config form. This is the <code class="literal">xtype</code> property we used in our <code class="literal">Main.js</code> file for the fourth panel. The <code class="literal">title</code> <a id="id368" class="indexterm"/>and <code class="literal">iconCls</code> <a id="id369" class="indexterm"/>properties control how the navigation for this panel appears in the main view.</p><p>Next, we need to add some items to our panel. We will start by adding number fields for <code class="literal">Starting Weight</code> and <code class="literal">Target Weight</code>. By using a <a id="id370" class="indexterm"/>
<code class="literal">numberfield</code> component we make sure that the number keyboard will appear on most mobile devices. To keep the field organized, we will put them <a id="id371" class="indexterm"/>in a <code class="literal">fieldset</code> <a id="id372" class="indexterm"/>component. This will go in the empty <code class="literal">items</code> config:</p><div><pre class="programlisting">{
    xtype:'fieldset',
    title:'Weight Loss Goal',
    items:[
        {
            xtype:'numberfield',
            id:'startingWeight', 
            name:'startingWeight',
            label:'Starting Weight'
        },
        {
            xtype:'numberfield',
            id:'targetWeight', 
            name:'targetWeight',
            label:'Target Weight'
        }
    ]
}</pre></div><p>Next, we will <a id="id373" class="indexterm"/>add a set of spinner fields. The <code class="literal">spinnerfield</code> <a id="id374" class="indexterm"/>component allows the user to increment the field values using <strong>+</strong> and <strong>-</strong> buttons. These will also be in a <code class="literal">fieldset</code> component<a id="id375" class="indexterm"/> like the previous ones:</p><div><pre class="programlisting">{
xtype:'fieldset',
title:'Daily Goals',
items:[
    {
        xtype:'spinnerfield',
        id:'exercisePerDay',
        label:'Exercise (minutes)',
        defaultValue:30,
        stepValue: 1
    },
    {
        xtype:'spinnerfield',
        id:'caloriesPerDay',
        label:'Caloric Intake',
        defaultValue:0,
        stepValue: 100
    },
    {
        xtype:'spinnerfield',
        id:'waterPerDay',
        label:'Water Consumption',
        defaultValue:8,
        stepValue: 1
    }
]
}</pre></div><p>Notice that the <a id="id376" class="indexterm"/>
<code class="literal">spinnerfield</code> component also allows us to set a <code class="literal">stepValue</code> configuration, <a id="id377" class="indexterm"/>
<a id="id378" class="indexterm"/>which controls how much the field will increase or decrease when the buttons are pressed.</p><p>Lastly, we will add our units of measurement section with radio buttons for different selections as follows:</p><div><pre class="programlisting">{
    xtype:'fieldset',
    title:'Units of Measure',
    padding:25,
    items:[
        {
            xtype:'fieldset',
            title:'Weight',
            items:[
                {
                    xtype:'radiofield',
                    label:'Pounds',
                    name:'weightUnits',
                    value:'lbs',
                    checked:true
                },
                {
                    xtype:'radiofield',
                    label:'Kilograms',
                    name:'weightUnits',
                    value:'kg'
                }
            ]
        },
        {
            xtype:'fieldset',
            title:'Water',
            items:[
                {
                    xtype:'radiofield',
                    label:'Glasses',
                    name:'waterUnits',
                    value:'glass',
                    checked:true
                },
                {
                    xtype:'radiofield',
                    label:'Ounces',
                    name:'waterUnits',
                    value:'oz'
                }
            ]
        }
    ]
}</pre></div><p>The end form <a id="id379" class="indexterm"/>
<a id="id380" class="indexterm"/>should look something like this:</p><div><img src="img/8901OS_04_06.jpg" alt="Creating the config form"/></div><p>Now that we have <a id="id381" class="indexterm"/>
<a id="id382" class="indexterm"/>our two forms, let's start working on the controllers for them. We'll start with the data entry controller.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Creating the DataEntry controller</h2></div></div></div><p>Let's start <a id="id383" class="indexterm"/>
<a id="id384" class="indexterm"/>
<a id="id385" class="indexterm"/>off with a bare controller like so:</p><div><pre class="programlisting">Ext.define('WeightWeight.controller.DataEntry', {
    extend: 'Ext.app.Controller',
    config: {
        refs: {
            
        },
        control: {
            
        }
    }
});</pre></div><p>We start off by extending the basic controller and then adding a <code class="literal">config</code> section that will contain the rest of our initial setup code. The <code class="literal">refs</code> section will contain references to other components we need, and the <code class="literal">control</code> section will assign functions to our buttons and other components.</p><p>The <code class="literal">refs</code> section <a id="id386" class="indexterm"/>
<a id="id387" class="indexterm"/>is where we will add a reference to our <code class="literal">AddTag</code> sheet:</p><div><pre class="programlisting">refs: {
    tagSheet: '#addTagSheet',
}</pre></div><p>This is occasionally written out in a longer form as follows:</p><div><pre class="programlisting">refs: {
    tagSheet: {
        selector: '#addTagSheet'
    }
}</pre></div><p>Both ways will work just fine. The reference looks for a component selector, in this case a component with an <code class="literal">id</code> value of <code class="literal">addTagSheet</code>.</p><p>By creating this reference using the <code class="literal">id</code> configuration of our <code class="literal">AddTag</code> sheet, we can access it anywhere in the controller by typing the following code:</p><div><pre class="programlisting">var sheet = this.getTagSheet();</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>Notice that despite the fact that we use <code class="literal">tagSheet</code> as the reference, the <code class="literal">get</code> function capitalizes the first letter in our reference to <code class="literal">getTagSheet</code>. Since JavaScript is case sensitive, if you tried using gettagSheet, JavaScript will return an error.</p></div></div><p>Now that we have our reference, we need to add controls to the <strong>Add Tag</strong> button in our <code class="literal">DataEntry</code> form and the two buttons on our <code class="literal">AddTag</code> sheet. The code is as follows:</p><div><pre class="programlisting">control: {
    'button#addTagButton': {
        tap: 'showAddTag'
    },
    '#addTagSheet button[text="Cancel"]': {
        tap: 'cancelAddTag'
    },
    '#addTagSheet button[text="Save"]': {
        tap: 'saveAddTag'
    }
}</pre></div><p>Each of our controls has three parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A DOM selector that tells the program which component we want to bind to</li><li class="listitem" style="list-style-type: disc">The event we want it to listen for</li><li class="listitem" style="list-style-type: disc">The function to fire when the event occurs</li></ul></div><p>We will add additional controls later on when we create our data stores. For now, let's add in the functions that need to fire when these three buttons are clicked.</p><p>The first is a <code class="literal">showAddTag</code> function. It calls our <code class="literal">AddTag</code> sheet and displays it. The function is <a id="id388" class="indexterm"/>
<a id="id389" class="indexterm"/>added after the end of the <code class="literal">config</code> section and looks similar to the following code:</p><div><pre class="programlisting">showAddTag: function() {
    var sheet = this.getTagSheet();
    if (typeof sheet == 'undefined') {
        sheet = Ext.widget('addtag');
        Ext.Viewport.add(sheet);
    }
    sheet.show();
}</pre></div><p>First, we check to see if there is already a sheet in the memory (using the <code class="literal">this.getTagSheet()</code> function automatically created by our reference in the <code class="literal">refs</code> section), and if not, then we create a new one using the <code class="literal">Ext.Widget()</code> function to create a new component with an <code class="literal">xtype</code> property of <code class="literal">addtag</code>. We then add this sheet to the view port and show it.</p><p>The <strong>Cancel</strong> button in our <code class="literal">AddTag</code> sheet has a very simple function:</p><div><pre class="programlisting">cancelAddTag: function() {
    this.getTagSheet().hide();
}</pre></div><p>This is also used as our autogenerated reference function to grab the open sheet and close it.</p><p>For now, we will duplicate this function for our last <code class="literal">saveAddTag</code> function:</p><div><pre class="programlisting">saveAddTag: function() {
    this.getTagSheet().hide();
}</pre></div><p>This will simply hide that sheet as well. We will add the code to save our tag data once we get our stores created. For now, save and test the code to make sure that the sheet appears and hides as expected.</p><p>The end result should look something like this:</p><div><img src="img/8901OS_04_07.jpg" alt="Creating the DataEntry controller"/></div><p>Now that we have the basic forms, we need to create our stores and models. This will provide us with <a id="id390" class="indexterm"/>
<a id="id391" class="indexterm"/>places to store the data from our various forms.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Defining the models and stores</h1></div></div></div><p>For this project, we will be <a id="id392" class="indexterm"/>
<a id="id393" class="indexterm"/>
<a id="id394" class="indexterm"/>
<a id="id395" class="indexterm"/>
<a id="id396" class="indexterm"/>using the local storage offered by HTML5 to store our data. We will begin by defining the model for our data entry form. We will just call this one <code class="literal">Entry.js</code> and it goes in the <code class="literal">models</code> folder. The code is as follows:</p><div><pre class="programlisting">Ext.define('WeightWeight.model.Entry', {
    extend: 'Ext.data.Model',
    
    config: {
        idProperty: 'id',
        fields: [
            {name: 'id', type: 'auto'},
            {name: 'entryDate', type: 'date', dateFormat: 'm-d-Y'},
            {name: 'weight', type:'float'},
            {name: 'water', type:'int'},
            {name: 'calories', type: 'int'},
            {name: 'exercise', type: 'int'},
            {name: 'tag', type: 'string'}
        ],
        proxy: {
            type: 'localstorage',
            id: 'weightweight-entry'
        }
    }
});</pre></div><p>The model is pretty straightforward, defining the various data types and names. One thing to be aware of is the <code class="literal">entryDate</code> field<a id="id397" class="indexterm"/>, <a id="id398" class="indexterm"/>which has a <code class="literal">type</code> field of <code class="literal">date</code>.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>When you use a date type in a model, you should always declare a <code class="literal">dateFormat component</code>. This tells the model how to store and retrieve the data. It also provides a common <a id="id399" class="indexterm"/>
<a id="id400" class="indexterm"/>
<a id="id401" class="indexterm"/>translation for the components that grab data from the model. Failure to set the <code class="literal">dateFormat</code> <a id="id402" class="indexterm"/>component often leads to foul language and extreme frustration.</p></div></div><p>The next model we need is a model for the tags. The <code class="literal">Tag.js</code> file goes in the <code class="literal">models</code> folder and it is pretty simple. It only has an <code class="literal">id</code> field and a <code class="literal">text</code> field:</p><div><pre class="programlisting">Ext.define('WeightWeight.model.Tag', {
    extend: 'Ext.data.Model',
    
    config: {
        idProperty: 'id',
        fields: [
            {name: 'id', type: 'auto'},
            {name: 'text', type: 'string'}
        ],
        proxy: {
            type: 'localstorage',
            id: 'weightweight-tag'
        }
    }
});</pre></div><p>As before, we just use a <code class="literal">localstorage</code> proxy and give it a unique ID. This ID makes sure that the data is stored in its own separate table.</p><p>The last model we need <a id="id403" class="indexterm"/>
<a id="id404" class="indexterm"/>
<a id="id405" class="indexterm"/>is our <code class="literal">Config.js</code> model. This model follows the same format as a local storage proxy and the fields from our <code class="literal">config</code> form. The code is as follows:</p><div><pre class="programlisting">Ext.define('WeightWeight.model.Config', {
 extend: 'Ext.data.Model',
 config: {
  fields: [
   {name: 'id', type: 'int'},
   {name: 'startingWeight', type: 'float'},
   {name: 'targetWeight', type: 'float'},
   {name: 'exercisePerDay', type: 'int', defaultValue: 30},
   {name: 'caloriesPerDay', type: 'int'},
   {name: 'waterPerDay', type: 'int', defaultValue: 8},
   {name: 'weightUnits', type: 'string', defaultValue: 'lbs'},
   {name: 'waterUnits', type: 'string', defaultValue: 'glass'}
  ],
  proxy: {
   type: 'localstorage',
   id  : 'weightweight-config'
  }
 }
});</pre></div><p>We also include some default values as part of the model. These values will get pulled into the form when we create a new config record.</p><p>Once we have our models, we need <a id="id406" class="indexterm"/>
<a id="id407" class="indexterm"/>to create our data store. The <code class="literal">EntryStore.js</code> file is created and it goes into the <code class="literal">stores</code> folder. The code is as follows:</p><div><pre class="programlisting">Ext.define('WeightWeight.store.EntryStore', {
   extend: 'Ext.data.Store',
    config: {
   model: 'WeightWeight.model.Entry',
   autoLoad: true,
    storeId: 'EntryStore'
    }
});</pre></div><p>This is a very basic store that we will expand later. For now, we will be using the model to do most of the heavy lifting. We give the store a <code class="literal">storeId</code> value of <code class="literal">EntryStore</code>, so that we can easily address it with our <code class="literal">DataEntry</code> controller.</p><p>Next, we need a store for our tags. Since we only need very limited control over the tag store (it only feeds the list in our <code class="literal">AddTag</code> form), we are going to add the store as part of the component itself. Open the <code class="literal">AddTag.js</code> file and modify the <code class="literal">list</code> entry so that it looks similar to the following code:</p><div><pre class="programlisting">{
    xtype: 'list',
    height: 300,
    store: {
        model: 'WeightWeight.model.Tag',
        autoLoad: true
    },
    itemTpl: [
        '&lt;div&gt;{text}&lt;/div&gt;'
    ]
}</pre></div><p>This simple store format creates the store as part of the <code class="literal">list</code> entry and does not need to be added to our <code class="literal">app.js</code> file.</p><p>Speaking of the <code class="literal">app.js</code> file, we should <a id="id408" class="indexterm"/>
<a id="id409" class="indexterm"/>
<a id="id410" class="indexterm"/>add other models and stores near the top of the <code class="literal">Ext.Application</code> function as follows:</p><div><pre class="programlisting">models: ["Tag", "Entry", "Config"]
stores: ['EntryStore']</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>If a model or store is within its own file, then it needs to be added into the <code class="literal">app.js</code> file. But, since the simple store format for our <code class="literal">list</code> is part of the component itself, we don't need to add it to the <code class="literal">app.js</code> file.</p></div></div><p>In the case of our <code class="literal">Config</code> model, there will only be one config record for the application. This means that we don't actually need a store to use it. We will take care of that back in our controllers. </p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Meanwhile, back in the controllers</h2></div></div></div><p>Back in our <a id="id411" class="indexterm"/>
<a id="id412" class="indexterm"/>controllers, it's time to put those stores to work for us, saving and displaying our data.</p><p>Let's start with our <code class="literal">DataEntry</code> controller. First, we are going to add a few more references, so that we can get to our components easier. Update the <code class="literal">DataEntry.js</code> references as follows:</p><div><pre class="programlisting">refs: {
    tagSheet: '#addTagSheet',
    tagList: '#addTagSheet list',
    tagInput: '#addTagSheet textfield',
    tagButton: 'button#addTagButton',
    tagField: '#hiddenTagField',
    entrySaveButton: 'dataentry button[text="Save"]',
    entryCancelButton: 'dataentry button[text="Cancel"]',
    entryForm: 'dataentry'
}</pre></div><p>This provides us with easy access to our tag adding sheet, the list of tags, the input and hidden fields, as well as the button that opens the sheet. We also add references to our data entry form and both of its buttons.</p><p>Here, in the <code class="literal">control</code> <a id="id413" class="indexterm"/>
<a id="id414" class="indexterm"/>section we need to assign events and functions to each of these items. We can also use our reference names here to address the controls as follows:</p><div><pre class="programlisting">control: {
    tagButton: {
        tap: 'showAddTag'
    },
    tagInput: {
      clearicontap: 'deselectTag'
    },
    tagList: {
      select: 'selectTag'
    },
    '#addTagSheet button[text="Cancel"]': {
        tap: 'cancelAddTag'
    },
    '#addTagSheet button[text="Save"]': {
        tap: 'saveAddTag'
    },
    entrySaveButton: {
        tap: 'saveEntry'
    },
    entryCancelButton: {
        tap: 'clearEntry'
    }
}</pre></div><p>Notice that we used the reference name for most of these. However, for the <code class="literal">Save</code> and <code class="literal">Cancel</code> buttons on our <code class="literal">tagSheet</code>, we used the component query reference. This is because we don't really need any additional control over those two pieces. They are basically single purpose components.</p><p>For example, our <code class="literal">showAddTag</code>
<a id="id415" class="indexterm"/> and <code class="literal">cancelAddTag</code> function<a id="id416" class="indexterm"/>s both need to be able to grab the sheet itself in order to show and hide it. Since we have a reference of <code class="literal">TagSheet</code> assigned to it, we can call it with the following code:</p><div><pre class="programlisting">var sheet = this.getTagSheet();</pre></div><p>Since we don't modify the <a id="id417" class="indexterm"/>
<code class="literal">Save</code> and <code class="literal">Cancel</code> button<a id="id418" class="indexterm"/>s once they have been created, there is no need to create a reference for them. However, we will be making some modifications to our <code class="literal">AddTagButton</code> when we save our tag, so we created a reference for that one.</p><p>Let's update <a id="id419" class="indexterm"/>
<a id="id420" class="indexterm"/>our <code class="literal">saveAddTag</code> function and see how that's done. Change the function as follows:</p><div><pre class="programlisting">saveAddTag: function() {
        var tag = this.getTagInput().getValue(),
            store = this.getTagList().getStore();
        if (tag != "") {
            this.getTagButton().setText('Tag: '+tag);
            this.getTagField().setValue(tag);
            if (store.findExact('text', tag) == -1) {
                store.add({text: tag});
                store.sync();
            }
        } else {
            this.getTagButton().setText('Add Tag');
            this.getTagField().setValue('');
        }

        this.getTagSheet().hide();
    }</pre></div><p>Right from the start we begin using the <code class="literal">get</code> functions automatically created by our references. We get the value of the <code class="literal">textfield</code> in our form using <code class="literal">this.getTagInput().getValue()</code> and then we get the store we use for our tag list by calling the <a id="id421" class="indexterm"/>
<code class="literal">this.getTagList().getStore()</code> function.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Remember, the list store is the one we created as part of the component instead of a separate <code class="literal">store.js</code> file. However, since we can get to the list, and the list knows what store it is using, we have easy access to everything we need. The reference to the parent also gives us quick access to its children.</p></div></div><p>Next, we check to see if the user entered anything into the field (if the value of <code class="literal">tag != ""</code>) and if so, we set the text on our button to say <strong>Tag:</strong> and whatever the user entered. This provides the user with easy feedback as to what tag is on the current entry, so if we tag our entry as <strong>Tired</strong>, then the button will look like this:</p><div><img src="img/8901OS_04_08.jpg" alt="Meanwhile, back in the controllers"/></div><p>Next, we set the value of our hidden field to the same value. We do this because we will need to load our form into a record to save it. We can load values from a form field but we cannot load values from a button name. We use the hidden field to hold the value within the form for later use.</p><p>Next, we <a id="id422" class="indexterm"/>
<a id="id423" class="indexterm"/>need to find out if the tag is the one that we have entered previously, or if it is something new. To do this, we need to search the store using <code class="literal">store.findExact('text', tag)</code>. This will return <code class="literal">-1</code> if the value of <code class="literal">tag</code> is not found in the <code class="literal">text</code> field for any of the store's data. If we don't find the tag, we add it to our store using the following code:</p><div><pre class="programlisting">store.add({text: tag});
store.sync();</pre></div><p>Lastly, if the user has cleared the <code class="literal">textfield</code> out leaving it blank, we remove the previous tag text from the button and clear out the value of the hidden field.</p><p>Our next function controls when the user selects an existing tag from the list of tags in the sheet (instead of entering a new one):</p><div><pre class="programlisting">selectTag: function(list, record) {
this.getTagInput().setValue(record.get('text'));
}</pre></div><p>When the user selects an item in the list, we put the text of the item in the text field for saving. The <a id="id424" class="indexterm"/>
<code class="literal">saveAddTag</code> function will take care of the rest.</p><p>We have a similar function that deselects the items in the list:</p><div><pre class="programlisting">deselectTag: function() {
 this.getTagList().deselectAll();
}</pre></div><p>Our text field has a clear icon that removes the value of the field. We tie into the <code class="literal">clearicontap</code> event that we set up in our <code class="literal">controllers</code> section to fire this <code class="literal">deselectTag</code> <a id="id425" class="indexterm"/>function.</p><p>Now that we have our tags taken care of, we will be able to save the full entry. We do this by adding the following function:</p><div><pre class="programlisting">saveEntry: function() {
    var values = this.getEntryForm().getValues(),
    store = Ext.getStore('EntryStore'),
    entry = Ext.create('WeightWeight.model.Entry', values);

    store.add(entry);

    store.sync();
    Ext.Msg.alert('Saved!', 'Your data has been saved.', this.clearEntry, this);
}</pre></div><p>This function grabs the values from our form and creates a new entry for our store. Since the form names match the names of our model, we can use <code class="literal">Ext.Create</code> to create a new entry record and assign the values directly. We then add the new record to the store and sync. Finally, we alert the user that the new data has been saved.</p><p>Our final <a id="id426" class="indexterm"/>
<a id="id427" class="indexterm"/>function clears the fields in our form by using the following function:</p><div><pre class="programlisting">clearEntry: function() {
    this.getEntryForm().reset();
    this.getTagButton().setText('Add Tag');
}</pre></div><p>This function resets our form and the text of the button. This function will be fired by the <strong>Cancel</strong> button in our data entry form.</p><p>This wraps up the <code class="literal">DataEntry.js</code> controller. We can now move on to the <code class="literal">Config.js</code> controller.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Config.js</h3></div></div></div><p>Create a new file <a id="id428" class="indexterm"/>in the <code class="literal">controllers</code> folder called <code class="literal">Config.js</code> (make <a id="id429" class="indexterm"/>sure to also add it to the <code class="literal">app.js</code> file in the list of controllers). We will start with just the basic controller:</p><div><pre class="programlisting">Ext.define('WeightWeight.controller.Config', {
    extend: 'Ext.app.Controller',
    
    config: {
        views:['Config'],
        models:['Config'],
        refs: {
            form: 'configform'
        },
        control: {
            form: {
                initialize: 'getSavedConfig'
            }
        }
    }
});</pre></div><p>This sets up the controller with our views, models, and references. It also assigns a function to our form so that when it is initialized it calls <code class="literal">getSavedConfig</code>. This function is also the first one we need to create.</p><p>Before we get started, we should keep in mind a few things about <code class="literal">config</code>. This will be like a set of preferences for the application. There will only be one record for <code class="literal">config</code>, which is why we don't need to create a store. We can use the <code class="literal">Config.js</code> model to create, load, and save the record directly. Let's take a look at how this gets done.</p><p>Beneath the <a id="id430" class="indexterm"/>
<a id="id431" class="indexterm"/>
<code class="literal">config</code> section, we need to add the following code:</p><div><pre class="programlisting">getSavedConfig: function() {
    var config = Ext.ModelManager.getModel('WeightWeight.model.Config');
    config.load(1, {
        scope: this,
        failure: this.createSavedConfig, 
        success: this.bindRecordToForm 
    });
}</pre></div><p>Here, we create an instance of our <code class="literal">Config</code> model and attempt to load the first record from the HTML5 local storage (remember this should also be the only record). There are two possible outcomes here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the load fails, it means that this is the first time the user has accessed the <code class="literal">Config</code> section and we have no record. In this case, we will call another function called <code class="literal">createSavedConfig</code>.</li><li class="listitem" style="list-style-type: disc">If the load succeeds then we need to load the data into our form for display. This will happen in the <a id="id432" class="indexterm"/><code class="literal">bindRecordToForm</code> function.</li></ul></div><p>By setting the scope of the function to <code class="literal">this</code> (meaning the controller itself), we can make these two functions part of the controller and call them with <code class="literal">this.createSavedConfig</code> and <code class="literal">this.bindRecordToForm</code> respectively.</p><p>We'll start by adding our new functions beneath the previous <code class="literal">getSavedConfig</code> function:</p><div><pre class="programlisting">createSavedConfig: function() {
    var config = Ext.create('WeightWeight.model.Config', {id: 1});
    config.save({
        success: this.bindRecordToForm
    }, this);
}</pre></div><p>This function creates a new empty record with the default values we defined in the <code class="literal">config</code> object and then saves the record. If this is successful, we call our next function, which binds the data record to our form:</p><div><pre class="programlisting">bindRecordToForm: function(record) {
    this.savedConfig = record;

    var form = this.getForm();
    form.setRecord(this.savedConfig);

    form.on({
       delegate: 'field',
       change: this.updateValue,
        spin: this.updateValue,
        check: function(field) {
            this.updateValue(field, field.getGroupValue());
        },
        scope: this
    });
}</pre></div><p>This function is called by both <code class="literal">getSavedConfig</code> and <code class="literal">createSavedConfig</code>, which pass along the data record automatically. We set this record to be our <code class="literal">savedConfig</code>, which allows us to get at the config data from anywhere in the controller.</p><p>Next we grab the <a id="id433" class="indexterm"/>
<a id="id434" class="indexterm"/>form and use <code class="literal">setRecord</code> to populate the form with our data. Once the form is populated, we also need a way to save the data. To do this, we are going to use an interesting technique<a id="id435" class="indexterm"/> called <strong>delegate</strong>.</p><p>Delegate allows us to set listeners and functions on specific children within the form. In this case, we do <code class="literal">form.on({ delegate: 'field'</code>, which lets us set a group of listeners on every field in our form:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">numberfield</code> component <a id="id436" class="indexterm"/>understands the <code class="literal">change</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">spinnerfield</code> component<a id="id437" class="indexterm"/> understands the <code class="literal">spin</code> event</li><li class="listitem" style="list-style-type: disc">The <code class="literal">checkboxfield</code> component<a id="id438" class="indexterm"/> understands the <code class="literal">check</code> event</li></ul></div><p>Each of these events will call <code class="literal">this.updateValue</code> to save the data. While the other fields pass along both the field and value automatically, the checkboxes actually only pass the field when the <code class="literal">check</code> event fires. This means we do a tiny bit of extra work to get them to pass both field and value to our next function.</p><p>Our <code class="literal">updateValue</code> function<a id="id439" class="indexterm"/> takes the field and value passed in our previous function, and saves the data for us:</p><div><pre class="programlisting">updateValue: function(field, newValue) {
    this.savedConfig.set(field.getName(), newValue);
    this.savedConfig.save();
}</pre></div><p>This saves our data to local storage. Now that we have a way to save data and our goals, we can start looking at the charting functions for displaying the data.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Getting started with Sencha Touch Charts</h3></div></div></div><p>As we noted at the <a id="id440" class="indexterm"/>beginning of the chapter, Sencha Touch Charts is currently only available as part of Sencha Complete or the open source version of Sencha Touch 2.1. Previously, Sencha Touch Charts was a separate download, which had to be installed and configured as part of your application in order to function. This is no longer required.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>It should also be noted that if you are using the standalone commercial version of Sencha Touch 2.1 (which is not part of the Sencha Complete package), you will not be able to use the new Sencha Charts functions. While this standalone commercial version of Sencha Touch 2.1 includes an empty <code class="literal">src/charts</code> directory, it does not have any of the actual chart functionality.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Creating the overview chart</h2></div></div></div><p>The overview chart is <a id="id441" class="indexterm"/>a single-line chart, tracking weight and <a id="id442" class="indexterm"/>exercise. Our chart will have three axes, with weight ranges displayed on the left, date ranges displayed across the bottom, and exercise time ranges along the right.</p><p>The following screenshot describes the preceding explanation in more detail:</p><div><img src="img/8901OS_04_09.jpg" alt="Creating the overview chart"/></div><p>We will start with a <a id="id443" class="indexterm"/>
<a id="id444" class="indexterm"/>few changes to our placeholder for the <code class="literal">OverviewChart.js</code> view:</p><div><pre class="programlisting">Ext.define("WeightWeight.view.OverviewChart", {
    extend:'Ext.Panel',
    alias:'widget.overview',
    config:{
        title:'Overview',
        iconCls:'star',
        layout: 'fit',
        items:[{
          xtype:'chart',
          store:'EntryStore', 
          legend:{
            position:'bottom'
          }]
       }
    }
});</pre></div><p>Here, we've replaced the <code class="literal">html</code> configuration and included a single <code class="literal">chart</code> item as part of our panel.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Previous versions of the Sencha Touch Chart software used a <code class="literal">chartPanel</code> object, which automatically included the <code class="literal">chart</code> item as part of the panel. The current Version 2.1 treats the <code class="literal">chart</code> item as a separate object, which allows the <code class="literal">chart</code> item to be embedded in a panel or a container.</p></div></div><p>We have given the <a id="id445" class="indexterm"/>
<a id="id446" class="indexterm"/>
<code class="literal">chart</code> item a <code class="literal">store</code> value to grab data from, and positioned the <code class="literal">legend</code> section at the <code class="literal">bottom</code> of the chart.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Adding the axes</h3></div></div></div><p>The next piece we need to <a id="id447" class="indexterm"/>
<a id="id448" class="indexterm"/>add is our axes. As we mentioned earlier, there are three for this graph. The code for them goes inside the <code class="literal">chart</code> section of the <code class="literal">config</code> definition (below our <code class="literal">legend</code> definition):</p><div><pre class="programlisting">axes:[
 {
  type:'numeric',
  position:'left',
  fields:['weight'],
  title:{
   text:'Weight',
   fontSize:14
  }
 },
 {
  type:'numeric',
  position:'right',
  fields:['exercise'],
  title:{
   text:'Exercise',
   fontSize:14
  }
 },
 {
  type:'time',
  dateFormat:'m-d-Y',
  position:'bottom',
  fields:'entryDate',
  title:{
   text:'Date',
   fontSize:20
  }
 }
]</pre></div><p>The first axis has a <code class="literal">title</code> section of <code class="literal">weight</code> and it's a <code class="literal">numeric</code> axis. We position it on the left-hand side and then tell the axis which fields we are tracking (in this case, <code class="literal">weight</code>).</p><p>As you might have <a id="id449" class="indexterm"/>
<a id="id450" class="indexterm"/>guessed from the name <code class="literal">fields</code>, this means we can have multiple items tracked along the same axis. This works well if you have multiple items with the same numeric range of data. In this case, we have too much variation in the range of <code class="literal">exercise</code> and <code class="literal">weight</code>, so we keep them on different axes.</p><p>The <code class="literal">exercise</code> axis is set up in a similar fashion, but positioned on the right.</p><p>The <code class="literal">date</code> axis is a bit different. It has a type of <code class="literal">date</code> and a <code class="literal">dateFormat</code> for display.</p><p>Next, we need to set up the series.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Creating the series</h3></div></div></div><p>The <code class="literal">series</code> section <a id="id451" class="indexterm"/>goes inside the chart configuration and beneath our <a id="id452" class="indexterm"/>axes section. The <code class="literal">series</code> section describes how the data points should align on the graph and how they should be formatted.</p><p>Our overview graph is a line graph display, tracking weight and exercise over time. We need one entry for weight and a second one for exercise:</p><div><pre class="programlisting">series:[
 {
  type:'line',
  xField:'entryDate',
  yField:'weight',
  title:'Weight',
  axis:'left',
  style:{
   smooth:false,
   stroke:'#76AD86',
   miterLimit:3,
   lineCap:'miter',
   lineWidth:3
  },
  marker:{
   type:'circle',
   r:6,
   fillStyle:'#76AD86'
  },
  highlightCfg:{
   scale:1.25
  }
 },
 {
  type:'line',
  xField:'entryDate',
  yField:'exercise',
  title:'Exercise',
  axis:'right',
  style:{
   smooth:false,
   stroke:'#7681AD',
   lineWidth:3
  },
  marker:{
   type:'circle',
   r:6,
   fillStyle:'#7681AD'
  },
  highlightCfg:{
   scale:1.25
  }
 }
]</pre></div><p>This defines our two series (<code class="literal">Weight</code> and <code class="literal">Exercise</code>). The <code class="literal">type</code> configuration defines which kind of series we are using. The <code class="literal">xField</code> configuration determines which data field is tracked along the horizontal axis (<code class="literal">entryDate</code> for both) and the <code class="literal">yField</code> configuration determines which field is tracked <a id="id453" class="indexterm"/>along the vertical axis (<code class="literal">weight</code> for the first series and <code class="literal">exercise</code> for the second). The <code class="literal">axis</code> configuration tells the series which part of the graph to map its values to.</p><p>The <code class="literal">style</code> section <a id="id454" class="indexterm"/>determines how the line for our series will appear. The <code class="literal">marker</code> section<a id="id455" class="indexterm"/> gives us the appearance of each data point along the line. The <code class="literal">highlightCfg</code> section uses <code class="literal">scale</code> to increase the size of a selected marker, so when the user clicks on a data point, the marker will increase to 1.25 times its normal size.</p><p>The <code class="literal">marker</code> section itself is actually a <code class="literal">sprite</code> reference, which means that we can use any of the available Sencha Touch <code class="literal">sprite</code> objects for our <code class="literal">marker</code>. These include things such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Circles</li><li class="listitem" style="list-style-type: disc">Ellipses</li><li class="listitem" style="list-style-type: disc">Images</li><li class="listitem" style="list-style-type: disc">Rectangles</li><li class="listitem" style="list-style-type: disc">Text</li></ul></div><p>A full list of available <a id="id456" class="indexterm"/>sprites and their configuration options can be found at <a class="ulink" href="http://docs.sencha.com/touch/2-1/">http://docs.sencha.com/touch/2-1/</a> in the <strong>draw</strong> | <strong>sprite</strong> section of the API. To use these sprites, you just need to set the type configuration to the sprite name. The name for each sprite can be <a id="id457" class="indexterm"/>
<a id="id458" class="indexterm"/>found at the top of the documentation as seen in the following screenshot:</p><div><img src="img/8901OS_04_10.jpg" alt="Creating the series"/></div><p>Once the <code class="literal">type</code> config is set for the <code class="literal">marker</code> section, you can use any of the sprite's configuration options to customize the marker's appearance.</p><p>Now that the series configuration is complete, we can also add some interactions to the graph to make it more interesting.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>The interactions section</h3></div></div></div><p>The <a id="id459" class="indexterm"/>
<a id="id460" class="indexterm"/>
<code class="literal">interactions</code> section allows us to respond to the user's taps and gestures to expand the amount of information we provide. The current types of interactions include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ItemCompare</code>: This lets the <a id="id461" class="indexterm"/><a id="id462" class="indexterm"/>user select two items and see a data comparison</li><li class="listitem" style="list-style-type: disc"><code class="literal">ItemHightlight</code>: This lets the user <a id="id463" class="indexterm"/><a id="id464" class="indexterm"/>tap and highlight a series of data items in the chart</li><li class="listitem" style="list-style-type: disc"><code class="literal">ItemInfo</code>: This lets the <a id="id465" class="indexterm"/><a id="id466" class="indexterm"/>user tap and get a detailed view of the data record</li><li class="listitem" style="list-style-type: disc"><code class="literal">PanZoom</code>: This lets the user <a id="id467" class="indexterm"/><a id="id468" class="indexterm"/>pinch the chart to zoom in and out, or let them tap and drag to pan</li><li class="listitem" style="list-style-type: disc"><code class="literal">PieGrouping</code>: This lets the <a id="id469" class="indexterm"/><a id="id470" class="indexterm"/>user select and merge consecutive pie slices</li><li class="listitem" style="list-style-type: disc"><code class="literal">Rotate</code>: This lets the user tap and <a id="id471" class="indexterm"/><a id="id472" class="indexterm"/>drag around the center of the pie or radar charts to rotate the chart</li><li class="listitem" style="list-style-type: disc"><code class="literal">ToggleStacked</code>: This lets the user <a id="id473" class="indexterm"/><a id="id474" class="indexterm"/>toggle between stacked and grouped orientations on a bar or column series chart</li></ul></div><p>For this <a id="id475" class="indexterm"/>application, we will allow the user to tap the data points and get back all of the details for that particular day. We set up an interaction with a <code class="literal">type</code> value of <code class="literal">iteminfo</code> and define a <code class="literal">tpl</code> tag, which is used to display the data in the panel. The interaction receives the entire data record for the tapped data point so the <code class="literal">tpl</code> tag can use any of our values for weight, exercise, water, calories, or tags:</p><div><pre class="programlisting">interactions:[
 {
  type:'iteminfo',
  panel:{
   tpl:[ '&lt;table&gt;',
    '&lt;tpl if="weight"&gt;&lt;tr&gt;&lt;th&gt;Weight&lt;/th&gt;&lt;td&gt;{weight} ({weightUnits})&lt;/td&gt;&lt;/tr&gt;&lt;/tpl&gt;',
    '&lt;tpl if="water"&gt;&lt;tr&gt;&lt;th&gt;Water&lt;/th&gt;&lt;td&gt;{water} ({waterUnits})&lt;/td&gt;&lt;/tr&gt;&lt;/tpl&gt;',
    '&lt;tpl if="calories"&gt;&lt;tr&gt;&lt;th&gt;Calories&lt;/th&gt;&lt;td&gt;{calories}&lt;/td&gt;&lt;/tr&gt;&lt;/tpl&gt;',
    '&lt;tpl if="exercise"&gt;&lt;tr&gt;&lt;th&gt;Exercise&lt;/th&gt;&lt;td&gt;{exercise} minutes&lt;/td&gt;&lt;/tr&gt;&lt;/tpl&gt;',
    '&lt;tpl if="tag"&gt;&lt;tr&gt;&lt;th&gt;Tag&lt;/th&gt;&lt;td&gt;{tag}&lt;/td&gt;&lt;/tr&gt;&lt;/tpl&gt;',
    '&lt;/table&gt;'
   ]
  }</pre></div><p>This template will display our detailed item info. Next, we need to add the listener that will show the window when we click on one of the data points in our <code class="literal">OverviewChart</code>:</p><div><pre class="programlisting">  listeners:{
   show:function (interaction, item, panel) {
    var record = item.record;
    var dt = new Date(record.get('entryDate'));
    var config = Ext.ModelManager.getModel('WeightWeight.model.Config');
    config.load(1, {
     scope:this,
     success:function (configRecord) {
      panel.setData(Ext.apply(record.getData(), configRecord.getData()));
     }
    });

panel.getDockedComponent(0).setTitle(Ext.Date.format(dt, 'm-d-Y'));
   }
  }
 }
]</pre></div><p>The listener starts by setting <code class="literal">var record = item.record;</code> and then getting the date out of the record so that we can format it properly for our <code class="literal">setTitle</code> function at the end of the listener.</p><p>Next, we <a id="id476" class="indexterm"/>grab our single config record so that we can get the units of measurement for weight and water consumption. Then we set the data for the panel to the combined <code class="literal">record</code> and <code class="literal">configRecord</code> objects (using <code class="literal">Ext.apply()</code>). <a id="id477" class="indexterm"/>This gets both sets of data into our <code class="literal">tpl</code> for display.</p><p>Lastly, since this is a special floating panel in Sencha Touch, it has no <code class="literal">title</code> attribute, but we can create one using the first docked component in the panel. We set this <code class="literal">title</code> to the formatted date we grabbed at the top of the function.</p><div><img src="img/8901OS_04_11.jpg" alt="The interactions section"/></div><p>You should be able to save your work now and click on any of the data points to see our new detailed item info.</p><p>The last <a id="id478" class="indexterm"/>thing we want to cover is creating the details view.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Creating the details view</h2></div></div></div><p>For the details <a id="id479" class="indexterm"/>chart, we have decided to make something a little more <a id="id480" class="indexterm"/>reusable. Our overall details view will contain three similar charts and a radar chart. Since we don't want to create the same chart over and over, we need a view we can call up with a different configuration for each of our charts. This will be a simple bar style chart with two axes; one for the date and one for the amount.</p><div><img src="img/8901OS_04_12.jpg" alt="Creating the details view"/></div><p>This reusable <a id="id481" class="indexterm"/>chart will be our <code class="literal">goalChart</code> view. <a id="id482" class="indexterm"/>We will create <a id="id483" class="indexterm"/>the <code class="literal">goalChart</code> view with its own <code class="literal">xtype</code>, which will allow us to reuse it with different configurations.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Creating the goalChart view</h3></div></div></div><p>We start by <a id="id484" class="indexterm"/>creating a <code class="literal">goalChart</code> view and <a id="id485" class="indexterm"/>setting it up to load our <code class="literal">config</code> file when it initializes:</p><div><pre class="programlisting">Ext.define('WeightWeight.view.goalChart', {
   extend:'Ext.Panel',
    alias:'widget.goalchart',
    config: {
      layout: 'fit'
    },
    constructor: function (config) {
        this.store = Ext.getStore('EntryStore');

        Ext.apply(this, config);

        this.callParent([config]);
        var configRecord = Ext.ModelManager.getModel('WeightWeight.model.Config');
        configRecord.load(1, {
            scope:this,
            success: this.createChart
        });

    }
});</pre></div><p>Here, we set our panel's store to the <code class="literal">EntryStore</code> that contains all of our data (this gives us access to every record). Next, our <a id="id486" class="indexterm"/>
<code class="literal">constructor</code> function will take whatever configuration options are passed to it, <a id="id487" class="indexterm"/>and applies them to the panel using <code class="literal">Ext.apply(this, config);</code>. This is where we will set an individual <code class="literal">title</code>, <code class="literal">dataField</code>, <code class="literal">goalField</code>, and <code class="literal">colorSet</code> for each chart.</p><p>Once these <a id="id488" class="indexterm"/>options are set, the panel then loads the goals and measurements from our single <code class="literal">configRecord</code> in much the same way as our previous chart panel. This time when the <code class="literal">Config</code> successfully loads, we call a new function called <code class="literal">createChart</code>.</p><p>The <code class="literal">createChart</code> function<a id="id489" class="indexterm"/> comes right after our <code class="literal">constructor</code> function:</p><div><pre class="programlisting">createChart: function(config) {
 this.configRecord = config;
 var goalStore = Ext.create('Ext.data.Store',{ fields: [
    'entryDate', 
    {name: Ext.String.capitalize(this.dataField), type:'int'}, 
    {name: 'goal', type: 'int'}
   ]
  }
 );
 this.store.each(function(record) {
 if (record.get(this.dataField)) {
  var values = {
  entryDate: Ext.Date.format(dt,'m-d-Y'),
  goal: this.configRecord.get(this.goalField)
  };
  values[Ext.String.capitalize(this.dataField)] = record.get(this.dataField);
  goalStore.add(values);
  }
 }, this);
}</pre></div><p>The <code class="literal">createChart</code> <a id="id490" class="indexterm"/>function starts by creating a second <code class="literal">store</code> called the <code class="literal">goalStore</code> and gives it three fields as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">entryDate</code>: This is the date field from our store</li><li class="listitem" style="list-style-type: disc"><code class="literal">goal</code>: This is the the goal passed from our <code class="literal">configRecord</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">this.dataField</code>: This will be passed to us as one of our config options when we use the <code class="literal">goalChart</code> view</li></ul></div><p>We then loop through our data in the main store (<code class="literal">EntryData</code>) and look for any values in the field that match the value we received for <code class="literal">this.dataField</code>. As we find matches, we add them to our <code class="literal">goalStore</code>. <a id="id491" class="indexterm"/>The <code class="literal">goalStore</code> is the actual store that will feed the chart.</p><p>For example, <a id="id492" class="indexterm"/>we could use the following code to create a <code class="literal">goalChart</code> view:</p><div><pre class="programlisting">{
  xtype: 'goalchart', 
  chartTitle: 'Exercise', 
  dataField: 'exercise', 
  goalField: 'exercisePerDay', 
  colorSet:['#a61120', '#ff0000'] 
}</pre></div><p>The <code class="literal">goalChart</code> <a id="id493" class="indexterm"/>view would use the <code class="literal">dataField</code> value to look for any data we have for <code class="literal">exercise</code> and create the chart. It would also use the <code class="literal">goalField</code> value of <code class="literal">exercisePerDay</code> to grab that number from our config record and add it to the display.</p><p>The final part of our <code class="literal">goalChart</code> sets up the series and axes much like the previous one:</p><div><pre class="programlisting">this.chart = Ext.factory({
 xtype: 'chart',
 store: goalStore,
 animate: true,
 legend: {
  position: 'right'
 },
 axes: [{
  type:'Numeric',
  position:'left',
  fields:[ Ext.String.capitalize(this.dataField), 'goal'],
  title: Ext.String.capitalize(this.dataField),
  decimals:0,
  minimum:0
 },
 {
  type:'category',
  position:'bottom',
  fields:['entryDate'],
  title:'Date'
 }],
 series: [
  {
   type: 'bar',
   xField: 'entryDate',
   yField: Ext.String.capitalize(this.dataField),
   style: {
    fill: this.colorSet[0],
    shadowColor: 'rgba(0,0,0,0.3)',
    maxBarWidth: 50,
    minGapWidth: 3,
    shadowOffsetX: 3,
    shadowOffsetY: 3
   }
  },
  {
   type:'line',
   style: {
    smooth: false,
    stroke: this.colorSet[1],
    lineWidth: 3
   },
   axis:'left',
   xField:'entryDate',
   yField:'goal',
   showMarkers: false,
   title:'Goal'
   }
  ]
 }, 'Ext.char t.Chart');</pre></div><p>The main difference <a id="id494" class="indexterm"/>from the previous charts is that we have some values that will be supplied by our <code class="literal">config</code>, and we use the <code class="literal">Ext.factory</code> function to create the chart object.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Here, our use of <code class="literal">Ext.factory</code> is equivalent to <code class="literal">Ext.create</code>, but <code class="literal">Ext.factory</code> can also be used to update the configuration of existing objects. We chose to use <code class="literal">Ext.factory</code> here, rather than <code class="literal">Ext.create</code>, solely because most of the Sencha Charts examples refer to <code class="literal">Ext.factory</code> when creating charts, and we wanted to be consistent.</p></div></div><p>Now we can re-use the chart for our exercise, water, and weight charts just by setting different <code class="literal">config</code> values for:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dataField</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">goalField</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">chartTitle</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">colorSet</code></li></ul></div><p>Take a look at the <code class="literal">DetailChart.js</code> file in our example code to see how this works.</p><p>The last chart we <a id="id495" class="indexterm"/>need to touch on is the word chart.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Creating the word chart</h3></div></div></div><p>The <code class="literal">wordChart</code> view is <a id="id496" class="indexterm"/>set up much like our <code class="literal">goalChart</code> with its own <code class="literal">constructor</code> and <code class="literal">createChart</code> function. However, the goal chart uses our tags to create a <a id="id497" class="indexterm"/>different type of chart called a radar chart. Our <code class="literal">wordChart.js</code> file checks for the number of occurrences of specific words and uses the information to draw our radar chart.</p><div><img src="img/8901OS_04_13.jpg" alt="Creating the word chart"/></div><p>The beginning of the <code class="literal">wordChart.js</code> file looks almost the same as our <code class="literal">goalChart</code>:</p><div><pre class="programlisting">Ext.define('WeightWeight.view.wordChart', {
    extend:'Ext.Panel',
    alias:'widget.wordchart',
    config: {
        layout: 'fit'
    },
    constructor: function (config) {
        this.store = Ext.getStore('EntryStore');
        Ext.apply(this, config);
        this.callParent([config]);
        var configRecord = Ext.ModelManager.getModel('WeightWeight.model.Config');
        configRecord.load(1, {
            scope:this,
            success: this.createChart
        });

    }


});</pre></div><p>After the <a id="id498" class="indexterm"/>
<a id="id499" class="indexterm"/>end of the <code class="literal">constructor</code>, we set up our <code class="literal">createChart</code> function:</p><div><pre class="programlisting">createChart: function(config) {
        this.configRecord = config;
        this.store.filterBy(function(record) {
            if (record.get('tag')) {
                return true;
            } else {
                return false;
            }
        });
        this.store.setGroupField('tag');
        this.store.setGroupDir('ASC');
        var groups = this.store.getGroups();
        this.store.setGroupField('');
        this.store.clearFilter();
        var wordStore = Ext.create('Ext.data.Store',
            { fields: ['name', {name: 'count', type: 'int'}]}
        );
        Ext.each(groups, function(group) {
           wordStore.add({name: group.name, count: group.children.length});
        });</pre></div><p>This grabs our <code class="literal">configRecord</code> like we did previously and then filters our <code class="literal">store</code> to find only the records that have <code class="literal">tag</code> data. We then <code class="literal">group</code> the fields by <code class="literal">tag</code> so that we can generate a <code class="literal">count</code> for each <code class="literal">tag</code>.</p><p>Next we create a <a id="id500" class="indexterm"/>
<a id="id501" class="indexterm"/>second <code class="literal">store</code>, much like in our <code class="literal">goalCharts</code> and we transfer our tag names and our counts into the second <code class="literal">store</code>. This one is called our <a id="id502" class="indexterm"/>
<code class="literal">wordStore</code>.</p><p>Now that we have a <code class="literal">wordStore</code> that consists only of the tag name and the number of times it occurs, we can use it to feed our new chart. Again, we use the <code class="literal">Ext.Factory</code> to create our store:</p><div><pre class="programlisting">this.chart = Ext.factory({
 xtype: 'polar',
 store: wordStore,
 animate: {
  easing: "backInOut",
  duration: 500
 },
 series: [{
  type: 'radar',
  xField: 'name',
  yField: 'count',
  labelField: 'name',
  marker:{
   type:'circle',
   r:3,
   fillStyle:'#76AD86'
  },
  style: {
   fillStyle: 'rgba(0,255,0,0.2)',
   strokeStyle: 'rgba(0,0,0,0.8)',
   lineWidth: 1
  }
 }]</pre></div><p>The radar style chart uses an <code class="literal">xtype</code> value of <code class="literal">polar</code> as part of its chart configuration.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>
<strong>Polar</strong> charts<a id="id503" class="indexterm"/> include circular chart systems such as the pie and radar style charts, whereas <strong>Cartesian</strong> charts<a id="id504" class="indexterm"/> are line-based charts such as the area and bar charts.</p></div></div><p>In the <code class="literal">series</code> section, the <code class="literal">type</code> value for our chart is then set to <code class="literal">radar</code>, which gives us our specific chart appearance.</p><p>As with our previous charts, we also set <code class="literal">marker</code> and <code class="literal">style</code> configurations. Finally, we finish our <code class="literal">wordChart</code> by setting up the axes, closing out the chart object, and adding it to our panel:</p><div><pre class="programlisting">axes: [{
  type: 'numeric',
   position: 'radial',
   fields: 'count',
   grid: true,
   label: {
    fill: 'black'
   }
  },{
   type: 'category',
   position: 'angular',
   fields: 'name',
   grid: true,
   label: {
    fill: 'black'
   },
  style: {
   estStepSize: 1
  }
 }]
}, 'Ext.chart.Chart');

this.add(this.chart); </pre></div><p>We have two axes here: a <code class="literal">numeric</code> axis for our tag counts and a <code class="literal">category</code> axis for our tag names. We map <a id="id505" class="indexterm"/>
<a id="id506" class="indexterm"/>these axes to the correct <code class="literal">field</code> and set <code class="literal">grid</code> to <code class="literal">true</code>. This will give us an underlying grid for our radar chart.</p><p>The <code class="literal">style</code> setting of <code class="literal">estStepSize: 1</code> ensures that all of our words will show up around the edge of our radar chart, without skipping any words.</p><p>Now that our <code class="literal">wordChart</code> is finished, we need to assemble all of our charts into a single page for our full details view:</p><div><img src="img/8901OS_04_14.jpg" alt="Creating the word chart"/></div><p>Back in our <code class="literal">details.js</code> placeholder file, we need to set up a new layout and add our four charts. <a id="id507" class="indexterm"/>
<a id="id508" class="indexterm"/>As you can see in the screenshot, we have our four charts arranged in a square on the page with one chart in each corner. The easiest way to accomplish this is with a set of nested <code class="literal">hbox</code> and <code class="literal">vbox</code> layouts:</p><div><img src="img/8901OS_04_15.jpg" alt="Creating the word chart"/></div><p>As you can see in the previous image, our details panel will have a <code class="literal">layout</code> section of <code class="literal">hbox</code>, with two containers inside, one on top of the other. In our <code class="literal">config</code> section, add the layout as follows:</p><div><pre class="programlisting">  layout: {
   type: 'hbox',
   align: 'stretch',
   pack: 'center',
   flex: 1
  }</pre></div><p>The <code class="literal">stretch</code> and <code class="literal">center</code> values ensure that our containers will expand to fill the available <a id="id509" class="indexterm"/>
<a id="id510" class="indexterm"/>space and occupy the center of our details panel. The <code class="literal">flex</code> value makes the inner containers equal in size. These two containers will have a layout of <code class="literal">vbox</code>.</p><p>We add these two containers in an <code class="literal">items</code> section within our <code class="literal">config</code> section:</p><div><pre class="programlisting">items: [
    {
        xtype: 'container',
        layout: {
            type: 'vbox',
            align: 'stretch',
            pack: 'center',
            flex: 1
        },
        items: [
            {height: 300, width: 400, xtype: 'goalchart', chartTitle: 'Exercise', dataField: 'exercise', goalField: 'exercisePerDay', colorSet:['#a61120', '#ff0000'] },
            {height: 300, width: 400, xtype: 'goalchart', chartTitle: 'Caloric Intake', dataField: 'calories', goalField: 'caloriesPerDay', colorSet:['#ffd13e', '#ff0000']}
        ]
    },
    {
        xtype: 'container',
        layout: {
            type: 'vbox',
            align: 'stretch',
            pack: 'center',
            flex: 1
        },
        items: [
            {height: 300, width: 400, xtype: 'goalchart', chartTitle: 'Water', dataField: 'water', goalField: 'waterPerDay', colorSet:['#115fa6', '#ff0000']},
            {height: 300, width: 400, xtype: 'wordchart', chartTitle: 'Tags', dataField: 'tag'}
        ]
    }
]</pre></div><p>The two containers form a top and bottom layout with two charts each. The goal charts each have slightly different configurations so that they display exercise, calories, and water consumption. We also color them differently to provide more visual appeal. The <code class="literal">wordchart</code> uses a similar configuration to include only the data from our tags.</p><p>With this <a id="id511" class="indexterm"/>
<a id="id512" class="indexterm"/>last panel completed, you should be able to enter data into the application and test all of the charts.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Homework</h1></div></div></div><p>Take some time to play around with the different types of charts and see what is available. The Sencha website has <a id="id513" class="indexterm"/>an excellent guide for using charts and interactions at <a class="ulink" href="http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting">http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter we talked about:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the basic application to create the different views for the application</li><li class="listitem" style="list-style-type: disc">Creating the stores that will hold the data and feed our charts</li><li class="listitem" style="list-style-type: disc">Setting up the controllers for the application</li><li class="listitem" style="list-style-type: disc">Creating the overview chart</li><li class="listitem" style="list-style-type: disc">Creating the details chart</li></ul></div><p>In the next chapter we will look at creating a simple application to work with an external API.</p></div></body></html>