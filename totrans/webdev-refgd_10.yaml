- en: Chapter 10. JavaScript Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is an object-oriented programming language. In **object-oriented
    programming** (**OOP**) languages, we use the concept of objects rather than actions
    to develop applications. In the past, JavaScript had no real foundation and was
    just a basic language. JavaScript is not a fully OOP-based language like JAVA,
    C#, and other programming languages, but it still has many OOP features.
  prefs: []
  type: TYPE_NORMAL
- en: There are many features in JavaScript where code is reused. So, rather than
    using procedural concepts in JavaScript, we use object-oriented programming techniques.
    There are four basic principles of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since JavaScript is a dynamic language, it supports **polymorphism**. Polymorphism
    can be understood as the ability of an object to be different at different times.
    For example, a shape can be a square, a rectangle, or a circle.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This feature is also supported in JavaScript. It means protecting parts of code
    from external use. It protects part of the code that does not concern the end
    user but is important for running an application, such as in an application that
    stores passwords. Users don't have to know how their passwords are encrypted.
    Hence, this code is encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, inheritance can be used to derive properties of parent objects
    to their child objects and have some unique attributes for themselves as well.
    For example, a square and a triangle may inherit their stroke or fill from a `shape`
    object and, at the same time, have a number of vertices unique to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstraction is not natively supported in JavaScript, but there are methods through
    which this can be achieved, using a combination of polymorphism and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects are the basic key to understand object-oriented programming. Programming
    objects are just like real-world objects. Look around, you'll see many objects.
    Your car, mobile phone, desk, laptop, pet dog, and DVD player are all objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'All objects have two characteristics: properties and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: A mobile has properties (color, screen size, height, and weight) and methods
    (make calls, send SMSs, receive calls, and transfer files).
  prefs: []
  type: TYPE_NORMAL
- en: A car has properties (color, height, gearbox, wheels, engine, brakes, and steering)
    and methods (start engine, steer, change gear, apply brake, stop, and crash).
  prefs: []
  type: TYPE_NORMAL
- en: Just like these real-world examples, the objects in OOP have the same characteristics.
    So, an object, in terms of programming, can have properties (variables in any
    programming language) and methods (functions in any programming language).Hence,
    we can define an object as "*an entity or a thing that has some properties and
    methods associated with it. An object can be individually selected and manipulated*".
  prefs: []
  type: TYPE_NORMAL
- en: All generic properties and methods are combined into a template called a **class**.
    A class is then used as a template to instantiate single or multiple objects.
    In JavaScript, there are many built-in objects, such as Maths, Dates, Regular
    Expressions, Arrays, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, we can create objects in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using object literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using new keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `object.create()` method (ECMAScript 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the simplest way to create an object. An object can be both created
    and defined in one statement using an object literal. An object literal is a comma-separated
    list of `name:value` (like year:1990, age:25) pairs enclosed within curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have created a `car` object with four properties
    or attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, this piece of code creates an object with no properties.
  prefs: []
  type: TYPE_NORMAL
- en: The new keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `new` keyword is used to create and initialize a new object. The `new` keyword
    is always followed by a function call. This function is known as a constructor,
    which initializes the newly created object. JavaScript contains built-in constructors
    for the native types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example also creates a new `car` object with four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The object.create() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `object.create()` method was originally defined in ECMAScript 5\. It is
    also used to create an object. The first argument passed to this method is the
    prototype of that object. The second argument is optional. It describes the object's
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Null` can be passed if the object does not have any prototype. However, this
    object will not inherit anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write scalable code, we need to track down the recurring sections in our
    code and to optimize them in a way that it's easy to maintain the code. Design
    patterns help us in doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a book, *Addison-Wesley Professional* by *Erich Gamma*, *John Vlissides*,
    *Ralph Johnson*, and *Richard Helm*; First edition (November 10, 1994), Design
    Patterns are defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A design pattern names, abstracts, and identifies the key aspects of a common
    design structure that make it useful for creating a reusable object-oriented design.
    The design pattern identifies the participating classes and their instances, their
    roles and collaborations, and the distribution of responsibilities.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Each design pattern focuses on a particular object-oriented design problem
    or issue. It describes when it applies, whether or not it can be applied in view
    of other design constraints, and the consequences and trade-offs of its use. Since
    we must eventually implement our designs, a design pattern also provides sample
    code to illustrate an implementation.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Although design patterns describe object-oriented designs, they are based
    on practical solutions that have been implemented in mainstream object-oriented
    programming languages.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Developers usually question whether there is any best design pattern to implement
    in their workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, no single design pattern is perfect for all scenarios. Each and every
    web application that is developed has its own needs. We have to see which pattern
    will add value to our application if implemented, because all design patterns
    serve different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once we have a good understanding of design patterns, it will be easier
    for us to integrate a pattern into our application architecture. Design patterns
    are classified into three categories: creational, structural, and behavioral.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational design patterns**: Constructor, factory, prototype, and singleton
    are examples of creational design patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural design patterns**: Decorator, façade, and flyweight are example
    of structural design patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral** **design patterns**: Observer and mediator are examples of such
    patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructors are special methods used to initialize objects. They may accept
    arguments, which are then used to set values to member properties and methods
    when the object is created. Native constructors, such as arrays and objects, are
    present inside JavaScript as native functions. We can also create custom constructors
    that define properties and methods for our custom object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the `constructor` method, we create an object using the `new` keyword. In
    this method, we define properties and methods with the `this` keyword. Properties
    are defined after the `=` sign. When you define each property, you must place
    a semicolon at the end. When you use the `this` method in your script, you need
    to first initialize the object and then use it in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple constructors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A constructor is considered to be the most suitable way to implement an instance.
    The `new` keyword tells JavaScript that we would like that function to act like
    a constructor and to create an instance also called `object`. Within a constructor,
    the `this` keyword is used to reference the new object.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype constructors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prototype is a property of functions in JavaScript. Whenever a `constructor`
    function is invoked to create a new object, all of the characteristics of that
    constructor's prototype are then associated to the new object.
  prefs: []
  type: TYPE_NORMAL
- en: Module pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Modules are an essential part of any well-constructed web application. They
    are independent blocks linked with each other in a neat, understandable and well-organized
    way. In other words, they give the program a structure and also provide encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Modules can be implemented in several ways in JavaScript. We will be discussing
    two of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: Object literal notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object literal notation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As we have read earlier, object literals are a list of `name:value` pairs separated
    by commas enclosed inside curly braces `{}`. Names can be identifiers or strings
    followed by a colon. Make sure there is no comma after the last `name:value` pair;
    otherwise, it may result in some unexpected errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We do not have to instantiate object literals with the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Care should be taken to see that the keyword `new` is not used at the start
    of the statement. This is because the opening curly bracket could be interpreted
    as the start of a code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add new members from the outside object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using modules can help in hiding data members (encapsulation) and managing code
    in an organized way.
  prefs: []
  type: TYPE_NORMAL
- en: The module pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In conventional software engineering, the module pattern provides public and
    private access to classes, methods, and variables. The focus of the module pattern
    is to reduce the use of global variables, minimizing the conflicts inside the
    code throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most famous and commonly used design pattern that is implemented
    in large JavaScript frameworks and extension libraries such as **jQuery**, **ExtJS**,
    **YUI**, and **DoJo**.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of the module pattern that makes use of a shared private
    cache. This method enables us to create objects using shared storage that will,
    in return, optimize performance because the functions are only created one time
    in the start. The mixin uses the function reference to call them rather than creating
    a new instance of that function every time it needs them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the module pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern has a cleaner approach for developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is less global namespace cluttering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This supports localized functions and variables with closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: As the public and private members are accessed in a different manner, when there
    is a need to change visibility of a specific member we would have to change it
    everywhere the object was being used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private members cannot be accessed from new methods that are added to objects
    afterwards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private members cannot be extended easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The revealing module pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern is almost identical to the module pattern. The only difference
    is that, in this pattern, all members are kept private until they are explicitly
    called, usually by an object literal returned by the closure from which it is
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Christian Heilmann engineered this pattern. He disliked the fact that we had
    to switch to object literal notation for the objects that we want to keep public.
    There was another drawback: we had to repeat the name of main object if we had
    to access public variables from one method into an other or call public methods.'
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, we define all functions and variables as private and, at the
    end of module, return an anonymous object along with the pointers to the private
    functions and variables we would like to expose as public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the revealing module pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaner approach for developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less global namespace cluttering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localized functions and variables with closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More consist script syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit definition of public functions and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Private members are inaccessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to patch public functions and variables that are referred to
    by some private members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern ensures that only one instance of a class is created and provides
    a global access point to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The singleton pattern is implemented by creating a class with a method whose
    object can only be created if it doesn't exist already. If the object already
    existed, the reference will be returned to that object.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to delay the initialization of singletons in cases where they
    require some information that might not be available at the time of initialization.
    Hence, they are different from static classes or objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimized memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single global point of access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delayed initialization, which prevents instantiation until it is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no reset option once it is instantiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing is difficult because when we reference a singleton class that exists
    outside of the class under test, then we do not have a true unit test. Instead
    of what should have been a single unit test of the target class, we end up testing
    the target class and the singleton together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may introduce hidden dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The observer pattern is such that if one object changes state all others are
    notified and can update automatically. Thus this pattern defines a one-to-many
    dependency relationship between objects.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the observer pattern, an object (also called a subject/publisher) is connected
    to multiple other objects that are dependent on our subject. These depending objects
    are called **observers**/**subscribers**.
  prefs: []
  type: TYPE_NORMAL
- en: The subject broadcasts a notification whenever a change in state occurs. All
    observers receive the notification and update them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The book, *Design Patterns: Elements of Reusable Object-Oriented Software*,
    describes the observer pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"One or more observers are interested in the state of a subject and register
    their interest with the subject by attaching themselves. When something changes
    in our subject that the observer may be interested in, a notify message is sent
    which calls the update method in each observer. When the observer is no longer
    interested in the subject''s state, they can simply detach themselves."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Requires a deeper understanding of various components in the system and their
    relationship with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps in pointing out dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps in disintegrating objects into smaller reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Application integrity check can become difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching an observer from one subject to another can be tough
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mediator pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, a mediator is a person who assists in negotiations between
    two or more conflicting parties.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of software engineering, mediator comes under the behavioral design
    pattern category. The pattern enables us to implement a single object through
    which different components of an application communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The mediator pattern promotes loose coupling by ensuring that, instead of objects
    interacting with each other directly, they communicate across a central point.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a real-world example to understand it in a better way. Consider an
    airport traffic-control system. The control tower acts as a mediator, while all
    other planes are communicating with the control tower and waiting for the notifications
    to land or to take off. They do not contact each other but just with the control
    tower. The role of the control tower is very essential and central. Hence, it
    an important key for this system.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the mediator is as important in this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When we call mediator's subscribe method, we pass in a callback, and the mediator
    queues up these callbacks for when the given event is fired and subsequently the
    decoupled object's callback is fired. Mediator triggers the signal for the object
    to fire, allowing the object to be decoupled from any others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the mediator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Removes many-to-many relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishes many-to-one relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help us to figure out dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps in disintegrating objects to promote smaller reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduces a single point of failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance issues may arise when too many modules try to communicate back and
    forth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the prototype pattern, objects are created on the template of the existing
    object through cloning.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This pattern focuses on creating an object that can be used as a template/blueprint
    for other objects through prototypal inheritance. JavaScript has native support
    for prototypal inheritance. Therefore, it's easy to work in this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the prototype pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Suitable for applications where object creation is in focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better performance as new objects inherit features from the prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Overkill for an application that has very few objects or prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this pattern, commands are encapsulated as objects.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Command objects allow loosely coupled systems to separate objects that issue
    requests from the objects that process requests. These requests are known as **events**
    and the code that processes these requests is called an event handler.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler words, we can say that the main purpose of the command pattern is
    separating the features of giving out commands from executing commands and delegating
    this feature to a different object. Practically, command objects bind an action
    to the object that will invoke the action. They always include a function such
    as `run()` or `execute()`. One of the biggest advantages of this pattern is that
    command objects with the same interface can be easily interchanged whenever needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern makes it easier to construct general components that have
    to execute/delegate/sequence method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command objects with same interface can be interchanged whenever needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows bookkeeping about command executions, without interference from the
    client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: It significantly increases the number of classes for each command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is useful while creating structures where generation and execution of requests
    do not depend on each other. We can say that a command instance can be instantiated
    by the client and run later by the **invoker**. The client and invoker may not
    know anything about each other.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is scalable as we can add new commands without changing any existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A façade is a front layer that is presented to and is visible to the world.
    Behind it lies all the complexity and unpresentable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The façade pattern is a structural pattern that enables us to hide the backend
    complexities under an interface. This pattern increases usability of the application
    modules. Internal features and methods are not exposed directly to developers,
    but they can interact with them through this façade. This pattern makes your application
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery is an example of a JavaScript library that uses the façade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we use jQuery's `$(this).animate()` or `$(this).css()` function, we
    are using a façade. Similarly, `$(document).ready()` implements a façade.
  prefs: []
  type: TYPE_NORMAL
- en: The core jQuery attributes should be considered intermediate abstractions. The
    more immediate burden to developers is the DOM API and facades are what make the
    jQuery library so easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: The `ready()` function has lots of complexities at the backend. jQuery simplifies
    browser inconsistency to ensure that `ready()` is invoked at the appropriate time.
  prefs: []
  type: TYPE_NORMAL
- en: However, we only see a façade or a simple interface layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the facade pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Improves a web application's security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatible with other patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to patch internal modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a simpler public interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being used in other JavaScript frameworks, such as jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: No proven disadvantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like other creational design patterns, the factory pattern also focuses
    on object creation. However, it differs in the way that it does not require a
    constructor method to create objects.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The factory pattern provides an interface for object creation where we specify
    the type of factory object we need to create. Subclasses are allowed to decide
    which class will be instantiated so that they can specify which type of factory
    object will be created. Factory pattern is very extensible. Factory methods are
    used when collection of objects are being maintained. These collection of objects
    are different but still have many common methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, we do not use the `new` keyword to create an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a real-time example that will clarify this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose there is a garment factory. We need to create a type of garment. Instead
    of creating this object directly using the `new` keyword, we will request a factory
    object for a new garment. We tell the factory which type of object is needed (a
    shirt, jeans, coat, a scarf, and so on). It instantiates that class and returns
    the object for our further usage.
  prefs: []
  type: TYPE_NORMAL
- en: ExtJS is a JavaScript library that uses this pattern. Methods for creating objects
    can be categorized and further sub classed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the factory pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Object creation is much easier through an interface class, which does the process
    for us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good for creating objects based on different scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical for similar instantiating objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects through one instance is simplified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Difficult to test object-creation process as it's hidden behind factory methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mixin pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In OOP, mixins are classes that can be inherited by a subclass or a group of
    subclasses for functionality reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Subclassing means to inherit properties for our new object from a super or base
    class object.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, there is an `apple` class that is able to extend from another
    class, `fruit`. Here, `fruit` is a superclass, while `apple` is a subclass of
    `fruit`. All objects of `apple` inherit properties from `fruit`. However, `apple`
    is able to define its own methods and override those defined by `fruit`.
  prefs: []
  type: TYPE_NORMAL
- en: If `apple` needs to call an overridden method in `fruit`, it's called method
    chaining.
  prefs: []
  type: TYPE_NORMAL
- en: If `apple` needs to call `fruit's` constructor, it's called **constructor chaining**.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins let other objects inherit their functionality with a very minimal level
    of complexity. This pattern allows us to share functionalities from many mixins
    through multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few advantages and disadvantages of the mixin pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern helps in decreasing function duplication and promotes reuse of
    functions. In applications where functionality is shared across the system, we
    can put the shared functions in mixins and focus on the rest of the distinct functionality
    in our system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping functionality in the object prototype may result in prototype pollution
    and may confuse tracking the origin of our functions. This may cause problems
    in large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Property getter and setter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In programming languages, getting and setting properties are used to `get` and
    `set` the values of an object. The `g` `etter` method is used to get values of
    properties and the `setter` method is used to set values of properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two property accessors in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: getter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: setter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getter` and `setter` are methods that help us access and manipulate the
    data within an object very easily. They can help us build shortcuts to access
    concealed information. The `getter` and `setter` methods work in such a way that
    they bind objects with a function so that they look like normal object properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getter`: This method is a special kind of property accessor. When you want
    to access a property, the value is generated dynamically. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setter`: This method is used to set properties. It passes a value as an argument
    and the returned value of the function is set to the property. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deleting properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like we can add properties to objects, JavaScript allows us to remove object
    properties as well.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `delete` operator is used to delete a property of an object. It deletes
    properties from the local version. The scope of a property can be reassigned to
    another variable on the same scope. In JavaScript, the `delete` operator always
    returns a Boolean value. Using this keyword, you cannot delete objects declared
    with the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have an object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We wish to remove the `age` property so that we can have a final object that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use this command to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Testing properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the common tests performed by developers on an object is to check whether
    an object has a specific property or not. There are different ways to check whether
    an object has a given property.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, there are two methods for property testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hasOwnProperty`: This method is used to check whether an object has its own
    property or not. If the property is inherited from anywhere, then it will return
    `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`propertyIsEnumerable`: This method returns `true`, only if `hasOwnProperty`
    returns `true` and that property is enumerable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check properties in JavaScript, we can use the `in` keyword. If an object
    property has its own value, it will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, enumeration of an object's properties is done using the `for-in`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, enumerating properties are used in the `for-in` loop as this
    loop accesses all properties of an object. When we want to check the list of properties
    of an object, then we use the `for-in` loop to iterate properties. It assigns
    the name of the property to the loop variable.
  prefs: []
  type: TYPE_NORMAL
- en: Inherited objects are not enumerable, but properties that you add with these
    objects are enumerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Property attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The information associated with every JavaScript property is called an **attribute**.
    Different types of property attributes are explained here.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of JavaScript properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Data property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AccessorProperty (`getter` and `setter` properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are four attributes that a property has:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enumerable**: This checks whether the property is in a loop construct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurable**: This checks whether we can delete or modify a property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writable**: This checks whether we can set the value of a property or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value**: This is a value of property and it can be of any data type in JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data property has all of the preceding attributes, while the accessor property
    does not have a value or writable attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Object attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three types of object properties in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Named data properties**: These are normal object properties in which an object
    maps string name a to a value. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Named accessor properties**: Functions that are used to get and set properties
    are known as **named accessor** **properties**. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s another example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Internal properties**: Some properties that are not accessible via language
    are called **internal** **properties** in JavaScript. These properties are purely
    for specification purposes. These properties have special names and are written
    inside square brackets. All objects have an internal property known as `[[Prototype]]`.
    The value of this property is either null or an object, which is used for implementing
    inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has two parts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Prototype**: This tells the prototype of an object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: This tells us whether we can or cannot add properties to an
    object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serializing an object means converting an object into bytes so that it can be
    stored in memory persistently, or it can be sent across the network. These bytes
    can then be deserialized into the original object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Serialization is used to store or preserve the internal state of an object.
    In serialization, an object can be transported or retrieved later. There are two
    methods of serialization in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON.stringify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.parse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These methods can also retrieve and store objects, `arrays`, `strings`, `true`
    and `false`. Enumerable values are preserved or restored by the `JSON.stringify()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Objects methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object methods are functions that are stored as object properties. These methods
    can be performed by calling them directly following a variable for which the function
    is to be called and a . (dot).
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every object has methods, which are basically actions performed on it. A method
    is a property of an object.
  prefs: []
  type: TYPE_NORMAL
- en: The `toLowerCase()`, `toUpperCase()`, `substr()`, `trim()`, `charAt()`, and
    `indexOf()` methods are some of the examples of native (part of the core language)
    methods of a string object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using the `toUpperCase()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Functions and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function is a part of code that does a particular operation that is written
    by the user and called by name independently. A function may be passed some data
    and it may also return some data. On the other hand, you can think of methods
    as defined properties of objects that can be called with reference from the object
    of the class only. Objects that are associated with methods are basically window
    objects. The syntax of defining a method and a function is different in JavaScript.
    Methods are only used to define window objects. The way of defining a method is
    different than defining a function in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The four different ways of invoking a function are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a function as a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking a function as a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking a function as a constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking a function with a function method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these methods were discussed in detail in the previous chapter. There is
    a different way of initializing the `this` keyword. When you call a function,
    it starts a function. However, when you invoke a function, it executes it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you define a function, your script will not execute, but when you invoke
    a function, the script will execute. A JavaScript function performs a particular
    task. When any object calls this function, it starts working. To define a function
    in JavaScript, we use the `function` keyword. A function can have multiple parameters
    depending on the task. You can find more detail for this in [Chapter 8](ch08.html
    "Chapter 8. JavaScript Implementations, Syntax Basics, and Variable Types"), *JavaScript
    Implementations, Syntax Basics, and Variable Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, a function can have number of arguments. A function may be called
    with a number of arguments. If you do not provide any argument in a function,
    then it will become undefined. Arguments are optional in a JavaScript function.
    If you do not pass any argument in a function, then it will set it to default.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we passed two arguments in the function: arguments `x` and
    `y`. When the first function `arg(2)` is called, then `a=2` and `b` will be undefined.
    When the second function is called, `a=2` and `b=1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters and return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know we can pass arguments in a function. A function returns a value to
    perform a different operation in your script. There are two ways to pass a value
    into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pass by value**: When we pass any variable (of primitive data types) as an
    argument in the function, we pass it by value. For example, first, the value is
    `2`. After passing, it is `3`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Pass by reference**: When you pass a value to an object, it is passed by
    reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Functions as namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Namespace is a set of logical identifiers grouped together. JavaScript does
    not provide a namespace facility by default. So, for creating namespaces in JavaScript,
    we declare a global object and make all functions and properties into that global
    object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write better code, we use closures in JavaScript. Better code means code
    that is creative and expressive. In JavaScript, you encounter closures repeatedly,
    whether you are a good JavaScript programmer or not. Depending on how you use
    closures in your code, it could be complex or easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, closures are the inner functions of JavaScript used to access the
    outer function''s scope. There are three scopes of a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: Access of outer function variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to its own scope variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to its global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inner functions also have access to outer function variables and parameters.
    In its own scope, variables are defined in curly brackets. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Function properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define a function in JavaScript, we use the `function` variable. This function
    can be called anywhere in your script. It could also be a function constructor.
    The attributes and their descriptions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments`: This is an array passed to a function as an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`argument.length`: This tells us the number of arguments in a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constructor`: This is used to create an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: This defines the number on an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prototype`: This allows a function to add object properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arguments.callee`: This tells us which function is executing currently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actions performed on objects are known as **methods** in JavaScript. They contain
    function definitions. They are stored as object properties in a script. For example,
    you can create a method like this in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `FullName` is both a property (`Student.FullName`) and a method (`Student.FullName()`).
    When you access object properties without brackets, this will return a function
    definition. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Function constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function constructor is used to define a function dynamically. A new operator
    is use to define a function with the constructor method. You can also pass as
    many arguments you want to use in your script to a constructor. The last argument
    will be the body of the function. It can also contain statements separated by
    commas. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We cannot pass the same function name in a constructor as an argument, as it
    will create an error in the script. It can also create an unnamed function, known
    as an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, we do not have any native approach to creating classes, but we
    can create a class using prototype inheritance and a constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are containers for objects. We use classes to encapsulate a namespace
    and logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instantiate a class, we can use the `new` keyword. Classes are similar to
    constructor functions. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules are used to include and extend classes and properties easily. Modules
    attach properties to global objects to export module values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes and their modules are extremely important and vital aspects of JavaScript.
    We will be covering the following topics in the subsequent sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java-style classes in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmented JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes in ECMA5 script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, a class is an object with special types of properties and methods.
    It is used to create instances and define the behavior of instances. Instances'
    behavior changes dynamically and we have a special syntax to write it in JavaScript.
    Instances are created when special methods are invoked on a class.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes and functions are two different things in JavaScript. A constructor
    can be any function, but a prototype is a special kind of object. To define a
    behavior of any instance, we use a prototype. There are no special properties
    or methods a prototype has. When we modify a prototype, we have instances.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler words, we can say that in JavaScript, a constructor can be any function
    that is responsible for creating an instance. On the other hand, a prototype can
    be any object that has no special methods or properties. Prototypes are responsible
    for an instance's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, the prototype and constructor functions act like a class, because
    a class has a constructor, and to define methods, you have a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are no special properties or objects associated with a prototype. An object
    in your script can be an empty project or a prototype. When we say that any object
    can be a prototype, then this object will have functions and data types. Prototypes
    are not special kinds of objects, but classes are special kinds of objects in
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class contains a set of objects, and for initialization of the objects, we
    use constructors. In a class, we can create objects using the `new` operator.
    We can define a class as a subclass to construct objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a single property of prototype, a constructor is created. If we overwrite
    the prototype property, the reference to the constructor might be lost. In JavaScript,
    we use the `constructor` property to create a class from an object that is passed
    as an object. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Defining a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three ways of defining a class in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A singleton using a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create an object using the `new` keyword in a function. To access methods
    and properties, use the `this` keyword. There would be a conflict if you define
    a function with the same name in a class.
  prefs: []
  type: TYPE_NORMAL
- en: Using object literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To define an object or array in JavaScript, we use literals. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Classes in the ECMA5 script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For specific objects'' properties, the ECMA5 script added five methods. These
    methods are used to secure and restrict the extensibility of objects in the script.
    These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we define a class in JavaScript, these methods are very useful. When you
    store an object, it sets an object ID for these methods. When we use a looping
    statement, it will return this object ID. All objects inherit the object ID, which
    is enumerable. To read a property, it will invoke the `getter` function, and there
    will be no `setter` function. So, it will be read-only. We cannot modify it, so
    it cannot be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two very important aspects of modules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**They have dependencies**: This means that when you write a module in your
    system, it is fully dependent on the function. We import dependencies from functions
    while creating our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**They have exports**: If you leave some function and variable public in your
    system, anything can export these. For example, you have exported a function `$function`,
    module that depends on this function will also have access to this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A module can export a number of multiple variables and functions. To export
    these functions and variables, we use the `export` keyword. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also store a variable after exporting it. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript supports prototype inheritance. In other programming languages,
    objects and classes inherit from each other to use each other''s properties and
    functions. However, in JavaScript, you have an object-based inheritance, which
    is called a prototype, in which objects use the properties of other objects. For
    example, if you have a `Person` object, then you can use the `_proto_` attribute
    for that object to create another `Student` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](img/Image1544.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prototype chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, you create new objects from existing objects. This process is
    called **prototype chaining**. It is similar to inheritance in object-oriented
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prototype is a property of the `constructor` function. When you add any object
    property to a prototype, it will add this property or method to the objects created
    by the constructor function. In prototype chaining, we create a function prototype
    using the properties of the `constructor` function. Using this, all methods or
    properties transfer to the `prototype` object from the `constructor` function.
    This method is very easy and useful for creating the `constructor` function to
    create objects. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In method resolution, first JavaScript checks objects for methods. When you
    use prototype chaining, it can override methods for prototypes of an object. So,
    the JavaScript construction function sets methods for objects.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor stealing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, constructor stealing is also called **classical inheritance**.
    This method is use to inherit problems of prototype reference values.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In constructor stealing, we call a super constructor in a subtype constructor.
    This idea is quite simple and easy. We use the `call()` and `apply()` methods
    for function calling. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `call()` method to call a super constructor for
    a newly created subclass instead of a subconstructor. This will initialize all
    objects in the `super()` function on `sub()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we use prototype chaining, the `constructor` function will allow us to
    pass arguments from a super constructor to within the subconstructor.
  prefs: []
  type: TYPE_NORMAL
- en: Combination inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combination inheritance is also called **pseudo-classical inheritance**. This
    is a combination of constructor stealing and prototype chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In combination inheritance, prototype chaining inherits properties and methods
    from a prototype, and constructor stealing inherits instances. In this way, we
    can reuse methods on prototypes by allowing methods to have their own properties.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `SuperType` constructor defines two properties: `name`
    and `colors`. The `SuperType` prototype has a single method called `sayName()`.
    The `SubType` constructor calls the `SuperType` constructor, passing in the `name`
    argument, and defines its own property called `age`. Additionally, the `SubType`
    prototype is assigned to be an instance of `SuperType`, and then, a new method
    called `sayAge()` is defined. With this code, it''s then possible to create two
    separate instances of `SubType` that have their own properties, including the
    `colors` property, but all use the same methods. Addressing the downsides of both
    prototype chaining and constructor stealing, combination inheritance is the most
    frequently used inheritance pattern in JavaScript. It also preserves the behavior
    of `instanceof` and `isPrototypeOf()` to identify the composition of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Prototypal inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In prototypal inheritance, we use an object as a base for another object.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In prototypal inheritance, there are no classes, only objects. To create an
    object, you can either create a totally new object or you can clone an existing
    object. New objects can be then extended with new properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding object has no prototype and is a clone of `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `rect` inherits the `area` function from `rectangle`.
    Here, rectangle is an object literal, an object literal is a way to create a clone
    of `Object.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend the newly created object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a `constructor` function that will clone `rectangle` for us and
    will extend it with the `height` and `width` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Parasitic inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parasitic inheritance is similar to prototypal inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It simply works by creating a function that performs inheritance, object augmentation,
    and finally, it returns the object after completing each task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, in this example, we have the `abc()` function that has one argument, which
    is an object based on a new object. This object is passed to the `object` function
    and saves the resulting object into a `clone` variable. Now, the `clone` object
    will have a new object property, and at the end, we return the object.
  prefs: []
  type: TYPE_NORMAL
- en: Parasitic combination inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A parasite is defined as an organism that lives inside another organism and
    relies on its resources. Similarly, in this inheritance, a child object relies
    on a parent object and extends its properties from it.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first constructor calls the subtype `prototype` and then it calls the subtype
    `constructor`. This is a very efficient way of creating new objects in JavaScript.
    At the end, the subtype will have all the properties of the super type. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between parasitic combination inheritance and combination
    inheritance is that, in the former one, the base constructor is called once, and
    in the latter one, the base constructor is called twice.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In every programming language, every subclass has a super class that inherits
    its properties and methods from. JavaScript is not a pure class-based programming
    language, but it follows some of the rules of OOP. We make classes in JavaScript
    using object notations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, you can only perform inheritance using the `constructor` function
    or prototype. This inheritance is only done at run time, which means dynamically.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the preceding code execute following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Built-in objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add flexibility in language, JavaScript supports a number of built-in objects.
    The most commonly used objects are:'
  prefs: []
  type: TYPE_NORMAL
- en: Global
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RegExp (Regular Expression)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementations of these built-in objects are complex and different.
  prefs: []
  type: TYPE_NORMAL
- en: Global objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Global objects are objects defined outside the function. Every function can
    access these variables because their scope is global for all.
  prefs: []
  type: TYPE_NORMAL
- en: When you do not declare a variable and assign a value to it, then it will automatically
    become global.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When your code starts execution, functions and constants immediately become
    available. A global variable does not initialize with the `new` keyword. Basically,
    global objects are used to share same data to add properties. You can store methods
    within global objects in your script.
  prefs: []
  type: TYPE_NORMAL
- en: Objects that you cannot access directly for accessing those object we use global
    objects. We pass those object directly as arguments after declaring the global
    variable. You can create a number of instances and a number of global objects
    in your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'A global object has a fixed number of properties. Multiple object instances
    can access this global object. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Date object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Date objects in JavaScript deal with date and time objects. For example, if
    we are writing a script and we need some functionality of date and time, then
    we can use this built-in object simply.
  prefs: []
  type: TYPE_NORMAL
- en: getTime()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current time with respect to the number of
    milliseconds since January 1, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The number of milliseconds since January 1, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name states, this function is used to obtain the current time, in the
    form of milliseconds. We need to create a date object first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: getMilliseconds()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current time with respect to the number of
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number from 0-999.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name states, this function is used to obtain the current time, in the
    form of milliseconds. We need to create a date object first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: getMinutes()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current time with respect to the number of
    minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number from 0-59.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function is used to obtain the current time, in the form of minutes. We
    need to create a date object first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: getHours()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current time with respect to the number of
    hours.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number from 0-23 with 0 being midnight.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function is used to obtain the current time, in the form of hours. We need
    to create a date object first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: getDate()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current day.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number from 1-31.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function is used to obtain the current day. We need to create a date object
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: getDay()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current day in the week.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number from 0-6 with 0 being Sunday.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function is used to obtain the current day in the week. We need to create
    a date object first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: getMonth()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current month.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number from 0-11.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function is used to obtain the current month in the year. We need to create
    a date object first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: getFullYear()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to get the current year.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters passed.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The year in the YYYY format.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function is used to obtain the current year. We need to create a date object
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Set date methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Methods are available in date objects to manipulate dates. We can also adjust
    the date dynamically. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set upcoming dates and the current date by using this function,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The date set methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setTime()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setMilliseconds()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setMinutes()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setMinutes()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setHours()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setDate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setDay()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setMonth()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFullYear()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods are very similar to the date get methods described in the preceding
    term list.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compare dates using the date object.
  prefs: []
  type: TYPE_NORMAL
- en: Math object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, the math object is used to perform mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This object has several mathematical functions. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Math.E`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.PI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.sqrt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.Ln2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Math.ln10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `math` object has different methods. For example, we have the `pow` method
    that calculates the power of the first variable times the second.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: min()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to find out the the argument with the minimum value.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The values to be evaluated are passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The argument with the minimum value.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name suggests, this function is simply used to obtain the minimum value
    among all values in an argument
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: max()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to find the argument with the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The values to be evaluated are passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The argument with the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name suggests, this function is simply used to obtain the maximum value
    among all values in an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: random()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to generate a random number between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A random number between 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `random()` function is useful in generating random numbers. The value of
    the number will always lie between 0 and 1 (never exactly 1). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: round()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to round the number to its nearest integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The values to be evaluated are passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The rounded number.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to create integer values after rounding them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: ceil()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to round a number up to the nearest and highest possible
    integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The values to be evaluated are passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The highest rounded number.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to create integer values after rounding them to the higher
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: floor()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function is used to round a number down to the nearest and lowest possible
    integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The values to be evaluated are passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The lowest rounded number.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to create integer values after rounding them to the lower
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The RegExp object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, for pattern matches in string, we use a regular expression. It
    is a very powerful and useful tool for expression pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pattern**: The text/pattern of the regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: If specified, flags can have any combination of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: Global match'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: Ignore case'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: Multiline; treat beginning and end characters (`^` and `$`) as working
    over multiple lines (that is, match the beginning or end of each line (delimited
    by `\n` or `\r`), not only the very beginning or end of the whole input string)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The return type of different regular expressions is different.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using a regular expression, you can make a complex task simple by writing few
    lines of codes. There are five methods in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegExp.exec(pattern)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp.replace(pattern)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp.split(pattern)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp.match(pattern)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a regular expression
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two ways of writing a regular expression in JavaScript. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: RegExp constructor method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are differences between the `RegExp` object and global object. They look
    the same but act differently.
  prefs: []
  type: TYPE_NORMAL
- en: RegExp constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method is used to dynamically construct a string search pattern. A regular
    expression in this method should be written in quotation marks. This method has
    three parameters. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: E-mail is a required parameter to which regular expression values are assigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d` is a pattern parameter used to match regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g` is global, which is a flag parameter. In this function, there are four
    types of parameters (`g`, `I`, `m` ,`u`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal syntax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In literal notation, we write a regular expression without brackets. Here,
    `i` is a flag that shows to ignore case of the text whether it is uppercase, lowercase
    or any other. We have more flag objects such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`g`: Global object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: Ignore case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: Multi search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: Unicode search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In regular expressions, we can have a global regular expression object, which
    will have information for each match case. A simple regular expression object
    has information about a particular regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: String object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are four string methods for pattern matching. In these objects, a pattern
    is sent with a parameter. These methods allow you to search, match, replace, and
    split patterns.
  prefs: []
  type: TYPE_NORMAL
- en: These methods are represented as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Match(pattern)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to find a matching pattern within a string. Using the `not`
    (`!`) operator it can also be used to find non-matches.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `string.Match(Expression)`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The string pattern that is to be matched.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It returns the result if a match is found or `0` or `null` if no match is found.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This runs a search for matching strings in a regular expression. If the search
    is matched or successful then it will return an array of matching results, if
    not then it will return `null` or `0`. It is also used to update properties in
    a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Replace(pattern)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to replace a part of the string.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `string.replace(stringSearched, stringReplacement)`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The string pattern that is to be replaced is passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The string with the replaced value.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This executes a search and is used for replacement of regular expression match
    resulted with alternative text. This is also used for replacement of regular expressions
    with specific and different `regExp` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember here that the search is case sensitive, so if you provide the value
    `parsestring1=str1.replace("piE", "Cinnamon Roll");` then no replacement is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, only the first occurrence of the pattern is replaced. Hence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`, `Banana Pie`, `Strawberry
    PIE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a global search and replacement so that all occurrences are replaced
    we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`, `Banana Cinnamon
    Roll`, `Strawberry PIE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a global insensitive search, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`, `Banana Cinnamon
    Roll`, `Strawberry Cinnamon Roll`.
  prefs: []
  type: TYPE_NORMAL
- en: Split(pattern)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is use to split a string in a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `string.split(separator,limit)`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A separator and limit are provided as optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The split string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With this method the string is split. Every word in the string is treated as
    a single element in an array. If a null string is passed as a parameter, the method
    causes each letter to be split into different characters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `parseString` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Providing a limit will return a comma separated array of the words containing
    only the specified number of elements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The value of `parseString` is `My,Car,is`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a letter or letters as a separator will give the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `parseString` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `parseString` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: search(pattern)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to search for a particular string.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `string.search(stringSearched)`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The string pattern that is to be searched is passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It returns the position of the starting letter of the string if a match is found.
    If no match is found then it returns `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is used to find a match in a string. If a match is found it will send an
    index of that match otherwise, if a match is not found, it will return `-1`. Global
    flags are not supported by this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The value of `parseString` here is `18`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are additional string methods available to perform other tasks on strings.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed list of these methods can be found at [https://msdn.microsoft.com/en-us/library/ecczf11c(v=vs.94).aspx](https://msdn.microsoft.com/en-us/library/ecczf11c(v=vs.94).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Array objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is a collection of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an array in JavaScript, the elements of the collection are enclosed
    within square brackets and separated by commas, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'An array can also be initialized using the `new` keyword or by specifying their
    length between 0 and 232-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'To access array elements, we can use an index notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Always remember that array elements always start with the zero index. Hence,
    the third element in the preceding array has the index of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Array objects can hold all sorts of data, for example, strings, numbers, literals,
    dates, and even user-defined objects.
  prefs: []
  type: TYPE_NORMAL
- en: .Pop()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to *pop* an element out of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters for this method.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It returns the *popped* element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here an array is considered as a stack and the elements that are last in the
    array are popped out first. This follows the LIFO principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The value of the element here is `Black Forest`.
  prefs: []
  type: TYPE_NORMAL
- en: .Push()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to *push* an element into an array.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters for this method.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It returns the new length of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here an array is considered as a stack and the elements that are pushed appear
    at the end of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The value of the element here is `6`.
  prefs: []
  type: TYPE_NORMAL
- en: .ToString()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This converts the elements in an array into a string. The elements appear as
    comma-separated strings.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns a string containing the elements of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `ToString()` function is used to convert an array into a string. The elements
    of the array appear in the string and are separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `StrSweets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: .ValueOf()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is also used to convert an array into a string.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns a string containing the elements of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is default behaviour of the array and works same as the `ToString()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `StrSweets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: .Join()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to convert an array into a string. The elements are separated
    by the delimiter specified.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A separator to separate the elements in the new string.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This returns a string containing the elements of the array separated by the
    delimiter specified.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Join()` function is used to convert an array into a string. The elements
    of the array appear in the string and are separated by the delimter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `StrSweets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: .Splice()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Splice, as the name suggests, is used to add new elements into the array. Unlike
    the `push()` method we can add elements in whichever position we want.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following are the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of elements to be removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements to be added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The array as a string along with the new elements, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is used to remove and add elements in one step. We can specify where
    the new element is to be added and which elements are to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `StrSweets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: .sort()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to sort an array into alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sorted array is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sort method is used to sort an array, alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `StrSweets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: .reverse()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests it reverses the order of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The reversed array is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The reverse method is used to sort an array, alphabetically, in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `StrSweets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: .slice()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, this method is used to slice up an array and create a
    new array using a part of the original array.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The index at which we want the array sliced. The index of an array begins at
    `0`. So the first element has index `0`, the second element has index `1`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sliced array containing the remaining elements is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The slice method is used to slice up an array and get the remainder of the array
    as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `StrSweets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: .concat()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is used to concatenate two or more arrays into a single array.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The array to be concated is passed as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Returns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method returns the concated array.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Concat()` method is used to create a single array by joining two or more
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the value of `CoolShades` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
