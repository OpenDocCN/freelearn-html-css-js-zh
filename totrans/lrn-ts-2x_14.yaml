- en: Application Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序测试
- en: In [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating Your
    Development Workflow*, we learned how to write unit tests and generate a test
    coverage report. However, application testing is a very extensive subject, and
    we barely touched its surface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章，*自动化你的开发工作流程*中，我们学习了如何编写单元测试和生成测试覆盖率报告。然而，应用程序测试是一个非常广泛的主题，我们只是触及了其表面。
- en: 'In this chapter, we are going to learn how to write multiple kinds of automated
    tests for a TypeScript application. We are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何为TypeScript应用程序编写多种类型的自动化测试。我们将涵盖以下主题：
- en: Testing terminology
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试术语
- en: Testing planning and methodologies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试规划和方法论
- en: Writing unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Isolating components during tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试期间隔离组件
- en: Writing integration tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: Writing end-to-end (e2e) tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写端到端（e2e）测试
- en: We are going to get started by learning about the core terminology used in the
    field of software testing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习软件测试领域核心术语开始。
- en: Testing terminology
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试术语
- en: Throughout this chapter, we are going to use some concepts that may not be familiar
    to readers without previous experience in the field of software testing. For this
    reason, we are going to take a quick look at some of the most popular concepts
    in software testing before we get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一些可能对没有软件测试领域经验读者不熟悉的概念。因此，在我们开始之前，我们将快速浏览一些软件测试中最流行的概念。
- en: Assertions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: An **assertion** is a condition that must be tested to confirm that a certain
    piece of code behaves as expected, or, in other words, to confirm conformance
    to a requirement.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**是一个必须被测试的条件，以确认某段代码的行为是否符合预期，或者换句话说，以确认符合要求。'
- en: Let's imagine that we are working as part of the Google Chrome development team,
    and we must implement the JavaScript `Math` API. If we are working on the `pow`
    method, the requirement could be something like, the `Math.pow` (base, exponent)
    function should return the base (the base number) to the exponent (the exponent
    used to raise the base) power-that is, base `^` exponent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们正在作为谷歌Chrome开发团队的一部分工作，并且我们必须实现JavaScript `Math` API。如果我们正在处理`pow`方法，需求可能如下，`Math.pow`（底数，指数）函数应该返回底数（底数数字）的指数次幂——即底数`^`指数。
- en: 'With this information, we could create the following implementation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，我们可以创建以下实现：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that we use the name `MathAPI` instead of `Math` in this example
    because the `Math` variable is already declared by the real JavaScript Math API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们使用`MathAPI`而不是`Math`，因为`Math`变量已经被真实的JavaScript Math API声明了。
- en: 'To ensure that the method is correctly implemented, we must test its accordance
    with the requirement. If we analyze the requirements closely, we should identify
    at least two necessary assertions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保方法被正确实现，我们必须测试其是否符合要求。如果我们仔细分析需求，我们应该至少识别出两个必要的断言：
- en: 'The function should return the base to the exponent:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该返回底数的指数：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The exponent is not being used as the base (or the base is not used as the
    exponent):'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数没有被用作底数（或者底数没有被用作指数）：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If both assertions are valid, then our code adheres to the requirements, and
    we know that it will work as expected.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个断言都有效，那么我们的代码符合要求，我们知道它将按预期工作。
- en: Specs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范
- en: '**Spec **is a term used by software development engineers to refer to test
    specifications. A test specification (not to be confused with a test plan) is
    a detailed list of all the scenarios that should be tested and how they should
    be tested, as well as other details.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范**是软件开发工程师用来指代测试规范的一个术语。测试规范（不要与测试计划混淆）是一个详细列出所有应该被测试的场景以及如何测试它们的清单，以及其他详细信息。'
- en: Test coverage
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: The term **test coverage** refers to a unit of measurement, which is used to
    illustrate the number of portions of code in an application that have been tested
    via an automated test. Test coverage can be obtained by automatically generating
    test coverage reports.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试覆盖率**这个术语指的是一个度量单位，用来说明应用程序中通过自动化测试测试过的代码部分的数量。可以通过自动生成测试覆盖率报告来获得测试覆盖率。'
- en: Refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn how to generate a test coverage report.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第9章，*自动化你的开发工作流程*，了解如何生成测试覆盖率报告。
- en: Test cases
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例
- en: A **test case** is a set of conditions used to determine whether one of the
    features of an application is working as it was originally intended to work. We
    might wonder what the difference between a test assertion and a test case is.
    While a test assertion is a single condition, a test case is a set of conditions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例**是一组条件，用于确定应用程序的一个功能是否按原意工作。我们可能会想知道测试断言和测试用例之间的区别是什么。虽然测试断言是一个单一条件，但测试用例是一组条件。'
- en: Suites
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套件
- en: A **suite** is a collection of test cases. While a test case should focus on
    only one test scenario, a test suite can contain test cases for many test scenarios.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**套件**是一组测试用例。虽然测试用例应该只关注一个测试场景，但测试套件可以包含多个测试场景的测试用例。'
- en: We will learn how to define assertions, test cases, and test suites later in
    this chapter, in the *Unit tests and integration tests with Mocha* section).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的“使用 Mocha 的单元测试和集成测试”部分学习如何定义断言、测试用例和测试套件。
- en: Spies
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍
- en: '**Spies** are a feature provided by some testing frameworks. They allow us
    to wrap a method or function and record its usage. We can record things such as
    the method or function arguments, their return type, or the number of times that
    they have been invoked. When we wrap a method or function with a spy, the underlying
    method''s functionality does not change.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**间谍**是某些测试框架提供的一个功能。它们允许我们包装一个方法或函数并记录其使用情况。我们可以记录诸如方法或函数的参数、它们的返回类型或它们被调用的次数等信息。当我们用间谍包装一个方法或函数时，底层方法的功能不会改变。'
- en: Dummies
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 占位符
- en: A **dummy** object is an object that is passed around during the execution of
    a test, but it is never actually used.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**占位符**对象是在测试执行过程中传递的对象，但它实际上从未被使用。'
- en: Stubs
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟器
- en: A **stub** is a feature provided by some testing frameworks. Like spies, stubs
    also allow us to wrap a method or function to record its usage. Unlike in the
    case of spies, when we wrap a function with a stub, the underlying method's functionality
    is replaced with new behavior.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟器**是某些测试框架提供的一个功能。与间谍类似，模拟器也允许我们包装一个方法或函数来记录其使用情况。与间谍的情况不同，当我们用模拟器包装一个函数时，底层方法的功能被替换为新的行为。'
- en: Mocks
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟器
- en: 'Mocks are often confused with stubs. Martin Fowler once wrote the following
    in an article titled *Mocks Aren''t Stubs*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器经常与模拟器混淆。马丁·福勒曾在题为《模拟器不是占位符》的文章中写道：
- en: '"In particular, I see them (mocks) often confused with stubs - a common helper
    to testing environments. I understand this confusion - I saw them as similar for
    a while too, but conversations with the mock developers have steadily allowed
    a little mock understanding to penetrate my tortoiseshell cranium. This difference
    is actually two separate differences. On the one hand, there is a difference in
    how test results are verified: a distinction between state verification and behavior
    verification. On the other hand, is a whole different philosophy to the way testing
    and design play together, which I term here as the classical and mockist styles
    of Test Driven Development."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “特别是，我经常看到它们（模拟器）与模拟器混淆——测试环境的一个常见辅助工具。我理解这种混淆——我一开始也认为它们很相似，但与模拟器开发者的对话逐渐让我对模拟器有了更深入的理解。这种差异实际上是两个不同的差异。一方面，测试结果验证的方式有所不同：状态验证和行为验证之间的区别。另一方面，是对测试和设计如何协同工作的一种完全不同的哲学，我将其称为经典和模拟风格测试驱动开发。”
- en: 'Both mocks and stubs provide some input to the test case, but despite their
    similarities, the flow of information from each is very different:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器和模拟器都为测试用例提供了一些输入，但尽管它们相似，每个的信息流都非常不同：
- en: Stubs provide input for the application under test so that the test can be performed
    on something else. Stubs are used to replace behavior.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟器为正在测试的应用程序提供输入，以便测试可以在其他事物上进行。模拟器用于替代行为。
- en: Mocks provide input to the test to decide whether the test should pass or fail.
    Mocks are used to declare an expectation.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟器为测试提供输入以决定测试是否应该通过或失败。模拟器用于声明期望。
- en: The difference between mocks and stubs will become clearer as we move towards
    the end of this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们接近本章的结尾，模拟器和模拟器之间的区别将变得更加清晰。
- en: Prerequisites
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: Throughout this chapter, we will be using third-party tools. In this section,
    we are going to learn how to install these. Before we get started, however, we
    need to use npm to create a `package.json` file in the folder that we are going
    to use to implement the examples in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用第三方工具。在本节中，我们将学习如何安装这些工具。然而，在我们开始之前，我们需要使用 npm 在我们将要用于实现本章示例的文件夹中创建一个
    `package.json` 文件。
- en: 'Let''s create a new folder and go inside it to generate a new `package.json`
    file using the `npm init` command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件夹，并进入它以使用 `npm init` 命令生成一个新的 `package.json` 文件：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, for additional information about npm.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[第 5 章](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)，*与依赖项一起工作*，以获取有关 npm
    的更多信息。
- en: Mocha
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocha
- en: 'Mocha is a popular JavaScript testing library that facilitates the creation
    of test suites, test cases, and test specs. Mocha can be used to test TypeScript
    in the frontend and backend, identify performance issues, and generate different
    types of test reports, among many other functions. We can install Mocha using
    the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是一个流行的 JavaScript 测试库，它简化了测试套件、测试用例和测试规范的创建。Mocha 可以用于前端和后端测试 TypeScript，识别性能问题，并生成不同类型的测试报告，以及其他许多功能。我们可以使用以下命令安装
    Mocha：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Chai
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chai
- en: 'Chai is a test-assertion library that supports **test-driven development**
    (**TDD**) and **behavior-driven development** (**BDD**) test styles. The main
    goal of Chai is to reduce the amount of work necessary to create a test assertion
    and make the test more readable. We can install Chai using the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 是一个支持**测试驱动开发**（**TDD**）和**行为驱动开发**（**BDD**）测试风格的测试断言库。Chai 的主要目标是减少创建测试断言所需的工作量，并使测试更易于阅读。我们可以使用以下命令安装
    Chai：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Please note that we are going to learn more about TDD and BDD later in this
    chapter in the section titled *Testing methodologies*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在本章的 *测试方法* 部分后面学习更多关于 TDD 和 BDD 的内容。
- en: Sinon.JS
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sinon.JS
- en: 'Sinon.JS is a library that provides us with a set of APIs that can help us
    to test a component in isolation, thanks to its usage of spies, stubs, and mocks.
    Testing software components can be very difficult when there is a high level of
    coupling between them. However, a library such as Sinon.JS can help us isolate
    the components to test their features. We can install Sinon.JS using the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 是一个库，它提供了一套 API，可以帮助我们通过使用间谍、存根和模拟来隔离测试组件。当软件组件之间存在高度耦合时，测试软件组件可能非常困难。然而，像
    Sinon.JS 这样的库可以帮助我们隔离组件以测试其功能。我们可以使用以下命令安装 Sinon.JS：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: nyc
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nyc
- en: 'As we already learned in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*, we can use nyc to generate test coverage
    reports for our applications. We can install nyc using the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 9 章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)中已经学到的，*自动化开发工作流程*，我们可以使用
    nyc 为我们的应用程序生成测试覆盖率报告。我们可以使用以下命令安装 nyc：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Webpack
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack
- en: 'As we already learned in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*, we can use nyc to generate test coverage
    reports for our applications. We can install Webpack and some additional plugins
    using the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 9 章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)中已经学到的，*自动化开发工作流程*，我们可以使用
    nyc 为我们的应用程序生成测试覆盖率报告。我们可以使用以下命令安装 Webpack 和一些额外的插件：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Enzyme
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Enzyme
- en: 'Enzyme is an open source testing library developed by Airbnb that can help
    us to test React components. We can install enzyme using the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme 是由 Airbnb 开发的开源测试库，可以帮助我们测试 React 组件。我们可以使用以下命令安装 enzyme：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: SuperTest
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SuperTest
- en: 'SuperTest is a library that can help us to test HTTP web services developed
    with Node.js and Express.js. We can install SuperTest using the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SuperTest 是一个库，可以帮助我们测试使用 Node.js 和 Express.js 开发的 HTTP 网络服务。我们可以使用以下命令安装 SuperTest：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: PM2
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PM2
- en: 'PM2 is a production process manager for Node.js applications with a built-in
    load balancer. PM2 allows us to run a Node.js application as a background process,
    which is something that we are going to need to run our e2e tests. We can install
    PM2 using the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 是一个内置负载均衡器的 Node.js 应用程序的生产进程管理器。PM2 允许我们将 Node.js 应用程序作为后台进程运行，这是我们运行端到端测试所必需的。我们可以使用以下命令安装
    PM2：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Nightwatch.js and ChromeDriver
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nightwatch.js 和 ChromeDriver
- en: 'Nightwatch.js is a library that helps us to implement **end-to-end** (**e2e**)
    tests. We also need a tool known as ChromeDriver. Nightwatch.js can run our test
    in multiple web browsers, but in our example, we are going use Google Chrome.
    The `chromedriver` library is an adapter that allows Nightwatch.js to communicate
    with Google Chrome during the test''s execution. We can install Nightwatch.js
    and ChromeDriver using the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Nightwatch.js 是一个库，帮助我们实现 **端到端**（**e2e**）测试。我们还需要一个名为 ChromeDriver 的工具。Nightwatch.js
    可以在多个网络浏览器中运行我们的测试，但在我们的例子中，我们将使用 Google Chrome。`chromedriver` 库是一个适配器，允许 Nightwatch.js
    在测试执行期间与 Google Chrome 通信。我们可以使用以下命令安装 Nightwatch.js 和 ChromeDriver：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Refer to the companion source code to check the exact versions used in the `package.json`
    file. If you use `npm install`, the latest version will be installed by default.
    The version used in these examples might become outdated over time, which could
    lead to some configuration issues. If you want to use the latest version (which
    is recommended), you will have to check the documentation of each of the modules
    to learn about potential breaking changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考配套源代码以检查 `package.json` 文件中使用的确切版本。如果你使用 `npm install`，默认将安装最新版本。这些示例中使用的版本可能会随着时间的推移而变得过时，这可能导致一些配置问题。如果你想使用最新版本（这是推荐的），你必须检查每个模块的文档，以了解潜在的重大更改。
- en: Testing methodologies
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试方法
- en: 'Every time we develop a new application, we need to make a lot of decisions.
    For example, we need to choose the type of database, architecture, libraries,
    and frameworks that we will use. However, not all our choices are about technologies,
    and we can also choose a software development methodology, such as extreme programming
    or scrum. When it comes to testing, there are two major styles or methodologies:
    TDD and BDD.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们开发一个新的应用程序时，我们都需要做出很多决定。例如，我们需要选择数据库类型、架构、库和框架。然而，我们的选择并不全是关于技术的，我们还可以选择软件开发方法，如极限编程或敏捷。当涉及到测试时，有两种主要风格或方法：TDD
    和 BDD。
- en: Test-driven development (TDD)
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）
- en: 'Test-driven development is a testing methodology that focuses on encouraging
    developers to write tests before they write application code. Usually, the process
    of writing code in TDD consists of the following basic steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）是一种测试方法，它侧重于鼓励开发者在编写应用程序代码之前编写测试。通常，TDD中编写代码的过程包括以下基本步骤：
- en: Write a test that fails. There is no application code at this point, so the
    test should fail.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个失败的测试。目前还没有应用程序代码，所以测试应该失败。
- en: Run the test and ensure that it fails.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并确保它失败。
- en: Write the code to pass the test.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以通过测试。
- en: Run the test and ensure that it works.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并确保它工作。
- en: Run all the other existing tests to ensure that no other parts of the application
    are broken because of the changes.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有其他现有测试，以确保应用程序的其他部分没有因为更改而损坏。
- en: Repeat the process for every new feature or bug fix.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个新的功能或错误修复，重复此过程。
- en: 'This process is often represented as the "red-green-refactor" diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程通常表示为“红色-绿色-重构”图：
- en: '![](img/0c6d09aa-720f-4c36-899b-80f169a96f25.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c6d09aa-720f-4c36-899b-80f169a96f25.png)'
- en: The choice between using TDD or not comes down to the mindset you wish to adopt.
    Many developers don't like writing tests, so the chances are that if we leave
    their implementation as the last task in the development process, the tests will
    never be implemented or the application will just be partially tested. It is also
    possible that the application could be implemented in a way that is harder to
    test. If we are planning to write a test, doing it upfront can lead to a reduction
    in the implementation cost.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用测试驱动开发（TDD）取决于你希望采取的心态。许多开发者不喜欢编写测试，所以如果我们将他们的实现作为开发流程中的最后一项任务，测试可能永远不会被实现，或者应用程序只是部分测试。也有可能应用程序的实现方式更难进行测试。如果我们计划编写测试，提前进行可以降低实现成本。
- en: TDD is recommended because it effectively helps you and your team to increase
    the test coverage of your applications and, therefore, significantly reduce the
    number of potential issues, which eventually ends up saving money.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用 TDD，因为它有效地帮助你和你团队增加应用程序的测试覆盖率，从而显著减少潜在问题的数量，最终节省资金。
- en: Behavior-driven development (BDD)
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发（BDD）
- en: Behavior-driven development appeared after TDD, with the mission of being a
    refined version of TDD. BDD focuses on the way tests are described (specs) and
    states that the tests should focus on the application requirements and not the
    test requirements. Ideally, this will encourage developers to think less about
    the tests themselves and think more about the entire application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 行为驱动开发是在TDD之后出现的，其使命是成为TDD的改进版。BDD关注测试的描述方式（规范），并声称测试应该关注应用程序需求而不是测试需求。理想情况下，这将鼓励开发者更多地考虑整个应用程序，而不是仅仅关注测试本身。
- en: The original article in which the BDD principles were introduced by *Dan North*
    is available at [http://dannorth.net/introducing-bdd/](http://dannorth.net/introducing-bdd/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由*丹·诺斯*引入BDD原则的原始文章可在[http://dannorth.net/introducing-bdd/](http://dannorth.net/introducing-bdd/)找到。
- en: As we have already learned, Mocha and Chai provide APIs for both the TDD and
    BDD approaches. Later in this chapter, we will further explore these two approaches.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学到的，Mocha和Chai为TDD和BDD方法都提供了API。在本章的后面部分，我们将进一步探讨这两种方法。
- en: Recommending one of these methodologies is not trivial because TDD and BDD are
    both good testing methodologies. However, BDD was developed after TDD with the
    objective of improving it, so we can argue that BDD has some additional advantages
    over TDD. In BDD, the description of a test focuses on what the application should
    do and not what the test code is testing. This can help the developers to identify
    tests that reflect the behavior desired by the customer. BDD tests can be used
    to document the requirements of a system in a way that can be understood and validated
    by both the developer and the customer. This is a clear advantage over TDD tests,
    as TDD tests cannot be understood with ease by the customer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐这些方法之一并不简单，因为TDD和BDD都是优秀的测试方法。然而，BDD是在TDD之后开发的，目的是改进它，因此我们可以认为BDD相对于TDD有一些额外的优势。在BDD中，测试的描述重点在于应用程序应该做什么，而不是测试代码在测试什么。这可以帮助开发者识别出反映客户期望行为的测试。BDD测试可以用来以可被开发者和客户理解和验证的方式记录系统的需求。这是相对于TDD测试的一个明显优势，因为TDD测试不能轻易为客户所理解。
- en: Tests plans and test types
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试计划和测试类型
- en: The term "test plan" is sometimes incorrectly used to refer to a test specification.
    While test specifications define the scenarios that will be tested and how they
    will be tested, a test plan is a collection of all the test specs for a given
    area.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: “测试计划”这个术语有时被错误地用来指代测试规范。虽然测试规范定义了将要测试的场景以及如何测试，但测试计划是一个给定区域的全部测试规范的集合。
- en: It is recommended that you create an actual planning document, because a test
    plan can involve many processes, documents, and practices. One of the main goals
    of a test plan is to identify and define what kind of test is adequate for a component
    or set of components in an application. The following are the most commonly used
    test types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您创建一个实际的规划文档，因为测试计划可能涉及许多流程、文档和实践。测试计划的主要目标之一是确定和定义适用于应用程序中某个组件或一组组件的适当测试类型。以下是最常用的测试类型。
- en: Unit tests
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: These are used to test an isolated component. If the component is not isolated—that
    is, if the component has some dependencies—we will have to use some tools and
    practices, such as stubs or dependency injections, to try to isolate it as much
    as we can during the test. If it is not possible to manipulate the component's
    dependencies, we will use spies to facilitate the creation of the unit tests.
    Our main goal should be to achieve the total isolation of a component when it
    is tested. A unit test should also be fast, and we should try to avoid input/output,
    network usage, and any other operations that could potentially affect the speed
    of the test.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于测试一个独立的组件。如果组件没有隔离——也就是说，如果组件有一些依赖关系——我们就必须使用一些工具和实践，例如存根或依赖注入，尽量在测试期间将其隔离。如果无法操作组件的依赖关系，我们将使用间谍来帮助创建单元测试。我们的主要目标应该是实现组件在测试时的完全隔离。单元测试也应该快速，我们应该尽量避免输入/输出、网络使用以及可能影响测试速度的任何其他操作。
- en: Integration tests
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests are used to test a set of components (partial-integration
    test) or the entire application (full-integration test). In integration, we will
    normally use known test data to feed the backend with information that will be
    displayed on the frontend. We will then assert that the displayed information
    is correct.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试用于测试一组组件（部分集成测试）或整个应用程序（完整集成测试）。在集成测试中，我们通常会使用已知测试数据向后端提供信息，这些信息将在前端显示。然后我们将断言显示的信息是正确的。
- en: Regression tests
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归测试
- en: Regression tests are used to verify that an issue has been fixed. If we are
    using TDD or BDD, whenever we encounter an issue, we should create a unit test
    that reproduces the issue before we fix the issue. By doing this, we will be able
    to reproduce past issues and ensure that we don't have to deal with the same issue
    ever again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试用于验证问题已被修复。如果我们正在使用 TDD 或 BDD，每次遇到问题时，我们应该在修复问题之前创建一个单元测试来重现该问题。通过这样做，我们将能够重现过去的问题，并确保我们不再需要处理相同的问题。
- en: Performance and load tests
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和负载测试
- en: Performance and load tests verify whether the application meets our performance
    expectations. We can use performance tests to verify that our application will
    be able to handle many concurrent users or activity spikes. To learn more about
    this type of test, look at [Chapter 13](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml),
    *Application Performance*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和负载测试用于验证应用程序是否符合我们的性能预期。我们可以使用性能测试来验证我们的应用程序是否能够处理许多并发用户或活动峰值。要了解更多关于此类测试的信息，请参阅第
    13 章，*应用程序性能*。
- en: End-to-end (e2e) tests
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端（e2e）测试
- en: End-to-end tests are not that different from full-integration tests. The main
    difference is that in an e2e testing session, we will try to emulate an environment
    that is almost identical to the real user environment. We will use Nightwatch.js
    and ChromeDriver for this purpose.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试与完整集成测试没有太大区别。主要区别在于，在 e2e 测试会话中，我们将尝试模拟一个几乎与真实用户环境相同的环境。我们将使用 Nightwatch.js
    和 ChromeDriver 来实现这一目的。
- en: User-acceptance tests (UAT)
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户验收测试（UAT）
- en: User-acceptance tests help us to ensure that the system meets all the requirements
    of the end users.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 用户验收测试（UAT）帮助我们确保系统满足最终用户的所有要求。
- en: The example application
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: 'In this chapter, we are going to develop an entire web application. The application
    itself is not a very realistic example, but should be realistic enough to demonstrate
    many kinds of testing practices and technologies. We are going to develop a calculator
    that can perform the `pow` operation. The calculator application is composed of
    the following components:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个完整的 Web 应用程序。该应用程序本身不是一个非常真实的应用示例，但应该足够真实，足以展示许多种测试实践和技术。我们将开发一个可以进行
    `pow` 操作的计算器。计算器应用程序由以下组件组成：
- en: A graphic user interface that is implemented using React, and fetches the result
    of the `pow` operation from a web service using an HTTP client
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 实现的图形用户界面，并使用 HTTP 客户端从 Web 服务获取 `pow` 操作的结果
- en: A web service that is implemented using Node.js and Express.js, and finds the
    result of the `pow` operation using a small math library
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js 和 Express.js 实现的 Web 服务，并使用一个小型数学库来查找 `pow` 操作的结果
- en: 'The application''s graphic user interface looks as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的图形用户界面如下所示：
- en: '![](img/cd3ea0db-790e-4a0e-9f3c-d7ab03ecb36b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd3ea0db-790e-4a0e-9f3c-d7ab03ecb36b.png)'
- en: We are going to define many different automated tasks using npm scripts. Each
    task uses different tools, and some tasks must take place before others. We could
    use a more complex setup to run some tasks in parallel and reduce the execution
    time of the whole process, or use a more realistic application, but we want to
    keep things as simple as possible to focus on the test techniques and tools.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 npm 脚本定义许多不同的自动化任务。每个任务使用不同的工具，有些任务必须在其他任务之前执行。我们可以使用更复杂的设置来并行运行一些任务，从而减少整个过程的执行时间，或者使用更真实的应用程序，但我们希望尽可能保持简单，以便专注于测试技术和工具。
- en: 'We are going to define the following tasks in our `package.json` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `package.json` 文件中定义以下任务：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you are using Windows, the commands defined in the preceding code will fail
    because the relative paths use the Unix notation. You can solve this problem by
    installing Git and then installing Git Bash on Windows from [https://git-scm.com/downloads](https://git-scm.com/downloads),
    and then setting up npm to use Git Bash using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，前面代码中定义的命令将失败，因为它们使用了 Unix 格式的相对路径。你可以通过安装 Git 并从 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    安装 Git Bash 来解决这个问题，然后使用以下命令设置 npm 以使用 Git Bash：
- en: '`npm config set script-shell "C:Program FilesGitbinbash.exe"`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm config set script-shell "C:Program FilesGitbinbash.exe"`'
- en: You might also need to install Python and the C++ build tools because both are
    required by the `node-sass` module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要安装 Python 和 C++ 编译工具，因为这两个都是 `node-sass` 模块所必需的。
- en: Remember that the entire source code is included in the companion source code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，整个源代码都包含在配套源代码中。
- en: 'The process has been designed in a way that allows us to run it entirely by
    using the `npm run all` command. This command will execute all the other tasks
    in order, as described in the following diagram:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程被设计成可以通过使用 `npm run all` 命令完全运行。此命令将按以下图中描述的顺序执行所有其他任务：
- en: '![](img/6e61d224-ac63-4152-9d05-5e34a65b775b.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e61d224-ac63-4152-9d05-5e34a65b775b.png)'
- en: The preceding diagram allows us to visualize which tasks are initialized by
    a parent task. For example, the clean, install, lint, build, and test tasks are
    all started by the **all** task. The diagram also helps us to visualize the order
    in which the tasks are executed. For example, we can see that the first task is
    the **all** task and the last task is the **kill** task.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表使我们能够可视化由父任务初始化的任务。例如，clean、install、lint、build 和 test 任务都是由 **all** 任务启动的。该图表还帮助我们可视化任务的执行顺序。例如，我们可以看到第一个任务是
    **all** 任务，最后一个任务是 **kill** 任务。
- en: 'We will now examine the purpose of each of these tasks:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查每个这些任务的目的：
- en: The **all** task is the root task, and it is used to start other tasks.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**all** 任务是根任务，用于启动其他任务。'
- en: The **clean** task removes some of the previous outputs to ensure that results
    are not influenced by any cache issues.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clean** 任务移除一些之前的输出，以确保结果不受任何缓存问题的影响。'
- en: The **install** task downloads all the required dependencies.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**install** 任务下载所有必需的依赖项。'
- en: The **lint** task enforces some code-styling rules.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lint** 任务强制执行一些代码风格规则。'
- en: The **build** task starts the compilation tasks for both frontend and end-to-end
    tests. Compilation for the backend and the unit tests is not required because
    the tools used (nyc and ts-node) don't require it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**build** 任务启动前端和端到端测试的编译任务。对于后端和单元测试不需要编译，因为使用的工具（nyc 和 ts-node）不需要它。'
- en: The **build_e2e** task compiles the e2e tests using tsc.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**build_e2e** 任务使用 tsc 编译 e2e 测试。'
- en: The **build_frontend** task compiles the frontend application using Webpack.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**build_frontend** 任务使用 Webpack 编译前端应用程序。'
- en: The **test** task runs both the unit tests with nyc and the e2e tests with Nightwatch.js.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**test** 任务运行带有 nyc 的单元测试和带有 Nightwatch.js 的 e2e 测试。'
- en: The **nyc** task runs the unit tests and integration tests, and generates a
    test-coverage report.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nyc** 任务运行单元测试和集成测试，并生成测试覆盖率报告。'
- en: The **e2e** task runs the e2e tests. Before we run the e2e tests, we need to
    serve the application using a web server, and we will also need to stop serving
    the application once we are done.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**e2e** 任务运行 e2e 测试。在我们运行 e2e 测试之前，我们需要使用网络服务器来提供服务应用程序，完成测试后我们还需要停止服务。'
- en: The **start** task uses PM2 to starts the Node.js process that serves the application.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**start** 任务使用 PM2 启动服务应用程序的 Node.js 进程。'
- en: The **nw** task stands for Nightwatch.js, and is used to execute the e2e tests.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nw** 任务代表 Nightwatch.js，用于执行 e2e 测试。'
- en: The **kill** task uses PM2 to stop the Node.js process that serves the application.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kill** 任务使用 PM2 停止服务应用程序的 Node.js 进程。'
- en: We shouldn't worry too much if we don't understand what the mission is of each
    of the tasks or tools mentioned in the preceding list, because we are going to
    spend the rest of this chapter learning about them in detail, except for the clean,
    install, lint and build tasks, because we have already learned about these tasks
    in previous chapters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们不理解前面列表中提到的每个任务或工具的使命，我们不必过于担心，因为我们将在本章的剩余部分详细学习它们，除了 clean、install、lint
    和 build 任务，因为我们已经在之前的章节中学习了这些任务。 '
- en: Refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automa**ting
    Your Development Workflow*, to learn how to generate a test-coverage report.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第 9 章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)，*自动化您的开发工作流程*，了解如何生成测试覆盖率报告。
- en: Unit tests and integration tests with Mocha
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocha 进行单元测试和集成测试
- en: 'In [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating Your
    Development Workflow*, we learned the basic details of the unit tests and test-coverage
    reports with nyc, ts-node, Mocha, and Chai. In this chapter, we are going to learn
    how to test asynchronous APIs using Mocha and how to combine Mocha with other
    powerful tools, such as Sinon.JS, SuperTest, and Enzyme:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)，*自动化您的开发工作流程*中，我们学习了使用
    nyc、ts-node、Mocha 和 Chai 进行单元测试和测试覆盖率报告的基本细节。在本章中，我们将学习如何使用 Mocha 测试异步 API，以及如何将
    Mocha 与其他强大的工具结合使用，例如 Sinon.JS、SuperTest 和 Enzyme：
- en: We are going to learn how to write tests for every layer of an application.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何为应用程序的每一层编写测试。
- en: We are going to start by testing a math library used in the backend.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先测试一个用于后端的后台数学库。
- en: We will then test a web service, which consumes the math library, and a client,
    which consumes the web service.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将测试一个消耗数学库的 Web 服务和一个消耗 Web 服务的客户端。
- en: We will finish the section by writing tests for the graphic user interface and
    creating some e2e tests.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过编写图形用户界面的测试和创建一些端到端测试来完成本节。
- en: Back to basics
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归基础
- en: 'The companion source code includes a class named `MathDemo`. This class allows
    us to perform the `pow` calculation in a few different ways. One of them is the
    synchronous `pow` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 配套源代码包括一个名为 `MathDemo` 的类。这个类允许我们以几种不同的方式执行 `pow` 计算。其中之一是同步的 `pow` 函数：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we learned in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, we can test the method declared in the preceding function
    using the following test case:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 9 章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)，*自动化您的开发工作流程*中学习的，我们可以使用以下测试用例测试前面函数中声明的函数：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then use the `nyc` command with ts-node and Mocha to run our tests and
    generate a test-coverage report. In the companion source code, this is wrapped
    with npm scripts as the following command to facilitate the usage:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `nyc` 命令与 ts-node 和 Mocha 运行我们的测试并生成测试覆盖率报告。在配套源代码中，这被 npm 脚本包装如下命令，以方便使用：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If everything goes according to plan, we should see a list of all the tests
    that have been executed. The result generated by the tests that were included
    in the companion source code should look as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，我们应该看到已执行的所有测试的列表。包含在配套源代码中的测试生成的结果应如下所示：
- en: '![](img/4bf922d0-0900-4999-a882-59206c64d969.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4bf922d0-0900-4999-a882-59206c64d969.png)'
- en: 'The command should also generate a test coverage report as shown in the following
    screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 命令还应生成如下截图所示的测试覆盖率报告：
- en: '![](img/f485c5ad-6c53-4ea6-b6d4-08de7bcf0855.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f485c5ad-6c53-4ea6-b6d4-08de7bcf0855.png)'
- en: 'Once we have executed our tests with the `nyc` command, we can generate a test
    coverage report by running the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `nyc` 命令执行了测试，我们可以通过运行以下命令生成测试覆盖率报告：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will generate a folder named `coverage` in the current directory. The
    coverage folder contains some HTML files that we can open using a web browser:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录下生成一个名为 `coverage` 的文件夹。该覆盖率文件夹包含一些我们可以使用网页浏览器打开的 HTML 文件：
- en: '![](img/f6c95fc0-ba15-461c-aecf-3fc52a48829e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6c95fc0-ba15-461c-aecf-3fc52a48829e.png)'
- en: 'If we click on one of the files, we will be able to see a line-by-line test
    coverage report for the selected file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击其中一个文件，我们将能够看到所选文件的逐行测试覆盖率报告：
- en: '![](img/834099f2-1655-4fa3-8147-b366b458353d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/834099f2-1655-4fa3-8147-b366b458353d.png)'
- en: Testing asynchronous code
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异步代码
- en: 'The `MathDemo` class also includes an asynchronous version of the same method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`MathDemo` 类还包括相同方法的异步版本：'
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we try to test this method, and we don''t wait for its result, our test
    will be useless. However, if we wait for the result, using the `Promise.then`
    method, our test will also fail, unless we pass a callback (named `done` in the
    example) function to the test-case handler:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试测试此方法，并且我们没有等待其结果，我们的测试将毫无用处。然而，如果我们等待结果，使用 `Promise.then` 方法，我们的测试也将失败，除非我们向测试用例处理器传递一个回调函数（在示例中命名为
    `done`）：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, we can use async and await, as demonstrated in the following
    code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 async 和 await，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When testing asynchronous code, Mocha will consider the test as failed (timeout)
    if it takes more than 2,000 milliseconds to invoke the `done` function. The time
    limit before a timeout can be configured, as can warnings for slow functions.
    By default, when a test takes more than 40 milliseconds, a warning will be displayed.
    The warning suggests that our test is somehow slow. If the test execution takes
    over 100 milliseconds, the warning will suggest that our test is quite slow. We
    can change this configuration using the `--timeout` command-line argument of the
    `mocha` command.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试异步代码时，如果调用 `done` 函数的时间超过 2,000 毫秒，Mocha 将认为测试失败（超时）。在超时之前的时间限制是可以配置的，同样，对于慢速函数的警告也可以配置。默认情况下，当测试时间超过
    40 毫秒时，会显示警告。警告建议我们的测试可能有些慢。如果测试执行时间超过 100 毫秒，警告将建议我们的测试相当慢。我们可以使用 `mocha` 命令的
    `--timeout` 命令行参数来更改此配置。
- en: The companion source code includes examples of each kind of warning and failure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的源代码包含了每种警告和失败的示例。
- en: Asserting exceptions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言异常
- en: 'In the previous examples, we have learned how to assert the type and value
    of a variable:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何断言变量的类型和值：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, there is one scenario that is perhaps not as intuitive as the previous
    one—testing for an exception.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个场景可能不如前面的场景直观——测试异常。
- en: 'The `MathDemo` class also contains a method named `bad`, which was added with
    the sole purpose of illustrating how to test for an exception. The `bad` method
    throws an exception when it is invoked with a `null` argument:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`MathDemo` 类还包含一个名为 `bad` 的方法，它被添加的唯一目的是说明如何测试异常。当使用 `null` 参数调用时，`bad` 方法会抛出异常：'
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following test, we can see how we can use the `expect` API to assert
    that an exception is thrown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的测试中，我们可以看到如何使用 `expect` API 断言抛出异常：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you wish to learn more about assertions, visit the Chai official documentation
    available at [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于断言的信息，请访问位于 [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/)
    的 Chai 官方文档。
- en: Testing a web service with SuperTest
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SuperTest 测试 web 服务
- en: 'The demo application included in the companion source code declares a web service
    that allows us to get the result of the `pow` calculation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码中的演示应用程序声明了一个允许我们获取 `pow` 计算结果的 web 服务：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The initialization of the application is separated into two files: `main.ts`
    and `server.ts`. The `server.ts` file defines the `getApp` function that we have
    examined in the preceding code snippet. The `main.ts` file uses the `getApp` function
    to start the server:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的初始化被分为两个文件：`main.ts` 和 `server.ts`。`server.ts` 文件定义了我们在前面的代码片段中检查过的 `getApp`
    函数。`main.ts` 文件使用 `getApp` 函数来启动服务器：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sometimes, it is a good idea to test a web service as a whole in what is known
    as integration tests. As we learned earlier in this chapter, integration tests
    are used to test a set of components. In this case, we are going to test the server-side
    route handlers and their usage of the `MathDemo` class. We can define a test for
    the `pow` service as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将整个 web 服务作为一个整体进行测试，这被称为集成测试，是一个好主意。正如我们在本章前面所学到的，集成测试用于测试一组组件。在这种情况下，我们将测试服务器端的路由处理程序及其对
    `MathDemo` 类的使用。我们可以定义一个针对 `pow` 服务的测试如下：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see in the preceding code snippet, we have used a function named `getApp`
    to get the instance of the Express.js app. Once we have the app instance, we can
    use the request method from the `supertest` module to send a request to the service.
    We can use SuperTest together with Chai to assert that the response of the request
    matches an expected result. It is important to mention that the `getApp` function
    creates an app, but it doesn't launch the app. Or, in other words, the `getApp` function
    avoids invoking the `app.listen` method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们使用了一个名为 `getApp` 的函数来获取 Express.js 应用的实例。一旦我们有了应用实例，我们可以使用 `supertest`
    模块中的请求方法向服务发送请求。我们可以使用 SuperTest 与 Chai 一起断言请求的响应与预期的结果匹配。重要的是要提到，`getApp` 函数创建了一个应用，但它不会启动应用。或者换句话说，`getApp`
    函数避免了调用 `app.listen` 方法。
- en: Working with tests suites
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与测试套件一起工作
- en: 'A test suite is a group of test cases. We have already learned that we can
    use the `describe` function from Mocha to define a test suite and the `it` function
    to define a test case. However, we have not learned that we can define event handlers
    that can be invoked before and after all the tests in a test suite. The following
    code snippet demonstrates how we can define these event handlers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件是一组测试用例。我们已经了解到我们可以使用 Mocha 的 `describe` 函数来定义测试套件，以及使用 `it` 函数来定义测试用例。然而，我们还没有学习到我们可以定义在测试套件中的所有测试之前和之后可以调用的事件处理器。以下代码片段展示了我们如何定义这些事件处理器：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This can be useful if we want to reuse some of the initialization logic across
    multiple test cases. For example, we can rewrite the example that we used to test
    a web service earlier in the preceding section, in a way that will allow us to
    share the Express.js application instance across multiple test cases:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在多个测试用例之间重用一些初始化逻辑，这可能会很有用。例如，我们可以将前面章节中用来测试 Web 服务的示例重写，以便我们可以在多个测试用例之间共享
    Express.js 应用程序实例：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Usually, testing frameworks (regardless of the language we are working with)
    won't allow us to control the order in which the unit tests and test suites are
    executed. The tests can even be executed in parallel by using multiple threads.
    For this reason, it is important to ensure that the unit tests in our test suites
    are independent of each other.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试框架（无论我们使用的是哪种语言）都不会允许我们控制单元测试和测试套件的执行顺序。测试甚至可以通过使用多个线程并行执行。因此，确保我们测试套件中的单元测试彼此独立是很重要的。
- en: Isolating components with Sinon.JS
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 隔离组件
- en: We have learned that unit tests are used to test individual components, and
    integration tests are used to test a set of components and their interactions.
    When we write a unit test, and a component has a dependency on another, we will
    need to provide stubs, mocks, or dummies instead of real dependencies to ensure
    that the component is being tested in isolation. However, sometimes this can be
    more complicated than it sounds. Luckily, Sinon.JS can help us to ensure that
    our components are tested in isolation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到单元测试用于测试单个组件，集成测试用于测试一组组件及其交互。当我们编写单元测试时，如果组件依赖于另一个组件，我们需要提供存根、模拟或占位符来代替真实依赖，以确保组件是在隔离的情况下进行测试的。然而，有时这比听起来要复杂得多。幸运的是，Sinon.JS
    可以帮助我们确保我们的组件是在隔离的情况下进行测试的。
- en: 'The following code snippet is used to test the web client of the `pow` web
    service that we described earlier in this chapter. We use Sinon.JS to define a
    stub for a global object named `fetch`. The `fetch` global object is a function
    that allows us to send an AJAX request to the backend from the frontend. Replacing
    the `fetch` object with a stub is a good idea because it will help us to ensure
    that the client class is not interacting with the backend, and, thus, that it
    is tested in complete isolation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段用于测试本章前面描述的 `pow` Web 服务的 Web 客户端。我们使用 Sinon.JS 为名为 `fetch` 的全局对象定义了一个存根。`fetch`
    全局对象是一个允许我们从前端向后端发送 AJAX 请求的函数。用存根替换 `fetch` 对象是一个好主意，因为它将帮助我们确保客户端类没有与后端交互，因此可以在完全隔离的情况下进行测试：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using a global is a bad idea because it goes against the dependency inversion
    principle and makes our applications harder to test. Fortunately, Sinon.JS can
    help us to overcome this kind of difficulty.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量是一个坏主意，因为它违反了依赖倒置原则，并使得我们的应用程序更难测试。幸运的是，Sinon.JS 可以帮助我们克服这种困难。
- en: Refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working with
    Dependencies*, to learn more about dependency inversion and its underlying principles.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第 5 章](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)，*与依赖项一起工作*，了解更多关于依赖倒置及其基本原理。
- en: It is also worth mentioning that the stubs provide us with an API that can help
    us to check things, such as the number of times that the stub was used or which
    arguments were passed to it. This was demonstrated by the last assertion in the
    preceding code snippet.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，存根为我们提供了一个 API，可以帮助我们检查一些事情，例如存根被使用的次数或传递给它的参数。这在上面的代码片段的最后一条断言中得到了演示。
- en: jsdom
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jsdom
- en: 'Some testing tools, such as Enzyme (we will learn about this in the following
    section), expect to be used in a web browser. In our example, the application
    uses nyc and ts-node to execute all our unit tests, which means that we are not
    using a web browser. Sometimes, it is possible to overcome this problem by using
    jsdom, which is described by its creators as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试工具，例如 Enzyme（我们将在下一节中了解它），期望在网页浏览器中使用。在我们的例子中，应用程序使用 nyc 和 ts-node 来执行所有单元测试，这意味着我们没有使用网页浏览器。有时，通过使用
    jsdom 可以克服这个问题，其创造者是这样描述的：
- en: '"jsdom is a pure-JavaScript implementation of many web standards, notably the
    WHATWG DOM and HTML Standards, for use with Node.js. In general, the goal of the
    project is to emulate enough of a subset of a web browser to be useful for testing
    and scraping real-world web applications."'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '"jsdom 是许多网页标准的纯 JavaScript 实现，特别是 WHATWG DOM 和 HTML 标准，用于 Node.js。一般来说，项目的目标是模拟足够多的网页浏览器子集，以便在测试和抓取现实世界网页应用程序时有用。"'
- en: 'If we examine the `nyc` command in the `package.json` file included in the
    companion source code, we will see that one of the arguments provided to the nyc
    binary is `--require ./jsdom.js`. This will force Mocha to need the `jsdom.js`
    file before any tests are executed. The `jsdom.js` file is used to initialize
    jsdom, and looks as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查伴随源代码中包含的 `package.json` 文件中的 `nyc` 命令，我们会看到提供给 nyc 二进制的参数之一是 `--require
    ./jsdom.js`。这将强制 Mocha 在执行任何测试之前需要 `jsdom.js` 文件。`jsdom.js` 文件用于初始化 jsdom，其外观如下：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding file creates a few global variables that allow us to run the backend
    code that was originally designed to be executed in a web browser. In the Node.js
    execution environment, we don't have certain variables, such as the window variable.
    The preceding code snippet initializes all the required variables to enable the
    execution of frontend code in our backend execution environment (Node.js). This
    is useful, for example, when we want to write a test for a frontend component
    because we can execute our tests without the need for a web browser.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件创建了一些全局变量，使我们能够运行原本设计为在网页浏览器中执行的后端代码。在 Node.js 执行环境中，我们没有某些变量，例如 window
    变量。上述代码片段初始化所有必需的变量，以便在我们的后端执行环境中（Node.js）执行前端代码。这很有用，例如，当我们想要为前端组件编写测试时，因为我们可以在不需要网页浏览器的情况下执行我们的测试。
- en: Refer to the Enzyme documentation at [https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md](https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md)
    to learn more about the jsdom configuration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 参考Enzyme文档[https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md](https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md)，了解更多关于
    jsdom 配置的信息。
- en: Testing React web components with Enzyme
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Enzyme 测试 React 网页组件
- en: At this point, we have tested the backend of our application using both unit
    tests and integration tests (with SuperTest). We have also tested our client in
    complete isolation, thanks to the usage of Sinon.JS. However, our application
    can still fail if something is wrong in the presentation layer (the graphic user
    interface). In this section, we are going to learn how we can use some libraries
    to help us to test each of the components of our graphic user interface.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用单元测试和集成测试（使用 SuperTest）测试了应用程序的后端。我们还利用 Sinon.JS 的使用在完全隔离的情况下测试了我们的客户端。然而，如果表示层（图形用户界面）出现问题，我们的应用程序仍然可能失败。在本节中，我们将学习如何使用一些库来帮助我们测试图形用户界面的每个组件。
- en: Refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about React.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 11 章，*使用 React 和 TypeScript 进行前端开发*，了解更多关于 React 的信息。
- en: 'The companion source code includes the following React component:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随源代码包括以下 React 组件：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As we learned earlier in this chapter, the preceding component will display
    a web form on the screen. The users of the application need to provide two numbers
    (`base` and `exponent`) as inputs. The input is then sent to a web service in
    the backend, and the response is displayed as a result. The following code snippet
    demonstrates how we can isolate the preceding component from the HTTP client using
    a stub. The code snippet also demonstrates how we can configure Enzyme to work
    with version 16 of React and then use it to simulate user events, such as clicking
    on an element or typing in an input:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所学，前面的组件将在屏幕上显示一个网页表单。应用程序的用户需要提供两个数字（`基数`和`指数`）作为输入。然后输入被发送到后端的一个网络服务，并将响应显示为结果。以下代码片段演示了我们可以如何使用存根将前面的组件从
    HTTP 客户端隔离出来。代码片段还演示了我们可以如何配置 Enzyme 以与 React 的第 16 版一起工作，然后使用它来模拟用户事件，例如点击元素或输入文本：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding tests insert a value for the base and exponent inputs and then
    click on the Submit button. This will invoke the web client, which has been replaced
    by a stub.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试为基数和指数输入插入一个值，然后点击提交按钮。这将调用被存根替换的客户端。
- en: 'Enzyme has been designed to work with React. However, each major version of
    React requires a specific adapter. Other frameworks might require other libraries.
    For example, in Angular, we can use the utilities provided by the `@angular/core/testing`
    module to do something like the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme 已经被设计成与 React 一起工作。然而，React 的每个主要版本都需要一个特定的适配器。其他框架可能需要其他库。例如，在 Angular
    中，我们可以使用`@angular/core/testing`模块提供的实用工具执行如下操作：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Please refer to the documentation at [https://angular.io/api/core/testing](https://angular.io/api/core/testing)
    to learn more about testing in Angular.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://angular.io/api/core/testing](https://angular.io/api/core/testing)中的文档以了解更多关于
    Angular 中测试的信息。
- en: TDD versus BDD with Mocha and Chai
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocha 和 Chai 的 TDD 与 BDD
- en: As we have already seen, TDD and BDD follow many of the same principles, but
    have some differences in their style. While these two styles provide the same
    functionality, BDD is considered to be easier to read by many developers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，TDD 和 BDD 遵循许多相同的原则，但在风格上有所不同。虽然这两种风格提供了相同的功能，但许多开发者认为 BDD 更易于阅读。
- en: 'The following table compares the naming and style of the suites, tests, and
    assertions used by the TDD and BBD styles:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下表比较了 TDD 和 BDD 风格使用的套件、测试和断言的命名和风格：
- en: '| **TDD** | **BDD** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **TDD** | **BDD** |'
- en: '| `suite` | `describe` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `suite` | `describe` |'
- en: '| `setup` | `before` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `setup` | `before` |'
- en: '| `teardown` | `after` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `teardown` | `after` |'
- en: '| `suiteSetup` | `beforeEach` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `suiteSetup` | `beforeEach` |'
- en: '| `suiteTeardown` | `afterEach` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `suiteTeardown` | `afterEach` |'
- en: '| `test` | `it` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `test` | `it` |'
- en: '| `assert.equal(math.PI, 3.14159265359);` | `expect(math.PI).to.equals(3.14159265359);`
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `assert.equal(math.PI, 3.14159265359);` | `expect(math.PI).to.equals(3.14159265359);`
    |'
- en: End-to-end tests with Nightwatch.js
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nightwatch.js 的端到端测试
- en: 'Writing an e2e test with Nightwatch.js is very simple because its API is very
    readable. We should be able to read an e2e test and be able to understand it,
    even if it is the first time that we see one. For example, the following is an
    example of an e2e test that is used to test the application included in the companion
    source code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Nightwatch.js 编写端到端测试非常简单，因为它的 API 非常易于阅读。我们应该能够阅读一个端到端测试并理解它，即使这是我们第一次看到它。例如，以下是一个用于测试配套源代码中包含的应用程序的端到端测试示例：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the `NightwatchBrowser` instance to navigate to a URL, wait for a few
    elements to be visible, set the value of a few inputs, and then click on the Submit
    button.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`NightwatchBrowser`实例导航到 URL，等待几个元素可见，设置几个输入的值，然后点击提交按钮。
- en: 'While the e2e tests API is very simple, the process behind it is not so simple.
    If we examine the `npm script` commands in the `package.json` file included in
    the companion source code, we will be able to observe that the command triggers
    four other commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然端到端测试 API 非常简单，但其背后的过程并不简单。如果我们检查包含在配套源代码中的`package.json`文件中的`npm script`命令，我们将能够观察到该命令触发了四个其他命令：
- en: Compile the e2e tests
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译端到端测试
- en: Run the application
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Run the e2e tests
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行端到端测试
- en: Kill the application
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止应用程序
- en: The first command uses PM2 and ts-node to run the application. PM2 is a very
    powerful process management tool that allows us to run a Node.js app as a cluster
    and to monitor it. However, this is not why we are using it here. We use PM2 because
    it is a very easy way to run the application as a background process. We need
    to run the entire application before our e2e tests are executed. The problem is
    that when the app starts waiting for HTTP requests, it blocks all the subsequent
    commands. PM2 solves this problem by allowing us to run the app in a background
    process.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令使用PM2和ts-node来运行应用程序。PM2是一个非常强大的进程管理工具，它允许我们将Node.js应用程序作为集群运行并对其进行监控。然而，这并不是我们在这里使用它的原因。我们使用PM2是因为它是一种非常简单的方式来以后台进程运行应用程序。在我们执行e2e测试之前，我们需要运行整个应用程序。问题是当应用程序开始等待HTTP请求时，它会阻塞所有后续的命令。PM2通过允许我们在后台进程中运行应用程序来解决此问题。
- en: Another thing worth mentioning is that our e2e tests are browser-independent.
    This explains why Nightwatch.js requires us to configure a driver. The driver
    provides native access to the web browser that will execute the e2e tests.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的事情是我们的e2e测试是浏览器无关的。这解释了为什么Nightwatch.js要求我们配置一个驱动器。驱动器提供了对将执行e2e测试的Web浏览器的原生访问。
- en: In the demo application, we are using ChromeDriver. We have created a file named
    `globals.js` that is used to define some global events that will be executed before
    and after our e2e tests. The event handlers are very similar to the ones that
    we learned about while defining a test suite with Mocha earlier in this chapter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示应用程序中，我们使用ChromeDriver。我们创建了一个名为`globals.js`的文件，用于定义一些全局事件，这些事件将在我们的e2e测试之前和之后执行。事件处理器与我们之前在本章中定义测试套件时了解的非常相似。
- en: 'We use the event handlers declared in the `globals.js` file to create and destroy
    instances of `chromedriver`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在`globals.js`文件中声明的事件处理器来创建和销毁`chromedriver`的实例：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The version of the `chromedriver` npm module used in this example is 2.36.0\.
    This version has been tested with Google Chrome 65.0\. If you are using a later
    version of Google Chrome, please ensure that you also upgrade the `chromedriver`
    module.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的`chromedriver` npm模块的版本是2.36.0。这个版本已经与Google Chrome 65.0进行了测试。如果您使用的是Google
    Chrome的较新版本，请确保您也升级了`chromedriver`模块。
- en: 'We then create a file named Nightwatch.js that contains the following configuration:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个名为Nightwatch.js的文件，其中包含以下配置：
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we can see in the preceding code snippet, we are configuring ChromeDriver
    to use the `globals.js` events and Google Chrome as the web browser to be used
    to run our tests. We have also configured Nightwatch.js to look for our test under
    the `dist` folder. Nightwatch.js cannot understand TypeScript natively, which
    explains why we need to compile the tests into the `dist` folder before we can
    run them.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们正在配置ChromeDriver以使用`globals.js`事件和Google Chrome作为运行测试时要使用的Web浏览器。我们还配置了Nightwatch.js以在`dist`文件夹中查找我们的测试。Nightwatch.js无法原生理解TypeScript，这就是为什么我们需要在运行测试之前将测试编译到`dist`文件夹中。
- en: 'We need to define a second `tsconfig.json` file named `tsconfig.e2e.json` with
    some additional options to ensure that we only compile the required files:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个名为`tsconfig.e2e.json`的第二个`tsconfig.json`文件，并添加一些额外的选项以确保我们只编译所需的文件：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please note that the `extends` filed in the `tsconfig.json` file allows us to
    inherit all the settings from a previously declared `tsconfig.json` file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tsconfig.json`文件中的`extends`字段允许我们从先前声明的`tsconfig.json`文件继承所有设置。
- en: 'If everything goes well, we should be able to see results like the following
    on the console:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该能够在控制台看到以下结果：
- en: '![](img/3cabd2d8-73ef-49f6-935d-0161d5146026.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cabd2d8-73ef-49f6-935d-0161d5146026.png)'
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some core testing concepts, such as stubs, suites,
    and more. We also looked at the test-driven development and behavior-driven development
    approaches, and how to work with some of the leading JavaScript testing frameworks,
    such as Mocha, Chai, Sinon.JS, Enzyme, SuperTest, and Nightwatch.js.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些核心测试概念，例如存根、套件等。我们还探讨了测试驱动开发和行为驱动开发方法，以及如何与一些主要的JavaScript测试框架一起工作，例如Mocha、Chai、Sinon.JS、Enzyme、SuperTest和Nightwatch.js。
- en: In the next chapter, we will learn how to use the TypeScript language services
    to create our development tools.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用TypeScript语言服务来创建我们的开发工具。
