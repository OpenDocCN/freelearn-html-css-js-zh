- en: Application Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating Your
    Development Workflow*, we learned how to write unit tests and generate a test
    coverage report. However, application testing is a very extensive subject, and
    we barely touched its surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn how to write multiple kinds of automated
    tests for a TypeScript application. We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing planning and methodologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolating components during tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing end-to-end (e2e) tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to get started by learning about the core terminology used in the
    field of software testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we are going to use some concepts that may not be familiar
    to readers without previous experience in the field of software testing. For this
    reason, we are going to take a quick look at some of the most popular concepts
    in software testing before we get started.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **assertion** is a condition that must be tested to confirm that a certain
    piece of code behaves as expected, or, in other words, to confirm conformance
    to a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we are working as part of the Google Chrome development team,
    and we must implement the JavaScript `Math` API. If we are working on the `pow`
    method, the requirement could be something like, the `Math.pow` (base, exponent)
    function should return the base (the base number) to the exponent (the exponent
    used to raise the base) power-that is, base `^` exponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information, we could create the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we use the name `MathAPI` instead of `Math` in this example
    because the `Math` variable is already declared by the real JavaScript Math API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the method is correctly implemented, we must test its accordance
    with the requirement. If we analyze the requirements closely, we should identify
    at least two necessary assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function should return the base to the exponent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The exponent is not being used as the base (or the base is not used as the
    exponent):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If both assertions are valid, then our code adheres to the requirements, and
    we know that it will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Specs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spec **is a term used by software development engineers to refer to test
    specifications. A test specification (not to be confused with a test plan) is
    a detailed list of all the scenarios that should be tested and how they should
    be tested, as well as other details.'
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **test coverage** refers to a unit of measurement, which is used to
    illustrate the number of portions of code in an application that have been tested
    via an automated test. Test coverage can be obtained by automatically generating
    test coverage reports.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, to learn how to generate a test coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: Test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **test case** is a set of conditions used to determine whether one of the
    features of an application is working as it was originally intended to work. We
    might wonder what the difference between a test assertion and a test case is.
    While a test assertion is a single condition, a test case is a set of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **suite** is a collection of test cases. While a test case should focus on
    only one test scenario, a test suite can contain test cases for many test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to define assertions, test cases, and test suites later in
    this chapter, in the *Unit tests and integration tests with Mocha* section).
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spies** are a feature provided by some testing frameworks. They allow us
    to wrap a method or function and record its usage. We can record things such as
    the method or function arguments, their return type, or the number of times that
    they have been invoked. When we wrap a method or function with a spy, the underlying
    method''s functionality does not change.'
  prefs: []
  type: TYPE_NORMAL
- en: Dummies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **dummy** object is an object that is passed around during the execution of
    a test, but it is never actually used.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stub** is a feature provided by some testing frameworks. Like spies, stubs
    also allow us to wrap a method or function to record its usage. Unlike in the
    case of spies, when we wrap a function with a stub, the underlying method's functionality
    is replaced with new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mocks are often confused with stubs. Martin Fowler once wrote the following
    in an article titled *Mocks Aren''t Stubs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '"In particular, I see them (mocks) often confused with stubs - a common helper
    to testing environments. I understand this confusion - I saw them as similar for
    a while too, but conversations with the mock developers have steadily allowed
    a little mock understanding to penetrate my tortoiseshell cranium. This difference
    is actually two separate differences. On the one hand, there is a difference in
    how test results are verified: a distinction between state verification and behavior
    verification. On the other hand, is a whole different philosophy to the way testing
    and design play together, which I term here as the classical and mockist styles
    of Test Driven Development."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both mocks and stubs provide some input to the test case, but despite their
    similarities, the flow of information from each is very different:'
  prefs: []
  type: TYPE_NORMAL
- en: Stubs provide input for the application under test so that the test can be performed
    on something else. Stubs are used to replace behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocks provide input to the test to decide whether the test should pass or fail.
    Mocks are used to declare an expectation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between mocks and stubs will become clearer as we move towards
    the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be using third-party tools. In this section,
    we are going to learn how to install these. Before we get started, however, we
    need to use npm to create a `package.json` file in the folder that we are going
    to use to implement the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new folder and go inside it to generate a new `package.json`
    file using the `npm init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working
    with Dependencies*, for additional information about npm.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mocha is a popular JavaScript testing library that facilitates the creation
    of test suites, test cases, and test specs. Mocha can be used to test TypeScript
    in the frontend and backend, identify performance issues, and generate different
    types of test reports, among many other functions. We can install Mocha using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chai is a test-assertion library that supports **test-driven development**
    (**TDD**) and **behavior-driven development** (**BDD**) test styles. The main
    goal of Chai is to reduce the amount of work necessary to create a test assertion
    and make the test more readable. We can install Chai using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we are going to learn more about TDD and BDD later in this
    chapter in the section titled *Testing methodologies*.
  prefs: []
  type: TYPE_NORMAL
- en: Sinon.JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sinon.JS is a library that provides us with a set of APIs that can help us
    to test a component in isolation, thanks to its usage of spies, stubs, and mocks.
    Testing software components can be very difficult when there is a high level of
    coupling between them. However, a library such as Sinon.JS can help us isolate
    the components to test their features. We can install Sinon.JS using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: nyc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already learned in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*, we can use nyc to generate test coverage
    reports for our applications. We can install nyc using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already learned in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*, we can use nyc to generate test coverage
    reports for our applications. We can install Webpack and some additional plugins
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enzyme is an open source testing library developed by Airbnb that can help
    us to test React components. We can install enzyme using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: SuperTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SuperTest is a library that can help us to test HTTP web services developed
    with Node.js and Express.js. We can install SuperTest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: PM2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PM2 is a production process manager for Node.js applications with a built-in
    load balancer. PM2 allows us to run a Node.js application as a background process,
    which is something that we are going to need to run our e2e tests. We can install
    PM2 using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Nightwatch.js and ChromeDriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nightwatch.js is a library that helps us to implement **end-to-end** (**e2e**)
    tests. We also need a tool known as ChromeDriver. Nightwatch.js can run our test
    in multiple web browsers, but in our example, we are going use Google Chrome.
    The `chromedriver` library is an adapter that allows Nightwatch.js to communicate
    with Google Chrome during the test''s execution. We can install Nightwatch.js
    and ChromeDriver using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the companion source code to check the exact versions used in the `package.json`
    file. If you use `npm install`, the latest version will be installed by default.
    The version used in these examples might become outdated over time, which could
    lead to some configuration issues. If you want to use the latest version (which
    is recommended), you will have to check the documentation of each of the modules
    to learn about potential breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time we develop a new application, we need to make a lot of decisions.
    For example, we need to choose the type of database, architecture, libraries,
    and frameworks that we will use. However, not all our choices are about technologies,
    and we can also choose a software development methodology, such as extreme programming
    or scrum. When it comes to testing, there are two major styles or methodologies:
    TDD and BDD.'
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development (TDD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test-driven development is a testing methodology that focuses on encouraging
    developers to write tests before they write application code. Usually, the process
    of writing code in TDD consists of the following basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test that fails. There is no application code at this point, so the
    test should fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test and ensure that it fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code to pass the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test and ensure that it works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all the other existing tests to ensure that no other parts of the application
    are broken because of the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process for every new feature or bug fix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process is often represented as the "red-green-refactor" diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c6d09aa-720f-4c36-899b-80f169a96f25.png)'
  prefs: []
  type: TYPE_IMG
- en: The choice between using TDD or not comes down to the mindset you wish to adopt.
    Many developers don't like writing tests, so the chances are that if we leave
    their implementation as the last task in the development process, the tests will
    never be implemented or the application will just be partially tested. It is also
    possible that the application could be implemented in a way that is harder to
    test. If we are planning to write a test, doing it upfront can lead to a reduction
    in the implementation cost.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is recommended because it effectively helps you and your team to increase
    the test coverage of your applications and, therefore, significantly reduce the
    number of potential issues, which eventually ends up saving money.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development (BDD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavior-driven development appeared after TDD, with the mission of being a
    refined version of TDD. BDD focuses on the way tests are described (specs) and
    states that the tests should focus on the application requirements and not the
    test requirements. Ideally, this will encourage developers to think less about
    the tests themselves and think more about the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: The original article in which the BDD principles were introduced by *Dan North*
    is available at [http://dannorth.net/introducing-bdd/](http://dannorth.net/introducing-bdd/).
  prefs: []
  type: TYPE_NORMAL
- en: As we have already learned, Mocha and Chai provide APIs for both the TDD and
    BDD approaches. Later in this chapter, we will further explore these two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Recommending one of these methodologies is not trivial because TDD and BDD are
    both good testing methodologies. However, BDD was developed after TDD with the
    objective of improving it, so we can argue that BDD has some additional advantages
    over TDD. In BDD, the description of a test focuses on what the application should
    do and not what the test code is testing. This can help the developers to identify
    tests that reflect the behavior desired by the customer. BDD tests can be used
    to document the requirements of a system in a way that can be understood and validated
    by both the developer and the customer. This is a clear advantage over TDD tests,
    as TDD tests cannot be understood with ease by the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Tests plans and test types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term "test plan" is sometimes incorrectly used to refer to a test specification.
    While test specifications define the scenarios that will be tested and how they
    will be tested, a test plan is a collection of all the test specs for a given
    area.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you create an actual planning document, because a test
    plan can involve many processes, documents, and practices. One of the main goals
    of a test plan is to identify and define what kind of test is adequate for a component
    or set of components in an application. The following are the most commonly used
    test types.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are used to test an isolated component. If the component is not isolated—that
    is, if the component has some dependencies—we will have to use some tools and
    practices, such as stubs or dependency injections, to try to isolate it as much
    as we can during the test. If it is not possible to manipulate the component's
    dependencies, we will use spies to facilitate the creation of the unit tests.
    Our main goal should be to achieve the total isolation of a component when it
    is tested. A unit test should also be fast, and we should try to avoid input/output,
    network usage, and any other operations that could potentially affect the speed
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests are used to test a set of components (partial-integration
    test) or the entire application (full-integration test). In integration, we will
    normally use known test data to feed the backend with information that will be
    displayed on the frontend. We will then assert that the displayed information
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Regression tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regression tests are used to verify that an issue has been fixed. If we are
    using TDD or BDD, whenever we encounter an issue, we should create a unit test
    that reproduces the issue before we fix the issue. By doing this, we will be able
    to reproduce past issues and ensure that we don't have to deal with the same issue
    ever again.
  prefs: []
  type: TYPE_NORMAL
- en: Performance and load tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance and load tests verify whether the application meets our performance
    expectations. We can use performance tests to verify that our application will
    be able to handle many concurrent users or activity spikes. To learn more about
    this type of test, look at [Chapter 13](2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml),
    *Application Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end (e2e) tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: End-to-end tests are not that different from full-integration tests. The main
    difference is that in an e2e testing session, we will try to emulate an environment
    that is almost identical to the real user environment. We will use Nightwatch.js
    and ChromeDriver for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: User-acceptance tests (UAT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User-acceptance tests help us to ensure that the system meets all the requirements
    of the end users.
  prefs: []
  type: TYPE_NORMAL
- en: The example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to develop an entire web application. The application
    itself is not a very realistic example, but should be realistic enough to demonstrate
    many kinds of testing practices and technologies. We are going to develop a calculator
    that can perform the `pow` operation. The calculator application is composed of
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: A graphic user interface that is implemented using React, and fetches the result
    of the `pow` operation from a web service using an HTTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web service that is implemented using Node.js and Express.js, and finds the
    result of the `pow` operation using a small math library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The application''s graphic user interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd3ea0db-790e-4a0e-9f3c-d7ab03ecb36b.png)'
  prefs: []
  type: TYPE_IMG
- en: We are going to define many different automated tasks using npm scripts. Each
    task uses different tools, and some tasks must take place before others. We could
    use a more complex setup to run some tasks in parallel and reduce the execution
    time of the whole process, or use a more realistic application, but we want to
    keep things as simple as possible to focus on the test techniques and tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to define the following tasks in our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Windows, the commands defined in the preceding code will fail
    because the relative paths use the Unix notation. You can solve this problem by
    installing Git and then installing Git Bash on Windows from [https://git-scm.com/downloads](https://git-scm.com/downloads),
    and then setting up npm to use Git Bash using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm config set script-shell "C:Program FilesGitbinbash.exe"`'
  prefs: []
  type: TYPE_NORMAL
- en: You might also need to install Python and the C++ build tools because both are
    required by the `node-sass` module.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the entire source code is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process has been designed in a way that allows us to run it entirely by
    using the `npm run all` command. This command will execute all the other tasks
    in order, as described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e61d224-ac63-4152-9d05-5e34a65b775b.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram allows us to visualize which tasks are initialized by
    a parent task. For example, the clean, install, lint, build, and test tasks are
    all started by the **all** task. The diagram also helps us to visualize the order
    in which the tasks are executed. For example, we can see that the first task is
    the **all** task and the last task is the **kill** task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now examine the purpose of each of these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The **all** task is the root task, and it is used to start other tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **clean** task removes some of the previous outputs to ensure that results
    are not influenced by any cache issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **install** task downloads all the required dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **lint** task enforces some code-styling rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **build** task starts the compilation tasks for both frontend and end-to-end
    tests. Compilation for the backend and the unit tests is not required because
    the tools used (nyc and ts-node) don't require it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **build_e2e** task compiles the e2e tests using tsc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **build_frontend** task compiles the frontend application using Webpack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **test** task runs both the unit tests with nyc and the e2e tests with Nightwatch.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **nyc** task runs the unit tests and integration tests, and generates a
    test-coverage report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **e2e** task runs the e2e tests. Before we run the e2e tests, we need to
    serve the application using a web server, and we will also need to stop serving
    the application once we are done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **start** task uses PM2 to starts the Node.js process that serves the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **nw** task stands for Nightwatch.js, and is used to execute the e2e tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **kill** task uses PM2 to stop the Node.js process that serves the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shouldn't worry too much if we don't understand what the mission is of each
    of the tasks or tools mentioned in the preceding list, because we are going to
    spend the rest of this chapter learning about them in detail, except for the clean,
    install, lint and build tasks, because we have already learned about these tasks
    in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automa**ting
    Your Development Workflow*, to learn how to generate a test-coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests and integration tests with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating Your
    Development Workflow*, we learned the basic details of the unit tests and test-coverage
    reports with nyc, ts-node, Mocha, and Chai. In this chapter, we are going to learn
    how to test asynchronous APIs using Mocha and how to combine Mocha with other
    powerful tools, such as Sinon.JS, SuperTest, and Enzyme:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to learn how to write tests for every layer of an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to start by testing a math library used in the backend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then test a web service, which consumes the math library, and a client,
    which consumes the web service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will finish the section by writing tests for the graphic user interface and
    creating some e2e tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back to basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The companion source code includes a class named `MathDemo`. This class allows
    us to perform the `pow` calculation in a few different ways. One of them is the
    synchronous `pow` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating
    Your Development Workflow*, we can test the method declared in the preceding function
    using the following test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `nyc` command with ts-node and Mocha to run our tests and
    generate a test-coverage report. In the companion source code, this is wrapped
    with npm scripts as the following command to facilitate the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes according to plan, we should see a list of all the tests
    that have been executed. The result generated by the tests that were included
    in the companion source code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bf922d0-0900-4999-a882-59206c64d969.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The command should also generate a test coverage report as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f485c5ad-6c53-4ea6-b6d4-08de7bcf0855.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have executed our tests with the `nyc` command, we can generate a test
    coverage report by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a folder named `coverage` in the current directory. The
    coverage folder contains some HTML files that we can open using a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6c95fc0-ba15-461c-aecf-3fc52a48829e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on one of the files, we will be able to see a line-by-line test
    coverage report for the selected file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/834099f2-1655-4fa3-8147-b366b458353d.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MathDemo` class also includes an asynchronous version of the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to test this method, and we don''t wait for its result, our test
    will be useless. However, if we wait for the result, using the `Promise.then`
    method, our test will also fail, unless we pass a callback (named `done` in the
    example) function to the test-case handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use async and await, as demonstrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When testing asynchronous code, Mocha will consider the test as failed (timeout)
    if it takes more than 2,000 milliseconds to invoke the `done` function. The time
    limit before a timeout can be configured, as can warnings for slow functions.
    By default, when a test takes more than 40 milliseconds, a warning will be displayed.
    The warning suggests that our test is somehow slow. If the test execution takes
    over 100 milliseconds, the warning will suggest that our test is quite slow. We
    can change this configuration using the `--timeout` command-line argument of the
    `mocha` command.
  prefs: []
  type: TYPE_NORMAL
- en: The companion source code includes examples of each kind of warning and failure.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, we have learned how to assert the type and value
    of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, there is one scenario that is perhaps not as intuitive as the previous
    one—testing for an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MathDemo` class also contains a method named `bad`, which was added with
    the sole purpose of illustrating how to test for an exception. The `bad` method
    throws an exception when it is invoked with a `null` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following test, we can see how we can use the `expect` API to assert
    that an exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you wish to learn more about assertions, visit the Chai official documentation
    available at [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  prefs: []
  type: TYPE_NORMAL
- en: Testing a web service with SuperTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The demo application included in the companion source code declares a web service
    that allows us to get the result of the `pow` calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization of the application is separated into two files: `main.ts`
    and `server.ts`. The `server.ts` file defines the `getApp` function that we have
    examined in the preceding code snippet. The `main.ts` file uses the `getApp` function
    to start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is a good idea to test a web service as a whole in what is known
    as integration tests. As we learned earlier in this chapter, integration tests
    are used to test a set of components. In this case, we are going to test the server-side
    route handlers and their usage of the `MathDemo` class. We can define a test for
    the `pow` service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, we have used a function named `getApp`
    to get the instance of the Express.js app. Once we have the app instance, we can
    use the request method from the `supertest` module to send a request to the service.
    We can use SuperTest together with Chai to assert that the response of the request
    matches an expected result. It is important to mention that the `getApp` function
    creates an app, but it doesn't launch the app. Or, in other words, the `getApp` function
    avoids invoking the `app.listen` method.
  prefs: []
  type: TYPE_NORMAL
- en: Working with tests suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A test suite is a group of test cases. We have already learned that we can
    use the `describe` function from Mocha to define a test suite and the `it` function
    to define a test case. However, we have not learned that we can define event handlers
    that can be invoked before and after all the tests in a test suite. The following
    code snippet demonstrates how we can define these event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be useful if we want to reuse some of the initialization logic across
    multiple test cases. For example, we can rewrite the example that we used to test
    a web service earlier in the preceding section, in a way that will allow us to
    share the Express.js application instance across multiple test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Usually, testing frameworks (regardless of the language we are working with)
    won't allow us to control the order in which the unit tests and test suites are
    executed. The tests can even be executed in parallel by using multiple threads.
    For this reason, it is important to ensure that the unit tests in our test suites
    are independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating components with Sinon.JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that unit tests are used to test individual components, and
    integration tests are used to test a set of components and their interactions.
    When we write a unit test, and a component has a dependency on another, we will
    need to provide stubs, mocks, or dummies instead of real dependencies to ensure
    that the component is being tested in isolation. However, sometimes this can be
    more complicated than it sounds. Luckily, Sinon.JS can help us to ensure that
    our components are tested in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is used to test the web client of the `pow` web
    service that we described earlier in this chapter. We use Sinon.JS to define a
    stub for a global object named `fetch`. The `fetch` global object is a function
    that allows us to send an AJAX request to the backend from the frontend. Replacing
    the `fetch` object with a stub is a good idea because it will help us to ensure
    that the client class is not interacting with the backend, and, thus, that it
    is tested in complete isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using a global is a bad idea because it goes against the dependency inversion
    principle and makes our applications harder to test. Fortunately, Sinon.JS can
    help us to overcome this kind of difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml), *Working with
    Dependencies*, to learn more about dependency inversion and its underlying principles.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that the stubs provide us with an API that can help
    us to check things, such as the number of times that the stub was used or which
    arguments were passed to it. This was demonstrated by the last assertion in the
    preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: jsdom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some testing tools, such as Enzyme (we will learn about this in the following
    section), expect to be used in a web browser. In our example, the application
    uses nyc and ts-node to execute all our unit tests, which means that we are not
    using a web browser. Sometimes, it is possible to overcome this problem by using
    jsdom, which is described by its creators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"jsdom is a pure-JavaScript implementation of many web standards, notably the
    WHATWG DOM and HTML Standards, for use with Node.js. In general, the goal of the
    project is to emulate enough of a subset of a web browser to be useful for testing
    and scraping real-world web applications."'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we examine the `nyc` command in the `package.json` file included in the
    companion source code, we will see that one of the arguments provided to the nyc
    binary is `--require ./jsdom.js`. This will force Mocha to need the `jsdom.js`
    file before any tests are executed. The `jsdom.js` file is used to initialize
    jsdom, and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file creates a few global variables that allow us to run the backend
    code that was originally designed to be executed in a web browser. In the Node.js
    execution environment, we don't have certain variables, such as the window variable.
    The preceding code snippet initializes all the required variables to enable the
    execution of frontend code in our backend execution environment (Node.js). This
    is useful, for example, when we want to write a test for a frontend component
    because we can execute our tests without the need for a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the Enzyme documentation at [https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md](https://github.com/airbnb/enzyme/blob/master/docs/guides/jsdom.md)
    to learn more about the jsdom configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Testing React web components with Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have tested the backend of our application using both unit
    tests and integration tests (with SuperTest). We have also tested our client in
    complete isolation, thanks to the usage of Sinon.JS. However, our application
    can still fail if something is wrong in the presentation layer (the graphic user
    interface). In this section, we are going to learn how we can use some libraries
    to help us to test each of the components of our graphic user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about React.
  prefs: []
  type: TYPE_NORMAL
- en: 'The companion source code includes the following React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned earlier in this chapter, the preceding component will display
    a web form on the screen. The users of the application need to provide two numbers
    (`base` and `exponent`) as inputs. The input is then sent to a web service in
    the backend, and the response is displayed as a result. The following code snippet
    demonstrates how we can isolate the preceding component from the HTTP client using
    a stub. The code snippet also demonstrates how we can configure Enzyme to work
    with version 16 of React and then use it to simulate user events, such as clicking
    on an element or typing in an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding tests insert a value for the base and exponent inputs and then
    click on the Submit button. This will invoke the web client, which has been replaced
    by a stub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enzyme has been designed to work with React. However, each major version of
    React requires a specific adapter. Other frameworks might require other libraries.
    For example, in Angular, we can use the utilities provided by the `@angular/core/testing`
    module to do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the documentation at [https://angular.io/api/core/testing](https://angular.io/api/core/testing)
    to learn more about testing in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: TDD versus BDD with Mocha and Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen, TDD and BDD follow many of the same principles, but
    have some differences in their style. While these two styles provide the same
    functionality, BDD is considered to be easier to read by many developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table compares the naming and style of the suites, tests, and
    assertions used by the TDD and BBD styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **TDD** | **BDD** |'
  prefs: []
  type: TYPE_TB
- en: '| `suite` | `describe` |'
  prefs: []
  type: TYPE_TB
- en: '| `setup` | `before` |'
  prefs: []
  type: TYPE_TB
- en: '| `teardown` | `after` |'
  prefs: []
  type: TYPE_TB
- en: '| `suiteSetup` | `beforeEach` |'
  prefs: []
  type: TYPE_TB
- en: '| `suiteTeardown` | `afterEach` |'
  prefs: []
  type: TYPE_TB
- en: '| `test` | `it` |'
  prefs: []
  type: TYPE_TB
- en: '| `assert.equal(math.PI, 3.14159265359);` | `expect(math.PI).to.equals(3.14159265359);`
    |'
  prefs: []
  type: TYPE_TB
- en: End-to-end tests with Nightwatch.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing an e2e test with Nightwatch.js is very simple because its API is very
    readable. We should be able to read an e2e test and be able to understand it,
    even if it is the first time that we see one. For example, the following is an
    example of an e2e test that is used to test the application included in the companion
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We use the `NightwatchBrowser` instance to navigate to a URL, wait for a few
    elements to be visible, set the value of a few inputs, and then click on the Submit
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the e2e tests API is very simple, the process behind it is not so simple.
    If we examine the `npm script` commands in the `package.json` file included in
    the companion source code, we will be able to observe that the command triggers
    four other commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile the e2e tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the e2e tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kill the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first command uses PM2 and ts-node to run the application. PM2 is a very
    powerful process management tool that allows us to run a Node.js app as a cluster
    and to monitor it. However, this is not why we are using it here. We use PM2 because
    it is a very easy way to run the application as a background process. We need
    to run the entire application before our e2e tests are executed. The problem is
    that when the app starts waiting for HTTP requests, it blocks all the subsequent
    commands. PM2 solves this problem by allowing us to run the app in a background
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing worth mentioning is that our e2e tests are browser-independent.
    This explains why Nightwatch.js requires us to configure a driver. The driver
    provides native access to the web browser that will execute the e2e tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the demo application, we are using ChromeDriver. We have created a file named
    `globals.js` that is used to define some global events that will be executed before
    and after our e2e tests. The event handlers are very similar to the ones that
    we learned about while defining a test suite with Mocha earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the event handlers declared in the `globals.js` file to create and destroy
    instances of `chromedriver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The version of the `chromedriver` npm module used in this example is 2.36.0\.
    This version has been tested with Google Chrome 65.0\. If you are using a later
    version of Google Chrome, please ensure that you also upgrade the `chromedriver`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a file named Nightwatch.js that contains the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, we are configuring ChromeDriver
    to use the `globals.js` events and Google Chrome as the web browser to be used
    to run our tests. We have also configured Nightwatch.js to look for our test under
    the `dist` folder. Nightwatch.js cannot understand TypeScript natively, which
    explains why we need to compile the tests into the `dist` folder before we can
    run them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define a second `tsconfig.json` file named `tsconfig.e2e.json` with
    some additional options to ensure that we only compile the required files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the `extends` filed in the `tsconfig.json` file allows us to
    inherit all the settings from a previously declared `tsconfig.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, we should be able to see results like the following
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cabd2d8-73ef-49f6-935d-0161d5146026.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed some core testing concepts, such as stubs, suites,
    and more. We also looked at the test-driven development and behavior-driven development
    approaches, and how to work with some of the leading JavaScript testing frameworks,
    such as Mocha, Chai, Sinon.JS, Enzyme, SuperTest, and Nightwatch.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use the TypeScript language services
    to create our development tools.
  prefs: []
  type: TYPE_NORMAL
