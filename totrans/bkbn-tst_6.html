<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Automated Web Testing</h1></div></div></div><p>Having finished discussing the substantive techniques for testing Backbone.js applications, we will now look into various means of automating our test infrastructure. The ability to programmatically run our test collection enables new and exciting use cases beyond a single developer manually running a test driver page during development. In this chapter we will explore the following automation and development topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Surveying scenarios and motivations for automating our test infrastructure</li><li class="listitem" style="list-style-type: disc">Investigating different approaches for programmatically running a Backbone.js application test suite</li><li class="listitem" style="list-style-type: disc">Introducing PhantomJS and adapter tools for frontend testing</li><li class="listitem" style="list-style-type: disc">Integrating our existing test infrastructure into the PhantomJS environment</li><li class="listitem" style="list-style-type: disc">Concluding our discussion on the principles and practices of Backbone.js application testing with suggestions and resources for the next steps after finishing this book</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>The world of testing beyond humans and browsers</h1></div></div></div><p>Up to this point, our<a id="id489" class="indexterm"/> test development workflow has comprised writing test suites, adding them to a test driver page, and firing up the test page in a web browser on a development computer. However, test infrastructures can be used in far more scenarios than just manually running web reports. Examining the ensuing use cases, we will see how automatically running our test collection in arbitrary environments (for example, from a command line or build script, and possibly without a web browser) has enormous potential for the application development process.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Continuous integration</h2></div></div></div><p>In collaborative software <a id="id490" class="indexterm"/>development, problems can arise when engineers develop code separately that they later merge into a common code base. Unforeseen interactions between the changes can cause integration errors, breaking the overall application.</p><p>One mitigation <a id="id491" class="indexterm"/>approach for such errors is continuous integration, which relies extensively on automated testing. Continuous integration aggregates and tests application code to detect integration errors early and automatically. For an in-depth introduction on the topic, see <em>Continuous Integration</em> by <em>Martin Fowler</em> at <a class="ulink" href="http://martinfowler.com/articles/continuousIntegration.html">http://martinfowler.com/articles/continuousIntegration.html</a>.</p><p>The process of continuous integration is typically implemented using a dedicated server that incrementally gathers code changes, creates a clean application environment, runs build commands, and acts on the command outputs. For instance, let's say we have a Node.js application stored on <a id="id492" class="indexterm"/>GitHub. A continuous integration server could download code changes from GitHub, create a new build directory for the application, install package dependencies (for example, <code class="literal">npm install</code>), and run the tests (for example, <code class="literal">npm test</code>). If any of the tests fail, the server will notify the developer(s) responsible for the changes. Some prevalent continuous integration servers include<a id="id493" class="indexterm"/> Jenkins <a id="id494" class="indexterm"/>(<a class="ulink" href="http://jenkins-ci.org/">http://jenkins-ci.org/</a>) and<a id="id495" class="indexterm"/> Travis<a id="id496" class="indexterm"/> (<a class="ulink" href="https://travis-ci.org/">https://travis-ci.org/</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Continuous deployment</h2></div></div></div><p>A continuous deployment server<a id="id497" class="indexterm"/> is an <a id="id498" class="indexterm"/>enhancement of a continuous integration<a id="id499" class="indexterm"/> server that additionally deploys code to a live application environment (for example, production) if all the tests pass. It relies on automated tests to validate the entire application, so that code changes can be pushed out as fast as possible while retaining at least some semblance of quality assurance. The article <em>Why Continuous Deployment?</em> by <em>Eric Ries</em> at <a class="ulink" href="http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html">http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html</a> is a good starting point for the motivations and practices behind continuous deployment.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Other scenarios</h2></div></div></div><p>Test automation enables many other useful applications. For example, development utilities called <strong>watchers</strong>
<a id="id500" class="indexterm"/> or <strong>guards</strong>
<a id="id501" class="indexterm"/> check code periodically for modifications and perform further actions when the files change. Watchers are regularly used on a development machine to automatically run tests and display alerts when code changes have broken one or more tests, so that developers can discover errors quickly and effortlessly.</p><p>
<strong>Cross-browser testing</strong>
<a id="id502" class="indexterm"/> is another area made easier through automation. While a programmer can manually run a test collection on many different target browsers, this is often time consuming, error prone, and boring. Fortunately, there are testing tools that can programmatically run tests on a number of arbitrary web browsers without human interaction.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Automating browser environments</h1></div></div></div><p>Having introduced <a id="id503" class="indexterm"/>some motivating use cases, we now turn to the nuts and bolts of automating our test infrastructure. We will cover the following techniques for programmatically driving our Backbone.js tests:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Remote controlling tests in a real web browser</li><li class="listitem" style="list-style-type: disc">Running tests in a browser simulation library</li><li class="listitem" style="list-style-type: disc">Executing tests in a headless web browser environment</li><li class="listitem" style="list-style-type: disc">Combining the first three approaches</li></ul></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Remote controlled web browsers</h2></div></div></div><p>The most comprehensive <a id="id504" class="indexterm"/>automation technique is to remotely control a web browser. Remote control means that a program does what a human can do using a <em>real</em> web browser—opening the browser to a given page, clicking on links, filling in inputs, and so on.</p><p>One of the most popular remote control frameworks is <a id="id505" class="indexterm"/>
<strong>Selenium</strong> (<a class="ulink" href="http://docs.seleniumhq.org/">http://docs.seleniumhq.org/</a>). Selenium <a id="id506" class="indexterm"/>provides many <a id="id507" class="indexterm"/>
<strong>web drivers</strong>, which are programmatic adapters that hook into a real web browser and trigger actions through the normal user interface. Selenium supports a diverse array of environments, providing web drivers on different operating systems for various browsers, including Chrome, Safari, Firefox, and Internet Explorer.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>The Selenium project encompasses more features and functionality than just browser remote control. Notably, Selenium can use other test execution approaches, including headless web tools such as <a id="id508" class="indexterm"/>PhantomJS. See the Selenium projects page (<a class="ulink" href="http://docs.seleniumhq.org/projects/">http://docs.seleniumhq.org/projects/</a>) and the web driver list (<a class="ulink" href="http://docs.seleniumhq.org/projects/webdriver/">http://docs.seleniumhq.org/projects/webdriver/</a>) for starting points and additional information.</p></div></div><p>Automating our test infrastructure with a remote control tool such as Selenium involves two basic steps: open and run the test driver page and then, infer whether or not the tests have passed. As an example, we could write a Selenium script that opens a browser window to the Notes application test driver page <code class="literal">notes/test/test.html</code> in the code samples. The Selenium script could then scrape the report page HTML to check for a telltale string such as <code class="literal">failures: 0</code> in the DOM and terminate the script with an appropriate success/failure exit code.</p><p>Thus, remote-controlled <a id="id509" class="indexterm"/>tools such as Selenium<a id="id510" class="indexterm"/> are quite powerful because they can do anything a real browser can do, just automatically. And, with a cross-platform compatible tool such as Selenium, we can run tests on nearly all modern browser/operating system combinations from a single script.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>
<strong>Hosted test automation providers</strong>
</p><p>Capitalizing on<a id="id511" class="indexterm"/> Selenium's broad test environment support, vendors now offer services that allow users to upload a Selenium test script, designate a desired array of operating system/browser configurations, and have the service run and return test reports. One such vendor is Sauce Labs<a id="id512" class="indexterm"/> (<a class="ulink" href="https://saucelabs.com/">https://saucelabs.com/</a>), which<a id="id513" class="indexterm"/> runs user scripts on virtual machines with various Selenium-supported test environments. Hosted services such as these are often the quickest way to get broad browser compatibility coverage with minimum developer effort.</p></div></div><p>The remote controlled approach does have a few downsides, the first of which is that the test tools can be relatively slow. Scripts can take seconds or even minutes to hook into a target browser and run a test driver page. Additionally, these frameworks require a real web browser and a desktop windowing system. This can be an issue for build/continuous integrations that are headless, meaning they have no graphical user interface or window environment installed by default.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Simulated browser environments</h2></div></div></div><p>An alternative automation<a id="id514" class="indexterm"/> approach is to replace the web browser with a test-friendly simulation of the browser environment and state. Typically, browser simulation libraries provide implementations of the JavaScript API within a browser such as DOM objects (for example, <code class="literal">window</code> and <code class="literal">document</code>), CSS selectors, and JSON interfaces.</p><p>
<strong>JSDom</strong>
<a id="id515" class="indexterm"/> (<a class="ulink" href="https://github.com/tmpvar/jsdom">https://github.com/tmpvar/jsdom</a>) is <a id="id516" class="indexterm"/>a prevalent simulation library that provides a fairly complete browser environment. JSDom is written in JavaScript and packaged as a Node.js module. Because Node.js can be easily scripted, JSDom offers us a good starting point for integrating and running Backbone.js tests from the command line.</p><p>Test automation is such a common use case that several test-friendly libraries have been written around JSDom. One such library is <a id="id517" class="indexterm"/>Zombie.js<a id="id518" class="indexterm"/> (<a class="ulink" href="http://zombie.labnotes.org/">http://zombie.labnotes.org/</a>), which provides convenient browser abstractions and integration with various test frameworks, including Mocha. Using a library such as Zombie.js, we could write a Node.js script that creates a fake browser simulation, navigates to our Backbone.js test driver page, and scrapes the test result HTML to check if any tests failed. For a more in-depth treatment of testing JavaScript web applications with Zombie.js and Mocha, see <em>Using Node.js for UI Testing</em> by <em>Pedro Teixeira</em> (<a class="ulink" href="http://www.packtpub.com/testing-nodejs-web-uis/book">http://www.packtpub.com/testing-nodejs-web-uis/book</a>).</p><p>Browser simulation libraries <a id="id519" class="indexterm"/>are fast because they run simulation code in the same underlying JavaScript engine as the test code without external dependencies (for example, on a real web browser executable). Simulation libraries are often quite extensible, as the simulation JavaScript code runs in the same process as the application and the tests.</p><p>However, simulations suffer from a few key drawbacks. One primary issue is that simulations can deviate from the true environment in a real web browser. Complicated browser interactions such as heavily chained event triggers or complex DOM manipulations can potentially break the simulation or behave differently than a real browser. Additionally, a browser simulation library provides only a single browser environment implementation and thus cannot test the quirks and differences across various real web browsers.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Headless web browsers</h2></div></div></div><p>Between remote <a id="id520" class="indexterm"/>controlled browsers and simulation libraries are headless web browsers. A headless browser takes a real web browser and gets rid of the user interface, leaving only the JavaScript engine and environment. What remains is a command line tool that can navigate to web pages, execute JavaScript within the browser environment, and communicate through non-graphical interfaces such as alerts and console logging.</p><p>One of the most popular headless toolkits<a id="id521" class="indexterm"/> is PhantomJS<a id="id522" class="indexterm"/> (<a class="ulink" href="http://phantomjs.org/">http://phantomjs.org/</a>), which is based on the <strong>WebKit</strong>
<a id="id523" class="indexterm"/> open source browser <a id="id524" class="indexterm"/>(<a class="ulink" href="http://www.webkit.org/">http://www.webkit.org/</a>) that powers browsers such as Safari<a id="id525" class="indexterm"/>. PhantomJS enhances WebKit with scripting support and a JavaScript API.</p><p>Integrating Backbone.js application tests with a headless browser is analogous to configuring a remote-controlled browser. Conveniently, PhantomJS ships with native support for a wide array of test infrastructures and offers third-party adapters for many others. See <a class="ulink" href="https://github.com/ariya/phantomjs/wiki/Headless-Testing">https://github.com/ariya/phantomjs/wiki/Headless-Testing</a> for more test support details.</p><p>Headless web tools have a mix of some of the best features of the previous automation approaches, including the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Headless<a id="id526" class="indexterm"/> JavaScript engines are often faster than remote control frameworks</li><li class="listitem" style="list-style-type: disc">The browser environment is <em>real</em>, which avoids some of the API and correctness issues potentially found in browser simulations</li><li class="listitem" style="list-style-type: disc">Headless frameworks are usually easy to install and can be run on servers without a windowing environment</li></ul></div><p>At the same time, headless browsers incur some performance penalties from starting up and running the browser engine. They also forgo cross-browser capabilities, because headless tools are tied to a specific web browser engine implementation. Considering the overall advantages and disadvantages, headless frameworks provide a good compromise between the many mutually exclusive automation features.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Multiple environment aggregators</h2></div></div></div><p>Capitalizing on the <a id="id527" class="indexterm"/>benefits of various approaches, many frameworks aggregate different automation schemes into a single package. For example, the following test frameworks can programmatically drive tests in major web browsers <em>and</em> PhantomJS:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Testem</strong><a id="id528" class="indexterm"/> (<a class="ulink" href="https://github.com/airportyh/testem">https://github.com/airportyh/testem</a>)</li><li class="listitem" style="list-style-type: disc"><strong>Karma</strong><a id="id529" class="indexterm"/> (<a class="ulink" href="http://karma-runner.github.io/">http://karma-runner.github.io/</a>)</li></ul></div><p>Aggregation frameworks are desirable because they allow a single test collection to be reused in different automation environments, although some tools are more difficult to set up and maintain than a single automation tool.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Headless testing with PhantomJS</h1></div></div></div><p>As a concrete automation example, we <a id="id530" class="indexterm"/>will adapt our existing Backbone.js <a id="id531" class="indexterm"/>test infrastructure to use PhantomJS. PhantomJS offers an amenable set of features and capabilities for Backbone.js testing—it is fast, relatively easy to set up, and provides a real (headless) browser. As a practical matter, larger Backbone.js applications often require a real browser engine to function properly, particularly applications that exercise the murkier and more complicated parts of the browser environment.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Installing PhantomJS and the supporting tools</h2></div></div></div><p>To get up and <a id="id532" class="indexterm"/>running with <a id="id533" class="indexterm"/>PhantomJS, let's start by installing the toolkit as per the instructions at <a class="ulink" href="http://phantomjs.org/download.html">http://phantomjs.org/download.html</a>. Note that the installation procedures are operating system dependent, with packages for Windows, Mac OS X, and Linux. Alternatively, PhantomJS can be installed directly with NPM using the <code class="literal">phantomjs</code> Node.js wrapper (<a class="ulink" href="https://github.com/Obvious/phantomjs">https://github.com/Obvious/phantomjs</a>).</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>We provide command line examples in this section from a UNIX-like operating system such as Linux and Mac OS X. At the same time, PhantomJS and Node.js have first class support on Windows, so the ensuing examples should be mostly analogous to what will work on Windows.</p></div></div><p>Once installation is complete, you can verify that the PhantomJS binary is available:</p><div><pre class="programlisting">
<strong>$ phantomjs --help</strong>
</pre></div><p>With PhantomJS in place, we next turn to the Mocha-PhantomJS bridge library. Mocha-PhantomJS uses PhantomJS to run a Mocha test driver page and transform the test results into formatted command line output. The library throws proper errors on test failures, making it quite useful for scripting. See the online documentation at <a class="ulink" href="http://metaskills.net/mocha-phantomjs/">http://metaskills.net/mocha-phantomjs/</a> for additional capabilities and details.</p><p>To install Mocha-PhantomJS, you need the Node.js framework, which can be obtained by following the instructions at <a class="ulink" href="http://nodejs.org/download/">http://nodejs.org/download/</a>. A modern Node.js installation includes the NPM package manager tool used for Mocha-PhantomJS. We can confirm that Node.js and the package manager are correctly installed with the following commands:</p><div><pre class="programlisting">
<strong>$ node --help</strong>
<strong>$ npm --help</strong>
</pre></div><p>Next, install Mocha-PhantomJS with the global NPM flag (<code class="literal">-g</code>) to make the <code class="literal">mocha-phantomjs</code> binary available anywhere in a shell:</p><div><pre class="programlisting">
<strong>$ npm install -g mocha-phantomjs</strong>
</pre></div><p>After NPM finishes the installation, check whether Mocha-PhantomJS is available with the following command:</p><div><pre class="programlisting">
<strong>$ mocha-phantomjs --help</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Running Backbone.js tests with PhantomJS</h2></div></div></div><p>With the necessary tools<a id="id534" class="indexterm"/> installed, we can now adapt our <a id="id535" class="indexterm"/>Backbone.js test infrastructure to run against PhantomJS. Mocha-PhantomJS provides a replacement proxy object, <code class="literal">mochaPhantomJS</code>, to control Mocha tests and reports. We just need to replace the real <code class="literal">mocha</code> object where <code class="literal">mocha.run()</code> is normally called in the test driver web page. Inserting the following code snippet into the test driver page will allow Mocha to run <em>both</em> in a real browser and with PhantomJS:</p><div><pre class="programlisting">&lt;!-- Test Setup --&gt;
&lt;script&gt;
  var expect = chai.expect;
  mocha.setup("bdd");

  window.onload = function () {
    <strong>(window.mochaPhantomJS || mocha).run()</strong>;
  };
&lt;/script&gt;</pre></div><p>Once we have modified the test driver page with the <code class="literal">(window.mochaPhantomJS || mocha).run()</code> function call, we can execute the page tests with Mocha-PhantomJS. For example, if we modify the Notes<a id="id536" class="indexterm"/> application test driver file <code class="literal">chapters/05/test/test.html</code> from the previous chapter with the <code class="literal">mochaPhantomJS</code> change, we can run the file and generate the following command line report:</p><div><pre class="programlisting">
<strong>$ mocha-phantomjs chapters/05/test/test.html</strong>


<strong>  App.Views.NotesItem</strong>
<strong>    remove</strong>
<strong>√ is removed on model destroy</strong>
<strong>    render</strong>
<strong>√ renders on model change w/ stub</strong>
<strong>√ renders on model change w/ mock</strong>
<strong>    DOM</strong>
<strong>√ renders data to HTML</strong>
<strong>    actions</strong>
<strong>√ views on click</strong>
<strong>√ edits on click</strong>
<strong>√ deletes on click</strong>
<strong>  App.Routers.Router</strong>
<strong>√ can route to note</strong>
<strong>√ can route around</strong>

<strong>  9 tests complete (39 ms)</strong>
</pre></div><p>Reviewing this<a id="id537" class="indexterm"/> report, we can see that all of our tests <a id="id538" class="indexterm"/>passed, and that the PhantomJS test run was quite fast, clocking in at 39 milliseconds. With these modest test driver web page changes, we can run nearly any test web page from the command line or a build script using PhantomJS.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Automating tests in the code samples</h2></div></div></div><p>Putting these<a id="id539" class="indexterm"/> suggested principles into practice, nearly <a id="id540" class="indexterm"/>all of the test code samples presented in this book are scripted to run from the command line under PhantomJS. If you review the downloadable code samples repository, you will notice that all of the chapter and application test pages actually use the <code class="literal">(window.mochaPhantomJS || mocha).run()</code> function call instead of a raw <code class="literal">mocha.run()</code> statement.</p><p>The integration of PhantomJS into the code samples provides a practical starting point for some of the automated testing use cases that we discussed earlier in this chapter. Specifically, the examples implement the following automation scenarios:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Command line tests</strong>: The code <a id="id541" class="indexterm"/>samples contain a Node.js NPM <code class="literal">package.json</code> file with script commands that can run chapter and application test driver pages with PhantomJS.</li><li class="listitem" style="list-style-type: disc"><strong>Continuous integration server</strong>: The GitHub repository for the code samples (<a class="ulink" href="https://github.com/ryan-roemer/backbone-testing/">https://github.com/ryan-roemer/backbone-testing/</a>) uses the Travis continuous integration<a id="id542" class="indexterm"/> server for automated failure alerts. Travis is configured to run all of the example tests with PhantomJS on every code change. Travis is a particularly good choice for a test infrastructure such as the one presented in this book because its build environment already contains PhantomJS and it is quite amenable to Node.js and NPM modules such as Mocha-PhantomJS. To see all of this in action, you can navigate a browser to <a class="ulink" href="https://travis-ci.org/ryan-roemer/backbone-testing">https://travis-ci.org/ryan-roemer/backbone-testing</a> at any time to check out the live build status for all of the code we have discussed in this book. (Hopefully you will find that all of our tests are passing!)</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Parting thoughts, next steps, and future ideas</h1></div></div></div><p>We are now at the end of our journey through the fundamentals of testing Backbone.js applications with Mocha, Chai, and Sinon.JS. We have explored the background, configuration, and use of each of these test frameworks and tried out a number of complementary tools and helpers. We have reviewed Backbone.js application development, specific component testing goals, and written test collections around a full Backbone.js application. So, what comes next?</p><p>Our first suggestion is to review the online documentation for the various testing technologies. The official APIs and guides for all of the frameworks we use in the book are quite good and can provide starting points for more complicated test scenarios that may arise in real-world Backbone.js application development. As a refresher, the documentation sites for our core test stack include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mocha</strong>: <a id="id543" class="indexterm"/><a class="ulink" href="http://visionmedia.github.io/mocha/">http://visionmedia.github.io/mocha/</a></li><li class="listitem" style="list-style-type: disc"><strong>Chai</strong>: <a id="id544" class="indexterm"/><a class="ulink" href="http://chaijs.com/">http://chaijs.com/</a></li><li class="listitem" style="list-style-type: disc"><strong>Sinon.JS</strong>: <a id="id545" class="indexterm"/><a class="ulink" href="http://sinonjs.org/">http://sinonjs.org/</a></li></ul></div><p>After the framework documentation, you can review the article, blog, and book suggestions that we have provided throughout this book. In particular, the references in <a class="link" href="ch02.html" title="Chapter 2. Creating a Backbone.js Application Test Plan">Chapter 2</a>, <em>Creating a Backbone.js Application Test Plan</em> on general test methodology and Backbone.js testing are great resources for those seeking a broader background in the software development and testing techniques appropriate for larger-scale Backbone.js applications.</p><p>Finally, we suggest that you download and install the book code samples. These samples are essentially the practical application of the principles we have covered in this book, with useful applications, tests, and files put together in a single package. Additionally, they provide examples of more testing and automation techniques<a id="id546" class="indexterm"/> for you to explore on your own, including the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Style checking</strong>: JavaScript style <a id="id547" class="indexterm"/>checkers automatically analyze source files to find language or convention errors. Checkers are invaluable during software development, often finding programming errors early on and in places that tests can miss. Additionally, style checkers can enforce consistent coding styles for all members of a team working on a single application. The code samples use JSHint<a id="id548" class="indexterm"/> (<a class="ulink" href="http://www.jshint.com/">http://www.jshint.com/</a>) to check all of the application and test examples that we have discussed in this book. You can inspect the <code class="literal">package.json</code> file in the code samples to see our JSHint usage in the script commands <code class="literal">style</code>, <code class="literal">style-server</code>, and <code class="literal">style-client</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Code coverage</strong>: Code coverage is a <a id="id549" class="indexterm"/>technique to quantify how much of an application is actually exercised by tests. Coverage tools run behind the scenes during tests, recording which application code lines are executed, and provide a report that measures the lines covered in each application file. The code samples provide a test driver page for the Notes application at <code class="literal">notes/test/coverage.html</code> that uses <strong>Blanket.js</strong><a id="id550" class="indexterm"/> (<a class="ulink" href="http://blanketjs.org/">http://blanketjs.org/</a>) to provide a coverage report. You can run the Notes test and the coverage report online at <a class="ulink" href="http://backbone-testing.com/notes/test/coverage.html">http://backbone-testing.com/notes/test/coverage.html</a>.</li></ul></div><p>The rest is left up to you. <a id="id551" class="indexterm"/>While we are at the end of the road for this book, the world of testing will keep pushing forward in new and interesting ways. We bid you good luck in your continued learning and discovery of more testing tools, methods, and topics for Backbone.js application development.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we have learned how to remove manual browser interaction from the test process with an introduction to test automation approaches and use cases. We have investigated different tools to drive our tests from the command line and worked through a concrete test automation implementation using PhantomJS to drive our Backbone.js application tests.</p><p>Also, we left with a few final thoughts on the principles that we have developed throughout the course of this book and where to turn next. Hopefully, you now have the fundamentals and direction to create your own Backbone.js test infrastructures, apply good test-driven application development practices, and tackle your frontend tests with confidence.</p></div></body></html>