- en: Chapter 5. Its All About the View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI layer, or **View**, is the most visible component of any application.
    No matter what is going on underneath the hood, be it REST, Websockets, MQTT,
    or SOAP, the view is where everything culminates for a full, interactive application
    experience. Just as with the server side, the view has its own set of complexities
    and myriad of architectural choices to make from a development perspective. We
    will now explore some of these choices along with some different design patterns
    that can be used in the all-encompassing view layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following images:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences among various JavaScript templating engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of precompiling JavaScript templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to optimize your application layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript templating engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining the view on the frontend of your application goes a long way toward
    keeping it server-side agnostic. Even if you are using a MVC framework underneath
    to serve REST endpoints for your application, keeping the view templates and logic
    on the frontend will ensure that you can more easily swap out the MVC backend
    in the future without significantly altering the logical and architectural structure
    of your application. JavaScript templating engines provide an effective way to
    manage view templates entirely on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many open source JavaScript templating engines available. Next, we
    will cover the basics of some of the more popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Underscore.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mustache.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlebars.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscore.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Underscore.js** library is well known for its useful JavaScript functional
    programming helpers and utility methods. One of those utility methods is `_.template()`.
    This method is used to compile strings with expressions into functions that replace
    those expressions with dynamic values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underscore.js template syntax delimiters resemble those of the **ERB**, or
    **Embedded Ruby** template syntax, with an **equals** sign following the opening
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An Underscore.js template expression used within HTML looks like the preceding
    example. The variable name would be dynamically passed in to the compiled function
    for this template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_.template()` method can also be used to parse and execute arbitrary JavaScript
    code within a template. JavaScript code within Underscore.js templates is delimited
    by using the ERB style tags *without* an equals sign following the opening tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, the ERB tags within the template give the script
    access to the global `_` object and allow it to iterate over a given object or
    array contained in that context or even up the scope chain from that context using
    the library's `_.each()` method. The fact that the script has access to the `_`
    object shows that any global variable attached to the `window` namespace is available
    to the script.
  prefs: []
  type: TYPE_NORMAL
- en: Giving templates the ability to execute arbitrary JavaScript code is a subject
    that has met with much debate in the community, and the general consensus is that
    the practice is frowned upon. This is due to the lessons learned from other web
    scripting languages, such as PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing code for dynamic business logic with HTML directly in your templates
    can lead to a codebase that is difficult to maintain and debug by other developers
    and future generations. This type of code also violates the principles of MVC
    and MVW architectural patterns. It should go without saying that it is up to the
    developer writing the code how much or how little business logic they choose to
    include in their templates, but for the creators of many JavaScript templating
    engines, leaving that door open was not an option. For these reasons, the concept
    of *logic-less* templates was born.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Underscore.js at `underscorejs.org`.
  prefs: []
  type: TYPE_NORMAL
- en: Mustache.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mustache.js** is an implementation of the popular **Mustache template system**
    for JavaScript templating. Mustache touts itself as a *logic-less* template syntax.
    The idea behind this concept is not necessarily to have templates completely void
    of logic, but more to discourage the practice of including a large amount of business
    logic within your templates.'
  prefs: []
  type: TYPE_NORMAL
- en: Mustache gets its name from the use of double curly braces, which resemble the
    shape of a mustache, as the default delimiter tags for templates. The major difference
    between Mustache templates and Underscore.js templates is that Mustache does not
    allow for the placement of arbitrary JavaScript within an alternate form of its
    tags; it only allows for expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, a Mustache template maps values from a JavaScript object
    directly to their respective template expressions, represented by the keys for
    those object values. Take an object such as the one shown here, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The values from this object can be represented in a Mustache template like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, you can see that even nested object values can be accessed
    by using JavaScript dot notation, as shown with `{{name.first}}` and `{{name.last}}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mustache templates also include the ability to render *sections*, or *blocks
    of text*. This involves using an alternate expression syntax that includes an
    opening and closing tag syntax. How a section is rendered depends on the value
    of the key being called for it.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given a Boolean value, a section will render or not render depending on if
    that Boolean is `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The delimiter syntax for sections consists of opening curly braces followed
    by the pound `#` symbol and the name of the property to start the section, and
    closing curly braces followed by the `/` symbol and the property name to end the
    section. This syntax is similar to HTML opening and closing tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `email_subscriber` property is set to false, so the template
    would render the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, the use of a section with a Boolean value is equivalent to an `if`
    conditional statement. Such a use case does indeed include logic, though in its
    most basic form. In this way, the term *logic-less* is proven to not be as stringent
    as it may initially be perceived.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Additionally, sections can be used to iterate over a list of items set as the
    value for a given object key. Within a section, the context, or variable scope,
    is shifted to that of the key that is being iterated over. Take the following
    parent key and corresponding list of values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a list of people and their names, a section can be used to render each
    person''s name in an HTML unordered list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This template code would render the following HTML, given the preceding example
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Lambdas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Object property values can also be returned from *lambdas*, or functions that
    are passed to return values as data, to the current section''s context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a list, a lambda will return a value based on the context of
    the current list item for an iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this manner, the preceding template will produce the same output as the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inverted sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An inverted section in a Mustache template is one that is rendered only when
    the value for that section''s key is `false` or *falsy*, such as `null`, `undefined`,
    `0`, or an empty list `[]`. Take the following object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'An inverted section begins with a caret `^` symbol following the opening curly
    braces, rather than the pound `#` symbol used for a standard section. Given the
    preceding example object, the following template syntax can be used to render
    HTML for the `false` property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This template would render the following HTML, based on the `false` property
    value in the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mustache templates also give you the ability to include comments within your
    templates. The advantage to using the Mustache syntax for your comments over HTML
    comments is that they will not be rendered in the HTML output, as would be the
    case with standard HTML comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Mustache comments are denoted by a *bang*, or exclamation point, following
    the opening curly braces. The preceding template code would render the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the Mustache template comment is not part of the rendered HTML, but
    the standard HTML comment is. The advantage to using Mustache template comments
    is in the payload size of the rendered HTML, which you want to keep as small as
    possible, and there are probably not many cases in which you would actually want
    to render comments in dynamic HTML. This allows you to have helpful comments for
    other developers in your template code without it putting a burden on the frontend
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Partials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful features of Mustache templates is the ability to include
    *partials*, or separate templates rendered at runtime within a compiled template.
    Conceptually, this feature is similar to *includes* for server-side template languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for partials uses a greater than `>` sign after the opening curly
    braces followed by the name of the partial. A common file naming convention is
    to prepend the uncompiled partial filenames with an underscore `_.` Consider the
    following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user.hbs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`_user-details.hbs`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to include the partial file is indicated on the second line of user.hbs.
    This will parse _user-details.hbs in the same context as user.hbs. In a standard
    compiler setup, the underscore on the partial filename would be excluded from
    the key name, and the template would be stored within the partials namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the preceding example object, the fully rendered HTML from the template
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the example, the key names from the object were used directly
    in the partial from the same context as the parent template.
  prefs: []
  type: TYPE_NORMAL
- en: Set alternative delimiters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the more unusual features of Mustache templates is the ability to set
    *alternative* delimiters from inside standard Mustache delimiter tags in a template.
    This is done by using an equals sign `=` following the opening standard delimiter
    tags, inserting the new opening delimiter followed by the new closing delimiter,
    and an equals sign followed by the standard closing delimiter tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If this code is placed anywhere inside of a Mustache template, the delimiter
    tags from below that point will then use the new syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the preceding object, a template could be constructed using that data
    combined with alternative delimiter tags for parsing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the standard tags are used once, then the set delimiters feature
    is used to change the tags to use the ERB style delimiters, then the tags are
    again changed back to the original standard delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The resulting HTML would look like the preceding code, rendered with two entirely
    different sets of delimiters inside of one template.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Mustache.js at [github.com/janl/mustache.js](http://github.com/janl/mustache.js),
    or learn about the original Mustache templates at [mustache.github.io](http://mustache.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handlebars.js templates are also considered *logic-less* and are largely based
    on Mustache templates, but provide some additional features. They also exclude
    some of the features of Mustache templates that the creators did not consider
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars is one of the more prominent templating engines in the JavaScript
    community. It is used by several major open source JavaScript frameworks including
    Backbone.js, Ember.js, and the popular Meteor.js framework. It uses their own
    reactive flavor of Handlebars templating engine called Spacebars. Due to its popularity,
    we will cover Handlebars in a bit more depth here.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit path lookup versus recursive path lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the features that differentiates Handlebars templates from Mustache
    templates is that Handlebars does not support recursive path lookup as Mustache
    templates do. This concerns sections, or blocks, as they are referred to in Handlebars.
    When you are in the context of a child property of an object, Handlebars will
    not automatically look up the scope chain for an expression reference. Instead,
    you must explicitly define the path to the scope for the variable that you are
    looking for. This makes the scope in Handlebars templates more meaningful and
    understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this object, the following template syntax would work with Mustache templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This template would render the value for the `profession` key inside of the
    block scope for `#profession` because Mustache supports recursive path lookup.
    In other words, a nested context always has access to variables on the parent
    context above it. This is not the case by default, however, with Handlebars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this example, the `this` keyword is used to reference the variable
    for which the current block context is set. If the `profession` variable itself
    were referenced, this would throw an error in Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, Handlebars can look up the scope chain for a variable with an
    **explicit path** reference using the `../` syntax shown in the preceding code.
    This syntax mimics that of recursive file path lookups in command-line interfaces.
    In this example, the `../profession` reference simply looks up the variable for
    which the current block context is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The reason Handlebars does not support recursive path lookup by default is for
    speed. By limiting the path lookup to the current block context, Handlebars templates
    can render more quickly. A compile time `compat` flag is provided to override
    this functionality and allow recursive path lookups, but the creators of Handlebars
    advise against this and note that there is a performance cost in doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Handlebars templates do not support the use of lambdas defined in objects such
    as Mustache templates, but instead use helpers for added functionality. Helpers
    in Handlebars are a way to abstract away view logic that might otherwise be done
    directly in the templates when using a less restrictive templating engine such
    as Underscore.js. Instead, you can write a helper in the form of a regular JavaScript
    function, register it on the Handlebars namespace, and in your template, use it
    as a single expression or a block expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this example object, a helper can be written to return the user''s full
    name based on the object properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown here, the `Handlebars` object provides a `registerHelper` method that
    gives you the ability to define a helper by defining the name as the first argument
    and a lambda as the second argument. Arguments to the lambda can be provided directly
    from the template context at the point the helper is invoked; in this case, as
    an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for the helper, as shown in the preceding example, uses the name
    of the helper immediately following the opening Handlebars tags followed by any
    arguments to be passed to the helper; in this case, the `name` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The template would then be rendered as HTML with the full name returned from
    the helper by passing the required object property from the template context.
  prefs: []
  type: TYPE_NORMAL
- en: Helpers as block expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handlebars templates use block expression syntax to invoke helpers as well.
    The context for the block expression, however, is entirely dependent upon the
    way the helper is written. Several built-in block helpers are provided with Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: '#if block helper'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A simple `#if` block helper is provided with Handlebars for rendering content
    or not based on Boolean values or truthy versus falsy value resolution. This means
    that values such as `0`, `null`, `undefined`, and empty lists `[]` will resolve
    as false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than using the standard Mustache style section implementation, the `#if`
    helper can be invoked on a Boolean value here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This template would not render the portion inside of the `#if` block because
    `email_subscriber` is `false`. The built-in `#if` helper also provides the ability
    to include an `{{else}}` section within the `#if` block that will render if the
    passed variable evaluates to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the example object, this template would render the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Another difference between the `#if` helper in Handlebars and a section in Mustache
    templates is that the context inside of the `#if` helper does not change, whereas
    the context inside of a section is changed to the object property for which it
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: '#unless block helper'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `#unless` block helper in Handlebars is similar to the inverted section
    feature in Mustache templates, and it can also be considered the inverse of the
    Handlebars `#if` helper. If the value passed to the `#unless` helper is falsy,
    the block will be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider a template similar to the previous `#if` example and based on the
    preceding object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This template would render the content inside of the `#unless` block because
    the value of `email_subscriber` is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '#each block helper'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `#each` block helper is used to iterate over both lists and objects. In
    its most basic form, it works just like a Mustache section in the context of a
    list, but it has additional features that make it much more powerful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `#each` context for a list, the `this` keyword can be used to refer
    to the current value in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the lambda example of iteration for Mustache templates, except
    that no lambda property value is needed to access the iterated object properties
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the scope for each iteration is constrained to the object that is currently
    being iterated over in this example, the preceding template could also be more
    simply written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `this` keyword is not necessary to access the properties
    for each object since the context for each iteration is set to that object.
  prefs: []
  type: TYPE_NORMAL
- en: '#with block helper'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `#with` block helper works much like a standard section in Mustache templates
    by constraining the context of the current block to the parent key that is passed
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this example object, a template can be constructed using the `#with`
    helper to constrain a block to the context of the `name` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This template would render the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Other differences in Handlebars from Mustache templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the features in Handlebars.js that differentiate it from Mustache.js
    are designed to make the templates render more quickly in a browser. One of the
    main features in Handlebars that allows this is the ability to precompile templates,
    as we covered in [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*.
  prefs: []
  type: TYPE_NORMAL
- en: Precompiling templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Precompiling the templates converts them to the JavaScript functions that are
    normally compiled in an application before rendering with other templating engines.
    Using this feature increases the speed of an application by skipping that step,
    and it additionally reduces the load on the browser for the application because
    the JavaScript compiler does not need to be included in the frontend asset payload.
  prefs: []
  type: TYPE_NORMAL
- en: No alternative delimiters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creators of Handlebars also decided that the ability to set alternative
    delimiters within a template is not necessary. This further reduces the asset
    payload for an application if you are not precompiling your templates.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the only reason you would want to change the delimiter style for templates,
    other than personal preference, is to avoid conflicts with another templating
    language, for example, a server-side templating language that uses the same delimiters.
    If you were to include your Handlebars templates inside of JavaScript blocks within
    a server-side template, this issue would materialize. If you precompile your templates
    or abstract them from your server-side templates by keeping them in their own
    external JavaScript files, however, that issue can be avoided entirely and there
    is no need to set alternative delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Handlebars.js at `handlbarsjs.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Pure.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure.js is a JavaScript templating engine that takes the concept of logic-less
    templates to an even greater extreme than Mustache and Handlebars do. Pure.js
    uses no special template expression syntax that has to be interpolated before
    rendering. Instead, it uses only pure HTML tags and CSS selectors, combined with
    JSON data, to render values in the DOM. In this way, Pure.js uses entirely logic-less
    views because there is no template markup in which to include any logic.
  prefs: []
  type: TYPE_NORMAL
- en: Markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using plain HTML, a simple Pure.js template can be constructed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The empty `<span>` element is where you might add data for a particular template,
    but you can use any HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we provide the data for the template in the `data` variable,
    and then provide what is called a `directive` that tells the templating engine
    how to map that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Pure.js provides a global `$p` object upon which methods for interacting with
    templates are available. In this case, we are calling the `render()` method and
    passing the `data` and the `directive` as the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This would be the rendered result of this simple example. You can learn more
    about Pure.js at `beebole.com/pure/.`
  prefs: []
  type: TYPE_NORMAL
- en: Pug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pug, formally named Jade, is a JavaScript templating engine that is prominent
    in the Node.js community. It is largely influenced by **HTML abstraction markup
    language** (**Haml**), which was originally designed to make authoring ERB templates
    easier by using a cleaner and less verbose syntax than raw HTML. In this way,
    Pug requires the compilation of not only its expressions, but of the markup language
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pug is similar to YAML in that hierarchy is denoted by whitespace with indentation
    for delimiters. This means that no closing element tags are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in this example, Pug can be used as a simple shorthand syntax for
    HTML. It can also include simple conditionals with variables, all following the
    same fluid syntax. HTML element attributes are added by including parenthesis
    after the tag name with the attributes defined inside them, such as `html(lang="en")`
    in the example. Elements populated with variables are indicated by placing an
    equals sign after the tag name and following it with a JavaScript key name, as
    shown by `title= pageTitle` in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this example JavaScript object, the preceding template would render the
    following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Inline variables can also be used with another syntax that allows for accessing
    top level properties and nested properties. Consider the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'A Pug template can be written to access all variables in this object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this template, you can see that the inline variable syntax `#{}` is used
    along with a conditional and an element populated with a variable using the `=`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice that the `h1` tag has a `#` symbol immediately following
    it with the word `title`, and the `h2` tags have .`className` following them.
    This demonstrates another feature of Pug which allows the use of standard CSS
    selector syntax to include IDs and classes. The rendered HTML from this template
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how much less verbose writing with Pug can be compared to
    standard HTML combined with another type of template syntax, and that is probably
    the reason it has become so popular. You can learn more about Pug at [pug-lang.com](http://pug-lang.com).
  prefs: []
  type: TYPE_NORMAL
- en: Embedded JavaScript (EJS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**EJS** is a JavaScript templating engine that works much like Underscore.js
    and also uses ERB `<% %>` style delimiters. Alternatively, it also allows the
    use of `[% %]` style tags for delimiters.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like Underscore.js, EJS allows arbitrary JavaScript to be parsed when used
    with the standard `<% %>` ERB style syntax, and allows the evaluation of expressions
    using an equals sign `=` following the opening delimiter tag `<%= %>:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This template can be used to iterate over a list of objects from which key
    names are evaluated as variables with different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterating over this object with the example template would render the following
    HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Synchronous template loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a typical EJS use case, each template is stored in a file with the proprietary
    `.ejs` extension. A template is compiled from JavaScript code by creating a new
    `EJS` object, supplying the path to the template file, and calling the render
    method with the data you want to be interpolated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume the EJS template is saved in a file located in your project at
    `templates/people.ejs`. The following JavaScript could then be written to render
    it as the HTML shown for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The global `EJS` object is a constructor for which you create a new instance
    to parse a template and call methods on it for rendering. Note that since the
    path to the file is referenced in the JavaScript, a *synchronous* call must be
    made to initially load the template for parsing. This keeps the initial page load
    for your application low, but can lead to longer response times when interacting
    with your app, depending upon both the complexity of the template being loaded
    and the speed of the server upon which your app is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the rendered HTML created in your JavaScript code, you simply
    insert it into the DOM in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous data loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One unique feature of EJS is the ability to render a template using asynchronous
    data loaded from an external source. Using the previous example, imagine the JSON
    data is in an external file named `people.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `.update()` method is called instead of `.render()`. The
    object instance is also not assigned to a variable because the DOM insertion is
    handled by the `.update()` method as well by passing a DOM node ID. For this method
    to work, no other CSS selectors can be used for injecting the HTML into the DOM;
    only an ID will work.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EJS caches templates by default after the first time they are loaded synchronously.
    This provides an advantage in that templates used multiple times will always load
    more quickly after the first request, and unused templates will not take up any
    memory. This approach is in stark contrast to precompiling in which all templates
    are loaded into memory at the initial page load of the application. Both of these
    approaches have advantages and disadvantages, so care must be taken to choose
    the best approach for your particular app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching can be also be turned off for any template by including a `cache` key
    in the object of options passed into any template instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: View helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EJS includes some view helpers that are similar to the concept of helpers in
    Handlebars templates. They allow the use of shorter syntax for some common HTML
    elements. We will illustrate a few examples here.
  prefs: []
  type: TYPE_NORMAL
- en: The link_to view helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `link_to` view helper provides a simple template syntax for insuring HTML
    hyperlinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter to the `link_to` view helper is the displayed text for
    the link, and the second parameter is the path to be passed to the `href` attribute
    for the link. Also notice that the delimiters for view helpers use the opening
    expression delimiter syntax. This example would render the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The img_tag view helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This `img_tag` view helper provides an easy syntax for including images in
    your rendered HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter to the `link_to` view helper is the path to the image,
    and the second parameter is the text for the image''s `alt` attribute. This example
    would render the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The form_tag view helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `form_tag` view helper provides a syntax for building HTML forms and can
    be used in conjunction with other view helpers for creating input elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, four view helpers are used to construct the form. The `form_tag`
    view helper creates the opening form body providing the form action to the first
    parameter, and other form attributes in the second parameter using a JavaScript
    object syntax with curly braces. The `input_field_tag` view helper is used to
    create a standard input text field, taking the input name as the first parameter,
    and optionally, the input value as the second parameter. The `submit_tag` view
    helper creates a form submit input with the button text passed as the first parameter.
    Finally, the `form_tag_end` view helper is used to close the body of the form.
    This example would render the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: EJS also includes many other view helpers for common HTML elements using the
    _tag suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Partials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EJS has its own implementation of partials that works using its synchronous
    template loading technique inside of template delimiter tags. To use this feature,
    a call to the partial template file is made directly inside of the parent template.
    Consider the following two template files:'
  prefs: []
  type: TYPE_NORMAL
- en: templates/parent.ejs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: templates/partial.ejs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the call to the partial template references the URL inside of the
    parent template using the expression syntax delimiters and a call to the `this.partial`
    method. To load the partial template inside of another, only the parent template
    has to be initialized from your JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The final rendered HTML would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: These examples provide a brief overview of EJS, but we will use this templating
    engine in more depth later. For additional information on EJS templates, visit
    `embeddedjs.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your application layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a JavaScript SPA can often involve many layers of abstraction including
    custom application code, third party libraries, frontend frameworks, task runners,
    transpilers, and more. All of this can end up amounting to a whole lot of JavaScript
    to be downloaded for the application on the frontend, so steps should always be
    taken to minimize this impact as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Node.js example application we have been working with
    so far. In [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    we wrote the index.html layout page for the app with the following script tags
    included for third party libraries and the compiled templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This is actually a minimal example compared to how many JavaScript files a full-scale
    application might include.
  prefs: []
  type: TYPE_NORMAL
- en: UglifyJS and grunt-contrib-uglify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common tool for minifying and concatenating JavaScript files is **UglifyJS**.
    We can leverage this tool on the command line and automate it using the Grunt
    task runner and the **grunt-contrib-uglify** task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, open up Gruntfile.js and add the following task to existing
    tasks immediately above the watch task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This sets up the uglify task to remove all comments with the `preserveComments`
    option set to false, to mangle or shorten variable and function names, and to
    concatenate the indicated list of JavaScript files into the single target filename
    of `all.min.js`. With this setup, UglifyJS will create the smallest possible download
    size for your JavaScript based on the input files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure to load the new uglify task at the bottom of Gruntfile.js with
    the other tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all you have to do is run the task on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the task, you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the CLI output indicates the original size of the JavaScript
    files, and what it is reduced to in the final output on the second line; in this
    example, showing 322.28 kB → 108.6 kB. In this case, it is compressed to less
    than half of its original size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can change your index.html layout file to make a call to only one
    JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Placing the `<script>` tag at the bottom of the page also ensures that anything
    above it will be loaded and visible to the user before the JavaScript is entirely
    downloaded. This is another common practice in optimizing SPAs by preventing a
    delay before the user sees anything.
  prefs: []
  type: TYPE_NORMAL
- en: grunt-contrib-handlebars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Handlebars templates in an application, the **grunt-contrib-handlebars**
    task is available for precompiling them easily from the command line and via the
    watch task. In [Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"), *Model-View-Whatever*
    we created the example `user.handlebars` file in the root directory of the project,
    and in [Chapter 4](ch04.html "Chapter 4. REST is Best – Interacting with the Server
    Side of Your App"), *REST is Best - Interacting with the Server Side of Your App*
    we created `users.handlebars`. Let''s now create a new directory in `js/templates`
    and move the files there. Next, rename the files `user.hbs` and `users.hbs` for
    brevity. The `.hbs` extension is also widely accepted for Handlebars files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the grunt-contrib-handlebars plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, add the following task configuration to `Gruntfile.js`, just
    above the `uglify` task configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The Grunt plugin for Handlebars makes fewer assumptions for you than the Handlebars
    command-line tool does out of the box, so this configuration does several things
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Options configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, the `options` object is passed four parameters. The `namespace` option
    simply tells the compiler what global namespace to use to store the compiled Handlebars
    template functions. `Handlebars.templates`is the default namespace for this with
    the command line utility, so we will go with that.
  prefs: []
  type: TYPE_NORMAL
- en: The `processName` parameter is passed a function that takes a Handlebars file
    as the argument and uses it to create the key name for that template in the `Handlebars.templates`namespace.
    In this case, we are using a regex to take the path and filename and remove everything
    except for the prefix of the filename, so the compiled template function for `user.hbs`,
    for example, would be available at `Handlebars.templates.user`.
  prefs: []
  type: TYPE_NORMAL
- en: The `partialRegex` option accepts a regex that is used to identify a pattern
    for partial filenames. The default for this is a file prefixed with an underscore
    `_`, but in this case, we will be using a directory for partials, so the `partialRegex`
    option is set to `.*`, meaning it will identify any file on the given path as
    a partial.
  prefs: []
  type: TYPE_NORMAL
- en: The `partialsPathRegex` options accepts a regex that is used to identify the
    path to a directory of partials. We have set it to `/\/partials\//` , which will
    be evaluated as the `/partials` directory beneath the main template path that
    is passed in. Combined with the `partialRegex` option, this tells the compiler
    to parse every file in the `/partials` directory as a partial and add its compiled
    template function to the `Handlebars.partials` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Files configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The files configuration object passed to the Handlebars Grunt task is used
    to tell the compiler what file pattern to use for finding templates for compiling,
    and for defining the output filename of the compiled templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have defined the templates `src` directory to be located in
    the `js/templates/` under the root path, and to parse all files with the extension
    `.hbs` in that directory and every directory underneath it. The recursive directory
    lookup is indicated by the `/**/*.hbs` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The `dest` key tells the compiler to create the `js/src/templates.js` file with
    the final compiled output of all the templates.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Grunt Handlebars task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to run the handlebars task, we first need to load the plugin at the
    bottom of Gruntfile.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the grunt handlebars command from the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the task, you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you look in the `js/src/` directory, you should see that a `templates.js`
    file has been created there next to the `app.js` file we created in [Chapter 1](ch01.html
    "Chapter 1. Getting Organized with NPM, Bower, and Grunt"), *Getting Organized
    with NPM, Bower, and Grunt*. Now that we are storing the `templates.js` file here,
    go ahead and delete the original `templates.js` file in the root directory and
    edit the `files` object in the Grunt uglify task to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now we have added the new `templates.js` file to the uglify task so it is included
    in the full minified application JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Watching for changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you are loading the minified JavaScript file, you will probably want
    to add a watch task to create the file while you are developing so that you do
    not have to constantly run the command from the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, let''s assume that we want to detect changes to any files
    in the `js/src` directory where we are actively working. Edit the `watch` task
    configuration in `Gruntfile.js` and add the following directly underneath the
    `jshint` target for that task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Grunt to run the `uglify` task `main` target when it detects changes
    to files matching the pattern. Additionally, change the `jshint` watch task above
    the `uglify` watch task to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This tells the watch task to ignore changes to `templates.js` for running the
    jshint task. We want to ignore this file because it is compiled and will not pass
    JSHint tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the same file ignore path to the *main* `jshint` task `files` configuration
    near the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This will prevent JSHint from checking `templates.js` against its defined rules
    when the `jshint` task is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a `watch` task for changes to Handlebars template files. Add the
    following configuration underneath the `uglify` target in the `watch` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This will watch for any changes to the Handlebars templates and partials and
    run the `handlebars` task accordingly. Doing so will generate the `templates.js`
    file, which will then trigger the uglify watch task to run and compile the full
    application JavaScript to `all.min.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the Grunt `watch` command from the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `user.hbs` and change the markup to look like the following example.
    Note that the `{{name.first}}` and `{{name.last}}` expressions are updated to
    the properties we created in MongoDB in *[Chapter 4](ch04.html "Chapter 4. REST
    is Best – Interacting with the Server Side of Your App"), REST is Best - Interacting
    with the Server Side of Your App* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file, then check your console where you are running the `watch` task.
    You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The change to `user.hbs` set off a chain reaction of two tasks to run and your
    application JavaScript is compiled to the latest version. If you open the compiled
    `templates.js` file, you will see that both a user and a user''s property have
    been created with associated template functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, while the `handlebars` task is still running, move the `user.hbs` file
    to the `js/templates/partials` directory. This will again trigger the watch task.
    When it has completed, open `templates.js` again and you will notice that the
    `Handlebars.templates.user` property is no longer defined. Instead, a function
    call to `.registerPartial()` is made instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This will invoke the `user.hbs` partial when it is included in a parent template
    using the Handlebars partials syntax. Now open up `users.hbs` and change it to
    use the `user.hbs` partial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This will iterate over the user's data provided. In [Chapter 4](ch04.html "Chapter 4. REST
    is Best – Interacting with the Server Side of Your App"), *REST is Best - Interacting
    with the Server Side of Your App* we left the test database with only one entry,
    so let's add another one now to make this example more illustrative.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a separate console session, run your local Node.js server with Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go to localhost:8080 in your browser and add another entry to the database
    using the POST Request form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve added an additional record, click on the Load user data link under
    the GET Request form. You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This content was rendered by looping over the user data from MongoDB in `users.hbs`
    and populating the expressions in the `user.hbs` partial.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a single, minified JavaScript file for your application code, precompiling
    your JavaScript templates, and loading your JavaScript at the bottom of your application
    layout page are all good practices to follow in optimizing the download time of
    your SPA. Including all of the JavaScript in one file versus multiple files is
    just as important as minifying the JavaScript because it reduces the number of
    HTTP requests a client has to make in order to load your SPA. This same practice
    should be used with CSS and can be done with Grunt using plugins such as `grunt-contrib-cssmin`
    and `grunt-postcss`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a good understanding of the differences among some of the
    more popular JavaScript templating engines, how to use them for basic views, and
    some of their advantages and disadvantages. You should also understand the difference
    between using precompiled templates and templates that are compiled in the browser.
    Additionally, you have learned about optimizations to use in your layout file
    to minimize the download size of your app including minification, concatenation
    into one file, and including JavaScript at the bottom of the document. In the
    next chapter, we will dive further into the View layer by deconstructing the technique
    of data binding.
  prefs: []
  type: TYPE_NORMAL
