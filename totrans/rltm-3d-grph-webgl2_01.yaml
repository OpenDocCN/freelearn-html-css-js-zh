- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when most of the web comprised pages with static content—the
    only graphics were embedded images. Over time, however, application requirements
    became more ambitious and began running into limitations. As highly interactive
    applications became an increasingly important part of the user experience, there
    was, eventually, enough demand for a fully programmable graphics **Application
    Programming Interface** (**API**) to address these requirements. In 2006, Vladimir
    Vukicevic, an American-Serbian software engineer, began working on an OpenGL prototype
    for a then-upcoming HTML `<canvas>` element that he called Canvas 3D. In March
    2011, his work would lead to the Kronos Group, the nonprofit organization behind
    OpenGL, to create **WebGL**, a specification to grant internet browsers access
    to **Graphics Processing Units** (**GPUs**).
  prefs: []
  type: TYPE_NORMAL
- en: All of the browser engines collaborated to create WebGL, the standard for rendering
    3D graphics on the web. It was based on OpenGL **Embedded Systems** (**ES**),
    a cross-platform API for graphics targeted at embedded systems. This was the right
    starting place, because it made it possible to easily implement the same API in
    all browsers, especially since most browser engines were running on systems that
    had support for OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL was originally based on OpenGL ES 2.0, the OpenGL specification version
    for devices such as Apple's iPhone and iPad. But, as the specification evolved,
    it became independent with the goal of providing portability across various operating
    systems and devices. The idea of web-based, real-time rendering opened a new world
    of possibilities for web-based 3D environments. Due to the pervasiveness of web
    browsers, these and other kinds of 3D applications could now be rendered on desktop
    and mobile devices such as smartphones and tablets. According to the Khronos Group, the
    ability for Web developers to directly access OpenGL-class graphics directly from
    JavaScript, and freely mix 3D with other HTML content, will enable a new wave
    of innovation in Web gaming, educational and training applications.
  prefs: []
  type: TYPE_NORMAL
- en: Even though WebGL was vastly adopted for many years after it matured into a
    stable release—shipping inside Firefox, Chrome, Opera, IE11, and Android's mobile
    web browsers—Apple still lacked official WebGL support. Neither OS X Safari nor
    Safari Mobile supported WebGL. In fact, it wasn't until 2014, at June's **Worldwide
    Developers Conference** (**WWDC**), that Apple announced that both OS X Yosemite
    and iOS 8 would ship with WebGL support. This became a turning point for 3D graphics
    on the web. With official support from all major browsers, the entire range of
    3D graphics—at native speeds—could be delivered to billions of desktop and mobile
    devices. WebGL unleashed the power of graphics processors to developers on an
    open platform, allowing console-quality application to be built for the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the necessary system requirements to run WebGL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cover the common high-level components of a WebGL application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a drawing area (`canvas`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your browser's WebGL capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand that WebGL acts as a state machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify WebGL variables that affect your scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load and examine a fully-functional scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebGL is a web-based 3D Graphics API. As such, there is *no* installation needed. While
    WebGL 1 is based on the OpenGL ES 2.0 specification, WebGL 2 is based on OpenGL
    ES 3.0, which guarantees the availability of many WebGL 1 extensions along with
    new features.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL 2 Versus WebGL 1
  prefs: []
  type: TYPE_NORMAL
- en: Given this book covers WebGL 2, all WebGL and WebGL 2 terms reference the WebGL
    2 (OpenGL ES 3.0) specification. Any references to WebGL 1 (OpenGL ES 2.0) will
    be done so explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of January 27, 2016, WebGL 2 is available by default in Firefox and Chrome. You
    will automatically have access to WebGL 2, provided you have one of the following
    web browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: Firefox 51 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Chrome 56 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome for Android 64 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an updated list of the web browsers that support WebGL, please visit the
    Khronos Group web page: [http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation](http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation).
  prefs: []
  type: TYPE_NORMAL
- en: Or visit the well-known **CanIUse.com** resource: [https://caniuse.com/#search=WebGL
    2](https://caniuse.com/#search=webgl2).
  prefs: []
  type: TYPE_NORMAL
- en: Modern Standards
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be using modern browsers to run WebGL 2, we will also leverage
    HTML5, CSS3, and JavaScript ES6 throughout this book. For more information on
    these modern standards, please refer to the following link: [https://developer.mozilla.org/en-US/docs/Web](https://developer.mozilla.org/en-US/docs/Web).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this book's publication, WebGL 2 remains a specification that's
    in flux. Some parts of the specification are considered stable and have been implemented
    in modern browsers; other parts should be considered experimental and have been
    partially implemented to varying degrees. Therefore, you should be familiar with
    how the standardization process works and the levels of implementation for each
    new property. That being said, WebGL 2 is nearly 100% backward compatible with
    WebGL 1\. All exceptions to backward compatibility are recorded in the following
    link: [https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY](https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY).
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to WebGL 2
  prefs: []
  type: TYPE_NORMAL
- en: If you have prior experience with WebGL 1 or are curious about migration strategies
    to WebGL 2, you can refer to [Chapter 11](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml), *WebGL
    2 Highlights*, where key differences between WebGL 1 and WebGL 2 are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you will need to make sure that your computer has an approved graphics
    card. To quickly validate your current configuration for WebGL 2, please visit
    the following link: [https://get.webgl.org/WebGL 2/](https://get.webgl.org/webgl2/).
  prefs: []
  type: TYPE_NORMAL
- en: WebGL Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebGL is a 3D graphics library that enables modern web browsers to render 3D
    scenes in a standard and efficient manner. According to Wikipedia, **rendering** is
    the process of generating an image from a model by means of computer programs.
    Since this is a process executed by a computer, there are different ways to produce
    such images. There are three main distinctions to make when discussing rendering:
    software-based and hardware-based rendering, server-based and client-based rendering,
    and retained-mode and immediate-mode rendering. As we will see, WebGL offers a
    unique approach to hardware and client based rendering with an immediate-mode
    API on the web.'
  prefs: []
  type: TYPE_NORMAL
- en: Software and Hardware Based Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first distinction we should make is whether we are using any special graphics
    hardware. On one hand, we can talk about **software-based rendering** for cases
    where all required calculations to render 3D scenes are performed using the computer's
    **Central Processing Unit** (**CPU**). On the other hand, as is the case with
    WebGL, we use the term **hardware-based rendering** for scenarios where there
    is a GPU performing 3D graphics computations. From a technical standpoint, hardware-based
    rendering is much more efficient than software-based rendering, because the former
    involves dedicated hardware handling the necessary operations. In contrast, a
    software-based rendering solution can be more common due to the lack of hardware
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Server and Client Based Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second distinction to make is whether the rendering process is happening
    locally or remotely. When the image that needs to be rendered is too complex,
    the render will most likely occur remotely. This is the case for 3D animated movies
    where dedicated servers with lots of hardware resources render intricate scenes.
    We call this **server-based rendering**. The opposite of this approach takes place
    when rendering occurs locally. We call this **client-based rendering**. WebGL
    offers a client-based rendering approach: the elements that are a part of the
    3D scene are usually downloaded from a server. However, the processing required
    to obtain an image is all performed locally using the client''s graphics hardware.
    Although this is not a unique solution, compared to other technologies (such as
    Java 3D, Flash, and the Unity Web Player Plugin), WebGL presents several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript programming**: JavaScript is a language that is natural to both
    web developers and browsers. Working with JavaScript allows you to access all
    parts of the DOM and easily integrate WebGL applications with other JavaScript
    libraries such as jQuery, React, and Angular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic memory management**: WebGL—unlike other technologies, such as OpenGL,
    where memory allocation and deallocation are handled manually—follows the rules
    for JavaScript variable scoping and automatic memory management. This simplifies
    programming tremendously while reducing the code footprint. Ultimately, this simplification
    makes it easier to understand the application logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pervasiveness**: Web browsers with JavaScript capabilities are installed
    in smartphones and tablet devices by default. This means you can leverage WebGL
    across a vast ecosystem of desktop and mobile devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Performance of WebGL applications is comparable to equivalent
    standalone applications (with some exceptions). This is possible due to WebGL''s
    ability to access the local graphics hardware. Until recently, many 3D web rendering
    technologies used software-based rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero compilation**: WebGL is written in JavaScript; therefore, there is no
    need to compile your code before executing it on the web browser. This empowers
    you to make changes in real-time and see how those changes affect your 3D web
    application. Nevertheless, when we cover shader programs, we will understand that
    some compilation is needed. However, this occurs in your graphics hardware and
    not in your browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retained and Immediate Mode Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third distinction to make is that WebGL is an immediate mode 3D rendering
    API designed for the web. Graphics APIs can be divided into retained-mode APIs
    and immediate-mode APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Retained-Mode Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **retained-mode** API is declarative. The application builds a scene from
    primitives, such as shapes and lines, and then the graphics library maintains
    a scene model in memory. To change what is rendered, the application issues a
    command to update the scene, which could include, for example, adding or removing
    a shape; the library is then responsible for managing and redrawing the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20cc3540-9e72-4351-a72e-eb99abfa4bd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Immediate-Mode Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **immediate-mode** API is procedural. Immediate mode rendering requires
    the application to directly manage rendering. In this case, the graphics library
    does not maintain a scene model. Each time a new frame is drawn, the application
    issues all drawing commands required to describe the entire scene, regardless
    of actual changes. This method provides the maximum amount of control and flexibility
    to the application program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6445c540-8cec-4e28-826d-b4fe1b0e11c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Retained Versus Immediate Mode Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retained-mode rendering can be simpler to use, because the API does more of
    the work for you, such as initialization, state maintenance, and cleanup. However,
    it is often less flexible since the API forces its own particular scene model;
    it can also have higher memory prerequisites because it needs to provide a general-purpose
    scene model. Immediate-mode rendering, on the other hand, as offered with WebGL,
    is much more flexible and can implement targeted optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Elements in a WebGL Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebGL, like other 3D graphics libraries, comprises many common 3D elements.
    These fundamental elements will be covered, chapter-by-chapter, throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these common elements include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas`: It is the placeholder where our scene is rendered. It is a standard
    HTML5 element and as such, can be accessed using the **Document Object Model**
    (**DOM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects**: These are the 3D entities that make up the scene. These entities
    are composed of triangles. In the following chapters, we will see how WebGL handles
    and renders geometries using **buffers**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lights**: Nothing in a 3D world can be seen without lights. In later chapters,
    we will learn that WebGL uses **shaders **to model lights in the scene. We will
    see how 3D objects reflect or absorb light according to the laws of physics. We
    will also discuss different light models to visualize our objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera**: `canvas` acts as the viewport to the 3D world. We see and explore
    a 3D scene through it. In the following chapters, we will understand the different
    matrix operations that are required to produce a view perspective. We will understand
    how these operations can be modeled as a camera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will cover the first element of our list: `canvas`. The following
    sections will help us understand how to create a `canvas` element and how to set
    up a WebGL context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Creating an HTML5 Canvas Element'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `canvas` is a rectangular element in your web page where your 3D scene will
    be rendered. Let''s create a web page and add a HTML5 `canvas` element:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your favorite editor, create a web page with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Save the file as `ch01_01_canvas.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it with a supported browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see something similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b67f2ff-df20-4e1d-b7ed-56d1b62cc618.png)'
  prefs: []
  type: TYPE_IMG
- en: '***What just happened? ***'
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple web page containing a `canvas` element. This `canvas` will
    contain our 3D application. Let's go very quickly over some relevant elements
    presented in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a CSS Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the piece of code that determines the `canvas` style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code is not fundamental to build a WebGL application. Given that the `canvas`
    element is initially empty, a blue-dotted border is a simple way to verify the
    location of the `canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Canvas Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three attributes in our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the `canvas` identifier in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` and `height`: These two attributes determine the size of our `canvas`
    element. When these two attributes are missing, Firefox, Chrome, and WebKit will
    default to using `300px` by `150px`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What If Canvas Is Not Supported?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you see the following message on your screen, Your browser does not support
    the HTML5 canvas element (which is the message between the `<canvas>` tags), you
    need to make sure that you're using one of the supported web browsers described
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using Firefox and you still see this message, you may want to check
    whether WebGL is enabled (it is by *default*). To do so, go to Firefox and type `about:config` in
    the address bar. Then, look for the `webgl.disabled` property. If it is set to `true`,
    change it to `false`. When you restart Firefox and load `ch01_01_canvas.html`,
    you should be able to see the dotted border of the `canvas` element.
  prefs: []
  type: TYPE_NORMAL
- en: In the remote case that you still do not see `canvas`, it could be because your
    browser has blacklisted your GPU. If this is the case, please use a system with
    the appropriate hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Accessing the WebGL Context'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A WebGL context is a handle (more strictly a JavaScript object) through which
    we can access WebGL functions and attributes. These available features constitute
    the WebGL API.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a JavaScript function that will check whether a WebGL
    context can be obtained. Unlike other technologies that need to be downloaded
    into your project, WebGL is *already in your browser*. In other words, if you
    are using one of the supported browsers, you don't need to install or include
    any library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the previous example to add a JavaScript function to check the
    WebGL availability in your browser. This function is going to be called when the
    page has loaded. For this, we will use the standard DOM `onload` event:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch01_01_canvas.html` file in your favorite text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code right below the closing `<style>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save the file as `ch01_02_context.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ch01_02_context.html` file using one of the WebGL 2 supported browsers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you can run WebGL 2, you will see a dialog similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/507c43b1-14d5-4db6-b33a-2b3b5459ad76.png)'
  prefs: []
  type: TYPE_IMG
- en: Strict Mode
  prefs: []
  type: TYPE_NORMAL
- en: The Strict Mode, declared by `'use strict';`, is a feature that allows you to
    place a program, or a function, in a "strict" operating context. This strict context
    prevents certain actions from being taken and throws more exceptions. For more
    information, please visit the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  prefs: []
  type: TYPE_NORMAL
- en: '***What just happened? ***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning a JavaScript variable (`gl`), we obtained a reference to a WebGL
    context. Let''s go back and check the code that allows accessing WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `canvas.getContext` method gives us access to WebGL. `getContext` also provides
    access to the HTML5 2D graphics library when using `2D` as the context name. The
    HTML5 2D graphics API is completely independent from WebGL and is beyond the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: State Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A WebGL context can be understood as a state machine: once you modify attributes,
    the modifications persist until later modifications. At any point, you can query
    the state of these attributes to determine the current state of your WebGL context.
    Let''s analyze this behavior with an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Setting up WebGL Context Attributes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we are going to learn to modify the color we use to clear
    the `canvas` element:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your favorite text editor, open the `ch01_03_attributes.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that this file is similar to our previous example. However, there
    are new code constructs that we will explain briefly. This file contains three
    JavaScript functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `updateClearColor` | Updates `clearColor` and then sets the `canvas` element clear
    color, which is one of the WebGL context attributes. As previously mentioned,
    WebGL works as a state machine. Therefore, it will maintain this color until it''s
    changed using the `gl.clearColor` WebGL function (see the `checkKey` source code).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `checkKey` | This is an auxiliary function that has been attached to the
    window `onkeydown` event. It captures the keyboard input and executes code depending
    on the key entered. |'
  prefs: []
  type: TYPE_TB
- en: '| `init` | This function gets called on the document `onload` event. It obtains
    a WebGL context and sets it to the global `gl` variable. |'
  prefs: []
  type: TYPE_TB
- en: Open the `ch01_03_attributes.html` file in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *1*. You will see how the `canvas` changes its color to green. If you
    want to query the exact color used, press *4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `canvas` element will maintain the green color until we change it by calling `gl.clearColor`.
    Let's change it by pressing 2\. If you look at the source code, this will change
    the `canvas` clear color to blue. If you want to know the exact color, press 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can press *3*to set the clear color to a random color. As before, you can
    get the color by pressing *4**:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1dccfec1-da9e-4bda-bf30-ee51d860a267.png)'
  prefs: []
  type: TYPE_IMG
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we saw that we can change the color that WebGL uses to clear
    the `canvas` element by calling the `clearColor` function. Correspondingly, we
    used `getParameter(gl.COLOR_CLEAR_VALUE)` to obtain the current value of the `canvas`
    clear color.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will encounter similar constructs where specific functions
    establish attributes of the WebGL context while the `getParameter` function retrieves
    the current values for such attributes whenever the respective argument (in our
    example, `COLOR_CLEAR_VALUE`) is used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Context to Access the WebGL API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is essential to note that all of the WebGL functions are accessed through
    the WebGL context. In our examples, the context is being held by the `gl` variable.
    Therefore, any call to the WebGL API will be performed using this variable.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a 3D Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to set up a `canvas` element and how to obtain a WebGL
    context; the next step is to discuss objects, lights, and cameras. But why wait
    to see what WebGL can do? In this section, we will take a quick peek at a simplified
    version of the final WebGL application that we'll be building in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Car Showroom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this book, we will develop a virtual car showroom application using
    WebGL. At this point, we will load one simple scene into the `canvas` element.
    This scene will contain a car, some lights, and a camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Visualizing a 3D Showroom'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you finish reading this book, you will be able to create compelling 3D
    scenes such as the one we are going to play with next. This scene showcases one
    of the cars from this book''s virtual car showroom:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch01_04_showroom.html` file in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a WebGL scene with a car in it, as shown in the following screenshot.
    In the following chapters, we will cover geometry rendering and will see how to
    load and render various 3D models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c3ee1235-04f7-45e7-be3d-02a71bf74ef7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the sliders to interactively update the four light sources that have been
    defined for this scene. Each light source has two elements: diffuse and specular
    elements. We have [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml), *Lights*, dedicated
    entirely to lights in a 3D scene.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag on `canvas` to rotate the car and visualize it from different
    perspectives. You can zoom by pressing the *Alt*key while dragging the mouse on
    the `canvas`. You can also use the *arrow *keys to rotate the camera around the
    car. Make sure that `canvas` is in focus by clicking on it before using the *arrow*
    keys. In [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml), *Cameras*, we
    will discuss how to create and operate our own custom cameras in WebGL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the color selector widget to change the color of the car. The use of colors
    in the scene will be discussed in detail later in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have loaded a simple scene in a browser using WebGL. This scene consists
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `canvas`elementthrough which we see the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A series of polygonal meshes (**objects**) that constitute the car: roof, windows,
    headlights, fenders, doors, wheels, spoiler, bumpers, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Light **sources, otherwise everything would appear black.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **camera **that determines where our viewpoint is in the 3D world. This camera
    is interactive where the viewpoint can change, depending on user input. For example,
    we used various keys and the mouse to move the camera around the car.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other elements in this scene such as textures, colors, and special
    light effects (specularity). Do not panic! We will explain each element throughout
    this book. The point here is to identify that the four basic elements we discussed
    previously are present in the scene. That said, feel free to examine the source
    code to get a sense of what's to come.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress through chapters, we will encounter common functionality (for
    example, design patterns, utility functions, helpers, and data structures) that
    we can build upon. Not only this will serve us in writing **DRY** code, but it
    will also provide a useful architecture to support an advanced 3D WebGL application
    by the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: DRY**Don't Repeat Yourself** (**DRY**) is a software development principle,
    the main aim of which is to reduce repetition of code. **Write Everything Twice**
    (**WET**) is a cheeky abbreviation to mean the opposite— code that doesn't adhere
    to the DRY principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover some changes that we will use in future chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `common/js/utils.js` in your editor to see the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use `utils` to include many of the utility functions to serve us in
    building our 3D application. The two methods, `getCanvas` and `getGLContent`, inside
    of `utils` are similar to the code we''ve implemented earlier in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`getCanvas` returns the `canvas` element with the provided `id` as the argument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getGLContext` returns a WebGL 2 context for a given `canvas` element.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `ch01_05_attributes-final.html` in your editor to see the following
    changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've included `<link rel="stylesheet" href="/common/lib/normalize.css">` in
    the `<head>` of our document that resets many of the inconsistencies across browsers.
    This is an external library to help us normalize CSS styling across browsers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've included `<script type="text/javascript" src="img/utils.js"></script>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll to the `init` function where the necessary changes were made to use
    the `utils.getCanvas` and `utils.getGLContext` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Open up `ch01_05_attributes-final.html` in a browser to see these changes in
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Example Code Structure** All example code has been structured so that common
    functionality is at the root of the directory ( `common/`), while examples for
    each chapter are categorized under chapter directories (for example, `ch01/`,
    `ch02/`, and `ch03/`). That being said, to view these examples in your browser,
    you will need to start a server at the root of the directory to load all required
    assets for each example. Please refer to the [Preface](0761b7b6-811c-41b8-8345-601dfb43747e.xhtml) of
    this book for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s summarize what we''ve learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We covered the history of WebGL and how it came to fruition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about common elements—`canvas`, objects, lights, and camera—that
    are, generally, present in WebGL applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to add a HTML5 `canvas` element to our web page and how to set
    its `id`, `width`, and `height`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We implemented the code to obtain a WebGL context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered how WebGL works as a state machine and, as such, we can query any
    of its variables using the `getParameter` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We got a glimpse of the interactive 3D application that we'll build by the end
    of this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to define, load, and render objects into
    a WebGL scene.
  prefs: []
  type: TYPE_NORMAL
