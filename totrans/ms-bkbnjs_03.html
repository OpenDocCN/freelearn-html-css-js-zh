<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Model Bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Model Bindings</h1></div></div></div><p>Keeping models in sync with other objects such as views can be challenging, and if it is not done correctly, it can lead to messy code. In this chapter, we will explore how to deal with data synchronization to make data binding easier. But, what is data binding? Wikipedia defines<a id="id93" class="indexterm"/> data binding as:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Data binding is the process that establishes a connection between the application UI (User Interface) and business logic. If the settings and notifications are correctly set, the data reflects changes when made. It can also mean that when the UI is changed, the underlying data will reflect that change.</em></span></p></blockquote></div><p>A common <a id="id94" class="indexterm"/>issue with model binding<a id="id95" class="indexterm"/> is how to deal with complex model structures that include other embedded objects or lists; in this chapter, we will define a strategy to deal with these scenarios. A missing feature in Backbone is two-way binding; in the next sections, we will see how to implement this without a headache.</p><p>Let's start the chapter describing how to bind model data with views manually to see how Backbone works; after that, we can use Backbone.Stickit to make it much easier. After learning how to sync model data and views, we will explore how to perform validations on the models and how to display error messages.</p><div class="section" title="Manual binding"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Manual binding</h1></div></div></div><p>To make <a id="id96" class="indexterm"/>it simple, imagine that we have a form with a <a id="id97" class="indexterm"/>simple layout: name, phone, and an email address:</p><div class="informalexample"><pre class="programlisting">&lt;script id="form-template" type="text/template"&gt;
&lt;form&gt;
&lt;div class="form-group"&gt;
&lt;label for="name"&gt;Name&lt;/label&gt;
&lt;input id="name" class="form-control" type="text"
value="&lt;%= name %&gt;" /&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
&lt;label for="phone"&gt;Name&lt;/label&gt;
&lt;input id="phone" class="form-control" type="text"
value="&lt;%= phone %&gt;" /&gt;
&lt;/div&gt;
&lt;div class="form-group"&gt;
&lt;label for="email"&gt;Name&lt;/label&gt;
&lt;input id="email" class="form-control" type="text"
value="&lt;%= email %&gt;" /&gt;
&lt;/div&gt;
&lt;button type="submit"class="btn btn-default"&gt;Save now&lt;/button&gt;
&lt;/form&gt;
&lt;/script&gt;

&lt;script id="preview-template" type="text/template"&gt;
&lt;h3&gt;&lt;%= name %&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;%= phone %&gt;&lt;/li&gt;
&lt;li&gt;&lt;%= email %&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/script&gt;</pre></div><p>In the <a id="id98" class="indexterm"/>snippet, we <a id="id99" class="indexterm"/>have two views that will be rendered at the same time. When the user clicks on the <span class="strong"><strong>Save</strong></span> button in the form, the preview template will be updated with the model data:</p><div class="informalexample"><pre class="programlisting">'use strict';

var contact = new Backbone.Model({
  name: 'John Doe',
  phone: '555555555',
  email: 'john.doe@example.com'
});

class FormView extends ModelView {
  constructor(options) {
    super(options);
    this.template = '#form-template';
    this.model = contact;
  }
}

class ContactPreview extends ModelView {
  constructor(options) {
    super(options);
    this.template = '#preview-template';
    this.model = contact;

    // Re-render the view if something in the model
    // changes
    this.model.on('change', this.render, this);
  }
}

var form = new FormView({
  el: '#contact-form'
});

var preview = new ContactPreview({
  el: '#contact-preview'
});

form.render();
preview.render();</pre></div><p>This code <a id="id100" class="indexterm"/>will <a id="id101" class="indexterm"/>render the contents of the <code class="literal">contact</code> model in the form and in the preview. When the <span class="strong"><strong>Save now</strong></span> button is clicked, nothing happens because it hasn't yet been programmed, so let's save the changes in the model:</p><div class="informalexample"><pre class="programlisting">var FormView = ModelView.extend({
  // ...
  events() {
    return {
      'click button[type="submit"]': 'saveContact'
    };
  }

  saveContact(event) {
    event.preventDefault();
    this.model.set('name', this.$('#name').val());
    this.model.set('phone', this.$('#phone').val());
    this.model.set('email', this.$('#email').val());
  }
});</pre></div><p>Let's see what's happening here. In <code class="literal">FormView</code>, we're updating the model with the data in the form inputs; this action syncs the form data with the model, triggering a <code class="literal">'change'</code> event on the Model. Because <code class="literal">ContactPreview</code> is listening for the change, the event will update itself with the data in the model.</p><p>Backbone is <a id="id102" class="indexterm"/>not built with <span class="emphasis"><em>automagic</em></span> view-model <a id="id103" class="indexterm"/>bindings, so it's the developer's responsibility to implement it. Fortunately, there are some Backbone plugins that can help us to make it less painful; one of these is <code class="literal">Backbone.Stickit</code>, developed by the <span class="emphasis"><em>New York Times</em></span>.</p></div></div>
<div class="section" title="Two-way binding"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Two-way binding</h1></div></div></div><p>
<code class="literal">Angular.js</code> has <a id="id104" class="indexterm"/>been popularized as two-way data binding in <a id="id105" class="indexterm"/>the frontend; the idea behind two-way data binding is to keep views and models in sync. When you make a change in an input field the view the model should be updated immediately, and if you change a property in the model the view should show the current value immediately:</p><div class="mediaobject"><img src="graphics/B01962_03_01.jpg" alt="Two-way binding"/><div class="caption"><p>Figure 3.1 Two-way data binding with Backbone</p></div></div><p>Backbone does not provide a mechanism to achieve this easily; however, we can do it using the event system that Backbone models provide. Figure 3.1 shows how you can make an implementation.</p><p>
<code class="literal">Backbone.View</code> listens<a id="id106" class="indexterm"/> for <code class="literal">keyup</code> and <code class="literal">change</code> events on input controls at the DOM; when a change is triggered from the DOM, <code class="literal">Backbone.View</code> can extract the new value from the input and set the Model:</p><div class="informalexample"><pre class="programlisting">class FormView extends ModelView {
  // ...

  events() {
    return {
      'click button[type="submit"]': 'saveContact',
      'keyup input': 'inputChanged',
      'change input': 'inputChanged'
    };
  }

  inputChanged(event) {
    var $target = $(event.target);
    var value = $target.val();
    var id = $target.attr('id');
    this.model.set(id, value);
  }

// ...
}</pre></div><p>When you <a id="id107" class="indexterm"/>call the <code class="literal">set()</code> method on <code class="literal">Backbone.View</code>, at least two events are triggered: <code class="literal">change</code> and <code class="literal">change:&lt;fieldname&gt;</code>.We can use these events to update the necessary views:</p><div class="informalexample"><pre class="programlisting">var myModel = new Backbone.Model();

myModel.on('change:foo', event =&gt; {
  console.log('foo changed to', event.changed.foo);
});
myModel.on('change', event =&gt; {
  var changedKeys = _.keys(event.changed);

  changedKeys.forEach(key =&gt; {
    console.log(key, 'changed to', event.changed[key]);
  });
});

myModel.set('foo', 'bar');
myModel.set('baz', 'xyz');
myModel.set({
  foo: 'stuff',
  baz: 'zxy'
});</pre></div><p>You can see the output of the preceding snippet in the following figure:</p><div class="mediaobject"><img src="graphics/B01962_03_02.jpg" alt="Two-way binding"/><div class="caption"><p>Figure 3.2 Output of change events</p></div></div><p>We can <a id="id108" class="indexterm"/>use<a id="id109" class="indexterm"/> these events to update the view when necessary. Indeed, the code we already have is enough to keep the <code class="literal">ContactForm</code> and <code class="literal">ContactPreview</code> views in sync.</p><div class="informalexample"><pre class="programlisting">this.model.on('change', this.render, this);</pre></div><p>
<code class="literal">ContactPreview</code> is listening for every change in the model and re-rendering the view when something changes. However, re-rendering the whole view each time is a heavy process; it would be better if we made the changes only when necessary.</p><p>First, you will need to identify each field with an identifier:</p><div class="informalexample"><pre class="programlisting">&lt;script id="preview-template" type="text/template"&gt;
&lt;h3 id="name"&gt;&lt;%= name %&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li id="phone"&gt;&lt;%= phone %&gt;&lt;/li&gt;
&lt;li id="email"&gt;&lt;%= email %&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/script&gt;</pre></div><p>And the change event handler will update only the contents of the identified elements:</p><div class="informalexample"><pre class="programlisting">class ContactPreview extends ModelView {
  constructor(options) {
    //...

    // Re-render the view if something in the model
    // changes
    this.model.on('change', this.handleChange, this);
  }

  handleChange(event) {
    var changedKeys = _.keys(event.changed);

    changedKeys.forEach(key =&gt; {
      let $target = this.$('#' + key);
      if ($target) {
        $target.html(event.changed[key]);
      }
    });
  }
}</pre></div><p>Despite<a id="id110" class="indexterm"/> the<a id="id111" class="indexterm"/> result of the two-way data binding it should be used with caution; some people don't think that two-way data binding is a good idea and consider it as an anti-pattern.</p><div class="section" title="References"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>References</h2></div></div></div><p>Refer to<a id="id112" class="indexterm"/> the following URLs for more information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why you should not use AngularJS: <a class="ulink" href="http://bit.ly/1Mue1kC">http://bit.ly/1Mue1kC</a></li><li class="listitem" style="list-style-type: disc">AngularJS Antipatterns and Pitfalls: <a class="ulink" href="http://bit.ly/1kTHKqS">http://bit.ly/1kTHKqS</a></li><li class="listitem" style="list-style-type: disc">What's wrong with Angular 1: <a class="ulink" href="http://bit.ly/1N9wHok">http://bit.ly/1N9wHok</a></li></ul></div></div></div>
<div class="section" title="Data binding with plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Data binding with plugins</h1></div></div></div><p>As you <a id="id113" class="indexterm"/>can see in the previous section, Backbone does not provide an easy mechanism to sync your models and the views that use them. Some plugins for Backbone have been developed to minimize this issue; one of them is <code class="literal">Backbone.Stickit</code>.</p><p>If you want an easy and yet powerful way to bind DOM nodes and Backbone models, <code class="literal">Backbone.Stickit</code> will do a great job:</p><div class="informalexample"><pre class="programlisting">var FormView = ModelView.extend({
template: '#form-template',
  bindings: {
    '#name': 'name',
    '#phone': 'phone',
    '#email': 'email'
  },
  onRender: function() {
    this.stickit();
  }
});</pre></div><p>The <a id="id114" class="indexterm"/>preceding code example shows how it looks; please consult the project documentation to learn more about it.</p></div>
<div class="section" title="Binding embedded data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Binding embedded data</h1></div></div></div><p>One of <a id="id115" class="indexterm"/>the most common issues with Backbone is how to deal with complex model data:</p><div class="informalexample"><pre class="programlisting">{
"name": "John Doe",
"address": {
"street": "Seleme",
"number": "1975 int 6",
"city": "Culiacán"
  },
"phones": [{
"label": "Home",
"number": "55 555 123"
  }, {
"label": "Office",
"number": "55 555 234"
  }],
"emails": [{
"label": "Work",
"email": "john.doe@example.com"
  }]
}</pre></div><p>It could be easy to render a read-only view for this model data; however, the real challenge is how to bind form actions with embedded arrays. In Backbone, it is difficult to use the event system on array objects; if you push a new item in the list, no event will be triggered. This <a id="id116" class="indexterm"/>makes it difficult to keep model data in sync with the a view that edits its contents.</p><div class="section" title="Binding an embedded list"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Binding an embedded list</h2></div></div></div><p>Imagine<a id="id117" class="indexterm"/> that our Contacts App will now allow us to add more than one phone and email. We will need to change the edit form view to add support for adding, removing, and modifying items on the array of phones and emails:</p><div class="mediaobject"><img src="graphics/B01962_03_03.jpg" alt="Binding an embedded list"/><div class="caption"><p>Figure 3.3. Contact form layout with phone and email lists</p></div></div><p>Figure 3.3 shows the result of adding a <span class="strong"><strong>New</strong></span> button to allow the user to dynamically add the number of phones and emails he/she wants. Each item in the list should include a <span class="strong"><strong>Delete</strong></span> button too to allow the user to remove them.</p><p>To render the phone and email lists and sync the forms with the model, we will follow a different strategy; Figure 3.4 illustrates how our strategy will look:</p><div class="mediaobject"><img src="graphics/B01962_03_04.jpg" alt="Binding an embedded list"/><div class="caption"><p>Figure 3.4 Embedded array rendering strategy</p></div></div><p>We will <a id="id118" class="indexterm"/>create two new Backbone collections, one for phones and another for emails. With the data in the <code class="literal">Contact</code> model we can initialize these collections and render them as regular <code class="literal">CollectionView</code>.</p><p>As we saw in the previous chapter, <code class="literal">CollectionView</code> objects take care of the changes in the collection that it renders, so that we can modify the collection object and the view will behave as expected.</p><p>When the user clicks on the <span class="strong"><strong>Save</strong></span> button, we can serialize the content of these collections and update the model before we call the <code class="literal">save()</code> method.</p><p>Each item for phones and emails will have a very similar template:</p><div class="informalexample"><pre class="programlisting">&lt;script id="contact-form-phone-item" type="text/template"&gt;
&lt;div class="col-sm-4 col-md-2"&gt;
&lt;input type="text" class="form-control description" 
placeholder="home, office, mobile"
 value="&lt;%= description %&gt;" /&gt;
&lt;/div&gt;
&lt;div class="col-sm-6 col-md-8"&gt;
&lt;input type="text" class="form-control phone" 
placeholder="(123) 456 7890" value="&lt;%= phone %&gt;" /&gt;
&lt;/div&gt;
&lt;div class="col-sm-2 col-md-2 action-links"&gt;
&lt;a href="#" class="pull-rigth delete"&gt;delete&lt;/a&gt;
&lt;/div&gt;
&lt;/script&gt;</pre></div><p>This template<a id="id119" class="indexterm"/> will be used as a <code class="literal">ModelView</code> for a <code class="literal">CollectionView</code>:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class PhoneListItemView extends ModelView {
  constructor(options) {
    super(options);
    this.template = '#contact-form-phone-item';
  }

  get className() {
    return 'form-group';
  }
}

class PhoneListView extends CollectionView {
  constructor(options) {
    super(options);
    this.modelView = PhoneListItemView;
  }
}</pre></div><p>The contact form now should include two regions for <code class="literal">PhoneListView</code> and <code class="literal">EmailListView</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="panel panel-simple"&gt;
&lt;div class="panel-heading"&gt;
    Phones
&lt;button id="new-phone"
class="btn btn-primary btn-sm pull-right"&gt;New&lt;/button&gt;
&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;form class="form-horizontal phone-list-container"&gt;&lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="panel panel-simple"&gt;
&lt;div class="panel-heading"&gt;
    Emails
&lt;button id="new-email"
 class="btn btn-primary btn-sm pull-right"&gt;New&lt;/button&gt;
&lt;/div&gt;
&lt;div class="panel-body"&gt;
&lt;form class="form-horizontal email-list-container"&gt;&lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;</pre></div><p>
<code class="literal">ContactForm</code> should<a id="id120" class="indexterm"/> be changed to support regions; we will extend from <code class="literal">Layout</code> instead of <code class="literal">ModelView</code>:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactForm extends Layout {
  constructor(options) {
    super(options);
    this.template = '#contact-form';
    this.regions = {
      phones: '.phone-list-container',
      emails: '.email-list-container'
    };
  }

  // ...
}</pre></div><p>We will need two new models: <code class="literal">Phone</code> and <code class="literal">Email</code>. Because both models are very similar, I will only show <code class="literal">Phone</code>:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/models/phone.js
'use strict';

App.Models = App.Models || {};

class Phone extends Backbone.Model {
  get defaults() {
    return {
      description: '',
      phone: ''
    };
  }
}

App.Models.Phone = Phone;</pre></div><p>And collection that uses the <code class="literal">Phone</code> model:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/collections/phoneCollection.js
'use strict';

App.Collections = App.Collections || {};

class PhoneCollection extends Backbone.Collection {
  constructor(options) {
    super(options);
  }

  get model() {
    return App.Models.Phone;
  }
}

App.Collections.PhoneCollection = PhoneCollection;</pre></div><p>Now that we <a id="id121" class="indexterm"/>have the necessary objects to render the form, let's put them all together in the controller. First, we need to create the collection instances from the model data:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
  // ...

  showEditor(contact) {
// Data
    var phonesData = contact.get('phones') || [];
    var emailsData = contact.get('emails') || [];
this.phones = new App.Collections.PhoneCollection(phonesData);
this.emails = new App.Collections.EmailCollection(emailsData);

    // ...
  }

  // ...
}</pre></div><p>With the collections in place, we can build <code class="literal">CollectionView</code>s properly:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
  // ...

  showEditor(contact) {
    // ...

    // Create the views
    var layout = new ContactFormLayout({model: contact});
    var phonesView = new PhoneListView({collection: this.phones});
    var emailsView = new EmailListView({collection: this.emails});
    var contactForm = new ContactForm({model: contact});
    var contactPreview = new ContactPreview({model: contact});

    // ...
  }

  // ...
}</pre></div><p>The <code class="literal">phonesView</code> and <code class="literal">emailsView</code> can <a id="id122" class="indexterm"/>be rendered in the regions exposed in the <code class="literal">contactForm</code> object:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
  // ...

  showEditor(contact) {
    // ...

    // Render the views
    this.region.show(layout);
    layout.getRegion('form').show(contactForm);
    layout.getRegion('preview').show(contactPreview);
    contactForm.getRegion('phones').show(phonesView);
    contactForm.getRegion('emails').show(emailsView);

    // ...
  }

  // ...
}</pre></div><p>When the user clicks on the <span class="strong"><strong>New</strong></span> button, a new item in a proper list should be added:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactForm extends Layout {
  // ...

  get events() {
    return {
      'click #new-phone': 'addPhone',
      'click #new-email': 'addEmail',
      'click #save': 'saveContact',
      'click #cancel': 'cancel'
    };
  }

  addPhone() {
    this.trigger('phone:add');
  }

  addEmail() {
    this.trigger('email:add');
  }

  // ...
}</pre></div><p>The <code class="literal">ContactForm</code> knows<a id="id123" class="indexterm"/> nothing about the collections that we are using in the controller, so they can't add an item in the collection directly; the controller should listen for events in the <code class="literal">contactForm</code> and update the collection:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
  // ...

  showEditor(contact) {
    // ...

    this.listenTo(contactForm, 'phone:add', this.addPhone);
    this.listenTo(contactForm, 'email:add', this.addEmail);


    // ...
  }

  addPhone() {
    this.phones.add({});
  }

  addEmail() {
    this.emals.add({});
  }

  // ...
}</pre></div><p>When the user clicks on the <span class="strong"><strong>delete</strong></span> link in an item of the list, the item should be removed from the collection:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class PhoneListItemView extends ModelView {
  //...

  get events() {
    return {
      'click a': 'deletePhone'
    };
  }

  deletePhone(event) {
    event.preventDefault();
    this.trigger('phone:deleted', this.model);
  }
}</pre></div><p>As we did <a id="id124" class="indexterm"/>with <code class="literal">add</code>, the controller will take care of managing the collection data by attaching an event listener in the list view:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
  // ...

  showEditor(contact) {
    // ...

    this.listenTo(phonesView, 'item:phone:deleted',
(view, phone) =&gt; {
this.deletePhone(phone);
}
);
    this.listenTo(emailsView, 'item:email:deleted',
 (view, email) =&gt; {
this.deleteEmail(email);
}
);

    // ...
  }

  deletePhone(phone) {
    this.phones.remove(phone);
  }

  deleteEmail(email) {
    this.emails.remove(email);
  }

  // ...
}</pre></div><p>As you can see in the preceding snippets, adding items to the list (and removing them) is pretty simple; we just need <a id="id125" class="indexterm"/>to update the underlying collection and the views will be updated automatically. We did a great job with <code class="literal">CollectionViews</code> in the previous chapter.</p><p>To save the phone and email attributes in the model, we need to extract the data stored in the collections and replace the existing data in the model:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
  // ...

  saveContact(contact) {
    var phonesData = this.phones.toJSON();
    var emailsData = this.emails.toJSON();

    contact.set({
      phones: phonesData,
      emails: emailsData
    });

    contact.save(null, {
      success() {
        // Redirect user to contact list after save
        App.notifySuccess('Contact saved');
        App.router.navigate('contacts', true);
      },
      error() {
        // Show error message if something goes wrong
        App.notifyError('Something goes wrong');
      }
    });
  }
  // ...
}</pre></div><p>However, the <a id="id126" class="indexterm"/>collections are not in sync with the forms and you will end up with empty emails and phones. To fix this, we need to bind the models with the inputs:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class PhoneListItemView extends ModelView {
  // ...

  get events() {
    return {
      'change .description': 'updateDescription',
      'change .phone': 'updatePhone',
      'click a': 'deletePhone'
    };
  }

  updateDescription() {
    var $el = this.$('.description');
    this.model.set('description', $el.val());
  }

  updatePhone() {
    var $el = this.$('.phone');
    this.model.set('phone', $el.val());
  }

  // ...
}</pre></div><p>Now, if you click the <span class="strong"><strong>Save</strong></span> button, the data about the phones and emails will be stored as expected.</p><p>This way of binding embedded arrays in views through intermediate collections simplifies the way you work with lists and will make your code a lot simpler and more maintainable.</p></div></div>
<div class="section" title="Validating model data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Validating model data</h1></div></div></div><p>Usually, on <a id="id127" class="indexterm"/>frontend applications, the inputs are validated with UI plugins such as jQuery Validation, which focuses on the user interface. In other words, the data is validated directly on the DOM. However, on bigger applications that would not be the best approach.</p><p>Validations in Backbone can be done manually or through plugins. Of course, the best approach is to use a plugin because it saves time and effort, but before we learn how to use the <code class="literal">backbone.validation</code> plugin, I want to show you how native validation works.</p><div class="section" title="Manual validation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Manual validation</h2></div></div></div><p>Backbone <a id="id128" class="indexterm"/>models have three properties to help us validate the model data: <code class="literal">validate()</code>, <code class="literal">validationError()</code>, and<code class="literal"> isValid()</code>. The <code class="literal">validate()</code>method should return nothing if the model data is correct, or a value otherwise.</p><p>Backbone leaves open what should be returned by the <code class="literal">validate()</code> method, so you can return just a plain string message or a complex object:</p><div class="informalexample"><pre class="programlisting">class Chapter extends Backbone.Model{
  validate(attrs, options) {
    if (attrs.end &lt; attrs.start) {
      return "can't end before it starts";
    }
  }
}</pre></div><p>You can call the <code class="literal">isValid()</code> method to ensure that your model has a valid state; internally, Backbone will call the <code class="literal">validate()</code> method and will return a Boolean value depending on the returned value: <code class="literal">true</code> if <code class="literal">validate()</code> returns nothing, <code class="literal">false</code> if it returns something.</p><p>With <code class="literal">validationError</code>, you can get the latest validation error in the model—for example:</p><div class="informalexample"><pre class="programlisting">var one = new Chapter({
  title : "Chapter One: The Beginning",
  start: 15,
  end: 10
});

If (!one.isValid()) {
  alert(one.validationError);
}</pre></div><p>The <code class="literal">validate()</code> method is called by Backbone when you want to save the model, and will trigger an <code class="literal">'invalid'</code> event if the model is not valid:</p><div class="informalexample"><pre class="programlisting">one.on("invalid", function(model, error) {
  alert(model.get("title") + " " + error);
});

one.save({
  start: 15,
  end: 10
});</pre></div><p>In the contacts<a id="id129" class="indexterm"/> editor, we are not validating anything. It's time to start with some validations; let's validate the name of the contact:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/models/contact.js
var Contact extends Backbone.Model {
  validate(attrs) {
    if(_.isEmpty(attrs.name)) {
      return {
        attr: 'name',
        message: 'name is required'
      };
    }
  }
}

var contact = new Contact({
// ...
});</pre></div><p>Remember, the <code class="literal">validate()</code> method can return anything. Backbone will assume that the model is valid only if <code class="literal">validate()</code> does not return something. In this case, an object is returned. Objects are more useful that plain string, because return more information that can be used for a better user experience.</p><p>When an error occurs an <code class="literal">'invalid'</code> event will be triggered. The editor form should display the error, so that the form will be listening for the <code class="literal">'invalid'</code> event in the model, and managing the DOM to display error messages:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactForm extends Layout {
  constructor(options) {
    super(options);
    this.template = '#contact-form';
    this.regions = {
      phones: '.phone-list-container',
      emails: '.email-list-container'
    };

    this.listenTo(this.model, 'invalid', this.showError);
  }

// ...

  showError(model, error) {
    this.clearErrors();

    var selector = '#' + error.attr;
    var $msg = $('&lt;span&gt;')
      .addClass('error')
      .addClass('help-block')
      .html(error.message);
    this.$(selector)
      .closest('.form-group')
      .addClass('has-error');
    this.$(selector)
      .after($msg);
  }

  clearErrors() {
    this.$('.has-error').removeClass('has-error');
    this.$('span.error').remove();
  }
}</pre></div><p>The <code class="literal">showError()</code> method<a id="id130" class="indexterm"/> appends a <code class="literal">span</code> message below the input box, so the user can see what's wrong. With the <code class="literal">attr</code> property in the error object, we can put the error message in the right box; that's why using an error object is better than plain-text messages.</p><p>Note that we are creating a DOM element in the <code class="literal">showError()</code> method. I'm creating the element dynamically to simplify the code in the view. Of course, you can create a <code class="literal">span</code> element directly in the template too and show/hide it as needed.</p></div><div class="section" title="Validating with the Backbone.Validation plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Validating with the Backbone.Validation plugin</h2></div></div></div><p>
<code class="literal">Backbone.Validation</code> simplifies <a id="id131" class="indexterm"/>the<a id="id132" class="indexterm"/> validation process, allowing us to <a id="id133" class="indexterm"/>write validation rules in a declarative way instead of programmatically. Also, it comes with built-in validation rules that you can use out-of-the-box. When using <code class="literal">Backbone.Validation</code>, the way you validate models is simplified, as we will show next.</p><p>To start with <code class="literal">Backbone.Validation</code>, install the plugin after including Backbone.</p><div class="informalexample"><pre class="programlisting">&lt;script src="js/vendor/backbone.js"&gt;&lt;/script&gt;
&lt;script src="js/vendor/backbone-validation.js"&gt;&lt;/script&gt;</pre></div><p>Now we can use the plugin; <code class="literal">Backbone.Validation</code> uses a validation property in the models to specify validation rules:</p><div class="informalexample"><pre class="programlisting">class Contactextends Backbone.Model {
get validation: {
    name: {
      required: true,
      minLength: 3
    }
  }
}</pre></div><p>Instead of using the <code class="literal">validate()</code> method, you can write the validation rules in a configuration object, where the keys of the object are the name of the fields in the model; in this case, we are validating the <code class="literal">name</code> field. The <code class="literal">required</code> and <code class="literal">minLength</code> validation rules are applied to the <code class="literal">name</code> field by <code class="literal">Backbone.Validation</code>.</p><p>Now that the <code class="literal">Contact</code> model has the validation configuration, we need to override the default <code class="literal">validate()</code> method in the Backbone model to activate the <code class="literal">Backbone.Validation</code> plugin. To do it, we need to call the <code class="literal">Backbone.Validation.bind()</code> method in the <code class="literal">onRender()</code> method:</p><div class="informalexample"><pre class="programlisting">class ContactForm extends Layout {
// ...

  onRender() {
    Backbone.Validation.bind(this);
  }

  // …
});</pre></div><p>The <code class="literal">showError()</code> and <code class="literal">clearErrors()</code>are now unnecessary because we override the <code class="literal">validate()</code> method on the model. The <code class="literal">Backbone.Validation</code> plugin provides hooks to tell you when a model is valid; we will use these hooks as a shortcut. For now, the <code class="literal">save:contact</code> handler<a id="id134" class="indexterm"/> should change to invoke the <code class="literal">isValid()</code> method:</p><div class="informalexample"><pre class="programlisting">formLayout.on('save:contact', function() {
  if (!contact.isValid(true)) {
    return;
  }
  contact.unset('phones', { silent: true });
  contact.set('phones', phoneCollection.toJSON());
});</pre></div><p>Note the<a id="id135" class="indexterm"/> <code class="literal">true</code> argument in the <code class="literal">isValid()</code> method; this argument should be used to validate all the model attributes.</p><p>When <code class="literal">Backbone.Validation</code> detects that a field is invalid, it will try to show an error message in the form; however, the default behavior is based on the <code class="literal">name</code> attribute in the form inputs. You can change the default behavior to show errors properly in our layout:</p><div class="informalexample"><pre class="programlisting">// app.js
_.extend(Backbone.Validation.callbacks, {
  valid(view, attr) {
    var $el = view.$('#' + attr);
    if ($el.length === 0) {
      $el = view.$('[name~=' + attr + ']');
    }

    // If input is inside an input group, $el is changed to
    // remove error properly
    if ($el.parent().hasClass('input-group')) {
      $el = $el.parent();
    }

    var $group = $el.closest('.form-group');
    $group.removeClass('has-error')
      .addClass('has-success');

    var $helpBlock = $el.next('.help-block');
    if ($helpBlock.length === 0) {
      $helpBlock = $el.children('.help-block');
    }
    $helpBlock.slideUp({
      done: function() {
        $helpBlock.remove();
      }
    });
  },

  invalid(view, attr, error) {
    var $el = view.$('#' + attr);
    if ($el.length === 0) {
      $el = view.$('[name~=' + attr + ']');
    }

    $el.focus();

    var $group = $el.closest('.form-group');
    $group.removeClass('has-success')
      .addClass('has-error');

    // If input is inside an input group $el is changed to
    // place error properly
    if ($el.parent().hasClass('input-group')) {
      $el = $el.parent();
    }

    // If error already exists and its message is different to new
    // error's message then the previous one is replaced,
    // otherwise new error is shown with a slide down animation
    if ($el.next('.help-block').length !== 0) {
      $el.next('.help-block')[0].innerText = error;
    } else if ($el.children('.help-block').length !== 0) {
      $el.children('.help-block')[0].innerText = error;
    } else {
      var $error = $('&lt;div&gt;')
                 .addClass('help-block')
                 .html(error)
                 .hide();

      // Placing error
      if ($el.prop('tagName') === 'div' &amp;&amp;
 !$el.hasClass('input-group')) {
        $el.append($error);
      } else {
        $el.after($error);
      }

      // Showing animation on error message
      $error.slideDown();
    }
  }
});</pre></div><p>The <code class="literal">invalid()</code> method <a id="id136" class="indexterm"/>will be called when invalid data is found; the callback is called with an instance of the view, the<a id="id137" class="indexterm"/> field name that has the invalid data, and a message. With that information, we can create a <code class="literal">span</code> error message and add the <code class="literal">has-error</code> class to the <code class="literal">control-group</code> that contains the input.</p><p>Please consult the <code class="literal">Backbone.Validation</code> documentation to learn more about its advantages and usage.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we learned how to keep models and views in sync. In general, syncing model and views is easy but things can turn difficult if the model has embedded arrays. You can use a plugin to simplify the data binding; <code class="literal">Backbone.Stickit</code> is a good option because it allows you to make your bindings in a declarative way.</p><p>I showed you how you can make two-way data binding with a vanilla Backbone, taking advantage of the event system; it's not always a good idea to use intensive two-way data binding in your applications but in some cases it can be useful.</p><p>Finally, we learned how to validate models with Backbone and how to use the validation API to show error messages in views. The <code class="literal">Backbone.Validation</code> plugin can help you to validate Backbone models easily with minimal effort, once validation callbacks are set correctly.</p><p>In the next chapter, we will learn how to modularize our contacts application to make it more maintainable and more effectively manage dependencies. Then we will bundle the whole application in a single script to load it faster.</p></div></body></html>