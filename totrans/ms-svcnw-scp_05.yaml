- en: Introduction to Server-Side Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端脚本简介
- en: In this chapter, we will now take a look at the server side of scripting. Here,
    we look at getting started writing server-side scripts by introducing the basics
    for producing server-side code. We will also see how to test these scripts and
    take a look at some examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们现在将探讨脚本的服务器端。在这里，我们通过介绍生成服务器端代码的基本知识来开始编写服务器端脚本。我们还将了解如何测试这些脚本，并查看一些示例。
- en: 'We will be looking at the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Business rules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业规则
- en: UI actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI动作
- en: Access controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: How and when to write server-side scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及何时编写服务器端脚本
- en: Testing a server-side script
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试服务器端脚本
- en: Server-side script examples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端脚本示例
- en: Business rules
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业规则
- en: Business rules are usually the most used server-side scripting method. It is
    possible to use business rules in a basic way that simply requires configuration,
    rather than customization. I will say that for the majority of requirements that
    need a business rule, you will most often need to add some sort of customization
    in the form of scripts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 商业规则通常是使用最广泛的服务器端脚本方法。可以使用商业规则进行基本的配置，而不是定制。我可以说，对于大多数需要商业规则的需求，你通常需要添加一些形式的定制，即脚本。
- en: A particularly helpful aspect of business rules is the different ways they can
    be triggered. This allows us to run our server-side scripts at different times,
    based on actions that occur to a record.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 商业规则的一个特别有用的方面是它们可以以不同的方式被触发。这允许我们根据对记录发生的操作，在服务器端脚本的不同时间运行。
- en: When first viewing the business rule form, there are two options for when to
    run the business rule. These are upon the insert or update of the record. With
    the business rule in this essentially basic view, we can configure the business
    rule to run on a filter condition or ownership of a role and change field values.
    If we want to do more than this, which is often the case, we need to tick the
    advanced tick box on the form.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次查看商业规则表单时，有两个选项来决定何时运行商业规则。这些是在记录的插入或更新时。在这个基本上是基本视图的商业规则中，我们可以配置商业规则在筛选条件或角色的所有者以及更改字段值时运行。如果我们想做的更多，这通常是情况，我们需要在表单上勾选高级复选框。
- en: 'Once the advanced tick box has been checked, we then have four options for
    what action the business rule should run on. Let''s look at what these are and
    when, exactly, they run:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦勾选了高级复选框，我们就有四个选项来决定商业规则应该运行的动作。让我们看看这些选项是什么，以及它们确切运行的时间：
- en: 'Insert: Runs when a new record is inserted'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：在插入新记录时运行
- en: 'Update: Runs when a record is updated'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新：在记录更新时运行
- en: 'Delete: Runs when a record is deleted'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：在记录被删除时运行
- en: 'Query: Runs when records of this type are searched against'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询：当搜索此类记录时运行
- en: 'The time that a business rule runs is also dependent on the value of the When
    field. Here, we also have four options to choose from:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 商业规则运行的时间也取决于“何时”字段的值。在这里，我们也有四个选项可供选择：
- en: 'Before: Runs before the record is saved'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在保存记录之前：在记录保存之前运行
- en: 'After: Runs straight after the record is saved'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后：在记录保存后立即运行
- en: 'Async: Runs when the scheduler runs a scheduled job that gets sent to the scheduled
    job queue after the record is saved'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步：在调度器运行一个在记录保存后发送到计划作业队列的计划作业时运行
- en: 'Display: Runs before the form is loaded, after the data has been fetched from
    the database'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示：在从数据库获取数据后加载表单之前运行
- en: It is best to use before business rules when you are updating the record itself;
    then the changes are made before the insert or update, and so the record only
    updates once. After business rules should be used when the script does not affect
    the current record, so the script can run after a save.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在更新记录本身时，最好使用“之前”商业规则；这样，更改是在插入或更新之前进行的，因此记录只更新一次。应该使用“之后”商业规则，当脚本不影响当前记录时，这样脚本就可以在保存后运行。
- en: Async will run at some point in the future, so I would only use this if the
    actions taken in the script do not need to be seen straight away. This can be
    for queuing up events for notifications or sending jobs out from ServiceNow. Display
    business rules are best used to hold data in a scratchpad so that a client-side
    script can utilize it. This is helpful, as it stops client-side script from having
    to make a round-trip to the server, as the display business rule has already collected
    the data needed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 异步将在未来的某个时刻运行，所以只有当脚本中的操作不需要立即看到时，我才会使用它。这可以是排队事件以发送通知或从ServiceNow发送作业。显示业务规则最好用于在草稿板上保存数据，以便客户端脚本可以利用它。这很有帮助，因为它阻止客户端脚本需要往返服务器，因为显示业务规则已经收集了所需的数据。
- en: Using these checkboxes and the When field in combination gives a good selection
    of triggers for running our server-side script. The most common tends to be a
    before or after When field value with the insert and update checkboxes ticked.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些复选框和“当”字段，我们可以为运行我们的服务器端脚本提供良好的触发器选择。最常见的是勾选“插入”和“更新”复选框的“之前”或“之后”的“当”字段值。
- en: With the advanced box ticked, we can also see the advanced form section. This
    gives us the condition for running the script and a script field to put our server-side
    code into.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当勾选了高级复选框后，我们还可以看到高级表单部分。这为我们提供了运行脚本的条件和用于放入我们的服务器端代码的脚本字段。
- en: Now that we've had a look at the form of a business rule, let's have a look
    at how we add script. All we need to do is set up the form for when we want the
    script to run, add a condition if appropriate, and add our code in the script
    field.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了业务规则的格式，接下来让我们看看如何添加脚本。我们只需要设置脚本运行时的表单，如果需要的话添加一个条件，然后在脚本字段中添加我们的代码。
- en: 'As an example, we''ll set a network category incident to a high impact when
    created. For this, we need to add a condition in the condition field:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将创建网络类别事件时将其影响设置为高。为此，我们需要在条件字段中添加一个条件：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This condition field is helpful to stop running through scripts when it is not
    necessary. In the preceding code, we will only run our script if the category
    is `network`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件字段有助于在不必要时停止运行脚本。在先前的代码中，我们只有在类别是`network`时才会运行我们的脚本。
- en: 'Now we''ll look at the script we will run:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们将运行的脚本：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, let's look at the code ServiceNow gives us for a business rule. The `executeRule`
    function we are provided with has two parameters: `current` and `previous`. `current`
    is the object that holds all the current values of the record when the business
    rule is triggered. `previous` is the object that holds the value of the record
    before any updates were made, essentially holding the previous values. Previous
    can only be used with the `update` and `delete` actions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看ServiceNow为我们提供的业务规则代码。我们提供的`executeRule`函数有两个参数：`current`和`previous`。`current`是当业务规则被触发时包含记录所有当前值的对象。`previous`是包含任何更新之前记录值的对象，本质上持有前一个值。Previous只能与`update`和`delete`操作一起使用。
- en: 'Our example sets the impact to high for network category incidents. For our
    example, we would set the When field to before, which means we do not need to
    add any script to update the record, as we are changing the current record before
    it is being saved. We also need to check the insert checkbox on our business rule.
    We can see the business rule itself in *Figure 5.1*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将网络类别事件的影响设置为高。对于我们的示例，我们将“当”字段设置为“之前”，这意味着我们不需要添加任何脚本来更新记录，因为我们是在记录被保存之前更改当前记录。我们还需要在我们的业务规则中勾选“插入”复选框。我们可以在*图5.1*中看到业务规则本身：
- en: '![](img/84ad9c52-5dcc-4a1b-8d56-0ac35a32d2a9.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84ad9c52-5dcc-4a1b-8d56-0ac35a32d2a9.png)'
- en: 'Figure 5.1: Business rule setting a high impact for network category incidents'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：为网络类别事件设置高影响力的业务规则
- en: This gives an overview of how business rules work, and they are very well used
    across the ServiceNow platform.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们概述了业务规则的工作方式，并且在ServiceNow平台上被广泛使用。
- en: UI actions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI操作
- en: UI actions are the buttons, context menu selections, links, and list selections
    that you find throughout ServiceNow. Because you can make UI actions appear in
    different areas of the platform, they can be incredibly handy to add your script
    to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: UI操作是你可以在ServiceNow中找到的按钮、上下文菜单选择、链接和列表选择。因为你可以让UI操作出现在平台的不同区域，所以它们可以非常方便地添加你的脚本。
- en: I tend to find that the form buttons are most used for UI actions. These can
    be added as helpful additional buttons to add functionality or ways to move records
    through different states of a process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于发现表单按钮在 UI 动作中最常被使用。这些可以作为有用的附加按钮添加功能或以不同状态移动记录的方法。
- en: A UI action normally runs on the server side; however, we can run them on the
    client side, too, as we explored in the client-side chapters. By using the tick
    boxes, we can run UI actions on an insert when the record is created or on an
    update once the record already exists.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: UI 动作通常在服务器端运行；然而，我们也可以在客户端运行它们，正如我们在客户端章节中探讨的那样。通过使用复选框，我们可以在创建记录时插入 UI 动作，或者在记录已存在时更新。
- en: 'First, let''s take a look at the different ways you can display a UI action
    to the user. By ticking the relevant checkboxes, a UI action you create can be
    displayed in one or multiple ways. Let''s have a look at these options:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看您可以将 UI 动作显示给用户的不同方式。通过勾选相关的复选框，您创建的 UI 动作可以以一种或多种方式显示。让我们看看这些选项：
- en: '**Form button**: This displays the the UI action as a button on the form, similar
    to the Update button'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单按钮**：这将在表单上以按钮的形式显示 UI 动作，类似于更新按钮'
- en: '**Form context menu**: Displays the UI action in the context menu, the menu
    that appears when you right-click the header bar of the form'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单上下文菜单**：在上下文菜单中显示 UI 动作，该菜单在您右键单击表单标题栏时出现'
- en: '**Form link**: Displays the UI action as a link in the related links section,
    which appears between the form sections and related lists'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单链接**：在相关链接部分以链接的形式显示 UI 动作，该部分出现在表单部分和关联列表之间'
- en: '**List banner button**: Displays the UI action as a button at the top of a
    list view, next to the table label'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表横幅按钮**：在列表视图的顶部以按钮的形式显示 UI 动作，位于表标签旁边'
- en: '**List bottom button**: Shows the UI action at the bottom of a list as a button'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表底部按钮**：在列表底部以按钮的形式显示 UI 动作'
- en: '**List context menu**: Displays the UI action in the list context menu, accessed
    by right-clicking in a list of records'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表上下文菜单**：在记录列表中通过右键单击显示 UI 动作'
- en: '**List choice**: The UI actions appear in the choices of actions on selected
    rows at the bottom of the list'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表选择**：UI 动作出现在列表底部选定行的操作选择中'
- en: '**List link**: Shows the UI action in the related links section at the bottom
    of a list'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表链接**：在列表底部相关链接部分显示 UI 动作'
- en: In a similar way to business rules, we also get a condition and script field
    for UI actions. However, the script field starts blank on a UI action, so the
    developer must provide all of the code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与业务规则类似，我们同样为 UI 动作获取一个条件和脚本字段。然而，脚本字段在 UI 动作上开始时是空的，因此开发者必须提供所有代码。
- en: 'We''ll take a look at scripting a basic UI action. For our example, we''ll
    build a form button to change an incident state to `In progress`. Let''s take
    a look at the code we need:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看如何编写一个基本的 UI 动作脚本。以我们的示例为例，我们将构建一个表单按钮来将事件状态更改为“进行中”。让我们看看我们需要编写的代码：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we set the state to the value of `2`, which corresponds
    to the `In progress` state for incidents. Once this value has been set, all we
    need to do is update the record using `current.update`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将状态设置为 `2` 的值，这对应于事件的状态“进行中”。一旦设置了此值，我们只需要使用 `current.update` 更新记录。
- en: The `action.setRedirectURL` line is used in UI actions to redirect to the current
    record once the server-side script has run. If no redirection code is used when
    a UI action is pressed on a form, it will move back to the previous screen, usually
    the list view the record was selected from.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`action.setRedirectURL` 这一行在 UI 动作中用于在服务器端脚本运行后重定向到当前记录。如果在表单上按下 UI 动作而没有使用重定向代码，它将返回到上一个屏幕，通常是选择记录的列表视图。'
- en: In our script, this redirection line is saying that once the code has run, redirect
    the page to somewhere different; in our example, we use `current` as the current
    record. This then redirects back to the record we are on. This is helpful if we
    want to keep the user on the same record and show them the changes our UI action
    has made. In this case, the user should be able to see the state change.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，这条重定向行表示代码运行后，将页面重定向到不同的位置；在我们的示例中，我们使用 `current` 作为当前记录。然后它将重定向回我们所在的记录。如果我们想保持用户在同一个记录上并显示我们的
    UI 动作所做的更改，这很有用。在这种情况下，用户应该能够看到状态变化。
- en: 'We can see the UI action in *Figure 5.2*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图 5.2*中看到 UI 动作：
- en: '![](img/b76204ed-953e-4ea2-a92d-be09ac157d2a.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b76204ed-953e-4ea2-a92d-be09ac157d2a.png)'
- en: 'Figure 5.2: UI action that moves the state field to In progress'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：将状态字段移动到进行中的UI操作
- en: Here, we are only using our UI action as a form button, but we could also display
    it in other ways by using the tick boxes on the right. This UI action will appear
    on new and existing incident forms with the Show insert and Show update tick boxes
    checked.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只使用我们的UI操作作为表单按钮，但我们可以通过使用右侧的复选框以其他方式显示它。此UI操作将在带有“显示插入”和“显示更新”复选框勾选的新和现有事件表单上出现。
- en: Access controls
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制
- en: Access controls are a security aspect of ServiceNow, and whether access is given
    is mainly governed by configured roles. However, if a more complex calculation
    as to whether users are allowed access is required, we need to use script to account
    for this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制是ServiceNow的安全方面，访问是否授予主要受配置的角色控制。然而，如果需要更复杂的计算来确定用户是否允许访问，我们需要使用脚本来处理这一点。
- en: Generally, access controls are defined without the need for scripting, but there
    are still a fair amount of scenarios that require code to be used. These are often
    when information about a user is needed further than their roles; for example,
    their group membership or company.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，访问控制无需脚本即可定义，但仍有许多场景需要使用代码。这些通常是在需要用户信息超出其角色范围时；例如，他们的组成员或公司。
- en: To amend access controls, you need to have the security_admin role and ensure
    that you elevate privileges and use it before trying to make changes to them.
    To get to the scripting aspect of an access control, you need to tick the advanced
    checkbox. Once this is done, the script field will appear at the bottom of the
    form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改访问控制，您需要拥有security_admin角色，并确保在尝试修改之前提升权限并使用它。要访问访问控制的脚本方面，您需要勾选高级复选框。一旦完成，脚本字段将出现在表单底部。
- en: 'For each access control, a user is only granted access if they match all three
    aspects of the access control: the role, condition, and script. This is worth
    remembering when writing your access scripts, as it could be a role or condition
    stopping access, rather than the code you have written.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个访问控制，只有当用户匹配访问控制的三个方面：角色、条件和脚本时，才会授予用户访问权限。在编写您的访问脚本时，这值得记住，因为可能是角色或条件阻止了访问，而不是您编写的代码。
- en: 'Now let''s take a look at some access control code. Here, we will allow write
    access to the task number field if the user is part of the current assignment
    group:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些访问控制代码。在这里，我们将允许如果用户是当前分配组的成员，则对任务编号字段进行写访问：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example will allow the user access if they are a member of the current
    assignment group. The script in an access control needs to set an answer variable
    to true or false, or simply evaluate to true or false. In the example, we are
    just using the evaluation method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将允许用户访问，如果他们是当前分配组的成员。访问控制中的脚本需要将答案变量设置为true或false，或者简单地评估为true或false。在示例中，我们只是使用评估方法。
- en: 'In *Figure 5.3*, we can see the whole access control, allowing write access
    to the task number field. This would apply to task tables; for example, incident,
    change, and problem:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.3*中，我们可以看到整个访问控制，允许对任务编号字段进行写访问。这适用于任务表；例如，事件、变更和问题：
- en: '![](img/d4dd062c-1770-4d73-a7aa-fdf9cefc05fd.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4dd062c-1770-4d73-a7aa-fdf9cefc05fd.png)'
- en: 'Figure 5.3: Access control for the Number field on the Task table'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：任务表上数字字段的访问控制
- en: Access control scripting can be fairly short, and you tend to not get such complicated
    code here, but getting the right code is very important, as access controls can
    become a very complicated area of ServiceNow, with many rules applying and not
    applying to grant or disallow access for users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制脚本可以相当简短，并且您通常不会在这里遇到复杂的代码，但得到正确的代码非常重要，因为访问控制可以成为ServiceNow的一个非常复杂的领域，有许多规则适用于或不适用于授予或拒绝用户访问。
- en: How and when to write server-side scripts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何以及何时编写服务器端脚本
- en: Server-side scripting is generally preferred to client-side scripting, so it
    should be used where possible. As server-side script tends to run away from the
    user frontend, it is less likely to affect loading times that a user would see
    as a poor user experience.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端脚本通常比客户端脚本更受欢迎，因此应在可能的情况下使用。由于服务器端脚本通常在用户前端之外运行，因此它不太可能影响用户会看到的不良用户体验的加载时间。
- en: That said, it is still advisable to configure before customizing and avoid scripting
    at all, wherever possible. This is because script is harder to maintain and is
    more likely to cause issues between releases of ServiceNow.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，仍然建议在自定义之前进行配置，并在可能的情况下避免脚本化。这是因为脚本更难维护，并且更有可能在ServiceNow的版本之间引起问题。
- en: Let's explore some common uses for server-side scripting and how to best achieve
    these tasks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一些服务器端脚本的一些常见用途以及如何最佳完成这些任务。
- en: Changing form values
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改表单值
- en: Changing form values is usually best achieved by a business rule or UI action.
    If you want to change values when a user makes a click, then a UI action is best;
    however, if you simply want the values to change at all times when certain conditions
    are met, then a business rule is better. It is best to use a before business rule
    so that the form is only updated once.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过业务规则或UI操作来更改表单值通常是最佳选择。如果你想在使用者点击时更改值，那么UI操作是最好的；然而，如果你只想在满足某些条件时始终更改值，那么业务规则会更好。最好使用前置业务规则，这样表单就只会更新一次。
- en: Restricting access to forms and fields
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制表单和字段的访问
- en: When restricting access to forms and fields, it is best to use an access control.
    An access control will restrict access no matter how a form is accessed, so it
    is a powerful tool. If you only need to use roles or conditions to control access
    to forms and fields, then that is the preferred method, as this is classed as
    configuration and is easier to maintain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在限制表单和字段的访问时，最好使用访问控制。访问控制将限制无论以何种方式访问表单的访问，因此它是一个强大的工具。如果你只需要使用角色或条件来控制表单和字段的访问，那么这是首选方法，因为这被视为配置，并且更容易维护。
- en: If your access requirements are more complicated or convoluted than this, though,
    you will need to add script to the access control. The most common reasons for
    this are that a user needs to be part of certain groups or the user is referenced
    in fields on the form.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的访问要求比这更复杂或更复杂，那么你需要向访问控制中添加脚本。最常见的原因是用户需要成为某些组的成员，或者用户在表单的字段中被引用。
- en: Passing values to the client side
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将值传递到客户端
- en: Sometimes, you may want to pass values to the client side because they will
    not be visible on the loaded form, and these values may be useful for running
    client scripts. In this instance, you will want to use a display business rule.
    This allows scratchpad values to be set in the display business rule, which can
    then be used in client-side script on the form.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要将值传递到客户端，因为它们在加载的表单中不可见，而这些值可能对运行客户端脚本很有用。在这种情况下，你将想要使用显示业务规则。这允许在显示业务规则中设置临时值，然后可以在表单的客户端脚本中使用这些值。
- en: If you are considering calling the server from an `onLoad` client script, then
    it is usually better to use a display business rule instead, as this eliminates
    the need for an extra call to the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑在`onLoad`客户端脚本中调用服务器，那么通常更好的做法是使用显示业务规则，因为这样可以消除对服务器额外调用的需求。
- en: 'We can see what a display business rule looks like in *Figure 5.4*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图5.4*中看到显示业务规则的外观：
- en: '![](img/1ea516bb-7de8-439c-9dd2-0032485309dd.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ea516bb-7de8-439c-9dd2-0032485309dd.png)'
- en: 'Figure 5.4: Display business rule example'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：显示业务规则示例
- en: It is worth noting that once we pick the When to run field as display, we no
    longer have the Insert, Update, Delete, or Query checkboxes available to select.
    This is because a display business rule always runs at the same time, just before
    the form is loaded.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一旦我们选择了“何时运行”字段作为显示，我们就不再有插入、更新、删除或查询复选框可供选择。这是因为显示业务规则总是在表单加载之前以相同的时间运行。
- en: Review
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: We have looked at a few examples of when to script on the server and the best
    way to do it in various scenarios. Server-side scripting is usually much more
    common than client-side scripting and accounts for the majority of code in most
    ServiceNow instances.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了一些在服务器上脚本化以及在不同场景下如何最佳实现这些任务的例子。服务器端脚本通常比客户端脚本更常见，并且占大多数ServiceNow实例代码的大部分。
- en: Therefore, we are really just beginning to look at the possibilities of server-side
    scripting. There is great potential in the code that can be written, and we will
    explore some more advanced methods in the following chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实际上刚刚开始探讨服务器端脚本的可能性。代码中存在巨大的潜力，我们将在下一章中探讨一些更高级的方法。
- en: Testing server-side scripts
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务器端脚本
- en: As with client-side scripting, there are a few ways to test server-side scripts.
    These are generally less immediate than the client-side debugging techniques,
    but essential when working to fix your code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端脚本一样，测试服务器端脚本有几种方法。这些方法通常不如客户端调试技术那么直接，但在修复代码时是必不可少的。
- en: gs.log
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gs.log
- en: The first logging technique we will look at is `gs.log`. This was a very popular
    technique, and still is fairly widely used by developers. As we saw in [Chapter
    2](45863911-2233-475a-96b7-b076a4277a55.xhtml)*,* *Exploring the ServiceNow Glide
    Class*, `gs.log` lets us send logs to the system log with a script source so we
    can send messages as a piece of code executes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一种日志技术是`gs.log`。这是一种非常流行的技术，并且仍然被开发者广泛使用。正如我们在[第2章](45863911-2233-475a-96b7-b076a4277a55.xhtml)*探索ServiceNow
    Glide类*中看到的，`gs.log`让我们能够将日志发送到系统日志，带有脚本源，这样我们可以在代码执行时发送消息。
- en: We can create a `gs.log` from any server-side script, which makes it very useful;
    however, we cannot use it in a scoped application. We will have a look at scoped
    application logging later. As long as you are in the global scope, you can use
    `gs.log` and send messages to the system logs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从任何服务器端脚本中创建`gs.log`，这使得它非常有用；然而，我们无法在范围应用程序中使用它。我们将在稍后查看范围应用程序的日志记录。只要你在全局范围内，你就可以使用`gs.log`并向系统日志发送消息。
- en: 'Let''s remind ourselves of a simple piece of code using a `gs.log`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下使用`gs.log`的简单代码片段：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This log will appear in the Script Log Statements module in the application
    navigator when the script runs. We can also show the values of variables at certain
    stages in a script using this method. We could use this to display the caller
    on an incident record:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本运行时，此日志将出现在应用程序导航器中的脚本日志语句模块中。我们还可以使用此方法在脚本中的某个阶段显示变量的值。我们可以使用此方法来显示事件记录上的调用者：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This would display the current caller of an incident in the logs if used in
    a business rule. We can use the plus symbol to add strings and variables to our
    logging.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在业务规则中使用，这将显示日志中的当前事件调用者。我们可以使用加号符号向我们的日志添加字符串和变量。
- en: This method allows us to add as many logs as we like to our scripts to check
    that methods were called or the values of variables at certain points in the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许我们在脚本中添加尽可能多的日志，以检查方法是否在代码的某些点上被调用或变量的值。
- en: Remember to remove all of your `gs.log` statements or comment them out before
    putting your code live. Leaving too many logging lines in code can make the system
    logs difficult to debug.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在将代码上线之前删除所有的`gs.log`语句或将其注释掉。代码中留下太多的日志行会使系统日志难以调试。
- en: Logging in scoped applications
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围应用程序的日志记录
- en: As we discovered when we looked at `gs.log`, it does not work in scoped applications.
    For logging in scoped applications, we need to use a different method. In fact,
    there are four methods that can be used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在查看`gs.log`时发现的，它不在范围应用程序中工作。在范围应用程序中进行日志记录时，我们需要使用不同的方法。实际上，有四种方法可以使用。
- en: 'The four levels of logging in a scoped application are:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 范围应用程序中的四个日志级别是：
- en: '`Error`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误`'
- en: '`Warn`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告`'
- en: '`Info`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`信息`'
- en: '`Debug`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`调试`'
- en: This type of logging works in a very similar way to `gs.log`, but with the different
    levels of log replacing the word `log` after `gs`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的日志记录与`gs.log`非常相似，但用不同的日志级别替换了`gs`之后的单词`log`。
- en: 'Let''s have a look at how to write a basic script for each:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为每个编写一个基本的脚本：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These logs are visible in the application logs table, which can be viewed by
    going to System Logs | System Log | Application Logs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志可以在应用程序日志表中查看，可以通过访问系统日志 | 系统日志 | 应用程序日志来实现。
- en: By default, when you create a new application scope, only error, warn, and info
    messages are displayed, as set by the system property related to the scope. This
    property will be named `<scope name>.logging.verbosity` and can be set at any
    of the four levels. For each level set, it will show messages at that level and
    any higher-level message types. As the default value for the property is info,
    we will see all messages, apart from debug.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你创建一个新的应用程序范围时，只有错误、警告和info消息会被显示，这是由与范围相关的系统属性设置的。这个属性将被命名为`<scope name>.logging.verbosity`，可以在四个级别中的任何一个设置。对于每个设置的级别，它将显示该级别和任何更高级别的消息类型。由于属性的默认值是info，我们将看到所有消息，除了debug。
- en: In general, a lot of developers will simply use info messages as a generic way
    to debug script on the server side. However, if you are building debugging into
    the scoped application being created, it is better to use all of the level types
    for a more complete solution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，许多开发者会简单地使用信息消息作为在服务器端调试脚本的通用方式。然而，如果你正在将调试功能集成到创建的范围内应用程序中，最好使用所有级别类型以获得更完整的解决方案。
- en: Session debug
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话调试
- en: ServiceNow also provides some server-side debugger assistance in the form of
    session debugging. These are mainly listed as modules in the System Diagnostics
    application, but there is also security debugging available in the System Security
    application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow 还提供了一些服务器端调试辅助功能，形式为会话调试。这些主要列在系统诊断应用程序中的模块中，但在系统安全应用程序中也有安全调试可用。
- en: By clicking on these modules, you activate the debugging for that particular
    area; for example, business rules. This lasts for the session, or until you turn
    the debugging off by using the Disable All module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击这些模块，你可以激活特定区域的调试；例如，业务规则。这会持续到会话结束，或者你通过使用禁用所有模块来关闭调试。
- en: I have found that these modules can be useful, mainly for the security rule
    debugging, but are not generally comprehensively used by developers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这些模块很有用，主要是用于安全规则调试，但开发者通常并不全面地使用它们。
- en: Script debugger
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本调试器
- en: The script debugger has been introduced in the Istanbul release for use in server-side
    scripting. This allows developers to set break points in any server-side script,
    to then step through in the debugger.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本调试器是在伊斯坦布尔版本中引入的，用于服务器端脚本。这允许开发者设置任何服务器端脚本的断点，然后在调试器中逐步执行。
- en: 'To use the debugger, you must first click the left margin in a script to create
    a break point. Then, to load the script debugger, navigate to System Diagnostics
    | Script Debugger. The script debugger appears in a new window, where you can
    see the break points created in the script, as in *Figure 5.5*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用调试器，你必须首先在脚本中点击左侧边缘以创建断点。然后，要加载脚本调试器，导航到系统诊断 | 脚本调试器。脚本调试器在一个新窗口中显示，你可以看到在脚本中创建的断点，如图
    *5.5* 所示：
- en: '![](img/659e6278-61f6-4363-b5f6-575b5280e155.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/659e6278-61f6-4363-b5f6-575b5280e155.png)'
- en: 'Figure 5.5: Script debugger stepping through the incident events business rule'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：脚本调试器逐步执行事件业务规则
- en: Once the debugger is opened, trigger the script, and you are given the option
    to Start Debugging, which will allow you to step through the script.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开调试器，触发脚本，你将获得启动调试的选项，这将允许你逐步执行脚本。
- en: This can be a helpful tool if you need to find out where issues are in a script
    and are unsure of where in the script the problem lies. This is also a good tool
    for longer scripts often housed in script includes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要找出脚本中的问题所在，但不确定问题出在脚本中的哪个位置，这是一个有用的工具。这也是一个很好的工具，用于处理通常包含在脚本包含中的较长的脚本。
- en: Script examples
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本示例
- en: Now that we have seen how the basics of server-side scripting work, we can take
    a look at some scripting examples to further our knowledge of how to use these
    introductory server-side techniques.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了服务器端脚本的基本工作原理，我们可以看看一些脚本示例，以进一步了解如何使用这些入门级服务器端技术。
- en: We'll start with a further business rule example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个更进一步的业务规则示例开始。
- en: 'This time, we will create a before delete business rule to ensure that directors
    are not deleted. We need to set the business rule to advanced; select the delete
    checkbox and before in the When field. Let''s have a look at the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将创建一个删除前业务规则，以确保董事不会被删除。我们需要将业务规则设置为高级；选择删除复选框并在当字段中选择“之前”。让我们看看代码：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are checking whether the user is a director using the title field,
    and if so, using `setAbortAction` to stop the `delete` going ahead. To ensure
    the user is kept informed, we are also using `addErrorMessage` to display a message
    to the user and `action.setRedirectURL` to keep the user on the current record,
    so that they can see that the `delete` did not go ahead.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用标题字段检查用户是否是董事，如果是，则使用 `setAbortAction` 来阻止 `delete` 操作进行。为了确保用户得到通知，我们还使用
    `addErrorMessage` 向用户显示消息，并使用 `action.setRedirectURL` 保持用户在当前记录上，这样他们就可以看到 `delete`
    没有进行。
- en: 'The rule can be seen in *Figure 5.6*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则可以在 *图 5.6* 中看到：
- en: '![](img/307d57aa-70e8-4d80-9a96-61f2879fd280.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/307d57aa-70e8-4d80-9a96-61f2879fd280.png)'
- en: 'Figure 5.6: Business rule to stop director deletion'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：停止删除董事的业务规则
- en: 'Next, we''ll take a look at a UI action example. For this UI action, we will
    make a button to assign an incident to ourselves. Firstly, we will add a condition
    to only make the button appear on the form if it is a current member of the assignment
    group:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个UI操作示例。对于这个UI操作，我们将创建一个按钮，将事件分配给自己。首先，我们将添加一个条件，只有当它是分配组的当前成员时，按钮才会在表单上显示：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This line ensures that the logged-in user is a member of the assignment group,
    so that the incident can be assigned to them. The code we need to assign the incident
    to the user looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码确保登录用户是分配组的成员，以便可以将事件分配给他们。将事件分配给用户的代码如下所示：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The two lines set the assigned to value of the incident to the current logged-in
    user and then update the record to save the changes. This is quite a simple UI
    action, but one that is very helpful.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行将事件的分配给值设置为当前登录用户，然后更新记录以保存更改。这是一个相当简单的UI操作，但非常有帮助。
- en: 'Here, in *Figure 5.7*, we see the UI action we created:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在*图5.7*中，我们看到我们创建的UI操作：
- en: '![](img/6ea81b64-391f-49f4-a219-e7353090274e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ea81b64-391f-49f4-a219-e7353090274e.png)'
- en: 'Figure 5.7: UI action to assign an incident to the logged in user'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：将事件分配给登录用户的UI操作
- en: Often with UI actions, the script may not need to be that long to be an effective
    solution and add value to the user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与UI操作相关的脚本可能不需要很长就能成为有效的解决方案并为用户提供价值。
- en: Finally, we will take a look at an access control script example. Sometimes
    it may be necessary to restrict access to a single group and exclude even system
    admins from seeing records.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看一个访问控制脚本示例。有时可能有必要限制对单个组的访问，甚至排除系统管理员查看记录。
- en: We will use the change request table for this example, but obviously, other
    read access controls exist that would need to be deactivated for our new access
    control to work. We will only allow the `eCAB Approval` group access to `Software`
    category changes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用变更请求表来演示此示例，但显然，存在其他需要停用的读取访问控制，以便我们的新访问控制能够工作。我们只允许`eCAB Approval`组访问`软件`类别的变更。
- en: 'Let''s take a look at the code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are allowing access if the category is not `Software`; or, if it is
    `Software`, the user must be a member of the `eCAB Approval` group. We are clearing
    the Admin overrides checkbox, so even an admin will need to adhere to the rule
    to gain access. We also add the `itil` role to the rule to ensure that this role
    is needed for access to be given.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果类别不是`软件`，我们允许访问；或者，如果它是`软件`，用户必须是`eCAB Approval`组的成员。我们将清除管理员覆盖复选框，因此即使是管理员也需要遵守规则才能获得访问权限。我们还向规则添加了`itil`角色，以确保此角色对于授予访问权限是必需的。
- en: 'We can see the rule that we have created in *Figure 5.8*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图5.8*中看到我们创建的规则：
- en: '![](img/2744e7b6-86e1-487a-a94f-526dd10ade02.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2744e7b6-86e1-487a-a94f-526dd10ade02.png)'
- en: 'Figure 5.8: Access control to restrict access to the Software category to eCAB
    Approval group members'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：将访问限制为eCAB Approval组成员的软件类别访问控制
- en: This type of access control can be useful for sensitive information that perhaps
    even a system admin may not be able to view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的访问控制对于敏感信息可能很有用，也许甚至系统管理员也无法查看。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the basics of server-side scripting through business
    rules, UI actions, and access controls. We saw the various different runtimes
    of business rules and the multiple ways a UI action can be displayed to the user.
    We took a look at when it is appropriate to write server-side script and some
    examples of common uses, as well as how to test server-side script. We also saw
    some practical examples of server-side scripting using learned techniques.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过业务规则、UI操作和访问控制来查看服务器端脚本的基础。我们看到了业务规则的多种不同运行时以及UI操作显示给用户的多种方式。我们探讨了何时适合编写服务器端脚本，以及一些常见用途的示例，以及如何测试服务器端脚本。我们还查看了一些使用所学技术的服务器端脚本的实际示例。
- en: In the following chapter, we will be looking at the advanced side of server-side
    scripting, including script includes, scheduled jobs, and background scripts.
    We will also look at how to script in workflows and script actions, as well as
    how to set up events. We will introduce these server-side advanced topics and
    show you some practical examples.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨服务器端脚本的进阶方面，包括脚本包含、计划任务和后台脚本。我们还将查看如何在工作流中编写脚本以及脚本操作，以及如何设置事件。我们将介绍这些服务器端高级主题，并展示一些实际示例。
