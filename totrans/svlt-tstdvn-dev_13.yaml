- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Cucumber Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, you have seen two types of automated tests: Vitest unit tests
    and Playwright end-to-end tests. This chapter adds a third type of test: **Cucumber**
    ([https://cucumber.io](https://cucumber.io)).'
  prefs: []
  type: TYPE_NORMAL
- en: Just like Playwright, Cucumber has its own test runner, which is typically set
    up to drive your application in the same way as Playwright does. The difference
    is that Cucumber tests are not written in JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber tests are contained within *feature files* that contain tests formatted
    in a special syntax known as **Gherkin**. These tests, known as **features** and
    organized into scenarios, read like plain English. That has a couple of advantages.
  prefs: []
  type: TYPE_NORMAL
- en: First, they can be written and understood by the whole team, not just developers.
    That means you can extend test-first practices outside of the development team.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the absence of code encourages you to write tests that focus on user
    behavior rather than the technical details of the software. That, in turn, encourages
    you to build the right thing for your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does Cucumber turn features into executable code? Well, take a look at
    an example line (or, step) from a feature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Cucumber takes this step and looks for a matching JavaScript-defined step definition.
    The step definition, in this case, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the step definition has an associated code block. Once Cucumber
    finds a matching step definition, it executes that code block, supplying any parsed
    arguments. In this case, the `url` parameter will be provided as the `/birthdays`
    string. Cucumber also supports other data types, such as `int` and `bigdecimal`
    ([https://github.com/cucumber/cucumber-expressions#parameter-types](https://github.com/cucumber/cucumber-expressions#parameter-types)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the feature file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Playwright world object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing step definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll be confident in adding Cucumber tests to your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter13/Start).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the feature file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin with writing an example Cucumber feature file.
  prefs: []
  type: TYPE_NORMAL
- en: The Gherkin syntax that’s used to write features is characterized by the three
    words *Given*, *When*, and *Then*. These are analogous to the *Arrange*, *Act*,
    and *Assert* sections of all good unit tests, so they should feel familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s jump right in with our feature file and see what happens when we execute
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a new directory, `features`, with a new `features/birthdays.feature`
    file with the following content. It describes a user scenario in which the *Birthdays*
    application already supports editing a birthday. Here it is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Cucumber using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, go ahead and run the test with `npx @cucumber/cucumber`. You should see
    an output that starts like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just as all good test runners should, Cucumber is telling us the next task:
    defining the step definition. But before we get there, we need to pull in the
    Playwright APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Playwright world object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Cucumber execute your test? Just like with the Playwright tests, we
    need a running application server and a running browser to drive the **user interface**
    (**UI**). In this section, we’ll write all the code that gets the environment
    ready for test execution.
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber.js uses the concept of a `this` variable in each step. We also get
    access to it in special `Before` and `After` hooks, which are run before and after
    each scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The world object should contain functions (and state) that allow you to drive
    the UI. Since you’ve already learned and used the Playwright API for locating
    objects on a page, it would be marvelous if we could use that same API. It turns
    out we can indeed do this. We can also use the same `expect` API we’re used to
    as well, and we’ll do that in the next section when we begin writing step definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we’ll do: we’ll build a world class named `PlaywrightWorld` that
    has the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`launchServer` and `killServer` for starting and stopping the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launchBrowser` and `closeBrowser` for opening and closing a headless web browser,
    and for exposing the Playwright page and `request` APIs on our world object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we’ll use the `Before` and `After` hooks to start and stop both the server
    and browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note before we begin: our code files will use the `mjs` extension
    rather than `js`, to signify to `Cucumber.js` that these files use ECMAScript
    Module syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file, `features/support/world.mjs`, with the following
    import definitions. We’ll add more later, but these are enough to get us started
    with launching the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define the `removeAnsiColorCodes` function. This is important for execution
    environments (Windows, primarily) that will return color codes in the `stdout`
    stream data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re ready to define the `PlaywrightWorld` class, starting with a single method,
    `launchServer`. That method ends with a call to `setWorldConstructor` that makes
    this the designated world class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code in our `launchServer` function is very crude, but it does the job.
    It reads the Playwright configuration file and pulls out the value of `config.webServer.command`,
    which on my project is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Launching the web server using Playwright config
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a shell command, we must use the `detached` and `shell` properties
    when calling Node’s `childProcess.spawn` function.
  prefs: []
  type: TYPE_NORMAL
- en: Setting `env` means that any environment variables that Cucumber receives are
    also passed to this new shell. Once the server is started, we read the `stdout`
    data stream until we see a line that contains an HTTP URL. This is the URL of
    our running web server, so we parse that value and return it as the argument to
    `resolve`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `Promise` object means that the thread will wait until the value
    is retrieved, and then set the world’s `baseUrl` property to this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following error handling logic, which simply logs out any non-empty
    messages that appear on the `stderr` data stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s move on to `killServer`, starting by adding a new package, `tree-kill-promise`,
    that will allow us to easily shut down the server process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add that as an import at the top of the same world file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `killServer` method, shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s time to launch the browser. Start by bringing in the following Playwright
    `import` statements at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then define the `launchBrowser` and `closeBrowser` functions, as shown in the
    following code. The crucial piece is that we then end up with the `request` and
    `page` objects, which are the exact same objects we have in our Playwright end-to-end
    tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the world object complete, it’s time for the hooks. Add a new file named
    `features/support/hooks.mjs` and give it the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all the setup complete. The only remaining thing is the step definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the step definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of the puzzle is the `Given`, `When`, and `Then` functions for
    matching feature steps with their implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Checking your work as you go along
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will speed through the definition, but make sure you verify
    each step is working by running Cucumber (with the `npx @cucumber/cucumber` command)
    after you’ve implemented each function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another new directory, `features/support`, and create a file named `features/support/steps.mjs`,
    which starts with the following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then implement the first `Given` step from our feature file. This one calls
    into the API using the `this.request.post` function from Playwright. Note the
    use of `failOnStatusCode`, which makes sure that Cucumber fails the test if we
    don’t get a `200 OK` response back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we’re on to the `When` steps. There are two of these; arguably, one could
    have been `Given`, but I think they work nicely as a group, given that they are
    both user actions. The first one simply calls `this.page.goto`, which you’ve also
    seen before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the remaining steps, we will use our own `BirthdayListPage` page model
    object that we defined in [*Chapter 7*](B19611_07.xhtml#_idTextAnchor093), *Tidying
    up Test Suites*. Start by importing that at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then implement the next `When` step definition, which uses our battled-tested
    `beginEditingFor`, `dateOfBirthField`, and `saveButton` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s time for the `Then` step definitions. These are the ones that have expectations.
    To begin, add an `import` statement for `expect` at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the first `Then` clause, shown in the following code block. This
    checks that the new birthday is shown on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the step definitions with the final `Then` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the tests now, you should see all of them passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve now seen how to write a feature file using the Gherkin syntax, and how
    to write step definitions that use the same Playwright API that you’ve been using
    for your end-to-end-tests. You’ve also seen that the standard `expect` syntax
    can be used to write assertions that is used across all three types of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered how to use the Cucumber test runner to execute Gherkin
    feature files. Gherkin’s plain-English syntax makes this an important technique
    for bringing automated testing to the wider product development team.
  prefs: []
  type: TYPE_NORMAL
- en: The feature files are backed by step definitions. These step definitions are
    implemented using the `Given`, `When`, and `Then` functions, which map Gherkin
    step descriptions to JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how step definitions can re-use the existing Playwright API code
    to manage browser interactions.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our look at automated testing techniques. In *Part 3*, we’ll
    look at how to write unit tests for SvelteKit-specific features, starting with
    a chapter on strategies for testing authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Testing SvelteKit Features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part takes a glance at some specific features that require careful testing.
    These chapters aren’t sequential as in the previous parts. Instead, they are discussions
    on how you might approach your testing. The code samples included focus only on
    the novel pieces that haven’t been covered in previous chapters. You can always
    refer to the online repository for complete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19611_14.xhtml#_idTextAnchor156), *Testing Authentication*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19611_15.xhtml#_idTextAnchor168), *Test-Driving Svelte Stores*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19611_16.xhtml#_idTextAnchor175), *Test-Driving Service Workers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
