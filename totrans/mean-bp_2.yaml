- en: Chapter 2. Expense Tracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see how to build an expense tracker application. It
    will store all of our expenses for a given category. We will be able to see an
    aggregated balance of our expenses, or expenses by category. Each user will have
    a separate account to manage their expenses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the interesting topics that we will cover are:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multiuser system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with monetary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the MongoDB aggregation framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different authentication strategies, such as HTTP Basic and token-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the base application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's set up the base structure and files of our application. The whole source
    code for the project will be available as a bundle at [https://www.packtpub.com/](https://www.packtpub.com/).
    Therefore, we are only going to detail the most important part of setting up the
    base application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating our `package.json` file in the root of the project
    and adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step after defining the `package.json` file is to install the necessary
    dependencies. Run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After `npm` has pulled all the necessary files, you should be returned to the
    command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the base configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to reuse a lot of code from the previous contact manager project.
    We created a file to load the necessary environment config file based on the current
    environment node is running. Add a new config file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `config/environments/development.js` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to create the configuration file for Express and add the
    following lines of code to `config/express.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are going to add a file called `config/mongoose.js` to connect
    to MongoDB, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating the main server.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main entry point for our application is the `server.js` file. Create it
    in the root of the project. This file starts the web server and bootstraps all
    of the logic. Add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the user section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we also had a user section for the application. In
    this chapter, we are going to extend those functionalities by adding the register
    and change password functionalities. We are going to reuse the existing code base
    and add the new features.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the user model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a test file specifically for the user model. This will come
    in handy for testing all its functionalities without booting up the entire application.
    Create a file called `test/integration/user.model.test.js` and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined the base for our test file. Now we are going to add each test
    case one by one, before the last closing bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A user should be able to register with our system. We can test this with the
    following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same user cannot register twice with the same e-mail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After successful registration, a user should be able to authenticate into our
    system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a user provides invalid credentials, it should not be authenticated successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A user should be able to change the current password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An old password challenge must be passed in order to set a new password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the preceding test suit, we have described and will test the functionality
    of our implemented methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `user` model is going to use the same password helper principle as in [Chapter
    1](part0016_split_000.html#F8902-5c78d361d97340239270192b72d53e7b "Chapter 1. Contact
    Manager"), *Contact Manager*. Let''s create a file called `app/helpers/password.js`.
    The file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the `hashPassword()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added an extra function, called `generateDerivedKey()`, in order not
    to repeat code blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `verify()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a user schema in the model file. Create a new file, called
    `app/models/user.js`, and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, one by one, let''s add the required methods from the test. We will start
    with the `register()` method. Append these lines of code to the user model file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple function that will save a user in MongoDB. Before saving the
    user, we want to build a hash from the given password and save that hash with
    a salt in the database, instead of a plain password string. Mongoose will also
    validate the user data before saving it, based on the User schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `authenticate()` method, we will append the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The authentication method will find a user by e-mail. The `password` and `passwordSalt`
    fields are explicitly set to be read from the database only for this query. A
    password verification function will be called to match the existing password hash
    with the password sent to the authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we will add a `changePassword()` method. This method will be available
    on user instances only. Mongoose gives us the ability to use the `methods` property
    on a schema to attach new functions. Append the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The change password functionality is built using three small steps. The first
    step is to get the user's password and salt from the database. The returned data
    is used to verify the existing password hash and salt with the old password entered
    by the user. If everything goes well, the new password is hashed using a generated
    salt and the user instance is saved into MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to move the following line of code to the end of the file, in
    order to compile the user model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we run our user model test with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see all of our tests passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Authenticating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used session-based authentication. For this chapter,
    we are going to explore a different solution—using access tokens to authenticate
    our users.
  prefs: []
  type: TYPE_NORMAL
- en: Access tokens are widely used for RESTful APIs. Because we are building our
    application with the premise that it could be used not only by our Angular app
    but also by many other client applications, we need to rely on something that
    can be used to identify users with something that they have.
  prefs: []
  type: TYPE_NORMAL
- en: An access token is a string that identifies a user, or even an app, and it can
    be used to make API calls to our system. Tokens can be issued via a number of
    methods. For example, tokens can be issued easily using OAuth 2.0\.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we are going to build a custom module that is responsible
    for creating tokens. This will give us the ability to easily switch to any other
    available solution.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to implement two strategies to authenticate our users. One of them
    will be an HTTP Basic authentication strategy, which will use a simple username
    (e-mail in our case) and password combo to authenticate a user and generate a
    token that will be used for further API calls. The second strategy is an HTTP
    Bearer authentication, which will use the access token issued by the Basic authentication
    to grant the user access to resources.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the authentication strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing any code, we should create a test that will describe the
    desired behavior regarding user authentication. Create a file called `tests/integration/authentication.test.js`
    and describe the main test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test case should consider a positive scenario, that is, when a user
    tries to authenticate with valid credentials. This would look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a user tries to authenticate with invalid credentials, the system should
    return a bad request message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We described the basic strategy. We considered the fact that a user must send
    an e-mail as username and password via a POST call to the `/api/auth` endpoint
    and get back the user details and a valid token.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `request` library has a special property called `auth` that will encode
    the username-and-password tuple using base64 and set the appropriate headers for
    HTTP Basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our presumption is that a valid token will be generated when
    a user successfully authenticates into our system. For this reason, we are going
    to implement the token generation functionality before continuing further.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the token generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tokens can be generated in many ways. For this chapter, we are going to use
    the built-in crypto library from Node.js. We can use the `randomBytes()` method
    to generate a random string of a given length. One thing to note is that `randomBytes()`
    will throw an error if there is not enough accumulated entropy. This means that
    if there is not enough information in the entropy source to generate a random
    number, it will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `app/helpers/token.js` and add the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a helper function that will generate a random token for us. The
    function takes two arguments: the number of random bytes, which is optional, and
    a callback function.'
  prefs: []
  type: TYPE_NORMAL
- en: Persisting tokens in MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to check an access token sent by the user—that is, whether it's valid
    or not—we should store it somewhere. For this, we are going to use MongoDB as
    our storage engine for the tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you should treat your tokens with the same responsibility as user
    passwords, because tokens will give access to the system's functionality. One
    option to consider for further security improvements is to store tokens encrypted
    in the database or even store them in a separate token storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before anything, let''s create a test for the token model. Create a file called
    `tests/integration/token.model.js` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are going to add a `generate()` method to the `Token` model, which will return
    a cryptographically strong token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `app/models/token.js`. It will hold the `Token` Mongoose
    schema and the preceding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added an expiration date for our tokens. This could be used
    to automatically invalidate tokens after a given time. Usually, in an application,
    you don't want to have tokens without an expiration date. If there is a need for
    such tokens, another layer of authorization through API keys should be added to
    authorize the usage of the system for third-party clients.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication using HTTP Basic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before generating a token, we need to authenticate our users. One simple solution
    could be to use a simple username-and-password authentication and generate a token
    if the entered information is valid.
  prefs: []
  type: TYPE_NORMAL
- en: We can expose a route that will handle HTTP Basic authentication. This is the
    simplest technique for enforcing access control for a resource. In our case, the
    resource will be a token and it does not require cookies or identifying sessions.
    HTTP Basic authentication uses standard fields in the HTTP request header.
  prefs: []
  type: TYPE_NORMAL
- en: This method does not add any encryption or hashing in any way; just a simple
    base64 encoding is needed. For this reason, it is typically used over HTTPS. If
    the client wants to send the server the necessary credentials for authentication,
    it can use the `Authorization` header field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `passport-http` module for the Basic authentication
    strategy. Let''s create a file called `app/config/strategies/basic.js` and add
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The strategy uses the `authenticate()` method to check whether the credentials
    are valid. As you can see, we are not adding any extra logic here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to create a controller that will handle the basic authentication.
    Create a file called `app/controllers/authentication.js` and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Passport has an `authenticate()` method that enables us to call a given strategy.
    We are using a custom callback in order to generate and persist a token in MongoDB.
    When returning the token to the client, we only need a few things from the stored
    data, such as the value and expiration date.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file called `app/routes/authentication.js` and add the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `auth` route will allow users to make a post call and authenticate using
    the basic strategy. In order to create reusable routes, we do not mount the routes
    directly to the Express app instance. Instead, we use the `Router` class to instantiate
    a new router.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to configure what routes we are mounting on our Express
    application, we can create a file called `config/routes.js` with the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines of code should be straightforward. We are defining the routes'
    base path and mounting them onto our application. One thing to note is that we
    are adding a prefix to the authentication routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the main `server.js` file in order to
    initialize the routes configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run our authentication test with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This should have a similarly positive output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Verifying users using bearer authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For each request, tokens should be used to determine whether the requester has
    access to the system or not. We only used the basic strategy to issue a token
    if the user sent valid credentials. Passport has a `passport-http-bearer` module.
    Normally this is used to protect API endpoints, as in our case. The tokens are
    often issued using OAuth 2.0, but, in our case, we built a custom solution to
    issue tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Also in our case, a token is a string representing an access authorization key
    issued to the client by the system. The client application, the Angular app, will
    use the access token to retrieve protected resources from the RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe a simple use case to retrieve information using an access token.
    Append the following lines of code to `tests/integration/authentication.test.js`,
    after the basic authentication test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We assume the existence of an `/auth/info` route on which, if a GET call is
    made, it will return the token's owner credential. If the token is invalid, an
    unauthorized message is sent back, with the appropriate 401 HTTP status code.
  prefs: []
  type: TYPE_NORMAL
- en: Bearer strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a file called `config/strategies/bearer.js`. Add the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code searches in the database for the given token. In order to
    retrieve the token owner, we can use the `populate()` method from Mongoose in
    combination with a normal query method, such as `findOne()`. This can be done
    because we explicitly added a reference to the User model in the Token model.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting resources using tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to protect our resources, we need to add a layer that checks the presence
    of the access token. We did the first part of the Bearer strategy. Now we only
    need to use it; for this, we can create middleware that will validate the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `app/middlewares/authentication.js` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is fairly simple. We just use passport's built-in `authenticate()`
    method to call the bearer strategy. We don't want to save any session on the server.
    This piece of middleware can be used on each route in combination with any other
    application logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append the following lines of code to `app/controllers/authentication.js`.
    It will only check whether the user is present on the request object and return
    a JSON with the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s get back to our authentication route, `app/routes/authentication.js`,
    and add the following highlighted lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We added the authentication middleware before the execution of the logic from
    the controller in order to validate and retrieve the token's owner. Our bearer
    strategy will handle this and set the user on the request object; more precisely,
    it can be found on `req.user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our authentication test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output should be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With this, we've finally added all the necessary authentication methods to grant
    users access to our system.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking expenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main feature of our application is to track the user's expenses. A user
    should be able to insert expenses, be persisted in the system, and see the exact
    balance for his/her account.
  prefs: []
  type: TYPE_NORMAL
- en: 'There should always be a clear view of what is desired to be achieved. Let''s
    take a high-level view of what we want to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: A user should be able to persist an expense in the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user should be able to get all their expenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user should be able to get the balance of their expenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user should be able to define a category in which to save expenses, for example,
    groceries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monetary values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our case, an expense will store the exact value of money spent. In some cases,
    working with monetary data can get tricky. Often, applications that handle monetary
    data are required to work with fractional units of the currency.
  prefs: []
  type: TYPE_NORMAL
- en: We could store data in floating-point numbers. However, in JavaScript, floating-point
    arithmetic often does not conform to monetary arithmetic. In other words, values
    like one-third and one-tenth do not have an exact representation in binary floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB, for example, stores numeric data as either IEEE 754 standard 64-bit
    floating-point numbers, 32-bit, or 64-bit signed integers. JavaScript treats numbers
    according to specs as double-precision 64-bit format IEEE 754 values. Because
    of this, we need to pay attention to such operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We won't be able to store values such as 9.99 USD, representing cents in decimal.
    Don't get me wrong; we can store them, but we are not going to get correct results
    if we use the built-in MongoDB aggregation framework or do server-side arithmetic
    (the same thing applies for the client side too in JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not worry; there are a few solutions that we can use. There are two common
    approaches to storing monetary values in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: Exact precision is an approach that is used to multiply the monetary value by
    a power of 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arbitrary precision, on the other hand, uses two fields to represent the monetary
    value. One field stores the exact value as a non-numeric format, such as a string,
    and another field stores the floating-point approximation of the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our implementation, we are going to use the exact precision model. We will
    discuss all the details as we progress with the code.
  prefs: []
  type: TYPE_NORMAL
- en: The category model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, we want to be able to add an expense to a specific
    category. A user should also be able to invite another user to add expenses to
    a category. We are not going to detail the test cases for this feature, but you
    should consider writing tests to make sure that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `app/models/category.js` and add the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important things to note here: we define the owner of the category, which
    will always be the authenticated user that creates the category, and the collaborators
    field, which holds users that can insert expenses into the category.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, don''t forget to change the model configuration file, `config/models.js`,
    by adding the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Categories routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To expose a simple CRUD on the category collection, we have to define routes
    for those actions. For this, we are going to create a router file, called `app/routes/categories.js`,
    and add these lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that we actually have no implementation of the category controller
    at the moment. Let''s create a category controller with the following name: `app/controllers/category.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the category by ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `app/controllers/category.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will come in handy when the `categoryId` route `param` is
    present. It will automatically get a category, as we defined it in the route file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a category
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a category, append the following lines of code to the controller
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Before creating a category, we add the owner's ID, which is the current user's
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: Getting one and all categories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also want to get a single category and all categories. To get one category,
    we are going to use the results from getting a category by ID. To retrieve multiple
    categories, we are going to use the `find()` query method from Mongoose. We could
    easily add pagination or set limits, but we are going to presume that a user will
    not have so many categories. This could be a small improvement for our application
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append the following lines of code to the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Updating and deleting a category
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we get a category by ID, we set the returned instance from Mongoose to
    the request object. Due to this, we can use that instance to change its properties
    and save it back to Mongo. Append this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing can be used when deleting a category; also append the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding lines of code, we have finished CRUD operations on categories.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the expense model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we discussed the fact that we cannot simply store monetary data as
    floating-point numbers in the database or use it for server-side arithmetic. The
    accepted solution for our scenario was to use exact precision to store monetary
    data. In other words, money values will be stored by multiplying the initial value
    with a number that is a power of 10.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to assume that the required maximum precision will be a tenth of
    a cent. Going with this assumption, we will multiply the initial value by 1000\.
    For example, if we have an initial value of 9.99 USD, the stored value in the
    database will be 9990.
  prefs: []
  type: TYPE_NORMAL
- en: For the current implementation of the application, we are going to use USD as
    our currency for monetary values. The scale factor will be 1000 to preserve precision
    up to one-tenth of a cent. Using the exact precision model, the scale factor needs
    to be consistent for the currency across the application and anytime given it
    should be determined from the currency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our expense model, `app/models/expense.js`, and add the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table will give a short description of the fields in the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Name of the expense |'
  prefs: []
  type: TYPE_TB
- en: '| `amount` | The scaled amount of money |'
  prefs: []
  type: TYPE_TB
- en: '| `currency` | What currency is used to represent the money |'
  prefs: []
  type: TYPE_TB
- en: '| `scaleFactor` | The scale factor used to obtain the amount |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | To whom the expense belongs |'
  prefs: []
  type: TYPE_TB
- en: '| `category` | A category group that the expense belongs to |'
  prefs: []
  type: TYPE_TB
- en: '| `createdAt` | The date when the expense object was created |'
  prefs: []
  type: TYPE_TB
- en: Mongoose has an interesting feature, called `virtual attributes`. Such attributes
    are not persisted in the database but are really helpful in many scenarios. We
    are going to use a virtual attribute called `value`, which is going to represent
    the monetary value of the `amount` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append the following lines of code before the model compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Like all attributes, virtual attributes can have `getters` and `setters`. We
    are going to piggyback the setter and add our own logic, which will scale the
    value with a give factor and obtain the desired amount. Also, when getting the
    virtual `value` attribute, we are going to return the correct monetary representation,
    dividing the stored amount by the corresponding scale factor.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when doing a query, Mongoose will not return `virtual attributes`,
    but we have overwritten the default options for the schema to return all `virtual
    attributes` when using the `.toJSON()` and `.toObject()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the expense module functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we are going to write some tests for the expense module in order to define
    the required behavior of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to go faster, we are only going to define a few test cases. The rest
    of the CRUD test cases are the same as in earlier implementations for different
    modules. For reference, you can check out the full code base for the test suite
    at the following link: [https://www.packtpub.com/](https://www.packtpub.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `tests/integration/expense.test.js`. We are going
    to define the most important test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an expense, a value and a category must be present. The value
    should be a number that accepts decimal values too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should be able to get all of the user''s expenses from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If necessary, we should get only the expenses for a given category. This will
    come in handy when we want to display expenses for a certain category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code tests the creation of an expense and that the virtual value
    attribute works correctly. It also checks whether an invalid token is sent and
    that the application will treat it accordingly. Now the fun part starts with the
    `balance` functionality, which should return an aggregated value of the expenses
    for different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations for expenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we are going to implement the CRUD operations for expenses one by one.
    Before going any further, we are going to create a new routes file called `app/routes/expenses.js`
    and add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We added a bearer authentication for each route. You could have created a single
    route to catch all the resources that need authentication, but, in this way, you
    will have fine-grained control for each route.
  prefs: []
  type: TYPE_NORMAL
- en: Create expense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create the controller that the routes file needs—`app/controllers/expense.js`—and
    add the create expense logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The expense that we want to create should be for the token owner. Hence, we
    explicitly set the user property to the authenticated user's ID.
  prefs: []
  type: TYPE_NORMAL
- en: Get expense by ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The get one and update expense logic uses an expense instance to display or
    update it. Due to this, we are only going to add a single logic that retrieves
    an expense by ID. Append the following lines of code to the controller file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Because we are not going to do a final operation here, we only set the expense
    to be present on the request object and call the next handler in the route pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Get one expense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to extend "get expense by ID" and just respond with a JSON representation
    of the resource. Getting an expense logic should be a few lines of code appended
    to the controller file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Get all expenses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When getting all expenses, we need to take a different approach—one that enables
    us to filter them by a specific query. Expenses should also be returned for a
    specific category. We don''t need to implement different search logics for all
    these scenarios. Instead, we can create one that will wrap around our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Before querying the database using Mongoose to retrieve the necessary data,
    we construct a query variable that will hold all our criteria. One nice thing
    to note here is that once again we used the query builder object provided by Mongoose.
    Expenses are going to be stored in a greater number in MongoDB. Hence, we add
    a `limit` and a `skip` to retrieve only a limited set of data.
  prefs: []
  type: TYPE_NORMAL
- en: Expenses can be queried using a date range. Due to this reason, the `createdAt`
    property will be progressively extended to match only a set of expenses in a period.
    Expenses should also be returned in a chronological order; newly added expenses
    should be returned first.
  prefs: []
  type: TYPE_NORMAL
- en: To have all the necessary information about each expense, we are going to populate
    the category property of an expense with the appropriate category object from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Update expense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Append the following code for the update logic to the controller file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The update logic uses the expense instance set on the request object by the
    callback trigger for the expense ID parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Delete expense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to delete an expense, we just remove the expense instance from the
    database, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Getting the expense balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get back to the expense model and extend it with balance calculation.
    In order to get the balance in different scenarios, we are going to use the Aggregation
    framework from MongoDB. Aggregated data means computed results from operations
    on data from collections.
  prefs: []
  type: TYPE_NORMAL
- en: Mongo provides a complex set of operations to perform on datasets. Because we
    are using Mongoose, we have access to `Model.aggregate()`, which will help us
    create the aggregation pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the data returned from aggregation is in the form of plain
    JavaScript objects, not Mongoose documents. This is due to the fact that any shape
    of document can be returned when using aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append the following code before the expense model compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The preceding static `.getBalance()` method will calculate the current balance
    in different scenarios, as described in the test case. The `.aggregate()` method
    goes through multiple stages. The first one is a match stage that will select
    all the documents for our defined query. The result from the match is sent to
    the group stage, where the documents are grouped by a specified identifier.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, pipeline stages can use operators to perform different tasks, for
    example, calculating the balance in our scenario. We are using an accumulator
    operator called `$sum` that returns a numerical value for each group.
  prefs: []
  type: TYPE_NORMAL
- en: In the group stage, the `_id` field is mandatory, but you can specify a null
    value for it to calculate all the values for the input documents of the pipeline.
    The group operator has a limit of 100 megabytes of RAM, but you can set it to
    use the disk to write temporary files. To set this option, use Mongoose and take
    a look at the `.allowDiskUse()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the missing controller function, `app/controller/expense`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Angular client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the point in our project at which we will start integrating
    the AngularJS application. This chapter will take a different approach at building
    the desired application. An ideal application should be structured in a modular
    way, each module addressing a specific functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably already familiar with the component-based approach when building
    Angular apps. What this means is that we will create small modules that encapsulate
    specific functionalities. This enables us to add functionality incrementally;
    imagine adding vertical blocks onto the application.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we need to create a main block that glues everything together,
    pulling all features and modules together. Keep your main app module thin and
    move the rest of the logic to application modules.
  prefs: []
  type: TYPE_NORMAL
- en: One rule that I like to follow is to keep my folder structure as flat as possible.
    I always try to reduce the level of the folders so that I can locate code and
    functionality quickly. If your module grows too big, you can either split it up
    or add subfolders.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started and create a `public/package.json` file. We are going to
    use `npm` to install our dependencies for the frontend part of the project. The
    `package.json` file will have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this command to install all the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: After a successful installation, create a folder called `public/src`. This folder
    will hold the main Angular application. Inside this folder, we will create our
    modules folder and application files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your main app component file, called `public/src/app.component.ts`,
    and follow these steps to create the final version of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure your routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We defined a default path that will redirect to the `expenses` view, displaying
    all the entries to the user. There is also a `Signin` and `register` route available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the component annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the component''s class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If an unauthorized call is made, we redirect the user to the `Signin` route
    in order to authenticate itself with valid credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Registering users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application should support user registration. We already have the backend
    logic for this functionality. Now, all we have to do is tie it up with our Angular
    application. To do this, we are going to create a generic module called `auth`,
    which will be used for both registering and authenticating users.
  prefs: []
  type: TYPE_NORMAL
- en: The auth service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will continue with the `auth` service, which will hold all the communication
    logic with the Node.js backend application. Create a file called `public/src/auth/services/auth.service.ts`
    and implement the entire logic of the service by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the service class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `signin()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to expose a simple function to set the next value of the `currentUser`
    Observable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialize the session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the application reloads, we want to retrieve the current user from the
    local storage in order to restore the session. One improvement you can add is
    to check whether the token has expired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Append the helper methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding functions are simple abstractions for the `stringify` and `parse`
    JSON methods.
  prefs: []
  type: TYPE_NORMAL
- en: Register component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the appropriate component file, `public/src/auth/components/register.component.ts`,
    with the following lines of code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `register` method is called, we simply try to register our user using
    the `AuthService`. Error handling is not added in the preceding code. Only a simple
    log will be printed on the browser''s console. Let''s add the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The register component is pretty straightforward. We are defining a simple register
    function that will use the auth service's `register` method. All the necessary
    fields also can be found in the `template` property.
  prefs: []
  type: TYPE_NORMAL
- en: Sign-in-user component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to authenticate users, we have added some extra functionality to the
    auth service to enable us to sign in a user. Because we are not persisting the
    state of a user on the backend—in other words, our backend is stateless—we have
    to store the current state of the user on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we created an endpoint that will issue us a token for a valid
    username-and-password tuple. We are going to use that endpoint to retrieve a token
    that will grant us access to the rest of the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our sign-in component is fairly simple and it''s really reused from the previous
    chapter, but let''s refresh our memory and take a look at it. `SigninComponent`
    is found under `public/src/auth/components/signin.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Just as in `RegisterComponent`, we are using local variables for our fields.
    Using `AuthService`, we try to authenticate our user. We are not really focusing
    on handling errors, but, if the user successfully authenticates, we want to navigate
    to the `root` path and set the current user.
  prefs: []
  type: TYPE_NORMAL
- en: Common functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few functionalities that we used earlier and some extra functionality
    to consider before jumping further into development. For example, we used a common
    headers definition, found under `public/src/common/headers.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simply a way to define constants and use them across the application
    without repeating yourself. So, basically, we imported `Headers` from Angular
    2 and created a new instance. You can easily add extra fields to this header instance
    using the `append()` method, like this for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there a few other things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: When asking the server for resources through the API, we should send the required
    Bearer token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user makes a call and the server responds with a status code that equals
    401—unauthorized—we should redirect the user to the sign-in page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see what we can do about the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: Custom HTTP service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We did something similar in the previous chapter when we created a custom HTTP
    service to make calls to the Express backend application. But we need a few extra
    things, such as attaching the token to each call that is made through this service
    in order to identify the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we stored our user''s token inside the browser''s `LocalStorage`.
    This should be fairly simple to retrieve and I think we can even add it inside
    the service. Let''s get started and create a new file called `public/src/auth/services/auth-http.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'So this is our custom `HttpAuth` service, which exposes a few public methods,
    the same as in the previous chapter. Now the changes occur in the private `request()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Before we make a call, we attach the necessary token to the `Authorization`
    header. The token is stored in the browser's storage, so we use the `getToken()`
    method to retrieve it. If the request is unauthorized, we push it through our
    unauthorized data stream, which holds requests that failed authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getToken()` method has a very simple implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Using a single export file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add an `index.ts` file in the root of each module folder in order to
    export all public members. In the `auth` module, we can have a file called `public/src/auth/index.ts`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This technique will be used for each module and it's not going to be covered
    any further.
  prefs: []
  type: TYPE_NORMAL
- en: The categories module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The category module will hold all of the logic that is necessary to perform
    CRUD operations on categories and communicate with the backend through an Angular
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Category service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The category service is going to be fairly simple, it''s only going to manage
    the CRUD operations on categories. The following steps will describe the process
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `public/app/categories/category.service.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the necessary business logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the service will expose all the methods needed for the CRUD
    operations. Each method will return an observable, which will emit a single response.
    We are also using our own `AuthHttp` in order to check whether a request is unauthorized
    and the user needs to sign in.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, besides the returned observable, the `getAll()` method also updates
    the `categories` data stream in order to push the new values to each subscriber.
    This will come in handy when multiple subscribers use the same data source to
    display data in their own way.
  prefs: []
  type: TYPE_NORMAL
- en: The categories component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a component that is used when we navigate to the `/categories`
    path, which we configured at the beginning of the chapter. The final version of
    `AppComponent` was used earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`CategoriesComponent` will use two other components to create a new category
    and list all the available entries from the system. Let''s create a new file,
    `public/src/category/categories.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The previous component does not have much going on; we have no moving parts.
    We just import the two necessary components and include them in the template.
    Let's continue by implementing the other two components from this context.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A user must be able to interact with our application and add new categories,
    so we are going to create a separate component for this. Let''s break it down
    into these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create the view file, called `public/src/category/components/category-create.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the component annotation, which includes the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the component''s class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each time we add a new category, we want to broadcast the new item to all subscribers.
    For example, the categories list should have the new entry displayed. After we
    have successfully created the category, the form should be reset to its initial
    value.
  prefs: []
  type: TYPE_NORMAL
- en: List all categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can create categories, we should be able to list them for the user.
    In order to list the categories, we are going to use two components, one component
    to iterate over the data from the server and another to display information about
    a category.
  prefs: []
  type: TYPE_NORMAL
- en: The latter component will also have encapsulated the update functionality. So
    anytime the user can change information about a category and persist the changes
    on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new component file for the categories listing, called `public/src/category/components/category-list.component.ts`,
    and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We imported a `CategoryComponent`, which doesn't exist at the moment, but we
    should already have an idea of how we are going to use our component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the template and component annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using the `ngFor` directive to render the `category` template for each
    item from the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Declare the component''s class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the component is initialized, we are going to retrieve all the available
    categories from the backend using our `CategoryService`. Besides fetching all
    the necessary data, we also subscribe when a new category is created. Basically,
    we subscribe to a category data stream.
  prefs: []
  type: TYPE_NORMAL
- en: Each time a new category is added, it is going to be pushed to the `categories`
    list and displayed to the user. In order to render the information for the user,
    we are going to have a component for a single category.
  prefs: []
  type: TYPE_NORMAL
- en: When the component is destroyed, we want to unsubscribe from the data stream;
    otherwise, notifications will be pushed down the data stream.
  prefs: []
  type: TYPE_NORMAL
- en: The category component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display information for a single category from our list, we are going to
    create a new component, called `public/src/category/components/category.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This category gets input data to display information about a category. It also
    triggers an event when the **Save** button is clicked on and the form is submitted.
    We use our service to communicate with the server and persist the changes in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: The expenses module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this module, we are going to treat functionality related to expenses. This
    is going to be the main module used by our users in the frontend application,
    because here they will add new expenses and store them in MongoDB through our
    backend API.
  prefs: []
  type: TYPE_NORMAL
- en: Expense service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The expense service will implement CRUD operations on expenses and one other
    important feature of it is getting the balance of expenses. In order to create
    the expense service, we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `public/src/expense/expense.service.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the main logic of the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We just defined a list of exposed methods. We also exposed a few public properties,
    for the filter that can be updated externally, like the expense, and an Observable
    expenses data stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s follow the methods one by one and append their actual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an expense:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Getting all expenses matching a given query criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method uses a `serializeQuery()` method, which will transform
    our criteria into `query string` parameters. We are doing this to filter our expenses
    by a given criteria. Also, rather than returning an Observable from the HTTP call,
    we update our `expenses` data stream to notify all subscribers of the newly available
    data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Getting the balance of the expenses matching a query criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the same `serializeQuery()` function to transform our criteria into a
    `query string`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Updating an expense by ID with new data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Filter expenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a start, we are going to implement expenses filtering. We just want to have
    all the necessary blocks in order to list the expenses properly. Basically, this
    component will be a simple form with three inputs: start date, end date, and category.'
  prefs: []
  type: TYPE_NORMAL
- en: Using these simple criteria, we are going to filter our expenses on the backend.
    Remember, we need these in the `query` params so that the correct data is retrieved
    from the `expenses` collection.
  prefs: []
  type: TYPE_NORMAL
- en: This component will rely on the `CategoryService` and subscribe to the categories
    data stream. It will also push new values down the filter stream to notify each
    subscriber to filter the expenses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to implement our component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our component''s template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the `ExpenseFilterComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What will happen on initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the component is destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have to unsubscribe from the data stream. We used a subscriptions list in
    order to hold all of them in one place and later on iterate over the subscriptions
    and dispose of them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'How we update the filter stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Resetting the filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the component initializes, we subscribe to the `categories` data stream.
    If the user clicks on the `filter` button, we'll update the `filter` so that each
    subscriber can get the new filter criteria.
  prefs: []
  type: TYPE_NORMAL
- en: In order to reset everything, we can use the `reset` button and get back to
    the initial state. We can then notify all subscribers that we can retrieve all
    expenses once again.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new expense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because adding expenses will be a fairly well used feature, we are going to
    add the necessary logic into the same view and controller used to list expenses.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, in order to add a new expense, it must be included in a category.
    So we need a list of categories loaded into the component. This should be similar
    to what we did earlier in `ExpenseFilterComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps to implement the add expense functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, called `public/src/expense/components/expense-create.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the annotation with the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On initialization, we subscribe to the categories data stream and store the
    subscription so that we can dispose of it later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unsubscribe when the component is destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: List expenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display a list of expenses, we are going to query the server for the necessary
    information and create a table with the retrieved information. For this, we are
    going to go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the expenses controller file, called `public/src/expense/components/expense-list.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the service and other dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `expense` table in the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `ExpenseListComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Subscribe to all data streams on initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dispose of subscriptions when the component is destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We mostly use streams of data to display information to the user. When a new
    expense is created, we just get notified and update the list of expenses. If a
    new set of expenses is loaded, the list is updated with the new values. We also
    subscribe to the change of filter so that we can fetch data from the backend using
    that filter.
  prefs: []
  type: TYPE_NORMAL
- en: Display balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to display an accumulated value from the expenses amount. When we filter
    the expenses, the same filter should apply to the query for the balance. For example,
    we might want to display expenses from a specific category; in such a case, the
    balance should be displayed for expenses from that category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we do all the heavy lifting on the backend and the result that we get
    through the API is nicely formatted, we only have to implement a few things to
    display the balance properly:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file for the component, called `public/src/expense/components/expense-balance.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the balance from the backend based on a criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dispose of the subscriptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expenses component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have all the necessary components, we can implement our main expenses
    component, which will use all the previously implemented child components. We
    should create a new file, called `public/src/expense/components/expenses.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The component is fairly simple, but an interesting thing happens in the `ngOnInit()`
    method when we just get all the categories and set the filter to be an empty object.
    When this happens, all the rest of the components react to our actions and update
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have implemented the expenses module, which allows users to add
    expenses and see a list of all expenses. We left out some functionality, such
    as error handling, pagination, and other minor features, but you may improve this
    code as you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of a rather long chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to manipulate monetary data with JavaScript and Node.js and how to
    store it in MongoDB. We implemented a multiuser system in which users can easily
    register and sign in at any time.
  prefs: []
  type: TYPE_NORMAL
- en: We exposed most of our backend functionality through an API. We used a stateless
    authentication mechanism, granting access only by presenting a valid token.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to build a web page that is more public oriented,
    with different account types.
  prefs: []
  type: TYPE_NORMAL
