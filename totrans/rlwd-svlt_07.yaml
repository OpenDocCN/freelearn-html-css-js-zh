- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Progressive Enhancement with Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有操作的渐进增强
- en: Progressive enhancement is a design philosophy in web development that emphasizes
    providing content and core functionality to everyone while delivering an enhanced
    experience to users who can afford it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强是网络开发中的一种设计理念，强调为所有人提供内容和核心功能，同时为负担得起更好浏览器、更强大的硬件和更高互联网带宽的用户提供增强体验。
- en: In this chapter, we will start with a more in-depth discussion of what progressive
    enhancement is. There are many ways to achieve progressive enhancement in your
    application; we will explore one of them by using Svelte actions. I will explain
    my reasoning as to why I think Svelte actions are designed for this use case.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从更深入的角度讨论什么是渐进增强。在您的应用中实现渐进增强有许多方法；我们将通过使用Svelte操作来探索其中的一种。我将解释我为什么认为Svelte操作是为这种用例设计的。
- en: Toward the end of the chapter, we will go through a few examples of using Svelte
    actions to progressively enhance our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们将通过几个示例来展示如何使用Svelte操作来渐进增强我们的应用程序。
- en: By the end of this chapter, you will be able to build an application that follows
    the principles of progressive enhancement and supports as many user devices as
    possible.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够构建一个遵循渐进增强原则并支持尽可能多用户设备的应用程序。
- en: 'This chapter covers the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What is progressive enhancement?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是渐进增强？
- en: Why use Svelte actions for progressive enhancement?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用Svelte操作进行渐进增强？
- en: Examples of progressive enhancements using Svelte actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Svelte操作进行渐进增强的示例
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the examples and code for this chapter here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的示例和代码：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07)。
- en: What is progressive enhancement?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是渐进增强？
- en: The most important thing in *progressive enhancement* is missing from the phrase
    itself. Something that is implied here is where are we progressively enhancing
    from.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在“渐进增强”这个短语中，最重要的事情却缺失了。这里隐含的是我们从哪里开始渐进增强。
- en: The main idea of progressive enhancement is to provide a great baseline of essential
    content and core functionality to everyone, regardless of the browser software,
    device hardware, or the quality of the internet connection. Older browser software
    may not support newer JavaScript syntaxes and CSS features; older device hardware
    may take up more time to process and render your web page; a slower internet connection
    may take longer to load the resources needed to display your web page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强的主要思想是为每个人提供一个优秀的基线，包括基本内容和核心功能，无论浏览器软件、设备硬件还是互联网连接的质量如何。较旧的浏览器软件可能不支持较新的JavaScript语法和CSS功能；较旧的设备硬件可能需要更多时间来处理和渲染您的网页；较慢的互联网连接可能需要更长的时间来加载显示网页所需的资源。
- en: How do we ensure our web page stays usable for as many users as possible? Think
    about this for a while—I will come back to it later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保我们的网页尽可能多地为用户保持可用性？思考一下这个问题——我稍后会回到它。
- en: For users who can afford better browsers, more powerful hardware, and higher
    internet bandwidth, we progressively provide an enhanced experience to them. We
    leverage the power of JavaScript and CSS to surprise and delight our users.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于能够负担得起更好浏览器、更强大硬件和更高互联网带宽的用户，我们为他们提供增强体验。我们利用JavaScript和CSS的力量来惊喜和取悦我们的用户。
- en: How do we differentiate between the users and decide when to deliver an enhanced
    experience?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何区分用户并决定何时提供增强体验？
- en: There is another term that is often used to compare with progressive enhancement,
    and that is *graceful degradation*. Graceful degradation starts from a feature-rich
    baseline and gracefully handles the situation when the user browser can no longer
    support the feature by replacing it with a simpler alternate experience. A lot
    of the time, these features start with a more complex assumption, and so execution-wise,
    it is much harder to gracefully degrade to all kinds of users.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一个术语经常与渐进增强进行比较，那就是*优雅降级*。优雅降级从功能丰富的基线开始，优雅地处理用户浏览器无法再支持功能的情况，通过替换为更简单的替代体验来处理。很多时候，这些功能从更复杂的假设开始，因此在执行上，要优雅地降级到各种用户要困难得多。
- en: Progressive enhancement, on the other hand, starts from a baseline that works
    for most users and slowly works its way up by adding more features. So, we can
    be sure that when a new feature is not loaded or does not work, users will still
    have a basic working web page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步增强，另一方面，从大多数用户都能使用的基线开始，通过添加更多功能逐步提升。因此，我们可以确保当新功能没有加载或无法工作时，用户仍然有一个基本可用的网页。
- en: 'So, let’s get back to our question: *How do we make sure that our web page
    is usable to all users?* We’ll uncover that in the following section.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们回到我们的问题：*我们如何确保我们的网页对所有用户都是可用的？* 我们将在下一节中揭开这个秘密。
- en: Progressively enhancing the web experience
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐步增强网络体验
- en: One of the ways is to make sure that we follow the standards. HTML, CSS, and
    JavaScript are the main languages of the web. We make sure we only use language
    features that are part of the standard specifications. Features that have been
    part of the specifications for longer have a higher probability of being implemented
    by all browsers. The latest and hottest features are less likely to be available
    in all browsers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是我们确保遵循标准。HTML、CSS和JavaScript是网络的主要语言。我们确保我们只使用标准规范中的语言特性。那些已经包含在规范中较长时间的特性更有可能被所有浏览器实现。最新和最热门的特性在所有浏览器中可能不太可用。
- en: So, build your web pages with standard HTML, CSS, and JavaScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用标准的HTML、CSS和JavaScript构建你的网页。
- en: 'This then leads to the next question: *How do we deliver a differentiating
    experience to users based on their browser, device, and* *network capabilities?*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了下一个问题：*我们如何根据用户的浏览器、设备和* *网络能力提供差异化的用户体验？*
- en: There are many ways to do this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种方法可以做到这一点。
- en: One key idea for most approaches is to build your application layer by layer.
    Start with the first layer of core functionality and make sure everything works.
    Then, add subsequent layers to enhance the experience.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数方法来说，一个关键的想法是分层构建你的应用程序。从核心功能的第一层开始，确保一切正常工作。然后，添加随后的层来增强体验。
- en: Building web pages in layers
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层构建网页
- en: One example of building web pages in layers is to build the base content and
    functionality in HTML as the base layer, then add styles, transitions, and animations
    using CSS as the next layer. Finally, complex interactivity is added using JavaScript
    as the final layer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 分层构建网页的一个例子是，首先在HTML中构建基础内容和功能作为基础层，然后使用CSS作为下一层添加样式、过渡和动画。最后，使用JavaScript作为最终层添加复杂的交互性。
- en: This aligns with how the browser loads your website.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这与浏览器加载你的网站的方式相一致。
- en: Whenever a user visits your website, the first thing the browser downloads from
    your website is HTML. HTML describes your content. HTML tags such as `<p>`, `<div>`,
    and `<table>` describe how your content should be laid out on the screen. HTML
    tags such as `<form>`, `<input>`, and `<a>` describe how users can submit data
    and interact with your content.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户访问你的网站时，浏览器首先从你的网站下载的是HTML。HTML描述了你的内容。例如，`<p>`、`<div>`和`<table>`标签描述了内容在屏幕上的布局方式。而`<form>`、`<input>`和`<a>`标签描述了用户如何提交数据和与内容交互。
- en: With HTML, your website should already provide basic content and functionality
    to the user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML，你的网站应该已经为用户提供基本的内容和功能。
- en: And if you have `<link rel="stylesheet">` within the HTML, with reference to
    external CSS files, the browser will then make separate requests to download the
    CSS resource and parse and apply the CSS styles to your document. This will, in
    turn, enhance the look and feel of the default browser styles. HTML can offer
    basic layouts, but with CSS, you can have advanced layouts, such as flex layouts,
    grid layouts, and so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你HTML中有`<link rel="stylesheet">`，并引用外部CSS文件，浏览器将会分别发出请求下载CSS资源，然后解析并应用CSS样式到你的文档上。这将反过来增强默认浏览器样式的视觉效果。HTML可以提供基本的布局，但有了CSS，你可以拥有更高级的布局，例如弹性布局、网格布局等。
- en: On the other hand, if you have `<script>` tags in your HTML, the browser will
    seek them out and load the referenced JavaScript files, and as soon as the JavaScript
    files are downloaded, the browser will parse them and execute them. JavaScript
    can be used to dynamically make changes to the DOM, perform computations, and
    add interactivity to the website.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的HTML中有`<script>`标签，浏览器将会寻找并加载引用的JavaScript文件，一旦JavaScript文件下载完成，浏览器将会解析并执行它们。JavaScript可以用来动态地更改DOM，执行计算，并为网站添加交互性。
- en: Without JavaScript, HTML forms alone allow users to submit data; however, upon
    submission, the browser will navigate to a new location based on the form action.
    With JavaScript, you can make an asynchronous HTTP request to send data to the
    server while the user can continue browsing on the same page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 JavaScript，仅使用 HTML 表单即可让用户提交数据；然而，在提交后，浏览器将根据表单操作导航到新的位置。使用 JavaScript，您可以在用户继续在同一页面上浏览的同时，异步发送
    HTTP 请求将数据发送到服务器。
- en: So, as you can see, serving HTML as a base experience layer and adding CSS and
    JavaScript on top for an enhanced experience is progressive enhancement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所看到的，将 HTML 作为基础体验层，并在其上添加 CSS 和 JavaScript 以提供增强体验，这是一种渐进式增强。
- en: Users with older browsers, slower hardware, and lower internet bandwidth can
    still view and interact with your website with just HTML while waiting for CSS
    and JavaScript to be downloaded and executed for a more enhanced experience.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有较旧浏览器、较慢硬件和较低互联网带宽的用户仍然可以在等待 CSS 和 JavaScript 下载和执行以获得更丰富体验的同时，仅使用 HTML 查看和与您的网站互动。
- en: Hopefully, you are now convinced about the first HTML approach. But what if
    your website content is dynamic? How do you generate dynamic HTML for the user?
    Do you need to write separate code to generate dynamic HTML?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您现在已经对第一种 HTML 方法深信不疑。但假设您的网站内容是动态的？您如何为用户生成动态 HTML？您需要编写单独的代码来生成动态 HTML 吗？
- en: No, you don’t.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不，您不需要。
- en: Svelte supports **server-side rendering** (**SSR**). What that means is that
    the same Svelte component can be used to render content on the browser as well
    as generate HTML on the server side.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 支持 **服务器端渲染**（**SSR**）。这意味着相同的 Svelte 组件可以用于在浏览器上渲染内容，同时在服务器端生成 HTML。
- en: You can set it up yourself (however, that’s beyond the scope of this book),
    or you can use meta frameworks such as SvelteKit, which comprehensively sets out
    how everything should work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己设置它（然而，这超出了本书的范围），或者您可以使用像 SvelteKit 这样的元框架，它全面概述了所有应该如何工作。
- en: One thing to take away from here is that no matter your setup, it is possible
    to write your Svelte component as is and have the same Svelte component code that
    you write used in both generating HTML on the server side and rendering content
    on the browser side.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里可以吸取的一点是，无论您的设置如何，您都可以像这样编写您的 Svelte 组件，并且您编写的相同 Svelte 组件代码可以用于在服务器端生成 HTML
    和在浏览器端渲染内容。
- en: 'This begs the question: Does all the code work the same way on both the server
    side and the browser side? Is there code that only runs on the server but not
    on the browser, or the other way around?'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题：所有代码在服务器端和浏览器端是否都以相同的方式工作？是否有只在服务器端运行而不在浏览器端运行的代码，或者相反？
- en: Well, not all code runs both on the server side and on the browser. Svelte actions,
    along with `bind:` directives and `on:` event listeners, are Svelte features that
    do not run on both the server side and the browser side. Svelte actions only run
    on the browser side and not on the server side. That’s because Svelte actions
    run after an element is added to the DOM. Since there’s no DOM when generating
    HTML strings on the server side, Svelte actions do not run on the server side.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，并非所有代码都在服务器端和浏览器端运行。Svelte 动作，以及 `bind:` 指令和 `on:` 事件监听器，是 Svelte 功能，它们不会在服务器端和浏览器端同时运行。Svelte
    动作仅在浏览器端运行，不在服务器端运行。这是因为 Svelte 动作在元素添加到 DOM 之后运行。由于在服务器端生成 HTML 字符串时没有 DOM，因此
    Svelte 动作不会在服务器端运行。
- en: This makes Svelte actions the perfect candidate for progressive enhancements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 Svelte 动作成为渐进式增强的完美候选者。
- en: Svelte actions for progressive enhancements
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Svelte 动作用于渐进式增强
- en: In the previous section, we learned about progressive enhancements and the concept
    of building web pages in layers to achieve progressive enhancements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了渐进式增强以及以分层构建网页以实现渐进式增强的概念。
- en: In this section, we will delve deeper into the role of Svelte actions, which
    enable us to add an extra layer of interactivity to existing HTML elements, making
    them a natural fit for creating progressive enhancements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨 Svelte 动作的作用，这些动作使我们能够为现有的 HTML 元素添加额外的交互层，使它们非常适合创建渐进式增强。
- en: Let’s begin by examining a code example in Svelte to understand how Svelte actions
    fit into this approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查一个 Svelte 代码示例开始，以了解 Svelte 动作如何融入这种方法。
- en: 'Now, imagine the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象以下代码：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When rendered from the server side, you get HTML that looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当从服务器端渲染时，您得到的 HTML 看起来像这样：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The HTML `button` element alone should be able to do what a button element
    is supposed to do: be clickable and able to submit forms.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: But as JavaScript is loaded and the Svelte component code is executed, the `enhance`
    action is run with the `button` element, allowing the action code to enhance the
    `button` element.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of what the action could do: show a helpful tooltip
    upon hovering, provide a loading indicator when pressed, and so on.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Users with older browsers that are having trouble running the Svelte component
    code on the client side might still be able to use and interact with just the
    default HTML button element and experience an unenhanced version of the web page.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: As we have gathered from this section, Svelte actions allow us to add another
    layer of interactivity to existing HTML elements. They are a naturally good candidate
    for designing progressive enhancements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s look at a few examples of using actions to progressively enhance
    HTML elements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The first example we are going to look at is progressively enhancing the `<``a>`
    element.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Example – previewing a link with a <a> element
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first example, we will explore how to progressively enhance a `<a>` element
    to display a preview when hovered upon.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the browser receives HTML that contains a `<a>` tag with a `href` attribute,
    like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It then creates a hyperlink. When you click on the hyperlink, the browser will
    navigate to the destination specified in the `href` attribute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: This is the default behavior of the `<``a>` element.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: As the user loads the JavaScript, we want to make the `<a>` element do more
    than just navigate to a new location.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We are going to enhance the `<a>` element by having it show the destination
    location when hovering over it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we are going to create a `preview` action and use it on the `<``a>`
    element:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Regardless of how the `preview` action is implemented when rendering the preceding
    code on the server side, Svelte will generate the following HTML:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is because Svelte actions never run on the server side.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: As soon as your user receives the HTML response, they can start clicking on
    the link and navigating to new locations. You now have a workable application
    with just the HTML.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the user’s network condition, your JavaScript code, compiled from
    your Svelte component, may take a longer time to arrive. But that does not stop
    the user from using the hyperlinks to navigate away.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Only when the JavaScript is loaded and executed does Svelte run the `preview`
    action with the `<a>` element that is on the DOM and enhances the `<a>` element’s
    behavior.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The point here is that, as much as possible, we make the core functionality
    of our application workable with just the HTML, and we add a layer of enhancement
    with JavaScript, which may come at a much later time depending on the user’s network
    condition.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Enough with the progressive enhancement philosophy. Let’s look at how we can
    implement this `preview` action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: We want the `preview` action to show a floating popup containing the content
    of the link when we move our mouse cursor over the link and hide it as we move
    our mouse cursor away.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `preview` 动作在将鼠标光标移至链接时显示包含链接内容的浮动弹出窗口，并在我们将鼠标光标移开时隐藏它。
- en: 'We can achieve that with `''mouseover''` and `''mouseout''` events. Here’s
    how:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `'mouseover'` 和 `'mouseout'` 事件来实现这一点。下面是如何操作的：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code snippet, we add `'mouseover'` and `'mouseout'` event listeners
    at the beginning of the `preview` action. Additionally, we ensure proper cleanup
    by removing both the `'mouseover'` and `'mouseout'` event listeners in the `destroy`
    method. Before we figure out how to implement `onMouseOver` and `onMouseOut`,
    we need to first decide what the floating popup would look like and how would
    we lay it out in the DOM.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在 `preview` 动作开始时添加了 `'mouseover'` 和 `'mouseout'` 事件监听器。此外，我们通过在
    `destroy` 方法中移除这两个事件监听器来确保适当的清理。在我们弄清楚如何实现 `onMouseOver` 和 `onMouseOut` 之前，我们首先需要决定浮动弹出窗口的外观以及如何在
    DOM 中布局它。
- en: 'To show the content of the link target, we are going to use the `<iframe>`
    element, which allows us to embed another HTML page into the current one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示链接目标的内联内容，我们将使用 `<iframe>` 元素，它允许我们将另一个 HTML 页面嵌入到当前页面中：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To make the `<iframe>` element float above other content instead of being part
    of the document flow, we will need to modify the CSS `position` property of the
    `<iframe>` element by using either `position: fixed` or `position: absolute`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '为了使 `<iframe>` 元素浮在其他内容之上而不是成为文档流的一部分，我们需要通过使用 `position: fixed` 或 `position:
    absolute` 来修改 `<iframe>` 元素的 CSS `position` 属性。'
- en: 'If we used `position: fixed` on the `<iframe>` element, then the `<iframe>`
    element would be positioned relative to the viewport. To place the `<iframe>`
    element right next to the `<a>` element, we will have to figure out the position
    of the `<a>` element relative to the viewport and calculate the top and left values
    to place our `<``iframe>` element.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在 `<iframe>` 元素上使用 `position: fixed`，那么 `<iframe>` 元素将相对于视口进行定位。为了将 `<iframe>`
    元素放置在 `<a>` 元素旁边，我们需要确定 `<a>` 元素相对于视口的定位，并计算顶部和左侧的值以放置我们的 `<iframe>` 元素。'
- en: 'On the other hand, if we used `position: absolute`, then the `<iframe>` element
    would be positioned relative to the nearest positioned parent element. We could
    place the `<iframe>` element inside the `<a>` element and make the `<a>` element
    a positioned parent element by specifying `position: relative` on the `<a>` element
    (the `position: relative` CSS property is to be positioned relative to its current
    position). The `<iframe>` element would then be positioned relative to its parent,
    the `<``a>` element.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '另一方面，如果我们使用 `position: absolute`，那么 `<iframe>` 元素将相对于最近的定位父元素进行定位。我们可以将 `<iframe>`
    元素放在 `<a>` 元素内部，并通过在 `<a>` 元素上指定 `position: relative` 来使其成为定位父元素（`position: relative`
    CSS 属性是相对于其当前位置进行定位）。然后 `<iframe>` 元素将相对于其父元素，即 `<a>` 元素进行定位。'
- en: 'Either approach has its pros and cons. I am going to use the second approach
    here, which is to use `position: absolute`. I will have to modify the content
    and the `position` CSS property of the `<a>` element, but I could get away from
    needing to perform calculations if I use `position: absolute` instead of `position:
    fixed`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '两种方法都有其优缺点。在这里，我将使用第二种方法，即使用 `position: absolute`。我需要修改内容和 `<a>` 元素的 `position`
    CSS 属性，但如果我使用 `position: absolute` 而不是 `position: fixed`，我就可以避免进行计算。'
- en: 'Here’s what the DOM will look like after we place the `<iframe>` element inside
    the `<``a>` element:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将 `<iframe>` 元素放入 `<a>` 元素内部后 DOM 的样子：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our task now is to programmatically create and insert the `<iframe>` element
    in the `onMouseOver` function. The following code snippet illustrates how to do
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的任务是使用程序在 `onMouseOver` 函数中创建并插入 `<iframe>` 元素。以下代码片段展示了如何实现这一点：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, we set the CSS `position` property of the `<a>`
    element to `'relative'`. In the `onMouseOver` function, which will be called when
    the mouse is hovered over the `<a>` element, we programmatically create a `<iframe>`
    element, style it, and insert it into the `<``a>` element.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `<a>` 元素的 CSS `position` 属性设置为 `'relative'`。在鼠标悬停在 `<a>` 元素上时将被调用的
    `onMouseOver` 函数中，我们将程序化创建一个 `<iframe>` 元素，设置其样式，并将其插入到 `<a>` 元素中。
- en: In the previous code, we are using the DOM API such as `document.createElement()`
    and `element.appendChild()`. Since the `<iframe>` element is programmatically
    created, we are also programmatically modifying its `style` attribute.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 DOM API，如 `document.createElement()` 和 `element.appendChild()`。由于
    `<iframe>` 元素是程序创建的，我们也在程序上修改了它的 `style` 属性。
- en: Luckily, in this example, we are only creating one element, but you can imagine
    how this could easily grow messy if we were to create more elements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在这个例子中，我们只创建了一个元素，但你可以想象，如果我们创建更多元素，这会多么容易变得混乱。
- en: Since we are learning Svelte here and Svelte is designed to abstract out these
    imperative DOM instructions into declarative Svelte syntax, why not leverage Svelte
    in our action?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里学习 Svelte，而 Svelte 是设计用来将这些命令式 DOM 指令抽象成声明式 Svelte 语法，为什么不在我们的操作中利用 Svelte
    呢？
- en: 'We can replace the previous imperative code with a Svelte component, like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 Svelte 组件替换之前的命令式代码，如下所示：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code snippet shows a Svelte component that contains a `<iframe>`
    element. This `<iframe>` element is equivalent to the one we created programmatically
    in the previous code snippet. It has the same CSS styles applied.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了一个包含 `<iframe>` 元素的 Svelte 组件。这个 `<iframe>` 元素与我们之前代码中程序创建的元素等效。它应用了相同的
    CSS 样式。
- en: 'The Svelte component exposes a prop called `src`, and the value of the `src`
    prop will be used to set the value of the `src` attribute of the `<iframe>` element.
    Now, instead of calling the DOM APIs to create the `<iframe>` element, we can
    instantiate our Svelte component and pass the desired `src` value as the `src`
    prop to the component. In Svelte, you can instantiate a component by using the
    `new` keyword along with the component’s constructor, passing in any required
    props as part of the constructor arguments. The Svelte component will then render
    the `<iframe>` element with the specified `src` attribute value based on the passed
    prop. This simplifies the process of creating and managing a `<iframe>` element
    within our Svelte application:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 组件暴露了一个名为 `src` 的属性，`src` 属性的值将被用来设置 `<iframe>` 元素的 `src` 属性的值。现在，我们不再需要调用
    DOM API 来创建 `<iframe>` 元素，而是可以实例化我们的 Svelte 组件，并将期望的 `src` 值作为 `src` 属性传递给组件。在
    Svelte 中，你可以通过使用 `new` 关键字和组件的构造函数来实例化一个组件，将任何所需的属性作为构造函数参数的一部分传递。然后，Svelte 组件将根据传递的属性渲染具有指定
    `src` 属性值的 `<iframe>` 元素。这简化了在 Svelte 应用程序中创建和管理 `<iframe>` 元素的过程：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, we’ve replaced the DOM operations in the `onMouseOver`
    function to instantiate the `IframePopup` Svelte component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `onMouseOver` 函数中的 DOM 操作替换为实例化 `IframePopup` Svelte 组件。
- en: 'We need to remember to remove the popup when we move our mouse away from the
    link. Here’s how we can do that:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移动鼠标离开链接时，我们需要记住移除弹出窗口。以下是我们可以这样做的方法：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although we are only inserting one HTML element into the DOM through Svelte
    actions, we’ve seen that it’s much more manageable to encapsulate that into a
    Svelte component and instantiate the Svelte component instead of manually creating
    HTML elements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只通过 Svelte 动作将一个 HTML 元素插入 DOM，但我们已经看到，将其封装到一个 Svelte 组件中并实例化该组件，而不是手动创建
    HTML 元素，要容易管理得多。
- en: We can then leverage Svelte to create scoped styles, as well as add other interactive
    logic to the elements we are going to create.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以利用 Svelte 创建作用域样式，以及向我们将要创建的元素添加其他交互逻辑。
- en: 'We could also add transitions to elements; instead of appearing abruptly upon
    hovering, we can make the popup fade by using a `fade` transition, like so:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向元素添加过渡效果；而不是在悬停时突然出现，我们可以使用 `fade` 过渡效果使弹出窗口淡入，如下所示：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, transitions are not played when the component is first created.
    So, we need to pass in the `intro: true` option to play the transition:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，当组件首次创建时，不会播放过渡效果。因此，我们需要传递 `intro: true` 选项来播放过渡效果：'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code snippet, we pass in `intro: true` to the `IframePopup`
    constructor.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码片段中，我们将 `intro: true` 传递给 `IframePopup` 构造函数。'
- en: We now have a link that shows a preview in a popup that fades in upon hovering.
    Try simulating loading the page with a slow network. Most browsers provide developer
    tools to simulate network speed. For example, if you are using Google Chrome,
    then you can open the **Developer Tools**, find the **Network conditions** tab,
    look for the **Network throttling** section, and choose the **Slow** **3G** preset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个显示在弹出窗口中的链接，悬停时会淡入。尝试模拟使用慢速网络加载页面。大多数浏览器都提供开发者工具来模拟网络速度。例如，如果你使用Google
    Chrome，那么你可以打开**开发者工具**，找到**网络条件**选项卡，查找**网络限制**部分，并选择**慢速** **3G**预设。
- en: Try reloading your page, and you’ll find that once you see the link (albeit
    the JavaScript file is still loading), the link is immediately working; clicking
    it will navigate you to the destination. As the JavaScript is finally loaded into
    the browser, your link is now enhanced, and you are now able to hover over the
    link and see a preview.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重新加载你的页面，你会发现一旦你看到链接（尽管JavaScript文件仍在加载），链接就会立即生效；点击它将带你到目的地。随着JavaScript最终加载到浏览器中，你的链接现在得到了增强，你现在能够悬停在链接上并看到预览。
- en: With our link preview action done, let’s look at another common component in
    a web app, forms, and see how we can progressively enhance a form element.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的链接预览动作完成后，让我们看看网络应用中的另一个常见组件，表单，并看看我们如何逐步增强表单元素。
- en: Example – progressively enhancing a form
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 逐步增强表单
- en: A `<form>` element is a section of a document that can contain inputs that will
    be used to submit information.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`<form>`元素是文档的一部分，可以包含用于提交信息的输入。
- en: By default, when you submit a form, the browser will navigate to a URL to process
    the form submission. This means that the user will lose the state they are in
    as they navigate away from the current page when they submit the form.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你提交表单时，浏览器将导航到URL以处理表单提交。这意味着当用户提交表单并离开当前页面时，他们会丢失他们所在的状态。
- en: However, with the ability to make asynchronous requests through the browser
    `fetch` API, we can now submit data through API requests without leaving the current
    page, and stay where we are.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过浏览器`fetch` API的异步请求能力，我们现在可以通过API请求提交数据，而无需离开当前页面，并保持在原地。
- en: This means that if the site is playing music, video, or animation, they will
    still be playing while we make asynchronous API calls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果网站正在播放音乐、视频或动画，它们在我们进行异步API调用时仍然会播放。
- en: Our task now is to create an action to enhance the form element so that the
    enhanced form will not navigate to a new location, but rather submit the form
    data asynchronously.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的任务是创建一个动作来增强表单元素，使得增强后的表单不会导航到新位置，而是异步提交表单数据。
- en: For lack of a better name, I am going to call this enhancing action `enhance`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有更好的名字，我将把这个增强动作称为`enhance`。
- en: Before we proceed to implement the `enhance` action, let’s recap on the default
    form behavior.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实施`增强`动作之前，让我们回顾一下默认表单行为。
- en: The default form behavior
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认表单行为
- en: When you have a `<form>` element, by default when you hit the `action` attribute,
    carrying along with it the value filled in the `<input>` elements within the `<``form>`
    element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个`<form>`元素时，默认情况下，当你点击`action`属性时，它会携带`<form>`元素内填充的`<input>`元素的值。
- en: 'For example, imagine you have the following form:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象你有一个以下表单：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you hit the `/foo?name=xxx&address=yyy`, carrying the form data via query
    parameters.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入`/foo?name=xxx&address=yyy`，通过查询参数携带表单数据。
- en: A `<form>` element can define the HTTP method to use to submit the form, by
    specifying the `method` attribute.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`<form>`元素可以通过指定`method`属性来定义用于提交表单的HTTP方法。
- en: 'For example, the following form will navigate to `/foo` via a `POST` request:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下表单将通过`POST`请求导航到`/foo`：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Form data will be sent as a request body for the `POST` request.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表单数据将以请求体形式发送到`POST`请求。
- en: Depending on the server’s implementation for the `/foo` endpoint, the server
    can choose how to process the data and what to show on the `/foo` page. Sometimes,
    the server may decide to redirect back to the current page after processing the
    data. In that case, having an action that can replace the default form action
    and submit the form data asynchronously instead would be very useful, since we
    will eventually come back to the same page.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务器对`/foo`端点的实现，服务器可以选择如何处理数据以及要在`/foo`页面上显示什么。有时，服务器可能会决定在处理数据后重定向回当前页面。在这种情况下，有一个可以替换默认表单动作并异步提交表单数据的动作将非常有用，因为我们最终会回到同一个页面。
- en: Now we know the default form behavior, let’s figure out what we need to implement
    the `enhance` action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了默认的表单行为，让我们弄清楚我们需要实现`enhance`动作所需的内容。
- en: Implementing the enhance action
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现增强动作
- en: Let’s break the problem down.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个问题。
- en: First, we need to figure out how to know when a user submits a form. Then, we
    need to prevent the default form behavior and then make an asynchronous API call
    to submit the form asynchronously, and finally reset the form to the initial state,
    similar to what you would see after the server redirects back to the same page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要弄清楚何时用户提交表单。然后，我们需要防止默认的表单行为，然后异步调用API提交表单，最后将表单重置到初始状态，类似于服务器重定向回同一页面后的情况。
- en: 'To figure out when the user submits a form, we could listen to the `''submit''`
    event on the `<``form>` element:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定用户何时提交表单，我们可以监听`<form>`元素上的`'submit'`事件：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To prevent the default form behavior, we call `event.preventDefault()` on the
    `''submit''` event listener to prevent the default submit behavior:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止默认的表单行为，我们在`'submit'`事件监听器上调用`event.preventDefault()`以防止默认提交行为：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To make the API call to submit the form asynchronously, we need to first find
    out where we are submitting the form. We can get this information from reading
    the `action` property of the `form` instance:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了异步提交表单的API调用，我们首先需要找出我们正在提交表单的位置。我们可以从读取`form`实例的`action`属性来获取这个信息：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also determine the preferred HTTP request method from the `form` instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`form`实例中确定首选的HTTP请求方法：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To get the form data submitted, we can use the `FormData` interface:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取提交的表单数据，我们可以使用`FormData`接口：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the URL, request method, and data, we can use the `fetch` API to submit
    the form:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了URL、请求方法和数据后，我们可以使用`fetch` API提交表单：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, to reset the form, we can use the `reset()` method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了重置表单，我们可以使用`reset()`方法：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Putting everything together, we have the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合起来，我们得到以下内容：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, try to submit the form after the JavaScript is loaded. You’ll notice that
    a network request is made to submit the form, while you remain on the same page
    without navigating away.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试在JavaScript加载后提交表单。你会发现有一个网络请求被用来提交表单，而你仍然停留在同一页面上，没有导航离开。
- en: Try to disable the JavaScript or simulate a slow network speed. You’ll notice
    that you can still submit the form, while the JavaScript is still being loaded.
    However, this time round, you submit through the default browser behavior, which
    will navigate you away from the page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试禁用JavaScript或模拟缓慢的网络速度。你会发现你仍然可以提交表单，而JavaScript仍在加载。然而，这一次，你通过默认的浏览器行为提交，这会将你从页面上导航离开。
- en: Here we have it—a workable form by default, but progressively enhanced to submit
    form data without leaving the page if the JavaScript is being loaded.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是它——默认可用的可工作表单，但通过渐进增强可以在JavaScript加载时无需离开页面提交表单数据。
- en: 'There’s a lot that can be improved on the `enhance` action. I’ll leave that
    as an exercise:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`enhance`动作有很多可以改进的地方。我将把它留作练习：'
- en: Modify the `enhance` action to allow passing in a callback function that will
    be called after the form submission is successfully made.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`enhance`动作以允许传递一个回调函数，该函数将在表单提交成功后调用。
- en: What happens if the form submission fails? How should you handle such a case?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表单提交失败会发生什么？你应该如何处理这种情况？
- en: Right now, the `enhance` action submits the form data through the request body;
    however, when the form method is `"get"`, form data should be passed through query
    parameters. Modify the `enhance` action to handle the `"get"` form method.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，`enhance`动作通过请求体提交表单数据；然而，当表单方法为`"get"`时，表单数据应通过查询参数传递。修改`enhance`动作以处理`"get"`表单方法。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained what progressive enhancement is and why it is
    important. Following up on that, we learned how we can use Svelte actions to progressively
    enhance our elements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了渐进增强是什么以及为什么它很重要。在此基础上，我们学习了如何使用Svelte动作来渐进增强我们的元素。
- en: We went through two different examples of progressive enhancements—enhancing
    a link to make it show a preview popup, and enhancing form elements to submit
    a form asynchronously.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了两种不同的渐进增强示例——增强一个链接以显示预览弹出窗口，以及增强表单元素以异步提交表单。
- en: In the past three chapters, we’ve seen three different patterns and use cases
    of Svelte actions, creating custom events, integrating UI libraries, and progressive
    enhancements. What you can do with Svelte actions is not limited to the three
    different use cases that we’ve discussed so far, but hopefully, these patterns
    have opened your imagination and made you see what is possible with Svelte actions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的三章中，我们看到了 Svelte actions 的三种不同模式和用例，包括创建自定义事件、集成 UI 库和渐进式增强。Svelte actions
    可以做的不仅仅限于我们之前讨论的三个不同用例，但希望这些模式已经激发了你的想象力，让你看到了 Svelte actions 的可能性。
- en: With that, we are moving on to the next part of the book. We will be exploring
    Svelte context and stores from [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121)
    to [*Chapter 12*](B18887_12.xhtml#_idTextAnchor175), exploring their various use
    cases, such as in state management, creating renderless components, and using
    them for animations. We will start by defining and comparing Svelte contexts and
    Svelte stores in the next chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们将继续探索本书的下一部分。我们将从 [*第8章*](B18887_08.xhtml#_idTextAnchor121) 到 [*第12章*](B18887_12.xhtml#_idTextAnchor175)
    探索 Svelte 上下文和 Stores 的各种用例，例如在状态管理、创建无渲染组件以及用于动画。我们将在下一章中定义并比较 Svelte 上下文和 Svelte
    Stores。
- en: 'Part 3: Context and Stores'
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：上下文和 Stores
- en: In this part, we will dive deep into Svelte’s two core features, Svelte context
    and Svelte stores. Over the five chapters, we will explore different scenarios
    for using Svelte context and stores. We’ll start our exploration by defining Svelte
    context and stores. This will be followed by a deep dive into implementing custom
    stores and strategies for managing application state using Svelte stores. Following
    that, we will learn how to use Svelte context to create a renderless component.
    Finally, we will learn how to create animations using Svelte stores.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将深入探讨 Svelte 的两个核心特性：Svelte 上下文和 Svelte Stores。在接下来的五章中，我们将探索使用 Svelte
    上下文和 Stores 的不同场景。我们的探索将从定义 Svelte 上下文和 Stores 开始。随后，我们将深入研究实现自定义 Stores 和使用 Svelte
    Stores 管理应用程序状态的战略。接着，我们将学习如何使用 Svelte 上下文创建无渲染组件。最后，我们将学习如何使用 Svelte Stores 创建动画。
- en: 'This part has the following chapters:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B18887_08.xhtml#_idTextAnchor121)*, Context versus Stores*'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18887_08.xhtml#_idTextAnchor121)*，上下文与 Stores 对比*'
- en: '[*Chapter 9*](B18887_09.xhtml#_idTextAnchor135)*, Implementing Custom Stores*'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18887_09.xhtml#_idTextAnchor135)*，实现自定义 Stores*'
- en: '[*Chapter 10*](B18887_10.xhtml#_idTextAnchor152)*, State Management with Svelte
    Stores*'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18887_10.xhtml#_idTextAnchor152)*，使用 Svelte Stores 进行状态管理*'
- en: '[*Chapter 11*](B18887_11.xhtml#_idTextAnchor163)*, Renderless Components*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18887_11.xhtml#_idTextAnchor163)*，无渲染组件*'
- en: '[*Chapter 12*](B18887_12.xhtml#_idTextAnchor175)*, Stores and Animation*s'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18887_12.xhtml#_idTextAnchor175)*，Stores 和动画*'
