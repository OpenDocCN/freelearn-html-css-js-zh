- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Progressive Enhancement with Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Progressive enhancement is a design philosophy in web development that emphasizes
    providing content and core functionality to everyone while delivering an enhanced
    experience to users who can afford it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with a more in-depth discussion of what progressive
    enhancement is. There are many ways to achieve progressive enhancement in your
    application; we will explore one of them by using Svelte actions. I will explain
    my reasoning as to why I think Svelte actions are designed for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the chapter, we will go through a few examples of using Svelte
    actions to progressively enhance our application.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to build an application that follows
    the principles of progressive enhancement and supports as many user devices as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is progressive enhancement?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use Svelte actions for progressive enhancement?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of progressive enhancements using Svelte actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the examples and code for this chapter here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: What is progressive enhancement?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important thing in *progressive enhancement* is missing from the phrase
    itself. Something that is implied here is where are we progressively enhancing
    from.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea of progressive enhancement is to provide a great baseline of essential
    content and core functionality to everyone, regardless of the browser software,
    device hardware, or the quality of the internet connection. Older browser software
    may not support newer JavaScript syntaxes and CSS features; older device hardware
    may take up more time to process and render your web page; a slower internet connection
    may take longer to load the resources needed to display your web page.
  prefs: []
  type: TYPE_NORMAL
- en: How do we ensure our web page stays usable for as many users as possible? Think
    about this for a while—I will come back to it later.
  prefs: []
  type: TYPE_NORMAL
- en: For users who can afford better browsers, more powerful hardware, and higher
    internet bandwidth, we progressively provide an enhanced experience to them. We
    leverage the power of JavaScript and CSS to surprise and delight our users.
  prefs: []
  type: TYPE_NORMAL
- en: How do we differentiate between the users and decide when to deliver an enhanced
    experience?
  prefs: []
  type: TYPE_NORMAL
- en: There is another term that is often used to compare with progressive enhancement,
    and that is *graceful degradation*. Graceful degradation starts from a feature-rich
    baseline and gracefully handles the situation when the user browser can no longer
    support the feature by replacing it with a simpler alternate experience. A lot
    of the time, these features start with a more complex assumption, and so execution-wise,
    it is much harder to gracefully degrade to all kinds of users.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive enhancement, on the other hand, starts from a baseline that works
    for most users and slowly works its way up by adding more features. So, we can
    be sure that when a new feature is not loaded or does not work, users will still
    have a basic working web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s get back to our question: *How do we make sure that our web page
    is usable to all users?* We’ll uncover that in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: Progressively enhancing the web experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ways is to make sure that we follow the standards. HTML, CSS, and
    JavaScript are the main languages of the web. We make sure we only use language
    features that are part of the standard specifications. Features that have been
    part of the specifications for longer have a higher probability of being implemented
    by all browsers. The latest and hottest features are less likely to be available
    in all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: So, build your web pages with standard HTML, CSS, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'This then leads to the next question: *How do we deliver a differentiating
    experience to users based on their browser, device, and* *network capabilities?*'
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: One key idea for most approaches is to build your application layer by layer.
    Start with the first layer of core functionality and make sure everything works.
    Then, add subsequent layers to enhance the experience.
  prefs: []
  type: TYPE_NORMAL
- en: Building web pages in layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One example of building web pages in layers is to build the base content and
    functionality in HTML as the base layer, then add styles, transitions, and animations
    using CSS as the next layer. Finally, complex interactivity is added using JavaScript
    as the final layer.
  prefs: []
  type: TYPE_NORMAL
- en: This aligns with how the browser loads your website.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user visits your website, the first thing the browser downloads from
    your website is HTML. HTML describes your content. HTML tags such as `<p>`, `<div>`,
    and `<table>` describe how your content should be laid out on the screen. HTML
    tags such as `<form>`, `<input>`, and `<a>` describe how users can submit data
    and interact with your content.
  prefs: []
  type: TYPE_NORMAL
- en: With HTML, your website should already provide basic content and functionality
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: And if you have `<link rel="stylesheet">` within the HTML, with reference to
    external CSS files, the browser will then make separate requests to download the
    CSS resource and parse and apply the CSS styles to your document. This will, in
    turn, enhance the look and feel of the default browser styles. HTML can offer
    basic layouts, but with CSS, you can have advanced layouts, such as flex layouts,
    grid layouts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you have `<script>` tags in your HTML, the browser will
    seek them out and load the referenced JavaScript files, and as soon as the JavaScript
    files are downloaded, the browser will parse them and execute them. JavaScript
    can be used to dynamically make changes to the DOM, perform computations, and
    add interactivity to the website.
  prefs: []
  type: TYPE_NORMAL
- en: Without JavaScript, HTML forms alone allow users to submit data; however, upon
    submission, the browser will navigate to a new location based on the form action.
    With JavaScript, you can make an asynchronous HTTP request to send data to the
    server while the user can continue browsing on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, serving HTML as a base experience layer and adding CSS and
    JavaScript on top for an enhanced experience is progressive enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Users with older browsers, slower hardware, and lower internet bandwidth can
    still view and interact with your website with just HTML while waiting for CSS
    and JavaScript to be downloaded and executed for a more enhanced experience.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you are now convinced about the first HTML approach. But what if
    your website content is dynamic? How do you generate dynamic HTML for the user?
    Do you need to write separate code to generate dynamic HTML?
  prefs: []
  type: TYPE_NORMAL
- en: No, you don’t.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte supports **server-side rendering** (**SSR**). What that means is that
    the same Svelte component can be used to render content on the browser as well
    as generate HTML on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: You can set it up yourself (however, that’s beyond the scope of this book),
    or you can use meta frameworks such as SvelteKit, which comprehensively sets out
    how everything should work.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to take away from here is that no matter your setup, it is possible
    to write your Svelte component as is and have the same Svelte component code that
    you write used in both generating HTML on the server side and rendering content
    on the browser side.
  prefs: []
  type: TYPE_NORMAL
- en: 'This begs the question: Does all the code work the same way on both the server
    side and the browser side? Is there code that only runs on the server but not
    on the browser, or the other way around?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, not all code runs both on the server side and on the browser. Svelte actions,
    along with `bind:` directives and `on:` event listeners, are Svelte features that
    do not run on both the server side and the browser side. Svelte actions only run
    on the browser side and not on the server side. That’s because Svelte actions
    run after an element is added to the DOM. Since there’s no DOM when generating
    HTML strings on the server side, Svelte actions do not run on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: This makes Svelte actions the perfect candidate for progressive enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte actions for progressive enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned about progressive enhancements and the concept
    of building web pages in layers to achieve progressive enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will delve deeper into the role of Svelte actions, which
    enable us to add an extra layer of interactivity to existing HTML elements, making
    them a natural fit for creating progressive enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by examining a code example in Svelte to understand how Svelte actions
    fit into this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendered from the server side, you get HTML that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML `button` element alone should be able to do what a button element
    is supposed to do: be clickable and able to submit forms.'
  prefs: []
  type: TYPE_NORMAL
- en: But as JavaScript is loaded and the Svelte component code is executed, the `enhance`
    action is run with the `button` element, allowing the action code to enhance the
    `button` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of what the action could do: show a helpful tooltip
    upon hovering, provide a loading indicator when pressed, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Users with older browsers that are having trouble running the Svelte component
    code on the client side might still be able to use and interact with just the
    default HTML button element and experience an unenhanced version of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: As we have gathered from this section, Svelte actions allow us to add another
    layer of interactivity to existing HTML elements. They are a naturally good candidate
    for designing progressive enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s look at a few examples of using actions to progressively enhance
    HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: The first example we are going to look at is progressively enhancing the `<``a>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Example – previewing a link with a <a> element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first example, we will explore how to progressively enhance a `<a>` element
    to display a preview when hovered upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the browser receives HTML that contains a `<a>` tag with a `href` attribute,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It then creates a hyperlink. When you click on the hyperlink, the browser will
    navigate to the destination specified in the `href` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: This is the default behavior of the `<``a>` element.
  prefs: []
  type: TYPE_NORMAL
- en: As the user loads the JavaScript, we want to make the `<a>` element do more
    than just navigate to a new location.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to enhance the `<a>` element by having it show the destination
    location when hovering over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we are going to create a `preview` action and use it on the `<``a>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of how the `preview` action is implemented when rendering the preceding
    code on the server side, Svelte will generate the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is because Svelte actions never run on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as your user receives the HTML response, they can start clicking on
    the link and navigating to new locations. You now have a workable application
    with just the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the user’s network condition, your JavaScript code, compiled from
    your Svelte component, may take a longer time to arrive. But that does not stop
    the user from using the hyperlinks to navigate away.
  prefs: []
  type: TYPE_NORMAL
- en: Only when the JavaScript is loaded and executed does Svelte run the `preview`
    action with the `<a>` element that is on the DOM and enhances the `<a>` element’s
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The point here is that, as much as possible, we make the core functionality
    of our application workable with just the HTML, and we add a layer of enhancement
    with JavaScript, which may come at a much later time depending on the user’s network
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: Enough with the progressive enhancement philosophy. Let’s look at how we can
    implement this `preview` action.
  prefs: []
  type: TYPE_NORMAL
- en: We want the `preview` action to show a floating popup containing the content
    of the link when we move our mouse cursor over the link and hide it as we move
    our mouse cursor away.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve that with `''mouseover''` and `''mouseout''` events. Here’s
    how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we add `'mouseover'` and `'mouseout'` event listeners
    at the beginning of the `preview` action. Additionally, we ensure proper cleanup
    by removing both the `'mouseover'` and `'mouseout'` event listeners in the `destroy`
    method. Before we figure out how to implement `onMouseOver` and `onMouseOut`,
    we need to first decide what the floating popup would look like and how would
    we lay it out in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the content of the link target, we are going to use the `<iframe>`
    element, which allows us to embed another HTML page into the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the `<iframe>` element float above other content instead of being part
    of the document flow, we will need to modify the CSS `position` property of the
    `<iframe>` element by using either `position: fixed` or `position: absolute`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used `position: fixed` on the `<iframe>` element, then the `<iframe>`
    element would be positioned relative to the viewport. To place the `<iframe>`
    element right next to the `<a>` element, we will have to figure out the position
    of the `<a>` element relative to the viewport and calculate the top and left values
    to place our `<``iframe>` element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we used `position: absolute`, then the `<iframe>` element
    would be positioned relative to the nearest positioned parent element. We could
    place the `<iframe>` element inside the `<a>` element and make the `<a>` element
    a positioned parent element by specifying `position: relative` on the `<a>` element
    (the `position: relative` CSS property is to be positioned relative to its current
    position). The `<iframe>` element would then be positioned relative to its parent,
    the `<``a>` element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Either approach has its pros and cons. I am going to use the second approach
    here, which is to use `position: absolute`. I will have to modify the content
    and the `position` CSS property of the `<a>` element, but I could get away from
    needing to perform calculations if I use `position: absolute` instead of `position:
    fixed`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the DOM will look like after we place the `<iframe>` element inside
    the `<``a>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our task now is to programmatically create and insert the `<iframe>` element
    in the `onMouseOver` function. The following code snippet illustrates how to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we set the CSS `position` property of the `<a>`
    element to `'relative'`. In the `onMouseOver` function, which will be called when
    the mouse is hovered over the `<a>` element, we programmatically create a `<iframe>`
    element, style it, and insert it into the `<``a>` element.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, we are using the DOM API such as `document.createElement()`
    and `element.appendChild()`. Since the `<iframe>` element is programmatically
    created, we are also programmatically modifying its `style` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, in this example, we are only creating one element, but you can imagine
    how this could easily grow messy if we were to create more elements.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are learning Svelte here and Svelte is designed to abstract out these
    imperative DOM instructions into declarative Svelte syntax, why not leverage Svelte
    in our action?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace the previous imperative code with a Svelte component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows a Svelte component that contains a `<iframe>`
    element. This `<iframe>` element is equivalent to the one we created programmatically
    in the previous code snippet. It has the same CSS styles applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Svelte component exposes a prop called `src`, and the value of the `src`
    prop will be used to set the value of the `src` attribute of the `<iframe>` element.
    Now, instead of calling the DOM APIs to create the `<iframe>` element, we can
    instantiate our Svelte component and pass the desired `src` value as the `src`
    prop to the component. In Svelte, you can instantiate a component by using the
    `new` keyword along with the component’s constructor, passing in any required
    props as part of the constructor arguments. The Svelte component will then render
    the `<iframe>` element with the specified `src` attribute value based on the passed
    prop. This simplifies the process of creating and managing a `<iframe>` element
    within our Svelte application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we’ve replaced the DOM operations in the `onMouseOver`
    function to instantiate the `IframePopup` Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to remember to remove the popup when we move our mouse away from the
    link. Here’s how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although we are only inserting one HTML element into the DOM through Svelte
    actions, we’ve seen that it’s much more manageable to encapsulate that into a
    Svelte component and instantiate the Svelte component instead of manually creating
    HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: We can then leverage Svelte to create scoped styles, as well as add other interactive
    logic to the elements we are going to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also add transitions to elements; instead of appearing abruptly upon
    hovering, we can make the popup fade by using a `fade` transition, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, transitions are not played when the component is first created.
    So, we need to pass in the `intro: true` option to play the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we pass in `intro: true` to the `IframePopup`
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a link that shows a preview in a popup that fades in upon hovering.
    Try simulating loading the page with a slow network. Most browsers provide developer
    tools to simulate network speed. For example, if you are using Google Chrome,
    then you can open the **Developer Tools**, find the **Network conditions** tab,
    look for the **Network throttling** section, and choose the **Slow** **3G** preset.
  prefs: []
  type: TYPE_NORMAL
- en: Try reloading your page, and you’ll find that once you see the link (albeit
    the JavaScript file is still loading), the link is immediately working; clicking
    it will navigate you to the destination. As the JavaScript is finally loaded into
    the browser, your link is now enhanced, and you are now able to hover over the
    link and see a preview.
  prefs: []
  type: TYPE_NORMAL
- en: With our link preview action done, let’s look at another common component in
    a web app, forms, and see how we can progressively enhance a form element.
  prefs: []
  type: TYPE_NORMAL
- en: Example – progressively enhancing a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `<form>` element is a section of a document that can contain inputs that will
    be used to submit information.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when you submit a form, the browser will navigate to a URL to process
    the form submission. This means that the user will lose the state they are in
    as they navigate away from the current page when they submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the ability to make asynchronous requests through the browser
    `fetch` API, we can now submit data through API requests without leaving the current
    page, and stay where we are.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if the site is playing music, video, or animation, they will
    still be playing while we make asynchronous API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Our task now is to create an action to enhance the form element so that the
    enhanced form will not navigate to a new location, but rather submit the form
    data asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: For lack of a better name, I am going to call this enhancing action `enhance`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed to implement the `enhance` action, let’s recap on the default
    form behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The default form behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a `<form>` element, by default when you hit the `action` attribute,
    carrying along with it the value filled in the `<input>` elements within the `<``form>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When you hit the `/foo?name=xxx&address=yyy`, carrying the form data via query
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A `<form>` element can define the HTTP method to use to submit the form, by
    specifying the `method` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following form will navigate to `/foo` via a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Form data will be sent as a request body for the `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the server’s implementation for the `/foo` endpoint, the server
    can choose how to process the data and what to show on the `/foo` page. Sometimes,
    the server may decide to redirect back to the current page after processing the
    data. In that case, having an action that can replace the default form action
    and submit the form data asynchronously instead would be very useful, since we
    will eventually come back to the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know the default form behavior, let’s figure out what we need to implement
    the `enhance` action.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the enhance action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s break the problem down.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to figure out how to know when a user submits a form. Then, we
    need to prevent the default form behavior and then make an asynchronous API call
    to submit the form asynchronously, and finally reset the form to the initial state,
    similar to what you would see after the server redirects back to the same page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To figure out when the user submits a form, we could listen to the `''submit''`
    event on the `<``form>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent the default form behavior, we call `event.preventDefault()` on the
    `''submit''` event listener to prevent the default submit behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the API call to submit the form asynchronously, we need to first find
    out where we are submitting the form. We can get this information from reading
    the `action` property of the `form` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also determine the preferred HTTP request method from the `form` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the form data submitted, we can use the `FormData` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With the URL, request method, and data, we can use the `fetch` API to submit
    the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to reset the form, we can use the `reset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting everything together, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, try to submit the form after the JavaScript is loaded. You’ll notice that
    a network request is made to submit the form, while you remain on the same page
    without navigating away.
  prefs: []
  type: TYPE_NORMAL
- en: Try to disable the JavaScript or simulate a slow network speed. You’ll notice
    that you can still submit the form, while the JavaScript is still being loaded.
    However, this time round, you submit through the default browser behavior, which
    will navigate you away from the page.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have it—a workable form by default, but progressively enhanced to submit
    form data without leaving the page if the JavaScript is being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a lot that can be improved on the `enhance` action. I’ll leave that
    as an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `enhance` action to allow passing in a callback function that will
    be called after the form submission is successfully made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if the form submission fails? How should you handle such a case?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, the `enhance` action submits the form data through the request body;
    however, when the form method is `"get"`, form data should be passed through query
    parameters. Modify the `enhance` action to handle the `"get"` form method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained what progressive enhancement is and why it is
    important. Following up on that, we learned how we can use Svelte actions to progressively
    enhance our elements.
  prefs: []
  type: TYPE_NORMAL
- en: We went through two different examples of progressive enhancements—enhancing
    a link to make it show a preview popup, and enhancing form elements to submit
    a form asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: In the past three chapters, we’ve seen three different patterns and use cases
    of Svelte actions, creating custom events, integrating UI libraries, and progressive
    enhancements. What you can do with Svelte actions is not limited to the three
    different use cases that we’ve discussed so far, but hopefully, these patterns
    have opened your imagination and made you see what is possible with Svelte actions.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are moving on to the next part of the book. We will be exploring
    Svelte context and stores from [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121)
    to [*Chapter 12*](B18887_12.xhtml#_idTextAnchor175), exploring their various use
    cases, such as in state management, creating renderless components, and using
    them for animations. We will start by defining and comparing Svelte contexts and
    Svelte stores in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Context and Stores'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will dive deep into Svelte’s two core features, Svelte context
    and Svelte stores. Over the five chapters, we will explore different scenarios
    for using Svelte context and stores. We’ll start our exploration by defining Svelte
    context and stores. This will be followed by a deep dive into implementing custom
    stores and strategies for managing application state using Svelte stores. Following
    that, we will learn how to use Svelte context to create a renderless component.
    Finally, we will learn how to create animations using Svelte stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18887_08.xhtml#_idTextAnchor121)*, Context versus Stores*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18887_09.xhtml#_idTextAnchor135)*, Implementing Custom Stores*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18887_10.xhtml#_idTextAnchor152)*, State Management with Svelte
    Stores*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18887_11.xhtml#_idTextAnchor163)*, Renderless Components*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18887_12.xhtml#_idTextAnchor175)*, Stores and Animation*s'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
