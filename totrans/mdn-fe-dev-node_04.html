<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-43" lang="en-GB"><a id="_idTextAnchor042"/>4</h1>
<h1 id="_idParaDest-44" lang="en-GB"><a id="_idTextAnchor043"/>Using Different Flavors of JavaScript</h1>
<p lang="en-GB">With the previous chapter, you’ve completed the essentials for doing projects in Node.js. Looking at real projects out there, you’ll find quickly that people use Node.js with all kinds of flavors of JavaScript. A <strong class="bold" lang="">flavor</strong> of <a id="_idIndexMarker112"/>JavaScript is a new language that can be seen as a variation of the official JavaScript language standard. Mostly, these flavors look very much like the JavaScript you are used to but differ in key parts. Sometimes, they add new language constructs to simplify certain tasks; sometimes, they bring improvements for reliability before releasing any code.</p>
<p lang="en-GB">In this chapter, we’ll learn how different flavors of JavaScript can be used with Node.js. We will introduce the most important tools and flavors. As far as the tooling part is concerned, we’ll introduce the popular open source <a id="_idIndexMarker113"/>package, <strong class="bold" lang="">Babel</strong>. This tool can be quite helpful to teach Node.js how to use a flavor of JavaScript. These flavors include interesting <a id="_idIndexMarker114"/>additions to the language <a id="_idIndexMarker115"/>such as <strong class="bold" lang="">Flow</strong> or <strong class="bold" lang="">TypeScript</strong>. Both introduce type systems, but the latter also adds new constructs to the language.</p>
<p lang="en-GB">This chapter will help you to use languages that can be converted to JavaScript with Node.js. Ultimately, this is key – not only to be able to run JavaScript files independent of their syntax with any version of Node.js but also to introduce additional safety and convenience in larger projects.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Integrating Babel</li>
<li lang="en-GB">Using Flow</li>
<li lang="en-GB">Using TypeScript</li>
</ul>
<h1 id="_idParaDest-45" lang="en-GB"><a id="_idTextAnchor044"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter04">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter04</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="http://bit.ly/3UeL4Ot">http://bit.ly/3UeL4Ot</a>.</p>
<h1 id="_idParaDest-46" lang="en-GB"><a id="_idTextAnchor045"/>Integrating Babel</h1>
<p lang="en-GB">In the <a id="_idIndexMarker116"/>last decade, JavaScript ascended from a simple scripting language to the most used programming language in the whole world. With the increased popularity, the language has also gotten a lot of interesting features. Unfortunately, it always takes a while until the latest features are made available in all implementations. The problem gets worse if we want to use the latest language features in old implementations anyway.</p>
<p lang="en-GB">This is a problem that has been known by frontend developers for years – after all, the version and variety of the browser used cannot be predetermined by the developer. Only the user makes this decision – and an older browser may not understand some of the modern features that the developer wants to use. In Node.js, we don’t have exactly the same problem – as we can theoretically decide the version of Node.js – but it can be a similar issue if Node.js does not have the latest language features or if we create tools that are supposed to run on other people’s machines.</p>
<p lang="en-GB">A nice way out of the language feature lockdown (that is, the restriction to only use the feature set supported by the engine) is to use a tool that understands the latest language specification and is capable of properly translating it into an older language specification. The process of such a programming language<a id="_idIndexMarker117"/> translation is called <strong class="bold" lang="">transpilation</strong>. The tool is <a id="_idIndexMarker118"/>called a <strong class="bold" lang="">transpiler</strong>.</p>
<p lang="en-GB">One of the most known transpilers for JavaScript is Babel. Its power lies in a rich plugin ecosystem. Actually, it is so easy to extend the JavaScript language with constructs using Babel, that many features were first introduced in Babel before they either became part of the official standard or a de facto standard. An example of the former is <code>async</code>/<code>await</code>, which is a fairly complex feature. An example of the latter<a id="_idIndexMarker119"/> is <strong class="bold" lang="">JSX</strong>, that is, the extension of JavaScript with <strong class="bold" lang="">XML</strong>-like constructs.</p>
<p lang="en-GB">The following code is using <code>async</code>/<code>await</code> and would be incompatible with Node.js before version <em class="italic" lang="">7.6.0</em>:</p>
<pre class="source-code" lang="en-GB">function wait(time) {
  return new Promise(resolve =&gt; setTimeout(resolve, time));
}
async function example() {
  console.log('Starting...');
  await wait(1000);
  console.log('1s later...');
  await wait(1000);
  console.log('2s later...');
  await wait(3000);
  console.log('Done after 5s!');
}
example();</pre>
<p lang="en-GB">If we <a id="_idIndexMarker120"/>want to make this compatible with older versions (or, in general, JavaScript engines that cannot handle the modern <code>async</code>/<code>await</code> syntax), then we can use Babel.</p>
<p lang="en-GB">There are three ways of transpiling the code with Babel:</p>
<ul>
<li lang="en-GB">We can use the <code>@babel/node</code> package, which is a thin wrapper around Node.js. Essentially, it will transpile the modules during execution – that is, when they are needed.</li>
<li lang="en-GB">The <code>@babel/cli</code> package can be used to transpile the modules beforehand and run Node.js on the transpiled modules.</li>
<li lang="en-GB">Alternatively, the <code>@babel/core</code> package can be used to programmatically control the transpilation process – that is, which modules are being transpiled and what is done with the results.</li>
</ul>
<p lang="en-GB">Each way has its own advantages and disadvantages. For instance, choosing <code>@babel/node</code> might be the easiest to get running, but will actually give us a small performance hit and some uncertainty. If some lesser-used module has a syntax problem, then we would only find out later when the module is used.</p>
<p lang="en-GB">Likewise, <code>@babel/cli</code> certainly hits the sweet spot between convenience and power. Yes, it only works with files, but that is what we want in almost all cases.</p>
<p lang="en-GB">One <a id="_idIndexMarker121"/>way to see very conveniently how Babel handles things is to use the interactive<a id="_idIndexMarker122"/> website located at <a href="https://babeljs.io/repl">https://babeljs.io/repl</a>. For our previous code example, which is using an <code>async</code> function with <code>await</code>, we get a view as shown in <em class="italic" lang="">Figure 4</em><em class="italic" lang="">.1</em>:</p>
<div><div><img alt="Figure 4.1 – Transpiling some JavaScript via Babel online " src="img/Figure_4.01_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Transpiling some JavaScript via Babel online</p>
<p lang="en-GB">For the screenshot shown in <em class="italic" lang="">Figure 4</em><em class="italic" lang="">.1</em>, we specified the version of Node.js to be <em class="italic" lang="">7.6</em>. Once we change that to something lower, for example, <em class="italic" lang="">7.5</em>, we get a different output. It all starts with some generated code:</p>
<pre class="source-code" lang="en-GB">"use strict";
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }</pre>
<p lang="en-GB">After the <a id="_idIndexMarker123"/>generated code, our own code is spat out. The crucial difference is that our code now uses the helpers from the preceding generated code:</p>
<pre class="source-code" lang="en-GB">function wait(time) {
  return new Promise(resolve =&gt; setTimeout(resolve, time));
}
function example() {
  return _example.apply(this, arguments);
}
function _example() {
  _example = _asyncToGenerator(function* () {
    console.log('Starting...');
    yield wait(1000);
    console.log('1s later...');
    yield wait(1000);
    console.log('2s later...');
    yield wait(3000);
    console.log('Done after 5s!');
  });
  return _example.apply(this, arguments);
}
example();</pre>
<p lang="en-GB">As you can see, the code was modified with the generated functions. In our case, those functions have been used to replace the standard <code>async</code>/<code>await</code> mechanism with a generator function using <code>yield</code>. But even that could be changed further when transpiling for Node.js before version <em class="italic" lang="">6.0</em>, which introduced support for generator functions.</p>
<p lang="en-GB">In any case, Babel<a id="_idIndexMarker124"/> is actually doing the hard work of figuring out which constructs are used in our code, and which constructs need to be replaced depending on the target version of Node.js. It also knows the proper replacements and can generate some boilerplate code to support the language constructs.</p>
<p lang="en-GB">For Babel to do all this work, it needs to understand the JavaScript language. This is done by <strong class="bold" lang="">parsing</strong> the source code. Parsing<a id="_idIndexMarker125"/> is a process that involves going over all characters, grouping them into so-called tokens (such as identifiers, numbers, etc.), and then putting these tokens in a tree-like structure known as an <strong class="bold" lang="">abstract syntax tree</strong> (<strong class="bold" lang="">AST</strong>). One tool to explore the AST <a id="_idIndexMarker126"/>as seen by Babel can be<a id="_idIndexMarker127"/> found at <a href="https://astexplorer.net/">https://astexplorer.net/</a>.</p>
<p class="callout-heading" lang="en-GB">Understanding ASTs</p>
<p class="callout" lang="en-GB">Much like processing HTML results in a tree of different nodes, any programming language actually resolves to a tree of expressions and statements. While statements such as a <code>for</code> loop form a closed block of instructions, expressions such as an addition will always return a value. The AST puts all of those in relation and integrates all provided information for the respective node types. For instance, an addition expression consists of two expressions that should be added together. Those could be any expression, for example, a simple literal expression such as a number token.</p>
<p lang="en-GB">A snippet of the AST of the preceding example can be seen in <em class="italic" lang="">Figure 4</em><em class="italic" lang="">.2</em>. Each node in the AST <a id="_idIndexMarker128"/>has <a id="_idIndexMarker129"/>an associated type (such as <code>AwaitExpression</code>) and a position in the source document:</p>
<div><div><img alt="Figure 4.2 – The AST Explorer shows the information as parsed by Babel " src="img/Figure_4.02_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The AST Explorer shows the information as parsed by Babel</p>
<p lang="en-GB">Equipped with this knowledge, we can now try to do something locally using <code>@babel/node</code>:</p>
<ol>
<li lang="en-GB">We start by creating a new Node.js project. In a new directory, run the following:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm init -y</strong></pre></li>
<li lang="en-GB">This will create a <code>package.json</code> and include some basic information. Afterwards, you can install the <code>@babel/node</code> and <code>@babel/core</code> packages as a development dependency:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install @babel/core @babel/node --save-dev</strong></pre></li>
<li lang="en-GB">Feel free to use another package manager for this. Once the installation has finished, we <a id="_idIndexMarker130"/>should add the script. Create a new <code>index.js</code> file <a id="_idIndexMarker131"/>with the following content:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          index.js</p>
<pre class="console" lang="en-GB">
let x = 1;

let y = 2;

// use conditional assignment – ES2021 feature

x &amp;&amp;= y;

console.log('Conditional assignment', x);</pre>
<p lang="en-GB">The code uses an <code>ES2021</code> feature called conditional assignments. Only if <code>y</code> is truthy will the assignment be done. In this case, we expect <code>x</code> to be <code>2</code> after the conditional assignment.</p>
<ol>
<li lang="en-GB" value="4">To run the code, we need to modify <code>package.json</code>. In the <code>scripts</code> section, we add a <code>start</code> field. Now, the <code>scripts</code> section should look like this:<pre class="console" lang="en-GB">
"scripts": {</pre><pre class="console" lang="en-GB">
  "start": "node index.js",</pre><pre class="console" lang="en-GB">
  "test": "echo \"Error: no test specified\" &amp;&amp; exit</pre><pre class="console" lang="en-GB">
    1"</pre><pre class="console" lang="en-GB">
}</pre></li>
<li lang="en-GB">At this point, we can conveniently run the script using <code>npm start</code>. For recent Node.js versions (<em class="italic" lang="">15</em> or later), the output should be as follows:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm start</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">&gt; example01@1.0.0 start</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">&gt; node index.js</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Conditional assignment 2</strong></pre></li>
<li lang="en-GB">However, if we <a id="_idIndexMarker132"/>try to run the code with Node.js <em class="italic" lang="">14</em>, we’ll get an error:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm start</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">&gt; example01@1.0.0 start /home/node/examples/example01</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">&gt; node index.js</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">/home/node/examples/example01/index.js:4</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">x &amp;&amp;= y;</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  ^^^</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">SyntaxError: Unexpected token '&amp;&amp;='</strong></pre></li>
</ol>
<p lang="en-GB">Now, if you want this to run, you can switch the <code>start</code> script of <code>package.json</code> to use <code>babel-node</code> instead of the standard <code>node</code>. Trying this, however, will not work. The reason is that, by default, Babel does not understand the current environment and, therefore, cannot apply the transformations.</p>
<ol>
<li lang="en-GB" value="7">For Babel to actually understand it, we need to use the <code>@babel/preset-env</code> package. This is a preset that represents a collection of plugins. In this case, the <code>env</code> preset is a special one that intelligently looks for the right plugins depending on the current environment. Let’s first install it:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install @babel/preset-env --save-dev</strong></pre></li>
<li lang="en-GB">Afterward, we can integrate it by creating a new file:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          .babelrc</p>
<pre class="console" lang="en-GB">
{

  "presets": [["@babel/preset-env"]]

}</pre>
<ol>
<li lang="en-GB" value="9">The file has to be placed next to <code>package.json</code>. Once there, Babel will automatically<a id="_idIndexMarker133"/> load the file and take its content as configuration input. Now the output matches our expectations:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm start</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">&gt; example01@1.0.0 start</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  /home/rapplf/Code/Articles/Node.js-for-Frontend-</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  Developers/Chapter04/example01</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">&gt; babel-node index.js</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Conditional assignment 2</strong></pre></li>
</ol>
<p lang="en-GB">With these instructions, you are now able to run modern code, even on older versions of Node.js. The preceding example did finally run in Node.js <em class="italic" lang="">14</em> – even though this version does not support the <code>&amp;&amp;=</code> new assignment operator.</p>
<p lang="en-GB">There are many different packages that work together with Babel. Full languages or language extensions have been written for Babel. One of those extensions is Flow.</p>
<h1 id="_idParaDest-47" lang="en-GB"><a id="_idTextAnchor046"/>Using Flow</h1>
<p lang="en-GB">Flow is <a id="_idIndexMarker134"/>mainly<a id="_idIndexMarker135"/> a <strong class="bold" lang="">static type checker</strong> for JavaScript code. The purpose of a static type checker is to ensure at build time that everything works together as it should. As a result, we should see a lot fewer errors at runtime. In fact, proper usage of a static type checker will essentially eliminate all simple bugs and let us focus on solving the algorithmic and behavioral issues that would arise anyway.</p>
<p lang="en-GB">In Flow, every JavaScript file can be changed to a Flow file. All that needs to be done is to introduce the <code>@flow</code> comment. A simple example is as follows:</p>
<pre class="source-code" lang="en-GB">// @flow
function square(n: number): number {
  return n * n;
}
square("2"); // Error!</pre>
<p lang="en-GB">Even though <a id="_idIndexMarker136"/>the code would work pretty well in standard JavaScript, Flow will help us by raising an error in the last line. The <code>square</code> function has been annotated using types for the <code>n</code> input argument and the return value. The colon notation separates the identifier or function head from the specified type.</p>
<p lang="en-GB">Since the colon notation is not part of the JavaScript standard, we cannot just run the preceding code. Instead, we can use Babel together with the <code>@babel/preset-flow</code> package to strip away the Flow type annotations – keeping only the JavaScript that Node.js can understand.</p>
<p lang="en-GB">Let’s test this with a new project:</p>
<ol>
<li lang="en-GB" value="1">We start in a new directory by initializing an <code>npm</code> project and installing the necessary development dependencies:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm init -y</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install @babel/core @babel/node @babel/preset-</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  flow --save-dev</strong></pre></li>
<li lang="en-GB">Now, we configure Babel and change the <code>package.json</code> file:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          .babelrc</p>
<pre class="console" lang="en-GB">
{

  "presets": ["@babel/preset-flow"]

}</pre>
<ol>
<li lang="en-GB" value="3">In <code>package.json</code>, we need to add a <code>start</code> field to the <code>scripts</code> section:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          package.json</p>
<pre class="console" lang="en-GB">
{

  "name": "example02",

  "version": "1.0.0",

  "scripts": {

    "start": "babel-node index.js"

  },

  "devDependencies": {

    "@babel/core": "^7.18.5",

    "@babel/node": "^7.18.5",

    "@babel/preset-flow": "^7.17.12"

  }

}</pre>
<p lang="en-GB">Now, running <code>npm start</code> should work without any error message. However, if we run <code>node index.js</code>, then we’ll actually face an error. Still, shouldn’t we also face an error in this case?</p>
<ol>
<li lang="en-GB" value="4">Well, as <a id="_idIndexMarker137"/>mentioned, the Babel part is only for running. The installed preset only understands and removes the type annotations. It does not do the actual type checking. For this, we need to install another package called <code>flow-bin</code>:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install flow-bin --save-dev</strong></pre></li>
<li lang="en-GB">We can run <code>flow</code> with the <code>npx</code> runner that comes already with <code>npm</code>. First, we initialize the project:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx flow init</strong></pre></li>
<li lang="en-GB">Then, we can type-check our solution:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx flow</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Launching Flow server for</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  /home/node/examples/example02</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Spawned flow server (pid=13278)</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Logs will go to /tmp/flow/example02.log</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Monitor logs will go to</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  /tmp/flow/example02.monitor_log</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Error <img alt="" src="img/011.png"/> index.js:6:8</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Cannot call square with "2" bound to n because string</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> [1] is incompatible with number [2]. [incompatible-</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> call]</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> [2] 2│ function square(n: number): number {</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">     3│   return n * n;</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">     4│ }</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">     5│</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> [1] 6│ square("2"); // Error!</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">     7│</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Found 1 error</strong></pre></li>
</ol>
<p lang="en-GB">As expected, the call <a id="_idIndexMarker138"/>does not satisfy the type checks. This is great for our own code, but it is even better for using third-party libraries. With type checking, we can be sure that we use the provided APIs correctly. Not only now but also in the future when we install an update for third-party libraries.</p>
<p lang="en-GB">Unfortunately, not every package comes with <code>flow</code>-type annotations. However, the situation looks a bit more promising for a quite similar tool called TypeScript.</p>
<h1 id="_idParaDest-48" lang="en-GB"><a id="_idTextAnchor047"/>Using TypeScript</h1>
<p lang="en-GB">TypeScript is a full<a id="_idIndexMarker139"/> programming language that was designed as a superset of JavaScript. The basic idea was to start with JavaScript, enhance it with missing parts such as types, classes, or enums, and choose JavaScript as a transpilation target for the language. Over the years, many of the features that were first introduced in the TypeScript language also made it to the JavaScript language.</p>
<p lang="en-GB">Today, TypeScript<a id="_idIndexMarker140"/> is the most popular way to write large-scale JavaScript projects. Nearly every package on the official <code>npm</code> registry comes with TypeScript-compatible type annotations – either within the package or in a dedicated package. As an example, the type annotations for the <code>react</code> package can be found in the <code>@</code><code>types/react</code> package.</p>
<p lang="en-GB">To use TypeScript, we need to install the <code>typescript</code> package. This contains the <code>tsc</code> script, which gives us the ability to check types and transpile TypeScript files written using the <code>.ts</code> or <code>.</code><code>tsx</code> extension.</p>
<p lang="en-GB">Let’s go ahead and create a new project, install <code>typescript</code>, and add a source file:</p>
<ol>
<li lang="en-GB" value="1">We start with the project creation. In a new directory, run the following:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm init -y</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install typescript --save-dev</strong></pre></li>
<li lang="en-GB">Let’s add an <code>index.ts</code> file with <a id="_idIndexMarker141"/>content similar to the example for Flow:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          index.ts</p>
<pre class="console" lang="en-GB">
function square(n: number): number {

  return n * n;

}

square("2"); // Error!</pre>
<p lang="en-GB">The content of the file is pretty much the same as beforehand, however, the <code>@flow</code> comment is missing.</p>
<ol>
<li lang="en-GB" value="3">We can now run this directly via the <code>tsc</code> command, which has been installed together with the <code>typescript</code> package:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx tsc index.ts</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">index.ts:5:8 - error TS2345: Argument of type 'string'</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  is not assignable to parameter of type 'number'.</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">5 square("2"); // Error!</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">         ~~~</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Found 1 error in index.ts:5</strong></pre></li>
</ol>
<p lang="en-GB">In comparison<a id="_idIndexMarker142"/> to the <code>flow</code> tool, <code>tsc</code> does a bit more. It does not only do the type checking but it will also produce output files. What it does not do is run the code. The immediate evaluation functionality of <code>@babel/node</code> can be found in the <code>ts-node</code> package, which works quite similarly to its Babel counterpart.</p>
<ol>
<li lang="en-GB" value="4">By default, <code>tsc</code> tries to convert a <code>.ts</code> or <code>.tsx</code> input file to some new files: a <code>.js</code> and <code>.d.ts</code> file. Even in the case of failed type checks, these files might be produced. The <code>.js</code> file will be written by default, that is, with every use of <code>tsc</code>, unless we tell TypeScript to not emit the output. The <code>.d.ts</code> file will only be written if we also enable the creation of declarations. Looking at the directory after we’ve run the previous example will reveal two new files:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ ls -l</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">-rw-r--r-- 1   64 index.js</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">-rw-r--r-- 1   79 index.ts</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">drwxr-xr-x 4 4096 node_modules</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">-rw-r--r-- 1  387 package-lock.json</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">-rw-r--r-- 1  278 package.json</strong></pre></li>
<li lang="en-GB">Having the additional JavaScript is needed to actually run the code. This also applies to TypeScript being written for the browser. Since no browser understands TypeScript code, we need to transpile it to JavaScript beforehand. Like Babel, we can actually transpile for different versions of the JavaScript standard.</li>
<li lang="en-GB">In <a id="_idIndexMarker143"/>order to keep your code repository clean, you should not use TypeScript as shown earlier. Instead, a much better way is to introduce a <code>tsconfig.json</code> file, which you should place adjacent to the <code>package.json</code>. This way, you can not only properly define the target JavaScript version but also a destination directory where the transpilation output should be placed. The destination directory can then be ignored in your version <a id="_idIndexMarker144"/>control system:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          tsconfig.json</p>
<pre class="console" lang="en-GB">
<strong class="bold" lang="">{</strong>
<strong class="bold" lang="">  "compilerOptions": {</strong>
<strong class="bold" lang="">    "target": "es6",</strong>
<strong class="bold" lang="">    "outDir": "./dist"</strong>
<strong class="bold" lang="">  },</strong>
<strong class="bold" lang="">  "include": [</strong>
<strong class="bold" lang="">    "./src"</strong>
<strong class="bold" lang="">  ],</strong>
<strong class="bold" lang="">  "exclude": [</strong>
<strong class="bold" lang="">    "node_modules"</strong>
<strong class="bold" lang="">  ]</strong>
<strong class="bold" lang="">}</strong></pre>
<p lang="en-GB">In the configuration, we indicated an <code>src</code> directory as the root for the transpilation. Every <code>.ts</code> and <code>.tsx</code> file inside will be transpiled. The output will be available in the <code>dist</code> directory.</p>
<ol>
<li lang="en-GB" value="7">Now, you<a id="_idIndexMarker145"/> can just move <code>index.ts</code> inside a new <code>src</code> subfolder and try running <code>tsc</code> again. The same error pops up, but instead of creating the <code>index.js</code> adjacent to the <code>index.ts</code> file, the output would appear in the <code>dist</code> folder:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx tsc</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">src/index.ts:5:8 - error TS2345: Argument of type</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  'string' is not assignable to parameter of type</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  'number'.</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">5 square("2"); // Error!</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">         ~~~</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">Found 1 error in src/index.ts:5</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">$ ls -l dist/</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">-rw-r--r-- 1   64 index.js</strong></pre></li>
</ol>
<p lang="en-GB">Today, most libraries that are published on the public <code>npm</code> registry will be created using TypeScript. This not only prevents some unnecessary bugs but also makes the experience for consumers of the library much better.</p>
<h1 id="_idParaDest-49" lang="en-GB"><a id="_idTextAnchor048"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned how to use different flavors of JavaScript with Node.js. You have seen how Babel can be installed, configured, and used to transpile your code to the JavaScript standard supported by the target version of Node.js.</p>
<p lang="en-GB">Right now, you should also know the basics of the most important JavaScript flavors: Flow and TypeScript. We discussed how they can be installed and configured. Of course, to practically use these flavors, you’ll need additional material to learn their syntax and master the concepts behind these languages. A good book to learn TypeScript is <em class="italic" lang="">Mastering TypeScript</em> by <em class="italic" lang="">Nathan Rozentals</em>.</p>
<p lang="en-GB">In the next chapter, we will discuss a quite important area of tooling – applications that can give our code improved consistency and validation.</p>
</div>
</body></html>