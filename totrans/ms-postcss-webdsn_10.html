<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Building a Custom Processor"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Building a Custom Processor</h1></div></div></div><p>One of the key benefits of using PostCSS is its modular approach—we're not forced to use a large library, particularly if we only need to make use of a small part of its functionality! In this chapter, we'll pull together some of the themes we've discussed throughout earlier chapters, and create a fully working preprocessor, customized to our needs.</p><p>We'll use it to compile code for a simple site, explore using it for CMS systems such as WordPress, then take a look at extending it to work with frameworks such as CSStyle. We will cover a number of topics throughout this chapter, which will include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating our processor</li><li class="listitem" style="list-style-type: disc">Optimizing the output</li><li class="listitem" style="list-style-type: disc">Adding source map and vendor prefix support</li><li class="listitem" style="list-style-type: disc">Testing the final preprocessor on a simple site system</li><li class="listitem" style="list-style-type: disc">Extending our preprocessor to use the CSStyle framework</li></ul></div><p>Let's make a start!</p><div class="section" title="Creating your processor"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>Creating your processor</h1></div></div></div><p>Many developers who work <a id="id607" class="indexterm"/>with existing processors such as SASS, less, or Stylus will be accustomed to working with a library that is a necessary dependency, and where it is unlikely that they will be using 100% of the functionality available for their chosen processor.</p><p>This is not the case with PostCSS. One of the key attractions is its flexibility; gone are the days when we have excess baggage in our processor that is redundant for our needs! The power of flexibility can also be a shortcoming, where does one start deciding what to include in our processor, I hear you ask?</p><p>Throughout the course of this chapter, we will bring together the various elements of the processor we've used in the demos, and work through changes we can make to improve or extend functionality. The key, though, to any processor is that there is no right or wrong answer; each will be different, and they will depend on your requirements.</p><p>As time goes by, it is<a id="id608" class="indexterm"/> likely that you will find common elements that can be reused between projects, ultimately, it is up to you as the developer to find the combination that meets your requirements. This aside, let's begin with a detailed look at the processor we've used in recent examples, and explore some of the ideas and tips we can use to create our own version.</p></div></div>
<div class="section" title="Exploring our processor"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec81"/>Exploring our processor</h1></div></div></div><p>As part of creating the <a id="id609" class="indexterm"/>demos we've worked through in this book, we concentrated on ensuring plugins are installed, and that we have the right files in the right place. There is something missing though, and that is—what actually happens in the files? Why do we have tasks in a particular order? What is the reasoning behind choosing some of the plugins that we've used…and so on—you get the idea!</p><p>Over the next few pages, we're going to try to answer some of these questions (and more), by exploring the processor that we've used in some of the recent examples; you will see that there isn't a one-answer-fits-all approach, but more a case of working through your requirements, and picking plugins to suit your needs.</p><p>Before we go into depth, though, let's just quickly recap the make-up of our processor, starting with the <code class="literal">package.json</code> file.</p><div class="section" title="Dissecting the package.json file"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec100"/>Dissecting the package.json file</h2></div></div></div><p>The <code class="literal">package.json</code> file tells <a id="id610" class="indexterm"/>PostCSS which plugins to use, and may contain some of the key configuration settings to be used during compilation:</p><div class="informalexample"><pre class="programlisting">{
  "name": "postcss",
  "version": "1.0.0",
  "description": "Configuration file for PostCSS",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "Alex Libby",
  "license": "ISC",
  "dependencies": { "postcss": "^5.0.8" },</pre></div><p>The top half of our processor contains a number of key properties that tell us details such as the version, description, who created it, any dependencies, and the license being used for the project:</p><div class="informalexample"><pre class="programlisting">  "devDependencies": {
    "autoprefixer": "^6.0.3",
    "cssnano": "^3.2.0",
    "gulp": "^3.9.0",
    "gulp-postcss": "^6.0.0",
    "gulp-rename": "^1.2.2",
    "gulp-sourcemaps": "^1.5.2",
    "postcss-reporter": "^1.3.0",
    "stylelint": "^2.3.7"
  }
}</pre></div><p>In comparison, the key part for us is in the bottom half; this lists all of the plugins that will be used within<a id="id611" class="indexterm"/> our project. In many of our projects, we've installed the plugin—at point of installation, the plugin will add an entry into this file that contains the name and the minimum version required (represented by the <code class="literal">^</code> symbol).</p><p>It is worth noting that we can manually add entries to, or remove entries from this file, or even copy <code class="literal">package.json</code> files from one project to another if needed. This is particularly useful if we know that a new project has identical (or very similar) requirements to an existing one; plugins will only add an entry into this file at installation, if one does not already exist.</p></div><div class="section" title="Exploring the Gulp task file"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec101"/>Exploring the Gulp task file</h2></div></div></div><p>The <code class="literal">gulpfile.js</code> file is where the real magic happens—this contains all of the tasks that need to be performed on<a id="id612" class="indexterm"/> each style sheet within our project. Outside of the style sheet, this is the second of two files that we've simply copied across from the code download to our project area. Now that we've been using it in anger, it's worth taking a moment to explore what happens in more detail.</p><p>The <code class="literal">gulpfile.js</code> file is made up of several sections—in our example, we begin with a list of variables that define references to each of our plugins:</p><div class="informalexample"><pre class="programlisting">'use strict';

var gulp = require('gulp');
var postcss = require('gulp-postcss');
//var autoprefixer = require('autoprefixer');
var cssnano = require('gulp-cssnano');
var sourcemaps = require('gulp-sourcemaps');
var rename = require('gulp-rename');
var stylelint = require('stylelint');
var reporter = require('postcss-reporter');
var rucksack = require('rucksack-css');</pre></div><p>The first task in our list is the most important one—this picks up and compiles the source code into a valid <a id="id613" class="indexterm"/>CSS file and deposits it in the <code class="literal">dest</code> folder. As part of this, we provide links to any PostCSS plugin that is needed to transform our code—in this example, we're using Rucksack, set to include fallback support but not add vendor prefixes:</p><div class="informalexample"><pre class="programlisting">gulp.task('styles', function () {
  return gulp.src('src/*.css')
    .pipe(postcss([ rucksack({ fallbacks: true, autoprefixer: true }) ]))
    .pipe(gulp.dest('dest/'));
});</pre></div><p>This chunky task is less complicated than it looks—it checks our code for consistency, based on the rules set; it outputs any warnings or errors on screen using the reporter plugin. The key here is the <code class="literal">['styles']</code> attribute—this tells PostCSS not to perform this task until the styles task has been completed:</p><div class="informalexample"><pre class="programlisting">gulp.task("lint-styles", ['styles'], function() {
    return gulp.src("dest/*.css")
    .pipe(postcss([ stylelint({
        "rules": {
          "color-no-invalid-hex": 2,
          "declaration-colon-space-before": [2, "never"],
          "indentation": [2, 2],
          "number-leading-zero": [2, "always"]
        }
      }),
      reporter({ clearMessages: true, })
    ]))
});</pre></div><p>In comparison, the next two tasks are relatively straightforward—this one takes care of compressing our compiled code, and renaming it with a <code class="literal">.min.css</code> extension:</p><div class="informalexample"><pre class="programlisting">gulp.task('rename', ['lint-styles'], function () {
  return gulp.src('dest/*.css')
    .pipe(postcss([ cssnano() ]))
    .pipe(rename('style.min.css'))
    .pipe(gulp.dest("dest/"));
});</pre></div><p>This task is equally straightforward—it creates a source map of our style sheet, and sets it in a format that PostCSS can release into a file within the <code class="literal">dest</code> folder of our project area:</p><div class="informalexample"><pre class="programlisting">gulp.task('sourcemap', ['rename'], function () {
  return gulp.src('dest/*.css')
    .pipe(sourcemaps.init())
    .pipe(sourcemaps.write('maps/'))
    .pipe(gulp.dest("dest/"));
});</pre></div><p>The last two steps play the most important role in any Gulp task file—the first will fire off calls to each of our tasks if we enter <code class="literal">gulp</code> in a command line prompt:</p><div class="informalexample"><pre class="programlisting">gulp.task('default', ['styles', 'lint-styles',  'rename', 'sourcemap']);</pre></div><p>This task, although<a id="id614" class="indexterm"/> not obligatory, watches out for any changes to our code and sets off the tasks in our Gulp file automatically. It will respect any constraints set, although for consistency, it is preferable to list the tasks being performed in the same order as they are shown in the file:</p><div class="informalexample"><pre class="programlisting">var watcher = gulp.watch('src/*.css', ['styles',
'lint-styles', 'rename', 'sourcemap']);
watcher.on('change', function(event) {
  console.log('File ' + event.path + ' was ' +
event.type + ', running tasks...');
});</pre></div><p>There is more to the compilation process than these two files—thought should also be given to how we structure our working environment. A quick look at the Gulp task file should reveal that we've used a simple in-tray/out-tray approach; code is picked up from the <code class="literal">src</code> folder, and the results placed into the <code class="literal">dest</code> folder at the end of compilation.</p><p>This is an important part of the process—after all, there is no benefit in using PostCSS if we don't give any thought to the structure of our project area! Part of this is to maintain separation between source and compiled files, but also that we may decide to expand our compilation process to include tasks such as shrinking images. There is no right or wrong in how this area should be structured—this will be dictated by our project requirements.</p></div></div>
<div class="section" title="Dissecting issues with our processor"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec82"/>Dissecting issues with our processor</h1></div></div></div><p>With a Gulp task file <a id="id615" class="indexterm"/>and associated <code class="literal">package.json</code> file in place, we should be good to go, right? Well, not quite—yes, our processor has been used on demos<a id="id616" class="indexterm"/> throughout the book to great effect. But there is more that we can do: our Gulp file should never be static; we should always look to review it periodically, to ensure it is working at optimal efficiency.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>To see an updated version of our Gulp file, take a look in the <code class="literal">T49 – fixing issues in Gulpfile</code> folder within the code download that accompanies this book.</p></div></div><p>Our Gulp file does<a id="id617" class="indexterm"/> have a few issues we need to address, so let's look at these now:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some of our tasks are not correctly named—for example, the styles task could be renamed to better reflect that we're using Rucksack in this task.</li><li class="listitem" style="list-style-type: disc">There is a question about the use of source maps; so far we've used a dedicated source map plugin to create them. An upcoming change in Gulp 4 will reduce the need for a plugin—support for creating them is being added to Gulp core, so a separate plugin won't be required so often!</li><li class="listitem" style="list-style-type: disc">In the rename task, we've hard-coded a <code class="literal">style.min.css</code> filename as the output; this isn't going to suit all requirements, so we should change this to make it dynamic.</li><li class="listitem" style="list-style-type: disc">Staying with the rename task—we're combining two tasks, when they should be split into two separate processes.</li><li class="listitem" style="list-style-type: disc">Take a look at the processor list within the styles task at line 16; this isn't too bad now, but over time it could become long and awkward to read! Instead, we need to change it so that at the point of calling PostCSS, we can use an array instead to provide the names.</li><li class="listitem" style="list-style-type: disc">When creating source maps, our current setup provides both a full fat and minified version; is this really necessary? The issue comes from <code class="literal">cssnano</code>, which is compressing every <code class="literal">.css</code> file it sees; this isn't necessary, so needs to be changed.</li><li class="listitem" style="list-style-type: disc">The use of <code class="literal">cssnano</code> that should be run as a task within PostCSS is causing issues—even though it would make sense to run it this way, it needs to be run independently, to satisfy our needs.</li><li class="listitem" style="list-style-type: disc">We should make a decision on whether we use a dedicated plugin for providing vendor prefix support, or rely on the use of other plugins that may have this built in already.</li><li class="listitem" style="list-style-type: disc">When compiling source files, our processor is producing two minified files; one is correctly named, but the other is meant to be the uncompressed version for development purposes.</li></ul></div><p>Over the next few pages, we will explore ways of fixing and improving our Gulp task file—it's key to understand that whilst many of these changes are specific to our task file, they are ones that may crop up for your future projects. Above all, it is essential that we should continually review our production process to ensure it is working as needed.</p><p>Let's begin the process of fixing and improving our Gulp file before we put it to test on a sample site.</p><div class="section" title="Fixing our Gulp task file"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec102"/>Fixing our Gulp task file</h2></div></div></div><p>It has to be said that there are a few issues we need to resolve—the key here is that none of them will stop our <a id="id618" class="indexterm"/>compilation process; we should consider them more as rough edges on a diamond, which need polishing to make our process sparkle (pun intended!).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>Please note, the line numbers in the next exercise refer to the <span class="emphasis"><em>unmodified version</em></span> of the source code from the <code class="literal">T48 – existing processor</code> folder, prior to making any changes. If you want to keep existing copies of files, please move them prior to starting the exercise.</p></div></div><p>Okay, let's get cracking: there are a few changes to make, so we will start with the key task, which compiles the source file:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For this process, we need a copy of the <code class="literal">gulpfile.js</code> file from the <code class="literal">T48 – existing processor</code> folder within the code download that accompanies this book; go ahead and save it as <code class="literal">gulpfile.js</code> at the root of our project area.</li><li class="listitem">The first change we need to make is to enable <code class="literal">autoprefixer</code> support in the file—you should find it there but commented out on line 5; go ahead and remove the comment.</li><li class="listitem">On or around line 16, look for this line:<div class="informalexample"><pre class="programlisting">.pipe(postcss([ rucksack({ fallbacks: true, autoprefixer: true }) ]))</pre></div><p>We're not going to include fallback support, and will take care of <code class="literal">autoprefixer</code> separately, so for now, alter it as shown:</p><div class="informalexample"><pre class="programlisting">.pipe(postcss([ rucksack(), autoprefixer() ]))</pre></div></li><li class="listitem">Our next change is in the lint-styles task—two changes are required here; first, add this block at line 13, below the declaration for Rucksack:<div class="informalexample"><pre class="programlisting">var stylerules = {
  "color-no-invalid-hex": 2,
  "declaration-colon-space-before": [2, "never"],
  "indentation": [2, 2],
  "number-leading-zero": [2, "always"]
};</pre></div></li><li class="listitem">Next, go ahead and replace the entire lint-styles task with this:<div class="informalexample"><pre class="programlisting">gulp.task('lint', ['styles'], function() {
  return gulp.src("dest/*.css")
    .pipe(postcss([ stylelint({ "rules": stylerules }), 
    reporter({ clearMessages: true })
  ]))
});</pre></div></li><li class="listitem">In the rename task, we have three changes to make—first, remove the <code class="literal">cssnano</code> line at line 38; we're splitting the task into two, and this will be handled in a new task.</li><li class="listitem">This task has a prerequisite, which we've renamed—go ahead and change line 36 to this:<div class="informalexample"><pre class="programlisting">gulp.task('rename', ['lint'], function () {</pre></div></li><li class="listitem">Next, alter the <a id="id619" class="indexterm"/>rename command as indicated—this is on line 39:<div class="informalexample"><pre class="programlisting">.pipe(rename(<span class="strong"><strong>renameFunction</strong></span>))</pre></div></li><li class="listitem">In the next task, <code class="literal">sourcemap</code>, we have one alteration to make—on or around line 47, change this line as shown:<div class="informalexample"><pre class="programlisting">gulp.task('sourcemap', ['rename'], function () {
  return gulp.src(<span class="strong"><strong>sourceMapLocation</strong></span>)</pre></div></li><li class="listitem">We've talked about splitting out the minification task—go ahead and add this below the <code class="literal">sourcemap</code> task:<div class="informalexample"><pre class="programlisting">gulp.task('minifyCSS', ['sourcemap'], function () {
  return gulp.src('dest/*.min.css')
    .pipe(cssnano({ autoprefixer: false }))
    .pipe(gulp.dest("dest/"));
});</pre></div></li><li class="listitem">We've made changes to the task names, so we need to update the default task and watch facility—look for the string of names in square brackets on or around lines 50 and 52. Replace it with this string:<div class="informalexample"><pre class="programlisting">['styles', 'lint' , 'rename' , 'sourcemap', 'minifyCSS']</pre></div></li><li class="listitem">Our watch task can also be put on a diet—there is no need to specify all of the tasks twice! Instead, go ahead and change the code as indicated—when changes are made, the watch facility will run the default task, which already has the requisite tasks:<div class="informalexample"><pre class="programlisting">gulp.task('default', ['styles', 'lint' , 'rename' , 'minifyCSS', 'sourcemap']);

var watcher = gulp.watch('src/*.css', ['default']);
watcher.on('change', function(event) {</pre></div></li><li class="listitem">We're almost done—there are some additional declarations we need to add at the top of our file, to ensure everything works as expected. Below the <code class="literal">stylerules</code> declaration added in step <span class="emphasis"><em>4</em></span>, go ahead and add these extra lines:<div class="informalexample"><pre class="programlisting">var renameFunction = function (path) {
  path.extname = ".min.css";
  return path;
};

var sourceMapLocation = ['dest/*.css', '!dest/*.min.css'];</pre></div></li></ol></div><p>We now have an <a id="id620" class="indexterm"/>updated Gulp task file—we now need to copy the <code class="literal">style.css</code> from the <code class="literal">src</code> folder under <code class="literal">T49 – fixing issues in Gulpfile</code> to the <code class="literal">src</code> folder at the root of our project area. If all is well, we should have something akin to this in the <code class="literal">dest</code> folder of our project area when we compile our file, and a file named <code class="literal">style.css.map</code> in the maps folder:</p><div class="mediaobject"><img src="graphics/BO5194_10_01.jpg" alt="Fixing our Gulp task file"/></div><p>At this point, I am sure you will have a few questions about some of the changes we've made—the demo highlights a few key points, so it's worth taking time out to explore these in more detail.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>If you come across any issues with changing the gulp file, then check out a completed version in the <code class="literal">T49 - fixing issues in Gulpfile</code> folder in the code download that accompanies this book.</p></div></div></div><div class="section" title="Understanding the changes made"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec103"/>Understanding the changes made</h2></div></div></div><p>Throughout the <a id="id621" class="indexterm"/>course of our demo, we made a number of changes to our Gulp task file—the key thing to note is that none of them are compulsory. Our task file worked perfectly well prior to making the changes, so if they aren't compulsory, why are we making them?</p><p>The answer to this is simple—using a task runner such as Gulp is about automating processes so that you arrive at just the content you need. We had that, but the task runner produced extra files, didn't compress them as expected, and our Gulp file contained tasks that had multiple steps within the same task. The work we completed was about adding polish to the process—although our Gulp task file worked, we explored how we could improve on it by tweaking some of the processes.</p><p>We kicked off with<a id="id622" class="indexterm"/> changes to how vendor prefixes were added—our existing task completed this as part of compiling using the Rucksack plugin. The Rucksack plugin was to provide fallback support—I'm not a fan of working with older browsers, so we don't need it. This makes it less beneficial to incorporate vendor prefix support from such a large plugin, thus support is not enabled.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>There is another plugin available <a id="id623" class="indexterm"/>for PostCSS that handles vendor prefixes—<code class="literal">doiuse</code>, available at <a class="ulink" href="https://github.com/anandthakker/doiuse">https://github.com/anandthakker/doiuse</a>. Just another option to try!</p></div></div><p>The lint-styles task worked well—the changes we made focus on making the code easier to read in the task file. We moved the configuration block to the start of the file, and rearranged the format of the task; this means that we should not have to change the task, even though we may change the configuration!</p><p>Most of the remaining changes focus on splitting multiple roles into single tasks, and correcting some anomalies in the output. Our compilation process produced a minified file with the right extension, but also minified the original source file. We also had two source map files produced in a similar fashion—this is clearly not ideal! The changes we made now mean that our original source file is not minified, but only one minified file is produced, and that we have a single uncompressed style sheet created during the process.</p><p>Perfect, we now have a polished compilation process, which is producing the right files at the appropriate point; what next? Well, we can now add additional functionality to our compilation process. Using a task runner such as Gulp is about automating menial tasks, so let's explore what we might achieve in more detail.</p></div></div>
<div class="section" title="Optimizing the output"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec83"/>Optimizing the output</h1></div></div></div><p>The PostCSS<a id="id624" class="indexterm"/> system will quite happily play nicely with other plugins, be they Gulp-based, or using another task runner such as Grunt or Broccoli. This opens up a real world of possibilities, limited only by your imagination! There is one small but important point, though—it makes it crucial that we not only optimize our processor output (as we have done), but also fine tune it to ensure that we've added functionality that suits our needs.</p><p>So, what can we add? Well, here's a starter for ten: how about compressing images? Another common task relates to adding responsive content—we've already covered this earlier in the book with the <code class="literal">postcss-responsive-type</code> plugin. We could take that further, by adding a task that resizes images automatically to different sizes; we can then use these as appropriate in a responsive site.</p><p>Ultimately, it is up<a id="id625" class="indexterm"/> to you—as time goes by and you get more accustomed to using PostCSS, then it is likely that you will find yourself using some plugins more than others. The key here, though, is <span class="emphasis"><em>not</em></span> about simply adding in plugins haphazardly—instead, we're looking for plugins that we would use regularly in our development workflow, and can form the basis of a baseline processor. Any additional functionality that is needed to support a particular project can then be added at the appropriate time.</p><p>A great place to look is<a id="id626" class="indexterm"/> the PostCSS plugin directory at <a class="ulink" href="http://postcss.parts">http://postcss.parts</a>—it's worth taking a look to see what is there, and giving them a try! To get us started, we're going to work through a few ideas that are likely to be useful additions to your processor, beginning with improving support for source maps.</p><div class="section" title="Altering our source map support"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec104"/>Altering our source map support</h2></div></div></div><p>If we take a look back at <a id="id627" class="indexterm"/>our gulp file prior to completing the exercise in <span class="emphasis"><em>Fixing our gulp task file</em></span>, we can see it worked, but it suffered from a major drawback. The compilation process produced an extra source map which was minified by name, but not in reality! This is clearly something we didn't need—the changes made to this task transformed it into what we have now:</p><div class="informalexample"><pre class="programlisting">var sourceMapLocation = ['dest/*.css', '!dest/*.min.css'];
...
gulp.task('sourcemap', ['rename'], function () {
  return gulp.src(sourceMapLocation)
...
});</pre></div><p>This is a much better version—it only produces one source map file, which is not compressed; compression is not needed. That being said, we can still improve on it; it's simply a matter of working through the documentation to really explore what is available, and see if it can help us. As a starter, try this for size.</p><p>There may be instances where we need control over the full URL when compiling our code and creating the source map, for example, if we're transferring from a test environment to a production one. In an ideal world, we would use a relative file structure to avoid this issue, but for those occasions where this isn't possible, a simple change to our Gulp task will suffice:</p><div class="informalexample"><pre class="programlisting">    .pipe(sourcemaps.write('maps/', {
      sourceMappingURLPrefix: 'https://www.mydomain.com/'
    }))</pre></div><p>We can see the result in this screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_10_02.jpg" alt="Altering our source map support"/></div><p>Ultimately, the requirements for our projects will determine how source map support needs to be configured—we may even have to go as far as compiling multiple files into one larger master file, if our project requirements dictate.</p><p>There's one<a id="id628" class="indexterm"/> thing to bear in mind, though—there are plans to include native source map support in Gulp 4; this will likely mean that the need for a separate plugin will become redundant. It pays to keep abreast of changes, particularly if it might affect our processor!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>For a completed version of our Gulp file, which includes these changes, take a look at the <code class="literal">T50 - adjusting source map settings</code> folder in the code download that accompanies this book.</p></div></div><p>Let's change tack at this point, changing the source map compilation process was a straightforward alteration. We can take it up a notch with another key area—vendor prefixes. We've already covered the basics, so we'll take a look at how we can improve support.</p></div><div class="section" title="Taking care of prefixes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec105"/>Taking care of prefixes</h2></div></div></div><p>Aha, prefixes! The bane<a id="id629" class="indexterm"/> of any designer: adding them and keeping them up to date can be a real chore.</p><p>The <code class="literal">autoprefixer</code> task that has already featured throughout these pages goes some way to reducing the burden: it will add the current prefixes and remove any that are no longer needed. This is good…but we can do better! This time around, though, the emphasis is less on code, and more on the kinds of decisions we need to make:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What browser <a id="id630" class="indexterm"/>versions do you need to support? The <code class="literal">autoprefixer</code> plugin already uses data from <a class="ulink" href="http://caniuse.com/">http://caniuse.com/</a>, which is sufficient for most requirements. However, we can tweak our code to use Browserslist (hosted at <a class="ulink" href="https://github.com/ai/browserslist">https://github.com/ai/browserslist</a>) to determine which versions to support. For example, we might add <span class="emphasis"><em>&gt; 5%</em></span> to limit support to browsers which have over <span class="emphasis"><em>5%</em></span> of global use:<div class="informalexample"><pre class="programlisting">.pipe(postcss([ rucksack(), autoprefixer({browsers: ['last 2 versions']}) ])</pre></div><p>In an ideal world, I would push that as high as 10%, but that might be taking it too far!</p></li><li class="listitem" style="list-style-type: disc">From a consistency perspective, we should make it clear that <code class="literal">autoprefixer</code> is <code class="literal">disabled</code> from within Rucksack—my preference is not to enable it there, as it can get confusing as to which plugin is adding prefixes (given that <code class="literal">cssnano</code> can add them too). To correct this, all we need to do is to change this line:<div class="informalexample"><pre class="programlisting">.pipe(postcss([ rucksack({autoprefixer: false  }),
 autoprefixer({browsers: ['last 2 versions']}) ])</pre></div></li></ul></div><p>It's not obligatory, but it at least makes it clear! If we wanted to be real purists, we would split this task into two separate ones, so that we're keeping to the one task: one role mantra:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Although <code class="literal">autoprefixer</code> handles the removal of redundant prefixes, there is a useful trick<a id="id631" class="indexterm"/> we can use: add support for the <code class="literal">postcss-remove-prefixes</code> and <code class="literal">postcss-unprefix</code> plugins. The reason for this is simple—we may well not have a level playing field when running <code class="literal">autoprefixer</code>, where some vendor prefixes may be missing from our code. Adding these two plugins ensures that our code is as terse as possible prior to running <code class="literal">autoprefixer</code>.</li><li class="listitem" style="list-style-type: disc">If our code is based on using SASS, then there is a good chance that the Compass library is being used—it is worth checking to see if this is being used to add vendor prefixes. If it is, it may be worth switching to using <code class="literal">autoprefixer</code>, as it is reported to be more efficient at removing code. Don't forget that we can compile SASS code within our Gulp file at the same time as running PostCSS plugins—we will explore more of this later in this book.</li></ul></div><p>It goes without saying that vendor prefixes continually change; with careful planning and the right use of plugins, we can be safe in the knowledge that no matter what happens, our code will be updated at the next compilation.</p><p>Now, moving on: I am sure you are familiar with the ubiquitous pseudo-selector, such as hover. This is one area where we need to carefully consider what we might incorporate into our baseline processor; PostCSS has a number of plugins that can facilitate handling pseudo-selectors in our code. Let's take a look at this in more detail.</p></div><div class="section" title="Adding support for pseudo-selectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec106"/>Adding support for pseudo-selectors</h2></div></div></div><p>When designing sites, pseudo-selectors are a key part of providing interaction—they can be anything from the simple hover, all the way through to newer elements such as :range or :placeholder. We<a id="id632" class="indexterm"/> also have to be mindful of support—thankfully most elements will work in reasonably recent browsers (yes, even IE8!), but not all browsers use the same format of single or double colons when referencing the selector in CSS.</p><p>To help with both styling and providing consistency, PostCSS has a number of options we can use; we will explore using the <code class="literal">postcss-pseudo-elements-content</code> plugin in a moment, but for now, let's take a quick look at some of the options to give you a flavor of what is available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Do you often find yourself adding the <code class="literal">focus</code> pseudo-selector to your code? If the answer is yes, then the<a id="id633" class="indexterm"/> <code class="literal">postcss-focus</code> plugin will be of interest. Available from <a class="ulink" href="https://github.com/postcss/postcss-focus">https://github.com/postcss/postcss-focus</a>, this plugin will add a <code class="literal">focus</code> pseudo-selector automatically, when compiling code. The styles will be the same as the <code class="literal">:hover</code> element.</li><li class="listitem" style="list-style-type: disc">We've just talked about adding a <code class="literal">focus</code> element automatically—the developer Jonathan Neal had the idea of creating a polyfill to add support for an <code class="literal">:enter pseudo-selector</code>, which would replace both :hover and :focus within code. When<a id="id634" class="indexterm"/> compiled, the code would transpile any instance of <code class="literal">:enter</code> into <code class="literal">:hover</code> and <code class="literal">:active</code> styles in our code. Head over to <a class="ulink" href="https://github.com/jonathantneal/postcss-pseudo-class-enter">https://github.com/jonathantneal/postcss-pseudo-class-enter</a> for more details on this plugin.</li><li class="listitem" style="list-style-type: disc">This next plugin could be<a id="id635" class="indexterm"/> euphemistically described as being one for those who have better things to do than write styles for links…. In plain speak, this is a real shortcut of a plugin! It adds styles for <span class="emphasis"><em>all</em></span> of the link-related classes automatically; browse to <a class="ulink" href="https://github.com/jedmao/postcss-all-link-colors">https://github.com/jedmao/postcss-all-link-colors</a> for an example of how to be really lazy…</li><li class="listitem" style="list-style-type: disc">For those of you who<a id="id636" class="indexterm"/> regularly have to style form buttons (and face it, who doesn't?), then this next plugin from <a class="ulink" href="https://github.com/andrepolischuk/postcss-pseudo-class-any-button">https://github.com/andrepolischuk/postcss-pseudo-class-any-button</a> will be of interest: it allows us to use the <code class="literal">:any-button</code> selector (which isn't an official selector). When compiled, it transpiles this into four different types—plain button and three inputs (reset, submit, and button).</li></ul></div><p>This is just a small selection of the handful of plugins currently available in the PostCSS ecosystem, for handling pseudo-selectors. We can talk about using them, but in reality, the best way to understand their usefulness is to see them in action! With this in mind, let's take a look at one in action: <code class="literal">postcss-pseudo-elements-content</code>. This little beauty has but one purpose in life: to add a content: attribute to appropriate pseudo-selectors, if one is not present in our code.</p></div><div class="section" title="Updating our code"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec107"/>Updating our code</h2></div></div></div><p>There are a few examples of plugins that help handle pseudo-selectors better; our projects will dictate whether we <a id="id637" class="indexterm"/>should use them on a per case basis, or can incorporate some or all of them into our baseline processors.</p><p>One example that might suit being added to our baseline processor is postcss-pseudo-elements-content, which is available from <a class="ulink" href="https://github.com/omgovich/postcss-pseudo-elements-content">https://github.com/omgovich/postcss-pseudo-elements-content</a>. This simple plugin parses our code and will add a content: '' statement to our code, when it <a id="id638" class="indexterm"/>sees instances of appropriate pseudo-selectors. It doesn't require any configuration, so without further ado, let's get stuck into using it:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start as always with installing the plugin—for this, fire up a Node.js command prompt window and change the working folder to our project area.</li><li class="listitem">In the prompt, go ahead and run this command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-pseudo-elements-content --save-dev</strong></span>
</pre></div></li></ol></div><p>If all is well, we should see something akin to this:</p><div class="mediaobject"><img src="graphics/BO5194_10_03.jpg" alt="Updating our code"/></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">From a copy of the code download that accompanies this book, extract a copy of <code class="literal">style.css</code> and <code class="literal">content.html</code> from the <code class="literal">T51 - adding before and after content</code> folder. Save the style sheet to the <code class="literal">src</code> folder, and the <code class="literal">content.html</code> to the root of our project area.</li><li class="listitem">Open up a copy of <code class="literal">gulpfile.js</code> that is at the root of our project area, then add this line in at line 11:<div class="informalexample"><pre class="programlisting">var pseudoContent = require('postcss-pseudo-elements-content');</pre></div></li><li class="listitem">A little further down, we need to update our first task to allow for the additional plugin; go ahead and alter the line as indicated:<div class="informalexample"><pre class="programlisting">gulp.task('styles', function() {
  return gulp.src('src/*.css')
  .pipe(postcss([ autoprefixer(), pseudoContent() ]))</pre></div></li><li class="listitem">In the Node.js command prompt, enter <code class="literal">gulp</code> then press <span class="emphasis"><em>Enter</em></span>—if all is well, we should see our style sheet files and source map appear in the <code class="literal">dest</code> folder.</li><li class="listitem">Copy the<a id="id639" class="indexterm"/> contents of this folder to the <code class="literal">css</code> folder at the root of our project areas; if we preview <code class="literal">content.html</code>, we should see our menu appear:<div class="mediaobject"><img src="graphics/BO5194_10_04.jpg" alt="Updating our code"/></div></li></ol></div><p>In a sense, this could be treated as a shortcut plugin (in a similar fashion to ones we worked with earlier in the book). The magic happens by adding <code class="literal">–c</code> after our pseudo-selector, as shown in this code extract:</p><div class="informalexample"><pre class="programlisting">.underline a:hover::after-c, .underline a:focus::after-c {
  opacity: 1;
  transform: translateY(0px);
}</pre></div><p>When compiled, it adds the <code class="literal">content: ''</code> attribute, as shown in this screenshot:</p><div class="mediaobject"><img src="graphics/B05194_10_12.jpg" alt="Updating our code"/></div><p>Although it is debatable whether it is worth adding a plugin for something this small, it does at least ensure that we keep a consistent code base when compiling our style sheet.</p><p>The real decision is whether your code has sufficient instances of pseudo-selectors to warrant installing these plugins as part of a baseline, or if your projects dictate their use on a case-by-case basis.</p><p>Let's change tack, most<a id="id640" class="indexterm"/> of the improvements we've covered relate to text. Text sites can be very unappealing without images—thankfully, there are some plugins available to help extend our baseline processor, and better manage images. I feel a demo coming on, so let's go explore this in more detail.</p></div><div class="section" title="Dealing with images"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec108"/>Dealing with images</h2></div></div></div><p>If we were to consider<a id="id641" class="indexterm"/> our processor as being solely for compiling PostCSS code, then we are selling ourselves short—we've already covered how the use of a task runner such as Gulp allows us to add additional tasks such as <code class="literal">autoprefixer</code> and <code class="literal">cssnano</code>.</p><p>A great one to consider adding is the ability to compress our images for optimum size; would you want to do this manually, no matter how much or how little might be saved in size? I thought not. Automating this process means we can get on with tasks that add more value to the process. We can achieve this <a id="id642" class="indexterm"/>with the <code class="literal">gulp-imagemin</code> plugin, available from <a class="ulink" href="https://github.com/sindresorhus/gulp-imagemin">https://github.com/sindresorhus/gulp-imagemin</a>—let's take a look at what might be involved in minifying our images:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Fire up a Node.js command prompt window, then change the working directory to our project area.</li><li class="listitem">In the prompt, enter both commands, pressing <span class="emphasis"><em>Enter</em></span> after each:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install gulp-imagemin --save-dev</strong></span>
<span class="strong"><strong>npm install imagemin-jpegtran --save-dev</strong></span>
</pre></div><p>Keep the prompt open—we will use it again shortly.</p></li><li class="listitem">From the code download that accompanies this book, go ahead and extract copies of the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the <code class="literal">T52 - optimizing images</code> folder; save these to the root of our project area.</li><li class="listitem">Create a folder called <code class="literal">img</code> at the root of our project folder; this will be used as a temporary replacement for the <code class="literal">dest</code> folder already present.</li><li class="listitem">Find some large images—they should be JPEG format, and ideally be several megabytes in size; about four to six images will suffice.</li><li class="listitem">Go back to the Node.js prompt, then enter <code class="literal">gulp</code> and press <span class="emphasis"><em>Enter</em></span>—the screenshot below shows an example I performed with a handful of images:<div class="mediaobject"><img src="graphics/BO5194_10_05.jpg" alt="Dealing with images"/></div></li></ol></div><p>If all is well, we should see our newly compressed images in the <code class="literal">img</code> folder—this is a useful task to have<a id="id643" class="indexterm"/> within our processor, so let's go through a few points in more detail.</p><div class="section" title="Exploring the process"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec04"/>Exploring the process</h3></div></div></div><p>Image compression is key to a performant site—users will be turned off if the text appears within a couple of seconds, but images take much longer to appear! There are a few points to consider, though, with this approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It's not<a id="id644" class="indexterm"/> particularly fast—minifying a dozen images each around 2 MB in size isn't too bad, but this isn't going to improve if you have to minify large numbers of images.</li><li class="listitem" style="list-style-type: disc">We've limited our support to JPEG images—it is possible to optimize SVG and PNG images, but this will require changes to our code. If we look closely at the code used, we can see this:<div class="informalexample"><pre class="programlisting">var images = require('gulp-imagemin');
var jpegtran = require('imagemin-jpegtran');</pre></div></li></ul></div><p>The latter plugin is installed automatically by <code class="literal">gulp-imagemin</code>, and would need to be changed if working with SVG or PNG images:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tests performed locally seem to indicate that the size of reduction isn't as good as one might expect; I suspect that this will improve with much larger images. It is worth experimenting with changing the compression level—make sure your source images are as large as possible!</li></ul></div><p>Once our images have been optimized for size, we can then explore further options—here are a couple worth considering:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the age of development over multiple devices, we need our images to be responsive; the <a id="id645" class="indexterm"/>gulp-responsive plugin available from <a class="ulink" href="https://github.com/azat-io/postcss-responsive-images">https://github.com/azat-io/postcss-responsive-images</a> can help create these images.</li><li class="listitem" style="list-style-type: disc">We might want to use sprites instead. Thankfully, adding sprite support is easy within PostCSS: take a look at the postcss-sprites plugin for this task.</li><li class="listitem" style="list-style-type: disc">You may like to consider using an asset manager to resolve URLs—the postcss-assets plugin is a perfect candidate for this task. The source and details for using<a id="id646" class="indexterm"/> are available from <a class="ulink" href="https://github.com/assetsjs/postcss-assets">https://github.com/assetsjs/postcss-assets</a>.</li></ul></div><p>There's an important point to note, though—although plugins are available for the purpose, it is not <a id="id647" class="indexterm"/>worth considering minifying HTML; it is unlikely that you will get any significant space back, and the code will become hard to read. It is best to reserve minifying files for those external assets that have to be linked to your HTML pages, in order to get the most benefit.</p><p>Okay, let's move on: before we test our processor, there is one more idea that may be worth consideration. Adding an automatic reload capability to our code means that we do not need to reload our pages to view updated content. There is a heavy reliance on the use of Chrome to make it work, so it won't be for everyone: let's look at what would be involved in more detail.</p></div></div></div>
<div class="section" title="Adding reload capabilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec84"/>Adding reload capabilities</h1></div></div></div><p>Adding a reload capability<a id="id648" class="indexterm"/> reduces the amount of time spent manually reloading our pages after a code change; the latter can be a real pain, especially when working with complex CSS styles!</p><p>The downside to this is that it only works in Chrome—if this isn't an issue, then these are the steps you would need to follow to make this work:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by extracting copies of the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the <code class="literal">T53 – adding livereload capabilities</code> folder, from the code download that accompanies this book. Save both copies to the root of our project area.</li><li class="listitem">From the same <code class="literal">T53 – adding livereload capabilities</code> folder, extract and save a copy of the <code class="literal">style.css</code> file from the <code class="literal">src</code> folder within, to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">Fire up a Node.js command prompt, then change the working folder to our project area.</li><li class="listitem">In the prompt, enter <code class="literal">npm install gulp-livereload –save-dev</code> and press <span class="emphasis"><em>Enter</em></span>—let this install.</li><li class="listitem">Download and<a id="id649" class="indexterm"/> install the Chrome applet for LiveReload from <a class="ulink" href="http://bit.ly/IKI2MY">http://bit.ly/IKI2MY</a>.</li><li class="listitem">Add this line at the end of the <code class="literal">sourcemap</code> task:<div class="informalexample"><pre class="programlisting">.pipe(plugins.livereload());</pre></div></li><li class="listitem">Remove the semi-colon at the end of line 60.</li><li class="listitem">Add this<a id="id650" class="indexterm"/> line to our <code class="literal">watch</code> task:<div class="informalexample"><pre class="programlisting">plugins.livereload.listen();</pre></div></li><li class="listitem">Our task file will look like this, with the changes made at lines 61 and 68:<div class="mediaobject"><img src="graphics/BO5194_10_06.jpg" alt="Adding reload capabilities"/></div></li></ol></div><p>At this point, we can test to ensure it works by making a change to our style sheet—if all is well, Gulp will kick in and recompile our code; if we have a site open in a browser that we're developing, then this would be automatically reloaded by the plugin.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>For those of you interested in using this plugin in more detail, please refer to the documentation available on the GitHub site at <a class="ulink" href="https://github.com/vohof/gulp-livereload">https://github.com/vohof/gulp-livereload</a>. There is a full version of the code used in<a id="id651" class="indexterm"/> this example, within the <code class="literal">T53 - adding livereload capabilities</code> folder in the code download that accompanies this book.</p></div></div><p>Right, onwards we go! We're almost at the end of our journey through the art of the possible; before we move onto testing our processor, I thought I would leave you with a few more ideas that you may like to consider using in your processors. All of them should install using the same process that we've seen throughout this book.</p></div>
<div class="section" title="Extending our processor further"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec85"/>Extending our processor further</h1></div></div></div><p>Over the last few <a id="id652" class="indexterm"/>pages, we've explored a number of ways to improve our existing processor, as well as a few ideas for extending functionality. Although we can always keep to PostCSS plugins, we run the risk of limiting the "art of the possible", or what is available for us to use.</p><p>Sometimes, we might want to go a little further afield—creating a processor isn't just about the nitty-gritty of compiling code, but also about our working environment and the processes required to support it (at least in part). To prove this, we're going to explore installing the <code class="literal">postcss-stats</code> plugin as an example of how we can extend both our plugin and working environment.</p><p>This plugin helps provide useful statistics about each project as it is compiled—it's based on the <a id="id653" class="indexterm"/>CSS Stats system, and is available online at <a class="ulink" href="http://www.cssstats.com">http://www.cssstats.com</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>Throughout the demo, you may see a few issues with deprecated warnings—at the time of writing, the plugin needs a little polishing/updating. Don't worry though: the plugin will still work fine for the purposes of our demo.</p></div></div><p>The source for this plugin is<a id="id654" class="indexterm"/> available on GitHub at <a class="ulink" href="https://github.com/cssstats/postcss-cssstats">https://github.com/cssstats/postcss-cssstats</a>, and can be installed using the usual route. Let's dive in and take a look:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by firing up a Node.js command prompt session, then changing the working directory to the root of our project area.</li><li class="listitem">We need to install the plugin, so in the prompt, enter this command and press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-cssstats --save-dev </strong></span>
</pre></div></li></ol></div><p>Keep this open—we will need it later in the exercise.</p><p>Next, we need to<a id="id655" class="indexterm"/> update our <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files—go ahead and extract copies of both files from the <code class="literal">T54 - using cssstats</code> folder in the code download that accompanies this book. Save both files to the root of our project area:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">With our files in place, we can now test that it works—go ahead and save a copy of <code class="literal">style.css</code> from the same folder into the <code class="literal">src</code> folder of our project area.</li><li class="listitem">Revert to the Node.js command prompt we had open earlier—in the prompt, enter <code class="literal">gulp</code>, and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">PostCSS will compile our code—if all is well, we should see files appear in the now familiar <code class="literal">dest</code> folder…and we should also see something akin to this screenshot:<div class="mediaobject"><img src="graphics/BO5194_10_07.jpg" alt="Extending our processor further"/></div></li></ol></div><p>If I were a betting man (I'm not, but assume I am for this)—I would bet even odds that you're probably thinking "What on earth does all of that text mean?" Well, let me shed some light on what it all means.</p><p>In a nutshell, we've installed what is<a id="id656" class="indexterm"/> effectively a reporting system—this details a bunch of statistics about our code. It contains details about all kinds of information, including the number of selectors, colors, the level of CSS specificity, declarations, and so on. It's an easy way to get information about our code, as a means of documenting it for later use. The reason it is so easy to get the information lies in how it is configured—take a look at the <code class="literal">gulpfile.js</code> file; we will add a call to the plugin at the top:</p><div class="informalexample"><pre class="programlisting">var reporter = require('postcss-reporter');</pre></div><p>We can then modify the styles single task, by adding this line near the end:</p><div class="informalexample"><pre class="programlisting">    .pipe(postcss([ cssstats( function(stats) {
      console.log(stats);
    })
  ]))
  .pipe(gulp.dest('dest/'));
})</pre></div><p>The trouble is, whilst it might be easy to get the information, it's not so easy to store it!  We can absolutely improve on it; instead of getting the information via our processor, we can go directly to the source. Let's explore how to make this happen:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by firing up a Node.js command prompt, then changing the working folder to the root of our project area.</li><li class="listitem">At the prompt, go ahead and enter <code class="literal">npm install gulp-stylestats --save-dev</code>, then press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">We now need to edit the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files we used in the previous exercise, so open the <code class="literal">gulpfile.js</code> file in a text editor, and add these lines immediately below the closing bracket of the <code class="literal">sourcemap</code> task:<div class="informalexample"><pre class="programlisting">gulp.task('stylestats', ['minifyCSS'], function () {
  gulp.src('dest/*.css')
    .pipe(stylestats({
      type: 'json',
      outfile: true
    }))
    .pipe(gulp.dest('dest/'));
});</pre></div></li><li class="listitem">Next, we need to update the default task—alter it as indicated:<div class="informalexample"><pre class="programlisting">gulp.task('default', ['styles', 'lint', 'rename',
 'minifyCSS', 'sourcemap', 'stylestats']);</pre></div></li><li class="listitem">Revert to the Node.js command prompt, then enter <code class="literal">gulp</code> and press <span class="emphasis"><em>Enter</em></span>—assuming we still have the same <code class="literal">style.css</code> file in the <code class="literal">src</code> folder, we should see this appear in the <code class="literal">dest</code> folder at the root of our project area:<div class="mediaobject"><img src="graphics/BO5194_10_08.jpg" alt="Extending our processor further"/></div></li><li class="listitem">Whilst we clearly<a id="id657" class="indexterm"/> need to alter the parameters of our Gulp file to prevent it producing minified JSON files, we can at least see the result of the (uncompressed) JSON file. Go ahead and open it up—it will look something like this:<div class="mediaobject"><img src="graphics/BO5194_10_09.jpg" alt="Extending our processor further"/></div></li></ol></div><p>Although we're still only seeing code, we can now parse the content at will; we could, for instance, use jQuery to explore the contents and render it on screen using an appropriate style and format. I am <a id="id658" class="indexterm"/>sure you will agree though that this is a much easier way to view (and store) the information! The plugin needs minimal configuration to get started. We can use it to view any standard CSS file, once it has been through the compilation process.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>There are a number of options we can use with the <code class="literal">gulp-stylestats</code> plugin—for details, take a look at <code class="literal">https://github.com/t32k/stylestats</code>.</p></div></div><p>Right, we now have a completed processor; hopefully, this will also include a style guide that is running, using one of the plugins we've just discussed in the previous exercise. It's time we moved on—there is one task we should complete, though, before we embark on the next stage of our journey. It's time we put our processor to the test…</p></div>
<div class="section" title="Testing the final pre-processor"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Testing the final pre-processor</h1></div></div></div><p>Throughout this<a id="id659" class="indexterm"/> book, we've explored a number of different plugins and concepts to help construct a processor; over the last few pages, we've brought together some of those concepts as the final version of our processor—at least one we can start using in anger.</p><p>There is one key step left to complete—we've compiled code for simple exercises, this works well, but doesn't really represent the kind of processes we might go through as developers! For this, we need to construct a real-world example, and put our processor through its paces.</p><p>As luck would have it, there is an example web page we can use from the code download that accompanies this book—let's take a look at putting its style sheet code through our processor. We'll begin by running the normal tasks we've done before, but will add a selection of plugins to make for a more realistic example:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by extracting a copy of the <code class="literal">T55 - testing our processor</code> folder from the<a id="id660" class="indexterm"/> code download that accompanies this book; go ahead and save it to the root of our project area.</li><li class="listitem">Copy the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from within this sub-folder to the root of our project area.</li><li class="listitem">Fire up a Node.js command prompt, then change the working folder to our project area.</li><li class="listitem">In the prompt, go ahead and enter these three lines, pressing <span class="emphasis"><em>Enter</em></span> after each:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss-nesting --save-dev</strong></span>
<span class="strong"><strong>npm install postcss-short-color --save-dev</strong></span>
<span class="strong"><strong>npm install postcss-pixrem</strong></span>
</pre></div></li><li class="listitem">Copy the <code class="literal">site.css</code> file from within the <code class="literal">css – completed version</code> folder under <code class="literal">T55 – testing our processor</code>, to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">Revert to the Node.js session, then enter <code class="literal">gulp</code> at the prompt and press <span class="emphasis"><em>Enter</em></span>—wait for it to complete compiling.</li><li class="listitem">When compilation has finished, copy the contents of the <code class="literal">dest</code> folder to the <code class="literal">css</code> folder within <code class="literal">T55 – testing our processor</code>.</li><li class="listitem">Try previewing the results of the compiled file—if all is well, we should see something akin to this screenshot:<div class="mediaobject"><img src="graphics/BO5194_10_10.jpg" alt="Testing the final pre-processor"/></div></li></ol></div><p>Try resizing the browser window, or enabling Responsive Design mode in your browser (if supported)—we should see that content automatically flows or resizes, according to the size you set for the<a id="id661" class="indexterm"/> browser window. Overall, a successful result!</p><p>The question is—what happened here? If we take a look at our code, the sharp-eyed should spot the addition of three plugins, plus a lot more code in the compiled version; let's take a moment to digest the results of our exercise.</p><div class="section" title="Digesting the results of our exercise"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec109"/>Digesting the results of our exercise</h2></div></div></div><p>If we look through our Gulp task file carefully, there should not be much in there that comes as a surprise—many of the tasks used are ones we have used on many occasions throughout the book.</p><p>The key here, though, is that whilst we can run the standard processor that we've already used before, it's <a id="id662" class="indexterm"/>unlikely to suit all occasions. It's more likely that we can use it as our base (as stated earlier), then add any extra plugins as needed. The great thing about this is that most of the configuration work is done—it keeps a consistent approach to our work. All that remains is to install any plugins that we <span class="emphasis"><em>don't</em></span> already have in place—we of course have most of them, but need to install three additional ones, as highlighted here:</p><div class="informalexample"><pre class="programlisting">gulp.task('styles', function () {
  return gulp.src('src/*.css')
    .pipe(postcss([ rucksack({ fallbacks: true }), autoprefixer(), shortcolor, nesting, pixrem ]))
    .pipe(gulp.dest('dest/'));
});</pre></div><p>These have to be accompanied with the relevant calls at the top of our Gulp task file:</p><div class="informalexample"><pre class="programlisting">var nesting = require('postcss-nesting');
var shortcolor = require('postcss-short-color');
var pixrem = require('pixrem');</pre></div><p>In turn, these plugins are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rucksack</strong></span>: This is<a id="id663" class="indexterm"/> to handle responsive/media queries, fallback colors from rgba to hex, and implement <code class="literal">@font-face</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pixrem</strong></span>: Available at <a class="ulink" href="https://github.com/robwierzbowski/node-pixrem">https://github.com/robwierzbowski/node-pixrem</a>, this takes care <a id="id664" class="indexterm"/>of providing a fallback mechanism for the rem unit <a id="id665" class="indexterm"/>values used throughout our style sheet.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Nesting</strong></span>: Downloadable<a id="id666" class="indexterm"/> from <a class="ulink" href="https://github.com/jonathantneal/postcss-nesting">https://github.com/jonathantneal/postcss-nesting</a> (via Node), this covers an instance of nesting used in our code.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Shorthand Color</strong></span>: In a <a id="id667" class="indexterm"/>couple of instances, we combined <code class="literal">background-color</code> and <code class="literal">color</code> attributes in a <a id="id668" class="indexterm"/>shorthand form that is later transpiled by the plugin. You can see more about this plugin at <a class="ulink" href="https://github.com/jonathantneal/postcss-short-color">https://github.com/jonathantneal/postcss-short-color</a>.</li></ul></div><p>We can of course add others, and continue converting our code—there are other instances where Nesting can be applied, such as in the rules that control styling for our navigation. The key here, though, is that success is measured in how much we have to change our processor's <span class="emphasis"><em>default</em></span> setup—in this instance, we didn't have to change it at all! We of course added extra plugins that required a change to one line of code in the processor, but none of the other tasks required any changes at all.</p><p>It's at this stage<a id="id669" class="indexterm"/> that we have effectively completed the journey to create our processor—well, strictly speaking, our journey should always be considered without end; this will help ensure our tool remains up to date. This aside, though, there are some useful tips we can use when creating our processor, so let's take a moment to cover these in more detail.</p></div></div>
<div class="section" title="Getting started with some hints and tips"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Getting started with some hints and tips</h1></div></div></div><p>The time has come when it is over to you as developers to start creating your own processor! It may seem a daunting task at first, depending on the size and nature of your project; I've listed a<a id="id670" class="indexterm"/> few tips to help you over the initial hurdle of planning and creating your processor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Every processor is unique—do not be afraid to experiment. The processor of course must meet your requirements, but there are several ways to crack a nut, so if the first plugin you try doesn't work, then move on and try another.</li><li class="listitem" style="list-style-type: disc">Don't fall into the trap that many do, and consider PostCSS as either a pre-processor or a post-processor; it is neither and yet it is also both. The library itself does nothing; the magic lies in the plugins you add, which determine how it performs.</li><li class="listitem" style="list-style-type: disc">Start small—PostCSS was designed to be modular, so if all you need to begin with is a facility to add vendor prefixes, then fine. Over time, you can easily add extra plugins to your processor; it does not matter if this is adding to existing functionality, or replacing an old process that is no longer efficient or works.</li><li class="listitem" style="list-style-type: disc">Think iteratively—don't even try to convert something as large as the style sheet for WordPress in one go! You will soon lose patience and momentum, and potentially abandon a project before you get the benefits of using PostCSS.</li><li class="listitem" style="list-style-type: disc">The only time a processor should be retired is if there is a fundamental change in the architecture of your project, which makes it incompatible with PostCSS. The versatility of PostCSS is such that this isn't likely to happen—you should always review the functionality periodically to ensure you are getting the best out of your processor. Plugins change, are deprecated, or new ones are added—a check will ensure your solution still works as efficiently as possible.</li><li class="listitem" style="list-style-type: disc">Any processor should not be limited to PostCSS plugins only—even though this is what <a id="id671" class="indexterm"/>we've focused on, there are thousands of other plugins available for your task runner of choice, which will likely work with PostCSS. The key here is that if it helps automate a mundane task that saves you time as a developer, then consideration should be given to whether it can be included in your processor.</li><li class="listitem" style="list-style-type: disc">I personally take the view that if it can be automated reliably, then include a task for it—we live in an age where time is precious; there is no value in manually resizing images, for example, if it can be done automatically!</li><li class="listitem" style="list-style-type: disc">Although we've talked about some of the tasks we can complete using a task runner, we must not forget the folder structure too. There is nothing worse than compiling files for different environments, for example, if they land up in badly-organized folders! Gulp can automate a multitude of tasks, so the fewer changes we have to do, or the fewer files we have to copy, the better.</li></ul></div><p>Hopefully, they are a few tips to get you started! The great thing about PostCSS is that no two processors will be the same; whilst some may count that as a shortcoming, it should be noted that there is a wealth of possibilities out there to be explored, and that you can make your processor as simple or as complex as your project requirements dictate.</p><p>Before we bow out from our journey through building a custom processor, there is something we should consider. Our processor was constructed entirely using PostCSS plugins; in reality, our processor is more likely to go through a transitional phase, where we convert from the likes of SASS or less to using PostCSS.</p><p>To help with this process, we can always make use of a library such as CSStyle—this little interesting gem can work with either SASS or PostCSS, and could be a useful addition to the transition process. Over the course of the next two chapters, we will learn how to create custom syntaxes and explore some of the ways we can process both PostCSS and SASS content through the same process. As a taster for what is coming, let's take a quick tour through CSSStyle and see how it works in action.</p></div>
<div class="section" title="Introducing the CSStyle library"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Introducing the CSStyle library</h1></div></div></div><p>Cast your mind back to <a class="link" href="ch03.html" title="Chapter 3. Nesting Rules">Chapter 3</a>, <span class="emphasis"><em>Nesting Rules</em></span>, where we explored the concepts behind BEM, or the Block, Element, Modifier way of writing CSS. The key benefit of using this method is to help reduce<a id="id672" class="indexterm"/> CSS specificity, or where we might otherwise end up using something such as the following to style a simple button:</p><div class="informalexample"><pre class="programlisting">#maincontent .button .red.large:hover</pre></div><p>Okay, it's a little contrived, but you get the idea: the level of specificity makes it awkward to manage and potentially reuse in future projects.</p><p>We took a look at BEM as a possible alternative—it has the benefit of reducing styles down to one or two classes, but can be awkward to remember which conventions to use:</p><div class="informalexample"><pre class="programlisting">.component {
  /* represents a component */
}

.component__element {
  /* represents a small part that is used to make a component */

}

'.component--modifier {
  /* represents a state modifier for the component */
}</pre></div><p>Okay, so how can we get around this? Well, here's an option we can consider using: the CSStyle library. There are several reasons why this can help us—let's take a look in more detail.</p><div class="section" title="Exploring the benefits of using CSStyle"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec110"/>Exploring the benefits of using CSStyle</h2></div></div></div><p>The key behind CSStyle (available from <a class="ulink" href="http://csstyle.io/">http://csstyle.io/</a>) is that it is made up of modular blocks, in a similar fashion to BEM. The difference, though, is that instead of having to remember a<a id="id673" class="indexterm"/> set of conventions that aren't the most intuitive, we can <a id="id674" class="indexterm"/>use a simpler set to create cleaner code.</p><p>The real beauty, though, is that we can use either SASS or PostCSS to create our site—we can begin with SASS, but we can also begin to transition over to using PostCSS with minimal changes. Let's put this into <a id="id675" class="indexterm"/>practice, and explore a quick demo to see how easy it is to make these changes—before we do so, take a look at <a class="ulink" href="http://codepen.io/alibby251/pen/pgmqjJ">http://codepen.io/alibby251/pen/pgmqjJ</a>; this is a Pen that illustrates what we're going to create:</p><div class="mediaobject"><img src="graphics/BO5194_10_11.jpg" alt="Exploring the benefits of using CSStyle"/></div><p>It won't win any style awards, but the purpose of this demo is to show you the <span class="emphasis"><em>process</em></span> and not necessarily produce anything that is stunning! With that in mind, let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll begin by extracting a copy of the <code class="literal">T56 - using csstyle with sass</code> folder from<a id="id676" class="indexterm"/> the code download that accompanies this book; save the folder to the root of our project area.</li><li class="listitem">Copy the contents of the <code class="literal">src</code> folder within <code class="literal">T56 - using csstyle with sass</code> to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">Go ahead and replace the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files at the root of our project area with copies from within the <code class="literal">T56 - using csstyle with sass</code> folder.</li><li class="listitem">Fire up a Node.js command prompt session, then change the working folder to the root of our project area.</li><li class="listitem">At the prompt, enter gulp and press <span class="emphasis"><em>Enter</em></span>—if all is well, we should see a compiled <code class="literal">style.css</code> file appear in the <code class="literal">dest</code> folder in our project area.</li><li class="listitem">Copy the contents of the <code class="literal">dest</code> folder back to the <code class="literal">css</code> folder within the <code class="literal">T56 - using csstyle with sass</code> folder.</li></ol></div><p>At this point, try previewing the results in a browser. If all is well, we will see the three buttons appear, just as they show in the Pen we mentioned at the start of this exercise.</p><p>All looks good…we have a working demo, with a compiled style sheet—but hold on…in <span class="emphasis"><em>SASS</em></span>? Yes, if you look carefully, the demo was indeed set to use SASS, but with good reason: we're going to see how easy it is to change to using PostCSS <span class="emphasis"><em>without</em></span> making material changes to our style sheet or our compilation process. Let's make a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">gulpfile.js</code> that is at the root of our project area, comment out line 5, and uncomment lines 6 and 7; this switches our task file from using SASS to PostCSS.</li><li class="listitem">Rename the <code class="literal">[sass]</code> task <code class="literal">[style]</code>, on line 9.</li><li class="listitem">On line 10, the <code class="literal">gulp.src</code> call is looking for SASS files; change it to <code class="literal">src/*.css</code>.</li><li class="listitem">Replace line 11 with this line: <code class="literal">.pipe(postcss([nested, csstyle]))</code>—this removes the dependency on SASS and switches to using PostCSS.</li><li class="listitem">On line 15, our default task will call the <code class="literal">[sass]</code> task; change <code class="literal">[sass]</code> to <code class="literal">[style]</code>.</li><li class="listitem">Change the watch task on line 17 to monitor CSS files, and not SASS:<div class="informalexample"><pre class="programlisting">var watcher = gulp.watch('src/*.css', ['style']);</pre></div></li><li class="listitem">Go ahead and open up the SASS style sheet in the <code class="literal">src</code> folder at the root of our project area—rename the file as <code class="literal">style.css</code>.</li><li class="listitem">In <code class="literal">style.css</code>, go ahead and remove the <code class="literal">@import 'csstyle'</code> line at the top of our style sheet.</li><li class="listitem">Do a search and replace for <code class="literal">@include</code>—remove all instances in our style sheet.</li></ol></div><p>That's it for our demo, sorry<a id="id677" class="indexterm"/> to disappoint if you were expecting more! All that remains is to replace the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files at the root of the project area with copies from the <code class="literal">T57 –</code>
<code class="literal"> using csstyle with postcss</code> folder, and compile as normal.</p></div><div class="section" title="Dissecting our demo"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec111"/>Dissecting our demo</h2></div></div></div><p>Making the transition<a id="id678" class="indexterm"/> from SASS to PostCSS can be as easy or as complex as we make it. Using the CSStyle library can go a long way to easing the transition away from existing processors such as SASS.</p><p>Although our demo was just a quick whistle-stop tour through using CSStyle (and we will revisit it in <a class="link" href="ch12.html" title="Chapter 12. Mixing Preprocessors">Chapter 12</a>, <span class="emphasis"><em>Mixing Preprocessors</em></span>), it nevertheless illustrates a few important points of interest:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The library uses the concept of components, options, parts, and tweaks to create the base components, pass styling to override base rules, add extra elements (such as icons), or tweak code. Careful design means that we can reduce or remove the need to alter our HTML as part of the transition to using PostCSS.</li><li class="listitem" style="list-style-type: disc">It is perfectly possible to compile the SASS version of our demo using a standard SASS compiler; the reason for choosing to use a task runner version (in this case for Gulp) means that we can centralize the compilation process in one task file, and remove the need to use separate compilers in our process.</li><li class="listitem" style="list-style-type: disc">When planning the design or transition of our site to use PostCSS, it pays to choose plugins carefully within PostCSS; this will determine how easy or complex it will be to make the changes in our code and processor.</li><li class="listitem" style="list-style-type: disc">Our demo focused on the core compilation process, and didn't include the extra tasks we used in the past, such as adding source maps. This was purely for clarity—there is no reason why we can't add the remaining tasks we've used before, once we've confirmed our compilation process works as expected.</li></ul></div><p>Ultimately though, the use of this library is about helping to ease the process of making the transition to using PostCSS. There are different ways to approach this—using CSSStyle means that we<a id="id679" class="indexterm"/> have to completely redesign our HTML, but can easily alter the processor with minimal fuss. The flip side to this is that we can use PostCSS plugins that mimic SASS coding standards, or create our own custom syntax—we will explore these concepts in the next two chapters.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec89"/>Summary</h1></div></div></div><p>Creating our own processor can be a satisfying experience—we have total control over what elements should be included, and can add or remove elements at any time. Throughout the course of this book, we've explored a number of elements that make up what might be a typical processor; in this chapter, we pulled together all of these elements to create our final article. Let's take a moment to review what we have learnt.</p><p>We began with a look at some of the key elements of our processor, which we've already used previously, but have not really understood in detail how it all fits together. With this in mind, we moved on to examine some of the issues with our processor, before working out ways of correcting those issues and altering our code.</p><p>With our updated processor in place, we then took a look at ways of optimizing our output by altering existing functionality, or including new options that may or may not make up a baseline processor or one customized for a specific project. We then took a look at extending our functionality, that includes options we would not normally consider, but will complement our work processes perfectly.</p><p>We then rounded out our chapter with a quick test of our processor on a sample site, before exploring some of the hints and tips that will help us when creating our processors. The final step in our journey took a quick look at the CSSStyle library, as a precursor to creating custom syntaxes for PostCSS, which we will explore in the next chapter.</p></div></body></html>