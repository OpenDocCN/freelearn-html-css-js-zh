["```js\nimport dispatcher from '../dispatcher';\n\n// The action name.\nexport const SORT_USERS = 'SORT_USERS';\n\n// This action creator function hard-codes\n// the action payload.\nexport function sortUsers() {\n  dispatcher.dispatch({\n    type: SORT_USERS,\n    payload: {\n      direction: 'asc'\n    }\n  });\n}\n```", "```js\n// This object is used by several action\n// creator functions as part of the action\n// payload.\nexport const PAYLOAD_SORT = {\n  direction: 'asc'\n};\n```", "```js\nimport dispatcher from '../dispatcher';\nimport { PAYLOAD_SORT } from './payload-defaults';\n\n// The action name.\nexport const SORT_TASKS = 'SORT_TASKS';\n\n// This action creator function is using\n// the \"PAYLOAD_SORT\" default object as the\n// payload.\nexport function sortTasks() {\n  dispatcher.dispatch({\n    type: SORT_TASKS,\n    payload: PAYLOAD_SORT\n  });\n}\n```", "```js\nimport dispatcher from './dispatcher';\n\n// Gets the action constant and creator function\n// for \"SORT_USERS\".\nimport {\n  SORT_USERS,\n  sortUsers\n} from './actions/sort-users';\n\n// Gets the action constant and creator function\n// for \"SORT_TASKS\".\nimport {\n  SORT_TASKS,\n  sortTasks\n} from './actions/sort-tasks';\n\n// Listen for actions, and log some information\n// depending on which action was dispatched.\n// Note that we're using the action name constants\n// here, so there's less chance of human error.\ndispatcher.register((e) => {\n  switch (e.type) {\n    case SORT_USERS:\n      console.log(`Sorting users \"${e.payload.direction}\"`);\n      break;\n    case SORT_TASKS:\n      console.log(`Sorting tasks \"${e.payload.direction}\"`);\n      break;\n  }\n});\n\nsortUsers();\n// → Sorting users \"asc\"\n\nsortTasks();\n// → Sorting tasks \"asc\"\n```", "```js\nimport { ACTION_A } from '../actions/action-a';\nimport { ACTION_B } from '../actions/action-b';\nimport { ACTION_C } from '../actions/action-c';\n// …\n```", "```js\nexport { ACTION_A } from './action-a';\nexport { ACTION_B } from './action-b';\nexport { ACTION_C } from './action-c';\n```", "```js\nimport {\n  ACTION_A,\n  ACTION_B,\n  ACTION_C\n} from './actions/constants';\n\nconsole.log(ACTION_A);\n// → ACTION_A\n\nconsole.log(ACTION_B);\n// → ACTION_B\n\nconsole.log(ACTION_C);\n// → ACTION_C\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport const LOAD_TASKS = 'LOAD_TASKS';\n\n// Immediately dispatches the action using an array\n// of task objects as the mock data.\nexport function loadTasks() {\n  dispatcher.dispatch({\n    type: LOAD_TASKS,\n    payload: [\n      { id: 1, name: 'Task 1', state: 'running' },\n      { id: 2, name: 'Task 2', state: 'queued' },\n      { id: 3, name: 'Task 3', state: 'finished'}\n    ]\n  });\n}\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport const RUN_TASK = 'RUN_TASK';\n\n// Uses \"setTimeout()\" to simulate latency we'd\n// likely see in a real network request.\nexport function runTask() {\n  setTimeout(() => {\n    dispatcher.dispatch({\n      type: RUN_TASK,\n\n      // Highly-specific mock payload data. This\n      // mock data doesn't necessarily have to\n      // be hard-coded like this, but it does make\n      // experimentation easy.\n      payload: {\n        id: 2,\n        state: 'running'\n      }\n    });\n  }, 1000);\n}\n```", "```js\nimport EventEmitter from 'events';\nimport dispatcher from '../dispatcher';\nimport { LOAD_TASKS } from '../actions/load-tasks';\nimport { RUN_TASK } from '../actions/run-task';\n\n// The store for tasks displayed in the application.\nclass TaskStore extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = [];\n\n    dispatcher.register((e) => {\n      switch(e.type) {\n\n        // In the case of \"LOAD_TASKS\", we can use the\n        // \"payload\" as the new store state.\n        case LOAD_TASKS:\n          this.state = e.payload;\n          this.emit('change', this.state);\n          break;\n\n        // In the case of \"RUN_TASK\", we need to look\n        // up a specific task object and change it's state.\n        case RUN_TASK:\n          let task = this.state.find(\n            x =>x.id === e.payload.id);\n\n          task.state = e.payload.state;\n\n          this.emit('change', this.state);\n\n          break;\n      }\n    });\n  }\n}\n\nexport default new TaskStore();\n```", "```js\nimport taskStore from './stores/task';\nimport { loadTasks } from './actions/load-tasks';\nimport { runTask } from './actions/run-task';\n\n// Logs the state of the store, as a mapped array\n// of strings.\ntaskStore.on('change', (state) => {\n  console.log('tasks',\n    state.map(x => `${x.name} (${x.state})`));\n});\n\nloadTasks();\n// →\n// tasks [\n//   \"Task 1 (running)\",\n//   \"Task 2 (queued)\",\n//   \"Task 3 (finished)\"\n// ]\n\nrunTask();\n// →\n// tasks [\n//   \"Task 1 (running)\",\n//   \"Task 2 (running)\",\n//   \"Task 3 (finished)\"\n// ]\n```", "```js\nimport { MOCK } from '../settings';\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport const LOAD_USERS = 'LOAD_USERS';\n\n// The mock implementation of the action creator.\nfunction mockLoadUsers() {\n  dispatcher.dispatch({\n    type: LOAD_USERS,\n    payload: [\n      { id: 1, name: 'Mock 1' },\n      { id: 2, name: 'Mock 2' }\n    ]\n  });\n}\n\n// The production implementation of the action creator.\nfunction prodLoadUsers() {\n  dispatcher.dispatch({\n    type: LOAD_USERS,\n    payload: [\n      { id: 1, name: 'Prod 1' },\n      { id: 2, name: 'Prod 2' }\n    ]\n  });\n}\n\n// Here's where the \"loadUsers\" value is determined, based\n// on the \"MOCK\" setting. It's always going to be exported\n// as \"loadUsers\", meaning that no other code needs to change.\nconst loadUsers = MOCK ? mockLoadUsers : prodLoadUsers;\nexport { loadUsers as loadUsers };\n```", "```js\nimport dispatcher from './dispatcher';\n\n// This code never has to change, although the actual\n// function that's exported will change, depending on\n// the \"MOCK\" setting.\nimport { loadUsers } from './actions/load-users';\n\ndispatcher.register((e) => {\n  console.log('Users', e.payload.map(x =>x.name));\n});\n\nloadUsers();\n// → Users [\"Mock 1\", \"Mock 2\"]\n// When the \"MOCK\" setting is set to true...\n// → Users [\"Prod 1\", \"Prod 2\"]\n```", "```js\n// Get the action constants and action functions\n// that we need.\nimport { ONE, one } from './one';\nimport { TWO, two } from './two';\nimport { THREE, three } from './three';\n\nvar ws;\nvar actions = {};\n\n// Create a mapping of constants to functions\n// that the web socket handler can use to call\n// the appropriate action creator.\nactions[ONE] = one;\nactions[TWO] = two;\nactions[THREE] = three;\n\n// Connects the web socket...\nexport default function connect() {\n  ws = new WebSocket('ws://127.0.0.1:8000');\n\n  ws.addEventListener('message', (e) => {\n\n    // Parses the message data and uses the\n    // \"actions\" map to call the corresponding\n    // action creator function.\n    let data = JSON.parse(e.data);\n    actions[data.task](data.value);\n  });\n}\n```", "```js\n// The HTTP server...\nvar server = require('http').createServer();\n\n// The web socket server...\nvar ws = new require('ws').Server({\n  server: server,\n});\n\n// Makes life worth living...\nvar express = require('express');\nvar app = express();\n\n// So we can serve \"index.html\"...\napp.use(express.static(__dirname));\n\n// Handler for when a client connects via web socket.\nws.on('connection', function connection(ws) {\n  let i = 0;\n  const names = [ null, 'one', 'two', 'three' ];\n\n  // Sends the client 3 messages, spaced by 1 second\n  // intervals.\n  function interval() {\n    if (++i< 4) {\n      ws.send(JSON.stringify({\n        value: i,\n        task: names[i]\n      }));\n\n      setTimeout(interval, 1000);\n    }\n  }\n\n  setTimeout(interval, 1000);\n});\n\n// Fire up the HTTP and web socket servers.\nserver.on('request', app);\nserver.listen(8000, () => {\n  console.log('Listening on', server.address().port)\n});\n```", "```js\nimport dispatcher from './dispatcher';\nimport connect from './actions/socket-listener';\nimport { ONE } from './actions/one';\nimport { TWO } from './actions/two';\nimport { THREE } from './actions/three';\n\n// Logs the web socket messages that have been\n// dispatched as Flux actions.\ndispatcher.register((e) => {\n  switch (e.type) {\n    case ONE:\n      console.log('one', e.payload);\n      break;\n    case TWO:\n      console.log('two', e.payload);\n      break;\n    case THREE:\n      console.log('three', e.payload);\n      break;\n  }\n});\n// →\n// one 1\n// two 2\n// three 3\n\n// Establishes the web socket connection. Note\n// that it's important to connect after everything\n// with the Flux dispatcher is setup. \nconnect();\n```", "```js\nimport dispatcher from '../dispatcher';\nimport sortBy from 'lodash/sortBy';\n\n// The action identifier...\nexport const FIRST = 'FIRST';\n\nexport function first() {\n\n  // The payload data.\n  let payload = [ 20, 10, 30 ];\n\n  // Dispatches the \"FIRST\" action with\n  // the payload sorted in ascending order.\n  dispatcher.dispatch({\n    type: FIRST,\n    payload: sortBy(payload)\n  });\n}\n```", "```js\nimport dispatcher from '../dispatcher';\nimport sortBy from 'lodash/sortBy';\n\n// The action identifier...\nexport const SECOND = 'SECOND';\n\nexport function second() {\n\n  // The payload data.\n  let payload = [ 20, 10, 30 ];\n\n  // Dispatches the action, with the\n  // payload sorted in descending order.\n  dispatcher.dispatch({\n    type: SECOND,\n    payload: sortBy(payload, x => x * -1)\n  });\n}\n```", "```js\nimport dispatcher from '../dispatcher';\nimport sortBy from 'lodash/sortBy';\n\n// The action identifier...\nexport const THIRD = 'THIRD';\n\n// Accepts a sort direction, but defaults\n// to descending.\nexport function third(dir='desc') {\n\n  // The payload data.\n  let payload = [ 20, 10, 30 ];\n\n  // The iteratee function that's passed\n  // to \"sortBy()\".\n  let iteratee;\n\n  // Sets up the custom \"iteratee\" if we\n  // want to sort in descending order.\n  if (dir === 'desc') {\n    iteratee = x => x * -1;\n  }\n\n  // Dispatches the action, sorting the payload\n  // based on \"dir\".\n  dispatcher.dispatch({\n    type: THIRD,\n    payload: sortBy(payload, iteratee)\n  });\n}\n```", "```js\nimport dispatcher from './dispatcher';\nimport { FIRST, first } from './actions/first';\nimport { SECOND, second } from './actions/second';\nimport { THIRD, third } from './actions/third';\n\n// Logs the specific action payloads as\n// they're dispatched.\ndispatcher.register((e) => {\n  switch(e.type) {\n    case FIRST:\n      console.log('first', e.payload);\n      break;\n    case SECOND:\n      console.log('second', e.payload);\n      break;\n    case THIRD:\n      console.log('third', e.payload);\n      break;\n  }\n});\n\nfirst();\n// → first [10, 20, 30]\n\nsecond();\n// → second [30, 20, 10]\n\nthird();\n// → third [30, 20, 10]\n\nthird('asc');\n// → third [10, 20, 30]\n```", "```js\nimport dispatcher from '../dispatcher';\nimport partial from 'lodash/partial';\n\n// The action identifier...\nexport const FIRST = 'FIRST';\n\n// The generic implementation of the action creator.\nexport function first(...values) {\n\n  // The payload data.\n  let defaults = [ 'a', 'b', 'c' ];\n\n  // Dispatches the \"FIRST\" action with\n  // the \"values\" array concatenated to\n  // the \"defaults\" array.\n  dispatcher.dispatch({\n    type: FIRST,\n    payload: defaults.concat(values)\n  });\n}\n\n// Exports a common version of \"first()\" with\n// the common arguments already applied.\nexport const firstCommon = partial(first, 'd', 'e', 'f');\n```", "```js\nimport dispatcher from './dispatcher';\nimport { FIRST, first, firstCommon } from './actions/first';\n\n// Logs the specific action payloads as\n// they're dispatched.\ndispatcher.register((e) => {\n  switch(e.type) {\n    case FIRST:\n      console.log('first', e.payload);\n      break;\n  }\n});\n\n// Calls the action creator with a common set\n// of arguments. This is the type of code we\n// want to avoid repeating all over the place.\nfirst('d', 'e', 'f');\n// → first [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n\n// The exact same thing as the \"fist()\" call above.\n// The common arguments have been partially-applied.\nfirstCommon();\n// → first [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n```"]