["```js\nfunction someFunction(param1, param2, param3) {\n  // do something\n  // do something else\n  // and a bit more,\n  // and finally\n  return some expression;\n}\n```", "```js\nfunction someFunction(param1, param2, param3) {\n  console.log(\n    \"entering someFunction: \",\n    param1,\n    param2,\n    param3\n  );\n  // do something\n  // do something else\n  // and a bit more,\n  // and finally\n  const auxValue = ...some expression... ;\n  console.log(\"exiting someFunction: \", auxValue);\n  return auxValue;\n}\n```", "```js\n// logging.ts\nfunction addLogging(fn) {\n  return (...args) => {\n    console.log(`entering ${fn.name}(${args})`);\n    const valueToReturn = fn(...args);\n    console.log(`exiting  ${fn.name}=>${valueToReturn}`);\n    return valueToReturn;\n  };\n}\n```", "```js\n// continued...\nfunction addLogging<T extends (...args: any[]) => any>(\n  fn: T\n): (...args: Parameters<T>) => ReturnType<T> {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    console.log(`entering ${fn.name}(${args})`);\n    const valueToReturn = fn(...args);\n    console.log(`exiting  ${fn.name} => ${valueToReturn}`);\n    return valueToReturn;\n  };\n}\n```", "```js\n// continued...\nfunction subtract(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error(\"We don't subtract zero!\");\n  } else {\n    b = changeSign(b);\n    return a + b;\n  }\n}\nlet changeSign = (a: number): number => -a;\n// @ts-expect-error We want to reassign the function\nsubtract = addLogging(subtract);\nsubtract(8, 3);\nconsole.log(); // to separate\nchangeSign = addLogging(changeSign);\nsubtract(7, 5);\n```", "```js\nentering subtract(8,3)\nexiting  subtract => 5\nentering subtract(7,5)\nentering changeSign(5)\nexiting  changeSign => -5\nexiting  subtract => 2\n```", "```js\n// continued...\nfunction addLogging2<T extends (...args: any[]) => any>(\n  fn: T\n): (...args: Parameters<T>) => ReturnType<T> {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    console.log(`entering ${fn.name}(${args})`);\n    try {\n      const valueToReturn = fn(...args);\n      console.log(`exiting  ${fn.name}=>${valueToReturn}`);\n      return valueToReturn;\n    } catch (thrownError) {\n      console.log(\n        `exiting  ${fn.name}=>threw ${thrownError}`\n      );\n      throw thrownError;\n    }\n  };\n}\n```", "```js\ntry {\n  subtract2(11, 0);\n} catch (e) {\n  /* nothing */\n}\n/*\nentering subtract(11,0)\nexiting  subtract=>threw Error: We don't subtract zero!\n*/\n```", "```js\n// logging.test.ts\nimport { addLogging2 } from \"./logging\";\ndescribe(\"a logging function\", function () {\n  afterEach(() => {\n    // so count of calls to Math.random will be OK\n    jest.restoreAllMocks();\n  });\n  it(\"should log twice with well behaved functions\", () => {\n    jest.spyOn(global.console, \"log\");\n    let something = (a: number, b: number): string =>\n      `result=${a}:${b}`;\n    something = addLogging2(something);\n    something(22, 9);\n    expect(global.console.log).toHaveBeenCalledTimes(2);\n    expect(global.console.log).toHaveBeenNthCalledWith(\n      1,\n      \"entering something(22,9)\"\n    );\n    expect(global.console.log).toHaveBeenNthCalledWith(\n      2,\n      \"exiting  something=>result=22:9\"\n    );\n  });\n  it(\"should report a thrown exception\", () => {\n    jest.spyOn(global.console, \"log\");\n    let subtractZero = (x: number) => subtract(x, 0);\n    subtractZero = addLogging2(subtractZero);\n    expect(() => subtractZero(10)).toThrow();\n    expect(global.console.log).toHaveBeenCalledTimes(2);\n    expect(global.console.log).toHaveBeenNthCalledWith(\n      1,\n      \"entering subtractZero(10)\"\n    );\n    expect(global.console.log).toHaveBeenNthCalledWith(\n      2,\n      \"exiting  subtractZero=>threw Error: We don't subtract zero!\"\n    );\n  });\n  });\n});\n```", "```js\n// logging3.ts\nfunction addLogging3<T extends (...args: any[]) => any>(\n  fn: T,\n  logger = console.log.bind(console)\n): (...args: Parameters<T>) => ReturnType<T> {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    logger(`entering ${fn.name}(${args})`);\n    try {\n      const valueToReturn = fn(...args);\n      logger(`exiting  ${fn.name}=>${valueToReturn}`);\n      return valueToReturn;\n    } catch (thrownError) {\n      logger(`exiting  ${fn.name}=>threw ${thrownError}`);\n      throw thrownError;\n    }\n  };\n}\n```", "```js\n// continued...\nfunction subtract(...) { ... }\nlet changeSign = ... ;\n// @ts-expect-error We want to reassign the function\nsubtract = addLogging3(subtract, myLogger);\nsubtract(8, 3);\nconsole.log(); // to separate\nchangeSign = addLogging3(changeSign, myLogger);\nsubtract(7, 5);\n/*\n{\"level\":\"debug\",\"message\":\"entering subtract(8,3)\"}\n{\"level\":\"debug\",\"message\":\"exiting  subtract=>5\"}\n{\"level\":\"debug\",\"message\":\"entering subtract(7,5)\"}\n{\"level\":\"debug\",\"message\":\"entering changeSign(5)\"}\n{\"level\":\"debug\",\"message\":\"exiting  changeSign=>-5\"}\n{\"level\":\"debug\",\"message\":\"exiting  subtract=>2\"}\n*/\n```", "```js\n// logging3.test.ts\nimport { addLogging3 } from \"./logging3\";\ndescribe(\"addLogging3()\", function () {\n  it(\"should call the provided logger\", () => {\n    const logger = jest.fn();\n    let something = (a: number, b: number): string =>\n      `result=${a}:${b}`;\n    something = addLogging3(something, logger);\n    something(22, 9);\n    expect(logger).toHaveBeenCalledTimes(2);\n    expect(logger).toHaveBeenNthCalledWith(\n      1,\n      \"entering something(22,9)\"\n    );\n    expect(logger).toHaveBeenNthCalledWith(\n      2,\n      \"exiting  something=>result=22:9\"\n    );\n  });\n  it(\"a throwing function should be reported\", () => {\n    const logger = jest.fn();\n    let thrower = () => {\n      throw \"CRASH!\";\n    };\n    thrower = addLogging3(thrower, logger);\n    try {\n      thrower();\n    } catch (e) {\n      expect(logger).toHaveBeenCalledTimes(2);\n      expect(logger).toHaveBeenNthCalledWith(\n        1,\n        \"entering thrower()\"\n      );\n      expect(logger).toHaveBeenNthCalledWith(\n        2,\n        \"exiting  thrower=>threw CRASH!\"\n      );\n    }\n  });\n});\n```", "```js\nconst myGet = (): number => performance.now();\nconst myPut = (\n  text: string,\n  name: string,\n  tStart: number,\n  tEnd: number\n): void =>\n  console.log(`${name} - ${text} ${tEnd - tStart} ms`);\nfunction addTiming<T extends (...args: any[]) => any>(\n  fn: T,\n  { getTime, output } = {\n    getTime: myGet,\n    output: myPut,\n  }\n): (...args: Parameters<T>) => ReturnType<T> {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    const tStart = getTime();\n    try {\n      const valueToReturn = fn(...args);\n      output(\"normal exit\", fn.name, tStart, getTime());\n      return valueToReturn;\n    } catch (thrownError) {\n      output(\"exception!!\", fn.name, tStart, getTime());\n      throw thrownError;\n    }\n  };\n}\n```", "```js\n// continued...\nfunction subtract(...) { ... }\nlet changeSign = ... ;\n// @ts-expect-error We want to reassign the function\nsubtract = addTiming(subtract, myLogger);\nsubtract(8, 3);\nconsole.log(); // to separate\nchangeSign = addTiming(changeSign, myLogger);\nsubtract(7, 5);\n/*\nsubtract - normal exit 0.0217440128326416 ms\nchangeSign - normal exit 0.0014679431915283203 ms\nsubtract - normal exit 0.0415341854095459 ms\n*/\n```", "```js\n// fibonacci.ts\nfunction fib(n: number): number {\n  if (n == 0) {\n    return 0;\n  } else if (n == 1) {\n    return 1;\n  } else {\n    return fib(n - 2) + fib(n - 1);\n  }\n}\n```", "```js\n// memoize.ts\nconst memoize = (fn) => {\n  const cache = {};\n  return (x) =>\n    x in cache ? cache[x] : (cache[x] = fn(x));\n};\n```", "```js\n// continued...\nconst memoize = <T extends (x: number) => any>(\n  fn: T\n): ((x: number) => ReturnType<T>) => {\n  const cache = {} as Record<number, ReturnType<T>>;\n  return (x) =>\n    x in cache ? cache[x] : (cache[x] = fn(x));\n};\n```", "```js\nconst testFib = (n: number) => fib(n);\naddTiming(testFib)(45); // 18,957 ms\naddTiming(testFib)(40); //  1,691 ms\naddTiming(testFib)(35); //    152 ms\n```", "```js\nconst testMemoFib = memoize((n: number) => fib(n));\naddTiming(testMemoFib)(45); // 19,401 ms\naddTiming(testMemoFib)(45); //  0.005 ms – good!\naddTiming(testMemoFib)(40); //  2,467 ms  ???\naddTiming(testMemoFib)(35); //    174 ms  ???\n```", "```js\nfib = memoize(fib);\naddTiming(testFib)(45); // 0.1481 ms\naddTiming(testFib)(45); // 0.0022 ms\naddTiming(testFib)(40); // 0.0019 ms\naddTiming(testFib)(35); // 0.0029 ms\n```", "```js\n// continued...\nconst memoize2 = <\n  T extends (x: number, ...y: any[]) => any\n>(\n  fn: T\n): ((x: number, ...y: any[]) => ReturnType<T>) => {\n  if (fn.length === 1) {\n    const cache = {} as Record<number, ReturnType<T>>;\n    return (x) =>\n      x in cache ? cache[x] : (cache[x] = fn(x));\n  } else {\n    return fn;\n  }\n};\n```", "```js\nvar a = [1, 5, 3, 8, 7, 4, 6];\nString(a); // \"1,5,3,8,7,4,6\"\nvar b = [[1, 5], [3, 8, 7, 4, 6]];\nString(b); // \"1,5,3,8,7,4,6\"\nvar c = [[1, 5, 3], [8, 7, 4, 6]];\nString(c); // \"1,5,3,8,7,4,6\"\n```", "```js\nvar d = {a: \"fk\"};\nString(d); // \"[object Object]\"\nvar e = [{p: 1, q: 3}, {p: 2, q: 6}];\nString(e); // \"[object Object],[object Object]\"\n```", "```js\nvar a = [1, 5, 3, 8, 7, 4, 6];\nJSON.stringify(a); // \"[1,5,3,8,7,4,6]\"\nvar b = [[1, 5], [3, 8, 7, 4, 6]];\nJSON.stringify(b); // \"[[1,5],[3,8,7,4,6]]\"\nvar c = [[1, 5, 3], [8, 7, 4, 6]];\nJSON.stringify(c); // \"[[1,5,3],[8,7,4,6]]\"\nvar d = {a: \"fk\"}; JSON.stringify(d); // \"{\"a\":\"fk\"}\"\nvar e = [{p: 1, q: 3}, {p: 2, q: 6}];\nJSON.stringify(e); // \"[{\"p\":1,\"q\":3},{\"p\":2,\"q\":6}]\"\n```", "```js\n// continued...\nconst memoize3 = <T extends (...x: any[]) => any>(\n  fn: T\n): ((...x: Parameters<T>) => ReturnType<T>) => {\n  const cache = {} as Record<\n    number | string,\n    ReturnType<T>\n  >;\n  const PRIMITIVES = [\"number\", \"string\"];\n  return (...args) => {\n    const strX: number | string =\n      args.length === 1 &&\n      PRIMITIVES.includes(typeof args[0])\n        ? args[0]\n        : JSON.stringify(args);\n    return strX in cache\n      ? cache[strX]\n      : (cache[strX] = fn(...args));\n  };\n};\n```", "```js\n// continued...\nconst memoize4 = <T extends (...x: any[]) => any>(\n  fn: T\n): ((...x: Parameters<T>) => ReturnType<T>) => {\n  const cache = {} as Record<string, ReturnType<T>>;\n  return (...args) => {\n    const strX = JSON.stringify(args);\n    return strX in cache\n      ? cache[strX]\n      : (cache[strX] = fn(...args));\n  };\n};\n```", "```js\n// memoize.test.ts\nimport { fib } from \"./fibonacci\";\nimport * as moduleFib from \"./fibonacci\";\ndescribe(\"the original fib\", function () {\n  it(\"should repeat calculations\", () => {\n    jest.spyOn(moduleFib, \"fib\");\n    expect(fib(6)).toBe(8);\n    expect(fib).toHaveBeenCalledTimes(25);\n  });\n});\n```", "```js\n// continued...\ndescribe(\"the modified fib\", function () {\n  it(\"should repeat calculations\", () => {\n    let count = 0;\n    const fibM = (n: number): number => {\n      count++;\n      if (n == 0) {\n        return 0;\n      } else if (n == 1) {\n        return 1;\n      } else {\n        return fibM(n - 2) + fibM(n - 1);\n      }\n    };\n    expect(fibM(6)).toBe(8);\n    expect(count).toBe(25);\n  });\n});\n```", "```js\n// continued...\ndescribe(\"the memoized, modified fib\", function () {\n  it(\"should repeat calculations\", () => {\n    let count = 0;\n    const fibMM = memoize((n: number): number => {\n      count++;\n      if (n == 0) {\n        return 0;\n      } else if (n == 1) {\n        return 1;\n      } else {\n        return fibMM(n - 2) + fibMM(n - 1);\n      }\n    });\n    expect(fibMM(6)).toBe(8);\n    expect(count).toBe(7);\n  });\n```", "```js\n// memoize.ts\nconst promiseMemoize = <\n  A,\n  T extends (...x: any[]) => Promise<A>\n>(\n  fn: T\n): ((...x: Parameters<T>) => Promise<A>) => {\n  const cache = {} as Record<string, Promise<A>>;\n  return (...args) => {\n    const strX = JSON.stringify(args);\n    return strX in cache\n      ? cache[strX]\n      : (cache[strX] = fn(...args).catch((x) => {\n          delete cache[strX];\n          return x;\n        }));\n  };\n};\n```", "```js\n// once.ts\nfunction once<T extends (...args: any[]) => void>(\n  f: T\n): (...args: Parameters<T>) => void {\n  let done = false;\n  return ((...args: Parameters<T>) => {\n    if (!done) {\n      done = true;\n      f(...args);\n    }\n  }) as T;\n}\n```", "```js\n// continued...\nfunction once2<T extends (...args: any[]) => any>(\n  f: T\n): (...args: Parameters<T>) => ReturnType<T> {\n  let done = false;\n  let result: ReturnType<T>;\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    if (!done) {\n      done = true;\n      result = f(...args);\n    }\n    return result;\n  }) as T;\n}\n```", "```js\n// continued...\nfunction onceAndAfter<T extends (...args: any[]) => any>(\n  f: T,\n  g: T\n): (...args: Parameters<T>) => ReturnType<T> {\n  let done = false;\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    if (!done) {\n      done = true;\n      return f(...args);\n    } else {\n      return g(...args);\n    }\n  }) as T;\n}\n```", "```js\n// continued...\nfunction onceAndAfter2<T extends (...args: any[]) => any>(\n  f: T,\n  g: T\n): (...args: Parameters<T>) => ReturnType<T> {\n  let toCall = f;\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    let result = toCall(...args);\n    toCall = g;\n    return result;\n  }) as T;\n}\n```", "```js\nconst squeak = (x: string) => console.log(x, \"squeak!!\");\nconst creak = (x: string) => console.log(x, \"creak!!\");\nconst makeSound = onceAndAfter2(squeak, creak);\nmakeSound(\"door\"); // \"door squeak!!\"\nmakeSound(\"door\"); // \"door creak!!\"\nmakeSound(\"door\"); // \"door creak!!\"\nmakeSound(\"door\"); // \"door creak!!\"\n```", "```js\n// not.ts\nconst delinquent = serviceResult.accountsData.filter(\n  (v) => v.balance < 0\n);\n```", "```js\n// continued...\nconst notDelinquent = serviceResult.accountsData.filter(\n  (v) => v.balance >= 0\n);\nconst notDelinquent2 = serviceResult.accountsData.filter(\n  (v) => !(v.balance < 0)\n);\n```", "```js\n// continued...\nconst isNegativeBalance = (v: AccountData) => v.balance < 0;\n.\n. many lines later\n.\nconst delinquent2 = serviceResult.accountsData.filter(\n  isNegativeBalance\n);\n```", "```js\n// continued...\nconst not = (fn) => (...args) => !fn(...args);\n```", "```js\n// continued...\nconst notDelinquent3 = serviceResult.accountsData.filter(\n  not(isNegativeBalance)\n);\n```", "```js\n// continued...\nconst filterNot =\n  <A, T extends (x: A) => boolean>(arr: A[]) =>\n  (fn: T): A[] =>\n    arr.filter(not((y) => fn(y)));\n```", "```js\nconst spanishComparison = (a: string, b: string) =>\n  a.localeCompare(b, \"es\");\npalabras.sort(spanishComparison);\n// sorts the array according to Spanish rules\n```", "```js\n// invert.ts\nconst invert = (fn) => (...args) => -fn(...args);\n```", "```js\nconst spanishComparison = (a: string, b: string): number =>\n  a.localeCompare(b, \"es\");\nconst palabras = [\n  \"ñandú\",\n  \"oasis\",\n  \"mano\",\n  \"natural\",\n  \"mítico\",\n  \"musical\",\n];\npalabras.sort(spanishComparison);\n// \"mano\", \"mítico\", \"musical\", \"natural\", \"ñandú\", \"oasis\"\npalabras.sort(invert(spanishComparison));\n// \"oasis\", \"ñandú\", \"natural\", \"musical\", \"mítico\", \"mano\"\n```", "```js\n[\"123.45\", \"-67.8\", \"90\"].map(parseInt);\n// [123, NaN, NaN]\n```", "```js\nconst unary = fn => (...args) => fn(args[0]);\n```", "```js\n// arity.ts\nconst unary =\n  <T extends (...x: any[]) => any>(\n    fn: T\n  ): ((arg: Parameters<T>[0]) => ReturnType<T>) =>\n(x) => fn(x);\n```", "```js\n[\"123.45\", \"-67.8\", \"90\"].map(unary(parseInt));\n// [123, -67, 90]\n```", "```js\n// continued...\nconst binary = fn => (...a) => fn(a[0], a[1]);\nconst ternary = fn => (...a) => fn(a[0], a[1], a[2]);\n```", "```js\n// continued...\nconst arity = (n, fn) => (...a) => fn(...a.slice(0, n));\n```", "```js\nconst unary = fn => arity(1, fn);\nconst binary = fn => arity(2, fn);\nconst ternary = fn => arity(3, fn);\n```", "```js\n// debounce.ts\nconst debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  delay = 1000\n) => {\n  let timer: ReturnType<typeof setTimeout>;\n  return (...args: Parameters<T>): void => {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn(...args), timeDelay);\n  };\n};\n```", "```js\n// throttle.ts\nconst throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  delay = 1000\n) => {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return (...args: Parameters<T>): void => {\n    if (!timer) {\n      timer = setTimeout(() => {\n        timer = undefined;\n      }, delay);\n      fn(...args);\n    }\n  };\n};\n```", "```js\nconst mySum = myArray.reduce(\n  (x: number, y: number): number => x + y,\n  0\n);\n```", "```js\nconst factorialByRange = (n: number): number =>\n  range(1, n + 1).reduce((x, y) => x * y, 1);\n```", "```js\nconst mySum = myArray.reduce(binaryOp2(\"+\"), 0);\nconst factorialByRange = (n: number): number =>\n  range(1, n + 1).reduce(binaryOp2(\"*\"), 1);\n```", "```js\n// binaryOp.ts\nconst binaryOp1 = (op: string) => {\n  switch (op) {\n    case \"+\":\n      return (x: number, y: number): number => x + y;\n    case \"-\":\n      return (x: number, y: number): number => x - y;\n    case \"*\":\n      return (x: number, y: number): number => x * y;\n    //\n    // etc.\n    //\n    default:\n      throw new Error(`Unknown ${op} operator`);\n  }\n};\n```", "```js\n// continued...\nconst binaryOp2 = (op) =>\n  new Function(\"x\", \"y\", `return x ${op} y;`);\n```", "```js\n// continued...\nconst binaryOp2 = (op: string) =>\n  new Function(\"x\", \"y\", `return x ${op} y;`) as (\n    x: number,\n    y: number\n  ) => number;\n```", "```js\nconst isNegative = curry(binaryOp2(\">\"))(0);\n```", "```js\n// continued...\nconst binaryLeftOp =\n  (x: number, op: string) => (y: number) =>\n    binaryOp2(op)(x, y);\nconst binaryOpRight =\n  (op: string, y: number) => (x: number) =>\n    binaryOp2(op)(x, y);\n```", "```js\nconst isNegative1 = binaryLeftOp(0, \">\");\nconst isNegative2 = binaryOpRight(\"<\", 0);\n```", "```js\nconst isNegative3 = (x: number): boolean => x < 0;\n```", "```js\n// promisify.ts\nconst promisify =\n  <E, T extends any[], D>(\n    fn: (...args: [...T, (err: E, data: D) => void]) => void\n  ) =>\n  (...args: T): Promise<D> =>\n    new Promise((resolve, reject) =>\n      fn(...args, (err: E, data: D) =>\n        err ? reject(err) : resolve(data)\n      )\n    );\n```", "```js\nconst fs = require(\"fs\");\nconst cb = (err, data) =>\n  err\n    ? console.log(\"ERROR\", err)\n    : console.log(\"SUCCESS\", data);\nfs.readFile(\"./exists.txt\", cb);       // success, data\nfs.readFile(\"./doesnt_exist.txt\", cb); // fail, exception\n```", "```js\nconst fspromise = promisify(fs.readFile.bind(fs));\nconst goodRead = (data) =>\n  console.log(\"SUCCESSFUL PROMISE\", data);\nconst badRead = (err) =>\n  console.log(\"UNSUCCESSFUL PROMISE\", err);\nfspromise(\"./readme.txt\")    // success\n  .then(goodRead)\n  .catch(badRead);\nfspromise(\"./readmenot.txt\") // failure\n  .then(goodRead)\n  .catch(badRead);\n```", "```js\n// getField.ts\nconst markers = [\n  { name: \"UY\", lat: -34.9, lon: -56.2 },\n  { name: \"AR\", lat: -34.6, lon: -58.4 },\n  { name: \"BR\", lat: -15.8, lon: -47.9 },\n  // ...\n  { name: \"BO\", lat: -16.5, lon: -68.1 },\n];\nlet averageLat = average(markers.map(x => x.lat));\nlet averageLon = average(markers.map(x => x.lon));\n```", "```js\nconst delinquent = serviceResult.accountsData.filter(\n  (v) => v.balance < 0\n);\nconst delinquentIds = delinquent.map((v) => v.id);\n```", "```js\n// getField.ts\nconst getField = f => obj => obj[f];\n```", "```js\n// continued...\nconst getField = <D>(f: keyof D) => (obj: D) => obj[f];\n```", "```js\nlet averageLat = average(markers.map(getField(\"lat\")));\nlet averageLon = average(markers.map(getField(\"lon\")));\n```", "```js\ntype NumFn = (...args: any[]) => number;\nconst averageLat2 = average(\n  markers.map(getField(\"lat\") as NumFn)\n);\nconst averageLon2 = average(\n  markers.map(getField(\"lon\") as NumFn)\n);\n```", "```js\nconst getId = getField(\"id\") as (...args: any[]) => string;\nconst delinquent = serviceResult.accountsData.filter(\n  (v) => v.balance < 0\n);\nconst delinquentIds = delinquent.map(getId);\n```", "```js\n// demethodize.ts\nconst demethodize1 =\n  (fn) =>\n  (arg0, ...args) =>\n    fn.apply(arg0, args);\nconst demethodize2 =\n  (fn) =>\n  (arg0, ...args) =>\n    fn.call(arg0, ...args);\nconst demethodize3 =\n  (fn) =>\n  (arg0, ...args) =>\n    fn.bind(arg0, ...args)();\n```", "```js\nconst sort = demethodize1(Array.prototype.sort);\nconst a = [\"delta\", \"alfa\", \"beta\", \"gamma\", \"epsilon\"];\nconst b = sort(a);\nconsole.log(a, b);\n// [ 'alfa', 'beta', 'delta', 'epsilon', 'gamma' ] twice!\n```", "```js\nconst name = \"FUNCTIONAL\";\nconst result = name.split(\"\").map((x) => x.toUpperCase());\n// [\"F\", \"U\", \"N\", \"C\", \"T\", \"I\", \"O\", \"N\", \"A\", \"L\"]\n```", "```js\nconst map = demethodize1(Array.prototype.map);\nconst toUpperCase = demethodize2(\n  String.prototype.toUpperCase\n);\nconst result2 = map(name, toUpperCase);\n// [\"F\", \"U\", \"N\", \"C\", \"T\", \"I\", \"O\", \"N\", \"A\", \"L\"]\n```", "```js\nconst toLocaleString = demethodize3(\n  Number.prototype.toLocaleString\n);\nconst numbers = [2209.6, 124.56, 1048576];\nconst strings = numbers.map(toLocaleString);\nconsole.log(strings);\n/*\n[ '2.209,6', '124,56', '1.048.576' ] // Uruguay Locale\n*/\n```", "```js\n\"ABCDE\".reverse();     // \"EDCBA\"\n\"ABCDE\".reverse(true); // \"E-D-C-B-A\"\n```", "```js\n// methodize.ts\nfunction reverse(x: string, y = false): string {\n  return x\n    .split(\"\")\n    .reverse()\n    .join(y ? \"-\" : \"\");\n}\n```", "```js\n// continued...\ndeclare global {\n  interface String {\n    reverse(y?: boolean): string;\n  }\n}\n```", "```js\n// continued...\nString.prototype.reverse = function (\n  this: string,\n  y\n): string {\n  return reverse(this, y);\n};\n```", "```js\n// continued...\nfunction methodize(obj, fn) {\n  obj.prototype[fn.name] = function (...args) {\n    return fn(this, ...args);\n  };\n}\n```", "```js\nfunction methodize<\n  T extends any[],\n  O extends { prototype: { [key: string]: any } },\n  F extends (arg0: any, ...args: T) => any\n>(obj: O, fn: F) {\n  obj.prototype[fn.name] = function (\n    this: Parameters<F>[0],\n    ...args: T\n  ): ReturnType<F> {\n    return fn(this, ...args);\n  };\n}\n```", "```js\nmethodize(String, reverse);\n```", "```js\nconsole.log(\"MONTEVIDEO\".reverse());\n// OEDIVETNOM\nconsole.log(\"MONTEVIDEO\".reverse(true));\n// O-E-D-I-V-E-T-N-O-M\n```", "```js\n// continued...\nfunction average(x: number[]): number {\n  return (\n    x.reduce((x: number, y: number) => x + y, 0) / x.length\n  );\n}\n```", "```js\nconst xx = [\"FK\", \"ST\", \"JA\", \"MV\"].average();\n```", "```js\n// methodize.ts\ndeclare global {\n  // eslint-disable @typescript-eslint/no-unused-vars\n interface Array<T> {\n    average(): number;\n  }\n}\n```", "```js\nmethodize(Array, average);\nconst myAvg = [22, 9, 60, 12, 4, 56].average(); // 27.166667\n```", "```js\n// optimum.ts\nconst findOptimum = (arr: number[]): number =>\n  Math.max(...arr);\nconst myArray = [22, 9, 60, 12, 4, 56];\nconsole.log(findOptimum(myArray)); // 60\n```", "```js\n// continued...\nconst findOptimum2 =\n  <T>(fn: (x: T, y: T) => T) =>\n  (arr: T[]): T =>\n    arr.reduce(fn);\n```", "```js\nconst findMaximum = findOptimum2(\n  (x: number, y: number): number => (x > y ? x : y)\n);\nconst findMinimum = findOptimum2(\n  (x: number, y: number): number => (x < y ? x : y)\n);\nconsole.log(findMaximum(myArray)); // 60\nconsole.log(findMinimum(myArray)); // 4\n```", "```js\nclass Card {\n  name: string;\n  strength: number;\n  powers: number;\n  tech: number;\n  constructor(n: string, s: number, p: number, t: number) {\n    this.name = n;\n    this.strength = s;\n    this.powers = p;\n    this.tech = t;\n  }\n}\n```", "```js\nconst compareHeroes = (card1: Card, card2: Card): Card => {\n  const oneIfBigger = (x: number, y: number): number =>\n    x > y ? 1 : 0;\n  const wins1 =\n    oneIfBigger(card1.strength, card2.strength) +\n    oneIfBigger(card1.powers, card2.powers) +\n    oneIfBigger(card1.tech, card2.tech);\n  const wins2 =\n    oneIfBigger(card2.strength, card1.strength) +\n    oneIfBigger(card2.powers, card1.powers) +\n    oneIfBigger(card2.tech, card1.tech);\n  return wins1 > wins2 ? card1 : card2;\n};\n```", "```js\nconst codingLeagueOfAmerica = [\n  new Card(\"Forceful\", 20, 15, 2),\n  new Card(\"Electrico\", 12, 21, 8),\n  new Card(\"Speediest\", 8, 11, 4),\n  new Card(\"TechWiz\", 6, 16, 30),\n];\n```", "```js\nconst findBestHero = findOptimum2(compareHeroes);\nconsole.log(findBestHero(codingLeagueOfAmerica));\n// Electrico is the top Card!\n```", "```js\nconst filterNot2 =\n  <A, T extends (x: A) => boolean>(arr: A[]) =>\n  (fn: T): A[] =>\n    arr.filter(not(fn));\n```"]